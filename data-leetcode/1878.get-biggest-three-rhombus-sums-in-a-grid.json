[
    {
        "title": "Substrings of Size Three with Distinct Characters",
        "question_content": "A string is good if there are no repeated characters.\nGiven a string s​​​​​, return the number of good substrings of length three in s​​​​​​.\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\nA substring is a contiguous sequence of characters in a string.\n&nbsp;\nExample 1:\n\nInput: s = \"xyzzaz\"\nOutput: 1\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".\n\nExample 2:\n\nInput: s = \"aababcabc\"\nOutput: 4\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts​​​​​​ consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1238665,
                "title": "easy-solution-o-n-approach",
                "content": "Here we are using sliding window technique with a window size of 3\\nWith every iteration new element is pushed into the window and the last element of window is pushed out.\\nWith in every window we check if there is any repetition of elements using if loop\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)return 0;\\n        char a=s[0],b=s[1],c=s[2];\\n        int res=0;\\n        for(int i=3;i<=s.size()-1;i++)\\n        {\\n            if(a!=b and b!=c and c!=a)res++;\\n            a=b;\\n            b=c;\\n            c=s[i];\\n        }\\n        if(a!=b and b!=c and c!=a)res++;\\n        return res;\\n    }\\n};\\n```\\n**Do upvote and keep supporting..!**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)return 0;\\n        char a=s[0],b=s[1],c=s[2];\\n        int res=0;\\n        for(int i=3;i<=s.size()-1;i++)\\n        {\\n            if(a!=b and b!=c and c!=a)res++;\\n            a=b;\\n            b=c;\\n            c=s[i];\\n        }\\n        if(a!=b and b!=c and c!=a)res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399854,
                "title": "c-never-under-estimate-an-easy-qn-it-can-teach-you-many-things",
                "content": "```\\n//Approach-1 (That comes to your mind in one go)\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        if(s.length() < 3) return 0;\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using siding window - It can be used to solve the generalized version of the question ( k sized substring))\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        int dup   = 0;\\n        if(s.length() < 3) return 0;\\n        int mp[26] = {0};\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            mp[s[i]-\\'a\\']++;\\n            \\n            if(mp[s[i]-\\'a\\'] == 2)\\n                dup++;\\n            \\n            if(i < 2) continue;\\n            \\n            if(dup == 0) count++;\\n            \\n            //now shift right (so, (i-2)th character\\'s frequency in current window is decreased)\\n            mp[s[i-2]-\\'a\\']--;\\n            \\n            if(mp[s[i-2]-\\'a\\'] == 1) //it means it had increased dup (dup++)\\n                dup--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (That comes to your mind in one go)\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        if(s.length() < 3) return 0;\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using siding window - It can be used to solve the generalized version of the question ( k sized substring))\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        int dup   = 0;\\n        if(s.length() < 3) return 0;\\n        int mp[26] = {0};\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            mp[s[i]-\\'a\\']++;\\n            \\n            if(mp[s[i]-\\'a\\'] == 2)\\n                dup++;\\n            \\n            if(i < 2) continue;\\n            \\n            if(dup == 0) count++;\\n            \\n            //now shift right (so, (i-2)th character\\'s frequency in current window is decreased)\\n            mp[s[i-2]-\\'a\\']--;\\n            \\n            if(mp[s[i-2]-\\'a\\'] == 1) //it means it had increased dup (dup++)\\n                dup--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485329,
                "title": "classic-sliding-window-beats-100-beginner-friendly-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t/* \\n\\t * This is classic sliding window problem with fixed window length 3 here \\n\\t * we will always maintain the window len 3(fixed length)  by adjusting i and j \\n\\t * in all similar problems\\n\\t */\\n        /* i is LHS of the window */\\n        int i = 0;\\n       /* j is RHS of window */\\n        int j = 0;\\n        int n = s.size();\\n\\t\\t\\n\\t\\t/* Map to keep track of occurance of each char */\\n        unordered_map<char, int>mp;\\n\\t\\t\\n\\t\\t/* Variable keeping track of answer/result */\\n        int ans = 0;\\n        \\n        while (i < n && j < n) {\\n            /* Increment the count in map each time you iterate through any character */\\n            mp[s[j]]++;\\n            \\n           \\n            if (j - i + 1 < 3) {\\n            /* Case 1:\\n             *  Keep incrementing the RHS till you  make substring of exactly length 3(fixed length). \\n             */\\n                j++;\\n            } else if (mp.size() == 3) {\\n              /* Case 2: \\n\\t\\t\\t   * If the map size is exact 3 we have found the sub string with 3 unique \\n               * chars(here window len 3 we are mainting always) ,\\n\\t\\t\\t   * increment the answer, Also shift the LHS and RHS of the current window for which result is calulated\\n\\t\\t\\t   * and remove the entry from map for the LHS(Note the RHS will still be part of new shifted window).\\n\\t\\t\\t   */\\n                ans++;\\n                mp.erase(s[i]);\\n                i++;\\n                j++;\\n            } else {\\n               /*\\n\\t\\t\\t    * Case 3: \\n\\t\\t\\t    * If map size is not equal to 3 (sliding window len here will always be 3)then we surely have some\\n\\t\\t\\t    * repeating chars so we need to slide the window again.\\n\\t\\t\\t    * For LHS Decrement the count from map and if its zero then erase it as we are using \\n\\t\\t\\t    * size of map to calucate number of unique elements present(Note the RHS will  still be part of new shifted window) \\n\\t\\t\\t    */\\n                mp[s[i]]--;\\n                if (mp[s[i]] == 0) {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\nIts my first post, please upvote if you find this helpful :)",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t/* \\n\\t * This is classic sliding window problem with fixed window length 3 here \\n\\t * we will always maintain the window len 3(fixed length)  by adjusting i and j \\n\\t * in all similar problems\\n\\t */\\n        /* i is LHS of the window */\\n        int i = 0;\\n       /* j is RHS of window */\\n        int j = 0;\\n        int n = s.size();\\n\\t\\t\\n\\t\\t/* Map to keep track of occurance of each char */\\n        unordered_map<char, int>mp;\\n\\t\\t\\n\\t\\t/* Variable keeping track of answer/result */\\n        int ans = 0;\\n        \\n        while (i < n && j < n) {\\n            /* Increment the count in map each time you iterate through any character */\\n            mp[s[j]]++;\\n            \\n           \\n            if (j - i + 1 < 3) {\\n            /* Case 1:\\n             *  Keep incrementing the RHS till you  make substring of exactly length 3(fixed length). \\n             */\\n                j++;\\n            } else if (mp.size() == 3) {\\n              /* Case 2: \\n\\t\\t\\t   * If the map size is exact 3 we have found the sub string with 3 unique \\n               * chars(here window len 3 we are mainting always) ,\\n\\t\\t\\t   * increment the answer, Also shift the LHS and RHS of the current window for which result is calulated\\n\\t\\t\\t   * and remove the entry from map for the LHS(Note the RHS will still be part of new shifted window).\\n\\t\\t\\t   */\\n                ans++;\\n                mp.erase(s[i]);\\n                i++;\\n                j++;\\n            } else {\\n               /*\\n\\t\\t\\t    * Case 3: \\n\\t\\t\\t    * If map size is not equal to 3 (sliding window len here will always be 3)then we surely have some\\n\\t\\t\\t    * repeating chars so we need to slide the window again.\\n\\t\\t\\t    * For LHS Decrement the count from map and if its zero then erase it as we are using \\n\\t\\t\\t    * size of map to calucate number of unique elements present(Note the RHS will  still be part of new shifted window) \\n\\t\\t\\t    */\\n                mp[s[i]]--;\\n                if (mp[s[i]] == 0) {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238721,
                "title": "java-5-liner-o-n",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n\\tint result = 0;\\n\\tfor(int i=1;i<s.length()-1;i++)\\n\\t\\tif(s.charAt(i-1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i-1))\\n\\t\\t\\tresult++;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n\\tint result = 0;\\n\\tfor(int i=1;i<s.length()-1;i++)\\n\\t\\tif(s.charAt(i-1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i-1))\\n\\t\\t\\tresult++;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240095,
                "title": "python-3-simple-and-linear-time",
                "content": "Iterative over string and increase the counter if all characters of length 3 string are different.\\n\\n```\\n def countGoodSubstrings(self, s: str) -> int:\\n        ans=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def countGoodSubstrings(self, s: str) -> int:\\n        ans=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                ans+=1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238687,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = s.charAt(i + 1);\\n            char c3 = s.charAt(i + 2);\\n            if(c1 == c2 || c2 == c3 || c1 == c3) continue;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = s.charAt(i + 1);\\n            char c3 = s.charAt(i + 2);\\n            if(c1 == c2 || c2 == c3 || c1 == c3) continue;\\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238676,
                "title": "sliding-window",
                "content": "A standard approach to count repeated characters in a sliding window.\\n\\n**C++**\\n```cpp\\nint countGoodSubstrings(string s) {\\n    int cnt[123] = {}, repeat = 0, res = 0;\\n    for(int i = 0; i < s.size(); ++i) {\\n        repeat += cnt[s[i]]++ == 1;\\n        repeat -= i >= 3 && cnt[s[i - 3]]-- == 2;\\n        res += i >= 2 && repeat == 0;\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int countGoodSubstrings(String s) {\\n    int cnt[] = new int[123], repeat = 0, res = 0;\\n    for(int i = 0; i < s.length(); ++i) {\\n        repeat += cnt[s.charAt(i)]++ == 1 ? 1 : 0;\\n        repeat -= i >= 3 && cnt[s.charAt(i - 3)]-- == 2 ? 1 : 0;\\n        res += i >= 2 && repeat == 0 ? 1 : 0;\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint countGoodSubstrings(string s) {\\n    int cnt[123] = {}, repeat = 0, res = 0;\\n    for(int i = 0; i < s.size(); ++i) {\\n        repeat += cnt[s[i]]++ == 1;\\n        repeat -= i >= 3 && cnt[s[i - 3]]-- == 2;\\n        res += i >= 2 && repeat == 0;\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int countGoodSubstrings(String s) {\\n    int cnt[] = new int[123], repeat = 0, res = 0;\\n    for(int i = 0; i < s.length(); ++i) {\\n        repeat += cnt[s.charAt(i)]++ == 1 ? 1 : 0;\\n        repeat -= i >= 3 && cnt[s.charAt(i - 3)]-- == 2 ? 1 : 0;\\n        res += i >= 2 && repeat == 0 ? 1 : 0;\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429825,
                "title": "java-simple-o-n-100",
                "content": "if you like it pls upvote\\n\\nJava\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int res = 0;\\n        \\n        for(int i = 2 ; i< s.length();i++)\\n            if(s.charAt(i) != s.charAt(i-1) && s.charAt(i) != s.charAt(i-2)  && s.charAt(i-1) != s.charAt(i-2))\\n                res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int res = 0;\\n        \\n        for(int i = 2 ; i< s.length();i++)\\n            if(s.charAt(i) != s.charAt(i-1) && s.charAt(i) != s.charAt(i-2)  && s.charAt(i-1) != s.charAt(i-2))\\n                res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904752,
                "title": "sliding-window-simplest-approach-c",
                "content": "**AN UPVOTE WOUULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0;int j=0;\\n        map<char,int> ans;\\n        int a=0;\\n        while(j<s.size()){\\n            ans[s[j]]++;\\n            if(j-i+1<3) {j++;}\\n            else if(j-i+1==3){\\n                if(ans.size()==3) a++;\\n                if(ans[s[i]]==1) ans.erase(s[i]);\\n                else ans[s[i]]--;\\n                i++;j++;}\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0;int j=0;\\n        map<char,int> ans;\\n        int a=0;\\n        while(j<s.size()){\\n            ans[s[j]]++;\\n            if(j-i+1<3) {j++;}\\n            else if(j-i+1==3){\\n                if(ans.size()==3) a++;\\n                if(ans[s[i]]==1) ans.erase(s[i]);\\n                else ans[s[i]]--;\\n                i++;j++;}\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356591,
                "title": "easy-python-solution-98-80",
                "content": "Runtime: 24 ms, faster than 98.80% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 14.3 MB, less than 42.54% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\\n                count+=1\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 24 ms, faster than 98.80% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 14.3 MB, less than 42.54% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\\n                count+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1238685,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt=0,n=s.size();\\n        unordered_map<char,int> map;\\n        for(int i=0;i<n;i++){\\n            if(i>2 and --map[s[i-3]] == 0) map.erase(s[i-3]);\\n            map[s[i]]++;\\n            if(map.size() == 3) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt=0,n=s.size();\\n        unordered_map<char,int> map;\\n        for(int i=0;i<n;i++){\\n            if(i>2 and --map[s[i-3]] == 0) map.erase(s[i-3]);\\n            map[s[i]]++;\\n            if(map.size() == 3) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455895,
                "title": "easy-and-well-explained-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //we can solve this problem by using sliding window technique\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0; //k is the size of window\\n        int count=0,n = s.length();\\n        map<char,int>mp; //we create map to store the frequency of each character \\n        while(j<n){\\n            mp[s[j]]++; //push the element into map\\n            if(j-i+1 < k){ //since we want length of substring three so till that point we will just add character\\n                j++;\\n            }else{\\n                if(mp.size() == 3){ //we check that all three entries are unique or not..\\n                    count++;\\n                }\\n                mp[s[i]]--; //this is the step where we slide our window\\n                if(mp[s[i]] == 0){ //if at any step our frquency of that character becomes zero then we have to remove it from our map\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++; //to slide our window we move our both pointers\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we can solve this problem by using sliding window technique\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0; //k is the size of window\\n        int count=0,n = s.length();\\n        map<char,int>mp; //we create map to store the frequency of each character \\n        while(j<n){\\n            mp[s[j]]++; //push the element into map\\n            if(j-i+1 < k){ //since we want length of substring three so till that point we will just add character\\n                j++;\\n            }else{\\n                if(mp.size() == 3){ //we check that all three entries are unique or not..\\n                    count++;\\n                }\\n                mp[s[i]]--; //this is the step where we slide our window\\n                if(mp[s[i]] == 0){ //if at any step our frquency of that character becomes zero then we have to remove it from our map\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++; //to slide our window we move our both pointers\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155417,
                "title": "java-beats-90-sliding-window-with-detailed-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/b6852eab-4964-47ac-9e70-d7996cd86176_1675767633.4297187.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem is being approached by Sliding Windows Algorithm. We take two pointers for determining the window and then checking our condition of uniqueness.\\n\\n![WhatsApp Image 2023-02-07 at 4.28.52 PM.jpeg](https://assets.leetcode.com/users/images/ed778d99-d6d2-4a5b-9c35-00443b1aebbb_1675767797.020403.jpeg)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0, j=0, count=0;\\n        while(j<s.length()){\\n            if(j-i+1==3){\\n                if(s.charAt(i) != s.charAt(i+1) && s.charAt(i+1) != s.charAt(i+2) \\n                && s.charAt(i+2) != s.charAt(i)){\\n                    count++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# Do give this solution an Upvote if you find it helpful:)\\n![emojipng.com-12080000.png](https://assets.leetcode.com/users/images/8ecfc048-081b-4b5d-8acb-277a9d817b57_1675768050.9240546.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0, j=0, count=0;\\n        while(j<s.length()){\\n            if(j-i+1==3){\\n                if(s.charAt(i) != s.charAt(i+1) && s.charAt(i+1) != s.charAt(i+2) \\n                && s.charAt(i+2) != s.charAt(i)){\\n                    count++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458854,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 3971421,
                "title": "java-10000-beats-0-n-2-solution-hashset-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n           if(s.length()<=2) return 0;\\n           int ans = 0;   //  Please UPVOTE ME....\\n           for(int i=0; i<s.length()-2; i++){\\n               if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)) ans++;\\n           }\\n           return ans;\\n\\n\\n//                   Another solution (Using HashSet<>) --> try this one\\n\\n        // char temp[] = s.toCharArray();\\n        // int count = 0 , low = 0 , ans = 0 , i = 0;\\n        // Set<Character> set = new HashSet<>();\\n        // if(temp.length<=2) return 0;\\n        // while(low!=temp.length-2){\\n        //        set.add(temp[i]); i++; count++;\\n        //        if(count==3){\\n        //            if(set.size()==3){\\n        //                ans++; count = 0;\\n        //            }else  count = 0;\\n        //            low++; set.clear(); i = low;\\n        //        }\\n        // }\\n        // return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n           if(s.length()<=2) return 0;\\n           int ans = 0;   //  Please UPVOTE ME....\\n           for(int i=0; i<s.length()-2; i++){\\n               if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)) ans++;\\n           }\\n           return ans;\\n\\n\\n//                   Another solution (Using HashSet<>) --> try this one\\n\\n        // char temp[] = s.toCharArray();\\n        // int count = 0 , low = 0 , ans = 0 , i = 0;\\n        // Set<Character> set = new HashSet<>();\\n        // if(temp.length<=2) return 0;\\n        // while(low!=temp.length-2){\\n        //        set.add(temp[i]); i++; count++;\\n        //        if(count==3){\\n        //            if(set.size()==3){\\n        //                ans++; count = 0;\\n        //            }else  count = 0;\\n        //            low++; set.clear(); i = low;\\n        //        }\\n        // }\\n        // return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238647,
                "title": "clean-python-3-straightforward",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3: return 0 # it still can work if we remove this line (credit to @Silvia42)\\n        return sum(s[i] != s[i-1] != s[i-2] != s[i] for i in range(2, len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3: return 0 # it still can work if we remove this line (credit to @Silvia42)\\n        return sum(s[i] != s[i-1] != s[i-2] != s[i] for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314718,
                "title": "java-easy-solution-sliding-window",
                "content": "//please ask if have any doubt\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,count=0;\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        while(j<s.length())\\n        {\\n            map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }else if(j-i+1==3)\\n            {\\n                if(map.size()==3)\\n                {\\n                    count++;\\n                    //System.out.println(map);\\n                }\\n                int val=map.get(s.charAt(i));\\n                val=val-1;\\n                if(val==0){\\n                    map.remove(s.charAt(i));\\n                }else{\\n                    map.put(s.charAt(i),val);\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,count=0;\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        while(j<s.length())\\n        {\\n            map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }else if(j-i+1==3)\\n            {\\n                if(map.size()==3)\\n                {\\n                    count++;\\n                    //System.out.println(map);\\n                }\\n                int val=map.get(s.charAt(i));\\n                val=val-1;\\n                if(val==0){\\n                    map.remove(s.charAt(i));\\n                }else{\\n                    map.put(s.charAt(i),val);\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108020,
                "title": "aditya-verma-approach-sliding-window-with-fixed-size-window",
                "content": "# Intuition\\nSliding window with fixed size window.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;\\n        int i=0,j=0,n=s.length(),k=3;\\n        unordered_map<char,int>mp;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                    ans++;\\n                }\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;\\n        int i=0,j=0,n=s.length(),k=3;\\n        unordered_map<char,int>mp;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                    ans++;\\n                }\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803519,
                "title": "java-hashset-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        Set<Character> set;\\n\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            set = new HashSet<>();\\n\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i + 1));\\n            set.add(s.charAt(i + 2));\\n\\n            if (set.size() == 3) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        Set<Character> set;\\n\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            set = new HashSet<>();\\n\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i + 1));\\n            set.add(s.charAt(i + 2));\\n\\n            if (set.size() == 3) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441121,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countGoodSubstrings(string s) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\twhile(j < n){\\n\\n\\t\\t\\t\\tif(j-i+1 == 3){\\n\\n\\t\\t\\t\\t\\tstring temp = s.substr(i, 3);\\n\\n\\t\\t\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\t\\t\\tfor(auto i : temp){\\n\\t\\t\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(mp.size() == 3){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countGoodSubstrings(string s) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\twhile(j < n){\\n\\n\\t\\t\\t\\tif(j-i+1 == 3){\\n\\n\\t\\t\\t\\t\\tstring temp = s.substr(i, 3);\\n\\n\\t\\t\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\t\\t\\tfor(auto i : temp){\\n\\t\\t\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3560950,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- map is of size 3 at once\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i,j,k,c=0;\\n        unordered_map<char,int>map;\\n\\n        for(i=0;i<3;i++)\\n        map[s[i]]++;\\n\\n        for(i=3;i<s.size();i++){\\n            if(map.size()==3)\\n            c++;\\n\\n            if(map[s[i-3]]>1)\\n            map[s[i-3]]--;\\n            else\\n            map.erase(s[i-3]);\\n            map[s[i]]++;\\n        }\\n\\n        if(map.size()==3)\\n            c++;\\n            \\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i,j,k,c=0;\\n        unordered_map<char,int>map;\\n\\n        for(i=0;i<3;i++)\\n        map[s[i]]++;\\n\\n        for(i=3;i<s.size();i++){\\n            if(map.size()==3)\\n            c++;\\n\\n            if(map[s[i-3]]>1)\\n            map[s[i-3]]--;\\n            else\\n            map.erase(s[i-3]);\\n            map[s[i]]++;\\n        }\\n\\n        if(map.size()==3)\\n            c++;\\n            \\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496933,
                "title": "c-c-javascript-very-easy-solution",
                "content": "# We have to obtain every three character and check whether one of them is the same with other one.If it is not,then we increase total number to 1;\\n\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n         for(int i=1;i<s.size()-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n      int res=0;\\n         for(int i=1;i<s.Length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;  \\n    }\\n}\\n```\\n\\n![Vote.png](https://assets.leetcode.com/users/images/cfa28b29-b04a-43fc-8262-144616116687_1683465999.863679.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n         for(int i=1;i<s.size()-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n      int res=0;\\n         for(int i=1;i<s.Length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652821,
                "title": "sliding-window-set-o-n-time-o-1-space",
                "content": "<iframe src=\"https://leetcode.com/playground/hq4zYSic/shared\" frameBorder=\"0\" width=\"100%\" height=\"475\"></iframe>",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/hq4zYSic/shared\" frameBorder=\"0\" width=\"100%\" height=\"475\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1815788,
                "title": "python-2-lines-solution",
                "content": "**Python:**\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\tsubstr = [s[x:y] for x, y in itertools.combinations(range(len(s) + 1), r = 2) if len(s[x:y]) == 3 ]\\n\\treturn len([s for s in substr if len(set(s)) == len(s)])\\n```\\n\\n**Like it ? please upvote !**\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\tsubstr = [s[x:y] for x, y in itertools.combinations(range(len(s) + 1), r = 2) if len(s[x:y]) == 3 ]\\n\\treturn len([s for s in substr if len(set(s)) == len(s)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1581918,
                "title": "python-sliding-window-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k = 3\\n        if k > len(s):\\n            return 0\\n        \\n        letter_frequency = {}\\n        count, windowStart = 0, 0\\n        for windowEnd in range(len(s)):\\n            if s[windowEnd] not in letter_frequency:\\n                letter_frequency[s[windowEnd]] = 0\\n            letter_frequency[s[windowEnd]] += 1\\n            \\n            if windowEnd >= k - 1:\\n                if len(letter_frequency) == k:\\n                    count+=1\\n                letter_frequency[s[windowStart]] -= 1\\n                if letter_frequency[s[windowStart]] ==0:\\n                    del letter_frequency[s[windowStart]]\\n                windowStart += 1\\n        return count\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k = 3\\n        if k > len(s):\\n            return 0\\n        \\n        letter_frequency = {}\\n        count, windowStart = 0, 0\\n        for windowEnd in range(len(s)):\\n            if s[windowEnd] not in letter_frequency:\\n                letter_frequency[s[windowEnd]] = 0\\n            letter_frequency[s[windowEnd]] += 1\\n            \\n            if windowEnd >= k - 1:\\n                if len(letter_frequency) == k:\\n                    count+=1\\n                letter_frequency[s[windowStart]] -= 1\\n                if letter_frequency[s[windowStart]] ==0:\\n                    del letter_frequency[s[windowStart]]\\n                windowStart += 1\\n        return count\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434368,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0,j=0,count=0;\\n        while(j<s.size()){\\n            if(j-i+1 < 3)\\n                j++;\\n            else if(j-i+1 == 3){\\n               if((s[i]!=s[i+1] && s[i]!=s[i+2]) && (s[i+1]!=s[i] && s[i+1]!=s[i+2]) && (s[i+2]!=s[i+1] && s[i+2]!=s[i])) \\n                   count++;\\n                i++;j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0,j=0,count=0;\\n        while(j<s.size()){\\n            if(j-i+1 < 3)\\n                j++;\\n            else if(j-i+1 == 3){\\n               if((s[i]!=s[i+1] && s[i]!=s[i+2]) && (s[i+1]!=s[i] && s[i+1]!=s[i+2]) && (s[i+2]!=s[i+1] && s[i+2]!=s[i])) \\n                   count++;\\n                i++;j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697724,
                "title": "beats-100-can-be-extended-to-any-number-of-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate the no of unique characters for first k characters. traverse through the string , if removed character has freq 0 reduce unique by 1, if added character has freq 1 increment unique by 1. if unique is k increment count. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.length() <3) return 0; \\n        int count = 0; int k = 3; int u = 0; vector<int> t(26, 0); \\n        for(int i=0; i<k; i++) {t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; }\\n        if(u == k) count++; \\n        for(int i=k; i<s.length(); i++){\\n            t[s[i-k] - \\'a\\']--;  if(t[s[i-k] - \\'a\\'] == 0) u--;   t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; \\n            if(u == k) count++; \\n        }\\n\\n            return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.length() <3) return 0; \\n        int count = 0; int k = 3; int u = 0; vector<int> t(26, 0); \\n        for(int i=0; i<k; i++) {t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; }\\n        if(u == k) count++; \\n        for(int i=k; i<s.length(); i++){\\n            t[s[i-k] - \\'a\\']--;  if(t[s[i-k] - \\'a\\'] == 0) u--;   t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; \\n            if(u == k) count++; \\n        }\\n\\n            return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526377,
                "title": "java-beats-100-oms-easiest-3-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        if(n<3) return 0;\\n        int c=0;\\n        System.out.print(s.charAt(0));\\n        for(int i =0;i<n-2;i++){\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)){\\n                c++;\\n            }  \\n        }\\n        return c;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        if(n<3) return 0;\\n        int c=0;\\n        System.out.print(s.charAt(0));\\n        for(int i =0;i<n-2;i++){\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)){\\n                c++;\\n            }  \\n        }\\n        return c;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142344,
                "title": "python-4-lines-1-liner-beginners-friendly-solution",
                "content": "class Solution:\\n\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3: # taking a window of 3\\n                count+=1\\n        return count\\n# Python One-Liner\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n                \\n\\t\\t\\n\\t\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3: # taking a window of 3\\n                count+=1\\n        return count\\n# Python One-Liner\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n                \\n\\t\\t\\n\\t\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1813742,
                "title": "java-easy-solution-sliding-window",
                "content": "First we will find the Window. So till size we do J++.\\nAfter that we will slide it so i++ and j++. \\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int l=s.length();\\n        int i=0,j=0,k=3,count=0;\\n        while(j<l)\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(j) && s.charAt(j)!=s.charAt(i+1) && s.charAt(i)!=s.charAt(i+1))             \\n                    count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int l=s.length();\\n        int i=0,j=0,k=3,count=0;\\n        while(j<l)\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(j) && s.charAt(j)!=s.charAt(i+1) && s.charAt(i)!=s.charAt(i+1))             \\n                    count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643675,
                "title": "succinct-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        def match(t):\\n            return len(set(t)) == 3\\n        \\n        return sum(map(match, zip(s, s[1:], s[2:])))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        def match(t):\\n            return len(set(t)) == 3\\n        \\n        return sum(map(match, zip(s, s[1:], s[2:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436379,
                "title": "java-solution-easy-to-understand",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<Character> set = new HashSet();\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            String subStr = s.substring(i, i + 3);\\n            for (char ch : subStr.toCharArray()) {\\n                set.add(ch);\\n            }            \\n            if (set.size() == 3) {\\n                count++;\\n            }\\n            set.clear();\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<Character> set = new HashSet();\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            String subStr = s.substring(i, i + 3);\\n            for (char ch : subStr.toCharArray()) {\\n                set.add(ch);\\n            }            \\n            if (set.size() == 3) {\\n                count++;\\n            }\\n            set.clear();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238883,
                "title": "1876-set-sliding-window",
                "content": "---\\n\\nCool, felt good use of programming language construct `Set()`\\nNOTE: This is an easy problem, so I create many `Set()`s knowingly. We could always compare 3 vals directly.\\n\\nAlgo\\n\\n- If <3 chars, we can\\'t make a good string, return 0\\n- Take 1st 3 chars, add them into `Set()`, duplicates will be deleted\\n  - After that if size is 3 then there are 3 distinct chars in this substring, increment count\\n- Delete front char, add next char - repeat above until we reach end of string\\n- Return the count\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var countGoodSubstrings = function (s) {\\n        let n = s.length;\\n        if (n < 3) return 0;          // minimum 3 chars needed for good substring\\n\\n        let count = 0;\\n\\n        let A = [s[0], s[1]];\\n        for (let i = 2; i < n; i++) {\\n            A.push(s[i]);                            // add 1 char to the back\\n            if (new Set(A).size === 3) {\\n                count++;                             // if distinct, set size will be 3, if so increment counter\\n            }\\n            A.shift();                               // remove 1 char from the front\\n        }\\n\\n        return count;\\n    };\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "---\\n\\nCool, felt good use of programming language construct `Set()`\\nNOTE: This is an easy problem, so I create many `Set()`s knowingly. We could always compare 3 vals directly.\\n\\nAlgo\\n\\n- If <3 chars, we can\\'t make a good string, return 0\\n- Take 1st 3 chars, add them into `Set()`, duplicates will be deleted\\n  - After that if size is 3 then there are 3 distinct chars in this substring, increment count\\n- Delete front char, add next char - repeat above until we reach end of string\\n- Return the count\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var countGoodSubstrings = function (s) {\\n        let n = s.length;\\n        if (n < 3) return 0;          // minimum 3 chars needed for good substring\\n\\n        let count = 0;\\n\\n        let A = [s[0], s[1]];\\n        for (let i = 2; i < n; i++) {\\n            A.push(s[i]);                            // add 1 char to the back\\n            if (new Set(A).size === 3) {\\n                count++;                             // if distinct, set size will be 3, if so increment counter\\n            }\\n            A.shift();                               // remove 1 char from the front\\n        }\\n\\n        return count;\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1238814,
                "title": "c-concise-and-straightforward-solution-beats-100-with-python-1-liner",
                "content": "C++ solution\\n```\\nint countGoodSubstrings(string s) \\n{\\n\\tint result=0,n=s.length();\\n\\tfor(int i=0;i<n-2;i++)\\n\\t\\tif(s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]) result++;\\n\\n\\treturn result;\\n}\\n```\\nPython 1 liner:\\n```\\ndef countGoodSubstrings(self, s):\\n\\treturn sum([s[i]!=s[i+1]!=s[i+2]!=s[i] for i in range(len(s)-2)])\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) \\n{\\n\\tint result=0,n=s.length();\\n\\tfor(int i=0;i<n-2;i++)\\n\\t\\tif(s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]) result++;\\n\\n\\treturn result;\\n}\\n```\n```\\ndef countGoodSubstrings(self, s):\\n\\treturn sum([s[i]!=s[i+1]!=s[i+2]!=s[i] for i in range(len(s)-2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4088642,
                "title": "beats-100-easiest-explanation-clean-code-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The idea is so simple.\\n- Have a window of size 3, slide it and increment count if unique elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count=0, n = s.size();\\n        for(int i=0; i<=n-3; i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1] != s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count=0, n = s.size();\\n        for(int i=0; i<=n-3; i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1] != s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930431,
                "title": "slliding-window-o-n-t-c-proper-intuition-explained",
                "content": "# Intuition\\u2705\\nThis Easy question is good.I have solved this question using sliding window O(N) solution. i have used map to store frequency of each window. here window size will be 3 becaue we have to find good substrings of length three.\\n\\n# Approach\\u2705\\u2705\\n1. we will insert element till we hit window size 3. \\n2. After complete 3 size window, we will check all three character of particular window is **unique or not**.\\n3. if we find **all three character unique in window**( **if(mp.size() == 3)**)then increase cnt.\\n\\n4. Now we will slide window to right side for further investigation in right sides all window.\\n5. Important point is, before slide window we will decrease frequency of **s[i]** element in map. then we do i++.\\n6. [ ****if(mp[s[i]] == 0) mp.erase(s[i])**** ]  if we find any mapping of character equal to 0 then we have to erase that key from map other wise map keep it as size 1 . whenever we check condition for **(mp.size() == 3)** it increase size by 1 , which will be wrong.\\n\\n# Complexity\\n- Time complexity:\\n   O(N)\\n\\n- Space complexity:\\n\\n  O(N)\\n              \\n     ****\\uD83D\\uDE80\\uD83D\\uDE80Kindly upvote if you find helpful\\uD83D\\uDE80\\uD83D\\uDE80****\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n = s.size();\\n        unordered_map<char,int>mp;\\n        int i = 0, j=0;\\n        int cnt=0;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if((j-i+1) < 3) j++;\\n           else{\\n               if(mp.size() == 3){\\n                   cnt++;\\n               }\\n               mp[s[i]]--;\\n               if(mp[s[i]] == 0) mp.erase(s[i]);\\n               i++;\\n               j++;\\n           }   \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n = s.size();\\n        unordered_map<char,int>mp;\\n        int i = 0, j=0;\\n        int cnt=0;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if((j-i+1) < 3) j++;\\n           else{\\n               if(mp.size() == 3){\\n                   cnt++;\\n               }\\n               mp[s[i]]--;\\n               if(mp[s[i]] == 0) mp.erase(s[i]);\\n               i++;\\n               j++;\\n           }   \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106591,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0, j=0;\\n        int cnt=0;\\n        \\n        unordered_map<char,int> mpp;\\n        while(j< s.size()) {\\n            mpp[s[j]]++;\\n            \\n            if(j-i+1==3) {\\n                if(mpp.size()==3) cnt++;\\n                 mpp[s[i]]--;\\n                if(mpp[s[i]]==0) mpp.erase(s[i]);\\n                i++;\\n            }\\n        j++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0, j=0;\\n        int cnt=0;\\n        \\n        unordered_map<char,int> mpp;\\n        while(j< s.size()) {\\n            mpp[s[j]]++;\\n            \\n            if(j-i+1==3) {\\n                if(mpp.size()==3) cnt++;\\n                 mpp[s[i]]--;\\n                if(mpp[s[i]]==0) mpp.erase(s[i]);\\n                i++;\\n            }\\n        j++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070161,
                "title": "idiomatic-kotlin",
                "content": "# Explanation\\nDivide the input by a substrings of three (by default increments of 1). Obtained substrings of size are still the same size after they are added to a set, we can conclude that the characters are unique\\n# Code\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        return s.windowed(3).count { it.toSet().size == 3}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        return s.windowed(3).count { it.toSet().size == 3}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053190,
                "title": "c-o-n-solution-beats-100-o-1-space",
                "content": "\\n\\n# Approach : Sliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i = 0;\\n        int count = 0;\\n        unordered_map<char, int> ump;\\n        for(int j=0;j<s.size();j++) {\\n            ump[s[j]]++;\\n            if(j - i + 1 == 3) {\\n                if(ump.size() == 3) count++;\\n                ump[s[i]]--;\\n                if(ump[s[i]] == 0) ump.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i = 0;\\n        int count = 0;\\n        unordered_map<char, int> ump;\\n        for(int j=0;j<s.size();j++) {\\n            ump[s[j]]++;\\n            if(j - i + 1 == 3) {\\n                if(ump.size() == 3) count++;\\n                ump[s[i]]--;\\n                if(ump[s[i]] == 0) ump.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810964,
                "title": "python-sliding-window-95-01-faster-5-lines",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        c,n=0,len(s)\\n        for i in range(n-2):\\n            t=set(s[i:i+3])\\n            if len(t)==3:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        c,n=0,len(s)\\n        for i in range(n-2):\\n            t=set(s[i:i+3])\\n            if len(t)==3:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677301,
                "title": "java-simple-sol-o-n",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n\\n            char x=s.charAt(i);\\n            char y=s.charAt(i+1);\\n            char z=s.charAt(i+2);\\n\\n            if(x!=y && y!=z && z!=x) count++;\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n\\n            char x=s.charAt(i);\\n            char y=s.charAt(i+1);\\n            char z=s.charAt(i+2);\\n\\n            if(x!=y && y!=z && z!=x) count++;\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664924,
                "title": "java-easy-solution-single-if-beginner-friendly",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        //String res = s.substring(0,3);\\n        int c=0;\\n        \\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n                String res = s.substring(i,i+3);\\n                if(res.charAt(0)!=res.charAt(1) && res.charAt(1)!=res.charAt(2)&& res.charAt(0)!=res.charAt(2))\\n                    c++;\\n        }    \\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        //String res = s.substring(0,3);\\n        int c=0;\\n        \\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n                String res = s.substring(i,i+3);\\n                if(res.charAt(0)!=res.charAt(1) && res.charAt(1)!=res.charAt(2)&& res.charAt(0)!=res.charAt(2))\\n                    c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2408328,
                "title": "c-solution-using-2-approaches",
                "content": "Approach 1 : This is basically a brute force, which gets accepted here for this question as the s.size() can be 100 at max and size of window is 3.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0; //store count of GOOD (unique) substrings\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i-1]!=s[i] && s[i-1]!=s[i+1]) //check whether the letter at s[i] is equal to its previous and next letter\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2 : Classic Sliding Window (thanks to @sk58 for helping me in better understanding of this approach)\\nFor greater window sizes and greater length of string, we can use sliding window.\\nIntuition (how to check, if we can use sliding window here???) (NOTE : This is for general questions)\\n1. The data structure mentioned will be array/string.\\n2. The question asks for maximum or minimum of something, maybe count, sums or uniqueness; as we have here in the question.\\n3. The size of the window is mentioned in the question, here it is 3.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;  //stores the count of GOOD substrings\\n        int i=0, j=0; //initialize i as starting position of window & j as ending position of the window\\n        int n = s.size();\\n        unordered_map<char, int>freq; //to map the characters in the string to their frequency\\n        while(i<n && j<n)\\n        {\\n            freq[s[j]]++; //to get the count of characters\\n            if(j-i+1 < 3) // if we haven\\'t reached to the required size of window, just increment ending position\\n                j++;\\n            else if(freq.size()==3) //this means, we have reached the required window size along with GOOD substring\\n            {\\n                ans++;\\n                freq.erase(s[i]); //erase the character&its count, so that we can move forward with the window\\n                i++; //increment starting position\\n                j++; //increment ending position\\n\\t\\t\\t\\t//this maintains the size of the window\\n            }\\n            else // if the size of the freq != 3, this means there\\'s a repetition of characters, though the window size is still 3\\n            {\\n                freq[s[i]]--; //decrement the count of the character as we will be shifting the window\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]); //just remove the entry of the character, as it is not needed\\n                i++;\\n                j++;\\n\\t\\t\\t\\t//increment the positions to shift the window\\n            } \\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0; //store count of GOOD (unique) substrings\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i-1]!=s[i] && s[i-1]!=s[i+1]) //check whether the letter at s[i] is equal to its previous and next letter\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;  //stores the count of GOOD substrings\\n        int i=0, j=0; //initialize i as starting position of window & j as ending position of the window\\n        int n = s.size();\\n        unordered_map<char, int>freq; //to map the characters in the string to their frequency\\n        while(i<n && j<n)\\n        {\\n            freq[s[j]]++; //to get the count of characters\\n            if(j-i+1 < 3) // if we haven\\'t reached to the required size of window, just increment ending position\\n                j++;\\n            else if(freq.size()==3) //this means, we have reached the required window size along with GOOD substring\\n            {\\n                ans++;\\n                freq.erase(s[i]); //erase the character&its count, so that we can move forward with the window\\n                i++; //increment starting position\\n                j++; //increment ending position\\n\\t\\t\\t\\t//this maintains the size of the window\\n            }\\n            else // if the size of the freq != 3, this means there\\'s a repetition of characters, though the window size is still 3\\n            {\\n                freq[s[i]]--; //decrement the count of the character as we will be shifting the window\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]); //just remove the entry of the character, as it is not needed\\n                i++;\\n                j++;\\n\\t\\t\\t\\t//increment the positions to shift the window\\n            } \\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801123,
                "title": "easy-solution-0ms-solution",
                "content": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(k<s.size()){\\n            if(s[i]!=s[j] and s[j]!=s[k] and s[i]!=s[k]){\\n                count++;\\n                // i++;j++;k++;\\n            }\\n            i+=1;\\n            j+=1;\\n            k+=1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(k<s.size()){\\n            if(s[i]!=s[j] and s[j]!=s[k] and s[i]!=s[k]){\\n                count++;\\n                // i++;j++;k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1797917,
                "title": "java-time-o-n-space-o-n-for-all-windows-size-substrings-of-length",
                "content": "I think it\\'s easy to solve the length three problem just using three variables for monitoring. However, how about the problem becomes checking length four or even a hundred lengths? \\n\\nI wrote an answer that only modifies the size of the window, but works with different lengths.\\n\\n```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int countGoodSubstrings(String s) {\\n    int sum = 0;\\n    int window = 3;\\n    // Space O(n)\\n    Map<Character, Integer> map = new HashMap<>();\\n    // Space O(n)\\n    Set<Character> dup = new HashSet<>();\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      // Time O(1)\\n      int count = map.getOrDefault(s.charAt(i), 0);\\n      count++;\\n      // Time O(1)\\n      map.put(s.charAt(i), count);\\n      // Time O(1)\\n      if (count > 1 && !dup.contains(s.charAt(i))) {\\n        // Time O(1)\\n        dup.add(s.charAt(i));\\n      }\\n      if (i > (window - 1)) {\\n        // Time O(1)\\n        count = map.get(s.charAt(i - window)) - 1;\\n        // Time O(1)\\n        map.put(s.charAt(i - window), count);\\n        if (count < (window - 1)) {\\n          // Time O(1)\\n          dup.remove(s.charAt(i - window));\\n        }\\n      }\\n      // Time O(1)\\n      if (i > (window - 2) && dup.isEmpty()) {\\n        sum++;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int countGoodSubstrings(String s) {\\n    int sum = 0;\\n    int window = 3;\\n    // Space O(n)\\n    Map<Character, Integer> map = new HashMap<>();\\n    // Space O(n)\\n    Set<Character> dup = new HashSet<>();\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      // Time O(1)\\n      int count = map.getOrDefault(s.charAt(i), 0);\\n      count++;\\n      // Time O(1)\\n      map.put(s.charAt(i), count);\\n      // Time O(1)\\n      if (count > 1 && !dup.contains(s.charAt(i))) {\\n        // Time O(1)\\n        dup.add(s.charAt(i));\\n      }\\n      if (i > (window - 1)) {\\n        // Time O(1)\\n        count = map.get(s.charAt(i - window)) - 1;\\n        // Time O(1)\\n        map.put(s.charAt(i - window), count);\\n        if (count < (window - 1)) {\\n          // Time O(1)\\n          dup.remove(s.charAt(i - window));\\n        }\\n      }\\n      // Time O(1)\\n      if (i > (window - 2) && dup.isEmpty()) {\\n        sum++;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485706,
                "title": "c-100-faster",
                "content": "```\\nint countGoodSubstrings(string s) {\\n      if(s.size() < 3) return 0;\\n      int i=0, j=0, counter=0, ans=0;\\n      vector<int> map(128, 0);\\n\\t  \\n      while(j < s.size())\\n      {\\n        if(j-i+1 <= 3) {if(map[s[j++]]++ == 0) counter++;}\\n        else {\\n          if(counter == 3) ans++;\\n          if(map[s[i++]]-- == 1) counter--;\\n        }\\n        if(counter == 3 && j == s.size()) ans++;\\n      }\\n      return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) {\\n      if(s.size() < 3) return 0;\\n      int i=0, j=0, counter=0, ans=0;\\n      vector<int> map(128, 0);\\n\\t  \\n      while(j < s.size())\\n      {\\n        if(j-i+1 <= 3) {if(map[s[j++]]++ == 0) counter++;}\\n        else {\\n          if(counter == 3) ans++;\\n          if(map[s[i++]]-- == 1) counter--;\\n        }\\n        if(counter == 3 && j == s.size()) ans++;\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299772,
                "title": "easy-java-solution-100-fast",
                "content": "```\\n/* check every substring of size 3, if all the letters in the substring are distinct, increment the count of good strings*/\\n public int countGoodSubstrings(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(i+1);\\n            char ch3=s.charAt(i+2);\\n            if(ch1!=ch2 && ch2!=ch3 && ch1!=ch3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* check every substring of size 3, if all the letters in the substring are distinct, increment the count of good strings*/\\n public int countGoodSubstrings(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(i+1);\\n            char ch3=s.charAt(i+2);\\n            if(ch1!=ch2 && ch2!=ch3 && ch1!=ch3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1285693,
                "title": "c-solution-100-faster",
                "content": "```\\nint countGoodSubstrings(string s) {\\n        int i=0;\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(i<s.size()-2){\\n            if(s[i]!=s[i+1]&&s[i+1]!=s[i+2]&&s[i+2]!=s[i]){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) {\\n        int i=0;\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(i<s.size()-2){\\n            if(s[i]!=s[i+1]&&s[i+1]!=s[i+2]&&s[i+2]!=s[i]){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238901,
                "title": "easy-sliding-window-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n=s.length();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        int i=0,j=2,sum=0;\\n        while(j<n)\\n        {\\n            if(m.size()==3)\\n            {\\n                sum++;\\n            }\\n            if(m[s[i]]==1)\\n            {\\n                m.erase(s[i]);\\n            }\\n            else\\n            {\\n                m[s[i]]--;\\n            }\\n            m[s[j+1]]++;\\n            i++;\\n            j++;   \\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n=s.length();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        int i=0,j=2,sum=0;\\n        while(j<n)\\n        {\\n            if(m.size()==3)\\n            {\\n                sum++;\\n            }\\n            if(m[s[i]]==1)\\n            {\\n                m.erase(s[i]);\\n            }\\n            else\\n            {\\n                m[s[i]]--;\\n            }\\n            m[s[j+1]]++;\\n            i++;\\n            j++;   \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238768,
                "title": "java-easy-solution",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String str) {\\n        int count = 0;\\n        int counter;\\n        String s = \"\";\\n        for(int i = 0; i <= str.length() - 3; i++){\\n            Set<Character> set = new HashSet<Character>();\\n            s = str.substring(i, i + 3);\\n            counter = 0;\\n            for(char c : s.toCharArray()){\\n                if(set.add(c))\\n                    counter++;\\n                else\\n                    break;\\n            }\\n            if(counter == 3){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String str) {\\n        int count = 0;\\n        int counter;\\n        String s = \"\";\\n        for(int i = 0; i <= str.length() - 3; i++){\\n            Set<Character> set = new HashSet<Character>();\\n            s = str.substring(i, i + 3);\\n            counter = 0;\\n            for(char c : s.toCharArray()){\\n                if(set.add(c))\\n                    counter++;\\n                else\\n                    break;\\n            }\\n            if(counter == 3){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238638,
                "title": "a-few-solutions",
                "content": "**Brute-Force (Functional)**\\n\\nConsider each substring `t` of length `3` of the input string `s`.  Note: `t` is implied as the substring `s[i..i+3)` (ie. from `i` inclusive to `i + 3` non-inclusive).\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var countGoodSubstrings = { s: String -> s.toList().mapIndexed{ i, _ -> if (i + 3 <= s.length && s.substring(i, i + 3).toSet().size == 3) 1 else 0 }!!.sum() }\\n}\\n```\\n\\n*Javascript (note: `t` is the accumulator, ie. `t` is the total sum reduced thus far)*\\n```\\nlet countGoodSubstrings = s => s.split(\\'\\').reduce((t, _, i) => i + 3 <= s.length && new Set(s.substring(i, i + 3).split(\\'\\')).size == 3 ? 1 + t : t, 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(1 if i + 3 <= len(s) and len(set(list(s[i:i + 3]))) == 3 else 0 for i in range(len(s)))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        return count_if(s.begin(), s.end(), [i = -1, &s](auto _) mutable {\\n            ++i;\\n            if (s.size() < i + 3)\\n                return false;\\n            auto t = s.substr(i, 3);\\n            return Set{ t.begin(), t.end() }.size() == 3;\\n        });\\n    }\\n};\\n```\\n\\n---\\n\\n**Brute-Force (Procedural)**\\n\\nConsider each substring `t` of length `3` of the input string `s`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        for (i in 0 until s.length - 3 + 1)\\n            if (s.substring(i, i + 3).toSet().size == 3)\\n                ++cnt\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    for (let i = 0; i + 3 <= s.length; ++i) {\\n        let t = s.substring(i, i + 3);\\n        cnt += new Set(t).size == 3;\\n    }\\n    return cnt;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        for i in range(0, N - 3 + 1):\\n            t = s[i:i + 3]\\n            cnt += len(set(t)) == 3\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i + 3 <= N; ++i) {\\n            auto t = s.substr(i, 3);\\n            cnt += Set{ t.begin(), t.end() }.size() == 3;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\uD83D\\uDC48 Sliding Window ( a, b, c )**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var N = s.length\\n        if (N < 3)\\n            return 0\\n        var a = s[0]\\n        var b = s[1]\\n        var c = \\'*\\'\\n        for (i in 2 until N) {\\n            c = s[i]\\n            if (a != b && b != c && a != c)  // \\uD83C\\uDFAF 3 unique values\\n                ++cnt\\n            a = b; b = c                     // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    let N = s.length;\\n    if (N < 3)\\n        return 0;\\n    let a = s[0],\\n        b = s[1],\\n        c = \\'\\\\0\\';\\n    for (let i = 2; i < N; ++i) {\\n        c = s[i];\\n        cnt += a != b && b != c && a != c;  // \\uD83C\\uDFAF 3 unique values\\n        a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n    }\\n    return cnt;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        if N < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = \\'\\\\0\\'\\n        for i in range(2, N):\\n            c = s[i]; i += 1\\n            cnt += a != b and b != c and a != c  # \\uD83C\\uDFAF 3 unique values\\n            a = b; b = c                         # \\uD83D\\uDC48 slide window\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        if (N < 3)\\n            return 0;\\n        auto a = s[0],\\n             b = s[1],\\n             c = \\'\\\\0\\';\\n        for (auto i{ 2 }; i < N; ++i) {\\n            c = s[i];\\n            cnt += c != b && b != a && c != a;  // \\uD83C\\uDFAF 3 unique values\\n            a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\uD83D\\uDC49 Sliding Window [ i = j -2 .. i ] + \\uD83D\\uDDFA Map**\\n\\nUse a map `m` to track the count of each character in the window of size `3`.  Return the count `cnt` of unique substrings of length `3`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Char, Int>()\\n        var N = s.length\\n        var j = 0\\n        while (j < 2 && j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            ++j\\n        }\\n        while (j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            if (m.size == 3)\\n                ++cnt\\n            m[s[j - 2]] = -1 + m[s[j - 2]]!!\\n            if (m[s[j - 2]]!! == 0)\\n                m.remove(s[j - 2])\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, m = new Map(), cnt = 0) => {\\n    let N = s.length,\\n        j = 0;\\n    while (j < 2) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        ++j;\\n    }\\n    while (j < N) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        cnt += m.size == 3;\\n        if (!m.set(s[j - 2], -1 + m.get(s[j - 2])).get(s[j - 2]))\\n            m.delete(s[j - 2]);\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        j = 2\\n        m = Counter(c for c in s[:2])\\n        while j < N:\\n            m[s[j]] = 1 + (m[s[j]] if s[j] in m else 0)\\n            if len(m) == 3:\\n                cnt += 1\\n            m[s[j - 2]] -= 1\\n            if m[s[j - 2]] == 0:\\n                del m[s[j - 2]]\\n            j += 1\\n        return cnt\\n```\\n        \\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int countGoodSubstrings(string s, Map m = {}, int cnt = 0) {\\n        int N = s.size(),\\n            j = 0;\\n        while (j < min(2, N))\\n            ++m[s[j++]];\\n        while (j < N) {\\n            ++m[s[j]];\\n            cnt += m.size() == 3;\\n            if (!--m[s[j - 2]])\\n                m.erase(s[j - 2]);\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var countGoodSubstrings = { s: String -> s.toList().mapIndexed{ i, _ -> if (i + 3 <= s.length && s.substring(i, i + 3).toSet().size == 3) 1 else 0 }!!.sum() }\\n}\\n```\n```\\nlet countGoodSubstrings = s => s.split(\\'\\').reduce((t, _, i) => i + 3 <= s.length && new Set(s.substring(i, i + 3).split(\\'\\')).size == 3 ? 1 + t : t, 0);\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(1 if i + 3 <= len(s) and len(set(list(s[i:i + 3]))) == 3 else 0 for i in range(len(s)))\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        return count_if(s.begin(), s.end(), [i = -1, &s](auto _) mutable {\\n            ++i;\\n            if (s.size() < i + 3)\\n                return false;\\n            auto t = s.substr(i, 3);\\n            return Set{ t.begin(), t.end() }.size() == 3;\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        for (i in 0 until s.length - 3 + 1)\\n            if (s.substring(i, i + 3).toSet().size == 3)\\n                ++cnt\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    for (let i = 0; i + 3 <= s.length; ++i) {\\n        let t = s.substring(i, i + 3);\\n        cnt += new Set(t).size == 3;\\n    }\\n    return cnt;\\n}\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        for i in range(0, N - 3 + 1):\\n            t = s[i:i + 3]\\n            cnt += len(set(t)) == 3\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i + 3 <= N; ++i) {\\n            auto t = s.substr(i, 3);\\n            cnt += Set{ t.begin(), t.end() }.size() == 3;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var N = s.length\\n        if (N < 3)\\n            return 0\\n        var a = s[0]\\n        var b = s[1]\\n        var c = \\'*\\'\\n        for (i in 2 until N) {\\n            c = s[i]\\n            if (a != b && b != c && a != c)  // \\uD83C\\uDFAF 3 unique values\\n                ++cnt\\n            a = b; b = c                     // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    let N = s.length;\\n    if (N < 3)\\n        return 0;\\n    let a = s[0],\\n        b = s[1],\\n        c = \\'\\\\0\\';\\n    for (let i = 2; i < N; ++i) {\\n        c = s[i];\\n        cnt += a != b && b != c && a != c;  // \\uD83C\\uDFAF 3 unique values\\n        a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n    }\\n    return cnt;\\n}\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        if N < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = \\'\\\\0\\'\\n        for i in range(2, N):\\n            c = s[i]; i += 1\\n            cnt += a != b and b != c and a != c  # \\uD83C\\uDFAF 3 unique values\\n            a = b; b = c                         # \\uD83D\\uDC48 slide window\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        if (N < 3)\\n            return 0;\\n        auto a = s[0],\\n             b = s[1],\\n             c = \\'\\\\0\\';\\n        for (auto i{ 2 }; i < N; ++i) {\\n            c = s[i];\\n            cnt += c != b && b != a && c != a;  // \\uD83C\\uDFAF 3 unique values\\n            a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Char, Int>()\\n        var N = s.length\\n        var j = 0\\n        while (j < 2 && j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            ++j\\n        }\\n        while (j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            if (m.size == 3)\\n                ++cnt\\n            m[s[j - 2]] = -1 + m[s[j - 2]]!!\\n            if (m[s[j - 2]]!! == 0)\\n                m.remove(s[j - 2])\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, m = new Map(), cnt = 0) => {\\n    let N = s.length,\\n        j = 0;\\n    while (j < 2) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        ++j;\\n    }\\n    while (j < N) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        cnt += m.size == 3;\\n        if (!m.set(s[j - 2], -1 + m.get(s[j - 2])).get(s[j - 2]))\\n            m.delete(s[j - 2]);\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        j = 2\\n        m = Counter(c for c in s[:2])\\n        while j < N:\\n            m[s[j]] = 1 + (m[s[j]] if s[j] in m else 0)\\n            if len(m) == 3:\\n                cnt += 1\\n            m[s[j - 2]] -= 1\\n            if m[s[j - 2]] == 0:\\n                del m[s[j - 2]]\\n            j += 1\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int countGoodSubstrings(string s, Map m = {}, int cnt = 0) {\\n        int N = s.size(),\\n            j = 0;\\n        while (j < min(2, N))\\n            ++m[s[j++]];\\n        while (j < N) {\\n            ++m[s[j]];\\n            cnt += m.size() == 3;\\n            if (!--m[s[j - 2]])\\n                m.erase(s[j - 2]);\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241425,
                "title": "unpredicted-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:(i+3)]))==3:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:(i+3)]))==3:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240610,
                "title": "simple-and-easy-code-to-understand-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585357,
                "title": "sliding-window-python3-easy-undersatnding",
                "content": "This problem can be easily solved using Sliding Window pattern\\n\\n*Time: O(n)\\nSpace: O(1)*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        windowStart = 0\\n        \\n        c = 0\\n        \\n\\t\\t# O(n)\\n        for windowEnd in range(len(s)):\\n            \\n            if windowEnd - windowStart + 1 == 3:\\n                \\n                valid = True\\n                \\n\\t\\t\\t\\t# Stores at most 3 letters => O(1) \\n                vis = {}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Runs for 3 times at most => O(1) \\n                for i in range(windowStart, windowEnd+1):\\n                    \\n                    if s[i] not in vis:\\n                        vis[s[i]] = 1\\n                    else:\\n                        valid = False\\n                        break\\n                \\n                if valid:\\n                    c += 1\\n                \\n                windowStart += 1\\n        \\n        return c\\n                \\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        windowStart = 0\\n        \\n        c = 0\\n        \\n\\t\\t# O(n)\\n        for windowEnd in range(len(s)):\\n            \\n            if windowEnd - windowStart + 1 == 3:\\n                \\n                valid = True\\n                \\n\\t\\t\\t\\t# Stores at most 3 letters => O(1) \\n                vis = {}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Runs for 3 times at most => O(1) \\n                for i in range(windowStart, windowEnd+1):\\n                    \\n                    if s[i] not in vis:\\n                        vis[s[i]] = 1\\n                    else:\\n                        valid = False\\n                        break\\n                \\n                if valid:\\n                    c += 1\\n                \\n                windowStart += 1\\n        \\n        return c\\n                \\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464237,
                "title": "go-solution",
                "content": "```\\nfunc countGoodSubstrings(s string) int {\\n    charSet, count, left := make([]byte, 26), 0, 0\\n    \\n    for right := 0; right < len(s); right++ {\\n        charSet[s[right] - \\'a\\']++\\n        \\n        for right - left + 1 > 3 {\\n            charSet[s[left] - \\'a\\']--\\n            left++\\n        }\\n        \\n        if right-left+1 == 3 {\\n            charCount := 0\\n            \\n            for i := 0; i < 26; i++ {\\n                if charSet[i] > 0 {\\n                    charCount++\\n                }    \\n            }\\n            \\n            if charCount == 3 {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    charSet, count, left := make([]byte, 26), 0, 0\\n    \\n    for right := 0; right < len(s); right++ {\\n        charSet[s[right] - \\'a\\']++\\n        \\n        for right - left + 1 > 3 {\\n            charSet[s[left] - \\'a\\']--\\n            left++\\n        }\\n        \\n        if right-left+1 == 3 {\\n            charCount := 0\\n            \\n            for i := 0; i < 26; i++ {\\n                if charSet[i] > 0 {\\n                    charCount++\\n                }    \\n            }\\n            \\n            if charCount == 3 {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077347,
                "title": "js-sliding-window-solution-with-explanation",
                "content": "## Explanation\\n\\nPhase one: setup pointers to left and right of sliding window\\n```\\n// index           0 1 2 3 4 5 \\n//                 a b c b c a\\n// step 1:         ^              // map{a: 1},             left: 0, right: 0\\n// step 2:         ^ ^            // map{a: 1, b: 1},       left: 0, right: 1\\n// step 3:         ^   ^          // map{a: 1, b: 1, c: 1}, left: 0, right: 2\\n```\\nOn each step: we store characters to map (key: character; value: frequency).\\n\\nPhase two: moving sliding window until right pointer has reached the end of string.\\n```\\n// index           0 1 2 3 4 5\\n//                 a b c b c a\\n// step 4:           ^   ^            // map{b: 2, c: 1},  left: 1, right: 3\\n// step 5:             ^   ^          // map{b: 1, c: 2},  left: 2, right: 4\\n// etc\\u2026\\n```\\nOn each step:\\n 1) check size of map: if its equal windowSize then answer is updated.\\n 2) drop old left character from map\\n 3) add new right character to map\\n 4) move pointers of left and right of sliding window.\\n\\n\\n## Code:\\n```\\nvar countGoodSubstrings = function(s) {\\n    const lookup = new Map();\\n    const windowSize = 3;\\n    \\n    let answer = 0;\\n    let left = 0;\\n    let right = 0;\\n    \\n    while(right < s.length) {\\n        const rightChar = s[right];\\n        const val = lookup.get(rightChar) || 0;\\n        \\n        lookup.set(rightChar, val + 1);\\n        \\n        if (right - left + 1 < windowSize) {\\n            right += 1;\\n            \\n            continue;\\n        }\\n        \\n        if (lookup.size === windowSize) answer += 1;\\n        \\n        // update map\\n        const leftChar = s[left];\\n        lookup.set(leftChar, lookup.get(leftChar) - 1);\\n        if (lookup.get(leftChar) === 0) {\\n            lookup.delete(leftChar);\\n        }\\n        \\n        // move window\\n        left += 1;\\n        right += 1;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n// index           0 1 2 3 4 5 \\n//                 a b c b c a\\n// step 1:         ^              // map{a: 1},             left: 0, right: 0\\n// step 2:         ^ ^            // map{a: 1, b: 1},       left: 0, right: 1\\n// step 3:         ^   ^          // map{a: 1, b: 1, c: 1}, left: 0, right: 2\\n```\n```\\n// index           0 1 2 3 4 5\\n//                 a b c b c a\\n// step 4:           ^   ^            // map{b: 2, c: 1},  left: 1, right: 3\\n// step 5:             ^   ^          // map{b: 1, c: 2},  left: 2, right: 4\\n// etc\\u2026\\n```\n```\\nvar countGoodSubstrings = function(s) {\\n    const lookup = new Map();\\n    const windowSize = 3;\\n    \\n    let answer = 0;\\n    let left = 0;\\n    let right = 0;\\n    \\n    while(right < s.length) {\\n        const rightChar = s[right];\\n        const val = lookup.get(rightChar) || 0;\\n        \\n        lookup.set(rightChar, val + 1);\\n        \\n        if (right - left + 1 < windowSize) {\\n            right += 1;\\n            \\n            continue;\\n        }\\n        \\n        if (lookup.size === windowSize) answer += 1;\\n        \\n        // update map\\n        const leftChar = s[left];\\n        lookup.set(leftChar, lookup.get(leftChar) - 1);\\n        if (lookup.get(leftChar) === 0) {\\n            lookup.delete(leftChar);\\n        }\\n        \\n        // move window\\n        left += 1;\\n        right += 1;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971665,
                "title": "easy-o-n-js-solution",
                "content": "var countGoodSubstrings = function(s) {\\n    let total = 0;\\n    let setArr;\\n    for(let i=0; i<=s.length - 3; i++){\\n        setArr = new Set(s.slice(i, i+3));\\n        \\n        if(setArr.size === 3){\\n            total++;\\n        }\\n    }\\n    \\n    return total;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var countGoodSubstrings = function(s) {\\n    let total = 0;\\n    let setArr;\\n    for(let i=0; i<=s.length - 3; i++){\\n        setArr = new Set(s.slice(i, i+3));\\n        \\n        if(setArr.size === 3){\\n            total++;\\n        }\\n    }\\n    \\n    return total;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1755929,
                "title": "java-o-n-solution",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        int uniqueSubstrings = 0;\\n        int left = 0;\\n        int right = 2;\\n        \\n        for(int i = 1; i<s.length()-1; i++){\\n            \\n            if(s.charAt(i) != s.charAt(left) && s.charAt(i) != s.charAt(right) && s.charAt(right) != s.charAt(left)){\\n                uniqueSubstrings++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        return uniqueSubstrings;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        int uniqueSubstrings = 0;\\n        int left = 0;\\n        int right = 2;\\n        \\n        for(int i = 1; i<s.length()-1; i++){\\n            \\n            if(s.charAt(i) != s.charAt(left) && s.charAt(i) != s.charAt(right) && s.charAt(right) != s.charAt(left)){\\n                uniqueSubstrings++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        return uniqueSubstrings;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715117,
                "title": "sliding-window-using-map",
                "content": "\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)\\n        {\\n            return 0; //edge case\\n        }\\n        map<char,int> mp;\\n        int i=0,j=0,ans=0;\\n\\t\\t\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n\\t\\t\\t//if the window size is less than 3 slide j only\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==3)\\n            {\\n\\t\\t\\t    // when window size is hit check if there are 3 distinct elements or not in the map\\n                if(mp.size()==3)\\n                {\\n                    ans++;\\n                }\\n\\t\\t\\t\\t//after checking, slide the window \\n\\t\\t\\t\\t//decrement the value of the first element in the window in the map\\n                mp[s[i]]--;\\n\\t\\t\\t\\t//if the value becomes zero, remove the element from the map\\n                if(mp[s[i]]==0)\\n                {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)\\n        {\\n            return 0; //edge case\\n        }\\n        map<char,int> mp;\\n        int i=0,j=0,ans=0;\\n\\t\\t\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n\\t\\t\\t//if the window size is less than 3 slide j only\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==3)\\n            {\\n\\t\\t\\t    // when window size is hit check if there are 3 distinct elements or not in the map\\n                if(mp.size()==3)\\n                {\\n                    ans++;\\n                }\\n\\t\\t\\t\\t//after checking, slide the window \\n\\t\\t\\t\\t//decrement the value of the first element in the window in the map\\n                mp[s[i]]--;\\n\\t\\t\\t\\t//if the value becomes zero, remove the element from the map\\n                if(mp[s[i]]==0)\\n                {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1544118,
                "title": "c-sliding-window-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) \\n    {\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        int ans=0;\\n        while(j<s.size())\\n        {\\n            while(j-i+1<=3)\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }\\n            if(mp.size()==3)\\n            {\\n                    ans++;\\n            }\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0)\\n            {\\n                mp.erase(s[i]);\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) \\n    {\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        int ans=0;\\n        while(j<s.size())\\n        {\\n            while(j-i+1<=3)\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1313305,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int c=0,n=s.size();\\n        for(int i=0;i<n-2;i++){\\n            if(s[i]!=s[i+1]&& s[i+1]!=s[i+2] && s[i]!=s[i+2])\\n                c++;\\n        } \\n        return c;\\n    }\\n };\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int c=0,n=s.size();\\n        for(int i=0;i<n-2;i++){\\n            if(s[i]!=s[i+1]&& s[i+1]!=s[i+2] && s[i]!=s[i+2])\\n                c++;\\n        } \\n        return c;\\n    }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283969,
                "title": "java-simple-sliding-window-and-substrings",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        if(s.length() < 3)\\n            return 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            if(isGoodString(s.substring(i,i+3)))\\n                count++;\\n        }\\n    return count;\\n    }\\n    \\n    private static boolean isGoodString(String substring) {\\n        int[] intArray = new int[26];\\n        for (char c:substring.toCharArray()) {\\n            intArray[c - \\'a\\']++;\\n        }\\n        for (char c:substring.toCharArray()) {\\n            if(intArray[c - \\'a\\'] > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        if(s.length() < 3)\\n            return 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            if(isGoodString(s.substring(i,i+3)))\\n                count++;\\n        }\\n    return count;\\n    }\\n    \\n    private static boolean isGoodString(String substring) {\\n        int[] intArray = new int[26];\\n        for (char c:substring.toCharArray()) {\\n            intArray[c - \\'a\\']++;\\n        }\\n        for (char c:substring.toCharArray()) {\\n            if(intArray[c - \\'a\\'] > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269999,
                "title": "python-sliding-window",
                "content": "If you are familiar with the sliding window technique, this problem is pretty straightforward:\\n\\n1. Maintain a dictionary that stores letters you\\'ve seen so far. The letters are the key, and hwo many times you\\'ve seen them is the value.\\n2. Have a static window of size 3 and at each increment, check if the dictionary is of length 3. If so, this means that there are 3 unique characters you\\'ve seen in this substring, so increment your result by 1.\\n3. Remove the character at the leftmost position from the dictionary, by decrementing it\\'s value in the dictionary by 1. If this value reaches 0, pop this element from the dictionary.\\n\\nSpace complexity is O(1) since our dictionary is always at or below size 3, and time complexity is O(n) since we process each character at most twice, once from the window_end, and once from windows_start. \\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        seen = {}\\n        window_start = 0\\n        res = 0\\n        for window_end in range(len(s)):\\n            if s[window_end] not in seen:\\n                seen[s[window_end]] = 0\\n            seen[s[window_end]] += 1\\n            if window_end < 2:\\n                continue\\n            elif window_end == 2:\\n                if len(seen) == 3:\\n                    res += 1\\n            else:\\n                seen[s[window_start]] -= 1\\n                if seen[s[window_start]] == 0:\\n                    seen.pop(s[window_start])\\n                if len(seen) == 3:\\n                    res += 1\\n                window_start += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        seen = {}\\n        window_start = 0\\n        res = 0\\n        for window_end in range(len(s)):\\n            if s[window_end] not in seen:\\n                seen[s[window_end]] = 0\\n            seen[s[window_end]] += 1\\n            if window_end < 2:\\n                continue\\n            elif window_end == 2:\\n                if len(seen) == 3:\\n                    res += 1\\n            else:\\n                seen[s[window_start]] -= 1\\n                if seen[s[window_start]] == 0:\\n                    seen.pop(s[window_start])\\n                if len(seen) == 3:\\n                    res += 1\\n                window_start += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266224,
                "title": "c-easy-solution-o-n-time-o-1-space-0ms-solution",
                "content": "```\\n//if we observe clearly if a character repeats then they must be either adjacent or they must be at the end of the substring of length 3\\n//we use this to check if characters are repeated and if not we will increment the count\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n        int i=0;\\n        int j=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1==3)\\n            {\\n                //check if a char is repeated\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j])\\n                {\\n                    //char repeated\\n                }\\n                else{\\n                    res++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//if we observe clearly if a character repeats then they must be either adjacent or they must be at the end of the substring of length 3\\n//we use this to check if characters are repeated and if not we will increment the count\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n        int i=0;\\n        int j=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1==3)\\n            {\\n                //check if a char is repeated\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j])\\n                {\\n                    //char repeated\\n                }\\n                else{\\n                    res++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250624,
                "title": "using-queue-approach-in-c-100-beat",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        queue<int> q;\\n        int ct=0;\\n        for(int i=0;i<s.size();i++){\\n            if(q.empty()){\\n               q.push(s[i]);\\n            }else{\\n               if(q.back()==s[i]){\\n                   while(q.empty()==false) q.pop();\\n                   q.push(s[i]);\\n               }else{\\n                   q.push(s[i]);\\n               }\\n            }\\n            if(q.size()==3){\\n                if(q.front()!=q.back()) ct++;\\n                q.pop();\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        queue<int> q;\\n        int ct=0;\\n        for(int i=0;i<s.size();i++){\\n            if(q.empty()){\\n               q.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1248025,
                "title": "o-n-c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t\\n        int n=s.length(); // length of string\\n        bool m[26]={0}; //bool array to mark which letters are present\\n        int i,j,ans=0;\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            for(j=0;j<26;j++)// re-initialising all the letters as absent\\n\\t\\t\\t\\tm[j]=false;\\n\\t\\t\\t\\n            for(j=0;j<3;j++)\\n            {\\n                char c=s[i+j]-\\'a\\';\\n                if(m[c])// if c has already occured\\n                    break;\\n                else\\n                    m[c]=1; // mark c as present in the substring s[i...i+2]\\n            }\\n\\t\\t\\tif(j==3)ans++; // if we successfully reach end of substring means no duplicate\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t\\n        int n=s.length(); // length of string\\n        bool m[26]={0}; //bool array to mark which letters are present\\n        int i,j,ans=0;\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            for(j=0;j<26;j++)// re-initialising all the letters as absent\\n\\t\\t\\t\\tm[j]=false;\\n\\t\\t\\t\\n            for(j=0;j<3;j++)\\n            {\\n                char c=s[i+j]-\\'a\\';\\n                if(m[c])// if c has already occured\\n                    break;\\n                else\\n                    m[c]=1; // mark c as present in the substring s[i...i+2]\\n            }\\n\\t\\t\\tif(j==3)ans++; // if we successfully reach end of substring means no duplicate\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245999,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:            \\n        return sum(s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2] for i in range(2, len(s)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:            \\n        return sum(s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2] for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238755,
                "title": "sliding-window-technique-java-explained-with-comments",
                "content": "\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int windowStart = 0;\\n        int count = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char rightChar = s.charAt(windowEnd);\\n\\t\\t\\t// putting each character into map\\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\\n\\t\\t\\t// if at any point in time, the size of map becomes greater than 3\\n            while(map.size() >= 3) {\\n\\t\\t\\t\\t/* first check, if the current length of our window is 3\\n\\t\\t\\t\\t   length is 3, we are going to increment count and break for the current window. */\\n                if ((windowEnd - windowStart + 1) == 3) {\\n                    count++;\\n                    break;\\n                }\\n                else {\\n\\t\\t\\t\\t\\t/* otherwise, take character from left side of the window and start decrementing its\\n\\t\\t\\t\\t\\tfrequency from the map. Decrementing means, we are not considering this element \\n\\t\\t\\t\\t\\tin our window. And, if its frequency becomes zero, we\\'ll remove it from the map. */\\n                    char leftChar = s.charAt(windowStart);\\n                    map.put(leftChar, map.get(leftChar) - 1);\\n                    if(map.get(leftChar) == 0) {\\n                        map.remove(leftChar);\\n                    }\\n                    windowStart++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int windowStart = 0;\\n        int count = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char rightChar = s.charAt(windowEnd);\\n\\t\\t\\t// putting each character into map\\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\\n\\t\\t\\t// if at any point in time, the size of map becomes greater than 3\\n            while(map.size() >= 3) {\\n\\t\\t\\t\\t/* first check, if the current length of our window is 3\\n\\t\\t\\t\\t   length is 3, we are going to increment count and break for the current window. */\\n                if ((windowEnd - windowStart + 1) == 3) {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4041220,
                "title": "java-solution-tc-0ms-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n\\nint count = 0;\\n for(int i=2;i<s.length();i++){\\n                char a = s.charAt(i);\\n                char b = s.charAt(i-1);\\n                char c = s.charAt(i-2);\\n                if(a != b && a != c  && b != c)\\n                   count++;\\n }\\n return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n\\nint count = 0;\\n for(int i=2;i<s.length();i++){\\n                char a = s.charAt(i);\\n                char b = s.charAt(i-1);\\n                char c = s.charAt(i-2);\\n                if(a != b && a != c  && b != c)\\n                   count++;\\n }\\n return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808878,
                "title": "optimal-sliding-window-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = s[2]\\n        count = int(a != b and b !=c and c != a)\\n\\n        for i in range(3, len(s)):\\n            a = b\\n            b = c\\n            c = s[i]\\n            count += int(a != b and b !=c and c != a)\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = s[2]\\n        count = int(a != b and b !=c and c != a)\\n\\n        for i in range(3, len(s)):\\n            a = b\\n            b = c\\n            c = s[i]\\n            count += int(a != b and b !=c and c != a)\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421386,
                "title": "c",
                "content": "# Intuition\\nBecause I don\\'t know which character to remove from set when set length less than 3, so when it is greater than 3, i will re-check whole set \\nex : \"zyyyy\"\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwhen set length greater than 3, i will re-check whole set \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            public int CountGoodSubstrings(string s)\\n            {\\n                if(s.Length < 3) return 0;\\n                int result = 0;\\n                HashSet<char> record = new HashSet<char>();                \\n\\n                for (int i = 0; i<s.Length ;i++)\\n                {\\n                    record.Add(s[i]);\\n                    if (record.Count >= 3)\\n                    {\\n                        record.Clear();\\n                        for (int j = i-2; j <= i; j++)\\n                            record.Add(s[j]);\\n                    }\\n\\n                    if (record.Count == 3)\\n                        result += 1;\\n                }\\n                return result;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            public int CountGoodSubstrings(string s)\\n            {\\n                if(s.Length < 3) return 0;\\n                int result = 0;\\n                HashSet<char> record = new HashSet<char>();                \\n\\n                for (int i = 0; i<s.Length ;i++)\\n                {\\n                    record.Add(s[i]);\\n                    if (record.Count >= 3)\\n                    {\\n                        record.Clear();\\n                        for (int j = i-2; j <= i; j++)\\n                            record.Add(s[j]);\\n                    }\\n\\n                    if (record.Count == 3)\\n                        result += 1;\\n                }\\n                return result;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311957,
                "title": "c-easy-brute-force-approach-for-loop-only-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\njai shree ram\\nupvote if you find it helpfull\\nif any problem ask it in comment section..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n     int ans = 0;\\n      //check if the length is less than 3...\\n        if(s.length() < 3)\\n         return 0;\\n        //simple for loop check the 1 character with 2 and 1 with 3 and 2 with the 3 ..with if condition if it is true add it to ans..\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n     int ans = 0;\\n      //check if the length is less than 3...\\n        if(s.length() < 3)\\n         return 0;\\n        //simple for loop check the 1 character with 2 and 1 with 3 and 2 with the 3 ..with if condition if it is true add it to ans..\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034139,
                "title": "easiest-8-lines-beginner-friendly-solution",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\no(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    for(int i=0;i<s.length()-2;i++){\\n\\n    String temp=s.substring(i,i+3);\\n\\n    if(temp.charAt(0)!=temp.charAt(1)&&temp.charAt(0)!=temp.charAt(2)&&temp.charAt(1)!=temp.charAt(2)){\\n        count++;\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    for(int i=0;i<s.length()-2;i++){\\n\\n    String temp=s.substring(i,i+3);\\n\\n    if(temp.charAt(0)!=temp.charAt(1)&&temp.charAt(0)!=temp.charAt(2)&&temp.charAt(1)!=temp.charAt(2)){\\n        count++;\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744224,
                "title": "python-faster-than-94-of-submissions-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def countGoodSubstrings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)-2):\\n            q = s[i:i+4]\\n            if q[0] != q[1] and q[0] != q[2] and q[2] != q[1]:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGoodSubstrings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)-2):\\n            q = s[i:i+4]\\n            if q[0] != q[1] and q[0] != q[2] and q[2] != q[1]:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742324,
                "title": "sliding-window-here-we-count-the-substrings-of-size-3-having-all-unique-characters",
                "content": "```\\nHere we have to calculate the number of substrings of size 3 having all unique characters .\\nSo this question basically uses the concept of sliding window of fixed size which we will slide over the string . \\nWe will use map to store the frequency of characters in the window . \\nAll the characaters are unique in the particular window if current map size is equal to window length (j-i+1) . here i denotes the starting index of window \\nand j denotes the ending index of window . \\n\\nint countGoodSubstrings(string s) \\n    {\\n        int n = s.size(); \\n        int k = 3; // Required window size \\n        \\n        unordered_map<char,int> mp;\\n        int i=0,j=0; // i is starting index of window and j is ending index of window\\n        int count = 0; // Subarrays count\\n        \\n        while(j<n)\\n        {\\n            mp[s[j]]++; // Adding the frequency of jth character in map\\n            \\n            if(j-i+1<3) // If window size of 3 is not achieved\\n                j++;\\n            \\n            else if(j-i+1==3)  // If window size of 3 is achieved\\n            {\\n                if(mp.size()==(j-i+1)) // Checking if all the characters in window are unique\\n                {\\n                    count += 1;\\n                    \\n                    mp[s[i]]--; // Before sliding the window make sure to decrease the count of starting index character of window \\n                    if(mp[s[i]]==0) \\n                        mp.erase(s[i]);\\n                    \\n\\t\\t\\t\\t\\t// Sliding the window\\n                    i++; \\n                    j++;\\n                    \\n                }\\n                \\n                else if(mp.size()<(j-i+1)) // // if all the characters in window are not unique\\n                {\\n                    while(mp.size()<(j-i+1) && i<=j) // Removing the ith character from window until we have removed all the duplicate characters\\n                    {\\n                        mp[s[i]]--;\\n                        if(mp[s[i]]==0)\\n                            mp.erase(s[i]);\\n                        i++;\\n                    }\\n                    j++;\\n                }                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nHere we have to calculate the number of substrings of size 3 having all unique characters .\\nSo this question basically uses the concept of sliding window of fixed size which we will slide over the string . \\nWe will use map to store the frequency of characters in the window . \\nAll the characaters are unique in the particular window if current map size is equal to window length (j-i+1) . here i denotes the starting index of window \\nand j denotes the ending index of window . \\n\\nint countGoodSubstrings(string s) \\n    {\\n        int n = s.size(); \\n        int k = 3; // Required window size \\n        \\n        unordered_map<char,int> mp;\\n        int i=0,j=0; // i is starting index of window and j is ending index of window\\n        int count = 0; // Subarrays count\\n        \\n        while(j<n)\\n        {\\n            mp[s[j]]++; // Adding the frequency of jth character in map\\n            \\n            if(j-i+1<3) // If window size of 3 is not achieved\\n                j++;\\n            \\n            else if(j-i+1==3)  // If window size of 3 is achieved\\n            {\\n                if(mp.size()==(j-i+1)) // Checking if all the characters in window are unique\\n                {\\n                    count += 1;\\n                    \\n                    mp[s[i]]--; // Before sliding the window make sure to decrease the count of starting index character of window \\n                    if(mp[s[i]]==0) \\n                        mp.erase(s[i]);\\n                    \\n\\t\\t\\t\\t\\t// Sliding the window\\n                    i++; \\n                    j++;\\n                    \\n                }\\n                \\n                else if(mp.size()<(j-i+1)) // // if all the characters in window are not unique\\n                {\\n                    while(mp.size()<(j-i+1) && i<=j) // Removing the ith character from window until we have removed all the duplicate characters\\n                    {\\n                        mp[s[i]]--;\\n                        if(mp[s[i]]==0)\\n                            mp.erase(s[i]);\\n                        i++;\\n                    }\\n                    j++;\\n                }                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664467,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string n) {\\n        int s=n.size();\\n        int a=0;\\n        for(int i=1;i<s-1;i++)\\n        {\\n            if(n[i]!=n[i-1]&&n[i]!=n[i+1]&&n[i-1]!=n[i+1])\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string n) {\\n        int s=n.size();\\n        int a=0;\\n        for(int i=1;i<s-1;i++)\\n        {\\n            if(n[i]!=n[i-1]&&n[i]!=n[i+1]&&n[i-1]!=n[i+1])\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585933,
                "title": "c-sliding-window-approach-works-for-any-value-of-k",
                "content": "**For any value of k : **\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0,k=3;\\n        if(n<k) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<k;i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k) count++;\\n        for(int j=k;j<n;j++){\\n            m[s[j-k]]--;\\n            m[s[j]]++;\\n            if(m[s[j-k]]==0) m.erase(s[j-k]);\\n            if(m.size()==k) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nFor k=3;\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0;\\n        if(n<3) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++){   //in this question k=3;\\n            m[s[i]]++;\\n        }\\n        if(m.size()==3) count++;\\n        for(int j=3;j<n;j++){\\n            m[s[j-3]]--;\\n            m[s[j]]++;\\n            if(m[s[j-3]]==0) m.erase(s[j-3]);\\n            if(m.size()==3) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0,k=3;\\n        if(n<k) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<k;i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k) count++;\\n        for(int j=k;j<n;j++){\\n            m[s[j-k]]--;\\n            m[s[j]]++;\\n            if(m[s[j-k]]==0) m.erase(s[j-k]);\\n            if(m.size()==k) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0;\\n        if(n<3) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++){   //in this question k=3;\\n            m[s[i]]++;\\n        }\\n        if(m.size()==3) count++;\\n        for(int j=3;j<n;j++){\\n            m[s[j-3]]--;\\n            m[s[j]]++;\\n            if(m[s[j-3]]==0) m.erase(s[j-3]);\\n            if(m.size()==3) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357175,
                "title": "short-javascript-solution-using-a-set-object-and-the-sliding-window-technique",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst countGoodSubstrings = s => {\\n    let count = 0;\\n\\n    for (let i = 0; i < s.length - 2; i++) {\\n        let window = s.substring(i, 3 + i)\\n        if (new Set(window.split(\\'\\')).size === 3) count++\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst countGoodSubstrings = s => {\\n    let count = 0;\\n\\n    for (let i = 0; i < s.length - 2; i++) {\\n        let window = s.substring(i, 3 + i)\\n        if (new Set(window.split(\\'\\')).size === 3) count++\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258625,
                "title": "golang-easy-solution-0ms-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 1.9 MB, less than 58.82% of Go online submissions for Substrings of Size Three with Distinct Characters.\\n\\n```\\nfunc countGoodSubstrings(s string) int {\\n    if len(s) <= 2 {\\n        return 0\\n    }\\n    ans := 0\\n    for i := 0; i < len(s) - 2; i++ {\\n        tmp := s[i:i+3]\\n        if tmp[0] != tmp[1] && tmp[0] != tmp[2] && tmp[1] != tmp[2] {\\n            ans++\\n        }\\n    } \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    if len(s) <= 2 {\\n        return 0\\n    }\\n    ans := 0\\n    for i := 0; i < len(s) - 2; i++ {\\n        tmp := s[i:i+3]\\n        if tmp[0] != tmp[1] && tmp[0] != tmp[2] && tmp[1] != tmp[2] {\\n            ans++\\n        }\\n    } \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114971,
                "title": "javascript-sliding-window",
                "content": "Sliding Window is a good solution for substring problems. In this solution the window or subset has a maximum length (3) but is dynamic in that it grows and shrinks.\\n\\nTwo pointers are used to define the boundary of the subset (window). The left and right pointers are `left` and `i`, respectively.\\n\\n`Set` is used to store the values of the subset so we can check if a charcater already exists. When a character exists in the `Set`, we remove all the characters from the left (using our left pointer) until the duplicate character has been removed. The left pointer will now be at the start of our new subset.\\n\\nWhen the `Set` reaches a size of 3, the `count` is incremented by one, the starting character in the subset is removed and the left pointer incremented by 1.\\n\\n``` js\\nvar countGoodSubstrings = function (s) {\\n  let left = 0,\\n    count = 0,\\n    set = new Set();\\n\\n  for (let i = 0; i < s.length; i++) {\\n    while (set.has(s[i])) {\\n      set.delete(s[left]);\\n      left++;\\n    }\\n\\n    set.add(s[i]);\\n\\n    if (set.size === 3) {\\n      count++;\\n      set.delete(s[left]);\\n      left++;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "``` js\\nvar countGoodSubstrings = function (s) {\\n  let left = 0,\\n    count = 0,\\n    set = new Set();\\n\\n  for (let i = 0; i < s.length; i++) {\\n    while (set.has(s[i])) {\\n      set.delete(s[left]);\\n      left++;\\n    }\\n\\n    set.add(s[i]);\\n\\n    if (set.size === 3) {\\n      count++;\\n      set.delete(s[left]);\\n      left++;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106937,
                "title": "java-two-easy-solutions-with-explanation-o-n-brute-force",
                "content": "**Method 1:** **Brute Force Solution:**\\n1. Find the substring of length = 3\\n2. Store the substring in set -- set will eliminate duplicate characters --meaning 3 distinct characters in substring\\n3. If set.size() == 3, increase the count \\n4.  Return the count \\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n     int k = 3;\\n     int count = 0;   \\n     int kindex = k - 1;   \\n     String sub = new String();  \\n     for(int i = kindex; i < s.length(); i++){\\n        Set<Character> set = new HashSet<>(); \\n        sub = s.substring(i - kindex, i + 1);\\n        for(int j = 0 ; j < sub.length(); j++) \\n            set.add(sub.charAt(j));   \\n        if(set.size() == 3) count = count + 1; \\n     }  \\n       return count;     \\n    }\\n}\\n```\\n\\n**Method 2: O(N) solution using ArrayList - Approach - Sliding Window**\\n1. SlidingWindow length = 3\\n2. Add character in the list. If list size is greater than slidingwindow length, then remove the first element from the list\\n3. If list size is equal to 3, then check if all the elements are distinct, if yes increase the count\\n4. Return the count\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n      ArrayList<Character> list = new ArrayList<>();\\n      int slidingWindowSize = 3;  \\n      int count = 0;  \\n      for(int i = 0; i < s.length(); i++){\\n          list.add(s.charAt(i));\\n          if(list.size() > slidingWindowSize){ \\n              list.remove(0);\\n          }   \\n          if(list.size() == 3) {\\n              if(list.get(0) != list.get(1) && list.get(0) != list.get(2) && list.get(1) != list.get(2)) \\n                  count = count + 1;\\n          }\\n      }\\n     return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n     int k = 3;\\n     int count = 0;   \\n     int kindex = k - 1;   \\n     String sub = new String();  \\n     for(int i = kindex; i < s.length(); i++){\\n        Set<Character> set = new HashSet<>(); \\n        sub = s.substring(i - kindex, i + 1);\\n        for(int j = 0 ; j < sub.length(); j++) \\n            set.add(sub.charAt(j));   \\n        if(set.size() == 3) count = count + 1; \\n     }  \\n       return count;     \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n      ArrayList<Character> list = new ArrayList<>();\\n      int slidingWindowSize = 3;  \\n      int count = 0;  \\n      for(int i = 0; i < s.length(); i++){\\n          list.add(s.charAt(i));\\n          if(list.size() > slidingWindowSize){ \\n              list.remove(0);\\n          }   \\n          if(list.size() == 3) {\\n              if(list.get(0) != list.get(1) && list.get(0) != list.get(2) && list.get(1) != list.get(2)) \\n                  count = count + 1;\\n          }\\n      }\\n     return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041906,
                "title": "1876-substrings-of-size-three-with-distinct-characters",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(int left, int right, string& s){\\n        unordered_set<int> st;\\n        for(int i=left; i<=right; i++){\\n            st.insert(s[i]);\\n        }\\n        if(st.size()==right-left+1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    \\n    int countGoodSubstrings(string s) {\\n        if(s.length()<3)\\n            return 0;\\n        int count=0;\\n        int i=0;\\n        int k=3;\\n        int j=k-1;\\n        if(check(i,j,s))\\n            count++;\\n        while(j<s.length()-1)\\n        {\\n            i++;\\n            j++;\\n            if(check(i,j,s))\\n                    count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int left, int right, string& s){\\n        unordered_set<int> st;\\n        for(int i=left; i<=right; i++){\\n            st.insert(s[i]);\\n        }\\n        if(st.size()==right-left+1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    \\n    int countGoodSubstrings(string s) {\\n        if(s.length()<3)\\n            return 0;\\n        int count=0;\\n        int i=0;\\n        int k=3;\\n        int j=k-1;\\n        if(check(i,j,s))\\n            count++;\\n        while(j<s.length()-1)\\n        {\\n            i++;\\n            j++;\\n            if(check(i,j,s))\\n                    count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982289,
                "title": "c-solution-0ms",
                "content": "\\n        int goodStrCnt = 0, n = s.size();\\n        for(int i = 0; i < n-2 ; i++){\\n            if((s[i]^s[i+1]) == 0) continue;\\n            if((s[i+2]^s[i+1]) == 0)continue;\\n            if((s[i+2]^s[i]) == 0) continue;\\n            goodStrCnt++;\\n        }\\n        return goodStrCnt;\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "\\n        int goodStrCnt = 0, n = s.size();\\n        for(int i = 0; i < n-2 ; i++){\\n            if((s[i]^s[i+1]) == 0) continue;\\n            if((s[i+2]^s[i+1]) == 0)continue;\\n            if((s[i+2]^s[i]) == 0) continue;\\n            goodStrCnt++;\\n        }\\n        return goodStrCnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1913754,
                "title": "c-faster-than-100",
                "content": "```\\n int n = s.size();\\n        int ans = 0 ;\\n        int i  ;\\n        for(i= 0 ; i < n-2 ; i++){\\n            if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\\n                continue;\\n            ans++;\\n        }\\n        return ans;",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int n = s.size();\\n        int ans = 0 ;\\n        int i  ;\\n        for(i= 0 ; i < n-2 ; i++){\\n            if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\\n                continue;\\n            ans++;\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1855886,
                "title": "c-easy-solution-sliding-window-with-comments-explained",
                "content": "\\tint check(int i,int j,string& s)\\n    {\\n        set<int>st;//checking whether the selected part of string is duplicate or not\\n        for(int k=i;k<=j;k++)\\n        {\\n            st.insert(s[k]);\\n        }\\n        if(st.size()==3)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int countGoodSubstrings(string s)\\n    {\\n        int right=0;\\n        int left=0;\\n        int ans=0;\\n        while(right<s.length())\\n        {\\n            if(right-left==2)//taking the selected part of string\\n            {\\n                ans+=check(left,right,s);//sending the index to check\\n                left+=1;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "\\tint check(int i,int j,string& s)\\n    {\\n        set<int>st;//checking whether the selected part of string is duplicate or not\\n        for(int k=i;k<=j;k++)\\n        {\\n            st.insert(s[k]);\\n        }\\n        if(st.size()==3)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int countGoodSubstrings(string s)\\n    {\\n        int right=0;\\n        int left=0;\\n        int ans=0;\\n        while(right<s.length())\\n        {\\n            if(right-left==2)//taking the selected part of string\\n            {\\n                ans+=check(left,right,s);//sending the index to check\\n                left+=1;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1815806,
                "title": "c-simple-and-clean-solution-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if (s.size() < 3) return 0;\\n        \\n        int res = 0;\\n        for (int i = 0; i < s.size()-2; i++) {\\n            if (s[i] != s[i+1] && s[i+1] != s[i+2] && s[i] != s[i+2]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if (s.size() < 3) return 0;\\n        \\n        int res = 0;\\n        for (int i = 0; i < s.size()-2; i++) {\\n            if (s[i] != s[i+1] && s[i+1] != s[i+2] && s[i] != s[i+2]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742948,
                "title": "c-100-faster-solution",
                "content": "* j-i+1=window size\\n* \\n```\\nint countGoodSubstrings(string s) {\\n        unordered_map<char,int> mp;\\n        \\n        int i=0,j=0;\\n        int count=0;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n            \\n            if(j-i+1==3)\\n            {\\n                if(mp.size()==3)\\n                    count++;\\n                \\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)\\n                    mp.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string s) {\\n        unordered_map<char,int> mp;\\n        \\n        int i=0,j=0;\\n        int count=0;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n            \\n            if(j-i+1==3)\\n            {\\n                if(mp.size()==3)\\n                    count++;\\n                \\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)\\n                    mp.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729504,
                "title": "c-sliding-window-with-clear-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int low=0,high=2,count=0;  // create the window size as 3\\n        unordered_set <char> ch;\\n        while(high<s.size())  // iterate till high<=size\\n        {\\n            for(int i=low;i<=high;++i)  //push the characters into set\\n                ch.insert(s[i]);\\n            if(ch.size()==3)    // unique elements only if set size == 3\\n                count++;\\n            ch.clear();    // clear the set\\n            low++; high++;  // change the window\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int low=0,high=2,count=0;  // create the window size as 3\\n        unordered_set <char> ch;\\n        while(high<s.size())  // iterate till high<=size\\n        {\\n            for(int i=low;i<=high;++i)  //push the characters into set\\n                ch.insert(s[i]);\\n            if(ch.size()==3)    // unique elements only if set size == 3\\n                count++;\\n            ch.clear();    // clear the set\\n            low++; high++;  // change the window\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706220,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        start=0\\n        end=start+3\\n        count=0\\n        while(end<=len(s)):\\n            if len(s[start:end])==len(set(s[start:end])):\\n                count+=1\\n            start+=1\\n            end+=1\\n        return count",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        start=0\\n        end=start+3\\n        count=0\\n        while(end<=len(s)):\\n            if len(s[start:end])==len(set(s[start:end])):\\n                count+=1\\n            start+=1\\n            end+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1689404,
                "title": "c-o-n-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length(), ans=0;\\n        for(int i=1;i<n-1;i++){\\n            set<char> st = {s[i],s[i-1],s[i+1]};\\n            if(st.size()==3)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length(), ans=0;\\n        for(int i=1;i<n-1;i++){\\n            set<char> st = {s[i],s[i-1],s[i+1]};\\n            if(st.size()==3)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679788,
                "title": "c-simplest-solution-0ms",
                "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int l=s.size();int cnt=0;\\n        for(int i=0;i<l-2;i++)\\n        {\\n         if((s[i]!=s[i+1])&&(s[i+1]!=s[i+2])&&(s[i]!=s[i+2]))\\n             cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int l=s.size();int cnt=0;\\n        for(int i=0;i<l-2;i++)\\n        {\\n         if((s[i]!=s[i+1])&&(s[i+1]!=s[i+2])&&(s[i]!=s[i+2]))\\n             cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615243,
                "title": "100-fast-c-easy-understandable-solution-using-hash-and-sliding-window-technique",
                "content": "```\\nint countGoodSubstrings(string arr) {\\n        int i, j, count = 0,max_count = 0, k = 3;\\n        unordered_map<int, int> m;\\n\\t\\t// first taking an map with first three variable\\n        for (i = 0; i < k; i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n        }\\n        count = m.size();\\n        // then checking the size of the map if total size is 3 that means all elements are different  in that window\\n\\t\\tif(count == k){\\n            max_count++;\\n        }\\n        // sliding the window one by one removing the last element and its count and adding the very next element and again checking the count if its three then increasing our result .  \\n        for (i = k; i < (int)(arr.size()); i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n            if (m.find(arr[i - k]) != m.end())\\n            {\\n                if (m[arr[i - k]] == 1)\\n                    m.erase(arr[i - k]);\\n                else\\n                    m[arr[i - k]]--;\\n            }\\n            count = m.size();\\n            if(count == k){\\n                max_count++;\\n            }\\n        }\\n        return max_count;\\n    }\\n\\t// Hope it helps \\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string arr) {\\n        int i, j, count = 0,max_count = 0, k = 3;\\n        unordered_map<int, int> m;\\n\\t\\t// first taking an map with first three variable\\n        for (i = 0; i < k; i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n        }\\n        count = m.size();\\n        // then checking the size of the map if total size is 3 that means all elements are different  in that window\\n\\t\\tif(count == k){\\n            max_count++;\\n        }\\n        // sliding the window one by one removing the last element and its count and adding the very next element and again checking the count if its three then increasing our result .  \\n        for (i = k; i < (int)(arr.size()); i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n            if (m.find(arr[i - k]) != m.end())\\n            {\\n                if (m[arr[i - k]] == 1)\\n                    m.erase(arr[i - k]);\\n                else\\n                    m[arr[i - k]]--;\\n            }\\n            count = m.size();\\n            if(count == k){\\n                max_count++;\\n            }\\n        }\\n        return max_count;\\n    }\\n\\t// Hope it helps \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607378,
                "title": "easy-solution-in-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; i < n-2; i++)\\n        {\\n            if (s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2])\\n            {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; i < n-2; i++)\\n        {\\n            if (s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2])\\n            {\\n                result++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1596778,
                "title": "java-sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int windowStart = 0;\\n        int goodSubStrCount = 0;\\n        \\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char ch = s.charAt(windowEnd);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if((windowEnd - windowStart + 1) == 3) {\\n                if(map.size() == 3)\\n                    goodSubStrCount++;\\n                \\n                char sch = s.charAt(windowStart++);\\n                map.put(sch, map.get(sch) - 1);\\n                if(map.get(sch) == 0)\\n                    map.remove(sch);\\n            }\\n        }\\n        \\n        return goodSubStrCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int windowStart = 0;\\n        int goodSubStrCount = 0;\\n        \\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char ch = s.charAt(windowEnd);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if((windowEnd - windowStart + 1) == 3) {\\n                if(map.size() == 3)\\n                    goodSubStrCount++;\\n                \\n                char sch = s.charAt(windowStart++);\\n                map.put(sch, map.get(sch) - 1);\\n                if(map.get(sch) == 0)\\n                    map.remove(sch);\\n            }\\n        }\\n        \\n        return goodSubStrCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443202,
                "title": "python-o-n-time-just-check-if-all-len-3-substrings-are-unique",
                "content": "Since we are only interested in substrings of length 3, iterate through the string and check if all characters\\nin adjacent substrings of length 3 are unique.\\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        ans = 0\\n        for i in range(len(s)-2):\\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        ans = 0\\n        for i in range(len(s)-2):\\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421760,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<n){\\n            if(j-i+1<3){\\n                j++;\\n            }\\n            else if(j-i+1==3){\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j]){\\n                    //char repeated\\n                }\\n                else\\n                    ans++;\\n                j++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<n){\\n            if(j-i+1<3){\\n                j++;\\n            }\\n            else if(j-i+1==3){\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j]){\\n                    //char repeated\\n                }\\n                else\\n                    ans++;\\n                j++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391491,
                "title": "simple-c-solution-with-0-ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length();\\n        if(n<3){\\n            return 0;\\n        }\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n-2){\\n            if(s[i]!=s[j+1] && s[i]!=s[j+2] && s[j+1]!=s[j+2]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nJust simply traverse over the string with window of size 3, let\\'s say you are at index i then check if element at index i-1 and i+1 are not equal or equal to element at index i.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length();\\n        if(n<3){\\n            return 0;\\n        }\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n-2){\\n            if(s[i]!=s[j+1] && s[i]!=s[j+2] && s[j+1]!=s[j+2]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388272,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<=2)\\n            return 0;\\n        int i,c=0;\\n        for(i=0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<=2)\\n            return 0;\\n        int i,c=0;\\n        for(i=0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1379241,
                "title": "c-hashset-approach-72ms-23mb-o-n",
                "content": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        \\n        var strArray = s.ToCharArray(0, s.Length);\\n        var strSet = new HashSet<int>();\\n        var numOfGoodSubstring = 0;\\n        \\n        for (var i = 0; i < strArray.Count(); i++)\\n        {\\n            if (i+2 < strArray.Count())\\n            {\\n                strSet.Add(strArray[i]);\\n                strSet.Add(strArray[i+1]);\\n                strSet.Add(strArray[i+2]);\\n            }            \\n            \\n            if (strSet.Count == 3)\\n            {\\n                numOfGoodSubstring++;\\n            }\\n            strSet.Clear();\\n        }\\n        \\n        return numOfGoodSubstring;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        \\n        var strArray = s.ToCharArray(0, s.Length);\\n        var strSet = new HashSet<int>();\\n        var numOfGoodSubstring = 0;\\n        \\n        for (var i = 0; i < strArray.Count(); i++)\\n        {\\n            if (i+2 < strArray.Count())\\n            {\\n                strSet.Add(strArray[i]);\\n                strSet.Add(strArray[i+1]);\\n                strSet.Add(strArray[i+2]);\\n            }            \\n            \\n            if (strSet.Count == 3)\\n            {\\n                numOfGoodSubstring++;\\n            }\\n            strSet.Clear();\\n        }\\n        \\n        return numOfGoodSubstring;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366864,
                "title": "easy-to-understand-python3-faster-than-99-83-of-python3",
                "content": "\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s)-2):\\n            new = s[i:i+3]\\n            if len(new) == len(set(new)):\\n                counter = counter + 1\\n                \\n        return counter\\n```\\n\\nI know it can be condensed further but it works.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s)-2):\\n            new = s[i:i+3]\\n            if len(new) == len(set(new)):\\n                counter = counter + 1\\n                \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346771,
                "title": "java-clean-solution-why-people-confusing-with-i-1-i-1-all-the-jazz",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<3) return 0;\\n        \\n        int count = 0;\\n        for(int i=0;i+2<s.length();i++){\\n            char a = s.charAt(i);\\n            char b = s.charAt(i+1);\\n            char c = s.charAt(i+2);\\n            \\n            if(a !=b && b!=c && c!=a){\\n                count++; \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<3) return 0;\\n        \\n        int count = 0;\\n        for(int i=0;i+2<s.length();i++){\\n            char a = s.charAt(i);\\n            char b = s.charAt(i+1);\\n            char c = s.charAt(i+2);\\n            \\n            if(a !=b && b!=c && c!=a){\\n                count++; \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296008,
                "title": "kotlin-1-line",
                "content": "```\\nfun countGoodSubstrings(s: String) = s.windowed(3, 1).count { it.toSet().size == 3 }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun countGoodSubstrings(s: String) = s.windowed(3, 1).count { it.toSet().size == 3 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246820,
                "title": "java-sliding-window-approach-not-so-fast-but-intuitive",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        int res = 0, start = 0, end = 3;\\n        \\n        if(s.length() < 3){\\n            return 0;\\n        }\\n\\t        \\n\\t    HashMap<Character, Integer> map = new HashMap<>();\\n\\t        \\n\\t    for(int i = 0 ; i < 3; i++) {\\n\\t    \\t char c  = s.charAt(i);\\n\\t    \\t map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t     }\\n        \\n        if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    }\\n\\t       \\n\\t    while(end<s.length()) {\\n\\t    \\tchar e = s.charAt(end);\\n\\t    \\tchar st= s.charAt(start);\\n            \\n\\t    \\tmap.put(st, map.get(st) - 1);\\n\\t    \\tif(map.get(st) == 0) {\\n\\t    \\t\\t map.remove(st);\\n\\t    \\t }\\n            \\n\\t    \\tmap.put(e, map.getOrDefault(e ,0) + 1);\\n            \\n            if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    \\t   }\\n\\t    \\t   \\n\\t    \\t start++;\\n\\t    \\t end++;\\n\\t    }\\n\\t    return res;  \\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        int res = 0, start = 0, end = 3;\\n        \\n        if(s.length() < 3){\\n            return 0;\\n        }\\n\\t        \\n\\t    HashMap<Character, Integer> map = new HashMap<>();\\n\\t        \\n\\t    for(int i = 0 ; i < 3; i++) {\\n\\t    \\t char c  = s.charAt(i);\\n\\t    \\t map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t     }\\n        \\n        if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    }\\n\\t       \\n\\t    while(end<s.length()) {\\n\\t    \\tchar e = s.charAt(end);\\n\\t    \\tchar st= s.charAt(start);\\n            \\n\\t    \\tmap.put(st, map.get(st) - 1);\\n\\t    \\tif(map.get(st) == 0) {\\n\\t    \\t\\t map.remove(st);\\n\\t    \\t }\\n            \\n\\t    \\tmap.put(e, map.getOrDefault(e ,0) + 1);\\n            \\n            if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    \\t   }\\n\\t    \\t   \\n\\t    \\t start++;\\n\\t    \\t end++;\\n\\t    }\\n\\t    return res;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1238826,
                "title": "js-single-loop-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (!s[i+1] || !s[i+2]) break;\\n        if (s[i] !== s[i+1] && s[i] !== s[i+2] && s[i+1] !== s[i+2]) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (!s[i+1] || !s[i+2]) break;\\n        if (s[i] !== s[i+1] && s[i] !== s[i+2] && s[i+1] !== s[i+2]) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040602,
                "title": "sliding-window-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int j=0;\\n        int i=0;\\n        int n=s.length();\\n        int ans=0;\\n        unordered_map<char,int> m;\\n\\n        while(j<n){\\n            m[s[j]]++;\\n\\n            if(j-i+1 < 3){\\n                j++;\\n            }else{\\n                if(m.size()==3){\\n                    ans++;\\n                }\\n                m[s[i]]--;\\n                if(m[s[i]]==0){\\n                    m.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int j=0;\\n        int i=0;\\n        int n=s.length();\\n        int ans=0;\\n        unordered_map<char,int> m;\\n\\n        while(j<n){\\n            m[s[j]]++;\\n\\n            if(j-i+1 < 3){\\n                j++;\\n            }else{\\n                if(m.size()==3){\\n                    ans++;\\n                }\\n                m[s[i]]--;\\n                if(m[s[i]]==0){\\n                    m.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918330,
                "title": "java-easy-solution-using-one-single-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n            if((s.charAt(i)!=s.charAt(i+1))&&(s.charAt(i)!=s.charAt(i+2))&&(s.charAt(i+2)!=s.charAt(i+1))){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n            if((s.charAt(i)!=s.charAt(i+1))&&(s.charAt(i)!=s.charAt(i+2))&&(s.charAt(i+2)!=s.charAt(i+1))){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880268,
                "title": "easy-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt = 0;\\n        int sz = s.size();\\n        if(sz<3)return 0;\\n        for(int i = 0; i < sz-2; i++){\\n            string sb = s.substr(i,3);\\n            sort(sb.begin(),sb.end());\\n            for(int j = 0; j < 3; j++){\\n                if(j==2)cnt++;\\n                else if(sb[j]==sb[j+1])break;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt = 0;\\n        int sz = s.size();\\n        if(sz<3)return 0;\\n        for(int i = 0; i < sz-2; i++){\\n            string sb = s.substr(i,3);\\n            sort(sb.begin(),sb.end());\\n            for(int j = 0; j < 3; j++){\\n                if(j==2)cnt++;\\n                else if(sb[j]==sb[j+1])break;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782904,
                "title": "easy-java-solution-clean-code-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        int count = 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        while(end < s.length()) {\\n\\n            if(!map.containsKey(s.charAt(end))) {\\n\\n                map.put((s.charAt(end)), 1);\\n                count++;\\n            }\\n\\n            else {\\n\\n                map.put(s.charAt(end), map.get(s.charAt(end)) + 1);\\n\\n                if(map.get(s.charAt(end)) == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if(end - start + 1 < 3) {\\n                end++;\\n            }\\n\\n            else {\\n                if(count == 3) {\\n                    ans++;\\n                }\\n\\n                if(map.containsKey(s.charAt(start))) {\\n\\n                    map.put((s.charAt(start)), map.get(s.charAt(start)) - 1);\\n\\n                    if(map.get(s.charAt(start)) == 0) {\\n                        count--;\\n                    }\\n                }\\n                \\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        int count = 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        while(end < s.length()) {\\n\\n            if(!map.containsKey(s.charAt(end))) {\\n\\n                map.put((s.charAt(end)), 1);\\n                count++;\\n            }\\n\\n            else {\\n\\n                map.put(s.charAt(end), map.get(s.charAt(end)) + 1);\\n\\n                if(map.get(s.charAt(end)) == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if(end - start + 1 < 3) {\\n                end++;\\n            }\\n\\n            else {\\n                if(count == 3) {\\n                    ans++;\\n                }\\n\\n                if(map.containsKey(s.charAt(start))) {\\n\\n                    map.put((s.charAt(start)), map.get(s.charAt(start)) - 1);\\n\\n                    if(map.get(s.charAt(start)) == 0) {\\n                        count--;\\n                    }\\n                }\\n                \\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706864,
                "title": "very-easy-solution-using-set-and-only-one-loop-and-one-condition",
                "content": "# Code\\n``` Javascript []\\nfunction countGoodSubstrings(s){\\n    let res = 0\\n    for(let i = 0; i < s.length; i++){\\n        if(new Set(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```\\n``` Typescript []\\nfunction countGoodSubstrings(s: string): number {\\n    let res: number = 0\\n    for(let i: number = 0; i < s.length; i++){\\n        if(new Set<string>(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction countGoodSubstrings(s){\\n    let res = 0\\n    for(let i = 0; i < s.length; i++){\\n        if(new Set(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```\n``` Typescript []\\nfunction countGoodSubstrings(s: string): number {\\n    let res: number = 0\\n    for(let i: number = 0; i < s.length; i++){\\n        if(new Set<string>(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573719,
                "title": "o-n-substrings-of-size-three-with-distinct-characters-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i, count=0;\\n        if(s.length()<3)\\n            return 0;\\n        for(i=0 ; i<s.length()-2 ; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i+2]!=s[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/972e7951-f10d-45c5-8bcc-abe476d8f044_1685332135.679337.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i, count=0;\\n        if(s.length()<3)\\n            return 0;\\n        for(i=0 ; i<s.length()-2 ; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i+2]!=s[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510529,
                "title": "big-brian-genuis-solution-beats-100000",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse your brian\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse as many method call as possible\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSUPER FAST\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhat\\'s that?\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n            else {\\n                count++;\\n                set.remove(set.iterator().next());\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n        }\\n        if (set.size() == 3) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n            else {\\n                count++;\\n                set.remove(set.iterator().next());\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n        }\\n        if (set.size() == 3) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433317,
                "title": "python-99-92-faster-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return 0\\n        count = 0\\n        for idx in range((n-3)+1):\\n            subString = s[idx:idx+3]\\n            unique_word_len = len(set(subString))\\n            if unique_word_len == 3:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return 0\\n        count = 0\\n        for idx in range((n-3)+1):\\n            subString = s[idx:idx+3]\\n            unique_word_len = len(set(subString))\\n            if unique_word_len == 3:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336698,
                "title": "1876-substrings-of-size-three-with-distinct-characters-java",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,k=3,cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                    cnt++;\\n                  i++;\\n                  j++;  \\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,k=3,cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                    cnt++;\\n                  i++;\\n                  j++;  \\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291434,
                "title": "python-one-line-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        \\n        return sum(s[i] != s[i+1] and s[i]!= s[i+2] and s[i+1] != s[i+2] for i in range(len(s)-2))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        \\n        return sum(s[i] != s[i+1] and s[i]!= s[i+2] and s[i+1] != s[i+2] for i in range(len(s)-2))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147175,
                "title": "python-easy-beats-80-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082466,
                "title": "python-solution-o-n-approach-using-sliding-window-beats-92-submissions",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k=3\\n        i=0 \\n        j=0 \\n        n=len(s)\\n        count=0\\n        while j<n:\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                if s[i]!=s[i+1] and s[i+1]!=s[i+2] and s[i+2]!=s[i]:\\n                    count+=1 \\n                i+=1 \\n                j+=1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k=3\\n        i=0 \\n        j=0 \\n        n=len(s)\\n        count=0\\n        while j<n:\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                if s[i]!=s[i+1] and s[i+1]!=s[i+2] and s[i+2]!=s[i]:\\n                    count+=1 \\n                i+=1 \\n                j+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892544,
                "title": "c-simple-o-n-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        var result = 0;\\n        for(int i=0;i<s.Length-2;i++){\\n            if(s[i] != s[i+1] && s[i+1] != s[i+2] && s[i+2] != s[i]){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        var result = 0;\\n        for(int i=0;i<s.Length-2;i++){\\n            if(s[i] != s[i+1] && s[i+1] != s[i+2] && s[i+2] != s[i]){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876553,
                "title": "brute-force-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\n      //since the minimum length of the substring should be 3 \\n      if(s.length()<3) return 0;\\n      \\n      /* traverse the string and check if a substring of size 3 consists of all distinct characters and increment the ans variable */\\n      int ans = 0;\\n      for(int i=0;i<s.length()-2;++i){\\n         if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i]!=s[i+2]) ans++; \\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\n      //since the minimum length of the substring should be 3 \\n      if(s.length()<3) return 0;\\n      \\n      /* traverse the string and check if a substring of size 3 consists of all distinct characters and increment the ans variable */\\n      int ans = 0;\\n      for(int i=0;i<s.length()-2;++i){\\n         if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i]!=s[i+2]) ans++; \\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836229,
                "title": "substrings-of-size-three-with-distinct-characters",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        int windowStart = 0;\\n        int wLength = 0;\\n      \\n        \\n        for(int windowEnd = 0;windowEnd < s.length() -2 ;windowEnd++){\\n            if(s.charAt(windowEnd) != s.charAt(windowEnd+1) &&  s.charAt(windowEnd+1) != s.charAt(windowEnd+2) && s.charAt(windowEnd) != s.charAt(windowEnd+2)){\\n                    windowStart += s.charAt(windowEnd);\\n            }\\n            \\n               if(windowStart >= 3){\\n                    wLength++;\\n                    windowStart = windowStart - s.charAt(windowEnd);\\n                }\\n            }\\n        \\n        \\n       return wLength;\\n    }\\n}\\n****\\n// useing the sliding window Technique \\n//Time Complexity: O(n3) = O(n) Solution\\n// where 3 is the size of the window\\n******",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2819908,
                "title": "python3-solution-o-n-time-complexity-using-sliding-window",
                "content": "Approach:\\nSlidding Window Technique:\\n1. At each ith position slice the string from i to i + 3 and count the letters\\n2. If there is a substring with all elements with count one, then the substring will be counted else the substring will be skipped\\n3. Then finally return the number of substrings that are good in the given criteria.\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\ti = 0\\n\\tnumberOfSubstring = 0\\n\\twhile i + 3 <= len(s):\\n\\t\\tfirst3 = s[i:i+3]\\n\\t\\tcountFirst3 = Counter(first3)\\n\\t\\tisOne = True\\n\\t\\tfor letter in countFirst3:\\n\\t\\t\\tif countFirst3[letter] != 1:\\n\\t\\t\\t\\tisOne = False\\n\\t\\tif isOne:\\n\\t\\t\\tnumberOfSubstring +=1\\n\\t\\ti +=1\\n\\treturn numberOfSubstring",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Approach:\\nSlidding Window Technique:\\n1. At each ith position slice the string from i to i + 3 and count the letters\\n2. If there is a substring with all elements with count one, then the substring will be counted else the substring will be skipped\\n3. Then finally return the number of substrings that are good in the given criteria.\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\ti = 0\\n\\tnumberOfSubstring = 0\\n\\twhile i + 3 <= len(s):\\n\\t\\tfirst3 = s[i:i+3]\\n\\t\\tcountFirst3 = Counter(first3)\\n\\t\\tisOne = True\\n\\t\\tfor letter in countFirst3:\\n\\t\\t\\tif countFirst3[letter] != 1:\\n\\t\\t\\t\\tisOne = False\\n\\t\\tif isOne:\\n\\t\\t\\tnumberOfSubstring +=1\\n\\t\\ti +=1\\n\\treturn numberOfSubstring",
                "codeTag": "Python3"
            },
            {
                "id": 2596839,
                "title": "easy-understanding-brute-force-using-python",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        substr = []\\n        counter = 0\\n        for i in range(0,len(s)):\\n            if i <= len(s)-3:\\n                substr.append(s[i:i+3])\\n            else:\\n                break\\n        for i in range(len(substr)):\\n            if len(substr[i]) == len(set(substr[i])):\\n                counter += 1\\n        return counter\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        substr = []\\n        counter = 0\\n        for i in range(0,len(s)):\\n            if i <= len(s)-3:\\n                substr.append(s[i:i+3])\\n            else:\\n                break\\n        for i in range(len(substr)):\\n            if len(substr[i]) == len(set(substr[i])):\\n                counter += 1\\n        return counter\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568306,
                "title": "sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        int i = 0, j = 0;\\n        int count = 0;\\n        while(j < s.length())\\n        {\\n            if(j - i + 1 == 3)\\n            {\\n                char ch1 = s[j];\\n                char ch2 = s[j - 1];\\n                char ch3 = s[j - 2];\\n                if(ch1 != ch2 and ch2 != ch3 and ch1 != ch3)\\n                    count++;\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        int i = 0, j = 0;\\n        int count = 0;\\n        while(j < s.length())\\n        {\\n            if(j - i + 1 == 3)\\n            {\\n                char ch1 = s[j];\\n                char ch2 = s[j - 1];\\n                char ch3 = s[j - 2];\\n                if(ch1 != ch2 and ch2 != ch3 and ch1 != ch3)\\n                    count++;\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535673,
                "title": "python-3-multiple-solutions-including-one-liner-most-efficient-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        res=[]\\n        count=0\\n        for i in range(len(s)-2):\\n            res.append(s[i:i+3])\\n        for sub in res:\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            sub=s[i]+s[i+1]+s[i+2]\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\tcount=0\\n\\t\\tfor a,b,c in zip(s,s[1:],s[2:]):\\n\\t\\t\\tif len({a,b,c})==3:\\n\\t\\t\\t\\tcount+=1\\n\\t\\treturn count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        res=[]\\n        count=0\\n        for i in range(len(s)-2):\\n            res.append(s[i:i+3])\\n        for sub in res:\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            sub=s[i]+s[i+1]+s[i+2]\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\tcount=0\\n\\t\\tfor a,b,c in zip(s,s[1:],s[2:]):\\n\\t\\t\\tif len({a,b,c})==3:\\n\\t\\t\\t\\tcount+=1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507366,
                "title": "simple-and-easy-to-understand-java-solution-in-o-n-time-complexity",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2))\\n                ans++;\\n        }\\n               return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2))\\n                ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2465319,
                "title": "sliding-window-with-size-3",
                "content": "Start at index 2, then check if this char is different from the ones pointed at index-1 and at index-2. If all are different, count +1.\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        int i = 2, count = 0;\\n        while(i < s.length())\\n        {\\n            char last = s.charAt(i), middle = s.charAt(i-1), first = s.charAt(i-2);\\n            count += (last != middle && middle != first && first != last) ? 1 : 0;\\n            r++;\\n        }\\n        return count;\\n    }\\n```\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        int i = 2, count = 0;\\n        while(i < s.length())\\n        {\\n            char last = s.charAt(i), middle = s.charAt(i-1), first = s.charAt(i-2);\\n            count += (last != middle && middle != first && first != last) ? 1 : 0;\\n            r++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464600,
                "title": "new-one-simple-boolean-trick-applied-aditya-verma-type-modified-solution-sliding-window",
                "content": "**Here u may wonder how boolean works**\\n\\nThe idea is as WINDOW is size 3. Only possibility is either 1st char repeats more than once.\\nOr 2nd Char repeats more than once. \\nSo whenever u slide. If after reduction its 1 then you have eliminated the duplicate from the window\\n\\nDIDNT Get it YET???\\nDont worry\\nLets take cases\\n* aaa  => here after mpp[a]-- you have val as 2 DUPLICATE Not Eliminated if SLIDED\\n* aab => here after mpp[a]-- you have val as 1 DUPLICATE Eliminated if SLIDED\\n* abb => here after mpp[a]-- you have val as 0 DUPLICATE NOT Eliminated if SLIDED. As you removed a element that is unique only.\\n* So if val of map goes to 1 after reduction then char that was repeated is removed is the CRUX of whole Story.\\n\\n\\n```\\n//O(N) time O(1) Space. As always map takes only 3 chars max 26.\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        unordered_map<char,int> mpp; //char, freq\\n        int i=0;\\n        int j=0;\\n        int N = s.size();\\n        bool flag = true;\\n        int ans_count=0;\\n        \\n        while(j<N){\\n            //calcs\\n            mpp[s[j]]++;\\n            if(mpp[s[j]] >1) flag = false;\\n            \\n            if(j-i+1 < 3){\\n                j++;\\n            }\\n            else if(j-i+1 == 3){\\n                //ans calc\\n                if(flag) ans_count++;\\n                \\n                //slide\\n                char ch = s[i];\\n                mpp[ch]--;\\n                i++;\\n                if(mpp[ch]==1) flag =true;\\n                j++;\\n                \\n            }\\n        }\\n        return ans_count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n//O(N) time O(1) Space. As always map takes only 3 chars max 26.\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        unordered_map<char,int> mpp; //char, freq\\n        int i=0;\\n        int j=0;\\n        int N = s.size();\\n        bool flag = true;\\n        int ans_count=0;\\n        \\n        while(j<N){\\n            //calcs\\n            mpp[s[j]]++;\\n            if(mpp[s[j]] >1) flag = false;\\n            \\n            if(j-i+1 < 3){\\n                j++;\\n            }\\n            else if(j-i+1 == 3){\\n                //ans calc\\n                if(flag) ans_count++;\\n                \\n                //slide\\n                char ch = s[i];\\n                mpp[ch]--;\\n                i++;\\n                if(mpp[ch]==1) flag =true;\\n                j++;\\n                \\n            }\\n        }\\n        return ans_count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455835,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        string res;\\n        vector<string>sk;\\n        vector<int>end;\\n        int c=0;\\n        if(s.length()==1){return 0;}\\n       for(int i=0;i<s.length()-2;i++){\\n           for(int j=i+1;j<s.length();j++){\\n              res+=s[i];\\n               res+=s[j];\\n               res+=s[j+1];\\n               break;\\n           }\\n        sk.push_back(res);\\n           res=\"\";\\n       }\\n        res=\"\";\\n        for(auto i:sk){\\n            res=i;\\n            cout<<res<<\" \";\\n            for(int j=0;j<res.length()-2;j++){\\n                if(res[j]!=res[j+1] && res[j]!=res[j+2] && res[j+1]!=res[j+2]){\\n                    end.push_back(1);\\n                }\\n                else{\\n                    end.push_back(2);\\n                }\\n            }\\n            }\\n        \\n        for(auto i:end){\\n            if(i==1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        string res;\\n        vector<string>sk;\\n        vector<int>end;\\n        int c=0;\\n        if(s.length()==1){return 0;}\\n       for(int i=0;i<s.length()-2;i++){\\n           for(int j=i+1;j<s.length();j++){\\n              res+=s[i];\\n               res+=s[j];\\n               res+=s[j+1];\\n               break;\\n           }\\n        sk.push_back(res);\\n           res=\"\";\\n       }\\n        res=\"\";\\n        for(auto i:sk){\\n            res=i;\\n            cout<<res<<\" \";\\n            for(int j=0;j<res.length()-2;j++){\\n                if(res[j]!=res[j+1] && res[j]!=res[j+2] && res[j+1]!=res[j+2]){\\n                    end.push_back(1);\\n                }\\n                else{\\n                    end.push_back(2);\\n                }\\n            }\\n            }\\n        \\n        for(auto i:end){\\n            if(i==1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2446628,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count = 0\\n        l= []\\n        for i in range(0,len(s)-2):\\n            temp = \\'\\'\\n            if s[i] != s[i+1] and s[i+1] != s[i+2] and s[i] != s[i+2]:\\n                temp = s[i]+s[i+1] + s[i+2]\\n                count = count + 1\\n        return count\\nRuntime: 38 ms, faster than 85.92% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count = 0\\n        l= []\\n        for i in range(0,len(s)-2):\\n            temp = \\'\\'\\n            if s[i] != s[i+1] and s[i+1] != s[i+2] and s[i] != s[i+2]:\\n                temp = s[i]+s[i+1] + s[i+2]\\n                count = count + 1\\n        return count\\nRuntime: 38 ms, faster than 85.92% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440972,
                "title": "simple-sliding-window-o-n",
                "content": "The solution uses simple dynamic sliding window approach. Instead of matching the characters we are checking their last occurrance using a map and if found we are shifting the \\'start\\' of our window to \\'last_occurrance_index + 1\\' position. If the last occurrance is less than the start of our window then we can keep the start as it is because the last occurrance is not in the scope of our current window. \\n\\nOnce this is done, we are calculating the size of current window by using (end - start + 1) and if the answer is equal to or greater than our N=3 the increamenting the counter by 1 and we are done.\\n\\nNote - The original question is asked for fixed size sub array but here we can change the value of N to tackle the follow up questions :-)\\n\\n```\\nvar countGoodSubstrings = function(s) {\\n    const n = 3;\\n    let count = 0;\\n    const map = {};\\n    let start = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        const item = s[end]\\n        if (item in map) {\\n            start = Math.max(start, map[item] + 1)\\n        }\\n        map[item] = end\\n        const size = end - start + 1\\n        \\n        if (size >= n) {\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar countGoodSubstrings = function(s) {\\n    const n = 3;\\n    let count = 0;\\n    const map = {};\\n    let start = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        const item = s[end]\\n        if (item in map) {\\n            start = Math.max(start, map[item] + 1)\\n        }\\n        map[item] = end\\n        const size = end - start + 1\\n        \\n        if (size >= n) {\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437224,
                "title": "c-solution-for-a-general-case-using-unordered-map",
                "content": "This solution will work even for a general window size of k (here given 3).\\n\\nFor creating the window have created a unordered_map which will store the elements. If an elements value becomes equal to 2 in the map it means it is duplicate so we will increment the `duplicate`.\\nAfter the iteration we remove the first element of window from map and if it\\'s value becomes 1 in `umap` it means it is no longer a duplicate so decrement duplicate by 1. \\n\\nWe will only increment answer variable only if duplicate is = 0.\\n```\\n  int countGoodSubstrings(string s) {\\n        if(s.length()<3) return 0;\\n        int n = s.length();\\n        unordered_map<char, int> umap;\\n        int duplicate = 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            umap[s[i]]++; // insert in the window\\n            if(umap[s[i]]==2) duplicate++;\\n            if(i<2) continue; // if this satisfies we don\\'t need to remove anything from map neither increment count the first window is being created\\n            if(!duplicate) count++;\\n            umap[s[i-2]]--;  // remove from the window\\n            if(umap[s[i-2]]==1) duplicate--;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int countGoodSubstrings(string s) {\\n        if(s.length()<3) return 0;\\n        int n = s.length();\\n        unordered_map<char, int> umap;\\n        int duplicate = 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            umap[s[i]]++; // insert in the window\\n            if(umap[s[i]]==2) duplicate++;\\n            if(i<2) continue; // if this satisfies we don\\'t need to remove anything from map neither increment count the first window is being created\\n            if(!duplicate) count++;\\n            umap[s[i-2]]--;  // remove from the window\\n            if(umap[s[i-2]]==1) duplicate--;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393723,
                "title": "python-o-n-sliding-window",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s) - 2):\\n            if len(set(s[i:i+3])) == 3:\\n                counter += 1\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s) - 2):\\n            if len(set(s[i:i+3])) == 3:\\n                counter += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336890,
                "title": "python-short-simple-set",
                "content": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3])) == 3:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3])) == 3:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2327279,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        for(int i=0;i<s.length()-2;i++){\\n            String str = s.substring(i,i+3);\\n            if((str.charAt(0) != str.charAt(1)) && (str.charAt(1) != str.charAt(2)) && (str.charAt(0) != str.charAt(2))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        for(int i=0;i<s.length()-2;i++){\\n            String str = s.substring(i,i+3);\\n            if((str.charAt(0) != str.charAt(1)) && (str.charAt(1) != str.charAt(2)) && (str.charAt(0) != str.charAt(2))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321627,
                "title": "easy-c-3-line-solution-with-o-n-approach",
                "content": "Here we will use sliding window technique by taking the window size as 3 according to the details given.\\nrun a loop till the string length.\\nwith each iteration, check the current 3 variables if they are same and increase count if true;\\n\\n\\t\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tint count=0;\\n\\n\\t\\t\\tfor(int i=0;i+3<=s.length();i++) \\n\\t\\t\\tif((s[i]!=s[i+1]) && (s[i]!=s[i+2]) && (s[i+1]!=s[i+2])) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "Here we will use sliding window technique by taking the window size as 3 according to the details given.\\nrun a loop till the string length.\\nwith each iteration, check the current 3 variables if they are same and increase count if true;\\n\\n\\t\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tint count=0;\\n\\n\\t\\t\\tfor(int i=0;i+3<=s.length();i++) \\n\\t\\t\\tif((s[i]!=s[i+1]) && (s[i]!=s[i+2]) && (s[i+1]!=s[i+2])) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2276337,
                "title": "c-sliding-window-sets-straightforward",
                "content": "![image](https://assets.leetcode.com/users/images/6e09450a-70cc-4736-865e-721641a98f97_1657705720.691491.png)\\n\\n**n==s.size()\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//  Sliding window of constant length!\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tunordered_set<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i+2<s.size();i++){\\n\\t\\t\\t\\tfor(int j=i;j<=i+2;j++) st.insert(s[j]);\\n\\t\\t\\t\\tif(st.size()==3)count++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}    \\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t//  Sliding window of constant length!\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tunordered_set<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i+2<s.size();i++){\\n\\t\\t\\t\\tfor(int j=i;j<=i+2;j++) st.insert(s[j]);\\n\\t\\t\\t\\tif(st.size()==3)count++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2251130,
                "title": "java-sliding-window-1-ms",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if (s.length() < 3) return 0;\\n        int count = 0;\\n        for (int i = 0; i + 2 < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(i + 1) &&\\n                s.charAt(i + 1) != s.charAt(i + 2) &&\\n                s.charAt(i + 2) != s.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if (s.length() < 3) return 0;\\n        int count = 0;\\n        for (int i = 0; i + 2 < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(i + 1) &&\\n                s.charAt(i + 1) != s.charAt(i + 2) &&\\n                s.charAt(i + 2) != s.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241562,
                "title": "java-too-easy-solution-using-hashset",
                "content": "```\\nint c=0;\\n        for(int i=0;i<(s.length()-2);i++){\\n            Set<Character> set=new HashSet<>();\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i+1));\\n            set.add(s.charAt(i+2));\\n            if(set.size()==3)c++;\\n        }\\n        return c;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint c=0;\\n        for(int i=0;i<(s.length()-2);i++){\\n            Set<Character> set=new HashSet<>();\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i+1));\\n            set.add(s.charAt(i+2));\\n            if(set.size()==3)c++;\\n        }\\n        return c;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217193,
                "title": "simple-javascript-solution-using-set-and-for-loop-o-n",
                "content": "\\n\\n\\tvar countGoodSubstrings = function(s) {\\n    let numOfGoodStrings = 0;\\n  \\n    for(let i=1;i<s.length-1;i++) {\\n      numOfGoodStrings += new Set([s[i-1],s[i],s[i+1]]).size===3?1:0;\\n    }\\n    return numOfGoodStrings;\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "\\n\\n\\tvar countGoodSubstrings = function(s) {\\n    let numOfGoodStrings = 0;\\n  \\n    for(let i=1;i<s.length-1;i++) {\\n      numOfGoodStrings += new Set([s[i-1],s[i],s[i+1]]).size===3?1:0;\\n    }\\n    return numOfGoodStrings;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2195038,
                "title": "java-sliding-window-1-ms-faster-than-96-13-of-java-online-submissions",
                "content": "\\n        int i=0, ct=0;\\n        if(m.length()<3)\\n            return 0;\\n        for(i=1;i<m.length()-1;i++)\\n        {\\n          \\nif(m.charAt(i-1) != m.charAt(i) && m.charAt(i) != m.charAt(i+1) && m.charAt(i+1)!= m.charAt(i-1))\\n                ct++;\\n            \\n        \\n        }\\n        return ct;\\n\\t\\t\\n\\t\\t*** If You like the soution please hit up the like button share any thoughts and other solution  on this question  ****\\n\\t\\tThank You",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "\\n        int i=0, ct=0;\\n        if(m.length()<3)\\n            return 0;\\n        for(i=1;i<m.length()-1;i++)\\n        {\\n          \\nif(m.charAt(i-1) != m.charAt(i) && m.charAt(i) != m.charAt(i+1) && m.charAt(i+1)!= m.charAt(i-1))\\n                ct++;\\n            \\n        \\n        }\\n        return ct;\\n\\t\\t\\n\\t\\t*** If You like the soution please hit up the like button share any thoughts and other solution  on this question  ****\\n\\t\\tThank You",
                "codeTag": "Unknown"
            },
            {
                "id": 2187094,
                "title": "best-solution-and-4-method-in-python",
                "content": "\\tclass Solution:\\n\\t\\tdef countGoodSubstrings(self, s: str) -> int:\\n        \\n        #--------------Method-1---------------------\\n        # ans = 0\\n        # for i in range(3,len(s)+1):\\n        #     if len(set(s[i-3:i])) == 3:\\n        #         ans += 1\\n        # return ans\\n        \\n        #------------Method-2 (sliding window)------------------\\n        # c = 0\\n        # st = list(s[ : 3])\\n        # for i in range(3, len(s)):\\n        #     if len(set(st))==3:\\n        #         c += 1\\n        #     # print(st)\\n        #     st.append(s[i])\\n        #     st.pop(0)\\n        #     # print(st)\\n        # if len(set(st))==3:\\n        #     c += 1\\n        # return c\\n        \\n        #-------------Method-3--------------------\\n        # count=0\\n        # for i in range(len(s)-2):\\n        #     if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i+2]==s[i]):\\n        #         count+=0\\n        #     else:\\n        #         count+=1\\n        # return count\\n        \\n        #----------Method-4 (Using Map/Counting )----------------------\\n        if len(s) <3:\\n            return 0\\n        mp = {}\\n        c = 0\\n        left_window = 0\\n        right_window = 1\\n        for i in range(2):\\n            if s[i] not in mp:\\n                mp[s[i]] = 0\\n            mp[s[i]] += 1\\n            #--------OR-------\\n            # if s[i] in mp:\\n            #     mp[s[i]] += 1\\n            # else:\\n            #     mp[s[i]] = 1\\n        # print(mp)\\n        while right_window < len(s)-1 :\\n            right_window += 1\\n            if s[right_window] not in mp:\\n                  mp[s[right_window]] = 0\\n            mp[s[right_window]] += 1\\n            # print(mp)\\n            if all([mp[x]<2 for x in mp]):\\n                c += 1\\n                # print(all([mp[x]<2 for x in mp]))\\n            mp[s[left_window]] -=1\\n            left_window += 1\\n            # print(mp)\\n        return c",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef countGoodSubstrings(self, s: str) -> int:\\n        \\n        #--------------Method-1---------------------\\n        # ans = 0\\n        # for i in range(3,len(s)+1):\\n        #     if len(set(s[i-3:i])) == 3:\\n        #         ans += 1\\n        # return ans\\n        \\n        #------------Method-2 (sliding window)------------------\\n        # c = 0\\n        # st = list(s[ : 3])\\n        # for i in range(3, len(s)):\\n        #     if len(set(st))==3:\\n        #         c += 1\\n        #     # print(st)\\n        #     st.append(s[i])\\n        #     st.pop(0)\\n        #     # print(st)\\n        # if len(set(st))==3:\\n        #     c += 1\\n        # return c\\n        \\n        #-------------Method-3--------------------\\n        # count=0\\n        # for i in range(len(s)-2):\\n        #     if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i+2]==s[i]):\\n        #         count+=0\\n        #     else:\\n        #         count+=1\\n        # return count\\n        \\n        #----------Method-4 (Using Map/Counting )----------------------\\n        if len(s) <3:\\n            return 0\\n        mp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2172777,
                "title": "easy-java-solution-o-n-loop",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() < 3){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i< s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() < 3){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i< s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166220,
                "title": "simple-c-sliding-window-approach-o-n",
                "content": "```\\nint countGoodSubstrings(string s) \\n    {\\n        int i=0;\\n        int j=2;\\n        int c=0;\\n        \\n        while(j<s.length())\\n        {\\n            if(s[i+1]!=s[i] && s[i]!=s[j] && s[j-1]!=s[j])\\n                c++;\\n            i++;\\n            j++;\\n        }\\n     return c;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string s) \\n    {\\n        int i=0;\\n        int j=2;\\n        int c=0;\\n        \\n        while(j<s.length())\\n        {\\n            if(s[i+1]!=s[i] && s[i]!=s[j] && s[j-1]!=s[j])\\n                c++;\\n            i++;\\n            j++;\\n        }\\n     return c;   \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151101,
                "title": "simple-and-best-by-aditya-verma",
                "content": "first, create window size of 3, once created maintain it and check condition.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int> m;\\n        if(s.length()<3) return 0;\\n        int i=0,count=0,j=0,n=s.length();\\n        while(j<n){\\n            m[s[j]]++;\\n            if(j-i+1<3) j++;\\n            else if(j-i+1==3){\\n                if(m.size()==3) count++;\\n                j++;\\n                m[s[i]]--;\\n                if(m[s[i]]==0) m.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int> m;\\n        if(s.length()<3) return 0;\\n        int i=0,count=0,j=0,n=s.length();\\n        while(j<n){\\n            m[s[j]]++;\\n            if(j-i+1<3) j++;\\n            else if(j-i+1==3){\\n                if(m.size()==3) count++;\\n                j++;\\n                m[s[i]]--;\\n                if(m[s[i]]==0) m.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147861,
                "title": "c-fast-easy-simple-unique",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int start = 0;\\n        unordered_map<int,int>ump;\\n        int end = 0;\\n        int ans = 0;\\n        for( end = 0 ; end < 3 && end<s.size() ;end++){\\n            ump[s[end]]++;\\n        }\\n        if(end!=3){\\n            return ans;\\n        }\\n        if(ump.size() == end - start){\\n            ans += 1;\\n        }\\n        for(;end<s.size() ; end++){\\n            ump[s[start]]--;\\n            if(ump[s[start]] == 0){\\n                ump.erase(s[start]);\\n            }\\n            start++;\\n            ump[s[end]]++;\\n            if(ump.size() == end - start +1 ){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int start = 0;\\n        unordered_map<int,int>ump;\\n        int end = 0;\\n        int ans = 0;\\n        for( end = 0 ; end < 3 && end<s.size() ;end++){\\n            ump[s[end]]++;\\n        }\\n        if(end!=3){\\n            return ans;\\n        }\\n        if(ump.size() == end - start){\\n            ans += 1;\\n        }\\n        for(;end<s.size() ; end++){\\n            ump[s[start]]--;\\n            if(ump[s[start]] == 0){\\n                ump.erase(s[start]);\\n            }\\n            start++;\\n            ump[s[end]]++;\\n            if(ump.size() == end - start +1 ){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121793,
                "title": "easiet-java-solution-100-faster",
                "content": "int count = 0;\\n        for(int i = 0; i < s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "int count = 0;\\n        for(int i = 0; i < s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2089344,
                "title": "java-using-sliding-window",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<String>st=new HashSet();\\n        int co=0;\\n        int i=0;\\n        int j=2;\\n        while(j<s.length()){\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(j)&&s.charAt(j)!=s.charAt(i)){\\n                 co++;\\n        }\\n            i++;\\n            j++;\\n        }\\n        return co;\\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<String>st=new HashSet();\\n        int co=0;\\n        int i=0;\\n        int j=2;\\n        while(j<s.length()){\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(j)&&s.charAt(j)!=s.charAt(i)){\\n                 co++;\\n        }\\n            i++;\\n            j++;\\n        }\\n        return co;\\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034244,
                "title": "golang-o-n-sliding-windows",
                "content": "substring is valid if all chars are uniq. So we can check if there\\'s no duplication in the substring (identified by windows of size k)\\n\\n```\\nfunc countGoodSubstrings(s string) int {\\n    // sliding windows of size k\\n    // condition: all uniq chars ~ no duplication\\n    // count the char frequency via freq\\n    freq := make([]int, 128)\\n    ans, dup := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        freq[s[i]]++\\n        if freq[s[i]] == 2 { // duplicate found\\n            dup++\\n        }\\n        \\n\\t\\t// check if window size met\\n        if i < 2 {\\n            continue\\n        }\\n\\n        // is substring valid\\n        if dup == 0 {\\n            ans++\\n        }\\n        // resize windows from left side\\n        freq[s[i - 2]]--\\n        if freq[s[i - 2]] == 1 { // no longer dup, freq decreases from 2 or higher to 1\\n            dup--\\n        }\\n    }\\n    return ans\\n}\\n```\\n\\nComplexity: O(N) time, O(1) space.\\nWe may use `freq := make([]int, 26)` but updating frequency for char would need to change to `freq[s[i] - \\'a\\']`",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    // sliding windows of size k\\n    // condition: all uniq chars ~ no duplication\\n    // count the char frequency via freq\\n    freq := make([]int, 128)\\n    ans, dup := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        freq[s[i]]++\\n        if freq[s[i]] == 2 { // duplicate found\\n            dup++\\n        }\\n        \\n\\t\\t// check if window size met\\n        if i < 2 {\\n            continue\\n        }\\n\\n        // is substring valid\\n        if dup == 0 {\\n            ans++\\n        }\\n        // resize windows from left side\\n        freq[s[i - 2]]--\\n        if freq[s[i - 2]] == 1 { // no longer dup, freq decreases from 2 or higher to 1\\n            dup--\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004084,
                "title": "c-easy-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int>mp;\\n        int winStart=0;\\n        int ans=0;\\n        for(int winEnd=0; winEnd<s.size(); winEnd++){\\n            mp[s[winEnd]]++;\\n            int count=mp.size();\\n            if(winEnd>=3-1){\\n                mp[s[winStart]]--;\\n                if (mp[s[winStart]] == 0) {\\n                    mp.erase(s[winStart]);\\n                }\\n                 if(count==3){\\n                    ans++;\\n                }\\n                winStart++; \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int>mp;\\n        int winStart=0;\\n        int ans=0;\\n        for(int winEnd=0; winEnd<s.size(); winEnd++){\\n            mp[s[winEnd]]++;\\n            int count=mp.size();\\n            if(winEnd>=3-1){\\n                mp[s[winStart]]--;\\n                if (mp[s[winStart]] == 0) {\\n                    mp.erase(s[winStart]);\\n                }\\n                 if(count==3){\\n                    ans++;\\n                }\\n                winStart++; \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992350,
                "title": "python-solution-one-liner",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        count = 0\\n        \\n        for i in range(2, len(s)):\\n            if len(set(s[i-2:i+1])) == 3:\\n                count += 1\\n        \\n        return count\\n```\\n\\n**One-Liner**:\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        return sum(len(set(s[i-2:i+1])) == 3 for i in range(2, len(s)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        count = 0\\n        \\n        for i in range(2, len(s)):\\n            if len(set(s[i-2:i+1])) == 3:\\n                count += 1\\n        \\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        return sum(len(set(s[i-2:i+1])) == 3 for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943515,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        count = 0\\n        currString = \"\"\\n    \\n        for i in range(0, len(s) - 2):\\n            currString = s[i:i+3]\\n\\n            if len(set(currString)) == len(currString):\\n                count += 1\\n\\t\\t\\t\\t\\n            currString = \"\"\\n        \\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        count = 0\\n        currString = \"\"\\n    \\n        for i in range(0, len(s) - 2):\\n            currString = s[i:i+3]\\n\\n            if len(set(currString)) == len(currString):\\n                count += 1\\n\\t\\t\\t\\t\\n            currString = \"\"\\n        \\n        return count",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717329,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964571,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1733429,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2042625,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2035853,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1992869,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1926601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimize Maximum Pair Sum in Array",
        "question_content": "<p>The <strong>pair sum</strong> of a pair <code>(a,b)</code> is equal to <code>a + b</code>. The <strong>maximum pair sum</strong> is the largest <strong>pair sum</strong> in a list of pairs.</p>\r\n\r\n<ul>\r\n\t<li>For example, if we have pairs <code>(1,5)</code>, <code>(2,3)</code>, and <code>(4,4)</code>, the <strong>maximum pair sum</strong> would be <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code>.</li>\r\n</ul>\r\n\r\n<p>Given an array <code>nums</code> of <strong>even</strong> length <code>n</code>, pair up the elements of <code>nums</code> into <code>n / 2</code> pairs such that:</p>\r\n\r\n<ul>\r\n\t<li>Each element of <code>nums</code> is in <strong>exactly one</strong> pair, and</li>\r\n\t<li>The <strong>maximum pair sum </strong>is <strong>minimized</strong>.</li>\r\n</ul>\r\n\r\n<p>Return <em>the minimized <strong>maximum pair sum</strong> after optimally pairing up the elements</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,5,2,3]\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,5,4,2,4,6]\r\n<strong>Output:</strong> 8\r\n<strong>Explanation:</strong> The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>n == nums.length</code></li>\r\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>n</code> is <strong>even</strong>.</li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 1238655,
                "title": "java-c-python-min-max",
                "content": "# **Intuition**\\nSort A,\\nmake the pair with the `min + max`,\\nand continue do this.\\n<br>\\n\\n# **Prove**\\nassuming `amin <= ai <= amax`, `amin <= aj <= amax`,\\nthe combination of `(amin + amax, ai + aj)`,\\nis always no worse than\\nthe combination of `(amin + ai, aj + amax)`.\\n\\nSo we can always pair `amin` with `amax`,\\nand we can reach the optimized result.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n / 2; ++i)\\n            res = max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\\n\\n**Python**\\nO(n) space\\n```py\\n    def minPairSum(self, A):\\n        return max(a + b for a, b in zip(sorted(A), sorted(A)[::-1]))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\n```cpp\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n / 2; ++i)\\n            res = max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\n```py\\n    def minPairSum(self, A):\\n        return max(a + b for a, b in zip(sorted(A), sorted(A)[::-1]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238790,
                "title": "java-easy-solution-faster-than-100-sorting-two-pointer-algorithm",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i < j){\\n            max = Math.max(max, (nums[i++] + nums[j--]));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i < j){\\n            max = Math.max(max, (nums[i++] + nums[j--]));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238666,
                "title": "sort",
                "content": "The smallest number should be matched with the largest one (easy to prove otherwise).\\n\\nSo we sort the array, match the smallest with largest, next smallest with next largest, and so on.\\n\\n**C++**\\n```cpp\\nint minPairSum(vector<int>& nums) {\\n    int res = INT_MIN;\\n    sort(begin(nums), end(nums));\\n    for (auto i = 0; i < nums.size() / 2; ++i)\\n        res = max(res, nums[i] + nums[nums.size() - i - 1]);\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int minPairSum(int[] nums) {\\n    int res = Integer.MIN_VALUE;\\n    Arrays.sort(nums);\\n    for (int i = 0; i < nums.length / 2; ++i)\\n        res = Math.max(res, nums[i] + nums[nums.length - i - 1]);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint minPairSum(vector<int>& nums) {\\n    int res = INT_MIN;\\n    sort(begin(nums), end(nums));\\n    for (auto i = 0; i < nums.size() / 2; ++i)\\n        res = max(res, nums[i] + nums[nums.size() - i - 1]);\\n    return res;\\n}\\n```\n```java\\npublic int minPairSum(int[] nums) {\\n    int res = Integer.MIN_VALUE;\\n    Arrays.sort(nums);\\n    for (int i = 0; i < nums.length / 2; ++i)\\n        res = Math.max(res, nums[i] + nums[nums.length - i - 1]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499532,
                "title": "short-easy-explanation-2-approaches-c-beginner-friendly",
                "content": "**Using sorting**\\n**Time: O(nlogn)**\\n**Space: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums){\\n\\t    //sort the array\\n        sort(nums.begin(),nums.end());\\n        int start=0,end=nums.size()-1,min_max_pair_sum=0;\\n\\t\\t//Observe the pattern of taking the first and last element, second and second last element... and soo onn.. \\n\\t\\t//would help you to minimize the maximum sum.\\n        while(start<end){\\n            min_max_pair_sum=max(min_max_pair_sum,nums[start++]+nums[end--]);\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```\\n**Using freq of elements**\\n**Time: O(n)**\\n**Space: O(100001)**\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int arr[100001]={0};\\n        for(int i:nums){\\n            arr[i]++;\\n        }\\n        int i=0,j=100000,min_max_pair_sum=0;\\n        while(i<=j){\\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            }else if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }else{\\n                if(i+j > min_max_pair_sum) min_max_pair_sum = i+j;\\n                arr[i]--;\\n                arr[j]--; \\n            }\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums){\\n\\t    //sort the array\\n        sort(nums.begin(),nums.end());\\n        int start=0,end=nums.size()-1,min_max_pair_sum=0;\\n\\t\\t//Observe the pattern of taking the first and last element, second and second last element... and soo onn.. \\n\\t\\t//would help you to minimize the maximum sum.\\n        while(start<end){\\n            min_max_pair_sum=max(min_max_pair_sum,nums[start++]+nums[end--]);\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int arr[100001]={0};\\n        for(int i:nums){\\n            arr[i]++;\\n        }\\n        int i=0,j=100000,min_max_pair_sum=0;\\n        while(i<=j){\\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            }else if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }else{\\n                if(i+j > min_max_pair_sum) min_max_pair_sum = i+j;\\n                arr[i]--;\\n                arr[j]--; \\n            }\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368963,
                "title": "java-simple-and-elegant-solution-o-n",
                "content": "```\\npublic int minPairSum(int[] nums) {\\n         \\n        int max = 0;\\n        for(int i = 0; i < nums.length ; i++) if(nums[i] > max) max = nums[i];  \\n        \\n        int[] arr = new int[max+1];  \\n        for(int i = 0; i < nums.length ; i++) arr[nums[i]] += 1;\\n        \\n        int temp = 0;        \\n        int i = 0, j = max;\\n         while(i <= j){\\n             \\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            } \\n            if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }  \\n            if(arr[i] != 0 && arr[j] != 0){\\n                if(i+j > temp) temp = i+j;\\n                arr[i]--;\\n                arr[j]--;                \\n            }\\n        }        \\n        return temp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minPairSum(int[] nums) {\\n         \\n        int max = 0;\\n        for(int i = 0; i < nums.length ; i++) if(nums[i] > max) max = nums[i];  \\n        \\n        int[] arr = new int[max+1];  \\n        for(int i = 0; i < nums.length ; i++) arr[nums[i]] += 1;\\n        \\n        int temp = 0;        \\n        int i = 0, j = max;\\n         while(i <= j){\\n             \\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            } \\n            if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }  \\n            if(arr[i] != 0 && arr[j] != 0){\\n                if(i+j > temp) temp = i+j;\\n                arr[i]--;\\n                arr[j]--;                \\n            }\\n        }        \\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240098,
                "title": "simple-python-3-using-sorting",
                "content": "Sort the given array and find the maximum sum of (min,max) pairs.\\n\\n```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        c=len(nums)-1\\n        for i in range(len(nums)//2):\\n            ans=max(ans,nums[i]+nums[c])\\n            c-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        c=len(nums)-1\\n        for i in range(len(nums)//2):\\n            ans=max(ans,nums[i]+nums[c])\\n            c-=1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1617303,
                "title": "java-binary-search-using-count-array-no-sorting-99-faster-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int[] count = new int[100001];\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i : nums) {\\n            count[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int low = min, high = max;\\n        max = Integer.MIN_VALUE;\\n        while(low <= high) {\\n            if(count[low] == 0) low++; \\n            else if(count[high] == 0) high--;\\n            else {\\n                max = Math.max(low + high, max);\\n                count[low]--;\\n                count[high]--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int[] count = new int[100001];\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i : nums) {\\n            count[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int low = min, high = max;\\n        max = Integer.MIN_VALUE;\\n        while(low <= high) {\\n            if(count[low] == 0) low++; \\n            else if(count[high] == 0) high--;\\n            else {\\n                max = Math.max(low + high, max);\\n                count[low]--;\\n                count[high]--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243428,
                "title": "python-greedy-with-explanation",
                "content": "A = sorted(nums)\\n\\nAssume there is an optimal solution **S** composed by pairs `P1, P2, P3, P4...`\\nWithout generality assuming that A[0], A[-1] reside in pairs P1, P2 respectively.\\n`P1 = (A[0], A[i]), P2 = (A[j], A[-1]) where A[0] <= A[i], A[j] <= A[-1]`\\n\\nReplace P1, P2 with `P1\\' = (A[0], A[-1]), P2\\' = (A[i], A[j])` and I have **S\\'** = **P1\\', P2\\'**, P3, P4...... which **doesn\\'t generate a worse solution** \\n\\n# Proof:\\n1. Sum(P2) >= Sum(P1) , `A[-1] >= A[i] and A[j] >= A[0] => A[-1] + A[j] >= A[i] + A[0]` \\n2. Sum(P2) >= Sum(P1\\'), `A[j] >= A[0]                              => A[j] + A[-1]  >= A[0] + A[-1]`\\n3. Sum(P2) >= Sum(P2\\'), `A[-1] >= A[i]                             => A[j]  + A[-1] >= A[i] + A[j]`\\n\\n=> Sum(P1) <= Sum(P2) and P1\\' and P2\\' make no bigger sum than P2, such adjustment doesn\\'t generate a worse solution\\n\\n-----------------\\n\\nFollow the procedure, we can adjust the optimal solution S to greedy solution G where G is composed by `(A[0], A[-1]), (A[1], A[-2]), (A[2], A[-3]).....` And G should be no worse than S.\\n\\nSince S is the optimal solution and G is no worse than it, G should be one of the optimal solution, too.\\n\\n```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\" \\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return max(nums[i] + nums[-(i + 1)] for i in range(len(nums) // 2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\" \\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return max(nums[i] + nums[-(i + 1)] for i in range(len(nums) // 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238690,
                "title": "c-o-nlogn-easy-solution",
                "content": "The idea behind the approach is to arrange the array in such a manner that the maximum number is added to the minimum number. Thus the array is sorted so as to easily add the maximum number with minimum one, 2nd max to 2nd min...and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        int sum = INT_MIN;\\n        int len = arr.size();\\n        for(int i=0; i<len/2; i++)\\n        {\\n            int sub = arr[i] + arr[len-1-i];\\n            if(sum < sub)\\n                sum = sub;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        int sum = INT_MIN;\\n        int len = arr.size();\\n        for(int i=0; i<len/2; i++)\\n        {\\n            int sub = arr[i] + arr[len-1-i];\\n            if(sum < sub)\\n                sum = sub;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770711,
                "title": "precise-c-minimized-o-n-logn-time-o-1-space",
                "content": "Sort the array and then add max element with the min element to get minimized pair sum, while doing so you could parallelly check the max of these pairs to reduce the code length.\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MIN;\\n        for(int i=0;i<(nums.size()+1)/2;i++)\\n            res=max(res,nums[i]+nums[nums.size()-1-i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MIN;\\n        for(int i=0;i<(nums.size()+1)/2;i++)\\n            res=max(res,nums[i]+nums[nums.size()-1-i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406699,
                "title": "easy-5-line-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int output = Integer.MIN_VALUE;\\n        \\n\\t\\t//This is greedy, so n/2 pairs must be from start and end and move inwards\\n        for(int i=0, j=nums.length - 1; i<nums.length/2; i++, j--)\\n        {\\n            output = Math.max(output, nums[i] + nums[j]);\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int output = Integer.MIN_VALUE;\\n        \\n\\t\\t//This is greedy, so n/2 pairs must be from start and end and move inwards\\n        for(int i=0, j=nums.length - 1; i<nums.length/2; i++, j--)\\n        {\\n            output = Math.max(output, nums[i] + nums[j]);\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380693,
                "title": "simple-java-o-n-solution-runtime-7ms-beats-100",
                "content": "So to minimize the maximum sum of pair, we need to pair small elements with large elements,\\nfirst step\\n----------\\nstore the occurence of number and find the smallest and larget element.\\n\\nsecond step\\n-----------\\n```\\nint start = min; // indexOfSmallestElement \\nint end = max; // indexOfLargestElement\\nmaxPair = 0;\\nwhile(start < end) {\\n\\tif(count[start] == 0) move to start + 1.\\n\\telse if(count[end] == 0) move to end - 1;\\n\\telse { \\n\\t    we can pair start and end.\\n\\t\\tupdate the maxPair;\\n\\t\\tthen we will update the count. and one with lower occurence will be fully used.\\n\\t}\\n}\\n\\nif(count[start] > 1) { // means we can pair start with start\\n\\tupdate the maxPair\\n}\\nelse if(count[end] > 1) { // we can pair end with end\\n\\tupdate the maxPair\\n}\\n\\nreturn maxPair\\n```\\n\\n\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        // Arrays.sort(nums);\\n        // int max = 0;\\n        // int n = nums.length;\\n        // int temp = n / 2;\\n        // for(int i = 0, j = n - 1; i < temp; i++, j--) {\\n        //     max = Math.max(nums[i] + nums[j], max);\\n        // }\\n        return solution2(nums);\\n    }\\n    \\n    public int solution2(int[] nums) {\\n        int[] arr = new int[100001];\\n        int max = 0;\\n        int min = 100001;\\n        for(int i : nums) {\\n            arr[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int start = min; \\n        int end = max;\\n        max = 0;\\n        while(start < end) {\\n            if(arr[start] == 0) start++; \\n            else if(arr[end] == 0) end--;\\n            else {\\n                max = Math.max(start + end, max);\\n                int temp = Math.min(arr[start], arr[end]);\\n                arr[start] -= temp;\\n                arr[end] -= temp;\\n            }\\n        }\\n        \\n        if(arr[start] > 1) {\\n            max = Math.max(max, 2 * start);\\n        }\\n        else if(arr[end] > 1) {\\n            max = Math.max(max, 2 * end);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint start = min; // indexOfSmallestElement \\nint end = max; // indexOfLargestElement\\nmaxPair = 0;\\nwhile(start < end) {\\n\\tif(count[start] == 0) move to start + 1.\\n\\telse if(count[end] == 0) move to end - 1;\\n\\telse { \\n\\t    we can pair start and end.\\n\\t\\tupdate the maxPair;\\n\\t\\tthen we will update the count. and one with lower occurence will be fully used.\\n\\t}\\n}\\n\\nif(count[start] > 1) { // means we can pair start with start\\n\\tupdate the maxPair\\n}\\nelse if(count[end] > 1) { // we can pair end with end\\n\\tupdate the maxPair\\n}\\n\\nreturn maxPair\\n```\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        // Arrays.sort(nums);\\n        // int max = 0;\\n        // int n = nums.length;\\n        // int temp = n / 2;\\n        // for(int i = 0, j = n - 1; i < temp; i++, j--) {\\n        //     max = Math.max(nums[i] + nums[j], max);\\n        // }\\n        return solution2(nums);\\n    }\\n    \\n    public int solution2(int[] nums) {\\n        int[] arr = new int[100001];\\n        int max = 0;\\n        int min = 100001;\\n        for(int i : nums) {\\n            arr[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int start = min; \\n        int end = max;\\n        max = 0;\\n        while(start < end) {\\n            if(arr[start] == 0) start++; \\n            else if(arr[end] == 0) end--;\\n            else {\\n                max = Math.max(start + end, max);\\n                int temp = Math.min(arr[start], arr[end]);\\n                arr[start] -= temp;\\n                arr[end] -= temp;\\n            }\\n        }\\n        \\n        if(arr[start] > 1) {\\n            max = Math.max(max, 2 * start);\\n        }\\n        else if(arr[end] > 1) {\\n            max = Math.max(max, 2 * end);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371016,
                "title": "2-simple-solutions-using-sorting-and-priority-queue-c-solution",
                "content": "1 - Taking **maxheap** to geting always the maximum element in the array \\n      **minheap** to getting the minimum element in the array.\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        priority_queue<int> maxHeap(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>> minHeap(nums.begin(),nums.end());\\n        int n = nums.size()/2;\\n        int ans = INT_MIN;\\n        while(n--){\\n            int first = maxHeap.top();\\n            maxHeap.pop();\\n            int second = minHeap.top();\\n            minHeap.pop();\\n            ans = max(ans,first+second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2 - Simple **sort** the array and always take the **first(minimum)** and **last(maximum)** element from the sorted array.\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        int n = nums.size();\\n        int i = 0;\\n        int k = n/2;\\n        while(k--){\\n            ans = max(ans,nums[i] + nums[n-1-i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        priority_queue<int> maxHeap(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>> minHeap(nums.begin(),nums.end());\\n        int n = nums.size()/2;\\n        int ans = INT_MIN;\\n        while(n--){\\n            int first = maxHeap.top();\\n            maxHeap.pop();\\n            int second = minHeap.top();\\n            minHeap.pop();\\n            ans = max(ans,first+second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        int n = nums.size();\\n        int i = 0;\\n        int k = n/2;\\n        while(k--){\\n            ans = max(ans,nums[i] + nums[n-1-i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087728,
                "title": "python-easy-to-understand-code-beginner-friendly-brute-force",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pair_sum = []\\n        nums.sort()\\n        for i in range(len(nums)//2):\\n            pair_sum.append(nums[i]+nums[len(nums)-i-1])\\n        return max(pair_sum)\\n```\\nTo minimize the maximum pair sum , first sort the list , then add first and last element of this sorted list (i.e. ,  make pair of highest and lowest element in the list ) as in any other pair of elements the highest element will pair up with an element greater than the lowest element - making the maximum sum greater.\\nTherefore pair the 1st and last element , 2nd and second last element and so on.... , and store the sum in an array ( or list ) .\\nReturn the max(arr) to get the required answer.\\n.\\n.\\n.\\n.\\n.\\nPlease Upvote if you find this post useful...",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pair_sum = []\\n        nums.sort()\\n        for i in range(len(nums)//2):\\n            pair_sum.append(nums[i]+nums[len(nums)-i-1])\\n        return max(pair_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241257,
                "title": "c-simple-is-this-really-a-medium-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=0;\\n        for(int i=0,j=nums.size()-1;i<j;++i,--j)\\n            res=max(res,nums[i]+nums[j]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=0;\\n        for(int i=0,j=nums.size()-1;i<j;++i,--j)\\n            res=max(res,nums[i]+nums[j]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238670,
                "title": "a-few-solutions",
                "content": "Sort the input array `A`, then perform a linear scan of each pair `\\uD83D\\uDC49 i..j \\uD83D\\uDC48`, ie. from the outermost to innermost.\\n\\n* Note: This question is similar to [1874. Minimize Product Sum of Two Arrays](https://leetcode.com/problems/minimize-product-sum-of-two-arrays/discuss/1243346/a-few-solutions).\\n\\n---\\n\\n**Procedural Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        var best = -(1e9 + 7).toInt()\\n        A.sort()\\n        var N = A.size\\n        var i = 0\\n        var j = N - 1\\n        while (i < j)\\n            best = Math.max(best, A[i++] + A[j--])\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minPairSum = (A, best = -Infinity) => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        i = 0,\\n        j = N - 1;\\n    while (i < j)\\n        best = Math.max(best, A[i++] + A[j--]);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        i = 0\\n        j = N - 1\\n        while i < j:\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1\\n        return best\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut best = -1000000007;\\n        let mut A = A_.clone();\\n        A.sort();\\n        let (mut i, mut j) = (0, A.len() - 1);\\n        while i < j {\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1;\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minPairSum(VI& A, int best = -(1e9 + 7)) {\\n        sort(A.begin(), A.end());\\n        int N = A.size(),\\n            i = 0,\\n            j = N - 1;\\n        while (i < j)\\n            best = max(best, A[i++] + A[j--]);\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\n**Functional Solutions:** same idea as above to sum pairs; take `A` as sorted left/right halves `L` and `R` correspondingly, then zip `L` with reversed `R` to find the maximum accumulated pair sum.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        A.sort()\\n        var N = A.size\\n        var K = N / 2\\n        var (L, R) = A.toMutableList().chunked(K)\\n        return L.zip(R.asReversed()).map{ (a, b) -> a + b }!!.max()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minPairSum = A => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        K = Math.floor(N / 2);\\n    let L = A.slice(0, K),\\n        R = A.slice(K, N).reverse();\\n    return Math.max(..._.zip(L, R).map(([a, b]) => a + b));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        K = N // 2\\n        L, R = A[:K], A[K:][::-1]\\n        return max(a + b for a, b in zip(L, R))\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut A = A_.clone();\\n        A.sort();\\n        let N = A.len();\\n        let K = N / 2;\\n        A[0..K].iter().zip(A[K..N].iter().rev()).map(|(a, b)| a + b).max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        var best = -(1e9 + 7).toInt()\\n        A.sort()\\n        var N = A.size\\n        var i = 0\\n        var j = N - 1\\n        while (i < j)\\n            best = Math.max(best, A[i++] + A[j--])\\n        return best\\n    }\\n}\\n```\n```\\nlet minPairSum = (A, best = -Infinity) => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        i = 0,\\n        j = N - 1;\\n    while (i < j)\\n        best = Math.max(best, A[i++] + A[j--]);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        i = 0\\n        j = N - 1\\n        while i < j:\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1\\n        return best\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut best = -1000000007;\\n        let mut A = A_.clone();\\n        A.sort();\\n        let (mut i, mut j) = (0, A.len() - 1);\\n        while i < j {\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1;\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minPairSum(VI& A, int best = -(1e9 + 7)) {\\n        sort(A.begin(), A.end());\\n        int N = A.size(),\\n            i = 0,\\n            j = N - 1;\\n        while (i < j)\\n            best = max(best, A[i++] + A[j--]);\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        A.sort()\\n        var N = A.size\\n        var K = N / 2\\n        var (L, R) = A.toMutableList().chunked(K)\\n        return L.zip(R.asReversed()).map{ (a, b) -> a + b }!!.max()!!\\n    }\\n}\\n```\n```\\nlet minPairSum = A => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        K = Math.floor(N / 2);\\n    let L = A.slice(0, K),\\n        R = A.slice(K, N).reverse();\\n    return Math.max(..._.zip(L, R).map(([a, b]) => a + b));\\n};\\n```\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        K = N // 2\\n        L, R = A[:K], A[K:][::-1]\\n        return max(a + b for a, b in zip(L, R))\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut A = A_.clone();\\n        A.sort();\\n        let N = A.len();\\n        let K = N / 2;\\n        A[0..K].iter().zip(A[K..N].iter().rev()).map(|(a, b)| a + b).max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666346,
                "title": "best-o-nlogn-solution",
                "content": "# Approach\\nSort\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int i = 0, j = n - 1;\\n        int ans = 0;\\n        while (i < n && j >= 0) {\\n            ans = max (nums[i] + nums[j], ans);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int i = 0, j = n - 1;\\n        int ans = 0;\\n        while (i < n && j >= 0) {\\n            ans = max (nums[i] + nums[j], ans);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872919,
                "title": "easy-c-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        int i=0;int j=nums.size()-1;\\n        while(i<j){\\n            sum=max(nums[i]+nums[j],sum) ;\\n            i++;\\n            j--;\\n                 \\n        }\\n        return sum;\\n    }     \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        int i=0;int j=nums.size()-1;\\n        while(i<j){\\n            sum=max(nums[i]+nums[j],sum) ;\\n            i++;\\n            j--;\\n                 \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1725067,
                "title": "python-sort-and-two-pointers",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        \\n        res = 0\\n        \\n        while i < j:\\n            res = max(res, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        \\n        res = 0\\n        \\n        while i < j:\\n            res = max(res, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688360,
                "title": "python-two-liner-77-memory-72-faster",
                "content": "```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-1-i] for i in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-1-i] for i in range(len(nums)//2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1266185,
                "title": "java-solution-plus-proof",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {        \\n        Arrays.sort(nums);\\n\\n        int max = 0;\\n        int n = nums.length;\\n        \\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(nums[i] + nums[n-i-1] > max){\\n                max = nums[i] + nums[n-i-1];\\n            }\\n        }\\n        return max;\\n        \\n\\t\\t//this problem is the Minimize Maximum Pair Sum in Array leetcode problem,\\n\\t\\t//basically, you want to pair up all numbers in an array, such that the largest sum of pairs\\n\\t\\t//made is as small as it could possibly be, and return that smallest maximum pair sum\\n        //the code above works because we can prove the following\\n        \\n        //let a,b,c,d be ints, let a < b < c < d, we must show that\\n        // max(a+d,b+c) < max(a+c,b+d)\\n\\t\\t//what we mean to do by this is show\\n\\t\\t//that the maximum of pairing the smallest and largest integers is strictly\\n\\t\\t//less than pairing in any other way than twin pairing (int at position i \\n\\t\\t// is matched with int at position n-1-i)\\n        \\n\\t\\t//Given: \\n\\t\\t//let a,b,c,d be ints\\n\\t\\t//let a < b < c < d\\n\\t\\t//Prove the following: \\n\\t\\t//max(a+d,b+c) < max(a+c,b+d)\\n        \\n\\t\\t//well b+d > a+c always so this becomes\\n        // max(a+d,b+c) < b+d\\n        \\n        //then a+d < b+d  (because a < b) , \\n        // and b+c < b+d  (because c < d)\\n        \\n        //so  max(a+d,b+c) < b+d must always be true,\\n        // if this is true, then the smallest maximum pairing can only be found by pairing\\n\\t\\t//each int with its \\'twin\\' in order\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {        \\n        Arrays.sort(nums);\\n\\n        int max = 0;\\n        int n = nums.length;\\n        \\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(nums[i] + nums[n-i-1] > max){\\n                max = nums[i] + nums[n-i-1];\\n            }\\n        }\\n        return max;\\n        \\n\\t\\t//this problem is the Minimize Maximum Pair Sum in Array leetcode problem,\\n\\t\\t//basically, you want to pair up all numbers in an array, such that the largest sum of pairs\\n\\t\\t//made is as small as it could possibly be, and return that smallest maximum pair sum\\n        //the code above works because we can prove the following\\n        \\n        //let a,b,c,d be ints, let a < b < c < d, we must show that\\n        // max(a+d,b+c) < max(a+c,b+d)\\n\\t\\t//what we mean to do by this is show\\n\\t\\t//that the maximum of pairing the smallest and largest integers is strictly\\n\\t\\t//less than pairing in any other way than twin pairing (int at position i \\n\\t\\t// is matched with int at position n-1-i)\\n        \\n\\t\\t//Given: \\n\\t\\t//let a,b,c,d be ints\\n\\t\\t//let a < b < c < d\\n\\t\\t//Prove the following: \\n\\t\\t//max(a+d,b+c) < max(a+c,b+d)\\n        \\n\\t\\t//well b+d > a+c always so this becomes\\n        // max(a+d,b+c) < b+d\\n        \\n        //then a+d < b+d  (because a < b) , \\n        // and b+c < b+d  (because c < d)\\n        \\n        //so  max(a+d,b+c) < b+d must always be true,\\n        // if this is true, then the smallest maximum pairing can only be found by pairing\\n\\t\\t//each int with its \\'twin\\' in order\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468697,
                "title": "easy-to-understand-c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int ans=0,l=0,r=n.size()-1;\\n        sort(n.begin(),n.end());\\n        for(int i=0;i<n.size()/2;i++){\\n           int p=(n[l]+n[r]);\\n           l++;\\n           r--;\\n           ans=max(p,ans);\\n        }\\n    return ans;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int ans=0,l=0,r=n.size()-1;\\n        sort(n.begin(),n.end());\\n        for(int i=0;i<n.size()/2;i++){\\n           int p=(n[l]+n[r]);\\n           l++;\\n           r--;\\n           ans=max(p,ans);\\n        }\\n    return ans;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241450,
                "title": "use-pointers-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191882,
                "title": "easy-to-understand-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Sort the vector and then pair 1st and last element together and increase the counter till we reach the mid. While traversing also calculate the pair sum and store the maximum in one variable.\\n \\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = INT_MIN;\\n\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<n/2; i++)\\n        {\\n            int pair = nums[i] + nums[n-1-i];\\n            ans = max(ans, pair);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = INT_MIN;\\n\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<n/2; i++)\\n        {\\n            int pair = nums[i] + nums[n-1-i];\\n            ans = max(ans, pair);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099494,
                "title": "java-solution",
                "content": ">\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int start = 0, sum = 0, maxSum = 0;\\n        int end = nums.length - 1;\\n\\n        Arrays.sort(nums);\\n\\n        while (start < end) {\\n            sum = nums[start] + nums[end];\\n\\n            start++;\\n            end--;\\n\\n            if (sum > maxSum) {\\n                maxSum = sum;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int start = 0, sum = 0, maxSum = 0;\\n        int end = nums.length - 1;\\n\\n        Arrays.sort(nums);\\n\\n        while (start < end) {\\n            sum = nums[start] + nums[end];\\n\\n            start++;\\n            end--;\\n\\n            if (sum > maxSum) {\\n                maxSum = sum;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335735,
                "title": "fast-javascript-solution-explanation",
                "content": "1. Sort the numbers in `nums`.\\n2. Have two pointers `i = 0` and `j = nums.length - 1` so that you pair the next smallest number with the next largest number during each iteration\\n3. Sum the pairs before incrementing the pointer to the small half of `nums` and decrementing the pointer to the large half of `nums`.\\n4. Compare the result to the current maximum value encountered so far.\\n5. Return the max value.\\n\\nExample:\\n[3, 5, 2, 3] after sorting is [2, 3, 3, 5]\\n\\n[2, 3, 3, 5]\\n-i--------j max is -Infinity\\nfirst pair sum is (2 + 5 = 7)\\n7 > -Infinity, so update max to 7\\n\\n[2, 3, 3, 5]\\n----i--j---- max is 7\\nsecond pair sum is (3 + 3 = 6)\\n6 < 7, so we don\\'t update max since its already larger\\n\\n```\\nvar minPairSum = function(nums) {\\n    nums.sort((a, b) => a-b);\\n    let i = 0, j = nums.length - 1;\\n    let max = -Infinity;\\n    while (i < j) {\\n        max = Math.max(max, nums[i++] + nums[j--]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minPairSum = function(nums) {\\n    nums.sort((a, b) => a-b);\\n    let i = 0, j = nums.length - 1;\\n    let max = -Infinity;\\n    while (i < j) {\\n        max = Math.max(max, nums[i++] + nums[j--]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245286,
                "title": "c-binary-search-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& nums,int m,int n){\\n        int temp=0;\\n        int x = 0 , y = n-1;\\n        while(x<y){\\n            if(nums[x]+nums[y] > m) return false;\\n            x++;\\n            y--;\\n        }\\n        return true;\\n    }\\n    \\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l = nums[0]+nums[1]; // Minimum possible value of pair sum\\n        int n = nums.size();\\n        int r = nums[n-1]+nums[n-2]; // // Maximum possible value of pair sum\\n        int res = r;\\n        while(l<=r){\\n            int m = l + (r-l)/2; // To avoid over flow\\n            if(isSafe(nums,m,n)){ // if mid is safe then all elements from [mid.....r] are also safe\\n                res = min(res,m);\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& nums,int m,int n){\\n        int temp=0;\\n        int x = 0 , y = n-1;\\n        while(x<y){\\n            if(nums[x]+nums[y] > m) return false;\\n            x++;\\n            y--;\\n        }\\n        return true;\\n    }\\n    \\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l = nums[0]+nums[1]; // Minimum possible value of pair sum\\n        int n = nums.size();\\n        int r = nums[n-1]+nums[n-2]; // // Maximum possible value of pair sum\\n        int res = r;\\n        while(l<=r){\\n            int m = l + (r-l)/2; // To avoid over flow\\n            if(isSafe(nums,m,n)){ // if mid is safe then all elements from [mid.....r] are also safe\\n                res = min(res,m);\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238797,
                "title": "sorting-two-pointers-technique-java-easy-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums.length - 1;\\n        int max = Integer.MIN_VALUE;\\n        while(left < right) {\\n            int sum = nums[left] + nums[right];\\n            max = Math.max(sum, max);\\n            left++;\\n            right--;\\n        }\\n        return max;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums.length - 1;\\n        int max = Integer.MIN_VALUE;\\n        while(left < right) {\\n            int sum = nums[left] + nums[right];\\n            max = Math.max(sum, max);\\n            left++;\\n            right--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3832226,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Sorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n/2; i++) {\\n            ans = max(ans, nums[i] + nums[n-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n/2; i++) {\\n            ans = max(ans, nums[i] + nums[n-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365706,
                "title": "simple-approach-c",
                "content": "\\n- The main question is In which order we should be make pairs of nums?\\n- You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n    \\n    sort(nums.begin(),nums.end());\\n\\n    int l=0 , r=nums.size()-1 , res=0;\\n\\n    while(l<r){\\n        \\n        res = max(res,nums[l]+nums[r]);\\n        l++;\\n        r--;\\n\\n    }\\n    return res;\\n    \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n    \\n    sort(nums.begin(),nums.end());\\n\\n    int l=0 , r=nums.size()-1 , res=0;\\n\\n    while(l<r){\\n        \\n        res = max(res,nums[l]+nums[r]);\\n        l++;\\n        r--;\\n\\n    }\\n    return res;\\n    \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279827,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe best way to find minimize pair sum is to add min no. with maximum number.\\nSo, first sort the array and add first and last element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        //the best way to find minimize pair sum is to add min no. with maximum number.\\n        int maxSum = 0, sum = 0;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            sum = (nums[i] + nums[n - 1 - i]);\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        //the best way to find minimize pair sum is to add min no. with maximum number.\\n        int maxSum = 0, sum = 0;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            sum = (nums[i] + nums[n - 1 - i]);\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233158,
                "title": "easy-solution-using-sorting",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        low=0\\n        high=len(nums)-1\\n        mn=0\\n        while low<high:\\n            mn=max(mn,nums[low]+nums[high])\\n            low+=1\\n            high-=1\\n        return mn\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        low=0\\n        high=len(nums)-1\\n        mn=0\\n        while low<high:\\n            mn=max(mn,nums[low]+nums[high])\\n            low+=1\\n            high-=1\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229755,
                "title": "beats-100-simplest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n       \\n        sort(nums.begin(),nums.end());\\n        int res = 0  , i = 0, j = nums.size()-1; \\n        while(i<j){\\n            res = max(res,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n       \\n        sort(nums.begin(),nums.end());\\n        int res = 0  , i = 0, j = nums.size()-1; \\n        while(i<j){\\n            res = max(res,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214618,
                "title": "easy-sorting-approach-100-acceptance",
                "content": "# Intuition : sorting and finding min,max sum\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]+nums[n-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]+nums[n-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163868,
                "title": "c-sorting-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < (nums.size()>>1); i++){\\n            ans = max(ans,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < (nums.size()>>1); i++){\\n            ans = max(ans,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160063,
                "title": "best-c-solution",
                "content": "# Intuition\\nTake the smallest and largest number pair and return the maximum sum out of them.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0, hi=nums.size()-1,ans=-1;\\n        while(lo<hi){\\n            ans=max(ans,nums[lo++]+nums[hi--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0, hi=nums.size()-1,ans=-1;\\n        while(lo<hi){\\n            ans=max(ans,nums[lo++]+nums[hi--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021212,
                "title": "java-solution-beats-92-of-other-solutions",
                "content": "# Intuition\\nMinimizing max pair is basically sum of starting value and ending values in a sorted array of nums. i.e. if sorted array nums is [a,b,c,d], we need to return Min(a+d, b+c).\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<=nums.length/2;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<=nums.length/2;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021200,
                "title": "java-solution-beats-80-easy-to-understand-6-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<nums.length;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<nums.length;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837059,
                "title": "cpp-simple-solution",
                "content": "# Approach\\nSimply sort the vector use 2 pointers, one pointing the start element and another one at last element of the sorted array then find the maximum sum pair store it in a variable and return it.\\n# Complexity\\n- Time complexity: O(n*logn), 93% faster than Online Cpp Submissions\\n\\n- Space complexity: O(1), 22.20% better than Online Cpp Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int mx=INT_MIN; \\n        sort(n.begin(),n.end());\\n        int i=0,j=n.size()-1;\\n        while(i<j)\\n        {\\n            mx=max(mx,(n[i]+n[j]));\\n            i++;\\n            j--;\\n        }\\n   return mx; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int mx=INT_MIN; \\n        sort(n.begin(),n.end());\\n        int i=0,j=n.size()-1;\\n        while(i<j)\\n        {\\n            mx=max(mx,(n[i]+n[j]));\\n            i++;\\n            j--;\\n        }\\n   return mx; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802418,
                "title": "intuitive-and-easy-4-lines-of-code-c-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we are asked to find the pair whose sum is maximum among all pairs of Nums and the overall sum of that pair must be minimum. So Now, we know that we are required to minimise the Overall sum, for that we will have to first sort(ascending) the array. Then, for minimizing the sum of pairs we will choose one element from starting(minimum) and one from ending(maximum). So that Overall sum of that pair become as minimum as possible..... Then, among all these pairs, we will choose the one which will have maximum sum(among pairs).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, First we will sort the array, then we will make 2 pointers low(from starting index = 0) and high(from ending index = n-1).\\nNow, we will make pairs (nums[low++], nums[high--]).So, the pair having maximum sum among all these pairs will be our answer........\\n# Complexity\\n- Time complexity:  O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low = 0, high = nums.size()-1, maxi = INT_MIN;\\n        while(low < high)  maxi = max(maxi, nums[low++] + nums[high--];\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low = 0, high = nums.size()-1, maxi = INT_MIN;\\n        while(low < high)  maxi = max(maxi, nums[low++] + nums[high--];\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791629,
                "title": "java-solution",
                "content": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum[]= new int[nums.length/2];\\n        int s=0,max=0,j=nums.length-1;\\n        for(int i=0;i<nums.length/2;i++){\\n            s=nums[i]+nums[j--];\\n            if(s>max)\\n                max=s;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum[]= new int[nums.length/2];\\n        int s=0,max=0,j=nums.length-1;\\n        for(int i=0;i<nums.length/2;i++){\\n            s=nums[i]+nums[j--];\\n            if(s>max)\\n                max=s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2739587,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=INT_MIN;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n/2;i++)\\n        {\\n            v.push_back(nums[i]+nums[n-1-i]);\\n            maxi=max(maxi,v[i]);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=INT_MIN;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n/2;i++)\\n        {\\n            v.push_back(nums[i]+nums[n-1-i]);\\n            maxi=max(maxi,v[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2636906,
                "title": "c-easy-to-understand-detailed",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2600232,
                "title": "c-easy-solution-using-sorting-and-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size()/2;i++,n--){\\n            maxi=max(maxi,nums[i]+nums[n]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size()/2;i++,n--){\\n            maxi=max(maxi,nums[i]+nums[n]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526249,
                "title": "2-pointer-approach-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     Arrays.sort(nums) ;\\n        int i=0,j=nums.length-1,sum=0;\\n        int max=Integer.MIN_VALUE;\\n        \\n    while(i<j){\\n    sum=nums[i]+nums[j];\\n        j--;\\n        i++;\\n        max=Math.max(max,sum);\\n    \\n    }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     Arrays.sort(nums) ;\\n        int i=0,j=nums.length-1,sum=0;\\n        int max=Integer.MIN_VALUE;\\n        \\n    while(i<j){\\n    sum=nums[i]+nums[j];\\n        j--;\\n        i++;\\n        max=Math.max(max,sum);\\n    \\n    }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283977,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums.length-1,max=0;\\n        while(i<j)\\n            max = Math.max(nums[i++]+nums[j--],max);\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums.length-1,max=0;\\n        while(i<j)\\n            max = Math.max(nums[i++]+nums[j--],max);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1683310,
                "title": "simple-java-solution-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);        \\n        int i = 0, j = nums.length-1, max = 0;    \\n        while(i < j) {\\n            max = Math.max(nums[i] + nums[j], max);\\n            i++; j--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);        \\n        int i = 0, j = nums.length-1, max = 0;    \\n        while(i < j) {\\n            max = Math.max(nums[i] + nums[j], max);\\n            i++; j--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509768,
                "title": "java-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans =0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n            ans = Math.max(ans, nums[i]+nums[nums.length-i-1]);\\n        }\\n        return ans;        \\n    }\\n}\\n```\\n\\nApproach behind the solution is to sort the array, pair max with min, second max with second min and so on...",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans =0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n            ans = Math.max(ans, nums[i]+nums[nums.length-i-1]);\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292471,
                "title": "python-fast-and-pythonic",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([value+nums[-index] for index, value in enumerate(nums[:len(nums)//2], 1)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([value+nums[-index] for index, value in enumerate(nums[:len(nums)//2], 1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251127,
                "title": "golang-two-pointer-solution-with-quick-explanation",
                "content": "This is solution is pretty simple:\\n\\n* We first sort `nums`\\n* Then we loop through `0` to the mid (From `0` to `len(nums) / 2 - 1`)\\n* Then we check whether `nums[i] + nums[len(nums) - i - 1]` is greater than `res` (Note: `nums[i]` is the left pointer and `nums[len(nums) - i - 1]` is the right).\\n\\n```\\nfunc minPairSum(nums []int) int {\\n\\tsort.Ints(nums)\\n\\tres := 0\\n\\tfor i := 0; i < len(nums)/2; i++ {\\n\\t\\tif nums[i] + nums[len(nums) - i - 1] > res {\\n\\t\\t\\tres = nums[i] + nums[len(nums) - i - 1]\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minPairSum(nums []int) int {\\n\\tsort.Ints(nums)\\n\\tres := 0\\n\\tfor i := 0; i < len(nums)/2; i++ {\\n\\t\\tif nums[i] + nums[len(nums) - i - 1] > res {\\n\\t\\t\\tres = nums[i] + nums[len(nums) - i - 1]\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245692,
                "title": "python-two-lines-sort-and-list-comprehension",
                "content": "```python\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-i-1] for i in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-i-1] for i in range(len(nums)//2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238848,
                "title": "1877-sort-and-sum-from-opposite-ends-till-mid",
                "content": "---\\n\\nCode as-is from contest submission\\n\\nAlgo\\n- Sorting helps in getting minimized sums - when adding from opposite ends\\n- Take the max among them\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var minPairSum = function (A) {\\n        A.sort((a, b) => a - b);\\n\\n        let max = -Infinity;\\n        let n = A.length;\\n        for (let i = 0, j = n - 1; i < j; i++, j--) {\\n            max = Math.max(max, A[i] + A[j]);\\n        }\\n\\n        return max;\\n    };\\n\\n---\\n",
                "solutionTags": [],
                "code": "---\\n\\nCode as-is from contest submission\\n\\nAlgo\\n- Sorting helps in getting minimized sums - when adding from opposite ends\\n- Take the max among them\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var minPairSum = function (A) {\\n        A.sort((a, b) => a - b);\\n\\n        let max = -Infinity;\\n        let n = A.length;\\n        for (let i = 0, j = n - 1; i < j; i++, j--) {\\n            max = Math.max(max, A[i] + A[j]);\\n        }\\n\\n        return max;\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1238722,
                "title": "c-sort-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),mid=n/2,ans=0,j=1;\\n        \\n        for(int i=mid;i<n;i++,j=j+2)\\n            ans = max(ans ,nums[i]+nums[i-j]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),mid=n/2,ans=0,j=1;\\n        \\n        for(int i=mid;i<n;i++,j=j+2)\\n            ans = max(ans ,nums[i]+nums[i-j]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238650,
                "title": "c-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size() / 2; i++) {\\n            ans = max(ans, nums[i] + nums[nums.size() - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size() / 2; i++) {\\n            ans = max(ans, nums[i] + nums[nums.size() - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050767,
                "title": "sort-max-min-max",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(1)$$<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=-1;\\n        for(int i=0;i<nums.size()/2;i++){\\n            maxi=max(maxi,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=-1;\\n        for(int i=0;i<nums.size()/2;i++){\\n            maxi=max(maxi,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993535,
                "title": "easy-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(NlnN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low=0;\\n        int high=nums.size()-1;\\n        int ans=INT_MIN;\\n        while(low<high){\\n            ans=max(ans, nums[low++]+nums[high--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low=0;\\n        int high=nums.size()-1;\\n        int ans=INT_MIN;\\n        while(low<high){\\n            ans=max(ans, nums[low++]+nums[high--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833694,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i = 0; i < nums.length/2; i++) {\\n            int j = nums.length - 1 - i;\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i = 0; i < nums.length/2; i++) {\\n            int j = nums.length - 1 - i;\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774465,
                "title": "c-simple-solution-using-vector",
                "content": "# Flow of Code\\n1. Sorting the vector\\n2. Adding the first element and last element, second element and second last element like that so on and pushing to another vector.\\n3. Returning the largest value of vector as answer.\\n# Flow same logic for other programming languages too.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> A;\\n        int n=nums.size()/2,B=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            A.push_back(nums[i]+nums[B]);\\n            B--;\\n        }\\n        return *max_element(A.begin(),A.end());\\n    }\\n};\\n```\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> A;\\n        int n=nums.size()/2,B=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            A.push_back(nums[i]+nums[B]);\\n            B--;\\n        }\\n        return *max_element(A.begin(),A.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737808,
                "title": "c-super-rare-o-n-solution-clean-code-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        \\n        int freq[100001] = {0};\\n        int maxi = 0;\\n        int l = 0;\\n        int r = nums.size();\\n        for(int i=0; i<r; i++){\\n            freq[nums[i]]++;\\n        }\\n        r = 100000;\\n        while(l <= r){\\n            if(!freq[l]){\\n                l++;\\n                continue;\\n            }\\n            if(!freq[r]){\\n                r--;\\n                continue;\\n            }\\n            maxi = max(maxi,l + r);\\n            freq[l]--;\\n            freq[r]--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        \\n        int freq[100001] = {0};\\n        int maxi = 0;\\n        int l = 0;\\n        int r = nums.size();\\n        for(int i=0; i<r; i++){\\n            freq[nums[i]]++;\\n        }\\n        r = 100000;\\n        while(l <= r){\\n            if(!freq[l]){\\n                l++;\\n                continue;\\n            }\\n            if(!freq[r]){\\n                r--;\\n                continue;\\n            }\\n            maxi = max(maxi,l + r);\\n            freq[l]--;\\n            freq[r]--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690066,
                "title": "3-line-code-97-faster-proper-intuition",
                "content": "# Intuition\\u2705\\u2705\\nSort the vector and then pair 1st and last element together and traverse the vector till size-1. While traversing,  calculate the pair sum and store the maximum in variable(name as mx in below code).\\n\\n# Approach\\u2705\\u2705\\nsince below code is very small.\\n1. Sort the vector \\n2. pair 1st and last element together and increase the counter.\\n3. While traversing also calculate the pair sum and store the maximum in one variable.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\u2705\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572385,
                "title": "c-sorting-two-pointer-greedy",
                "content": "# Intuition\\nJust to know about window technique or two pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGet the nums sorted in non-decreasing order. \\nSet the two pointers one at start and one at end.\\nGet the sum of two numbers at the pointers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N Log-N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = nums.size()-1;\\n        int maxi = 0;\\n        while(i<j){\\n            maxi = max(maxi, nums[i]+nums[j]);\\n            ++i, --j;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n// 4,1,5,1,2,5,1,5,5,4\\n// 1,1,1,2,4,4,5,5,5,5\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = nums.size()-1;\\n        int maxi = 0;\\n        while(i<j){\\n            maxi = max(maxi, nums[i]+nums[j]);\\n            ++i, --j;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n// 4,1,5,1,2,5,1,5,5,4\\n// 1,1,1,2,4,4,5,5,5,5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436887,
                "title": "minimize-maximum-pair-sum-in-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int i, max=INT_MIN;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size()/2 ; i++)\\n        {\\n            if(nums[i]+nums[nums.size()-1-i]>max)\\n            {\\n                max = nums[i]+nums[nums.size()-1-i];\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1d985ac1-6611-48a2-9d29-846dc01fc081_1682613097.1268463.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int i, max=INT_MIN;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size()/2 ; i++)\\n        {\\n            if(nums[i]+nums[nums.size()-1-i]>max)\\n            {\\n                max = nums[i]+nums[nums.size()-1-i];\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410854,
                "title": "o-n-log-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ``O(n)*log(n)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ``O(n)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i <= n / 2; i++){\\n          ans = max(ans, nums[i] + nums[n - 1 - i]);\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i <= n / 2; i++){\\n          ans = max(ans, nums[i] + nums[n - 1 - i]);\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347233,
                "title": "c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1e9;\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            ans=max(nums[i++]+nums[j--],ans);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1e9;\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            ans=max(nums[i++]+nums[j--],ans);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028068,
                "title": "solution-based-on-sorting-and-pairing-javascript",
                "content": "# Intuition\\n1. Sort the array, so that we can have lowest to highest , which will help in pairing\\n2. pair the first and last element and follow this approach for all elements , doing this would help to minimize the pair sum.\\n\\n# Approach\\n1. Sort\\n2. Pair\\n3. keep updating the max sum\\n\\n# Complexity\\n- Time complexity:\\nO(n), since all is done in one loop.\\nO(nlogn),if we inculde the sorting.\\n\\n- Space complexity:\\nO(1), since we do not need any extra array or other memory , just a max variable.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b})\\n    let max=0\\n    let j=nums.length-1\\n    for(let i=0;i<nums.length;i++){\\n        max=Math.max(max,nums[i]+nums[j])\\n        j--\\n    }\\n    return max\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b})\\n    let max=0\\n    let j=nums.length-1\\n    for(let i=0;i<nums.length;i++){\\n        max=Math.max(max,nums[i]+nums[j])\\n        j--\\n    }\\n    return max\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2863236,
                "title": "sort-then-traverse-and-sum-from-front-and-back",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        \\n        \\n        int n = a.size();\\n        int j = n-1;\\n        int i = 0;\\n        int res = 0;\\n        while(i<j)\\n        {\\n            res = max(res,a[i++]+a[j--]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        \\n        \\n        int n = a.size();\\n        int j = n-1;\\n        int i = 0;\\n        int res = 0;\\n        while(i<j)\\n        {\\n            res = max(res,a[i++]+a[j--]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801513,
                "title": "fast-and-memory-efficient-solution",
                "content": "**heap sort** as efficient sorting with max O(nlogn) and then **two-pointers** with for loop that fast O(n). \\n\\n![image](https://assets.leetcode.com/users/images/a659e758-98bc-474f-a747-e7468a58beee_1668118121.382064.jpeg)\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        h = []\\n        heapq.heapify(nums)\\n        for i in range(len(nums)):\\n            h.append(heapq.heappop(nums))\\n            \\n        right = len(h)-1\\n        m = 0\\n        for left in range(len(h)//2):\\n            m = max(m, (h[left]+h[right]))\\n            right -= 1\\n        return m  \\n```\\n\\n```\\nif like this solution:\\n\\treturn \\'Upvote! You\\'re awsome\\'\\nelse:\\n\\treturn \\'Anyway you`re awsome\\'\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        h = []\\n        heapq.heapify(nums)\\n        for i in range(len(nums)):\\n            h.append(heapq.heappop(nums))\\n            \\n        right = len(h)-1\\n        m = 0\\n        for left in range(len(h)//2):\\n            m = max(m, (h[left]+h[right]))\\n            right -= 1\\n        return m  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773617,
                "title": "c-sorting-easy-to-understand",
                "content": "Explanation - Firstly we will sort the Array then we will find the sum of the smallest and largest element of the Array (For example if there are 6 elements in an Array then we will calculate the sum of element at index 0 & 5, 1 & 4, 2 & 3) and will return the max sum of all the pairs.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();   \\n        sort(nums.begin(), nums.end());\\n        \\n        int minSum=nums[0]+nums[n-1];\\n        \\n        int j=n-2;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int sum=nums[i]+nums[j];\\n            minSum=max(sum, minSum);\\n            j--;\\n        }\\n        return minSum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();   \\n        sort(nums.begin(), nums.end());\\n        \\n        int minSum=nums[0]+nums[n-1];\\n        \\n        int j=n-2;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int sum=nums[i]+nums[j];\\n            minSum=max(sum, minSum);\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2664064,
                "title": "simple-nlogn-solution-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,h=nums.size()-1;\\n        int res=INT_MIN;\\n        while(l<h){\\n            res=max(res,nums[l++]+nums[h--]);\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,h=nums.size()-1;\\n        int res=INT_MIN;\\n        while(l<h){\\n            res=max(res,nums[l++]+nums[h--]);\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648216,
                "title": "python-easy-solution-using-two-pointers",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i=0\\n        j=len(nums)-1\\n        m=0\\n        while i<=j:\\n            m=max(m,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i=0\\n        j=len(nums)-1\\n        m=0\\n        while i<=j:\\n            m=max(m,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591035,
                "title": "c-2-ways-to-solve-the-problem",
                "content": "1.  Bucket sort\\n2.  Traditional sort\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> bucket(100001,0);\\n        for (auto &n: nums)\\n            bucket[n]++;\\n        int l = 1; int h = 100000;\\n        int result = INT_MIN;\\n        int pairs = nums.size()/2;\\n        while(pairs) {\\n            while(!bucket[l])\\n                l++;\\n            while(!bucket[h])\\n                h--;\\n            result = max(result,l+h);\\n            bucket[l]--; bucket[h]--;\\n            pairs--;\\n        }\\n        return result;\\n    }\\n    \\n    int minPairSum1(vector<int>& nums) {\\n        int result = 0;\\n        int high = nums.size()-1;\\n        int low = 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        while(low < high) {\\n            result = max(result,nums[low]+nums[high]);\\n            low++; high--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> bucket(100001,0);\\n        for (auto &n: nums)\\n            bucket[n]++;\\n        int l = 1; int h = 100000;\\n        int result = INT_MIN;\\n        int pairs = nums.size()/2;\\n        while(pairs) {\\n            while(!bucket[l])\\n                l++;\\n            while(!bucket[h])\\n                h--;\\n            result = max(result,l+h);\\n            bucket[l]--; bucket[h]--;\\n            pairs--;\\n        }\\n        return result;\\n    }\\n    \\n    int minPairSum1(vector<int>& nums) {\\n        int result = 0;\\n        int high = nums.size()-1;\\n        int low = 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        while(low < high) {\\n            result = max(result,nums[low]+nums[high]);\\n            low++; high--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541247,
                "title": "easy-python-solution-o-nlogn-sort-2-pointers",
                "content": "Logic is that ans will be maximum of all the mini possible pairs in all combinations of 2 elements. These min possible pairs will come when we sort the array and chose pairs inwards from the ends.\\n\\nUpvote if you like the solution.\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        ans = -inf\\n        \\n        while i < j:\\n            ans = max(ans, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        ans = -inf\\n        \\n        while i < j:\\n            ans = max(ans, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541074,
                "title": "java-easy-two-pointer",
                "content": "```\\n Arrays.sort(nums);\\n        int low = 0;\\n        int high = nums.length-1;\\n        int res = 0;\\n        while(low<= high){\\n            int sum = nums[low]+nums[high];\\n            low++;\\n            high--;\\n            res = Math.max(res, sum);\\n            \\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n Arrays.sort(nums);\\n        int low = 0;\\n        int high = nums.length-1;\\n        int res = 0;\\n        while(low<= high){\\n            int sum = nums[low]+nums[high];\\n            low++;\\n            high--;\\n            res = Math.max(res, sum);\\n            \\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540940,
                "title": "java-easy-two-pointer",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int s=0;\\n        int l=nums.length-1;\\n        int sum=0;\\n        int msum=sum;\\n        \\n        while(s<l){\\n            sum=nums[s]+nums[l];\\n            s++;\\n            l--;\\n            msum=Math.max(msum,sum);\\n        }\\n        return msum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int s=0;\\n        int l=nums.length-1;\\n        int sum=0;\\n        int msum=sum;\\n        \\n        while(s<l){\\n            sum=nums[s]+nums[l];\\n            s++;\\n            l--;\\n            msum=Math.max(msum,sum);\\n        }\\n        return msum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501764,
                "title": "c-solution-3-lines-code-leetcode-must-change-this-questions-category-to-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2489453,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int mini=0;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            mini=max(mini,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int mini=0;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            mini=max(mini,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373516,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<n/2;i++){\\n            ans = Math.max(ans,nums[i]+nums[n-i-1]);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<n/2;i++){\\n            ans = Math.max(ans,nums[i]+nums[n-i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2334722,
                "title": "c-sort-o-nlog-n-tc-o-1-sc",
                "content": "\\tint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size()/2;i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "\\tint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size()/2;i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2327399,
                "title": "python-easy-fast-solution-two-pointer",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        \\n        nums.sort()\\n        \\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            ans = max(ans, nums[l]+nums[r])\\n            l += 1\\n            r -= 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        \\n        nums.sort()\\n        \\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            ans = max(ans, nums[l]+nums[r])\\n            l += 1\\n            r -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298875,
                "title": "least-runtime-solution",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        a = nums[:n//2]\\n        b = nums[:n//2 - 1:-1]\\n        maximum = 0\\n        for i, j in zip(a, b):\\n            if i + j > maximum:\\n                maximum = i + j\\n        \\n        return maximum\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        a = nums[:n//2]\\n        b = nums[:n//2 - 1:-1]\\n        maximum = 0\\n        for i, j in zip(a, b):\\n            if i + j > maximum:\\n                maximum = i + j\\n        \\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259015,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int i,j=nums.size()-1,k=-1;\\n        sort(nums.begin(),nums.end());\\n        for(i=0;i<nums.size()/2;i++)\\n        {\\n           k=max(k,nums[i]+nums[j]);\\n            j--;\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int i,j=nums.size()-1,k=-1;\\n        sort(nums.begin(),nums.end());\\n        for(i=0;i<nums.size()/2;i++)\\n        {\\n           k=max(k,nums[i]+nums[j]);\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2228149,
                "title": "java-easy-solution-100",
                "content": "\\n\\nclass Solution {\\n         public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n         public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2205394,
                "title": "my-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length-1;\\n        while(i < j)\\n        {\\n            max = Math.max(nums[i]+nums[j], max);\\n            i++;\\n            j--;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length-1;\\n        while(i < j)\\n        {\\n            max = Math.max(nums[i]+nums[j], max);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2137290,
                "title": "python-2-liner",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, x: List[int]) -> int:\\n        x.sort()\\n        return max(x[i]+x[-i-1] for i in range(len(x)//2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, x: List[int]) -> int:\\n        x.sort()\\n        return max(x[i]+x[-i-1] for i in range(len(x)//2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087701,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        vector <int> v;\\n        sort(nums.begin(),nums.end());\\n        int length=nums.size();\\n        for(int i=0;i<=length/2;i++)\\n        {\\n            v.push_back(nums.at(i)+nums.at(length-i-1));\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        vector <int> v;\\n        sort(nums.begin(),nums.end());\\n        int length=nums.size();\\n        for(int i=0;i<=length/2;i++)\\n        {\\n            v.push_back(nums.at(i)+nums.at(length-i-1));\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086664,
                "title": "scala-one-line-solution",
                "content": "```\\n\\n  def minPairSum(nums: Array[Int]): Int = (nums.sorted.reverse zip nums.sorted).map(n => n._1 + n._2).max\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def minPairSum(nums: Array[Int]): Int = (nums.sorted.reverse zip nums.sorted).map(n => n._1 + n._2).max\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2075670,
                "title": "java-sorting-solution-two-pointers-o-nlogn",
                "content": "Summary: Sort the array. Add the elements from the start and end of the array, and compare the sum with the max sum found so far. Increment the start pointer by 1 and decrement the end pointer by 1 (until start < end).\\n\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        else if(nums.length == 2) return nums[0] + nums[1];\\n        \\n        Arrays.sort(nums);\\n        \\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        \\n        for(; i < j; i ++, j--) {\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        else if(nums.length == 2) return nums[0] + nums[1];\\n        \\n        Arrays.sort(nums);\\n        \\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        \\n        for(; i < j; i ++, j--) {\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072009,
                "title": "c-solution-using-sort-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        if(nums.size() == 2) return nums[0] + nums[1];\\n        sort(nums.begin(), nums.end());\\n        int pos1 = nums.size() / 2 - 1, pos2 = nums.size() / 2, maxVal = INT_MIN;\\n        while(pos1 >= 0)\\n            maxVal = max(maxVal, nums[pos1--] + nums[pos2++]);\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        if(nums.size() == 2) return nums[0] + nums[1];\\n        sort(nums.begin(), nums.end());\\n        int pos1 = nums.size() / 2 - 1, pos2 = nums.size() / 2, maxVal = INT_MIN;\\n        while(pos1 >= 0)\\n            maxVal = max(maxVal, nums[pos1--] + nums[pos2++]);\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003573,
                "title": "very-easy-solution-cpp",
                "content": "*  Sort the vector then add the smallest number with largest one then next smalles number to next largest one and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936210,
                "title": "c-just-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0 ; \\n        int j = nums.size()-1;\\n        int maxPair = 0;\\n        while(i<j){\\n            maxPair=max(nums[i++]+nums[j--],maxPair);\\n        }\\n        return maxPair;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0 ; \\n        int j = nums.size()-1;\\n        int maxPair = 0;\\n        while(i<j){\\n            maxPair=max(nums[i++]+nums[j--],maxPair);\\n        }\\n        return maxPair;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841067,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinPairSum(int[] nums) \\n    {\\n        int max = int.MinValue;\\n        Array.Sort(nums);\\n        \\n        int st=0;\\n        int en=nums.Length-1;\\n        \\n        while(st<en)\\n        {\\n            max = Math.Max(max,nums[st++]+nums[en--]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinPairSum(int[] nums) \\n    {\\n        int max = int.MinValue;\\n        Array.Sort(nums);\\n        \\n        int st=0;\\n        int en=nums.Length-1;\\n        \\n        while(st<en)\\n        {\\n            max = Math.Max(max,nums[st++]+nums[en--]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818157,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0, j = nums.length-1; i <= j; i++, j--){\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0, j = nums.length-1; i <= j; i++, j--){\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814831,
                "title": "easy-sorting-two-pointer",
                "content": "\\'\\'\\'class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int l =0; int h =nums.length-1;\\n        \\n        int maxsum = Integer.MIN_VALUE;\\n        while(l< h){\\n            int sum = nums[l]+nums[h];\\n            maxsum=Math.max(maxsum , sum);\\n            l++;\\n            h--;\\n        }return maxsum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int l =0; int h =nums.length-1;\\n        \\n        int maxsum = Integer.MIN_VALUE;\\n        while(l< h){\\n            int sum = nums[l]+nums[h];\\n            maxsum=Math.max(maxsum , sum);\\n            l++;\\n            h--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791444,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int[] rev = new int[nums.length];    \\n        for(int i=nums.length-1, j=0; i>=0; i--)\\n        {\\n            rev[j++] = nums[i];\\n        }\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int sum = nums[i]+rev[i];\\n            max = Math.max(sum, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int[] rev = new int[nums.length];    \\n        for(int i=nums.length-1, j=0; i>=0; i--)\\n        {\\n            rev[j++] = nums[i];\\n        }\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int sum = nums[i]+rev[i];\\n            max = Math.max(sum, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788821,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn min_pair_sum(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let len = nums.len();\\n        (0..len/2)\\n            .map(|n| nums[n] + nums[len-n-1])\\n            .max()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_pair_sum(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let len = nums.len();\\n        (0..len/2)\\n            .map(|n| nums[n] + nums[len-n-1])\\n            .max()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787724,
                "title": "java-easy-understanding",
                "content": "public int minPairSum(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int start = 0, end = nums.length - 1;\\n        int maxSum = 0;\\n       while(start < end){\\n           if( nums[start] + nums[end] > maxSum){\\n               maxSum =  nums[start] + nums[end];\\n           }\\n           start++;\\n           end--;\\n       }\\n        return maxSum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "public int minPairSum(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int start = 0, end = nums.length - 1;\\n        int maxSum = 0;\\n       while(start < end){\\n           if( nums[start] + nums[end] > maxSum){\\n               maxSum =  nums[start] + nums[end];\\n           }\\n           start++;\\n           end--;\\n       }\\n        return maxSum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1786459,
                "title": "simplest-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n1.  SORT THE ARRAY.\\n2. ADD FIRST AND LAST ELEMENT BECAUSE THAT\\'S HOW WE GET MINIMUM FOR TWO ELEMENT SUM.(largest and smallest)\\n3. AND WE WANT THE LARGEST DIFFERENCE BETWEEN 2.\\n4. SO RETURN THE LARGEST DIFFERENCE.\\n**HAPPY CODING.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int s=0;\\n        int e=nums.size()-1;\\n        int ma=0;\\n        while(s<e){\\n            int a=nums[s]+nums[e];\\n            ma=max(ma,a);\\n            s++;\\n            e--;\\n        }return ma;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int s=0;\\n        int e=nums.size()-1;\\n        int ma=0;\\n        while(s<e){\\n            int a=nums[s]+nums[e];\\n            ma=max(ma,a);\\n            s++;\\n            e--;\\n        }return ma;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780433,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int m = INT_MIN,sum;\\n        for(int i=0,j=nums.size()-1;i<j;i++,j--)\\n        {\\n            sum = nums[i]+nums[j];\\n            if(sum>m)\\n                m = sum;\\n        }\\n        return m;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Two Pointers",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int m = INT_MIN,sum;\\n        for(int i=0,j=nums.size()-1;i<j;i++,j--)\\n        {\\n            sum = nums[i]+nums[j];\\n            if(sum>m)\\n                m = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1763527,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n           result = Math.max(result, nums[i] + nums[nums.length - i - 1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n           result = Math.max(result, nums[i] + nums[nums.length - i - 1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760881,
                "title": "java-easy-solution",
                "content": "\\n\\t\\t\\t\\t   \\n\\t\\t\\t\\t   \\n\\t\\t\\tclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n       Arrays.sort(nums);\\n        int a=nums.length-1;\\n        int max=0;\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n           max=Math.max(max,nums[i]+nums[a--]); \\n        }\\n        \\n        return max;\\n     }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n       Arrays.sort(nums);\\n        int a=nums.length-1;\\n        int max=0;\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n           max=Math.max(max,nums[i]+nums[a--]); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755553,
                "title": "java-easy-clean-and-concise-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int i = 0, j = nums.length - 1;\\n        while(i < j){\\n            int sum = nums[i++] + nums[j--];\\n            if(sum > ans)\\n                ans = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int i = 0, j = nums.length - 1;\\n        while(i < j){\\n            int sum = nums[i++] + nums[j--];\\n            if(sum > ans)\\n                ans = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755196,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans=Integer.MIN_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i< nums.length/2;i++){\\n          ans=Math.macax(nums[i]+nums[nums.length-i-1],ans);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans=Integer.MIN_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i< nums.length/2;i++){\\n          ans=Math.macax(nums[i]+nums[nums.length-i-1],ans);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747931,
                "title": "java-100-fast",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n       int left=0;\\n        int right = nums.length-1;\\n        int result = Integer.MIN_VALUE;\\n        while(left < right){\\n         \\n            result = Math.max(result,nums[left] +nums[right] );\\n            left++;\\n            right--;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n       int left=0;\\n        int right = nums.length-1;\\n        int result = Integer.MIN_VALUE;\\n        while(left < right){\\n         \\n            result = Math.max(result,nums[left] +nums[right] );\\n            left++;\\n            right--;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735982,
                "title": "beginner-friendly-javascript-soltion",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let max = 0;\\n    for(let i=0; i<nums.length/2; i++){\\n        max = Math.max(max , nums[i] + nums[nums.length-1-i]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let max = 0;\\n    for(let i=0; i<nums.length/2; i++){\\n        max = Math.max(max , nums[i] + nums[nums.length-1-i]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734770,
                "title": "java-arraylist-easy-solution",
                "content": "public int minPairSum(int[] nums) {\\n        \\n        if(nums.length == 0)\\n            return 0;\\n\\t\\t\\t\\n        List<Integer> list = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        \\n        for(int i = 0; i< nums.length/2; i++){    \\n            list.add(nums[i] + nums[nums.length - 1 - i]);          \\n        }      \\n        return Collections.max(list);        \\n    }",
                "solutionTags": [],
                "code": "public int minPairSum(int[] nums) {\\n        \\n        if(nums.length == 0)\\n            return 0;\\n\\t\\t\\t\\n        List<Integer> list = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        \\n        for(int i = 0; i< nums.length/2; i++){    \\n            list.add(nums[i] + nums[nums.length - 1 - i]);          \\n        }      \\n        return Collections.max(list);        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1703088,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        \\n        int i =0;\\n        int j = nums.length -1;\\n        \\n        while(i<j){\\n            max = Math.max(max, nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        \\n        int i =0;\\n        int j = nums.length -1;\\n        \\n        while(i<j){\\n            max = Math.max(max, nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699715,
                "title": "two-pointers-sorting-c",
                "content": "```\\nclass Solution {\\npublic:\\n   int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ans=max(ans,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n   int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ans=max(ans,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1653815,
                "title": "python-simple-two-pointers-solution-after-sort",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        res = 0 \\n        l, r = 0, n-1\\n        while l < r:\\n            res = max(res, nums[l] + nums[r])\\n            l += 1\\n            r -= 1\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        res = 0 \\n        l, r = 0, n-1\\n        while l < r:\\n            res = max(res, nums[l] + nums[r])\\n            l += 1\\n            r -= 1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631031,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max=0;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            \\n            max=Math.max(max,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max=0;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            \\n            max=Math.max(max,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589452,
                "title": "easy-one-pass-two-indices",
                "content": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums);\\n};\\n\\n\\nint Solution::minPairSum(vector<int>& nums) {\\n    int size = nums.size();\\n    int min_max_pair_sum;\\n    \\n    sort(nums.begin(), nums.end()); // sort ascending\\n    \\n    int low = 0, high = size-1;\\n    while(low < high) {\\n        if(low == 0)\\n            min_max_pair_sum = nums[low] + nums[high];\\n        else\\n            min_max_pair_sum = max(min_max_pair_sum, nums[low]+nums[high]);\\n        low++, high--;\\n    }\\n    return min_max_pair_sum;\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1584312,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = 0;\\n        int a = 0;\\n        int b = n - 1;\\n        while(a < b)\\n        {\\n            int temp = nums[a] + nums[b];\\n            a++;\\n            b--;\\n            ans = Math.max(ans, temp);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = 0;\\n        int a = 0;\\n        int b = n - 1;\\n        while(a < b)\\n        {\\n            int temp = nums[a] + nums[b];\\n            a++;\\n            b--;\\n            ans = Math.max(ans, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1547862,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int maxSum=0;\\n        Arrays.sort(nums);\\n        \\n        int i =0, j = nums.length-1;\\n        while(i < j){\\n           int sum = nums[i] + nums[j];\\n            if(sum>maxSum){\\n                maxSum = sum;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int maxSum=0;\\n        Arrays.sort(nums);\\n        \\n        int i =0, j = nums.length-1;\\n        while(i < j){\\n           int sum = nums[i] + nums[j];\\n            if(sum>maxSum){\\n                maxSum = sum;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526182,
                "title": "c-sort-two-pointers",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) \\n    {\\n        if(nums == null || nums.Length == 0) return 0;\\n        \\n        Array.Sort(nums);\\n        \\n        int maxSum = 0;\\n        \\n        int i = 0;\\n        int j = nums.Length-1;\\n        \\n        while(i < j)\\n        {\\n            int sum = nums[i++] + nums[j--];\\n            maxSum = Math.Max(sum,maxSum);\\n        }        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) \\n    {\\n        if(nums == null || nums.Length == 0) return 0;\\n        \\n        Array.Sort(nums);\\n        \\n        int maxSum = 0;\\n        \\n        int i = 0;\\n        int j = nums.Length-1;\\n        \\n        while(i < j)\\n        {\\n            int sum = nums[i++] + nums[j--];\\n            maxSum = Math.Max(sum,maxSum);\\n        }        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522618,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0, j = nums.length-1, ans = Integer.MIN_VALUE;\\n        while(i < j)\\n        {\\n            ans = Math.max(nums[i++]+nums[j--],ans);\\n        }\\n        \\n        return ans;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0, j = nums.length-1, ans = Integer.MIN_VALUE;\\n        while(i < j)\\n        {\\n            ans = Math.max(nums[i++]+nums[j--],ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1506956,
                "title": "easy-problem-two-pointer-c-ac",
                "content": "1) sort the array\\n2) two pointer approach\\n3) keep updating the max_sum\\n4) return the max_sum\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max_sum=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int sum=nums[i]+nums[j];\\n            max_sum=max(sum,max_sum);\\n            i++;\\n            j--;\\n        }\\n        return max_sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max_sum=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int sum=nums[i]+nums[j];\\n            max_sum=max(sum,max_sum);\\n            i++;\\n            j--;\\n        }\\n        return max_sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443821,
                "title": "java-7-line-ez",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int y = nums.length-1-i;\\n            max = (nums[i]+nums[y] > max) ? nums[i] + nums[y] : max;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int y = nums.length-1-i;\\n            max = (nums[i]+nums[y] > max) ? nums[i] + nums[y] : max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1413885,
                "title": "simple-c-using-2pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int l=0;\\n        int r = nums.size()-1;\\n        int maxx = INT_MIN;\\n        while(l<r) {\\n            maxx = max(maxx, nums[l] + nums[r]);\\n            l++;\\n            r--;\\n        }\\n        return maxx;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int l=0;\\n        int r = nums.size()-1;\\n        int maxx = INT_MIN;\\n        while(l<r) {\\n            maxx = max(maxx, nums[l] + nums[r]);\\n            l++;\\n            r--;\\n        }\\n        return maxx;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359976,
                "title": "sort-and-zip-98-speed",
                "content": "Runtime: 1108 ms, faster than 97.68%\\nMemory Usage: 28.1 MB, less than 28.84%\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        half_len_nums = len(nums) // 2\\n        return max(a + b for a, b in zip(nums[:half_len_nums:],\\n                                         nums[-1:half_len_nums - 1: -1]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        half_len_nums = len(nums) // 2\\n        return max(a + b for a, b in zip(nums[:half_len_nums:],\\n                                         nums[-1:half_len_nums - 1: -1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348644,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     \\n        Arrays.sort(nums);\\n        int left = 0, right = nums.length-1;\\n        int res=0; \\n        \\n        while(left < right){\\n            res = Math.max(res,nums[left]+nums[right]);  \\n            left++;\\n            right--;  \\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     \\n        Arrays.sort(nums);\\n        int left = 0, right = nums.length-1;\\n        int res=0; \\n        \\n        while(left < right){\\n            res = Math.max(res,nums[left]+nums[right]);  \\n            left++;\\n            right--;  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339219,
                "title": "simple-c-solution",
                "content": "```\\n   int minPairSum(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n/2;i++){\\n            ans=max(ans,arr[i]+arr[n-1-i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int minPairSum(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n/2;i++){\\n            ans=max(ans,arr[i]+arr[n-1-i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1328364,
                "title": "easy-c-with-explanation",
                "content": "**Intution** :\\n**Sort** nums,\\nMake the pair with the **min + max,**\\nand continue do this\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int max_min = INT_MIN;\\n        int sum = 0;\\n        int i = 0; int j = n-1;\\n        while(i < j)\\n        {\\n            sum = nums[i]+nums[j];\\n            max_min = max(max_min,sum);\\n            i++;\\n            j--;\\n        }    \\n        return max_min;   \\n        }\\n};\\n```\\nImage Description :\\n![image](https://assets.leetcode.com/users/images/b45c4118-d377-48af-812a-5a81a07d0dc2_1625910545.8103118.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int max_min = INT_MIN;\\n        int sum = 0;\\n        int i = 0; int j = n-1;\\n        while(i < j)\\n        {\\n            sum = nums[i]+nums[j];\\n            max_min = max(max_min,sum);\\n            i++;\\n            j--;\\n        }    \\n        return max_min;   \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313363,
                "title": "c-sort-solution",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        \\n        Array.Sort(nums);\\n\\n        var max = 0;\\n        for (int i = 0; i < nums.Length / 2; i++) {\\n            max = Math.Max(max, nums[i] + nums[nums.Length - 1 - i]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        \\n        Array.Sort(nums);\\n\\n        var max = 0;\\n        for (int i = 0; i < nums.Length / 2; i++) {\\n            max = Math.Max(max, nums[i] + nums[nums.Length - 1 - i]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307462,
                "title": "javascript-solution-using-sorting-and-two-pointer-technique",
                "content": "```\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var i = 0\\n    var j = nums.length-1\\n    var maxx = -(10**9)\\n    while(i<j){\\n        if(nums[i]+nums[j]>maxx){\\n            maxx = nums[i]+nums[j]\\n        }\\n        i++\\n        j--\\n    }\\n    return maxx\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var i = 0\\n    var j = nums.length-1\\n    var maxx = -(10**9)\\n    while(i<j){\\n        if(nums[i]+nums[j]>maxx){\\n            maxx = nums[i]+nums[j]\\n        }\\n        i++\\n        j--\\n    }\\n    return maxx\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302487,
                "title": "c-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0;i<nums.size()/2;i++) ans=max(ans,nums[i]+nums[nums.size()-1-i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0;i<nums.size()/2;i++) ans=max(ans,nums[i]+nums[nums.size()-1-i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282386,
                "title": "simple-c-solution-using-two-pointers",
                "content": "```\\nint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int i=0,j=n-1,maxi=0,sum=0;\\n        while(i<j){\\n            sum=nums[i]+nums[j];\\n            maxi=max(maxi,sum);\\n            sum=0;\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int i=0,j=n-1,maxi=0,sum=0;\\n        while(i<j){\\n            sum=nums[i]+nums[j];\\n            maxi=max(maxi,sum);\\n            sum=0;\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276736,
                "title": "python3-simple-solution-using-sorting-and-single-while-loop-beats-90-users",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i,j = 0, len(nums)-1\\n        res = []\\n        while i < j:\\n            res.append(nums[i]+nums[j])\\n            i += 1\\n            j -= 1\\n        return max(res)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i,j = 0, len(nums)-1\\n        res = []\\n        while i < j:\\n            res.append(nums[i]+nums[j])\\n            i += 1\\n            j -= 1\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275361,
                "title": "java-easy-solution-sort-then-two-pointer-o-nlogn-n-2",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n       Arrays.sort(nums);\\n        \\n        int low=0;\\n        int high=nums.length-1;\\n        int max=0;\\n        while(low<high)\\n        {            \\n            max=Math.max(max,(nums[low]+nums[high]));\\n            low++;\\n            high--;               \\n        }\\n        \\n        return max;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n       Arrays.sort(nums);\\n        \\n        int low=0;\\n        int high=nums.length-1;\\n        int max=0;\\n        while(low<high)\\n        {            \\n            max=Math.max(max,(nums[low]+nums[high]));\\n            low++;\\n            high--;               \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1263319,
                "title": "javascript-solution-faster-than-80-simple-solutoin",
                "content": "var minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b});\\n    let newarr = [];\\n    let j = nums.length-1;\\n    for(let i=0;i<nums.length;i++)\\n        {\\n            let temp = nums[i] + nums[j];\\n            newarr.push(temp);\\n            j--;\\n        }\\n    return Math.max(...newarr);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b});\\n    let newarr = [];\\n    let j = nums.length-1;\\n    for(let i=0;i<nums.length;i++)\\n        {\\n            let temp = nums[i] + nums[j];\\n            newarr.push(temp);\\n            j--;\\n        }\\n    return Math.max(...newarr);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1257193,
                "title": "java-easy-greedy",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] arr) {\\n        Arrays.sort(arr);\\n        int ans = 0;\\n       for(int i = 0,j = arr.length-1 ; i<=j ;i++,j--){\\n         \\n         ans = Math.max(ans,arr[i]+arr[j]);\\n         \\n       }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] arr) {\\n        Arrays.sort(arr);\\n        int ans = 0;\\n       for(int i = 0,j = arr.length-1 ; i<=j ;i++,j--){\\n         \\n         ans = Math.max(ans,arr[i]+arr[j]);\\n         \\n       }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256494,
                "title": "c-short-crispy-to-the-point",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());  // Sort the array\\n        int ans=0;\\n        int n=nums.size()-1;\\n        \\n        for(int i=0;i<=n/2;i++){        // Sum first and last term , then second and second \\n            int x=nums[i]+nums[n-i];    // last and go on and find the maximum i.e. answer\\n            ans=max(ans,x);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());  // Sort the array\\n        int ans=0;\\n        int n=nums.size()-1;\\n        \\n        for(int i=0;i<=n/2;i++){        // Sum first and last term , then second and second \\n            int x=nums[i]+nums[n-i];    // last and go on and find the maximum i.e. answer\\n            ans=max(ans,x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1249815,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minPairSum = nums => {\\n    nums.sort((a,b) => a - b);\\n    let maxSum = 0;\\n    const middle = nums.length/2;\\n    \\n    for (let i = 0; i < middle; i++) {\\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - i - 1])\\n    }\\n    \\n    return maxSum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minPairSum = nums => {\\n    nums.sort((a,b) => a - b);\\n    let maxSum = 0;\\n    const middle = nums.length/2;\\n    \\n    for (let i = 0; i < middle; i++) {\\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - i - 1])\\n    }\\n    \\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249217,
                "title": "c-easy-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        //sort the array\\n        sort(nums.begin(),nums.end());\\n        \\n        //the reason behind sorting is we can get the kth largest and kth smallest element from the array\\n        //the sum would be mninimum if we add a small number and a large number\\n        int maxi=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int currSum=0;\\n        while(i<j)\\n        {\\n            currSum=nums[i]+nums[j];\\n            maxi=max(maxi,currSum); //get the maximum pair sum\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        //sort the array\\n        sort(nums.begin(),nums.end());\\n        \\n        //the reason behind sorting is we can get the kth largest and kth smallest element from the array\\n        //the sum would be mninimum if we add a small number and a large number\\n        int maxi=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int currSum=0;\\n        while(i<j)\\n        {\\n            currSum=nums[i]+nums[j];\\n            maxi=max(maxi,currSum); //get the maximum pair sum\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248013,
                "title": "o-nlogn-c-surely-easier-than-medium-level",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minPairSum(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n/2;i++)\\n            ans=max(nums[i]+nums[n-1-i],ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minPairSum(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n/2;i++)\\n            ans=max(nums[i]+nums[n-1-i],ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245842,
                "title": "python3-simple-solution-beats-99-43-of-python3-submissions",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()        \\n        return max([nums[x]+nums[-x-1] for x in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()        \\n        return max([nums[x]+nums[-x-1] for x in range(len(nums)//2)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241834,
                "title": "c-sort-2-indices",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        Array.Sort(nums);\\n        int r = 0, i = 0, j = nums.Length - 1;\\n        while (i < j) {\\n            r = Math.Max(r, nums[i++] + nums[j--]);\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        Array.Sort(nums);\\n        int r = 0, i = 0, j = nums.Length - 1;\\n        while (i < j) {\\n            r = Math.Max(r, nums[i++] + nums[j--]);\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240324,
                "title": "c-0-n-log-n-with-explanations-two-pointer-5-lines",
                "content": "If we want to Minimize Maximum sum , First sort the array ,Now we can pick lowest value[0] with the higest value [n-1],and so on so that every elemet is in pair and Minimize Maximum sum.\\n0 , n-1\\n1, n-2\\n2,n-3\\n|\\n|\\n\\nTwo Pointer types;\\n\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        size_t n = nums.size();\\n        int pairSum=0,ans=0;\\n        \\n        for(int i=0;i<n/2;i++){\\n            pairSum = nums[i] + nums[n-1-i];\\n            ans = max(ans,pairSum);\\n        } \\n        return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        size_t n = nums.size();\\n        int pairSum=0,ans=0;\\n        \\n        for(int i=0;i<n/2;i++){\\n            pairSum = nums[i] + nums[n-1-i];\\n            ans = max(ans,pairSum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1239731,
                "title": "full-explanation-python-solution",
                "content": "**Approach: The idea is to first sort the given array and then iterate over the loop to form pairs (i, j) where i would start from 0 and j would start from end of array correspondingly. Increment i and Decrement j to form the next pair and so on.\\nBelow is the implementation of above approach. **\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        i=0\\n        j=len(nums)-1\\n        res=0\\n        while(i<j):\\n            res=max(res,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        i=0\\n        j=len(nums)-1\\n        res=0\\n        while(i<j):\\n            res=max(res,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239179,
                "title": "java-clean-concise-optimal-code-sort-approach-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        Arrays.sort (nums);\\n        \\n        for (int i = 0, j = nums.length - 1; i < j; i++, j--) {\\n            maxSum = Math.max (maxSum, nums[i] + nums[j]);\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        Arrays.sort (nums);\\n        \\n        for (int i = 0, j = nums.length - 1; i < j; i++, j--) {\\n            maxSum = Math.max (maxSum, nums[i] + nums[j]);\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238987,
                "title": "faster-then-100-of-solutions-easy-to-understand",
                "content": "```\\npublic int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int pairSum = 0;\\n        for (int i = 0; i < nums.length / 2; ++i)\\n            pairSum = Math.max(pairSum, nums[i] + nums[nums.length - i - 1]);\\n        return pairSum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int pairSum = 0;\\n        for (int i = 0; i < nums.length / 2; ++i)\\n            pairSum = Math.max(pairSum, nums[i] + nums[nums.length - i - 1]);\\n        return pairSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238932,
                "title": "c-easy-solution",
                "content": "**Approach**: The idea is to first sort the given array and then \\nIterate over the loop to form pairs (i, j) \\n \\nWhere  i would start from 0 and j would start from end of array correspondingly. \\nIncrement i and Decrement j to form the next pair.\\nthen find the maximum sum of the pair.\\n \\n ```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            nums[i] = nums[i] + nums[j];\\n            if(nums[i]>ans)\\n                ans = nums[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            nums[i] = nums[i] + nums[j];\\n            if(nums[i]>ans)\\n                ans = nums[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238919,
                "title": "python-sort",
                "content": "It can easily be seen that we have to pair the smallest element with largest element and then second smallest element with second largest element and so on.\\n\\nThen we will compute the sum of all pairs and then return the maximum sum.\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pairs = []\\n        nums = sorted(nums)\\n        n = len(nums)\\n        for i in range(len(nums)//2):\\n            a = [nums[i],nums[n-i-1]]\\n            pairs.append(a)\\n        sum_ = []\\n        for i,j in pairs:\\n            sum_.append(i+j)\\n        return max(sum_)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pairs = []\\n        nums = sorted(nums)\\n        n = len(nums)\\n        for i in range(len(nums)//2):\\n            a = [nums[i],nums[n-i-1]]\\n            pairs.append(a)\\n        sum_ = []\\n        for i,j in pairs:\\n            sum_.append(i+j)\\n        return max(sum_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238865,
                "title": "python-python3-solution-in-5-lines-with-explanation",
                "content": "**Explanation:**\\n1. Sort the given list\\n2. Since it is a sorted list it will in the order of lowest to highest simple add kth smallest and kth largest element and append it to the another list or keep a max variable and change the maximum value while traversing itself.\\n3. Finally return the maximum element\\n\\n**Example:**\\nnums : [3,5,4,2,4,6]\\n1. [2,3,4,4,5,6]\\n2. (2+8),(3+5),(4+4) = [8,8,8]\\n3. max([8,8,8]) = 8\\n\\n**Code:**\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort() # sort the numbers\\n        lis = [] # to store the res and it takes O(n) space complexity\\n        for i in range(len(nums)//2): # traverse the loop to length(nums)/2 times\\n            lis.append(nums[i]+nums[~i]) #add the indexes 0+(-1),1+(-2)...goes on till n//2 times\\n        return max(lis) # return the maximum element in the list\\n```\\n\\n**Using max variable**\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()# sort the numbers\\n        maxi = 0 # to store the maximum value and it takes only O(1) space complexity\\n        for i in range(len(nums)//2):# traverse the loop to length(nums)/2 times\\n            maxi = max(maxi,nums[i]+nums[~i])#add the indexes 0+(-1),1+(-2)...goes on till n//2 times and compute the maxi value simultaneously\\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort() # sort the numbers\\n        lis = [] # to store the res and it takes O(n) space complexity\\n        for i in range(len(nums)//2): # traverse the loop to length(nums)/2 times\\n            lis.append(nums[i]+nums[~i]) #add the indexes 0+(-1),1+(-2)...goes on till n//2 times\\n        return max(lis) # return the maximum element in the list\\n```\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()# sort the numbers\\n        maxi = 0 # to store the maximum value and it takes only O(1) space complexity\\n        for i in range(len(nums)//2):# traverse the loop to length(nums)/2 times\\n            maxi = max(maxi,nums[i]+nums[~i])#add the indexes 0+(-1),1+(-2)...goes on till n//2 times and compute the maxi value simultaneously\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238803,
                "title": "simple-sorting-technique-2-pointers-easy-solution",
                "content": "class Solution {\\n\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n        int max = 0;\\n        while(lo < hi) {\\n            max = Math.max(max,(nums[lo] + nums[hi]));\\n            lo++;\\n            hi--;\\n        } \\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n        int max = 0;\\n        while(lo < hi) {\\n            max = Math.max(max,(nums[lo] + nums[hi]));\\n            lo++;\\n            hi--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238733,
                "title": "simple-c-sort-solution",
                "content": "```\\n// Runtime: 212 ms, faster than 100.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\n// Memory Usage: 96.3 MB, less than 50.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        int ans=INT_MIN;\\n        // make pairs with smallest ans largest element and find max sum\\n        for(int i=0;i<A.size()/2;++i)\\n            ans=max(ans,A[i] + A[A.size()-i-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Runtime: 212 ms, faster than 100.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\n// Memory Usage: 96.3 MB, less than 50.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        int ans=INT_MIN;\\n        // make pairs with smallest ans largest element and find max sum\\n        for(int i=0;i<A.size()/2;++i)\\n            ans=max(ans,A[i] + A[A.size()-i-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238664,
                "title": "java-simple-sorting",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0; i < n / 2; i++) sum = Math.max(sum, nums[i] + nums[n - 1 - i]);\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0; i < n / 2; i++) sum = Math.max(sum, nums[i] + nums[n - 1 - i]);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1238653,
                "title": "easy-explanation-with-code",
                "content": "**Approach:** \\n1. Maximum pair sum can only be obtained, if we pair up the maximum element with its minimum counterpart.\\n2. This can be done simply by sorting the vector, and adding the maximum to its minimum counterpart, i.e - we sum up the last and the first element, and likewise.\\n3. Below code will make the steps more clear.\\n\\n* C++\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a)\\n    {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = max(ans, a[i]+a[j]);\\n            i++, j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n* Java\\n```\\nclass Solution {\\n    public int minPairSum(int[] a)\\n    {\\n        int n = a.length;\\n        Arrays.sort(a);\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = Math.max(ans, a[i]+a[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a)\\n    {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = max(ans, a[i]+a[j]);\\n            i++, j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPairSum(int[] a)\\n    {\\n        int n = a.length;\\n        Arrays.sort(a);\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = Math.max(ans, a[i]+a[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238642,
                "title": "clean-python-3-sort",
                "content": "Sort `nums` first, use larger element to pair with smaller element.\\n\\nTime: `O(sort)`\\nSpace: `O(sort)`\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mx, left, right = 0, 0, len(nums) - 1\\n        while left < right:\\n            mx = max(mx, nums[left] + nums[right])\\n            left += 1\\n            right -= 1\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mx, left, right = 0, 0, len(nums) - 1\\n        while left < right:\\n            mx = max(mx, nums[left] + nums[right])\\n            left += 1\\n            right -= 1\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085481,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums)\\n    {\\n      Array.Sort(nums);\\n      return nums[..(nums.Length/2)]\\n        .Select((n, i) => n + nums[^(i + 1)])\\n        .Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums)\\n    {\\n      Array.Sort(nums);\\n      return nums[..(nums.Length/2)]\\n        .Select((n, i) => n + nums[^(i + 1)])\\n        .Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085047,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minPairSum(self, nums): \\n        output = 0\\n        nums.sort()\\n        for i in range(len(nums)/2):\\n            current = nums[i] + nums[len(nums) - i - 1]\\n            if(current > output):\\n                output = current\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPairSum(self, nums): \\n        output = 0\\n        nums.sort()\\n        for i in range(len(nums)/2):\\n            current = nums[i] + nums[len(nums) - i - 1]\\n            if(current > output):\\n                output = current\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083469,
                "title": "1877",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = nums[0] + nums[nums.length-1];\\n        for(int i=1;i<nums.length/2;i++){\\n            sum = Math.max(sum,nums[i]+nums[nums.length-1-i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = nums[0] + nums[nums.length-1];\\n        for(int i=1;i<nums.length/2;i++){\\n            sum = Math.max(sum,nums[i]+nums[nums.length-1-i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717331,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1784492,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1753146,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1657272,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1800361,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1670061,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1790493,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1741951,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1732312,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1785186,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1717331,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1784492,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1753146,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1657272,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1800361,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1670061,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1790493,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1741951,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1732312,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1785186,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 2063463,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2045193,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2032625,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2031671,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2013820,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1986232,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1967097,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1962042,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1946858,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1936227,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Get Biggest Three Rhombus Sums in a Grid",
        "question_content": "<p>You are given an <code>m x n</code> integer matrix <code>grid</code>​​​.</p>\n\n<p>A <strong>rhombus sum</strong> is the sum of the elements that form <strong>the</strong> <strong>border</strong> of a regular rhombus shape in <code>grid</code>​​​. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each <strong>rhombus sum</strong>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png\" style=\"width: 385px; height: 385px;\" />\n<p>Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.</p>\n\n<p>Return <em>the biggest three <strong>distinct rhombus sums</strong> in the </em><code>grid</code><em> in <strong>descending order</strong></em><em>. If there are less than three distinct values, return all of them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png\" style=\"width: 360px; height: 361px;\" />\n<pre>\n<strong>Input:</strong> grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n<strong>Output:</strong> [228,216,211]\n<strong>Explanation:</strong> The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 20 + 3 + 200 + 5 = 228\n- Red: 200 + 2 + 10 + 4 = 216\n- Green: 5 + 200 + 4 + 2 = 211\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png\" style=\"width: 217px; height: 217px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [20,9,8]\n<strong>Explanation:</strong> The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 4 + 2 + 6 + 8 = 20\n- Red: 9 (area 0 rhombus in the bottom right corner)\n- Green: 8 (area 0 rhombus in the bottom middle)\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[7,7,7]]\n<strong>Output:</strong> [7]\n<strong>Explanation:</strong> All three possible rhombus sums are the same, so return [7].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1238660,
                "title": "brute-force",
                "content": "I was thinking that we need some clever implementation here, but I did not see it. Therefore I went with a brute-force, and tested it agains 100 x 100 grid.\\n\\nIt looks like the actual OJ constraint is 50 x 50. And, brute-force was like 16 ms on that grid:\\n> expected \\'grid\\' to have 1 <= size <= 50 but got 100\\n\\nI think that the complexity of this problem is in handling rhombi corectly? \\n\\nWe can improve the runtime here by computing each rhombus sum in O(1). For that, we will need to compute prefix sums for each `\\\\` and `/` diagonals.This feels tedious and straightforward, so I\\'ll pass.\\n\\n```cpp\\nvector<int> getBiggestThree(vector<vector<int>>& g) {\\n    set<int> s;\\n    for (int i = 0; i < g.size(); ++i)\\n        for (int j = 0; j < g[0].size(); ++j)\\n            for (int sz = 0; i + sz < g.size() && i - sz >= 0 && j + 2 * sz < g[0].size(); ++sz) {\\n                int x = i, y = j, r_sum = 0;\\n                do r_sum += g[x++][y++]; while (x < i + sz);\\n                if (sz > 0) {\\n                    do r_sum += g[x--][y++]; while (y < j + 2 * sz);\\n                    do r_sum += g[x--][y--]; while (x > i - sz);\\n                    do r_sum += g[x++][y--]; while (x < i);\\n                }\\n                s.insert(r_sum);\\n                if (s.size() > 3)\\n                    s.erase(begin(s));                \\n            }\\n    return vector<int>(rbegin(s), rend(s));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> getBiggestThree(vector<vector<int>>& g) {\\n    set<int> s;\\n    for (int i = 0; i < g.size(); ++i)\\n        for (int j = 0; j < g[0].size(); ++j)\\n            for (int sz = 0; i + sz < g.size() && i - sz >= 0 && j + 2 * sz < g[0].size(); ++sz) {\\n                int x = i, y = j, r_sum = 0;\\n                do r_sum += g[x++][y++]; while (x < i + sz);\\n                if (sz > 0) {\\n                    do r_sum += g[x--][y++]; while (y < j + 2 * sz);\\n                    do r_sum += g[x--][y--]; while (x > i - sz);\\n                    do r_sum += g[x++][y--]; while (x < i);\\n                }\\n                s.insert(r_sum);\\n                if (s.size() > 3)\\n                    s.erase(begin(s));                \\n            }\\n    return vector<int>(rbegin(s), rend(s));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238730,
                "title": "python-dp-o-mn-min-m-n-solution-explained",
                "content": "If we want to achieve complexity better than `O(m^2n^2)`, we need to cache some values. \\n\\nImagine, than we have original `grid`:\\n\\n`01 02 03 04 05`\\n`06 07 08 09 10`\\n`11 12 13 14 15`\\n`16 17 18 19 20`\\n\\nThen table `dp(i, j, -1)` will have values, which goes in direction (1, 1).\\n\\n`01 02 03 04 05`\\n`06 08 10 12 14`\\n`11 18 21 24 27`\\n`16 28 36 40 44`\\n\\n`dp(i, j, 1)` is used to hash another type of diagonals. It will look like this:\\n\\n`01 08 21 40 44`\\n`06 18 36 39 42`\\n`11 28 30 32 34`\\n`16 17 18 19 20`\\n\\nWe will use `lru_cache` options here to get fast updates. Then we need to traverse all possible rhombus: we will have `O(mn*min(m,n))` of them and carefully evaluate sum of elements on border: which can be separated into `4` sides, which I denoted `p1, p2, p3, p4`. Actually I do not like which indexes I have here, I think it can be improved (**UPD**, it is now)\\n\\n\\n#### Complexity\\nTime complexity is `O(m*n*min(m,n))`, space complexity is `O(mn)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def getBiggestThree(self, grid):\\n        m, n, heap = len(grid), len(grid[0]), []\\n        \\n        def update(heap, num):\\n            if num not in heap:\\n                heappush(heap, num)\\n                if len(heap) > 3: heappop(heap)\\n            return heap\\n        \\n        for num in chain(*grid): update(heap, num)\\n          \\n        @lru_cache(None)\\n        def dp(i, j, dr):\\n            if not 0 <= i < n or not 0 <= j < m: return 0\\n            return dp(i-1, j+dr, dr) + grid[j][i]\\n        \\n        for q in range(1, (1 + min(m, n))//2):\\n            for i in range(q, n - q):\\n                for j in range(q, m - q):\\n                    p1 = dp(i + q, j, -1) - dp(i, j - q, -1)\\n                    p2 = dp(i - 1, j + q - 1, -1) - dp(i - q - 1, j - 1, -1)\\n                    p3 = dp(i, j - q, 1) - dp(i - q, j, 1)\\n                    p4 = dp(i + q - 1, j + 1, 1) - dp(i - 1, j + q + 1, 1)\\n                    update(heap, p1 + p2 + p3 + p4)\\n\\n        return sorted(heap)[::-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def getBiggestThree(self, grid):\\n        m, n, heap = len(grid), len(grid[0]), []\\n        \\n        def update(heap, num):\\n            if num not in heap:\\n                heappush(heap, num)\\n                if len(heap) > 3: heappop(heap)\\n            return heap\\n        \\n        for num in chain(*grid): update(heap, num)\\n          \\n        @lru_cache(None)\\n        def dp(i, j, dr):\\n            if not 0 <= i < n or not 0 <= j < m: return 0\\n            return dp(i-1, j+dr, dr) + grid[j][i]\\n        \\n        for q in range(1, (1 + min(m, n))//2):\\n            for i in range(q, n - q):\\n                for j in range(q, m - q):\\n                    p1 = dp(i + q, j, -1) - dp(i, j - q, -1)\\n                    p2 = dp(i - 1, j + q - 1, -1) - dp(i - q - 1, j - 1, -1)\\n                    p3 = dp(i, j - q, 1) - dp(i - q, j, 1)\\n                    p4 = dp(i + q - 1, j + 1, 1) - dp(i - 1, j + q + 1, 1)\\n                    update(heap, p1 + p2 + p3 + p4)\\n\\n        return sorted(heap)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238639,
                "title": "c-solution-pre-calculate-prefix-diagonal-sum-and-calculate-all-the-rhombus-sum-o-n-3",
                "content": "### Idea\\n- First, We can calculate the prefix diagonal sum for each cell in the grid, for this direction: prefix[i][j] = prefix[i-1][j + 1] + grid[i][j]\\n![image](https://assets.leetcode.com/users/images/fbfc703c-9972-4fcb-895b-480133e50027_1622301941.958279.png)\\nfor this direction: prefix[i][j] = prefix[i-1][j - 1] + grid[i][j]\\n![image](https://assets.leetcode.com/users/images/0277a324-4d1d-4c18-8dfd-05d07022c0a3_1622302207.036526.png)\\n\\n- For each cell, We can calculate all the possible rhombus by extending k unit to the border and get the sum of 4 borders in O(1) by prefix sum. it is easy to get the 4 points when extending: current point = { i, j }, then left = { i + k, j }, right = { i, j + k }, bot = {i + 2 * k, j }\\n\\n- Use ordered map(TreeMap) to maintain the three distinct largest sum.\\n\\n### Complexity\\n- Time O(N ^ 3)\\n- Space O(N ^ 2)\\n\\n### Solution\\n- C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<vector<int> > ld = grid, rd = grid;//ld = left diagonal, rd = right diagonal\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int pi = i - 1;\\n                int prevj = j - 1;\\n                if(pi >= 0 && prevj >= 0) ld[i][j] += ld[pi][prevj];\\n                prevj = j + 1;\\n                if(pi >= 0 && prevj < n) rd[i][j] += rd[pi][prevj];\\n            }\\n        }\\n        map<int, int> cnt;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ++cnt[grid[i][j]];\\n                for(int k = 1; k <=max(m, n); ++k) {\\n                    int left = j - k;\\n                    int right = j + k;\\n                    int bot = i + 2 * k;\\n                    if(left < 0 || right >= n || bot >= m) continue;\\n                    int sum = rd[i + k][left] - rd[i][j] \\n                                         + ld[i + k][right] - ld[i][j] \\n                                         + ld[bot][j] - ld[i + k][left]\\n                                         + rd[bot][j] - rd[i + k][right]\\n                                         + grid[i][j] - grid[bot][j];\\n                    ++cnt[sum];\\n                }\\n                while(cnt.size() > 3) {\\n                    auto it = cnt.begin();\\n                    cnt.erase(it);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = cnt.rbegin(); it != cnt.rend(); it++) {\\n            ans.push_back(it->first);\\n            if(ans.size() >= 3) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<vector<int> > ld = grid, rd = grid;//ld = left diagonal, rd = right diagonal\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int pi = i - 1;\\n                int prevj = j - 1;\\n                if(pi >= 0 && prevj >= 0) ld[i][j] += ld[pi][prevj];\\n                prevj = j + 1;\\n                if(pi >= 0 && prevj < n) rd[i][j] += rd[pi][prevj];\\n            }\\n        }\\n        map<int, int> cnt;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ++cnt[grid[i][j]];\\n                for(int k = 1; k <=max(m, n); ++k) {\\n                    int left = j - k;\\n                    int right = j + k;\\n                    int bot = i + 2 * k;\\n                    if(left < 0 || right >= n || bot >= m) continue;\\n                    int sum = rd[i + k][left] - rd[i][j] \\n                                         + ld[i + k][right] - ld[i][j] \\n                                         + ld[bot][j] - ld[i + k][left]\\n                                         + rd[bot][j] - rd[i + k][right]\\n                                         + grid[i][j] - grid[bot][j];\\n                    ++cnt[sum];\\n                }\\n                while(cnt.size() > 3) {\\n                    auto it = cnt.begin();\\n                    cnt.erase(it);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = cnt.rbegin(); it != cnt.rend(); it++) {\\n            ans.push_back(it->first);\\n            if(ans.size() >= 3) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238844,
                "title": "python-faster-than-100-image-solution",
                "content": "The basic idea is going from a point (i,j) towards left and right (that is both the sides of rhombus) and finding the other point to obtain sum\\n\\n![image](https://assets.leetcode.com/users/images/f940e127-6b7e-45f9-89b5-c4d1d998509a_1622305480.096866.jpeg)\\n\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        l=[]\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                ans=grid[i][j]\\n                l.append(grid[i][j])\\n                distance=1 #distance variable to store the distance from j to the both ends of rhombus\\n                while(i+distance<n and j-distance>=0 and j+distance<m):\\n                    a=i+distance\\n                    b=j+distance\\n                    c=j-distance\\n                    ans+=grid[a][b]+grid[a][c]\\n                    dumm=0    #a dummy variable to store the present sum\\n                    while(True):\\n                        c+=1\\n                        b-=1  #comming back in rhombus\\n                        a+=1 #comming front in rhombus\\n                        if(c==m or b==0 or a==n):break\\n                        if(c==b): #found the bottom point of rhoombus\\n                            dumm+=grid[a][b]\\n                            l.append(ans+dumm) #appending the obtained sum\\n                            break\\n                        dumm+=grid[a][b]+grid[a][c] #adding both sides sum to dummy\\n                    distance+=1\\n        l=list(set(l))\\n        l.sort(reverse=True)\\n        return l[:3]\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        l=[]\\n        n=len(grid)\\n        m=len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                ans=grid[i][j]\\n                l.append(grid[i][j])\\n                distance=1 #distance variable to store the distance from j to the both ends of rhombus\\n                while(i+distance<n and j-distance>=0 and j+distance<m):\\n                    a=i+distance\\n                    b=j+distance\\n                    c=j-distance\\n                    ans+=grid[a][b]+grid[a][c]\\n                    dumm=0    #a dummy variable to store the present sum\\n                    while(True):\\n                        c+=1\\n                        b-=1  #comming back in rhombus\\n                        a+=1 #comming front in rhombus\\n                        if(c==m or b==0 or a==n):break\\n                        if(c==b): #found the bottom point of rhoombus\\n                            dumm+=grid[a][b]\\n                            l.append(ans+dumm) #appending the obtained sum\\n                            break\\n                        dumm+=grid[a][b]+grid[a][c] #adding both sides sum to dummy\\n                    distance+=1\\n        l=list(set(l))\\n        l.sort(reverse=True)\\n        return l[:3]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238637,
                "title": "python-3-brute-force-greedy",
                "content": "(Edit: There is a O(mn * min(m, n)) approach by using prefix sum,\\njust refer to:\\n[https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238730/Python-dp-O(mn*min(mn))-solution-explained](https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238730/Python-dp-O(mn*min(mn))-solution-explained)\\nor \\n[https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238678/Python3.-Diagonal-prefix-sums](https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238678/Python3.-Diagonal-prefix-sums))\\n\\nJust do what problem told us, get all rhombus sums and choose top three of them.\\nUse a set to filter distinct sum and use a heap to maintain top three sum.\\n\\nTime: `O(mn * min(m, n)^2)`\\nSpace: `O(mn)`\\n\\n```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        S = {cell for row in grid for cell in row}\\n        heap = list(S)\\n        heapq.heapify(heap)\\n        while len(heap) > 3:\\n            heapq.heappop(heap)\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(1, min(m, n)):\\n                    if i - k < 0 or i + k >= m or j - k < 0 or j + k >= n:\\n                        break\\n                    curr = 0\\n                    for l in range(k + 1):\\n                        curr += grid[i+l][j+k-l] + grid[i-l][j+k-l] + grid[i+l][j-k+l] + grid[i-l][j-k+l]\\n                    curr -= grid[i+k][j] + grid[i-k][j] + grid[i][j+k] + grid[i][j-k]\\n                    if curr not in S:\\n                        S.add(curr)\\n                        heapq.heappush(heap, curr)\\n                        if len(heap) > 3: heapq.heappop(heap)\\n        return sorted(heap, reverse=True)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        S = {cell for row in grid for cell in row}\\n        heap = list(S)\\n        heapq.heapify(heap)\\n        while len(heap) > 3:\\n            heapq.heappop(heap)\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(1, min(m, n)):\\n                    if i - k < 0 or i + k >= m or j - k < 0 or j + k >= n:\\n                        break\\n                    curr = 0\\n                    for l in range(k + 1):\\n                        curr += grid[i+l][j+k-l] + grid[i-l][j+k-l] + grid[i+l][j-k+l] + grid[i-l][j-k+l]\\n                    curr -= grid[i+k][j] + grid[i-k][j] + grid[i][j+k] + grid[i][j-k]\\n                    if curr not in S:\\n                        S.add(curr)\\n                        heapq.heappush(heap, curr)\\n                        if len(heap) > 3: heapq.heappop(heap)\\n        return sorted(heap, reverse=True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537239,
                "title": "python-intuitive-solution-85-faster-and-98-less-memory",
                "content": "The idea is visiting every box and calculating the sum of all the possible rhombuses with this box as the center.\\nA max heap will be used to contain the largest 3 distinctive rhombus perimeter sums (variable s in this code)\\nFeel free to ask me any questions about the approach or implementation \\nand please **upvote** if you found it helpful.\\n```\\nimport heapq\\nclass Solution:\\n\\t# Function that evaluates the new sum\\n    def modifyHeap(self, heap, num):\\n        if num not in heap:\\n            if len(heap)<3:\\n                heappush(heap, num)\\n            elif heap[0] < num:\\n                heapreplace(heap, num)\\n        return\\n    # Function that evaluates the rhombuses with center [row][col]  and corners \"dist\" away from center      \\n    def explore(self, grid, m, n, row, col, heap, dist):\\n        if dist == 0:\\n            s = grid[row][col]\\n            self.modifyHeap(heap, s)\\n            self.explore(grid, m, n, row, col, heap, dist+1)\\n            return\\n        \\n\\t\\t# Corners locations\\n        up = row - dist\\n        down = row + dist\\n        left = col - dist\\n        right = col + dist\\n\\n        if m <= down or up < 0 or n <= right or left < 0:\\n            return\\n        \\n\\t\\t# add the sum of the corners of the rhombus\\n        s = grid[up][col] + grid[down][col] + grid[row][right] + grid[row][left]\\n        \\n\\t\\t# add the sum of the all diagonal boxes between the corners\\n        u, d, r, l = up+1, down-1, col+1, col-1\\n\\t\\t\\n        while u < row:\\n            s += grid[u][r] + grid[u][l] + grid[d][r] + grid[d][l]\\n            u+=1\\n            r+=1\\n            l-=1\\n            d-=1\\n        \\n        self.modifyHeap(heap, s)\\n        self.explore(grid, m, n, row, col, heap, dist+1)\\n        return\\n        \\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        heap = []\\n        heapify(heap)\\n\\n        #m x n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        for row in range(m):\\n            for col in range(n):\\n                self.explore(grid, m, n, row, col, heap, 0)\\n\\n        \\n        heap = sorted(heap, reverse = True)\\n        return heap\\n\\t```\\n\\tTime Complexity O((mn)^2)\\n\\tSpace Complexity O(1)",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n\\t# Function that evaluates the new sum\\n    def modifyHeap(self, heap, num):\\n        if num not in heap:\\n            if len(heap)<3:\\n                heappush(heap, num)\\n            elif heap[0] < num:\\n                heapreplace(heap, num)\\n        return\\n    # Function that evaluates the rhombuses with center [row][col]  and corners \"dist\" away from center      \\n    def explore(self, grid, m, n, row, col, heap, dist):\\n        if dist == 0:\\n            s = grid[row][col]\\n            self.modifyHeap(heap, s)\\n            self.explore(grid, m, n, row, col, heap, dist+1)\\n            return\\n        \\n\\t\\t# Corners locations\\n        up = row - dist\\n        down = row + dist\\n        left = col - dist\\n        right = col + dist\\n\\n        if m <= down or up < 0 or n <= right or left < 0:\\n            return\\n        \\n\\t\\t# add the sum of the corners of the rhombus\\n        s = grid[up][col] + grid[down][col] + grid[row][right] + grid[row][left]\\n        \\n\\t\\t# add the sum of the all diagonal boxes between the corners\\n        u, d, r, l = up+1, down-1, col+1, col-1\\n\\t\\t\\n        while u < row:\\n            s += grid[u][r] + grid[u][l] + grid[d][r] + grid[d][l]\\n            u+=1\\n            r+=1\\n            l-=1\\n            d-=1\\n        \\n        self.modifyHeap(heap, s)\\n        self.explore(grid, m, n, row, col, heap, dist+1)\\n        return\\n        \\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        heap = []\\n        heapify(heap)\\n\\n        #m x n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        for row in range(m):\\n            for col in range(n):\\n                self.explore(grid, m, n, row, col, heap, 0)\\n\\n        \\n        heap = sorted(heap, reverse = True)\\n        return heap\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1238787,
                "title": "java-brute-force-clean-o-n-m-l-2",
                "content": "```java\\n    public int[] getBiggestThree(int[][] grid) {\\n        final int n = grid.length;\\n        final int m = grid[0].length;\\n        final Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                set.add(grid[i][j]);\\n                for (int L = 1; L <= 25; L++) {\\n                    final int curr = f(grid, L, i, j, n, m);\\n                    if (curr != (int) 1e9) {\\n                        set.add(curr);\\n                    }\\n                }\\n            }\\n        }\\n        return set.stream().sorted(Comparator.reverseOrder()).limit(3).mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    private static int f(int[][] g, int size, int i, int j, int n, int m) {\\n        if (i + size >= n || i - size < 0 || (j + 2 * size) >= m) {\\n            return (int) 1e9;\\n        }\\n        int sum = 0;\\n        for (int k = 1; k < size; k++) {\\n            sum += g[i - k][j + k];\\n            sum += g[i + k][j + k];\\n            sum += g[i - k][j + 2 * size - k];\\n            sum += g[i + k][j + 2 * size - k];\\n        }\\n        sum += g[i][j];\\n        sum += g[i][j + 2 * size];\\n        sum += g[i + size][j + size];\\n        sum += g[i - size][j + size];\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public int[] getBiggestThree(int[][] grid) {\\n        final int n = grid.length;\\n        final int m = grid[0].length;\\n        final Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                set.add(grid[i][j]);\\n                for (int L = 1; L <= 25; L++) {\\n                    final int curr = f(grid, L, i, j, n, m);\\n                    if (curr != (int) 1e9) {\\n                        set.add(curr);\\n                    }\\n                }\\n            }\\n        }\\n        return set.stream().sorted(Comparator.reverseOrder()).limit(3).mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    private static int f(int[][] g, int size, int i, int j, int n, int m) {\\n        if (i + size >= n || i - size < 0 || (j + 2 * size) >= m) {\\n            return (int) 1e9;\\n        }\\n        int sum = 0;\\n        for (int k = 1; k < size; k++) {\\n            sum += g[i - k][j + k];\\n            sum += g[i + k][j + k];\\n            sum += g[i - k][j + 2 * size - k];\\n            sum += g[i + k][j + 2 * size - k];\\n        }\\n        sum += g[i][j];\\n        sum += g[i][j + 2 * size];\\n        sum += g[i + size][j + size];\\n        sum += g[i - size][j + size];\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238786,
                "title": "c-o-n-3-presum",
                "content": "preSums[i][j][0] is the presum of (i - 1, j - 1) to the upper left.\\npreSums[i][j][1] is the presum of (i - 1, j + 1) to the upper right.\\n\\nIn each rhombus:\\nup: `(i, j)`\\nleft: `(i + l, j - l)`\\nright: `(i + l, j + l)`\\ndown: `(i + 2 * l, j)`\\n\\nWe can easily calculate the sum of each rhombus defined by <i, j, l>\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>> preSums(m + 1, vector<vector<int>>(n + 2, {0, 0}));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                preSums[i + 1][j + 1][0] = preSums[i][j][0] + grid[i][j];\\n                if (j - 1 >= 0) {\\n                    preSums[i + 1][j - 1][1] = preSums[i][j][1] + grid[i][j];\\n                }\\n            }\\n        }\\n        set<int> bTree;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bTree.insert(grid[i][j]);\\n                if (bTree.size() > 3) {\\n                    bTree.erase(bTree.begin());\\n                }\\n                for (int l = 1; (i + 2 * l < m) && (j - l >= 0) && (j + l < n); l++) {\\n                    int sum = -grid[i][j] + grid[i + 2 * l][j];  //deduplicate\\n                    sum += preSums[i + l][j - l][1] - preSums[i][j][1];  //upper left\\n                    sum += preSums[i + l][j + l][0] - preSums[i][j][0];  //upper right\\n                    sum += preSums[i + 2 * l][j][0] - preSums[i + l][j - l][0];  //lower left\\n                    sum += preSums[i + 2 * l][j][1] - preSums[i + l][j + l][1];  //lower right\\n                    bTree.insert(sum);\\n                    if (bTree.size() > 3) {\\n                        bTree.erase(bTree.begin());\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> result;\\n        for (int num : bTree) {\\n            result.push_back(num);\\n        }\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>> preSums(m + 1, vector<vector<int>>(n + 2, {0, 0}));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                preSums[i + 1][j + 1][0] = preSums[i][j][0] + grid[i][j];\\n                if (j - 1 >= 0) {\\n                    preSums[i + 1][j - 1][1] = preSums[i][j][1] + grid[i][j];\\n                }\\n            }\\n        }\\n        set<int> bTree;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bTree.insert(grid[i][j]);\\n                if (bTree.size() > 3) {\\n                    bTree.erase(bTree.begin());\\n                }\\n                for (int l = 1; (i + 2 * l < m) && (j - l >= 0) && (j + l < n); l++) {\\n                    int sum = -grid[i][j] + grid[i + 2 * l][j];  //deduplicate\\n                    sum += preSums[i + l][j - l][1] - preSums[i][j][1];  //upper left\\n                    sum += preSums[i + l][j + l][0] - preSums[i][j][0];  //upper right\\n                    sum += preSums[i + 2 * l][j][0] - preSums[i + l][j - l][0];  //lower left\\n                    sum += preSums[i + 2 * l][j][1] - preSums[i + l][j + l][1];  //lower right\\n                    bTree.insert(sum);\\n                    if (bTree.size() > 3) {\\n                        bTree.erase(bTree.begin());\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> result;\\n        for (int num : bTree) {\\n            result.push_back(num);\\n        }\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238785,
                "title": "yet-another-brute-force-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        set<int> s;\\n        \\n        // 1x1, 3x3, 5x5\\n        for (int len = 1; len <= min(m, n); len += 2) {\\n            for (int i = 0; i + len <= n; i ++) {\\n                for (int j = 0; j + len <= m; j ++) {\\n                    int d = len / 2;\\n                    if (d == 0) { s.insert(grid[i][j]); }\\n                    else {\\n                        int x = i, y = j + d;\\n                        long long sum = 0;\\n                        for (int k = 0; k < d; k ++) sum += grid[x++][y++];\\n                        for (int k = 0; k < d; k ++) sum += grid[x++][y--];\\n                        for (int k = 0; k < d; k ++) sum += grid[x--][y--];\\n                        for (int k = 0; k < d; k ++) sum += grid[x--][y++];\\n                        s.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (s.size() < 3)\\n            return vector<int>(s.rbegin(), s.rend());\\n        \\n        return vector<int>(s.rbegin(), next(s.rbegin(), 3));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        set<int> s;\\n        \\n        // 1x1, 3x3, 5x5\\n        for (int len = 1; len <= min(m, n); len += 2) {\\n            for (int i = 0; i + len <= n; i ++) {\\n                for (int j = 0; j + len <= m; j ++) {\\n                    int d = len / 2;\\n                    if (d == 0) { s.insert(grid[i][j]); }\\n                    else {\\n                        int x = i, y = j + d;\\n                        long long sum = 0;\\n                        for (int k = 0; k < d; k ++) sum += grid[x++][y++];\\n                        for (int k = 0; k < d; k ++) sum += grid[x++][y--];\\n                        for (int k = 0; k < d; k ++) sum += grid[x--][y--];\\n                        for (int k = 0; k < d; k ++) sum += grid[x--][y++];\\n                        s.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (s.size() < 3)\\n            return vector<int>(s.rbegin(), s.rend());\\n        \\n        return vector<int>(s.rbegin(), next(s.rbegin(), 3));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238678,
                "title": "python3-diagonal-prefix-sums",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        # build prefix diagonal sums\\n        # grid[i][j][0] is sum(grid[i][j], grid[i - 1][j - 1], grid[i - 2][j - 2], ...)\\n        # grid[i][j][1] is sum(grid[i][j], grid[i - 1][j + 1], grid[i - 2][j + 2], ...)\\n\\t\\t\\n\\t\\t# adding (0, 0) on the last row and to the end of each row for computing convenience\\n        grid.append([(0, 0)] * (m + 1))\\n        for i in range(n):\\n            for j in range(m):\\n                grid[i][j] = (grid[i][j] + grid[i - 1][j - 1][0], grid[i][j] + grid[i - 1][j + 1][1])\\n            grid[i].append((0, 0))\\n\\n        # heap for keeping 3 max elements\\n        h = []\\n\\t\\t# k - romb size\\n        for k in range((min(n, m) + 1) // 2):\\n\\t\\t\\t# (i, j) - romb center position\\n            for i in range(k, n - k):\\n                for j in range(k, m - k):\\n                    if k == 0:\\n                        s = grid[i][j][0] - grid[i - 1][j - 1][0]\\n                    else:\\n                        left_top = grid[i][j - k][1] - grid[i - k - 1][j + 1][1]\\n                        right_top = grid[i][j + k][0] - grid[i - k][j][0]\\n                        left_bottom = grid[i + k][j][0] - grid[i][j - k][0]\\n                        right_bottom = grid[i + k - 1][j + 1][1] - grid[i][j + k][1]\\n                        s = left_top + right_top + left_bottom + right_bottom\\n\\n                    if s not in h:\\n                        if len(h) < 3:\\n                            heappush(h, s)\\n                        else:\\n                            heappushpop(h, s)\\n        h.sort(reverse=True)\\n        return h\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        # build prefix diagonal sums\\n        # grid[i][j][0] is sum(grid[i][j], grid[i - 1][j - 1], grid[i - 2][j - 2], ...)\\n        # grid[i][j][1] is sum(grid[i][j], grid[i - 1][j + 1], grid[i - 2][j + 2], ...)\\n\\t\\t\\n\\t\\t# adding (0, 0) on the last row and to the end of each row for computing convenience\\n        grid.append([(0, 0)] * (m + 1))\\n        for i in range(n):\\n            for j in range(m):\\n                grid[i][j] = (grid[i][j] + grid[i - 1][j - 1][0], grid[i][j] + grid[i - 1][j + 1][1])\\n            grid[i].append((0, 0))\\n\\n        # heap for keeping 3 max elements\\n        h = []\\n\\t\\t# k - romb size\\n        for k in range((min(n, m) + 1) // 2):\\n\\t\\t\\t# (i, j) - romb center position\\n            for i in range(k, n - k):\\n                for j in range(k, m - k):\\n                    if k == 0:\\n                        s = grid[i][j][0] - grid[i - 1][j - 1][0]\\n                    else:\\n                        left_top = grid[i][j - k][1] - grid[i - k - 1][j + 1][1]\\n                        right_top = grid[i][j + k][0] - grid[i - k][j][0]\\n                        left_bottom = grid[i + k][j][0] - grid[i][j - k][0]\\n                        right_bottom = grid[i + k - 1][j + 1][1] - grid[i][j + k][1]\\n                        s = left_top + right_top + left_bottom + right_bottom\\n\\n                    if s not in h:\\n                        if len(h) < 3:\\n                            heappush(h, s)\\n                        else:\\n                            heappushpop(h, s)\\n        h.sort(reverse=True)\\n        return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240592,
                "title": "java-readable-faster-than-100-memory-less-than-100-submissions",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int end = Math.min(grid.length, grid[0].length);\\n        int maxThree[] = {0,0,0};\\n        for(int length=0; length<end; length++){\\n            searchBigThree(grid, maxThree, length);\\n        }\\n        \\n        Arrays.sort(maxThree);\\n        \\n        // If there are less than three distinct values, return all of them.\\n        if(maxThree[0] == 0){\\n            if(maxThree[1] == 0){\\n                return new int[]{maxThree[2]}; \\n            }\\n            return new int[]{maxThree[2],maxThree[1]}; \\n        }\\n        \\n        // reverse array\\n        maxThree[0] = maxThree[0]^maxThree[2];\\n        maxThree[2] = maxThree[0]^maxThree[2];\\n        maxThree[0] = maxThree[0]^maxThree[2];\\n        \\n        \\n        return maxThree;\\n    }\\n    \\n    void searchBigThree(int[][] grid, int[] maxThree, int length){\\n        int end = grid.length-(length==0?0: 2*length);\\n        int end1 = grid[0].length-(length);\\n        for(int start = 0; start<end; start++){\\n            for(int start1 = length; start1<end1; start1++){\\n                if(start+start1 >= length){\\n                    addToMaxThree(maxThree, getSum(grid, start, start1, length));\\n                }\\n            }\\n        }\\n    }\\n    \\n    /*\\n    get sum of edges of rhombus abcd\\n            a\\n           / \\\\\\n          d   b\\n           \\\\ /\\n            c\\n    \\n    */\\n    int getSum(int[][] grid, int i, int j, int length){\\n        if(length == 0){\\n            return grid[i][j];\\n        }\\n        \\n        int sum = 0;\\n        // edge ab\\n        for(int it=0; it<=length; it++){\\n            sum = sum + grid[i+it][j+it];\\n        }\\n        \\n        // edge ad\\n        for(int it=1; it<=length; it++){\\n            sum = sum + grid[i+it][j-it];\\n        }\\n        \\n        // edge dc\\n        for(int it=1; it<=length; it++){\\n            sum = sum + grid[i+length+it][j-length+it];\\n        }\\n        \\n        // edge bc\\n        for(int it=1; it<length; it++){\\n            sum = sum + grid[i+length+it][j+length-it];\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    void addToMaxThree(int[] maxThree, int num){\\n        // Do not add duplicate entry\\n        if(maxThree[0] == num || maxThree[1] == num || maxThree[2] == num ){\\n            return;\\n        }\\n        \\n        Arrays.sort(maxThree);\\n        \\n        if(maxThree[0] < num){\\n            maxThree[0] = num;\\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int end = Math.min(grid.length, grid[0].length);\\n        int maxThree[] = {0,0,0};\\n        for(int length=0; length<end; length++){\\n            searchBigThree(grid, maxThree, length);\\n        }\\n        \\n        Arrays.sort(maxThree);\\n        \\n        // If there are less than three distinct values, return all of them.\\n        if(maxThree[0] == 0){\\n            if(maxThree[1] == 0){\\n                return new int[]{maxThree[2]}; \\n            }\\n            return new int[]{maxThree[2],maxThree[1]}; \\n        }\\n        \\n        // reverse array\\n        maxThree[0] = maxThree[0]^maxThree[2];\\n        maxThree[2] = maxThree[0]^maxThree[2];\\n        maxThree[0] = maxThree[0]^maxThree[2];\\n        \\n        \\n        return maxThree;\\n    }\\n    \\n    void searchBigThree(int[][] grid, int[] maxThree, int length){\\n        int end = grid.length-(length==0?0: 2*length);\\n        int end1 = grid[0].length-(length);\\n        for(int start = 0; start<end; start++){\\n            for(int start1 = length; start1<end1; start1++){\\n                if(start+start1 >= length){\\n                    addToMaxThree(maxThree, getSum(grid, start, start1, length));\\n                }\\n            }\\n        }\\n    }\\n    \\n    /*\\n    get sum of edges of rhombus abcd\\n            a\\n           / \\\\\\n          d   b\\n           \\\\ /\\n            c\\n    \\n    */\\n    int getSum(int[][] grid, int i, int j, int length){\\n        if(length == 0){\\n            return grid[i][j];\\n        }\\n        \\n        int sum = 0;\\n        // edge ab\\n        for(int it=0; it<=length; it++){\\n            sum = sum + grid[i+it][j+it];\\n        }\\n        \\n        // edge ad\\n        for(int it=1; it<=length; it++){\\n            sum = sum + grid[i+it][j-it];\\n        }\\n        \\n        // edge dc\\n        for(int it=1; it<=length; it++){\\n            sum = sum + grid[i+length+it][j-length+it];\\n        }\\n        \\n        // edge bc\\n        for(int it=1; it<length; it++){\\n            sum = sum + grid[i+length+it][j+length-it];\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    void addToMaxThree(int[] maxThree, int num){\\n        // Do not add duplicate entry\\n        if(maxThree[0] == num || maxThree[1] == num || maxThree[2] == num ){\\n            return;\\n        }\\n        \\n        Arrays.sort(maxThree);\\n        \\n        if(maxThree[0] < num){\\n            maxThree[0] = num;\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239929,
                "title": "python-100-faster-well-explained-simple-approach",
                "content": "Don\\'t leave the idea of question and if you want more explaination or any example please feel free to ask !!\\n## IDEA :\\n\\uD83D\\uDC49 Firstly we will  determine all the four vertices of rhombus.\\n\\uD83D\\uDC49 Then we will pass that rhombus to calc function to calculate the score(perimeter).\\n\\uD83D\\uDC49 \"expand\" flag is used to determine upto what time rhombus will expand then again it will get shrink.\\n\\uD83D\\uDC49 Store that perimeter in heap\\n\\uD83D\\uDC49 length of heap will always be three\\n\\uD83D\\uDC49 Return heap after sorting in reverse order.\\n\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calc(l,r,u,d):\\n            sc=0\\n            c1=c2=(l+r)//2\\n            expand=True\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sc+=grid[row][c1]\\n                else:\\n                    sc+=grid[row][c1]+grid[row][c2]\\n                \\n                if c1==l:\\n                    expand=False\\n                \\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sc\\n            \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        heap=[]\\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<=n-1 and d<=m-1:\\n                    sc=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if len(heap)<3:\\n                        if sc not in heap:\\n                            heapq.heappush(heap,sc)\\n                    else:\\n                        if sc not in heap and sc>heap[0]:\\n                            heapq.heappop(heap)\\n                            heapq.heappush(heap,sc)\\n        \\n        heap.sort(reverse=True)\\n        return heap\\n\\nThank You\\nif you liked please **Upvote** !!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "Don\\'t leave the idea of question and if you want more explaination or any example please feel free to ask !!\\n## IDEA :\\n\\uD83D\\uDC49 Firstly we will  determine all the four vertices of rhombus.\\n\\uD83D\\uDC49 Then we will pass that rhombus to calc function to calculate the score(perimeter).\\n\\uD83D\\uDC49 \"expand\" flag is used to determine upto what time rhombus will expand then again it will get shrink.\\n\\uD83D\\uDC49 Store that perimeter in heap\\n\\uD83D\\uDC49 length of heap will always be three\\n\\uD83D\\uDC49 Return heap after sorting in reverse order.\\n\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calc(l,r,u,d):\\n            sc=0\\n            c1=c2=(l+r)//2\\n            expand=True\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sc+=grid[row][c1]\\n                else:\\n                    sc+=grid[row][c1]+grid[row][c2]\\n                \\n                if c1==l:\\n                    expand=False\\n                \\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sc\\n            \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        heap=[]\\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<=n-1 and d<=m-1:\\n                    sc=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if len(heap)<3:\\n                        if sc not in heap:\\n                            heapq.heappush(heap,sc)\\n                    else:\\n                        if sc not in heap and sc>heap[0]:\\n                            heapq.heappop(heap)\\n                            heapq.heappush(heap,sc)\\n        \\n        heap.sort(reverse=True)\\n        return heap\\n\\nThank You\\nif you liked please **Upvote** !!",
                "codeTag": "Java"
            },
            {
                "id": 1241728,
                "title": "easy-to-understand-c-solution-well-commented-and-explained-prefix-diagonal-sum-o-n-3",
                "content": "Feel free to suggest any improvements\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> R(m, vector<int>(n, 0));\\n        vector<vector<int>> L(m, vector<int>(n, 0));\\n        for(int i=0; i<m; i++){ // To fill the diagonals going to the bottom right side with prefix sum of diagonals\\n            for(int j=0; j<n; j++){\\n                if(i-1>=0 && j-1>=0){\\n                    R[i][j]=grid[i][j]+R[i-1][j-1];\\n                } else {\\n                    R[i][j]=grid[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0; i<m; i++){ // To fill the diagonals going to the bottom left side with prefix sum of diagonals\\n            for(int j=n-1; j>=0; j--){\\n                if(i-1>=0 && j+1<n){\\n                    L[i][j]=grid[i][j]+L[i-1][j+1];\\n                } else {\\n                    L[i][j]=grid[i][j];\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for(int i=0; i<m; i++){ // For each i, j iterate over k\\n            // 4 corners of rhombus = (i,j), (i+k, j-k), (i+k, j+k), (i+2*k, j)\\n            for(int j=0; j<n; j++){\\n                int k=0;\\n                while((i+2*k)<m && j+k<n && j-k>=0){\\n                    int sum=0;\\n                    sum+=R[i+k][j+k]-R[i][j]+grid[i][j]; // Add side value sum from (i,j) to (i+k, j+k)\\n                    sum+=L[i+k][j-k]-L[i][j]; // Add side value sum from (i,j) to (i+k, j-k)\\n                    sum+=R[i+(2*k)][j]-R[i+k][j-k]; // Add side value sum from (i+k,j-k) to (i+2*k, j)\\n                    sum+=L[i+(2*k)][j]-L[i+k][j+k]; // Add side value sum from (i+k,j+k) to (i+2*k, j)\\n                    if(k>0)\\n                        sum-=grid[i+(2*k)][j]; // We have added this twice during the last 2 steps if k>0\\n                    res.push_back(sum);\\n                    k++;\\n                }\\n            }\\n        }\\n        sort(res.begin(), res.end()); // Sort to remove duplicate elements in next step\\n        res.erase(unique(res.begin(), res.end()), res.end());\\n        int sz=res.size();\\n        // To return greatest min(3, res.size()) values\\n        if(sz==1){\\n            return {res[0]};\\n        } else if(sz==2){\\n            return {res[1], res[0]};\\n        } else {\\n            return {res[sz-1], res[sz-2], res[sz-3]};\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> R(m, vector<int>(n, 0));\\n        vector<vector<int>> L(m, vector<int>(n, 0));\\n        for(int i=0; i<m; i++){ // To fill the diagonals going to the bottom right side with prefix sum of diagonals\\n            for(int j=0; j<n; j++){\\n                if(i-1>=0 && j-1>=0){\\n                    R[i][j]=grid[i][j]+R[i-1][j-1];\\n                } else {\\n                    R[i][j]=grid[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0; i<m; i++){ // To fill the diagonals going to the bottom left side with prefix sum of diagonals\\n            for(int j=n-1; j>=0; j--){\\n                if(i-1>=0 && j+1<n){\\n                    L[i][j]=grid[i][j]+L[i-1][j+1];\\n                } else {\\n                    L[i][j]=grid[i][j];\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for(int i=0; i<m; i++){ // For each i, j iterate over k\\n            // 4 corners of rhombus = (i,j), (i+k, j-k), (i+k, j+k), (i+2*k, j)\\n            for(int j=0; j<n; j++){\\n                int k=0;\\n                while((i+2*k)<m && j+k<n && j-k>=0){\\n                    int sum=0;\\n                    sum+=R[i+k][j+k]-R[i][j]+grid[i][j]; // Add side value sum from (i,j) to (i+k, j+k)\\n                    sum+=L[i+k][j-k]-L[i][j]; // Add side value sum from (i,j) to (i+k, j-k)\\n                    sum+=R[i+(2*k)][j]-R[i+k][j-k]; // Add side value sum from (i+k,j-k) to (i+2*k, j)\\n                    sum+=L[i+(2*k)][j]-L[i+k][j+k]; // Add side value sum from (i+k,j+k) to (i+2*k, j)\\n                    if(k>0)\\n                        sum-=grid[i+(2*k)][j]; // We have added this twice during the last 2 steps if k>0\\n                    res.push_back(sum);\\n                    k++;\\n                }\\n            }\\n        }\\n        sort(res.begin(), res.end()); // Sort to remove duplicate elements in next step\\n        res.erase(unique(res.begin(), res.end()), res.end());\\n        int sz=res.size();\\n        // To return greatest min(3, res.size()) values\\n        if(sz==1){\\n            return {res[0]};\\n        } else if(sz==2){\\n            return {res[1], res[0]};\\n        } else {\\n            return {res[sz-1], res[sz-2], res[sz-3]};\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239523,
                "title": "java-priorityqueue-set-50-ms-faster-than-100-00",
                "content": "Java\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] g) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < g.length; i++){\\n            for(int j = 0; j < g[0].length; j++){\\n                q.offer(g[i][j]);\\n                for(int k = 1; k <= Math.min(g.length / 2, g[0].length / 2); k++){\\n                    if(i - k >= 0 && i + k < g.length && j - k >= 0 && j + k < g[0].length){\\n                        int sum = g[i][j - k] + g[i - k][j] + g[i + k][j] + g[i][j + k];\\n                        for(int l = 1; l < k; l++){\\n                            sum += g[i + l][j - k + l] + g[i - k + l][j + l];\\n                            sum += g[i - l][j - k + l] + g[i + k - l][j + l];\\n                        }\\n                        q.offer(sum);\\n                    }\\n                }\\n            }\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        while(q.size() > 0 && set.size() < 3){\\n            set.add(q.poll());\\n        }\\n        return set.stream().sorted(Comparator.reverseOrder()).limit(3).mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] g) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < g.length; i++){\\n            for(int j = 0; j < g[0].length; j++){\\n                q.offer(g[i][j]);\\n                for(int k = 1; k <= Math.min(g.length / 2, g[0].length / 2); k++){\\n                    if(i - k >= 0 && i + k < g.length && j - k >= 0 && j + k < g[0].length){\\n                        int sum = g[i][j - k] + g[i - k][j] + g[i + k][j] + g[i][j + k];\\n                        for(int l = 1; l < k; l++){\\n                            sum += g[i + l][j - k + l] + g[i - k + l][j + l];\\n                            sum += g[i - l][j - k + l] + g[i + k - l][j + l];\\n                        }\\n                        q.offer(sum);\\n                    }\\n                }\\n            }\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        while(q.size() > 0 && set.size() < 3){\\n            set.add(q.poll());\\n        }\\n        return set.stream().sorted(Comparator.reverseOrder()).limit(3).mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240674,
                "title": "c-with-explanation-diagonal-sums",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        vector <int> top3;\\n        priority_queue <int> pq;\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        // adding all the elements in priority queue\\n        // for rhombus with an area of 0\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                pq.push(grid[i][j]);\\n            }\\n        }\\n        \\n        // height of the rhombus\\n        int h = 1;\\n        int height = (2 * h) + 1;\\n        \\n        // find sum for all heights\\n        while (height <= r && height <= c) {\\n            \\n            for (int i = 0; i < r && (r - i) >= height; i++) {\\n                for (int j = h; j < c - h; j++) {\\n                    \\n                    int s = 0;\\n                    \\n                    int top = grid[i][j];\\n                    s += top;\\n                    \\n                    // top left diagonal elements of rhombus\\n                    for (int li = 1; li <= h; li++) {\\n                        s += grid[i + li][j - li];\\n                    }\\n                    \\n                    // top right diagonal elements of rhombus\\n                    for (int ri = 1; ri <= h; ri++) {\\n                        s += grid[i + ri][j + ri];\\n                    }\\n                    \\n                    int bottom = grid[i + height - 1][j];\\n                    // change the i co-ordinate\\n                    int bi = i + height - 1;\\n                    \\n                    // bottom left diagonal elements of rhombus\\n                    for (int bl = 1; bl <= (h - 1); bl++) {\\n                        s += grid[bi - bl][j - bl];\\n                    }\\n                    \\n                    // bottom right diagonal elements of rhombus\\n                    for (int br = 1; br <= (h - 1); br++) {\\n                       s += grid[bi - br][j + br]; \\n                    }\\n                    \\n                    s += bottom;\\n                    \\n                    // push the sum of each rhombus to priority queue\\n                    pq.push(s);\\n                }\\n            }\\n            \\n            // increase height\\n            h += 1;\\n            height = (2 * h) + 1;\\n        }\\n        \\n        // get top 3 distinct sums\\n        unordered_set <int> top;\\n        int k = 3;\\n        \\n        while (k > 0 && !pq.empty()) {\\n            int el = pq.top(); pq.pop();\\n            if (top.find(el) == top.end()) {\\n                top.insert(el);\\n                k--;\\n            }\\n        }\\n        \\n        for (auto i: top) {\\n            top3.push_back(i);\\n        }\\n        \\n        // sort them in decreasing order\\n        sort(top3.begin(), top3.end(), greater <int>());\\n        \\n        return top3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        vector <int> top3;\\n        priority_queue <int> pq;\\n        \\n        int r = grid.size();\\n        int c = grid[0].size();\\n        \\n        // adding all the elements in priority queue\\n        // for rhombus with an area of 0\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                pq.push(grid[i][j]);\\n            }\\n        }\\n        \\n        // height of the rhombus\\n        int h = 1;\\n        int height = (2 * h) + 1;\\n        \\n        // find sum for all heights\\n        while (height <= r && height <= c) {\\n            \\n            for (int i = 0; i < r && (r - i) >= height; i++) {\\n                for (int j = h; j < c - h; j++) {\\n                    \\n                    int s = 0;\\n                    \\n                    int top = grid[i][j];\\n                    s += top;\\n                    \\n                    // top left diagonal elements of rhombus\\n                    for (int li = 1; li <= h; li++) {\\n                        s += grid[i + li][j - li];\\n                    }\\n                    \\n                    // top right diagonal elements of rhombus\\n                    for (int ri = 1; ri <= h; ri++) {\\n                        s += grid[i + ri][j + ri];\\n                    }\\n                    \\n                    int bottom = grid[i + height - 1][j];\\n                    // change the i co-ordinate\\n                    int bi = i + height - 1;\\n                    \\n                    // bottom left diagonal elements of rhombus\\n                    for (int bl = 1; bl <= (h - 1); bl++) {\\n                        s += grid[bi - bl][j - bl];\\n                    }\\n                    \\n                    // bottom right diagonal elements of rhombus\\n                    for (int br = 1; br <= (h - 1); br++) {\\n                       s += grid[bi - br][j + br]; \\n                    }\\n                    \\n                    s += bottom;\\n                    \\n                    // push the sum of each rhombus to priority queue\\n                    pq.push(s);\\n                }\\n            }\\n            \\n            // increase height\\n            h += 1;\\n            height = (2 * h) + 1;\\n        }\\n        \\n        // get top 3 distinct sums\\n        unordered_set <int> top;\\n        int k = 3;\\n        \\n        while (k > 0 && !pq.empty()) {\\n            int el = pq.top(); pq.pop();\\n            if (top.find(el) == top.end()) {\\n                top.insert(el);\\n                k--;\\n            }\\n        }\\n        \\n        for (auto i: top) {\\n            top3.push_back(i);\\n        }\\n        \\n        // sort them in decreasing order\\n        sort(top3.begin(), top3.end(), greater <int>());\\n        \\n        return top3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238904,
                "title": "c-concise-solution-with-90-performance",
                "content": "~~~\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int  row = grid.size(), col = grid[0].size();\\n        \\n        // using set<int> takes much less memory, but is 3x slower\\n        priority_queue<int> pq;\\n        \\n        // size 0 Rhombus shapes\\n        for (auto &r: grid) {\\n            for(auto &c: r) pq.push(c);\\n        }\\n        \\n        // // size k Rhombus shapes\\n        for (int k = 1; k < min(row, col); ++k) {\\n            for (int i = 0; i + 2 * k < row; ++i) {\\n                for (int j = 0; j + 2 * k < col; ++j) {\\n                    int sum = 0;\\n                    \\n                    // collecting data along 4 lines\\n                    for (int m = 0; m < k; ++m) {\\n                        sum += grid[i + k - m][j + m]; // left->up\\n                        sum += grid[i + m][j + k + m]; // top->right\\n                        sum += grid[i + k + m][j + 2 * k - m]; //right->down\\n                        sum += grid[i + 2 * k - m][j + k - m]; // bottom->left\\n                    }\\n                    pq.push(sum);\\n                }\\n            }\\n        }\\n        \\n        // formatting the answer \\n        vector<int> ret;\\n        while (pq.empty() == false) {\\n            if (ret.empty() == true || ret.back() != pq.top()) {\\n                ret.push_back(pq.top());\\n            }\\n            if (ret.size() == 3) return ret;\\n            pq.pop();\\n        }\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int  row = grid.size(), col = grid[0].size();\\n        \\n        // using set<int> takes much less memory, but is 3x slower\\n        priority_queue<int> pq;\\n        \\n        // size 0 Rhombus shapes\\n        for (auto &r: grid) {\\n            for(auto &c: r) pq.push(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238712,
                "title": "java-brute-force-but-not-too-much",
                "content": "```\\nclass Solution {\\n    public static boolean safe(int n, int m, int i, int j, int side) {\\n        if(i + side >= n || j + side >= m || i - side < 0) return false;\\n        if(j + 2 * side >= m) return false;\\n        return true;\\n    }\\n    public int[] getBiggestThree(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        HashSet<Integer> set = new HashSet<>();\\n        int maxSide = 1 + Math.min(n, m) / 2; \\n        for(int i = 0; i < n; i++) {\\n            outer : for(int j = 0; j < m; j++) {\\n                set.add(grid[i][j]);\\n                for(int k = 1; k <= maxSide; k++) {\\n                    if(!safe(n, m, i, j, k)) continue outer;\\n                    int sum = 0;\\n                    int r = i, c = j;\\n                    for(int a = 0; a < k; a++) sum += grid[--r][++c];\\n                    for(int a = 0; a < k; a++) sum += grid[++r][++c];\\n                    for(int a = 0; a < k; a++) sum += grid[++r][--c];\\n                    for(int a = 0; a < k; a++) sum += grid[--r][--c];\\n                    set.add(sum);\\n                }\\n            }\\n        }\\n        Iterator<Integer> it = set.iterator();\\n        List<Integer> list = new ArrayList<>();\\n        while(it.hasNext()) list.add(it.next());\\n        Collections.sort(list);\\n        int[] ans = new int[Math.min(set.size(), 3)];\\n        for(int k = 0; k < Math.min(list.size(), 3); k++) ans[k] = list.get(list.size() - 1 - k);\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean safe(int n, int m, int i, int j, int side) {\\n        if(i + side >= n || j + side >= m || i - side < 0) return false;\\n        if(j + 2 * side >= m) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1442967,
                "title": "python-3-dp-matrix-padding-prefix-sum-explanation",
                "content": "### Intuition\\n- Brute force way is to pick all 4 nodes combinations, then:\\n\\t- Check whether they are Rhombus\\n\\t- Calculate its boarder sum\\n- This is obvious not doable given there are at most `50 * 50 = 2500` nodes\\n- A better way is to find sum on known Rhombus, how to get a Rhombus?\\n\\t- Pick any node as bottom, expand to its left & right and find the corresponding top node\\n- Why not think it as the left, right, top vertex? \\n\\t- You can, but it depends on the way you traverse the matrix\\n\\t- When traversing from left to right, top to bottom, only consider the vertex at the bottom vertex can have the information of left, right, bottom vertices\\n### Explanation\\n- Since we are trying to get sum of nodes, using prefix-sum becomes almsot obvious, espesically when the lines were drawn :) on the example\\n- Below is an implementation of the idea I mentioned above, see comments for more detail\\n> _**NOTE**_: I used a `(n+2) * (m+2)` matrix, so that I will have zero padding on the boarder, which will be eaiser when handling edge cases.\\n### Implementation\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[[0, 0]] * (n+2) for _ in range(m+2)]\\n        ans = []\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):                            # [i, j] will be the bottom vertex\\n                ans.append(grid[i-1][j-1])\\n                dp[i][j] = [grid[i-1][j-1], grid[i-1][j-1]]\\n                dp[i][j][0] += dp[i-1][j-1][0]                 # dp: major diagonal\\n                dp[i][j][1] += dp[i-1][j+1][1]                 # dp: minor diagonal\\n                for win in range(1, min(m, n)):\\n                    x1, y1 = i-win, j-win                      # left vertex\\n                    x2, y2 = i-win, j+win                      # right vertex\\n                    x3, y3 = i-win-win, j                      # top vertex\\n                    if not (all(1 <= x < m+1 for x in [x1, x2, x3]) and all(1 <= y < n+1 for y in [y1, y2, y3])):\\n                        break\\n                    b2l = dp[i][j][0] - dp[x1-1][y1-1][0]      # bottom node to left node (node sum), major diagonal\\n                    b2r = dp[i][j][1] - dp[x2-1][y2+1][1]      # bottom node to right node (node sum), minor diagonal\\n                    l2t = dp[x1][y1][1] - dp[x3-1][y3+1][1]    # left node to top node (node sum), minor diagonal\\n                    r2t = dp[x2][y2][0] - dp[x3-1][y3-1][0]    # right node to top node (node sum), major diagonal\\n                    vertices_sum = grid[i-1][j-1] + grid[x1-1][y1-1] + grid[x2-1][y2-1] + grid[x3-1][y3-1]\\n                    cur = b2l + b2r + l2t + r2t - vertices_sum # sum(edges) - sum(4 vertices)\\n                    ans.append(cur)\\n        return sorted(set(ans), reverse=True)[:3]              # unique + sort reverse + keep only first 3        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[[0, 0]] * (n+2) for _ in range(m+2)]\\n        ans = []\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):                            # [i, j] will be the bottom vertex\\n                ans.append(grid[i-1][j-1])\\n                dp[i][j] = [grid[i-1][j-1], grid[i-1][j-1]]\\n                dp[i][j][0] += dp[i-1][j-1][0]                 # dp: major diagonal\\n                dp[i][j][1] += dp[i-1][j+1][1]                 # dp: minor diagonal\\n                for win in range(1, min(m, n)):\\n                    x1, y1 = i-win, j-win                      # left vertex\\n                    x2, y2 = i-win, j+win                      # right vertex\\n                    x3, y3 = i-win-win, j                      # top vertex\\n                    if not (all(1 <= x < m+1 for x in [x1, x2, x3]) and all(1 <= y < n+1 for y in [y1, y2, y3])):\\n                        break\\n                    b2l = dp[i][j][0] - dp[x1-1][y1-1][0]      # bottom node to left node (node sum), major diagonal\\n                    b2r = dp[i][j][1] - dp[x2-1][y2+1][1]      # bottom node to right node (node sum), minor diagonal\\n                    l2t = dp[x1][y1][1] - dp[x3-1][y3+1][1]    # left node to top node (node sum), minor diagonal\\n                    r2t = dp[x2][y2][0] - dp[x3-1][y3-1][0]    # right node to top node (node sum), major diagonal\\n                    vertices_sum = grid[i-1][j-1] + grid[x1-1][y1-1] + grid[x2-1][y2-1] + grid[x3-1][y3-1]\\n                    cur = b2l + b2r + l2t + r2t - vertices_sum # sum(edges) - sum(4 vertices)\\n                    ans.append(cur)\\n        return sorted(set(ans), reverse=True)[:3]              # unique + sort reverse + keep only first 3        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252908,
                "title": "java-simple-and-easy-to-understand-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    int rows;\\n    int cols;\\n    int[][] grid;\\n    \\n    HashSet<Integer> set;\\n    PriorityQueue<Integer> minHeap;\\n    \\n    public int[] getBiggestThree(int[][] grid) {\\n        this.grid = grid;\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        \\n        set = new HashSet();\\n        minHeap = new PriorityQueue<Integer>((a, b) -> (a - b));\\n        \\n        \\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                //find all the rhombus of center (r, c)\\n                findRhombusWithCenter(r, c);\\n            }\\n        }\\n        \\n        //get the largest 3 rhombus \\n        int[] result = new int[minHeap.size()];\\n        int i = result.length - 1;\\n        while(!minHeap.isEmpty()){\\n            result[i--] = minHeap.remove();\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    \\n    private void findRhombusWithCenter(int r, int c){\\n        int sum = grid[r][c];\\n        \\n        if(!set.contains(sum)){\\n            minHeap.add(sum);\\n            if(minHeap.size() > 3) minHeap.remove();\\n            set.add(sum);\\n        }\\n        \\n        int size = 1;\\n        \\n        while(true){\\n            \\n            if(!insideGrid(r + size, c)) break;\\n            if(!insideGrid(r - size, c)) break;\\n            if(!insideGrid(r, c + size)) break;\\n            if(!insideGrid(r, c - size)) break;\\n            \\n            sum = 0;\\n            for(int i = 0; i <= size; i++){\\n                sum += grid[r - size + i][c + i];\\n                sum += grid[r - size + i][c - i];\\n                \\n                sum += grid[r + size - i][c + i];\\n                sum += grid[r + size - i][c - i];\\n            }\\n\\n            \\n            sum -= grid[r + size][c];\\n            sum -= grid[r - size][c];\\n            sum -= grid[r][c + size];\\n            sum -= grid[r][c - size];\\n            \\n            \\n            if(!set.contains(sum)){\\n                minHeap.add(sum);\\n                \\n                if(minHeap.size() > 3) minHeap.remove();\\n                \\n                set.add(sum);\\n            }\\n            \\n            size++;\\n        }\\n    }\\n    \\n    private boolean insideGrid(int i, int j){\\n        return i >= 0 && i < rows && j >= 0 && j < cols;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int rows;\\n    int cols;\\n    int[][] grid;\\n    \\n    HashSet<Integer> set;\\n    PriorityQueue<Integer> minHeap;\\n    \\n    public int[] getBiggestThree(int[][] grid) {\\n        this.grid = grid;\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        \\n        set = new HashSet();\\n        minHeap = new PriorityQueue<Integer>((a, b) -> (a - b));\\n        \\n        \\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                //find all the rhombus of center (r, c)\\n                findRhombusWithCenter(r, c);\\n            }\\n        }\\n        \\n        //get the largest 3 rhombus \\n        int[] result = new int[minHeap.size()];\\n        int i = result.length - 1;\\n        while(!minHeap.isEmpty()){\\n            result[i--] = minHeap.remove();\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    \\n    private void findRhombusWithCenter(int r, int c){\\n        int sum = grid[r][c];\\n        \\n        if(!set.contains(sum)){\\n            minHeap.add(sum);\\n            if(minHeap.size() > 3) minHeap.remove();\\n            set.add(sum);\\n        }\\n        \\n        int size = 1;\\n        \\n        while(true){\\n            \\n            if(!insideGrid(r + size, c)) break;\\n            if(!insideGrid(r - size, c)) break;\\n            if(!insideGrid(r, c + size)) break;\\n            if(!insideGrid(r, c - size)) break;\\n            \\n            sum = 0;\\n            for(int i = 0; i <= size; i++){\\n                sum += grid[r - size + i][c + i];\\n                sum += grid[r - size + i][c - i];\\n                \\n                sum += grid[r + size - i][c + i];\\n                sum += grid[r + size - i][c - i];\\n            }\\n\\n            \\n            sum -= grid[r + size][c];\\n            sum -= grid[r - size][c];\\n            sum -= grid[r][c + size];\\n            sum -= grid[r][c - size];\\n            \\n            \\n            if(!set.contains(sum)){\\n                minHeap.add(sum);\\n                \\n                if(minHeap.size() > 3) minHeap.remove();\\n                \\n                set.add(sum);\\n            }\\n            \\n            size++;\\n        }\\n    }\\n    \\n    private boolean insideGrid(int i, int j){\\n        return i >= 0 && i < rows && j >= 0 && j < cols;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238981,
                "title": "java-concise-simple-28-lines-code-o-n-3-no-prefix-sum",
                "content": "Find out minimum of length and width. \\nCorresponding to it find the maxSideLength a rhombus can have.\\nIterate over all rhombus length from each cell \\n\\n```\\nclass Solution {\\n\\tpublic int[] getBiggestThree(int[][] grid) {\\n\\t\\tint dx[][] = { { 1, 1, 0 }, { 1, -1, 0 }, { -1, -1, 0 }, { -1, 1, 1 } };\\n\\t\\tint minDimension = Math.min(grid.length, grid[0].length) , size = 0;\\n\\t\\tint maxSideLength = minDimension / 2 - (minDimension % 2 == 0 ? -1 : 0);\\n\\t\\tTreeSet<Integer> pq = new TreeSet<Integer>((a, b) -> b - a);\\n\\t\\tfor (int sideLength = 0; sideLength <= maxSideLength; sideLength++) {\\n\\t\\t\\tfor (int i = 0; i < grid.length - 2 * sideLength; i++) {\\n\\t\\t\\t\\tfor (int j = sideLength; j < grid[0].length - sideLength; j++) {\\n\\t\\t\\t\\t\\tint currentX = i, currentY = j, ans = grid[i][j];\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\tint countInDiagonal = sideLength - dx[k][2];\\n\\t\\t\\t\\t\\t\\twhile (countInDiagonal-- > 0) {\\n\\t\\t\\t\\t\\t\\t\\tcurrentX += dx[k][0];\\n\\t\\t\\t\\t\\t\\t\\tcurrentY += dx[k][1];\\n\\t\\t\\t\\t\\t\\t\\tans += grid[currentX][currentY];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsize += (pq.add(ans) ? 1 : 0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = Math.min(size, 3);\\n\\t\\tint arr[] = new int[size];\\n\\t\\tfor (int i = 0; i < size; i++) arr[i] = pq.pollFirst();\\n\\t\\treturn arr;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic int[] getBiggestThree(int[][] grid) {\\n\\t\\tint dx[][] = { { 1, 1, 0 }, { 1, -1, 0 }, { -1, -1, 0 }, { -1, 1, 1 } };\\n\\t\\tint minDimension = Math.min(grid.length, grid[0].length) , size = 0;\\n\\t\\tint maxSideLength = minDimension / 2 - (minDimension % 2 == 0 ? -1 : 0);\\n\\t\\tTreeSet<Integer> pq = new TreeSet<Integer>((a, b) -> b - a);\\n\\t\\tfor (int sideLength = 0; sideLength <= maxSideLength; sideLength++) {\\n\\t\\t\\tfor (int i = 0; i < grid.length - 2 * sideLength; i++) {\\n\\t\\t\\t\\tfor (int j = sideLength; j < grid[0].length - sideLength; j++) {\\n\\t\\t\\t\\t\\tint currentX = i, currentY = j, ans = grid[i][j];\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\tint countInDiagonal = sideLength - dx[k][2];\\n\\t\\t\\t\\t\\t\\twhile (countInDiagonal-- > 0) {\\n\\t\\t\\t\\t\\t\\t\\tcurrentX += dx[k][0];\\n\\t\\t\\t\\t\\t\\t\\tcurrentY += dx[k][1];\\n\\t\\t\\t\\t\\t\\t\\tans += grid[currentX][currentY];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsize += (pq.add(ans) ? 1 : 0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = Math.min(size, 3);\\n\\t\\tint arr[] = new int[size];\\n\\t\\tfor (int i = 0; i < size; i++) arr[i] = pq.pollFirst();\\n\\t\\treturn arr;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238757,
                "title": "brute-force-step-by-step-easy-to-understand",
                "content": "* For each cell in the matrix, we calculate the sums of all rhombii having that very cell as it\\'s top corner/vertex.\\n* This is a brute force approach.\\n* `count`  variable represents the edge size of the current rhombus.\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int>s;\\n        int m = grid.size(), n = grid[0].size();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                int count = 1;\\n                bool fl = true;\\n                s.insert(grid[i][j]);\\n                while(1){\\n                    int r,c, cnt = count;\\n                    int sum = 0;\\n                    r = i+1, c = j-1;\\n                    while(fl&&cnt--){\\n                        if(r>=m||c<0){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r++;\\n                        c--;\\n                    }\\n                    cnt = count;\\n                    r = i + count + 1;\\n                    c = j-count + 1;\\n                    while(fl&&cnt--){\\n                        if(r>=m||c>=n){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r++;\\n                        c++;\\n                    }\\n                    cnt = count;\\n                    r = i + 2*count - 1;\\n                    c = j + 1;\\n                    while(fl&&cnt--){\\n                        if(r<0||c>=n){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r--;\\n                        c++;\\n                    }\\n                    cnt = count;\\n                    r = i + count - 1;\\n                    c = j + count - 1;\\n                    while(fl&&cnt--){\\n                        if(r<0||c<0){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r--;\\n                        c--;\\n                    }\\n                    if(fl){\\n                        s.insert(sum);\\n                    }\\n                    else break;\\n                    count++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        int count = 3;\\n        auto it = s.rbegin();\\n        while(it!=s.rend()&&count--){\\n            ans.push_back(*it);\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int>s;\\n        int m = grid.size(), n = grid[0].size();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                int count = 1;\\n                bool fl = true;\\n                s.insert(grid[i][j]);\\n                while(1){\\n                    int r,c, cnt = count;\\n                    int sum = 0;\\n                    r = i+1, c = j-1;\\n                    while(fl&&cnt--){\\n                        if(r>=m||c<0){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r++;\\n                        c--;\\n                    }\\n                    cnt = count;\\n                    r = i + count + 1;\\n                    c = j-count + 1;\\n                    while(fl&&cnt--){\\n                        if(r>=m||c>=n){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r++;\\n                        c++;\\n                    }\\n                    cnt = count;\\n                    r = i + 2*count - 1;\\n                    c = j + 1;\\n                    while(fl&&cnt--){\\n                        if(r<0||c>=n){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r--;\\n                        c++;\\n                    }\\n                    cnt = count;\\n                    r = i + count - 1;\\n                    c = j + count - 1;\\n                    while(fl&&cnt--){\\n                        if(r<0||c<0){\\n                            fl = false;\\n                            break;\\n                        }\\n                        sum+=grid[r][c];\\n                        r--;\\n                        c--;\\n                    }\\n                    if(fl){\\n                        s.insert(sum);\\n                    }\\n                    else break;\\n                    count++;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        int count = 3;\\n        auto it = s.rbegin();\\n        while(it!=s.rend()&&count--){\\n            ans.push_back(*it);\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238700,
                "title": "simple-o-n-4-brute-force-accepted",
                "content": "Here i\\'ve used a way where if `(i,j)` is the center of rhombus and if `(i+k,j),(i-k,j),(i,j-k),(i,j+k)` are all points which lie inside the grid given then we can calculate rhombus sums for that center considering `(i+k,j),(i-k,j),(i,j-k),(i,j+k)` as vertices.\\n\\nNow how did i calculate the sum, if you notice closely then other than individual values (the values themselves), all the other points have borders(edges) such that the sum of (x and y) coordinates are `i+j-k,i+j+k` (where k can range from 1 to half of the grid size). Thus for 4 sides i used 4 loops to calculate the sum of each side. And at last I reduced the vertices values once from my sum because they were being considered 2 times each while calculating the edge sum.\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        set<int> pq;\\n        for(int i=0;i<r;++i){\\n            for(int j=0;j<c;++j){\\n                if(i==0 || j==0 || i==r-1 || j==c-1){\\n                    pq.insert(grid[i][j]);\\n                    if(pq.size()>3){\\n                        pq.erase(pq.begin());\\n                    }\\n                    continue;\\n                }\\n                pq.insert(grid[i][j]);\\n                \\n                if(pq.size()>3){\\n                    pq.erase(pq.begin());\\n                }\\n                \\n                for(int k=1;k<min(r,c)/2 + 1;++k){\\n                    \\n                    if(i+k < r && i-k >=0 && j+k<c && j-k>=0){\\n                        int temp=0;\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i+a][j+b];\\n                        }\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i-a][j+b];\\n                        }\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i+a][j-b];\\n                        }\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i-a][j-b];\\n                        }\\n                        temp -= (grid[i+k][j]+grid[i][j+k]+grid[i-k][j]+grid[i][j-k]);\\n                        pq.insert(temp);\\n                        if(pq.size()>3){\\n                            pq.erase(pq.begin());\\n                        }\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int i=3;\\n        while(i-- && !pq.empty()){\\n            ans.push_back(*pq.begin());\\n            pq.erase(pq.begin());\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        set<int> pq;\\n        for(int i=0;i<r;++i){\\n            for(int j=0;j<c;++j){\\n                if(i==0 || j==0 || i==r-1 || j==c-1){\\n                    pq.insert(grid[i][j]);\\n                    if(pq.size()>3){\\n                        pq.erase(pq.begin());\\n                    }\\n                    continue;\\n                }\\n                pq.insert(grid[i][j]);\\n                \\n                if(pq.size()>3){\\n                    pq.erase(pq.begin());\\n                }\\n                \\n                for(int k=1;k<min(r,c)/2 + 1;++k){\\n                    \\n                    if(i+k < r && i-k >=0 && j+k<c && j-k>=0){\\n                        int temp=0;\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i+a][j+b];\\n                        }\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i-a][j+b];\\n                        }\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i+a][j-b];\\n                        }\\n                        for(int a=k,b=0;a>=0 && b<=k;a--,b++){\\n                            temp+=grid[i-a][j-b];\\n                        }\\n                        temp -= (grid[i+k][j]+grid[i][j+k]+grid[i-k][j]+grid[i][j-k]);\\n                        pq.insert(temp);\\n                        if(pq.size()>3){\\n                            pq.erase(pq.begin());\\n                        }\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int i=3;\\n        while(i-- && !pq.empty()){\\n            ans.push_back(*pq.begin());\\n            pq.erase(pq.begin());\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036483,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ13. Get Biggest Three Rhombus Sums in a Grid**\\n### Code\\n```\\nclass Solution {\\npublic:\\n    // Function to check if a given cell is within the bounds of the grid\\n    bool isValid(int row, int col, int numRows, int numCols) {\\n        return (row >= 0 && row < numRows && col >= 0 && col < numCols);\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> sums;\\n        // Iterate through all cells in the grid\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                // Insert the value of the cell into the set\\n                sums.insert(grid[i][j]);\\n            }\\n        }\\n        // Iterate through all possible square sizes\\n        for(int squareSize=1; squareSize<=50; squareSize++) {\\n            // Iterate through all cells in the grid\\n            for(int row=0; row<grid.size(); row++) {\\n                for(int col=0; col<grid[0].size(); col++) {\\n                    if(isValid(row-squareSize, col, grid.size(), grid[0].size()) && isValid(row, col-squareSize, grid.size(), grid[0].size()) && isValid(row+squareSize, col, grid.size(), grid[0].size()) && isValid(row, col+squareSize, grid.size(), grid[0].size())) {\\n                        int sum = grid[row-squareSize][col] + grid[row+squareSize][col] + grid[row][col-squareSize] + grid[row][col+squareSize];\\n                        // calculate diagonal sum \\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row-diag][col+squareSize-diag];\\n                        }\\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row-diag][col-squareSize+diag];\\n                        }\\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row+diag][col+squareSize-diag];\\n                        }\\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row+diag][col-squareSize+diag];\\n                        }\\n                        sums.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> sumsList;\\n        for(auto it : sums) {\\n            sumsList.push_back(it);\\n        }\\n        reverse(sumsList.begin(), sumsList.end());\\n        vector<int> topThree;\\n        if(sumsList.size() < 3) {\\n            return sumsList;\\n        }\\n        for(int i = 0; i < 3; i++) {\\n            topThree.push_back(sumsList[i]);\\n        }\\n        return topThree;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check if a given cell is within the bounds of the grid\\n    bool isValid(int row, int col, int numRows, int numCols) {\\n        return (row >= 0 && row < numRows && col >= 0 && col < numCols);\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> sums;\\n        // Iterate through all cells in the grid\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                // Insert the value of the cell into the set\\n                sums.insert(grid[i][j]);\\n            }\\n        }\\n        // Iterate through all possible square sizes\\n        for(int squareSize=1; squareSize<=50; squareSize++) {\\n            // Iterate through all cells in the grid\\n            for(int row=0; row<grid.size(); row++) {\\n                for(int col=0; col<grid[0].size(); col++) {\\n                    if(isValid(row-squareSize, col, grid.size(), grid[0].size()) && isValid(row, col-squareSize, grid.size(), grid[0].size()) && isValid(row+squareSize, col, grid.size(), grid[0].size()) && isValid(row, col+squareSize, grid.size(), grid[0].size())) {\\n                        int sum = grid[row-squareSize][col] + grid[row+squareSize][col] + grid[row][col-squareSize] + grid[row][col+squareSize];\\n                        // calculate diagonal sum \\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row-diag][col+squareSize-diag];\\n                        }\\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row-diag][col-squareSize+diag];\\n                        }\\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row+diag][col+squareSize-diag];\\n                        }\\n                        for(int diag = 1; diag < squareSize; diag++) {\\n                            sum += grid[row+diag][col-squareSize+diag];\\n                        }\\n                        sums.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> sumsList;\\n        for(auto it : sums) {\\n            sumsList.push_back(it);\\n        }\\n        reverse(sumsList.begin(), sumsList.end());\\n        vector<int> topThree;\\n        if(sumsList.size() < 3) {\\n            return sumsList;\\n        }\\n        for(int i = 0; i < 3; i++) {\\n            topThree.push_back(sumsList[i]);\\n        }\\n        return topThree;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012572,
                "title": "c-sets-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(50*n*m)\\n\\n- Space complexity:O(n*m*k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int>s;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                s.insert(grid[i][j]);\\n            }\\n        }\\n        for(int i=1; i<=50; i++){\\n            for(int j=0; j<grid.size(); j++){\\n                for(int k=0; k<grid[0].size(); k++){\\n                    if(isvalid(j-i, k, grid.size(), grid[0].size()) && isvalid(j, k-i, grid.size(), grid[0].size()) && isvalid(j+i, k, grid.size(), grid[0].size()) && isvalid(j, k+i, grid.size(), grid[0].size())){\\n                        int sum=grid[j-i][k]+grid[j+i][k]+grid[j][k-i]+grid[j][k+i];\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j-x][k+i-x];\\n                        }\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j-x][k-i+x];\\n                        }\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j+x][k+i-x];\\n                        }\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j+x][k-i+x];\\n                        }\\n                        s.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>v;\\n        for(auto it: s){\\n            v.push_back(it);\\n        }\\n        reverse(v.begin(), v.end());\\n        vector<int>ans;\\n        if(v.size()<3){return v;}\\n        for(int i=0; i<3; i++){ans.push_back(v[i]);}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int>s;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                s.insert(grid[i][j]);\\n            }\\n        }\\n        for(int i=1; i<=50; i++){\\n            for(int j=0; j<grid.size(); j++){\\n                for(int k=0; k<grid[0].size(); k++){\\n                    if(isvalid(j-i, k, grid.size(), grid[0].size()) && isvalid(j, k-i, grid.size(), grid[0].size()) && isvalid(j+i, k, grid.size(), grid[0].size()) && isvalid(j, k+i, grid.size(), grid[0].size())){\\n                        int sum=grid[j-i][k]+grid[j+i][k]+grid[j][k-i]+grid[j][k+i];\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j-x][k+i-x];\\n                        }\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j-x][k-i+x];\\n                        }\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j+x][k+i-x];\\n                        }\\n                        for(int x=1; x<i; x++){\\n                            sum+=grid[j+x][k-i+x];\\n                        }\\n                        s.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>v;\\n        for(auto it: s){\\n            v.push_back(it);\\n        }\\n        reverse(v.begin(), v.end());\\n        vector<int>ans;\\n        if(v.size()<3){return v;}\\n        for(int i=0; i<3; i++){ans.push_back(v[i]);}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711559,
                "title": "java-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        int left, right, top, bottom;\\n        int curSum;\\n        // priority queue that stores the smallest sum at the top\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->(a-b));\\n        for(int row = 0; row < rowLen; row++){\\n            for(int col = 0; col < colLen; col++){\\n                left = right = col;\\n                top = bottom = row;\\n                // stop when any side hits the border\\n                while(left >= 0 && right <= colLen - 1 && bottom <= rowLen - 1){\\n                    curSum = calculateSum(grid, left, right, top, bottom);\\n                    left--;\\n                    right++;\\n                    bottom += 2;\\n                    \\n                    // add the current sum to the priority queue\\n                    if(!pq.contains(curSum)){\\n                        pq.add(curSum);   \\n                    }\\n                    if(pq.size() > 3){\\n                        pq.remove();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int[] arr = new int[pq.size()];\\n        for(int i = arr.length - 1; i >= 0; i--){\\n            arr[i] = pq.remove();\\n        }\\n        return arr;\\n    }\\n    \\n    private int calculateSum(int[][] grid, int left, int right, int top, int bottom){\\n        int sum = 0;\\n        int leftCol, rightCol;\\n        // find the middle column\\n        leftCol = rightCol = (left + right) / 2;\\n        boolean expand = true;\\n        int curRow = top;\\n        while(curRow <= bottom){\\n            if(leftCol == rightCol){\\n                sum += grid[curRow][leftCol];\\n            }else{\\n                sum += grid[curRow][leftCol] + grid[curRow][rightCol];\\n            }\\n            \\n            if(leftCol == left){\\n                expand = false;\\n            }\\n            \\n            if(expand == false){\\n                // shrinking\\n                leftCol++;\\n                rightCol--;\\n            }else{\\n                // expanding\\n                leftCol--;\\n                rightCol++;\\n            }\\n            curRow++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int rowLen = grid.length;\\n        int colLen = grid[0].length;\\n        int left, right, top, bottom;\\n        int curSum;\\n        // priority queue that stores the smallest sum at the top\\n        Queue<Integer> pq = new PriorityQueue<>((a,b)->(a-b));\\n        for(int row = 0; row < rowLen; row++){\\n            for(int col = 0; col < colLen; col++){\\n                left = right = col;\\n                top = bottom = row;\\n                // stop when any side hits the border\\n                while(left >= 0 && right <= colLen - 1 && bottom <= rowLen - 1){\\n                    curSum = calculateSum(grid, left, right, top, bottom);\\n                    left--;\\n                    right++;\\n                    bottom += 2;\\n                    \\n                    // add the current sum to the priority queue\\n                    if(!pq.contains(curSum)){\\n                        pq.add(curSum);   \\n                    }\\n                    if(pq.size() > 3){\\n                        pq.remove();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int[] arr = new int[pq.size()];\\n        for(int i = arr.length - 1; i >= 0; i--){\\n            arr[i] = pq.remove();\\n        }\\n        return arr;\\n    }\\n    \\n    private int calculateSum(int[][] grid, int left, int right, int top, int bottom){\\n        int sum = 0;\\n        int leftCol, rightCol;\\n        // find the middle column\\n        leftCol = rightCol = (left + right) / 2;\\n        boolean expand = true;\\n        int curRow = top;\\n        while(curRow <= bottom){\\n            if(leftCol == rightCol){\\n                sum += grid[curRow][leftCol];\\n            }else{\\n                sum += grid[curRow][leftCol] + grid[curRow][rightCol];\\n            }\\n            \\n            if(leftCol == left){\\n                expand = false;\\n            }\\n            \\n            if(expand == false){\\n                // shrinking\\n                leftCol++;\\n                rightCol--;\\n            }else{\\n                // expanding\\n                leftCol--;\\n                rightCol++;\\n            }\\n            curRow++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571329,
                "title": "javascript-solution-98-with-comments-and-explanation-feedback-welcomed",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n  \\n  // helper function to calculate area of rhombus\\n  const calculateRhombusArea = (r, c, s) => {\\n    let area = 0;\\n    \\n    for (let i = 0; i < s; i++) {\\n      area += grid[r++][c++];\\n    }\\n    for (let i = 0; i < s; i++) {\\n      area += grid[r++][c--];\\n    }\\n    for (let i = 0; i < s; i++) {\\n      area += grid[r--][c--];\\n    }\\n    for (let i = 0; i < s; i++) {\\n      area += grid[r--][c++];\\n    }\\n    \\n    return area;\\n  }\\n  \\n  // get the smallest dimension of the grid since that will be the max side length possible\\n  let maxSideLength = Math.min(grid.length, grid[0].length);\\n  \\n  // store all 0 sided rhombus\\' area since 0 sided is allowed (its just one cell)\\n  let maxArea = [];\\n  \\n  // run through all spaces in the grid and store the biggest ones\\n  // we only want the 3 greatest area\\'s max \\n  // so we sort descending after we add a new area \\n  // and get rid of the smallest after we get above 3 areas\\n  \\n  for (let row of grid) {\\n    for (let el of row) {\\n      if (!maxArea.includes(el)) {\\n        maxArea.push(el);\\n        if (maxArea.length > 3) {\\n          maxArea.sort((a,b) => b -a);\\n          maxArea.pop();\\n        }\\n      }\\n    }\\n  }\\n  \\n  /*\\n  now we loop through all the cells in the grid as long as each spot is a valid upper point of the rhombus\\n  a valid upper point means that the designated side length will stay within the grids bounds\\n  eg for example one at grid[0][3] => 1 would not be a valid upper point if the side length is 2 because if we went diagonally right we would fall off the grid.1 -> 3 -> dne\\n  if we do end up finding a valid rhombus upper point then we calculate the area with that point as the starting point\\n  */\\n  \\n  for (let side = 1; side <= maxSideLength; side ++) {\\n    for (let row = 0; row < grid.length - (side * 2); row ++) {\\n      for (let col = side; col < grid[0].length - side; col ++) {\\n        let rhombusArea = calculateRhombusArea(row, col, side);\\n        /*\\n        now we check if these new areas are any bigger than the ones we already have if so we repeat the same steps\\n        */\\n        if (!maxArea.includes(rhombusArea)) {\\n          maxArea.push(rhombusArea);\\n          if (maxArea.length > 3) {\\n            maxArea.sort((a,b) => b - a);\\n            maxArea.pop();\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // return the maxArea arr sorted descending\\n  return maxArea.sort((a,b) => b - a);\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n  \\n  // helper function to calculate area of rhombus\\n  const calculateRhombusArea = (r, c, s) => {\\n    let area = 0;\\n    \\n    for (let i = 0; i < s; i++) {\\n      area += grid[r++][c++];\\n    }\\n    for (let i = 0; i < s; i++) {\\n      area += grid[r++][c--];\\n    }\\n    for (let i = 0; i < s; i++) {\\n      area += grid[r--][c--];\\n    }\\n    for (let i = 0; i < s; i++) {\\n      area += grid[r--][c++];\\n    }\\n    \\n    return area;\\n  }\\n  \\n  // get the smallest dimension of the grid since that will be the max side length possible\\n  let maxSideLength = Math.min(grid.length, grid[0].length);\\n  \\n  // store all 0 sided rhombus\\' area since 0 sided is allowed (its just one cell)\\n  let maxArea = [];\\n  \\n  // run through all spaces in the grid and store the biggest ones\\n  // we only want the 3 greatest area\\'s max \\n  // so we sort descending after we add a new area \\n  // and get rid of the smallest after we get above 3 areas\\n  \\n  for (let row of grid) {\\n    for (let el of row) {\\n      if (!maxArea.includes(el)) {\\n        maxArea.push(el);\\n        if (maxArea.length > 3) {\\n          maxArea.sort((a,b) => b -a);\\n          maxArea.pop();\\n        }\\n      }\\n    }\\n  }\\n  \\n  /*\\n  now we loop through all the cells in the grid as long as each spot is a valid upper point of the rhombus\\n  a valid upper point means that the designated side length will stay within the grids bounds\\n  eg for example one at grid[0][3] => 1 would not be a valid upper point if the side length is 2 because if we went diagonally right we would fall off the grid.1 -> 3 -> dne\\n  if we do end up finding a valid rhombus upper point then we calculate the area with that point as the starting point\\n  */\\n  \\n  for (let side = 1; side <= maxSideLength; side ++) {\\n    for (let row = 0; row < grid.length - (side * 2); row ++) {\\n      for (let col = side; col < grid[0].length - side; col ++) {\\n        let rhombusArea = calculateRhombusArea(row, col, side);\\n        /*\\n        now we check if these new areas are any bigger than the ones we already have if so we repeat the same steps\\n        */\\n        if (!maxArea.includes(rhombusArea)) {\\n          maxArea.push(rhombusArea);\\n          if (maxArea.length > 3) {\\n            maxArea.sort((a,b) => b - a);\\n            maxArea.pop();\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // return the maxArea arr sorted descending\\n  return maxArea.sort((a,b) => b - a);\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239133,
                "title": "it-first-fail-for-test-case-93-but-now-beats-90-submission",
                "content": "My approach is to take each cell (x,y) as a centre and draw a largest rhombus possible at `x,y` as centre.\\n\\nIt failr for test case : 93/112\\nMy output : [1331413,1263900,1180548]\\nExpected output : [1331413,1263900,1203482]\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] left = new int[m][n];\\n        int[][] right = new int[m][n];\\n        TreeSet<Integer> set = new TreeSet<>((a,b) -> b-a);\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j <n; j++){\\n                left[i][j] = grid[i][j];\\n                right[i][j] = grid[i][j];\\n                if( i-1 >= 0){\\n                    left[i][j] += j-1 >= 0 ? left[i-1][j-1] : 0;\\n                    right[i][j] += j+1 < n ? right[i-1][j+1] : 0;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                set.add(grid[i][j]);\\n                if( i == m-1 || i == 0 || j == 0 || j == n-1)\\n                    continue;\\n                int up = i;\\n                int down = i;\\n                int left_ = j;\\n                int right_ = j;\\n                int sum = 0;\\n                while( up > 0 && down < m-1 && left_ > 0 && right_ < n-1){\\n                    up--;\\n                    down++;\\n                    left_--;\\n                    right_++;\\n                }\\n                int side1 = right[i][left_] - right[up][j];\\n                int side2 = left[down][j] - left[i][left_];\\n                int side3 = left[i][right_] - left[up][j];\\n                int side4 = right[down][j] - right[i][right_];\\n                int temp = side1 + side2 + side3 + side4 + grid[up][j] - grid[down][j];\\n                set.add(temp);\\n            }\\n        }\\n        ArrayList<Integer> res = new ArrayList<>();\\n        while( res.size() < 3 && !set.isEmpty())\\n            res.add(set.pollFirst());\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n\\n**Working solution **\\n\\n@egermundson\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] left = new int[m][n];\\n        int[][] right = new int[m][n];\\n        TreeSet<Integer> set = new TreeSet<>((a,b) -> b-a);\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j <n; j++){\\n                left[i][j] = grid[i][j];\\n                right[i][j] = grid[i][j];\\n                if( i-1 >= 0){\\n                    left[i][j] += j-1 >= 0 ? left[i-1][j-1] : 0;\\n                    right[i][j] += j+1 < n ? right[i-1][j+1] : 0;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                set.add(grid[i][j]);\\n                if( i == m-1 || i == 0 || j == 0 || j == n-1)\\n                    continue;\\n                int up = i-1, down = i+1;\\n                int left_ = j-1, right_ = j+1;\\n\\n                while( up >= 0 && down <= m-1 && left_ >= 0 && right_ <= n-1){\\n                    int side1 = right[i][left_] - right[up][j];\\n                    int side2 = left[down][j] - left[i][left_];\\n                    int side3 = left[i][right_] - left[up][j];\\n                    int side4 = right[down][j] - right[i][right_];\\n                    int temp = side1 + side2 + side3 + side4 + grid[up][j] - grid[down][j];\\n                    set.add(temp);\\n                    up--;\\n                    down++;\\n                    left_--;\\n                    right_++;\\n                }\\n            }\\n        }\\n        ArrayList<Integer> res = new ArrayList<>();\\n        while( res.size() < 3 && !set.isEmpty())\\n            res.add(set.pollFirst());\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] left = new int[m][n];\\n        int[][] right = new int[m][n];\\n        TreeSet<Integer> set = new TreeSet<>((a,b) -> b-a);\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j <n; j++){\\n                left[i][j] = grid[i][j];\\n                right[i][j] = grid[i][j];\\n                if( i-1 >= 0){\\n                    left[i][j] += j-1 >= 0 ? left[i-1][j-1] : 0;\\n                    right[i][j] += j+1 < n ? right[i-1][j+1] : 0;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                set.add(grid[i][j]);\\n                if( i == m-1 || i == 0 || j == 0 || j == n-1)\\n                    continue;\\n                int up = i;\\n                int down = i;\\n                int left_ = j;\\n                int right_ = j;\\n                int sum = 0;\\n                while( up > 0 && down < m-1 && left_ > 0 && right_ < n-1){\\n                    up--;\\n                    down++;\\n                    left_--;\\n                    right_++;\\n                }\\n                int side1 = right[i][left_] - right[up][j];\\n                int side2 = left[down][j] - left[i][left_];\\n                int side3 = left[i][right_] - left[up][j];\\n                int side4 = right[down][j] - right[i][right_];\\n                int temp = side1 + side2 + side3 + side4 + grid[up][j] - grid[down][j];\\n                set.add(temp);\\n            }\\n        }\\n        ArrayList<Integer> res = new ArrayList<>();\\n        while( res.size() < 3 && !set.isEmpty())\\n            res.add(set.pollFirst());\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] left = new int[m][n];\\n        int[][] right = new int[m][n];\\n        TreeSet<Integer> set = new TreeSet<>((a,b) -> b-a);\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j <n; j++){\\n                left[i][j] = grid[i][j];\\n                right[i][j] = grid[i][j];\\n                if( i-1 >= 0){\\n                    left[i][j] += j-1 >= 0 ? left[i-1][j-1] : 0;\\n                    right[i][j] += j+1 < n ? right[i-1][j+1] : 0;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                set.add(grid[i][j]);\\n                if( i == m-1 || i == 0 || j == 0 || j == n-1)\\n                    continue;\\n                int up = i-1, down = i+1;\\n                int left_ = j-1, right_ = j+1;\\n\\n                while( up >= 0 && down <= m-1 && left_ >= 0 && right_ <= n-1){\\n                    int side1 = right[i][left_] - right[up][j];\\n                    int side2 = left[down][j] - left[i][left_];\\n                    int side3 = left[i][right_] - left[up][j];\\n                    int side4 = right[down][j] - right[i][right_];\\n                    int temp = side1 + side2 + side3 + side4 + grid[up][j] - grid[down][j];\\n                    set.add(temp);\\n                    up--;\\n                    down++;\\n                    left_--;\\n                    right_++;\\n                }\\n            }\\n        }\\n        ArrayList<Integer> res = new ArrayList<>();\\n        while( res.size() < 3 && !set.isEmpty())\\n            res.add(set.pollFirst());\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238853,
                "title": "c-accepted-brute-force-solution-with-scope-for-optimisation-to-reuse-calculated-sums",
                "content": "```csharp\\npublic class ReverseComparer : Comparer<int>\\n{\\n\\tpublic override int Compare(int x, int y)\\n\\t{\\n\\t\\treturn y.CompareTo(x);\\n\\t}\\n}\\n\\npublic int[] GetBiggestThree(int[][] grid)\\n{\\n\\tSortedSet<int> sums = new SortedSet<int>(new ReverseComparer());\\n\\n\\tfor (int i = 0; i < grid.Length; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < grid[i].Length; j++)\\n\\t\\t{\\n\\t\\t\\tsums.Add(grid[i][j]);\\n\\t\\t\\tgetRhombus(grid, i, j, sums);\\n\\t\\t}\\n\\t}\\n\\n\\treturn sums.Take(3).ToArray();\\n}\\n\\nprivate void getRhombus(int[][] grid, int row, int column, SortedSet<int> sums)\\n{\\n\\tint length = 1;\\n\\n\\twhile (column - length >= 0 && column + length < grid[0].Length\\n\\t\\t\\t&& row + 2 * length < grid.Length)\\n\\t{\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i <= length; i++)\\n\\t\\t{\\n\\t\\t\\tsum += grid[row + i][column - i];\\n\\t\\t\\tsum += grid[row + i][column + i];\\n\\t\\t\\tsum += grid[row + length + i][column + length - i];\\n\\t\\t\\tsum += grid[row + length + i][column - length + i];\\n\\t\\t}\\n\\n\\t\\tsum -= grid[row][column];\\n\\t\\tsum -= grid[row + length][column - length];                \\n\\t\\tsum -= grid[row + length][column + length];\\n\\t\\tsum -= grid[row + 2 * length][column];\\n\\n\\t\\tsums.Add(sum);\\n\\t\\tlength++;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class ReverseComparer : Comparer<int>\\n{\\n\\tpublic override int Compare(int x, int y)\\n\\t{\\n\\t\\treturn y.CompareTo(x);\\n\\t}\\n}\\n\\npublic int[] GetBiggestThree(int[][] grid)\\n{\\n\\tSortedSet<int> sums = new SortedSet<int>(new ReverseComparer());\\n\\n\\tfor (int i = 0; i < grid.Length; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < grid[i].Length; j++)\\n\\t\\t{\\n\\t\\t\\tsums.Add(grid[i][j]);\\n\\t\\t\\tgetRhombus(grid, i, j, sums);\\n\\t\\t}\\n\\t}\\n\\n\\treturn sums.Take(3).ToArray();\\n}\\n\\nprivate void getRhombus(int[][] grid, int row, int column, SortedSet<int> sums)\\n{\\n\\tint length = 1;\\n\\n\\twhile (column - length >= 0 && column + length < grid[0].Length\\n\\t\\t\\t&& row + 2 * length < grid.Length)\\n\\t{\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i <= length; i++)\\n\\t\\t{\\n\\t\\t\\tsum += grid[row + i][column - i];\\n\\t\\t\\tsum += grid[row + i][column + i];\\n\\t\\t\\tsum += grid[row + length + i][column + length - i];\\n\\t\\t\\tsum += grid[row + length + i][column - length + i];\\n\\t\\t}\\n\\n\\t\\tsum -= grid[row][column];\\n\\t\\tsum -= grid[row + length][column - length];                \\n\\t\\tsum -= grid[row + length][column + length];\\n\\t\\tsum -= grid[row + 2 * length][column];\\n\\n\\t\\tsums.Add(sum);\\n\\t\\tlength++;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238831,
                "title": "bruteforce-solution-108-ms",
                "content": "So the idea is to check all rhombuses possible at every coordinate.\\nRhombus is a symmetrical shape, somewhat like circle so we dont need to traverse it completely, we can do one quadrant and get the other coordinates by symmetry only.\\nFirst we need to check if a rhombus of distance _d_ from the center is possible or not, ie a rhombus whoose vertices are at _d_ distance from the center say [i, j] then I have traversed the first quadrant only and mapped the points to rest of the quadrants using the paramater _x_ (0 < x < d for a particular _d_).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& g) {\\n        priority_queue<int> pq;\\n        for(int i = 0; i < g.size(); ++i) {\\n            for(int j = 0; j < g[i].size(); ++j) {\\n                pq.push(g[i][j]); // Putting the 0 distance rhombus sum\\n                int d = 1;\\n                while(i - d >= 0 and i + d < g.size() and j - d >= 0 and j + d < g[i].size()) {\\n                    int tem = 0;\\n                    tem += g[i][j + d] + g[i][j - d] + g[i + d][j] + g[i - d][j];\\n                    for(int x = 1; x < d; ++x) {\\n                        tem += g[i - d + x][j + x] + g[i - d + x][j - x] + g[i + d - x][j - x] + g[i + d - x][j + x]; // points from all 4 quadrants\\n                    }\\n                    pq.push(tem);\\n                    ++d;\\n                }\\n            }\\n        }\\n        int k = 3;\\n        vector<int> ans;\\n\\t\\t// just taking top 3 elements from the priority queue\\n        while(pq.size() and k--) {\\n            int x = pq.top();\\n            ans.push_back(x);\\n            while(pq.size() and pq.top() == x) pq.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& g) {\\n        priority_queue<int> pq;\\n        for(int i = 0; i < g.size(); ++i) {\\n            for(int j = 0; j < g[i].size(); ++j) {\\n                pq.push(g[i][j]); // Putting the 0 distance rhombus sum\\n                int d = 1;\\n                while(i - d >= 0 and i + d < g.size() and j - d >= 0 and j + d < g[i].size()) {\\n                    int tem = 0;\\n                    tem += g[i][j + d] + g[i][j - d] + g[i + d][j] + g[i - d][j];\\n                    for(int x = 1; x < d; ++x) {\\n                        tem += g[i - d + x][j + x] + g[i - d + x][j - x] + g[i + d - x][j - x] + g[i + d - x][j + x]; // points from all 4 quadrants\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1238691,
                "title": "python-3-greedy",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        def calculate(i,j,s,n,m):\\n            p = i; q = i; up = 0; dn=0\\n            x = 0\\n            while i >= 0 and j <m and up != s:\\n                up+=1\\n                x += grid[i][j]\\n                i-=1\\n                j+=1\\n            \\n            while dn != s:\\n                dn+=1\\n                x += grid[i][j]\\n                i+=1; j+=1\\n            \\n            dw2 = 0\\n            while dw2 != s:\\n                dw2+=1\\n                x += grid[i][j]\\n                i+=1\\n                j-=1\\n            up2 = 0\\n            while up2 != s:\\n                up2 +=1\\n                x += grid[i][j]\\n                i-=1\\n                j-=1\\n            return x\\n            \\n            \\n        n = len(grid); m = len(grid[0])\\n        arr = []\\n        for row in grid:\\n            for ele in row:\\n                arr.append(ele)\\n                \\n        for size in range(1,n - 2+1):\\n            for i in range(size, n - size):\\n                for j in range(0, m - 2*size):\\n                    ans = calculate(i,j,size,n,m)\\n                    arr.append(ans)\\n        arr.sort(reverse=True)\\n        s = set()\\n        i = 0\\n        while i < len(arr) and  len(s) < 3:\\n            s.add(arr[i])\\n            i+=1\\n        if len(s) == 3:\\n            return sorted(list(s),reverse = True)\\n        return sorted(list(s),reverse = True)\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        def calculate(i,j,s,n,m):\\n            p = i; q = i; up = 0; dn=0\\n            x = 0\\n            while i >= 0 and j <m and up != s:\\n                up+=1\\n                x += grid[i][j]\\n                i-=1\\n                j+=1\\n            \\n            while dn != s:\\n                dn+=1\\n                x += grid[i][j]\\n                i+=1; j+=1\\n            \\n            dw2 = 0\\n            while dw2 != s:\\n                dw2+=1\\n                x += grid[i][j]\\n                i+=1\\n                j-=1\\n            up2 = 0\\n            while up2 != s:\\n                up2 +=1\\n                x += grid[i][j]\\n                i-=1\\n                j-=1\\n            return x\\n            \\n            \\n        n = len(grid); m = len(grid[0])\\n        arr = []\\n        for row in grid:\\n            for ele in row:\\n                arr.append(ele)\\n                \\n        for size in range(1,n - 2+1):\\n            for i in range(size, n - size):\\n                for j in range(0, m - 2*size):\\n                    ans = calculate(i,j,size,n,m)\\n                    arr.append(ans)\\n        arr.sort(reverse=True)\\n        s = set()\\n        i = 0\\n        while i < len(arr) and  len(s) < 3:\\n            s.add(arr[i])\\n            i+=1\\n        if len(s) == 3:\\n            return sorted(list(s),reverse = True)\\n        return sorted(list(s),reverse = True)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238689,
                "title": "brute-force",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun getBiggestThree(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): IntArray {\\n        var best = mutableSetOf<Int>()\\n        var M = A.size\\n        var N = A[0].size\\n        fun cost(i: Int, j: Int, k: Int): Int {\\n            var U = i\\n            var D = i + 2 * k\\n            var L = j - k\\n            var R = j + k\\n            if (!(D < M && 0 <= L && R < N))     // \\uD83D\\uDEAB out-of-bounds\\n                return -INF\\n            var t = A[i][j]                      // \\uD83D\\uDCB0 total t accumulated square sum\\n            L = j\\n            R = j\\n            while (U <= D) {\\n                if (L != R) t += A[U][L] + A[U][R]\\n                if (U != D) t += A[D][L] + if (L != R) A[D][R] else 0\\n                ++U; --D\\n                --L; ++R\\n            }\\n            return t\\n        }\\n        for (k in 0 until Math.min(M, N) / 2 + 1)\\n            for (i in 0 until M)\\n                for (j in 0 until N)\\n                    best.add(cost(i, j, k))\\n        return best.toMutableList().sorted().reversed().slice(0 until Math.min(best.size, 3)).toIntArray()  // \\uD83C\\uDFAF top 3 best candidates\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getBiggestThree = (A, best = new Set()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let cost = (i, j, k) => {\\n        let U = i,\\n            D = i + 2 * k,\\n            L = j - k,\\n            R = j + k;\\n        if (!(D < M && 0 <= L && R < N))                                                // \\uD83D\\uDEAB out-of-bounds\\n            return -Infinity;\\n        let t = A[i][j];                                                                // \\uD83D\\uDCB0 total t accumulated square sum\\n        L = j;\\n        R = j;\\n        while (U <= D) {\\n            if (L != R) t += A[U][L] + A[U][R];\\n            if (U != D) t += A[D][L] + (L != R ? A[D][R] : 0)\\n            ++U, --D;\\n            --L, ++R;\\n        }\\n        return t;\\n    };\\n    for (let k = 0; k < Math.floor(Math.min(M, N) / 2) + 1; ++k)\\n        for (let i = 0; i < M; ++i)\\n            for (let j = 0; j < N; ++j)\\n                best.add(cost(i, j, k));\\n    return [...best].sort((a, b) => a - b).reverse().slice(0, Math.min(best.size, 3));  // \\uD83C\\uDFAF top 3 best candidates\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getBiggestThree(self, A: List[List[int]], INF = int(1e9 + 7)) -> List[int]:\\n        M = len(A)\\n        N = len(A[0])\\n        def cost(i, j, k):\\n            U = i\\n            D = i + 2 * k\\n            L = j - k\\n            R = j + k\\n            if not (0 <= L and R < N and D < M):                          # \\uD83D\\uDEAB out-of-bounds\\n                return -INF\\n            t = A[i][j]                                                   # \\uD83D\\uDCB0 total t accumulated square sum\\n            L = j\\n            R = j\\n            while U <= D:\\n                if U != D: t += A[D][L] + (A[D][R] if L != R else 0)\\n                if L != R: t += A[U][L] + A[U][R]\\n                U += 1; D -= 1\\n                L -= 1; R += 1\\n            return t\\n        best = set()\\n        for k in range(0, min(M, N) // 2 + 1):\\n            for i in range(M):\\n                for j in range(N):\\n                    best.add(cost(i, j, k))\\n        ans = list(best)\\n        ans.sort()\\n        ans.reverse()\\n        return ans[:min(len(ans), 3)]                                      # \\uD83C\\uDFAF top 3 best candidates\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    VI getBiggestThree(VVI& A, Set best = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto cost = [&](auto i, auto j, auto k) {\\n            auto U = i,\\n                 D = i + 2 * k,\\n                 L = j - k,\\n                 R = j + k;\\n            if (!(D < M && 0 <= L && R < N))                              // \\uD83D\\uDEAB out-of-bounds\\n                return -INF;\\n            auto t = A[i][j];                                             // \\uD83D\\uDCB0 total t accumulated square sum\\n            L = j;\\n            R = j;\\n            while (U <= D) {\\n                if (L != R) t += A[U][L] + A[U][R];\\n                if (U != D) t += A[D][L] + (L != R ? A[D][R] : 0);\\n                ++U, --D;\\n                --L, ++R;\\n            }\\n            return t;\\n        };\\n        for (auto k{ 0 }; k < min(M, N) / 2 + 1; ++k)\\n            for (auto i{ 0 }; i < M; ++i)\\n                for (auto j{ 0 }; j < N; ++j)\\n                    best.insert(cost(i, j, k));\\n        VI ans{ best.begin(), best.end() };\\n        sort(ans.begin(), ans.end());\\n        return { ans.rbegin(), ans.rbegin() + min((int)ans.size(), 3) };  // \\uD83C\\uDFAF top 3 best candidates\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getBiggestThree(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): IntArray {\\n        var best = mutableSetOf<Int>()\\n        var M = A.size\\n        var N = A[0].size\\n        fun cost(i: Int, j: Int, k: Int): Int {\\n            var U = i\\n            var D = i + 2 * k\\n            var L = j - k\\n            var R = j + k\\n            if (!(D < M && 0 <= L && R < N))     // \\uD83D\\uDEAB out-of-bounds\\n                return -INF\\n            var t = A[i][j]                      // \\uD83D\\uDCB0 total t accumulated square sum\\n            L = j\\n            R = j\\n            while (U <= D) {\\n                if (L != R) t += A[U][L] + A[U][R]\\n                if (U != D) t += A[D][L] + if (L != R) A[D][R] else 0\\n                ++U; --D\\n                --L; ++R\\n            }\\n            return t\\n        }\\n        for (k in 0 until Math.min(M, N) / 2 + 1)\\n            for (i in 0 until M)\\n                for (j in 0 until N)\\n                    best.add(cost(i, j, k))\\n        return best.toMutableList().sorted().reversed().slice(0 until Math.min(best.size, 3)).toIntArray()  // \\uD83C\\uDFAF top 3 best candidates\\n    }\\n}\\n```\n```\\nlet getBiggestThree = (A, best = new Set()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let cost = (i, j, k) => {\\n        let U = i,\\n            D = i + 2 * k,\\n            L = j - k,\\n            R = j + k;\\n        if (!(D < M && 0 <= L && R < N))                                                // \\uD83D\\uDEAB out-of-bounds\\n            return -Infinity;\\n        let t = A[i][j];                                                                // \\uD83D\\uDCB0 total t accumulated square sum\\n        L = j;\\n        R = j;\\n        while (U <= D) {\\n            if (L != R) t += A[U][L] + A[U][R];\\n            if (U != D) t += A[D][L] + (L != R ? A[D][R] : 0)\\n            ++U, --D;\\n            --L, ++R;\\n        }\\n        return t;\\n    };\\n    for (let k = 0; k < Math.floor(Math.min(M, N) / 2) + 1; ++k)\\n        for (let i = 0; i < M; ++i)\\n            for (let j = 0; j < N; ++j)\\n                best.add(cost(i, j, k));\\n    return [...best].sort((a, b) => a - b).reverse().slice(0, Math.min(best.size, 3));  // \\uD83C\\uDFAF top 3 best candidates\\n};\\n```\n```\\nclass Solution:\\n    def getBiggestThree(self, A: List[List[int]], INF = int(1e9 + 7)) -> List[int]:\\n        M = len(A)\\n        N = len(A[0])\\n        def cost(i, j, k):\\n            U = i\\n            D = i + 2 * k\\n            L = j - k\\n            R = j + k\\n            if not (0 <= L and R < N and D < M):                          # \\uD83D\\uDEAB out-of-bounds\\n                return -INF\\n            t = A[i][j]                                                   # \\uD83D\\uDCB0 total t accumulated square sum\\n            L = j\\n            R = j\\n            while U <= D:\\n                if U != D: t += A[D][L] + (A[D][R] if L != R else 0)\\n                if L != R: t += A[U][L] + A[U][R]\\n                U += 1; D -= 1\\n                L -= 1; R += 1\\n            return t\\n        best = set()\\n        for k in range(0, min(M, N) // 2 + 1):\\n            for i in range(M):\\n                for j in range(N):\\n                    best.add(cost(i, j, k))\\n        ans = list(best)\\n        ans.sort()\\n        ans.reverse()\\n        return ans[:min(len(ans), 3)]                                      # \\uD83C\\uDFAF top 3 best candidates\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    VI getBiggestThree(VVI& A, Set best = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto cost = [&](auto i, auto j, auto k) {\\n            auto U = i,\\n                 D = i + 2 * k,\\n                 L = j - k,\\n                 R = j + k;\\n            if (!(D < M && 0 <= L && R < N))                              // \\uD83D\\uDEAB out-of-bounds\\n                return -INF;\\n            auto t = A[i][j];                                             // \\uD83D\\uDCB0 total t accumulated square sum\\n            L = j;\\n            R = j;\\n            while (U <= D) {\\n                if (L != R) t += A[U][L] + A[U][R];\\n                if (U != D) t += A[D][L] + (L != R ? A[D][R] : 0);\\n                ++U, --D;\\n                --L, ++R;\\n            }\\n            return t;\\n        };\\n        for (auto k{ 0 }; k < min(M, N) / 2 + 1; ++k)\\n            for (auto i{ 0 }; i < M; ++i)\\n                for (auto j{ 0 }; j < N; ++j)\\n                    best.insert(cost(i, j, k));\\n        VI ans{ best.begin(), best.end() };\\n        sort(ans.begin(), ans.end());\\n        return { ans.rbegin(), ans.rbegin() + min((int)ans.size(), 3) };  // \\uD83C\\uDFAF top 3 best candidates\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636910,
                "title": "c-easy-to-understand-detailed",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<vector<int> > ld = grid, rd = grid;//ld = left diagonal, rd = right diagonal\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int pi = i - 1;\\n                int prevj = j - 1;\\n                if(pi >= 0 && prevj >= 0) ld[i][j] += ld[pi][prevj];\\n                prevj = j + 1;\\n                if(pi >= 0 && prevj < n) rd[i][j] += rd[pi][prevj];\\n            }\\n        }\\n        map<int, int> cnt;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ++cnt[grid[i][j]];\\n                for(int k = 1; k <=max(m, n); ++k) {\\n                    int left = j - k;\\n                    int right = j + k;\\n                    int bot = i + 2 * k;\\n                    if(left < 0 || right >= n || bot >= m) continue;\\n                    int sum = rd[i + k][left] - rd[i][j] \\n                                         + ld[i + k][right] - ld[i][j] \\n                                         + ld[bot][j] - ld[i + k][left]\\n                                         + rd[bot][j] - rd[i + k][right]\\n                                         + grid[i][j] - grid[bot][j];\\n                    ++cnt[sum];\\n                }\\n                while(cnt.size() > 3) {\\n                    auto it = cnt.begin();\\n                    cnt.erase(it);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = cnt.rbegin(); it != cnt.rend(); it++) {\\n            ans.push_back(it->first);\\n            if(ans.size() >= 3) return ans;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<vector<int> > ld = grid, rd = grid;//ld = left diagonal, rd = right diagonal\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int pi = i - 1;\\n                int prevj = j - 1;\\n                if(pi >= 0 && prevj >= 0) ld[i][j] += ld[pi][prevj];\\n                prevj = j + 1;\\n                if(pi >= 0 && prevj < n) rd[i][j] += rd[pi][prevj];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2384412,
                "title": "simple-easy-brute-force-solution-using-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        priority_queue<int> pq;\\n        int col = grid[0].size();\\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                int length = 1;\\n                pq.push(grid[i][j]);\\n                while(true){\\n                    bool flag = false;\\n                    int temp = length;\\n                    int tempRow = i;\\n                    int tempCol = j;\\n                    int tempSum = 0;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow + 1 < row){\\n                            tempRow++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol - 1 >= 0){\\n                            tempCol--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow + 1 < row){\\n                            tempRow++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol + 1 < col){\\n                            tempCol++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow - 1 >= 0){\\n                            tempRow--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol + 1 < col){\\n                            tempCol++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow - 1 >= 0){\\n                            tempRow--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol - 1 >= 0){\\n                            tempCol--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    pq.push(tempSum);\\n                    length++;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int prev = -1;\\n        int count = 0;\\n        while(count != 3 && !pq.empty()){\\n            if(pq.top() != prev){\\n                prev = pq.top();\\n                ans.push_back(pq.top());\\n                count++;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        priority_queue<int> pq;\\n        int col = grid[0].size();\\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                int length = 1;\\n                pq.push(grid[i][j]);\\n                while(true){\\n                    bool flag = false;\\n                    int temp = length;\\n                    int tempRow = i;\\n                    int tempCol = j;\\n                    int tempSum = 0;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow + 1 < row){\\n                            tempRow++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol - 1 >= 0){\\n                            tempCol--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow + 1 < row){\\n                            tempRow++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol + 1 < col){\\n                            tempCol++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow - 1 >= 0){\\n                            tempRow--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol + 1 < col){\\n                            tempCol++;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    for(int l = 1 ; l <= temp ; l++){\\n                        if(tempRow - 1 >= 0){\\n                            tempRow--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        if(tempCol - 1 >= 0){\\n                            tempCol--;\\n                        }\\n                        else{\\n                            flag = true;\\n                            break;\\n                        }\\n                        tempSum += grid[tempRow][tempCol];\\n                    }\\n                    if(flag) break;\\n                    pq.push(tempSum);\\n                    length++;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int prev = -1;\\n        int count = 0;\\n        while(count != 3 && !pq.empty()){\\n            if(pq.top() != prev){\\n                prev = pq.top();\\n                ans.push_back(pq.top());\\n                count++;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267135,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // As contraints are small so O(n3) approach also works\\n    // So , consider each cell as center and make the rhombus of every possible size taking this cell as center.\\n    // find the sum of elements at border and insert it in set , and after inserting maitain the size of set to 3\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) \\n    {\\n        set<int , greater<int>> st;\\n        int n = grid.size() , m = grid[0].size();\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                int sz = 0;\\n                while(i - sz >= 0 && i + sz < n && j - sz >= 0 && j + sz < m)\\n                {\\n                    int sum = 0 , d = 0;\\n                    for(int k = i-sz;k<=i;k++)\\n                    {\\n                        if(d == 0) // corner element\\n                            sum += grid[k][j+d];\\n                        else \\n                            sum += (grid[k][j-d] + grid[k][j+d]);\\n                        d+=1;\\n                    }\\n                    d = 0;\\n                    for(int k = i+sz;k>i;k--)\\n                    {\\n                        if(d == 0) // corner element\\n                            sum += grid[k][j+d];\\n                        else \\n                            sum += (grid[k][j-d] + grid[k][j+d]);\\n                        d+=1;\\n                    }\\n                    \\n                    st.insert(sum);\\n                    if(st.size() > 3)\\n                    {\\n                        st.erase(prev(st.end()));\\n                    }\\n                    sz+=1; // increase size of rhombus\\n                }\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(auto &i :st)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // As contraints are small so O(n3) approach also works\\n    // So , consider each cell as center and make the rhombus of every possible size taking this cell as center.\\n    // find the sum of elements at border and insert it in set , and after inserting maitain the size of set to 3\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) \\n    {\\n        set<int , greater<int>> st;\\n        int n = grid.size() , m = grid[0].size();\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                int sz = 0;\\n                while(i - sz >= 0 && i + sz < n && j - sz >= 0 && j + sz < m)\\n                {\\n                    int sum = 0 , d = 0;\\n                    for(int k = i-sz;k<=i;k++)\\n                    {\\n                        if(d == 0) // corner element\\n                            sum += grid[k][j+d];\\n                        else \\n                            sum += (grid[k][j-d] + grid[k][j+d]);\\n                        d+=1;\\n                    }\\n                    d = 0;\\n                    for(int k = i+sz;k>i;k--)\\n                    {\\n                        if(d == 0) // corner element\\n                            sum += grid[k][j+d];\\n                        else \\n                            sum += (grid[k][j-d] + grid[k][j+d]);\\n                        d+=1;\\n                    }\\n                    \\n                    st.insert(sum);\\n                    if(st.size() > 3)\\n                    {\\n                        st.erase(prev(st.end()));\\n                    }\\n                    sz+=1; // increase size of rhombus\\n                }\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(auto &i :st)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360208,
                "title": "brute-force-75-speed",
                "content": "Runtime: 1284 ms, faster than 75.68%\\nMemory Usage: 14.8 MB, less than 85.07%\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        first = second = third = 0\\n\\n        def update_sums(val):\\n            nonlocal first, second, third\\n            if val > first:\\n                third = second\\n                second = first\\n                first = val\\n            elif first > val > second:\\n                third = second\\n                second = val\\n            elif second > val > third:\\n                third = val\\n\\n        rows, cols = len(grid), len(grid[0])\\n        max_size = max(rows // 2, cols // 2) + 1\\n        for r in range(rows):\\n            for c in range(cols):\\n                update_sums(grid[r][c])\\n                for n in range(1, max_size):\\n                    if c + 2 * n < cols and r - n >= 0 and r + n < rows:\\n                        sum_rhombus = (grid[r][c] + grid[r][c + 2 * n] +\\n                                       grid[r - n][c + n] + grid[r + n][c + n])\\n                        end_c = c + 2 * n\\n                        for i in range(1, n):\\n                            sum_rhombus += (grid[r + i][c + i] +\\n                                            grid[r - i][c + i] +\\n                                            grid[r + i][end_c - i] +\\n                                            grid[r - i][end_c - i])\\n                        update_sums(sum_rhombus)\\n                    else:\\n                        break\\n        biggest = {first, second, third} - {0}\\n        return sorted(biggest, reverse=True)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        first = second = third = 0\\n\\n        def update_sums(val):\\n            nonlocal first, second, third\\n            if val > first:\\n                third = second\\n                second = first\\n                first = val\\n            elif first > val > second:\\n                third = second\\n                second = val\\n            elif second > val > third:\\n                third = val\\n\\n        rows, cols = len(grid), len(grid[0])\\n        max_size = max(rows // 2, cols // 2) + 1\\n        for r in range(rows):\\n            for c in range(cols):\\n                update_sums(grid[r][c])\\n                for n in range(1, max_size):\\n                    if c + 2 * n < cols and r - n >= 0 and r + n < rows:\\n                        sum_rhombus = (grid[r][c] + grid[r][c + 2 * n] +\\n                                       grid[r - n][c + n] + grid[r + n][c + n])\\n                        end_c = c + 2 * n\\n                        for i in range(1, n):\\n                            sum_rhombus += (grid[r + i][c + i] +\\n                                            grid[r - i][c + i] +\\n                                            grid[r + i][end_c - i] +\\n                                            grid[r - i][end_c - i])\\n                        update_sums(sum_rhombus)\\n                    else:\\n                        break\\n        biggest = {first, second, third} - {0}\\n        return sorted(biggest, reverse=True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257263,
                "title": "cpp-faster-than-100-memory-less-than-98-with-explanation",
                "content": "The basic idea is to iterate over all the point in the 2d vector one by one.\\nCheck the point\\'s value, the sum of sides of Rhombus with this point at center (for all possible rhombuses around this point) and store the top 3 in 3 distinct variables \\n\\n```\\nclass Solution {\\npublic:vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        int max1=0,max2=0,max3=0,i,j; // variable to store 3 max elements\\n        int len,sum;\\n        \\n        for(i=0;i<grid.size();i++)\\n        {\\n            for(j=0;j<grid[i].size();j++)\\n            {\\n                sum = 0;\\n                len=0;\\n                if(i==0 || j==0 || i==grid.size()-1 || j==grid[i].size()-1)     //no need to check for rhombus in case of end element\\n                {\\n                    sum = grid[i][j];\\n                    //check the elements value and compare it with 3 max values\\n                    if(sum>max1)\\n                    {\\n                        max3=max2;\\n                        max2=max1;\\n                        max1=sum;\\n                    }\\n                    else if(sum>max2 && sum!=max1)\\n                    {\\n                        max3=max2;\\n                        max2=sum;\\n                    }\\n                    else if(sum>max3 && sum!=max2 && sum!=max1)\\n                    {\\n                        max3=sum;\\n                    }\\n                }\\n                else // if the point is not an end point, atleast a rhombus can be formed\\n                {\\n                    while((i-len-1)>=0 && (i+len+1)<grid.size() && (j-len-1)>=0 && (j+len+1)<grid[i].size() ) //loop to iterate over all the rhombuses for the given point i,j as center\\n                    {\\n                        sum = 0;\\n                        len++;  //len is half of diagonal length of rhombus\\n                        sum += grid[i+len][j];      //rightmost point of rhombus\\n                        sum += grid[i][j+len];      //bottommost point of rhombus\\n                        sum += grid[i-len][j];      //leftmost point of rhombus\\n                        sum += grid[i][j-len];      //topmost point of rhombus\\n                        \\n                        for(int k=1;k<len;k++)      // loop to get all the point along the edges\\n                        {\\n                            sum +=grid[i+len-k][j+k];\\n                            sum += grid[i-k][j+len-k];\\n                            sum += grid[i-len+k][j-k];\\n                            sum += grid[i+k][j-len+k];        \\n                        }\\n                        \\n                        \\n                        \\n                        if(sum<grid[i][j])          //compare the rhombus sum with center point\\'s value\\n                            sum = grid[i][j];\\n                        //compare the sum with 3 max values\\n                        if(sum>max1)\\n                        {\\n                            max3=max2;\\n                            max2=max1;\\n                            max1=sum;\\n                        }\\n                        else if(sum>max2 && sum!=max1)\\n                        {\\n                            max3=max2;\\n                            max2=sum;\\n                        }\\n                        else if(sum>max3 && sum!=max2 && sum!=max1)\\n                        {\\n                            max3=sum;\\n                        }\\n                        \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        vector <int> ans;  \\n    \\n        //  push the values in a vector before returning it\\n        if (max1!=0)\\n            ans.push_back(max1);\\n        if (max2!=0)\\n            ans.push_back(max2);\\n        if (max3!=0)\\n            ans.push_back(max3);\\n        \\n        return ans;\\n            \\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        int max1=0,max2=0,max3=0,i,j; // variable to store 3 max elements\\n        int len,sum;\\n        \\n        for(i=0;i<grid.size();i++)\\n        {\\n            for(j=0;j<grid[i].size();j++)\\n            {\\n                sum = 0;\\n                len=0;\\n                if(i==0 || j==0 || i==grid.size()-1 || j==grid[i].size()-1)     //no need to check for rhombus in case of end element\\n                {\\n                    sum = grid[i][j];\\n                    //check the elements value and compare it with 3 max values\\n                    if(sum>max1)\\n                    {\\n                        max3=max2;\\n                        max2=max1;\\n                        max1=sum;\\n                    }\\n                    else if(sum>max2 && sum!=max1)\\n                    {\\n                        max3=max2;\\n                        max2=sum;\\n                    }\\n                    else if(sum>max3 && sum!=max2 && sum!=max1)\\n                    {\\n                        max3=sum;\\n                    }\\n                }\\n                else // if the point is not an end point, atleast a rhombus can be formed\\n                {\\n                    while((i-len-1)>=0 && (i+len+1)<grid.size() && (j-len-1)>=0 && (j+len+1)<grid[i].size() ) //loop to iterate over all the rhombuses for the given point i,j as center\\n                    {\\n                        sum = 0;\\n                        len++;  //len is half of diagonal length of rhombus\\n                        sum += grid[i+len][j];      //rightmost point of rhombus\\n                        sum += grid[i][j+len];      //bottommost point of rhombus\\n                        sum += grid[i-len][j];      //leftmost point of rhombus\\n                        sum += grid[i][j-len];      //topmost point of rhombus\\n                        \\n                        for(int k=1;k<len;k++)      // loop to get all the point along the edges\\n                        {\\n                            sum +=grid[i+len-k][j+k];\\n                            sum += grid[i-k][j+len-k];\\n                            sum += grid[i-len+k][j-k];\\n                            sum += grid[i+k][j-len+k];        \\n                        }\\n                        \\n                        \\n                        \\n                        if(sum<grid[i][j])          //compare the rhombus sum with center point\\'s value\\n                            sum = grid[i][j];\\n                        //compare the sum with 3 max values\\n                        if(sum>max1)\\n                        {\\n                            max3=max2;\\n                            max2=max1;\\n                            max1=sum;\\n                        }\\n                        else if(sum>max2 && sum!=max1)\\n                        {\\n                            max3=max2;\\n                            max2=sum;\\n                        }\\n                        else if(sum>max3 && sum!=max2 && sum!=max1)\\n                        {\\n                            max3=sum;\\n                        }\\n                        \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        vector <int> ans;  \\n    \\n        //  push the values in a vector before returning it\\n        if (max1!=0)\\n            ans.push_back(max1);\\n        if (max2!=0)\\n            ans.push_back(max2);\\n        if (max3!=0)\\n            ans.push_back(max3);\\n        \\n        return ans;\\n            \\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242382,
                "title": "1878-get-biggest-three-rhombus-sums-in-a-grid-python-solution",
                "content": "it is a very simple solutions just we  fix upvertex and calculate all rohmbus through it and calculate ssum and see the top three and return ...if u have any doubts plz do tell\\n\\n\\n\\n```py\\nclass Solution(object):\\n    def getBiggestThree(self, grid):\\n        def calc(l,r,u,d):\\n            ssum=0\\n            expand=True\\n            c1=c2=(l+r)//2\\n            \\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    ssum+=grid[row][c1]\\n                else :\\n                    ssum+=grid[row][c1]+grid[row][c2]\\n                if c1==l:\\n                    expand=False\\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else :\\n                    c1+=1\\n                    c2-=1\\n            return ssum        \\n        m=len(grid)\\n        n=len(grid[0])\\n        pq=[]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<n and d<m:\\n                    ssum=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    \\n                    if len(pq)<3:\\n                        if ssum not in pq:\\n                            heapq.heappush(pq,ssum)\\n                    else :\\n                        if ssum not in pq and ssum>pq[0]:\\n                            heapq.heappop(pq)\\n                            heapq.heappush(pq,ssum)\\n        pq.sort(reverse=True)\\n        return pq\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```py\\nclass Solution(object):\\n    def getBiggestThree(self, grid):\\n        def calc(l,r,u,d):\\n            ssum=0\\n            expand=True\\n            c1=c2=(l+r)//2\\n            \\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    ssum+=grid[row][c1]\\n                else :\\n                    ssum+=grid[row][c1]+grid[row][c2]\\n                if c1==l:\\n                    expand=False\\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else :\\n                    c1+=1\\n                    c2-=1\\n            return ssum        \\n        m=len(grid)\\n        n=len(grid[0])\\n        pq=[]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<n and d<m:\\n                    ssum=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    \\n                    if len(pq)<3:\\n                        if ssum not in pq:\\n                            heapq.heappush(pq,ssum)\\n                    else :\\n                        if ssum not in pq and ssum>pq[0]:\\n                            heapq.heappop(pq)\\n                            heapq.heappush(pq,ssum)\\n        pq.sort(reverse=True)\\n        return pq\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1239286,
                "title": "java-straight-forward-iterates-every-points-to-draw-beat-100",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> (b - a));\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                helper(grid, q, i, j);\\n            }\\n        }\\n        Set<Integer> tmp = new HashSet<>();\\n        while (tmp.size() < 3 && !q.isEmpty()) {\\n            tmp.add(q.poll());\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int num : tmp) {\\n            res.add(num);\\n        }\\n        Collections.sort(res, Collections.reverseOrder());\\n        int[] finalRes = new int[res.size()];\\n        int index = 0;\\n        for (int i = 0; i < res.size(); i++) {\\n            finalRes[index++] = res.get(i);\\n        }\\n        return finalRes;\\n    }\\n    \\n    private void helper(int[][] grid, PriorityQueue<Integer> q, int x, int y) {\\n        q.add(grid[x][y]);\\n        int n = grid.length-1, m = grid[0].length-1;\\n        for (int k = 1; k <= 25; k++) {\\n            if (y + k > m || y - k < 0 || x + 2*k > n) continue;\\n            // 1 -1 -> left down,  1 1 -> right down, -1 1 -> right up, -1 -1 left up\\n            int sum = 0;\\n            int xx = x, yy = y;\\n            for (int i = 0; i < k; i++) {\\n                xx += 1;\\n                yy -= 1;\\n                sum += grid[xx][yy];\\n            }\\n            for (int i = 0; i < k; i++) {\\n                xx += 1;\\n                yy += 1;\\n                sum += grid[xx][yy];\\n            }\\n            for (int i = 0; i < k; i++) {\\n                xx -= 1;\\n                yy += 1;\\n                sum += grid[xx][yy];\\n            }\\n            for (int i = 0; i < k; i++) {\\n                xx -= 1;\\n                yy -= 1;\\n                sum += grid[xx][yy];\\n            }\\n            q.add(sum);\\n        }\\n\\n    }\\n}\\n```\\n\\nfor every point, add itself first, then check every possible length of the side. \\ndraw from top point, added as a cycle.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> (b - a));\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                helper(grid, q, i, j);\\n            }\\n        }\\n        Set<Integer> tmp = new HashSet<>();\\n        while (tmp.size() < 3 && !q.isEmpty()) {\\n            tmp.add(q.poll());\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int num : tmp) {\\n            res.add(num);\\n        }\\n        Collections.sort(res, Collections.reverseOrder());\\n        int[] finalRes = new int[res.size()];\\n        int index = 0;\\n        for (int i = 0; i < res.size(); i++) {\\n            finalRes[index++] = res.get(i);\\n        }\\n        return finalRes;\\n    }\\n    \\n    private void helper(int[][] grid, PriorityQueue<Integer> q, int x, int y) {\\n        q.add(grid[x][y]);\\n        int n = grid.length-1, m = grid[0].length-1;\\n        for (int k = 1; k <= 25; k++) {\\n            if (y + k > m || y - k < 0 || x + 2*k > n) continue;\\n            // 1 -1 -> left down,  1 1 -> right down, -1 1 -> right up, -1 -1 left up\\n            int sum = 0;\\n            int xx = x, yy = y;\\n            for (int i = 0; i < k; i++) {\\n                xx += 1;\\n                yy -= 1;\\n                sum += grid[xx][yy];\\n            }\\n            for (int i = 0; i < k; i++) {\\n                xx += 1;\\n                yy += 1;\\n                sum += grid[xx][yy];\\n            }\\n            for (int i = 0; i < k; i++) {\\n                xx -= 1;\\n                yy += 1;\\n                sum += grid[xx][yy];\\n            }\\n            for (int i = 0; i < k; i++) {\\n                xx -= 1;\\n                yy -= 1;\\n                sum += grid[xx][yy];\\n            }\\n            q.add(sum);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238921,
                "title": "java-easy-to-understand-100-faster-100-memory-saved",
                "content": "1. Will use Priority queue to order the elements in descending order.\\n2. Will use Hash set to store the unique elements.\\n3. Iterate for all possible length of diagonal, decided by target variable.\\n4. Iterate for all 4 sides of rhombus to get the desired sum.\\n5. Starting points of side are decided by id1,id2.\\n6. End point of side are decided by id1,id2.\\n7. Will only push the temp only if it is updated by all 4 sides.\\n8. Count of side is maintained by count variable.\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> b-a);\\n        ArrayList<Integer> al = new ArrayList();\\n        HashSet<Integer> hm = new HashSet();\\n        for(int i = 0; i < grid.length; i++)\\n        {\\n            for(int j = 0; j < grid[i].length; j++)\\n            {\\n                if(!hm.contains(grid[i][j]))\\n                {\\n                    pq.add(grid[i][j]);\\n                    hm.add(grid[i][j]);\\n                }\\n            }\\n        }\\n\\t\\t\\n        int row = grid.length/2;\\n        int col = grid[0].length/2;\\n        int min = Math.min(row,col);\\n        \\n        int target = 1;\\n        while(target <= min)\\n        {\\n            for(int i = 0; i < grid.length-min; i++)\\n            {\\n                for(int j = target; j < grid[0].length; j++)\\n                {\\n                    int temp = 0;\\n                    int count = 0;\\n                    int id1 = i;\\n                    int id2 = j;        \\n                    int end1 = id1 + target;\\n                    int end2 = id2 - target;\\n            \\n                    while(id1 < end1 && id2 > end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1++;\\n                            id2--;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t\\n                    id1 = end1;\\n                    id2 = end2;\\n                    end1 = id1+target;\\n                    end2 = id2+target;\\n                    \\n                    while(id1 < end1 && id2 < end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1++;\\n                            id2++;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    id1 = end1;\\n                    id2 = end2;\\n                    end1 = id1 - target;\\n                    end2 = id2 + target;\\n                    \\n                    while(id1 > end1 && id2 < end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1--;\\n                            id2++;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n    \\n                    id1 = end1;\\n                    id2 = end2;\\n                    end1 = id1-target;\\n                    end2 = id2-target;\\n                    \\n                    while(id1 > end1 && id2 > end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1--;\\n                            id2--;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t\\n                    if(count == 0)\\n                    {\\n                        if(!hm.contains(temp))\\n                        {\\n                            pq.add(temp);\\n                            hm.add(temp);\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n            target++;\\n        }\\n        al.add(pq.poll());\\n        \\n\\t\\tif(!pq.isEmpty())\\n        al.add(pq.poll());\\n        \\n\\t\\tif(!pq.isEmpty())\\n        al.add(pq.poll());\\n       \\n\\t   int[] ans1 = new int[al.size()];\\n       \\n\\t   for(int i = 0; i < al.size(); i++)\\n            ans1[i] = al.get(i);\\n        \\n\\t\\treturn ans1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> b-a);\\n        ArrayList<Integer> al = new ArrayList();\\n        HashSet<Integer> hm = new HashSet();\\n        for(int i = 0; i < grid.length; i++)\\n        {\\n            for(int j = 0; j < grid[i].length; j++)\\n            {\\n                if(!hm.contains(grid[i][j]))\\n                {\\n                    pq.add(grid[i][j]);\\n                    hm.add(grid[i][j]);\\n                }\\n            }\\n        }\\n\\t\\t\\n        int row = grid.length/2;\\n        int col = grid[0].length/2;\\n        int min = Math.min(row,col);\\n        \\n        int target = 1;\\n        while(target <= min)\\n        {\\n            for(int i = 0; i < grid.length-min; i++)\\n            {\\n                for(int j = target; j < grid[0].length; j++)\\n                {\\n                    int temp = 0;\\n                    int count = 0;\\n                    int id1 = i;\\n                    int id2 = j;        \\n                    int end1 = id1 + target;\\n                    int end2 = id2 - target;\\n            \\n                    while(id1 < end1 && id2 > end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1++;\\n                            id2--;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t\\n                    id1 = end1;\\n                    id2 = end2;\\n                    end1 = id1+target;\\n                    end2 = id2+target;\\n                    \\n                    while(id1 < end1 && id2 < end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1++;\\n                            id2++;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    id1 = end1;\\n                    id2 = end2;\\n                    end1 = id1 - target;\\n                    end2 = id2 + target;\\n                    \\n                    while(id1 > end1 && id2 < end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1--;\\n                            id2++;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n    \\n                    id1 = end1;\\n                    id2 = end2;\\n                    end1 = id1-target;\\n                    end2 = id2-target;\\n                    \\n                    while(id1 > end1 && id2 > end2)\\n                    {\\n                        if(id1 < grid.length && id1 >= 0 && id2 < grid[0].length && id2 >= 0)\\n                        {\\n                            temp += grid[id1][id2];\\n                            id1--;\\n                            id2--;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n\\t\\t\\t\\t\\t\\n                    if(count == 0)\\n                    {\\n                        if(!hm.contains(temp))\\n                        {\\n                            pq.add(temp);\\n                            hm.add(temp);\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n            target++;\\n        }\\n        al.add(pq.poll());\\n        \\n\\t\\tif(!pq.isEmpty())\\n        al.add(pq.poll());\\n        \\n\\t\\tif(!pq.isEmpty())\\n        al.add(pq.poll());\\n       \\n\\t   int[] ans1 = new int[al.size()];\\n       \\n\\t   for(int i = 0; i < al.size(); i++)\\n            ans1[i] = al.get(i);\\n        \\n\\t\\treturn ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238876,
                "title": "c-diagonal-prefix-sum-o-n-m-min-n-m",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// pref -> prefix sum while going from bottom-left to top-right\\n\\t\\t// pref2 -> prefix sum while going from top-left to bottom-right\\n        vector<vector<int>> pref(n, vector<int>(m)), pref2(n, vector<int>(m));\\n        for (int i = 0; i < n; ++i) pref[i][0] = grid[i][0];\\n        pref[n - 1] = grid[n - 1];\\n        for (int j = 1; j < m; ++j) {\\n            for (int i = 0; i < n - 1; ++i) {\\n                pref[i][j] += grid[i][j] + pref[i + 1][j - 1];\\n            }\\n        }\\n\\n        pref2[0] = grid[0];\\n        for (int i = 0; i < n; ++i) pref2[i][0] = grid[i][0];\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 1; j < m; ++j) {\\n                pref2[i][j] += grid[i][j] + pref2[i - 1][j - 1];\\n            }\\n        }\\n\\n        set<int, greater<int>> sums;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 0; k < min(n, m); ++k) {\\n                    if (i + k >= n or i - k < 0 or j + 2 * k >= m) continue;\\n                    int sum = pref[i - k][j + k] - (i == n - 1 or j == 0 ? 0 : pref[i + 1][j - 1]);\\n                    sum += pref2[i][j + 2 * k] - pref2[i - k][j + k];\\n\\t\\t\\t\\t\\t// subtract to avoid double counting\\n                    sum += pref[i][j + 2 * k] - pref[i + k][j + k] - grid[i][j + 2 * k];\\n                    sum += pref2[i + k][j + k] - pref2[i][j];\\n                    sums.insert(sum);\\n                }\\n                \\n            }\\n        }\\n        vector<int> ret;\\n        for (auto x: sums) {\\n            if (x != 0) ret.push_back(x);\\n            if (ret.size() == 3) break;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n---\\n_I also write [here](https://csposts.com) ([GitHub Repo](https://github.com/notescs/notescs.github.io/))._",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// pref -> prefix sum while going from bottom-left to top-right\\n\\t\\t// pref2 -> prefix sum while going from top-left to bottom-right\\n        vector<vector<int>> pref(n, vector<int>(m)), pref2(n, vector<int>(m));\\n        for (int i = 0; i < n; ++i) pref[i][0] = grid[i][0];\\n        pref[n - 1] = grid[n - 1];\\n        for (int j = 1; j < m; ++j) {\\n            for (int i = 0; i < n - 1; ++i) {\\n                pref[i][j] += grid[i][j] + pref[i + 1][j - 1];\\n            }\\n        }\\n\\n        pref2[0] = grid[0];\\n        for (int i = 0; i < n; ++i) pref2[i][0] = grid[i][0];\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 1; j < m; ++j) {\\n                pref2[i][j] += grid[i][j] + pref2[i - 1][j - 1];\\n            }\\n        }\\n\\n        set<int, greater<int>> sums;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 0; k < min(n, m); ++k) {\\n                    if (i + k >= n or i - k < 0 or j + 2 * k >= m) continue;\\n                    int sum = pref[i - k][j + k] - (i == n - 1 or j == 0 ? 0 : pref[i + 1][j - 1]);\\n                    sum += pref2[i][j + 2 * k] - pref2[i - k][j + k];\\n\\t\\t\\t\\t\\t// subtract to avoid double counting\\n                    sum += pref[i][j + 2 * k] - pref[i + k][j + k] - grid[i][j + 2 * k];\\n                    sum += pref2[i + k][j + k] - pref2[i][j];\\n                    sums.insert(sum);\\n                }\\n                \\n            }\\n        }\\n        vector<int> ret;\\n        for (auto x: sums) {\\n            if (x != 0) ret.push_back(x);\\n            if (ret.size() == 3) break;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238849,
                "title": "o-n-3-with-o-n-2-space-solution-c",
                "content": "we can pre-calc the all diagonal and anti-diagonal sums for given grid and can leverage that sum to eliminate another loop. Below is the constest code\\n```\\nclass Solution {\\npublic:\\n    int mat[110][110][2];\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid[0].size(), n = grid.size();\\n        memset(mat, 0, sizeof(mat));\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                mat[r][c][0] = mat[r][c][1] = grid[r][c];\\n                if (r - 1 >=0 && c -1 >=0) mat[r][c][0] += mat[r-1][c-1][0];\\n                if (r - 1 >= 0 && c + 1 < m) mat[r][c][1] += mat[r-1][c+1][1];\\n            }\\n        }\\n        set<int> sumis;\\n        for (int len = 0; len < min(n, m); len++) {\\n            for (int r = 0; r + 2*len < n; r++) {\\n                for (int c = 0; c + len < m; c++) if (c - len < 0) continue;\\n                else {\\n                    if (len == 0) {\\n                        sumis.insert(-grid[r][c]);\\n                        continue;\\n                    }\\n                    int a = mat[r+len][c-len][1] - mat[r][c][1] + grid[r][c];\\n                    int b = mat[r+len][c+len][0] - mat[r][c][0];\\n                    int cc = mat[r + 2*len][c][0] - mat[r + len][c - len][0];\\n                    int d = mat[r + 2*len][c][1] - mat[r+len][c+len][1];\\n                    int sum = a + b + cc + d - grid[r + 2*len][c];\\n                    sumis.insert(-sum);\\n                }\\n            }\\n        }\\n        vector<int>ret;\\n        for (int i =0 ; i < 3 && !sumis.empty(); i++) {\\n            ret.push_back(-(*sumis.begin()));\\n            sumis.erase(sumis.begin());\\n        }\\n        return ret;\\n    }\\n};\\n```\\nI used the variable `c` inside the loops which gave runtime error almost took 15-20 mins to debug it and finally changed it to `cc`.\\nLearning: Be carefull with your variable naming",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mat[110][110][2];\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid[0].size(), n = grid.size();\\n        memset(mat, 0, sizeof(mat));\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                mat[r][c][0] = mat[r][c][1] = grid[r][c];\\n                if (r - 1 >=0 && c -1 >=0) mat[r][c][0] += mat[r-1][c-1][0];\\n                if (r - 1 >= 0 && c + 1 < m) mat[r][c][1] += mat[r-1][c+1][1];\\n            }\\n        }\\n        set<int> sumis;\\n        for (int len = 0; len < min(n, m); len++) {\\n            for (int r = 0; r + 2*len < n; r++) {\\n                for (int c = 0; c + len < m; c++) if (c - len < 0) continue;\\n                else {\\n                    if (len == 0) {\\n                        sumis.insert(-grid[r][c]);\\n                        continue;\\n                    }\\n                    int a = mat[r+len][c-len][1] - mat[r][c][1] + grid[r][c];\\n                    int b = mat[r+len][c+len][0] - mat[r][c][0];\\n                    int cc = mat[r + 2*len][c][0] - mat[r + len][c - len][0];\\n                    int d = mat[r + 2*len][c][1] - mat[r+len][c+len][1];\\n                    int sum = a + b + cc + d - grid[r + 2*len][c];\\n                    sumis.insert(-sum);\\n                }\\n            }\\n        }\\n        vector<int>ret;\\n        for (int i =0 ; i < 3 && !sumis.empty(); i++) {\\n            ret.push_back(-(*sumis.begin()));\\n            sumis.erase(sumis.begin());\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238846,
                "title": "python3-prefix-sum-solution",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        main_diag_prefix = [[0] * (n+2) for _ in range(m+2)]\\n        alt_diag_prefix = [[0] * (n+2) for _ in range(m+2)]\\n        \\n        for i in range(1, m+1):\\n            for k in range(1, n+1):\\n                main_diag_prefix[i][k] = main_diag_prefix[i-1][k-1] + grid[i-1][k-1]\\n                alt_diag_prefix[i][k] = alt_diag_prefix[i-1][k+1] + grid[i-1][k-1]\\n        \\n        def get_main_diag_sum(left, right):\\n            i1, k1 = left\\n            i2, k2 = right\\n            return main_diag_prefix[i2][k2] - main_diag_prefix[i1-1][k1-1]\\n        \\n        def get_alt_diag_sum(left, right):\\n            i1, k1 = left\\n            i2, k2 = right\\n            return alt_diag_prefix[i2][k2] - alt_diag_prefix[i1-1][k1+1]\\n        \\n        def subtract_corners(corner):\\n            i, k = corner\\n            i -= 1\\n            k -= 1\\n            return grid[i][k]\\n            \\n        max_lens = []\\n        for i in range(m):\\n            for k in range(n):\\n                if grid[i][k] not in max_lens:\\n                    if len(max_lens) == 3:\\n                        heapq.heappushpop(max_lens, grid[i][k])\\n                    else:\\n                        heapq.heappush(max_lens, grid[i][k])\\n                for size in range(1, min(i, k, m-i-1, n-k-1)+1):\\n                    curr_sum = 0\\n                    left, right = (i+1, k-size+1), (i+1, k+size+1)\\n                    top, bottom = (i-size+1, k+1), (i+size+1, k+1)\\n                    \\n                    curr_sum += get_main_diag_sum(top, right)\\n                    curr_sum += get_main_diag_sum(left, bottom)\\n                    curr_sum += get_alt_diag_sum(right, bottom)\\n                    curr_sum += get_alt_diag_sum(top, left)\\n                    \\n                    curr_sum -= sum(subtract_corners(corner) for corner in (top, bottom, left, right))\\n                    if curr_sum not in max_lens:\\n                        if len(max_lens) == 3:\\n                            heapq.heappushpop(max_lens, curr_sum)\\n                        else:\\n                            heapq.heappush(max_lens, curr_sum)\\n        \\n        return sorted(max_lens, reverse=True)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        main_diag_prefix = [[0] * (n+2) for _ in range(m+2)]\\n        alt_diag_prefix = [[0] * (n+2) for _ in range(m+2)]\\n        \\n        for i in range(1, m+1):\\n            for k in range(1, n+1):\\n                main_diag_prefix[i][k] = main_diag_prefix[i-1][k-1] + grid[i-1][k-1]\\n                alt_diag_prefix[i][k] = alt_diag_prefix[i-1][k+1] + grid[i-1][k-1]\\n        \\n        def get_main_diag_sum(left, right):\\n            i1, k1 = left\\n            i2, k2 = right\\n            return main_diag_prefix[i2][k2] - main_diag_prefix[i1-1][k1-1]\\n        \\n        def get_alt_diag_sum(left, right):\\n            i1, k1 = left\\n            i2, k2 = right\\n            return alt_diag_prefix[i2][k2] - alt_diag_prefix[i1-1][k1+1]\\n        \\n        def subtract_corners(corner):\\n            i, k = corner\\n            i -= 1\\n            k -= 1\\n            return grid[i][k]\\n            \\n        max_lens = []\\n        for i in range(m):\\n            for k in range(n):\\n                if grid[i][k] not in max_lens:\\n                    if len(max_lens) == 3:\\n                        heapq.heappushpop(max_lens, grid[i][k])\\n                    else:\\n                        heapq.heappush(max_lens, grid[i][k])\\n                for size in range(1, min(i, k, m-i-1, n-k-1)+1):\\n                    curr_sum = 0\\n                    left, right = (i+1, k-size+1), (i+1, k+size+1)\\n                    top, bottom = (i-size+1, k+1), (i+size+1, k+1)\\n                    \\n                    curr_sum += get_main_diag_sum(top, right)\\n                    curr_sum += get_main_diag_sum(left, bottom)\\n                    curr_sum += get_alt_diag_sum(right, bottom)\\n                    curr_sum += get_alt_diag_sum(top, left)\\n                    \\n                    curr_sum -= sum(subtract_corners(corner) for corner in (top, bottom, left, right))\\n                    if curr_sum not in max_lens:\\n                        if len(max_lens) == 3:\\n                            heapq.heappushpop(max_lens, curr_sum)\\n                        else:\\n                            heapq.heappush(max_lens, curr_sum)\\n        \\n        return sorted(max_lens, reverse=True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238832,
                "title": "java-brute-force-simple-code-with-comments",
                "content": "```java\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\t\\t// To get biggest rhombus we store their sizes int decsending order\\n        TreeSet<Integer> pq = new TreeSet<Integer>((r1,r2) -> -Integer.compare(r1,r2));\\n\\t\\t// add all rhimbus with side = 0(one cell rhombuses)\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pq.add(grid[i][j]);\\n                if (pq.size() > 3) {\\n                    pq.pollLast();\\n                }\\n            }\\n        }\\n\\t\\t// add rhombuses with side k greater than 0\\n        int k = 1;\\n        while (k < n) {\\n            for (int i = k; i < n - k; i++) {\\n                for (int j = k; j < m - k; j++) {\\n                    pq.add(getSum(grid, i, j, k));\\n                    if (pq.size() > 3) {\\n                        pq.pollLast();\\n                    }\\n                }\\n            }\\n            k++;\\n        }\\n        int[] res = new int[Math.min(pq.size(), 3)];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = pq.pollFirst();\\n        }\\n        return res;\\n    }\\n    \\n    int getSum(int[][] grid, int i, int j, int k) {\\n        int sum = 0;\\n        \\n        int row = i;\\n        int col = j - k;\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\n\\t\\t              down(i-k,j)\\n\\t\\t\\t\\t\\t /           \\\\\\n\\t\\t\\t\\t\\t/             \\\\\\n\\t\\tleft(i,j-k)                top(i,j+k)\\n                    \\\\             /\\n                     \\\\           /\\n                       top(i+k,j)\\n\\t\\t\\n\\t\\t*/\\n        \\n        // left - down\\n        while (row > i - k && col < j) {\\n            sum += grid[row][col];\\n            row--;\\n            col++;\\n        }\\n        \\n        // down - right\\n        while (row < i && col < j + k) {\\n            sum += grid[row][col];\\n            row++;\\n            col++;\\n        }\\n        \\n        // right - top\\n        while (row < i + k && col > j) {\\n            sum += grid[row][col];\\n            row++;\\n            col--;\\n        }\\n        \\n        // top-left\\n        while (row > i && col > j - k) {\\n            sum += grid[row][col];\\n            row--;\\n            col--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\t\\t// To get biggest rhombus we store their sizes int decsending order\\n        TreeSet<Integer> pq = new TreeSet<Integer>((r1,r2) -> -Integer.compare(r1,r2));\\n\\t\\t// add all rhimbus with side = 0(one cell rhombuses)\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pq.add(grid[i][j]);\\n                if (pq.size() > 3) {\\n                    pq.pollLast();\\n                }\\n            }\\n        }\\n\\t\\t// add rhombuses with side k greater than 0\\n        int k = 1;\\n        while (k < n) {\\n            for (int i = k; i < n - k; i++) {\\n                for (int j = k; j < m - k; j++) {\\n                    pq.add(getSum(grid, i, j, k));\\n                    if (pq.size() > 3) {\\n                        pq.pollLast();\\n                    }\\n                }\\n            }\\n            k++;\\n        }\\n        int[] res = new int[Math.min(pq.size(), 3)];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = pq.pollFirst();\\n        }\\n        return res;\\n    }\\n    \\n    int getSum(int[][] grid, int i, int j, int k) {\\n        int sum = 0;\\n        \\n        int row = i;\\n        int col = j - k;\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\n\\t\\t              down(i-k,j)\\n\\t\\t\\t\\t\\t /           \\\\\\n\\t\\t\\t\\t\\t/             \\\\\\n\\t\\tleft(i,j-k)                top(i,j+k)\\n                    \\\\             /\\n                     \\\\           /\\n                       top(i+k,j)\\n\\t\\t\\n\\t\\t*/\\n        \\n        // left - down\\n        while (row > i - k && col < j) {\\n            sum += grid[row][col];\\n            row--;\\n            col++;\\n        }\\n        \\n        // down - right\\n        while (row < i && col < j + k) {\\n            sum += grid[row][col];\\n            row++;\\n            col++;\\n        }\\n        \\n        // right - top\\n        while (row < i + k && col > j) {\\n            sum += grid[row][col];\\n            row++;\\n            col--;\\n        }\\n        \\n        // top-left\\n        while (row > i && col > j - k) {\\n            sum += grid[row][col];\\n            row--;\\n            col--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238816,
                "title": "c-simple-approach-faster-than-91-67-submissions",
                "content": "```\\nvector<int> getBiggestThree(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int first=INT_MIN, second=INT_MIN, third=INT_MIN;\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] > first)\\n                {\\n                    swap(second,third);\\n                    swap(first,second);\\n                    first = grid[i][j];\\n                }\\n                else if(grid[i][j] > second && grid[i][j] != first)\\n                {\\n                    swap(second,third);\\n                    second = grid[i][j];\\n                }\\n                else if(grid[i][j] > third && grid[i][j] != second && grid[i][j] != first)\\n                {\\n                    third = grid[i][j];\\n                }\\n                \\n                int k=1;\\n                while(i+2*k < m && j-k >= 0 && j+k < n)\\n                {\\n                    int sum = grid[i][j];\\n                    \\n                    for(int a=1; a<=k; a++)\\n                    {\\n                        sum += grid[i+a][j-a];\\n                        sum += grid[i+a][j+a];\\n                    }\\n                    \\n                    sum += grid[i+2*k][j];\\n                    for(int a=2*k-1; a>k; a--)\\n                    {\\n                        sum += grid[i+a][j-(2*k-a)];\\n                        sum += grid[i+a][j+(2*k-a)];\\n                    }\\n                    \\n                    \\n                    if(sum > first)\\n                    {\\n                        swap(second,third);\\n                        swap(first,second);\\n                        first = sum;\\n                    }\\n                    else if(sum > second && sum != first)\\n                    {\\n                        swap(second,third);\\n                        second = sum;\\n                    }\\n                    else if(sum > third && sum != second && sum != first)\\n                    {\\n                        third = sum;\\n                    }\\n                    \\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        if(first != INT_MIN)\\n            ans.push_back(first);\\n        if(second != INT_MIN && second != first)\\n            ans.push_back(second);\\n        if(third != INT_MIN && third != second)\\n            ans.push_back(third);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> getBiggestThree(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int first=INT_MIN, second=INT_MIN, third=INT_MIN;\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] > first)\\n                {\\n                    swap(second,third);\\n                    swap(first,second);\\n                    first = grid[i][j];\\n                }\\n                else if(grid[i][j] > second && grid[i][j] != first)\\n                {\\n                    swap(second,third);\\n                    second = grid[i][j];\\n                }\\n                else if(grid[i][j] > third && grid[i][j] != second && grid[i][j] != first)\\n                {\\n                    third = grid[i][j];\\n                }\\n                \\n                int k=1;\\n                while(i+2*k < m && j-k >= 0 && j+k < n)\\n                {\\n                    int sum = grid[i][j];\\n                    \\n                    for(int a=1; a<=k; a++)\\n                    {\\n                        sum += grid[i+a][j-a];\\n                        sum += grid[i+a][j+a];\\n                    }\\n                    \\n                    sum += grid[i+2*k][j];\\n                    for(int a=2*k-1; a>k; a--)\\n                    {\\n                        sum += grid[i+a][j-(2*k-a)];\\n                        sum += grid[i+a][j+(2*k-a)];\\n                    }\\n                    \\n                    \\n                    if(sum > first)\\n                    {\\n                        swap(second,third);\\n                        swap(first,second);\\n                        first = sum;\\n                    }\\n                    else if(sum > second && sum != first)\\n                    {\\n                        swap(second,third);\\n                        second = sum;\\n                    }\\n                    else if(sum > third && sum != second && sum != first)\\n                    {\\n                        third = sum;\\n                    }\\n                    \\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        if(first != INT_MIN)\\n            ans.push_back(first);\\n        if(second != INT_MIN && second != first)\\n            ans.push_back(second);\\n        if(third != INT_MIN && third != second)\\n            ans.push_back(third);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238802,
                "title": "java-solution",
                "content": "Java Bruteforce solution. Reference: https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238637/Python-3-brute-force-greedy\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        \\n        int maxSize = grid.length/2;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>( (x,y) -> x-y );\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i = 0; i < grid.length; i++ ) {\\n            for(int j = 0; j < grid[i].length; j++ ) { \\n                \\n                if(!set.contains(grid[i][j])) {\\n                    pq.add(grid[i][j]);\\n                    set.add(grid[i][j]);\\n                }\\n                if(pq.size() > 3)\\n                    pq.poll();\\n               \\n                for(int k = 1; k <= maxSize && i >= k && j >= k && k + i <  grid.length && k+j < grid[i].length; k++) {\\n                    int dia = calcRombus(grid, i, j, k);\\n                    if(!set.contains(dia)) {\\n                        pq.add(dia);   \\n                        set.add(dia);\\n                    }\\n                    if(pq.size() > 3) \\n                        pq.poll();\\n                }  \\n            }\\n        }\\n        \\n        int[] res = new int[pq.size()];\\n        for(int i = pq.size()-1; i >= 0; i--) {\\n            res[i] = pq.poll();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int calcRombus(int[][] grid, int i, int j, int k) {\\n        \\n        int curr = 0;\\n\\n        for(int l = 0; l < k+1; l++)\\n            curr += grid[i+l][j+k-l] + grid[i-l][j+k-l] + grid[i+l][j-k+l] + grid[i-l][j-k+l];\\n        curr -= grid[i+k][j] + grid[i-k][j] + grid[i][j+k] + grid[i][j-k];\\n\\n        return curr;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        \\n        int maxSize = grid.length/2;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>( (x,y) -> x-y );\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i = 0; i < grid.length; i++ ) {\\n            for(int j = 0; j < grid[i].length; j++ ) { \\n                \\n                if(!set.contains(grid[i][j])) {\\n                    pq.add(grid[i][j]);\\n                    set.add(grid[i][j]);\\n                }\\n                if(pq.size() > 3)\\n                    pq.poll();\\n               \\n                for(int k = 1; k <= maxSize && i >= k && j >= k && k + i <  grid.length && k+j < grid[i].length; k++) {\\n                    int dia = calcRombus(grid, i, j, k);\\n                    if(!set.contains(dia)) {\\n                        pq.add(dia);   \\n                        set.add(dia);\\n                    }\\n                    if(pq.size() > 3) \\n                        pq.poll();\\n                }  \\n            }\\n        }\\n        \\n        int[] res = new int[pq.size()];\\n        for(int i = pq.size()-1; i >= 0; i--) {\\n            res[i] = pq.poll();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int calcRombus(int[][] grid, int i, int j, int k) {\\n        \\n        int curr = 0;\\n\\n        for(int l = 0; l < k+1; l++)\\n            curr += grid[i+l][j+k-l] + grid[i-l][j+k-l] + grid[i+l][j-k+l] + grid[i-l][j-k+l];\\n        curr -= grid[i+k][j] + grid[i-k][j] + grid[i][j+k] + grid[i][j-k];\\n\\n        return curr;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238735,
                "title": "simple-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void set_val( int i , vector<int> &res)\\n    {   \\n        if(i==res[2] or i==res[1] or i==res[0]) return ;\\n        if( i > res[2]){ res[0] = res[1]; res[1]= res[2]; res[2]=i; }\\n        else if(i>res[1]){ res[0] = res[1]; res[1]=i; }\\n        else if(i>res[0]){ res[0] = i; }\\n    }\\n    \\n    void findpossiblerobus(vector<vector<int>>& grid , int i, int j, int &n , int &m , vector<int>&res)\\n    {\\n        for(int x = 1;x<n;x++)\\n        {   \\n           \\n            if(i-x <0 or i+x>=n or j+ 2*x >=m )\\n                break;\\n            \\n            int sum = 0;\\n            int p=i,q=j;\\n            for( ; p< i+x && q< j+x    ; p++, q++) sum+=grid[p][q];\\n            for( ; p>i   && q<j+2*x ; p--,q++)  sum+=grid[p][q];\\n            for( ; p>i-x && q> j+x   ; p--,q--)  sum+=grid[p][q];\\n            for( ; p<i   && q> j     ; p++,q--)  sum+=grid[p][q];\\n            \\n            set_val(sum,res) ; \\n        }\\n        \\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n    vector<int> res(3,0);\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    \\n    for(int i=0; i<n;i++)\\n    {\\n        for(int j=0;j<m;j++)\\n        {   \\n            set_val( grid[i][j] , res );\\n            findpossiblerobus(grid , i , j ,n,m ,res);\\n        }\\n    }\\n    reverse(res.begin(),res.end());\\n    if(res[2]==res[1] or res[2]==0) res.pop_back();\\n    if(res[1]==res[0] or res[1]==0) res.pop_back();\\n    \\n        \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void set_val( int i , vector<int> &res)\\n    {   \\n        if(i==res[2] or i==res[1] or i==res[0]) return ;\\n        if( i > res[2]){ res[0] = res[1]; res[1]= res[2]; res[2]=i; }\\n        else if(i>res[1]){ res[0] = res[1]; res[1]=i; }\\n        else if(i>res[0]){ res[0] = i; }\\n    }\\n    \\n    void findpossiblerobus(vector<vector<int>>& grid , int i, int j, int &n , int &m , vector<int>&res)\\n    {\\n        for(int x = 1;x<n;x++)\\n        {   \\n           \\n            if(i-x <0 or i+x>=n or j+ 2*x >=m )\\n                break;\\n            \\n            int sum = 0;\\n            int p=i,q=j;\\n            for( ; p< i+x && q< j+x    ; p++, q++) sum+=grid[p][q];\\n            for( ; p>i   && q<j+2*x ; p--,q++)  sum+=grid[p][q];\\n            for( ; p>i-x && q> j+x   ; p--,q--)  sum+=grid[p][q];\\n            for( ; p<i   && q> j     ; p++,q--)  sum+=grid[p][q];\\n            \\n            set_val(sum,res) ; \\n        }\\n        \\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n    vector<int> res(3,0);\\n    int n=grid.size();\\n    int m=grid[0].size();\\n    \\n    for(int i=0; i<n;i++)\\n    {\\n        for(int j=0;j<m;j++)\\n        {   \\n            set_val( grid[i][j] , res );\\n            findpossiblerobus(grid , i , j ,n,m ,res);\\n        }\\n    }\\n    reverse(res.begin(),res.end());\\n    if(res[2]==res[1] or res[2]==0) res.pop_back();\\n    if(res[1]==res[0] or res[1]==0) res.pop_back();\\n    \\n        \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081675,
                "title": "100-speed-100-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNote: This is not an elegant solution. Just share how to solve a problem from the beginning.\\n1. Understand the problem statement\\n2. Figure out the possible border lengths within given grid (0, 1, 2, ...)\\n3. Figure out how to calculate the sum of a rhombus (of border-length 0, 1, 2...)\\n4. brute force\\n5. narrow down ranges to reduce loops\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    // only 0-area\\n    if (m <=2 || n <= 2) {\\n        const res = [...new Set([...grid.flat()])];\\n        res.sort((a, b) => b -a);\\n        return res.slice(0, 3);\\n    }\\n    \\n    // result array - values always in desc order.\\n    const res = [];\\n    // the max possible length of border\\n    const maxLength = Math.floor((Math.min(m, n) - 1) / 2);\\n\\n    // loop through all possible lengths: [0, maxLength]\\n    for (let length=0; length<=maxLength; length++) {\\n        // row range\\n        for (let r=length; r<=m-1-length; r++) {\\n            // column range\\n            for (let c=0; c<=n-1-2*length; c++) {\\n                const sum = calcSum(grid, r, c, length);\\n\\n                if (!res.length) res.push(sum);\\n                else if (sum > res[res.length - 1]){\\n                    const pops = [];\\n                    // move out all values less than sum\\n                    while (res.length && sum > res[res.length - 1]) {\\n                        pops.push(res.pop());\\n                    }\\n                    // ensure sum is in\\n                    if (!res.length || sum !== res[res.length - 1]) {\\n                        res.push(sum);\\n                    }\\n                    // add back prev values from big -> small\\n                    while (res.length < 3 && pops.length) {\\n                        res.push(pops.pop());\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return res;\\n};\\n\\nconst calcSum = function (grid, leftR, leftC, length) {\\n    // init: left-corner\\n    let sum = grid[leftR][leftC];\\n    if (length === 0) return sum;\\n\\n    // (left-corner, top], (left-corner, bottom]\\n    for (let i=1; i<=length; i++) {\\n        sum += grid[leftR-i][leftC+i] + grid[leftR+i][leftC+i];\\n    }\\n    // (top, right-corner), (bottom, right-corner)\\n    for (let i=1; i<length; i++) {\\n        sum += grid[leftR-i][leftC+2*length-i] + grid[leftR+i][leftC+2*length-i];\\n    }\\n    // right-corner\\n    sum += grid[leftR][leftC+2*length];\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    // only 0-area\\n    if (m <=2 || n <= 2) {\\n        const res = [...new Set([...grid.flat()])];\\n        res.sort((a, b) => b -a);\\n        return res.slice(0, 3);\\n    }\\n    \\n    // result array - values always in desc order.\\n    const res = [];\\n    // the max possible length of border\\n    const maxLength = Math.floor((Math.min(m, n) - 1) / 2);\\n\\n    // loop through all possible lengths: [0, maxLength]\\n    for (let length=0; length<=maxLength; length++) {\\n        // row range\\n        for (let r=length; r<=m-1-length; r++) {\\n            // column range\\n            for (let c=0; c<=n-1-2*length; c++) {\\n                const sum = calcSum(grid, r, c, length);\\n\\n                if (!res.length) res.push(sum);\\n                else if (sum > res[res.length - 1]){\\n                    const pops = [];\\n                    // move out all values less than sum\\n                    while (res.length && sum > res[res.length - 1]) {\\n                        pops.push(res.pop());\\n                    }\\n                    // ensure sum is in\\n                    if (!res.length || sum !== res[res.length - 1]) {\\n                        res.push(sum);\\n                    }\\n                    // add back prev values from big -> small\\n                    while (res.length < 3 && pops.length) {\\n                        res.push(pops.pop());\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return res;\\n};\\n\\nconst calcSum = function (grid, leftR, leftC, length) {\\n    // init: left-corner\\n    let sum = grid[leftR][leftC];\\n    if (length === 0) return sum;\\n\\n    // (left-corner, top], (left-corner, bottom]\\n    for (let i=1; i<=length; i++) {\\n        sum += grid[leftR-i][leftC+i] + grid[leftR+i][leftC+i];\\n    }\\n    // (top, right-corner), (bottom, right-corner)\\n    for (let i=1; i<length; i++) {\\n        sum += grid[leftR-i][leftC+2*length-i] + grid[leftR+i][leftC+2*length-i];\\n    }\\n    // right-corner\\n    sum += grid[leftR][leftC+2*length];\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035250,
                "title": "c-easy-solution-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool checkbound(vector<vector<int>>& grid,vector<pair<int,int>>&v)\\n{\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    for(auto it:v)\\n    {\\n        if(it.first<0||it.first>=m||it.second<0||it.second>=n) return false;\\n\\n    }\\n    return true;\\n}\\nbool getallvertices(vector<vector<int>>& grid,vector<pair<int,int>>&v,pair<int,int>c,int&delta)\\n{\\n    pair<int,int>A(c.first-delta,c.second);\\n    pair<int,int>B(c.first,c.second+delta);\\n    pair<int,int>C(c.first+delta,c.second);\\n    pair<int,int>D(c.first,c.second-delta);\\n    v[0]=A;\\n    v[1]=B;\\n    v[2]=C;\\n    v[3]=D;\\n    if(checkbound(grid,v)) return true;\\n    return false;\\n    \\n}\\nvoid getallsum(vector<vector<int>>& grid,int cx ,int cy,priority_queue<int>&pq)\\n{\\n    pq.push(grid[cx][cy]);\\n    int delta=1;\\n    vector<pair<int,int>>v(4);\\n    while(getallvertices(grid,v,{cx,cy},delta))\\n    {\\n            pair<int,int>&A=v[0];\\n            pair<int,int>&B=v[1];\\n            pair<int,int>&C=v[2];\\n            pair<int,int>&D=v[3];\\n    int csum=grid[A.first][A.second]+grid[B.first][B.second]+grid[C.first][C.second]+grid[D.first][D.second];  \\n    for(int i=1;i<(B.first-A.first);i++) \\n    {\\n        csum+=grid[A.first+i][A.second+i];\\n    }\\n     for(int i=1;i<(C.first-B.first);i++) \\n    {\\n        csum+=grid[B.first+i][B.second-i];\\n    }\\n     for(int i=1;i<(C.first-D.first);i++) \\n    {\\n        csum+=grid[C.first-i][C.second-i];\\n    }\\n     for(int i=1;i<(D.first-A.first);i++) \\n    {\\n        csum+=grid[D.first-i][D.second+i];\\n    }\\n    pq.push(csum);\\n    ++delta;\\n    }\\n}\\nbool canpush(vector<int>&ans,int&top)\\n{\\n   for(auto val:ans)\\n   {\\n       if(val==top)\\n       return false;\\n   }\\n   return true;\\n}\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int>ans;\\n        priority_queue<int>pq;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                getallsum(grid,i,j,pq);\\n            }\\n        }\\n        while(!pq.empty()&&ans.size()<3)\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            if(canpush(ans,top)) ans.push_back(top);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool checkbound(vector<vector<int>>& grid,vector<pair<int,int>>&v)\\n{\\n    int m=grid.size();\\n    int n=grid[0].size();\\n    for(auto it:v)\\n    {\\n        if(it.first<0||it.first>=m||it.second<0||it.second>=n) return false;\\n\\n    }\\n    return true;\\n}\\nbool getallvertices(vector<vector<int>>& grid,vector<pair<int,int>>&v,pair<int,int>c,int&delta)\\n{\\n    pair<int,int>A(c.first-delta,c.second);\\n    pair<int,int>B(c.first,c.second+delta);\\n    pair<int,int>C(c.first+delta,c.second);\\n    pair<int,int>D(c.first,c.second-delta);\\n    v[0]=A;\\n    v[1]=B;\\n    v[2]=C;\\n    v[3]=D;\\n    if(checkbound(grid,v)) return true;\\n    return false;\\n    \\n}\\nvoid getallsum(vector<vector<int>>& grid,int cx ,int cy,priority_queue<int>&pq)\\n{\\n    pq.push(grid[cx][cy]);\\n    int delta=1;\\n    vector<pair<int,int>>v(4);\\n    while(getallvertices(grid,v,{cx,cy},delta))\\n    {\\n            pair<int,int>&A=v[0];\\n            pair<int,int>&B=v[1];\\n            pair<int,int>&C=v[2];\\n            pair<int,int>&D=v[3];\\n    int csum=grid[A.first][A.second]+grid[B.first][B.second]+grid[C.first][C.second]+grid[D.first][D.second];  \\n    for(int i=1;i<(B.first-A.first);i++) \\n    {\\n        csum+=grid[A.first+i][A.second+i];\\n    }\\n     for(int i=1;i<(C.first-B.first);i++) \\n    {\\n        csum+=grid[B.first+i][B.second-i];\\n    }\\n     for(int i=1;i<(C.first-D.first);i++) \\n    {\\n        csum+=grid[C.first-i][C.second-i];\\n    }\\n     for(int i=1;i<(D.first-A.first);i++) \\n    {\\n        csum+=grid[D.first-i][D.second+i];\\n    }\\n    pq.push(csum);\\n    ++delta;\\n    }\\n}\\nbool canpush(vector<int>&ans,int&top)\\n{\\n   for(auto val:ans)\\n   {\\n       if(val==top)\\n       return false;\\n   }\\n   return true;\\n}\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int>ans;\\n        priority_queue<int>pq;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                getallsum(grid,i,j,pq);\\n            }\\n        }\\n        while(!pq.empty()&&ans.size()<3)\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            if(canpush(ans,top)) ans.push_back(top);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026799,
                "title": "clean-and-readable-solution-java-treeset",
                "content": "# Intuition\\nJust do what they ask!\\nThe only thing you need to think about here is the radius of a rhombus, which after a few contemplations can\\'t be more than min(n, m) / 2.\\n\\n# Approach\\n***Step 1:*** For simplicity purposes of calculating top3 highest sums I decided to use Binary Search Tree ( TreeSet ), since the number of elements in it won\\'t exceed 3 elements, it won\\'t take log time to process.\\n***Step 2:*** Iterate for each radius the entire matrix values, with restrictions on both sides with radius so that rhombus calculation function **getSum** could do it\\'s job without border checking.\\n***Step 3:*** Just look at rhombus closely and try to figure out the way to calculate all the values in it using parameter **d**.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m * d^2)\\nn = num rows\\nm = num columns\\nd = min(n, m) / 2\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private static int n;\\n    private static int m;\\n    public static int[] getBiggestThree(int[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int radius = Math.min(n, m) / 2;\\n        TreeSet<Integer> top3 = new TreeSet<>((a, b) -> b - a);\\n        for (int d = 0; d <= radius; d++) {\\n            for (int i = d; i < n-d; i++) {\\n                for (int j = d; j < m-d; j++) {\\n                    top3.add(getSum(i, j, d, grid));\\n                    if (top3.size() > 3) {\\n                        top3.remove(top3.last());\\n                    }\\n                }\\n            }\\n        }\\n\\n        int[] answer = new int[top3.size()];\\n        int i = 0;\\n        Iterator<Integer> it = top3.iterator();\\n        while (it.hasNext()) {\\n            answer[i++] = it.next();\\n        }\\n        return answer;\\n    }\\n\\n    private static int getSum(int i, int j, int d, int[][] grid) {\\n        if (d == 0) return grid[i][j];\\n        int sum = 0;\\n        for (int t = 0; t < d; t++) {\\n            sum += grid[i + d - t][j + t] + // bottom\\n                    grid[i - d + t][j - t] +  // up\\n                    grid[i + t][j - d + t] +  // left\\n                    grid[i - t][j + d - t]; // right\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    private static int n;\\n    private static int m;\\n    public static int[] getBiggestThree(int[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int radius = Math.min(n, m) / 2;\\n        TreeSet<Integer> top3 = new TreeSet<>((a, b) -> b - a);\\n        for (int d = 0; d <= radius; d++) {\\n            for (int i = d; i < n-d; i++) {\\n                for (int j = d; j < m-d; j++) {\\n                    top3.add(getSum(i, j, d, grid));\\n                    if (top3.size() > 3) {\\n                        top3.remove(top3.last());\\n                    }\\n                }\\n            }\\n        }\\n\\n        int[] answer = new int[top3.size()];\\n        int i = 0;\\n        Iterator<Integer> it = top3.iterator();\\n        while (it.hasNext()) {\\n            answer[i++] = it.next();\\n        }\\n        return answer;\\n    }\\n\\n    private static int getSum(int i, int j, int d, int[][] grid) {\\n        if (d == 0) return grid[i][j];\\n        int sum = 0;\\n        for (int t = 0; t < d; t++) {\\n            sum += grid[i + d - t][j + t] + // bottom\\n                    grid[i - d + t][j - t] +  // up\\n                    grid[i + t][j - d + t] +  // left\\n                    grid[i - t][j + d - t]; // right\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998808,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n    const int m = grid.size();\\n    const int n = grid[0].size();\\n    set<int> sums;\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        for (int sz = 0; i + sz < m && i - sz >= 0 && j + 2 * sz < n; ++sz) {\\n          const int sum = sz == 0 ? grid[i][j] : getSum(grid, i, j, sz);\\n          sums.insert(sum);\\n          if (sums.size() > 3)\\n            sums.erase(sums.begin());\\n        }\\n\\n    return vector<int>(sums.rbegin(), sums.rend());\\n  }\\n\\n private:\\n  // Returns rhombus sum of grid with top grid (i, j) and edge size `sz`.\\n  int getSum(const vector<vector<int>>& grid, int i, int j, int sz) {\\n    int x = i;\\n    int y = j;\\n    int sum = 0;\\n\\n    // Go left down.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[--x][++y];\\n\\n    // Go right down.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[++x][++y];\\n\\n    // Go right up.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[++x][--y];\\n\\n    // Go left up.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[--x][--y];\\n\\n    return sum;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n    const int m = grid.size();\\n    const int n = grid[0].size();\\n    set<int> sums;\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        for (int sz = 0; i + sz < m && i - sz >= 0 && j + 2 * sz < n; ++sz) {\\n          const int sum = sz == 0 ? grid[i][j] : getSum(grid, i, j, sz);\\n          sums.insert(sum);\\n          if (sums.size() > 3)\\n            sums.erase(sums.begin());\\n        }\\n\\n    return vector<int>(sums.rbegin(), sums.rend());\\n  }\\n\\n private:\\n  // Returns rhombus sum of grid with top grid (i, j) and edge size `sz`.\\n  int getSum(const vector<vector<int>>& grid, int i, int j, int sz) {\\n    int x = i;\\n    int y = j;\\n    int sum = 0;\\n\\n    // Go left down.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[--x][++y];\\n\\n    // Go right down.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[++x][++y];\\n\\n    // Go right up.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[++x][--y];\\n\\n    // Go left up.\\n    for (int k = 0; k < sz; ++k)\\n      sum += grid[--x][--y];\\n\\n    return sum;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994625,
                "title": "c-explanation-beats-99-45-runtime",
                "content": "# Approach\\n\\nSince `grid` max length/width is just 50, we can go along each cell in the grid and calculate its size.\\n\\nSo the first two cycles, ones incrementing `i_col` and `i_row` do that exactly. The next embedded cycle calculates the furthest sides of the rhombus, the left, up, right, and down. We need to make sure these don\\'t go out of the `grid`, so we do that too.\\n\\nTo avoid repeating the left/up/right/down calculations in both initialization and increment parts of the `for()` expression we use the trick that allows us to compute it inside the comparison part, and then compare the result.\\n\\nLastly, we use the computed sides to sum up each point from left to up, up \\u2192 right, right \\u2192 down, and down \\u2192 left. We only compute it till `len - 1` because otherwise we would end up calculating all four edge points twice.\\n\\nLastly, we check if the sum satisfies the requirement of being the biggest top 3. We use `std\\u2237set` to store the sums because it\\'s sorted, so we know exactly where\\'s the smallest element.\\n\\nLink to the submission: https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/submissions/1038966833/\\n\\n# Complexity\\n- Time complexity: $$O(m \\xD7 n \\xD7 min(m,n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(const vector<vector<int>>& grid) {\\n        set<int> ret;\\n        for (size_t i_row = 0; i_row < grid.size(); ++i_row) {\\n            for (size_t i_col = 0; i_col < grid[0].size(); ++i_col) {\\n                for (ssize_t i_up_row, i_down_row, i_left_col, i_right_col, len = 1;\\n                     (i_up_row = i_row - len + 1) >= 0 && (i_down_row = i_row + len - 1) < grid.size()\\n                         && (i_left_col = i_col - len + 1) >= 0 && (i_right_col = i_col + len - 1) < grid[0].size();\\n                     ++len) {\\n                    int curr_sum = 0;\\n                    if (len == 1)\\n                        curr_sum = grid[i_row][i_col];\\n                    else {\\n                        for (size_t i = 0; i < len - 1; ++i) {\\n                            curr_sum += grid[i_row - i][i_left_col + i] // left \\u2192 up\\n                                + grid[i_up_row + i][i_col + i]         // up \\u2192 right\\n                                + grid[i_row + i][i_right_col - i]      // right \\u2192 down\\n                                + grid[i_down_row - i][i_col - i];      // down \\u2192 left\\n                        }\\n                    }\\n                    if (ret.size() < 3)\\n                        ret.insert(curr_sum);\\n                    else if (curr_sum > *ret.begin() && ret.find(curr_sum) == ret.end()) {\\n                        ret.erase(ret.begin());\\n                        ret.insert(curr_sum);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ret2(ret.rbegin(), ret.rend());\\n        return ret2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(const vector<vector<int>>& grid) {\\n        set<int> ret;\\n        for (size_t i_row = 0; i_row < grid.size(); ++i_row) {\\n            for (size_t i_col = 0; i_col < grid[0].size(); ++i_col) {\\n                for (ssize_t i_up_row, i_down_row, i_left_col, i_right_col, len = 1;\\n                     (i_up_row = i_row - len + 1) >= 0 && (i_down_row = i_row + len - 1) < grid.size()\\n                         && (i_left_col = i_col - len + 1) >= 0 && (i_right_col = i_col + len - 1) < grid[0].size();\\n                     ++len) {\\n                    int curr_sum = 0;\\n                    if (len == 1)\\n                        curr_sum = grid[i_row][i_col];\\n                    else {\\n                        for (size_t i = 0; i < len - 1; ++i) {\\n                            curr_sum += grid[i_row - i][i_left_col + i] // left \\u2192 up\\n                                + grid[i_up_row + i][i_col + i]         // up \\u2192 right\\n                                + grid[i_row + i][i_right_col - i]      // right \\u2192 down\\n                                + grid[i_down_row - i][i_col - i];      // down \\u2192 left\\n                        }\\n                    }\\n                    if (ret.size() < 3)\\n                        ret.insert(curr_sum);\\n                    else if (curr_sum > *ret.begin() && ret.find(curr_sum) == ret.end()) {\\n                        ret.erase(ret.begin());\\n                        ret.insert(curr_sum);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ret2(ret.rbegin(), ret.rend());\\n        return ret2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986667,
                "title": "python-prefixes-sums-and-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe basically do lots of addition, so let\\'s do some of it ahead of time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate prefix sums of the diagonals. Keep track of best sums in a heap. For each point in the grid, we create the largest rhombus we can from that point, calculate the sum using the prefixes and add to our heap. If the heap is longer than 3, we pop. Return the sorted heap at the end.\\n\\n# Complexity\\n- Time complexity: O(mn*min(m,n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        left_prefix = [[0]*m for _ in range(n)]\\n        for j in range(m):\\n            left_prefix[0][j] = grid[0][j]\\n        for i in range(1, n):\\n            for j in range(m):\\n                if j + 1 < m:\\n                    left_prefix[i][j] = grid[i][j] + left_prefix[i-1][j+1]\\n                else:\\n                    left_prefix[i][j] = grid[i][j]\\n\\n        right_prefix = [[0]*m for _ in range(n)]\\n        for j in range(m):\\n            right_prefix[0][j] = grid[0][j]\\n        for i in range(1, n):\\n            for j in range(m):\\n                if j - 1 >= 0:\\n                    right_prefix[i][j] = grid[i][j] + right_prefix[i-1][j-1]\\n                else:\\n                    right_prefix[i][j] = grid[i][j]\\n        heap = []\\n        for i in range(n):\\n            for j in range(m):\\n                offset = 0\\n                while j - offset>= 0 and j + offset < m and i + 2*(offset) < n:\\n                    if offset == 0:\\n                        temp = grid[i][j]\\n                    else:\\n                        temp = left_prefix[i+offset][j-offset] - left_prefix[i][j] + grid[i][j] + right_prefix[i+offset][j+offset] - right_prefix[i][j] + right_prefix[i+2*offset][j]-right_prefix[i+offset][j-offset] + left_prefix[i+2*offset][j] - left_prefix[i+offset][j+offset] - grid[i+2*offset][j]\\n                    if temp not in heap:\\n                        heapq.heappush(heap, temp)\\n                        if len(heap) > 3:\\n                            heapq.heappop(heap)\\n                    offset+=1\\n        heap.sort(key = lambda x: -x)\\n        return heap\\n\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        left_prefix = [[0]*m for _ in range(n)]\\n        for j in range(m):\\n            left_prefix[0][j] = grid[0][j]\\n        for i in range(1, n):\\n            for j in range(m):\\n                if j + 1 < m:\\n                    left_prefix[i][j] = grid[i][j] + left_prefix[i-1][j+1]\\n                else:\\n                    left_prefix[i][j] = grid[i][j]\\n\\n        right_prefix = [[0]*m for _ in range(n)]\\n        for j in range(m):\\n            right_prefix[0][j] = grid[0][j]\\n        for i in range(1, n):\\n            for j in range(m):\\n                if j - 1 >= 0:\\n                    right_prefix[i][j] = grid[i][j] + right_prefix[i-1][j-1]\\n                else:\\n                    right_prefix[i][j] = grid[i][j]\\n        heap = []\\n        for i in range(n):\\n            for j in range(m):\\n                offset = 0\\n                while j - offset>= 0 and j + offset < m and i + 2*(offset) < n:\\n                    if offset == 0:\\n                        temp = grid[i][j]\\n                    else:\\n                        temp = left_prefix[i+offset][j-offset] - left_prefix[i][j] + grid[i][j] + right_prefix[i+offset][j+offset] - right_prefix[i][j] + right_prefix[i+2*offset][j]-right_prefix[i+offset][j-offset] + left_prefix[i+2*offset][j] - left_prefix[i+offset][j+offset] - grid[i+2*offset][j]\\n                    if temp not in heap:\\n                        heapq.heappush(heap, temp)\\n                        if len(heap) > 3:\\n                            heapq.heappop(heap)\\n                    offset+=1\\n        heap.sort(key = lambda x: -x)\\n        return heap\\n\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960934,
                "title": "brute-force-approach-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkBound(vector<vector<int>>& grid, vector<pair<int,int>>& v){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // points should not be out of bound\\n        // row should be in between (0,m)\\n        // col should be in between (0,n)\\n        for(auto pt : v){\\n            if(pt.first < 0 || pt.first >= m\\n                || pt.second < 0 || pt.second >= n)\\n                    return false;\\n        }\\n        return true;\\n    }\\n\\n    bool getAllVertices(vector<vector<int>>& grid, vector<pair<int,int>>& v,\\n                        pair<int,int> c, int& delta){\\n        pair<int,int> A = {c.first-delta,c.second};         // A( x-d , y \\n        pair<int,int> B = {c.first,c.second+delta};         // B( x   , y+d )\\n        pair<int,int> C = {c.first+delta,c.second};         // C( x+d , y )\\n        pair<int,int> D = {c.first,c.second-delta};         // D( x   , y-d )\\n\\n        v[0] = A;   v[1] = B;\\n        v[2] = C;   v[3] = D;\\n\\n        // check that the vertices we got are in bound or not\\n        if(checkBound(grid,v))\\n            return true;\\n        return false;\\n    }\\n\\n    void getAllSum(vector<vector<int>>& grid, int& cx, \\n                    int& cy, priority_queue<int>& pq){\\n        pq.push(grid[cx][cy]);\\n        int delta = 1;\\n        vector<pair<int,int>> v(4);\\n        while(getAllVertices(grid,v,{cx,cy},delta)){\\n            pair<int,int> A = v[0];\\n            pair<int,int> B = v[1];\\n            pair<int,int> C = v[2];\\n            pair<int,int> D = v[3];\\n            int csum = 0;\\n            // add all vertices\\n            csum = grid[A.first][A.second] + grid[B.first][B.second] \\n                    + grid[C.first][C.second] + grid[D.first][D.second];\\n            \\n            // add all intermidiate points\\n            // A - B\\n            for(int i = 1; i < (B.first-A.first); i++)\\n                csum += grid[A.first+i][A.second+i];\\n            // B - C\\n            for(int i = 1; i < (C.first-B.first); i++)\\n                csum += grid[B.first+i][B.second-i];\\n            \\n            // C - D\\n            for(int i = 1; i < (C.first-D.first); i++)\\n                csum += grid[C.first-i][C.second-i];\\n\\n            // D - A\\n            for(int i = 1; i < (D.first-A.first); i++)\\n                csum += grid[D.first-i][D.second+i];\\n\\n            pq.push(csum);\\n            delta++;\\n        }\\n\\n    }\\n\\n    bool canPush(vector<int>& ans, int top){\\n        for(auto i : ans){\\n            if(i == top)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                getAllSum(grid,i,j,pq);\\n            }\\n        }\\n\\n        while(!pq.empty() && ans.size() < 3){\\n            int top = pq.top();\\n            pq.pop();\\n            // store only unique entries\\n            if(canPush(ans,top))\\n                ans.push_back(top);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBound(vector<vector<int>>& grid, vector<pair<int,int>>& v){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // points should not be out of bound\\n        // row should be in between (0,m)\\n        // col should be in between (0,n)\\n        for(auto pt : v){\\n            if(pt.first < 0 || pt.first >= m\\n                || pt.second < 0 || pt.second >= n)\\n                    return false;\\n        }\\n        return true;\\n    }\\n\\n    bool getAllVertices(vector<vector<int>>& grid, vector<pair<int,int>>& v,\\n                        pair<int,int> c, int& delta){\\n        pair<int,int> A = {c.first-delta,c.second};         // A( x-d , y \\n        pair<int,int> B = {c.first,c.second+delta};         // B( x   , y+d )\\n        pair<int,int> C = {c.first+delta,c.second};         // C( x+d , y )\\n        pair<int,int> D = {c.first,c.second-delta};         // D( x   , y-d )\\n\\n        v[0] = A;   v[1] = B;\\n        v[2] = C;   v[3] = D;\\n\\n        // check that the vertices we got are in bound or not\\n        if(checkBound(grid,v))\\n            return true;\\n        return false;\\n    }\\n\\n    void getAllSum(vector<vector<int>>& grid, int& cx, \\n                    int& cy, priority_queue<int>& pq){\\n        pq.push(grid[cx][cy]);\\n        int delta = 1;\\n        vector<pair<int,int>> v(4);\\n        while(getAllVertices(grid,v,{cx,cy},delta)){\\n            pair<int,int> A = v[0];\\n            pair<int,int> B = v[1];\\n            pair<int,int> C = v[2];\\n            pair<int,int> D = v[3];\\n            int csum = 0;\\n            // add all vertices\\n            csum = grid[A.first][A.second] + grid[B.first][B.second] \\n                    + grid[C.first][C.second] + grid[D.first][D.second];\\n            \\n            // add all intermidiate points\\n            // A - B\\n            for(int i = 1; i < (B.first-A.first); i++)\\n                csum += grid[A.first+i][A.second+i];\\n            // B - C\\n            for(int i = 1; i < (C.first-B.first); i++)\\n                csum += grid[B.first+i][B.second-i];\\n            \\n            // C - D\\n            for(int i = 1; i < (C.first-D.first); i++)\\n                csum += grid[C.first-i][C.second-i];\\n\\n            // D - A\\n            for(int i = 1; i < (D.first-A.first); i++)\\n                csum += grid[D.first-i][D.second+i];\\n\\n            pq.push(csum);\\n            delta++;\\n        }\\n\\n    }\\n\\n    bool canPush(vector<int>& ans, int top){\\n        for(auto i : ans){\\n            if(i == top)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                getAllSum(grid,i,j,pq);\\n            }\\n        }\\n\\n        while(!pq.empty() && ans.size() < 3){\\n            int top = pq.top();\\n            pq.pop();\\n            // store only unique entries\\n            if(canPush(ans,top))\\n                ans.push_back(top);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858422,
                "title": "c-solution-better-than-98-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canPush(vector<int> &ans, int &top){\\n        for(auto it:ans){\\n            if(it == top)\\n                return false;\\n        }\\n        return true;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> maxheap;\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n\\n                //pushing one grid element\\n                    maxheap.push(grid[i][j]);\\n\\n                //now finding all related rhombuses taking current grid element as center\\n                //Let\\'s check if the current element is the edge of grid or not\\n                //when it is the edge element we cannot create a rhombus\\n                if(i==0 || j==0 || i==grid.size()-1 || j== grid[0].size()-1) \\n                    continue;\\n                \\n                //now create rhombuses from no edge elements\\n                else{\\n                    int delta =1;\\n                    \\n                    //mistake---! did not add all the conditions, upper limit I forgot to check\\n                    while(i-delta>=0 && j-delta>=0 && delta+i < grid.size() && delta+j <grid[i].size()){\\n                        //finding the vertices of rhombus\\n                        int a1 = i-delta;\\n                        int b1 = j;\\n\\n                        int a2 = i;\\n                        int b2 = j+delta;\\n                        \\n                        int a3 = i+delta;\\n                        int b3 = j;\\n                        \\n                        int a4 = i;\\n                        int b4 = j-delta;\\n\\n                        int sum = 0;\\n\\n                        //now finding the sum considering vertices and all grid cells between vertices\\n\\n                        //to find the sum from top point to right point \"\\\\\"\\n                        for(int v1=a1, v2=b1; v1<a2 && v2<b2; ){\\n                            sum += grid[v1++][v2++];\\n                        }\\n                        \\n                        //to find the sum from right to bottom line \"/\"\\n                        for(int v1=a2, v2=b2; v1<a3 && v2>b3; ){\\n                            sum += grid[v1++][v2--];\\n                        }\\n\\n                        //to find the sum from bottom to left \"\\\\\"\\n                        for(int v1=a3, v2=b3; v1>a4 && v2>b4; ){\\n                            sum += grid[v1--][v2--];\\n                        }\\n\\n                        //to find the sum from left to top \"/\"\\n                        for(int v1=a4, v2=b4; v1>a1 && v2<b1; ){\\n                            sum += grid[v1--][v2++];\\n                        }\\n\\n                        //if the current rhombus sum is greater than top element of heap then push it \\n                        maxheap.push(sum);\\n\\n                        delta ++;\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        //vector to store the answer\\n        vector<int> ans;\\n        \\n        ans.push_back(maxheap.top());\\n        maxheap.pop();\\n\\n        //loop to push all distinct elemnts from heap to array\\n        //mistake----! got stuck here.\\n        while (!maxheap.empty() && ans.size() < 3) {\\n            int top = maxheap.top();\\n            maxheap.pop();\\n\\n            if(canPush(ans, top))\\n                ans.push_back(top);\\n\\n        }    \\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canPush(vector<int> &ans, int &top){\\n        for(auto it:ans){\\n            if(it == top)\\n                return false;\\n        }\\n        return true;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> maxheap;\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n\\n                //pushing one grid element\\n                    maxheap.push(grid[i][j]);\\n\\n                //now finding all related rhombuses taking current grid element as center\\n                //Let\\'s check if the current element is the edge of grid or not\\n                //when it is the edge element we cannot create a rhombus\\n                if(i==0 || j==0 || i==grid.size()-1 || j== grid[0].size()-1) \\n                    continue;\\n                \\n                //now create rhombuses from no edge elements\\n                else{\\n                    int delta =1;\\n                    \\n                    //mistake---! did not add all the conditions, upper limit I forgot to check\\n                    while(i-delta>=0 && j-delta>=0 && delta+i < grid.size() && delta+j <grid[i].size()){\\n                        //finding the vertices of rhombus\\n                        int a1 = i-delta;\\n                        int b1 = j;\\n\\n                        int a2 = i;\\n                        int b2 = j+delta;\\n                        \\n                        int a3 = i+delta;\\n                        int b3 = j;\\n                        \\n                        int a4 = i;\\n                        int b4 = j-delta;\\n\\n                        int sum = 0;\\n\\n                        //now finding the sum considering vertices and all grid cells between vertices\\n\\n                        //to find the sum from top point to right point \"\\\\\"\\n                        for(int v1=a1, v2=b1; v1<a2 && v2<b2; ){\\n                            sum += grid[v1++][v2++];\\n                        }\\n                        \\n                        //to find the sum from right to bottom line \"/\"\\n                        for(int v1=a2, v2=b2; v1<a3 && v2>b3; ){\\n                            sum += grid[v1++][v2--];\\n                        }\\n\\n                        //to find the sum from bottom to left \"\\\\\"\\n                        for(int v1=a3, v2=b3; v1>a4 && v2>b4; ){\\n                            sum += grid[v1--][v2--];\\n                        }\\n\\n                        //to find the sum from left to top \"/\"\\n                        for(int v1=a4, v2=b4; v1>a1 && v2<b1; ){\\n                            sum += grid[v1--][v2++];\\n                        }\\n\\n                        //if the current rhombus sum is greater than top element of heap then push it \\n                        maxheap.push(sum);\\n\\n                        delta ++;\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        //vector to store the answer\\n        vector<int> ans;\\n        \\n        ans.push_back(maxheap.top());\\n        maxheap.pop();\\n\\n        //loop to push all distinct elemnts from heap to array\\n        //mistake----! got stuck here.\\n        while (!maxheap.empty() && ans.size() < 3) {\\n            int top = maxheap.top();\\n            maxheap.pop();\\n\\n            if(canPush(ans, top))\\n                ans.push_back(top);\\n\\n        }    \\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832723,
                "title": "java-step-by-step-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Try to create rhombus at each cell and get its sum , at the end add all answers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a max heap to get max rhomubs sum faster.\\n2. Go to each cell.\\n3. Each cell is a rhombus so add it into the heap.\\n4. Try to create a rhombus from current cell and check if it is valid or not.\\n5. if it is a valid rhombus then calculate its sum and add it to the ans.\\n6. repeat 3rd to 5th step for each cell.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n * max(m, n)), where m and n are the number of rows and columns in the grid, respectively.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n) because it dominates the space usage due to the priority queue.\\n# Code\\n```\\nimport java.util.*;\\n\\n// store cordinates of each element\\nclass Pair {\\n    int x;\\n    int y;\\n\\n    Pair(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nclass Solution {\\n\\n    // check if a rhombus is in bound\\n    static boolean inBound(int[][] grid, Pair v[]) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        // if it exceeds the row or column then it is out of bound\\n        for (int i = 0; i < v.length; i++) {\\n            if (v[i].x < 0 || v[i].x >= rows || v[i].y < 0 || v[i].y >= cols) {\\n                return false;\\n            }\\n        }\\n\\n        // otherwise it is in bound\\n        return true;\\n    }\\n\\n    static boolean getAllVertices(int[][] grid, Pair v[], Pair c, int delta) {\\n        // 4 cordinates of the rhombus.\\n        Pair A = new Pair(c.x - delta, c.y);\\n        Pair B = new Pair(c.x, c.y + delta);\\n        Pair C = new Pair(c.x + delta, c.y);\\n        Pair D = new Pair(c.x, c.y - delta);\\n\\n        // create a rhombus by putting all cordinates together.\\n        v[0] = A;\\n        v[1] = B;\\n        v[2] = C;\\n        v[3] = D;   \\n\\n        // check this rhombus is valid or not.\\n        if (inBound(grid, v)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // get sum of rhombus that can be created from the current cell\\n    static void getAllSum(int[][] grid, Queue<Integer> pq, int i, int j) {\\n        // every cell is a rhombus so add its value.\\n        pq.offer(grid[i][j]);\\n        int delta = 1;\\n        Pair v[] = new Pair[4];\\n\\n        // get all the rhombus that can be created from current cell\\n        while (getAllVertices(grid, v, new Pair(i, j), delta)) {\\n            // get the cordinates\\n            Pair A = v[0];\\n            Pair B = v[1];\\n            Pair C = v[2];\\n            Pair D = v[3];\\n            // calculate the sum of this rhombus\\n            int cSum = grid[A.x][A.y] + grid[B.x][B.y] + grid[C.x][C.y] + grid[D.x][D.y];\\n\\n            // cells between A -> B\\n            for (int z = 1; z < (B.x - A.x); z++) {\\n                cSum += grid[A.x + z][A.y + z];\\n            }\\n            // cells between B -> C\\n            for (int z = 1; z < (C.x - B.x); z++) {\\n                cSum += grid[B.x + z][B.y - z];\\n            }\\n            // cells between C -> D\\n            for (int z = 1; z < (C.x - D.x); z++) {\\n                cSum += grid[C.x - z][C.y - z];\\n            }\\n            // cells between D -> A\\n            for (int z = 1; z < (D.x - A.x); z++) {\\n                cSum += grid[D.x - z][D.y + z];\\n            }\\n\\n            // add the sum of all rhombus that can be made from current cell\\n            pq.offer(cSum);\\n            // increase the rhombus size\\n            ++delta;\\n        }\\n    }\\n\\n    public int[] getBiggestThree(int[][] grid) {\\n        // max heap to store rhombus sum \\n        Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        // traverse each cell and get all the sum of rhombus that can\\n        // be made from the current cell.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                getAllSum(grid, pq, i, j);\\n            }\\n        }\\n\\n        // list to store 3 biggest rhombus sum \\n        List<Integer> list = new ArrayList<>();\\n        \\n        // store rhomubses\\n        while (!pq.isEmpty() && list.size() < 3) {\\n            if (!list.contains(pq.peek())) {\\n                list.add(pq.poll());\\n            } else {\\n                pq.poll();\\n            }\\n        }\\n\\n        // final ans\\n        int ans[] = new int[list.size()];\\n        \\n        // convert into array\\n        for(int i = 0; i< list.size(); i++) ans[i] = list.get(i); \\n        pq = null;\\n        System.gc();\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\n// store cordinates of each element\\nclass Pair {\\n    int x;\\n    int y;\\n\\n    Pair(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nclass Solution {\\n\\n    // check if a rhombus is in bound\\n    static boolean inBound(int[][] grid, Pair v[]) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        // if it exceeds the row or column then it is out of bound\\n        for (int i = 0; i < v.length; i++) {\\n            if (v[i].x < 0 || v[i].x >= rows || v[i].y < 0 || v[i].y >= cols) {\\n                return false;\\n            }\\n        }\\n\\n        // otherwise it is in bound\\n        return true;\\n    }\\n\\n    static boolean getAllVertices(int[][] grid, Pair v[], Pair c, int delta) {\\n        // 4 cordinates of the rhombus.\\n        Pair A = new Pair(c.x - delta, c.y);\\n        Pair B = new Pair(c.x, c.y + delta);\\n        Pair C = new Pair(c.x + delta, c.y);\\n        Pair D = new Pair(c.x, c.y - delta);\\n\\n        // create a rhombus by putting all cordinates together.\\n        v[0] = A;\\n        v[1] = B;\\n        v[2] = C;\\n        v[3] = D;   \\n\\n        // check this rhombus is valid or not.\\n        if (inBound(grid, v)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // get sum of rhombus that can be created from the current cell\\n    static void getAllSum(int[][] grid, Queue<Integer> pq, int i, int j) {\\n        // every cell is a rhombus so add its value.\\n        pq.offer(grid[i][j]);\\n        int delta = 1;\\n        Pair v[] = new Pair[4];\\n\\n        // get all the rhombus that can be created from current cell\\n        while (getAllVertices(grid, v, new Pair(i, j), delta)) {\\n            // get the cordinates\\n            Pair A = v[0];\\n            Pair B = v[1];\\n            Pair C = v[2];\\n            Pair D = v[3];\\n            // calculate the sum of this rhombus\\n            int cSum = grid[A.x][A.y] + grid[B.x][B.y] + grid[C.x][C.y] + grid[D.x][D.y];\\n\\n            // cells between A -> B\\n            for (int z = 1; z < (B.x - A.x); z++) {\\n                cSum += grid[A.x + z][A.y + z];\\n            }\\n            // cells between B -> C\\n            for (int z = 1; z < (C.x - B.x); z++) {\\n                cSum += grid[B.x + z][B.y - z];\\n            }\\n            // cells between C -> D\\n            for (int z = 1; z < (C.x - D.x); z++) {\\n                cSum += grid[C.x - z][C.y - z];\\n            }\\n            // cells between D -> A\\n            for (int z = 1; z < (D.x - A.x); z++) {\\n                cSum += grid[D.x - z][D.y + z];\\n            }\\n\\n            // add the sum of all rhombus that can be made from current cell\\n            pq.offer(cSum);\\n            // increase the rhombus size\\n            ++delta;\\n        }\\n    }\\n\\n    public int[] getBiggestThree(int[][] grid) {\\n        // max heap to store rhombus sum \\n        Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        // traverse each cell and get all the sum of rhombus that can\\n        // be made from the current cell.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                getAllSum(grid, pq, i, j);\\n            }\\n        }\\n\\n        // list to store 3 biggest rhombus sum \\n        List<Integer> list = new ArrayList<>();\\n        \\n        // store rhomubses\\n        while (!pq.isEmpty() && list.size() < 3) {\\n            if (!list.contains(pq.peek())) {\\n                list.add(pq.poll());\\n            } else {\\n                pq.poll();\\n            }\\n        }\\n\\n        // final ans\\n        int ans[] = new int[list.size()];\\n        \\n        // convert into array\\n        for(int i = 0; i< list.size(); i++) ans[i] = list.get(i); \\n        pq = null;\\n        System.gc();\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818298,
                "title": "rust-brute-force-beats-100",
                "content": "# Approach\\nIterate through all possible rhombus, calculate the sums, and return the 3 largest distinct sums.\\n\\nSince the size of return Vec is just <= 3, I didn\\'t choose BTreeMap over Vec.\\n\\n# Complexity\\n- Time complexity: $$O(m*n*(m + n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nconst ANS_LEN: usize = 3;\\n\\nimpl Solution {\\n    pub fn get_biggest_three(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut ans = Vec::with_capacity(ANS_LEN + 1);\\n        for i in 0..m {\\n            for j in 0..n {\\n                Self::update(&mut ans, grid[i][j]);\\n                let max_w = j.min(n - j - 1).min((m - i - 1) / 2);\\n                for w in 1..=max_w {\\n                    // [i, j] is the top point of the rhombus.\\n                    let rh = (0..w).map(|k|\\n                        grid[i + k][j + k] +\\n                        grid[i + w + k][j + w - k] +\\n                        grid[i + 2*w - k][j - k] +\\n                        grid[i + w - k][j - w + k]\\n                    )\\n                    .sum::<i32>();\\n                    Self::update(&mut ans, rh);\\n                }\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn update(ans: &mut Vec<i32>, x: i32) {\\n        if let Err(i) = ans.binary_search_by(|y| x.cmp(y)) {\\n            ans.insert(i, x);\\n            ans.truncate(ANS_LEN);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst ANS_LEN: usize = 3;\\n\\nimpl Solution {\\n    pub fn get_biggest_three(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        let mut ans = Vec::with_capacity(ANS_LEN + 1);\\n        for i in 0..m {\\n            for j in 0..n {\\n                Self::update(&mut ans, grid[i][j]);\\n                let max_w = j.min(n - j - 1).min((m - i - 1) / 2);\\n                for w in 1..=max_w {\\n                    // [i, j] is the top point of the rhombus.\\n                    let rh = (0..w).map(|k|\\n                        grid[i + k][j + k] +\\n                        grid[i + w + k][j + w - k] +\\n                        grid[i + 2*w - k][j - k] +\\n                        grid[i + w - k][j - w + k]\\n                    )\\n                    .sum::<i32>();\\n                    Self::update(&mut ans, rh);\\n                }\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn update(ans: &mut Vec<i32>, x: i32) {\\n        if let Err(i) = ans.binary_search_by(|y| x.cmp(y)) {\\n            ans.insert(i, x);\\n            ans.truncate(ANS_LEN);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805895,
                "title": "c-80-beat-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPriority Queue\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkBound(vector<vector<int>>& grid,vector<pair<int,int>>&v){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(auto i:v){\\n           if(i.first <0 || i.first >=row || i.second <0 || i.second >=col){\\n               return false;\\n           }\\n        }\\n        return true;\\n    }\\n    bool getAllVertices(vector<vector<int>>& grid,vector<pair<int,int>>&v ,pair<int,int>c, int delta){\\n        pair<int,int> A = make_pair(c.first-delta,c.second);\\n        pair<int,int> B = make_pair(c.first,c.second+delta);\\n        pair<int,int> C = make_pair(c.first+delta,c.second);\\n        pair<int,int> D = make_pair(c.first,c.second-delta);\\n        \\n        v[0] = A;\\n        v[1] = B;\\n        v[2] = C;\\n        v[3] = D;\\n\\n        if(checkBound(grid,v)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    void getAllSum(vector<vector<int>>& grid,int &cx, int &cy, priority_queue<int> &pq){\\n        pq.push(grid[cx][cy]);\\n        int delta = 1;\\n        vector<pair<int,int>>v(4);\\n        while(getAllVertices(grid,v,{cx,cy},delta)){\\n              pair<int,int> &A = v[0];\\n              pair<int,int> &B = v[1];\\n              pair<int,int> &C = v[2];\\n              pair<int,int> &D = v[3];\\n\\n              int csum = grid[A.first][A.second]+grid[B.first][B.second]+grid[C.first][C.second]+grid[D.first][D.second];\\n\\n            //   A to B sum\\n            for(int i = 1;i<(B.first - A.first);i++){\\n                csum+= grid[A.first+i][A.second+i];\\n            }\\n            // B to C sum  \\n             for(int i = 1;i<(C.first - B.first);i++){\\n                csum+= grid[B.first+i][B.second-i];\\n            }\\n             // C to D sum  \\n             for(int i = 1;i<(C.first - D.first);i++){\\n                csum+= grid[C.first-i][C.second-i];\\n            }\\n\\n              // D to A sum  \\n             for(int i = 1;i<(D.first- A.first);i++){\\n                csum+= grid[D.first-i][D.second+i];\\n            }\\n            pq.push(csum);\\n            delta++;\\n        }\\n    }\\n    bool canpush(vector<int> &ans,int top){\\n\\n        for(auto val : ans){\\n            if(val == top){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        priority_queue<int> pq;\\n        for(int i = 0;i<row;i++){\\n            for(int j = 0;j<col;j++){\\n               getAllSum(grid,i,j,pq);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!pq.empty() && ans.size()<3){\\n          int top = pq.top();\\n          pq.pop();\\n\\n          if(canpush(ans,top)){\\n              ans.push_back(top);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBound(vector<vector<int>>& grid,vector<pair<int,int>>&v){\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(auto i:v){\\n           if(i.first <0 || i.first >=row || i.second <0 || i.second >=col){\\n               return false;\\n           }\\n        }\\n        return true;\\n    }\\n    bool getAllVertices(vector<vector<int>>& grid,vector<pair<int,int>>&v ,pair<int,int>c, int delta){\\n        pair<int,int> A = make_pair(c.first-delta,c.second);\\n        pair<int,int> B = make_pair(c.first,c.second+delta);\\n        pair<int,int> C = make_pair(c.first+delta,c.second);\\n        pair<int,int> D = make_pair(c.first,c.second-delta);\\n        \\n        v[0] = A;\\n        v[1] = B;\\n        v[2] = C;\\n        v[3] = D;\\n\\n        if(checkBound(grid,v)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    void getAllSum(vector<vector<int>>& grid,int &cx, int &cy, priority_queue<int> &pq){\\n        pq.push(grid[cx][cy]);\\n        int delta = 1;\\n        vector<pair<int,int>>v(4);\\n        while(getAllVertices(grid,v,{cx,cy},delta)){\\n              pair<int,int> &A = v[0];\\n              pair<int,int> &B = v[1];\\n              pair<int,int> &C = v[2];\\n              pair<int,int> &D = v[3];\\n\\n              int csum = grid[A.first][A.second]+grid[B.first][B.second]+grid[C.first][C.second]+grid[D.first][D.second];\\n\\n            //   A to B sum\\n            for(int i = 1;i<(B.first - A.first);i++){\\n                csum+= grid[A.first+i][A.second+i];\\n            }\\n            // B to C sum  \\n             for(int i = 1;i<(C.first - B.first);i++){\\n                csum+= grid[B.first+i][B.second-i];\\n            }\\n             // C to D sum  \\n             for(int i = 1;i<(C.first - D.first);i++){\\n                csum+= grid[C.first-i][C.second-i];\\n            }\\n\\n              // D to A sum  \\n             for(int i = 1;i<(D.first- A.first);i++){\\n                csum+= grid[D.first-i][D.second+i];\\n            }\\n            pq.push(csum);\\n            delta++;\\n        }\\n    }\\n    bool canpush(vector<int> &ans,int top){\\n\\n        for(auto val : ans){\\n            if(val == top){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        priority_queue<int> pq;\\n        for(int i = 0;i<row;i++){\\n            for(int j = 0;j<col;j++){\\n               getAllSum(grid,i,j,pq);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!pq.empty() && ans.size()<3){\\n          int top = pq.top();\\n          pq.pop();\\n\\n          if(canpush(ans,top)){\\n              ans.push_back(top);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798503,
                "title": "c-heaps-and-priority-queue-solution-easy-to-read-and-understand-code",
                "content": "# Complexity\\n- Time complexity: O(m * n * min(m, n));\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkBounds(vector<vector<int>>& grid, vector<pair<int, int>>& v)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(auto pt : v)\\n        {\\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n)\\n            {\\n                return false;\\n            }\\n        } \\n\\n        return true;\\n    }\\n\\n    bool getAllVertices(vector<vector<int>>& grid, vector<pair<int, int>>& v, pair<int, int> centre, int& delta)\\n    {\\n        pair<int, int> A(centre.first - delta, centre.second);\\n        pair<int, int> B(centre.first, centre.second + delta);\\n        pair<int, int> C(centre.first + delta, centre.second);\\n        pair<int, int> D(centre.first, centre.second - delta);\\n\\n        v[0] = A;\\n        v[1] = B;\\n        v[2] = C;\\n        v[3] = D;\\n\\n        if (checkBounds(grid, v)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void getAllSum(vector<vector<int>>& grid, int& cx, int& cy, priority_queue<int>& pq)\\n    {\\n        int delta = 0;\\n        vector<pair<int, int>> v(4);\\n        while (getAllVertices(grid, v, make_pair(cx, cy), delta))\\n        {\\n            int csum = 0;\\n\\n            // Loop for the side from A to B\\n            for (int i = 0; i <= delta; ++i)\\n            {\\n                csum += grid[v[0].first + i][v[0].second + i];\\n            }\\n\\n            // Loop for the side from B to C\\n            for (int i = 1; i <= delta; ++i)\\n            {\\n                csum += grid[v[1].first + i][v[1].second - i];\\n            }\\n\\n            // Loop for the side from C to D\\n            for (int i = 1; i <= delta; ++i)\\n            {\\n                csum += grid[v[2].first - i][v[2].second - i];\\n            }\\n\\n            // Loop for the side from D to A\\n            for (int i = 1; i < delta; ++i)\\n            {\\n                csum += grid[v[3].first - i][v[3].second + i];\\n            }\\n\\n            pq.push(csum);\\n            ++delta;\\n        }\\n    }\\n\\n    bool canPush(vector<int>& res, int& val)\\n    {\\n        for (auto it : res)\\n        {\\n            if (it == val) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int k = 3;\\n        vector<int> res;\\n        priority_queue<int> pq;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                getAllSum(grid, i, j, pq);\\n            }\\n        }\\n\\n        while (pq.size() > 0 && res.size() < k)\\n        {\\n            int val = pq.top();\\n            if (canPush(res, val)) {\\n                res.push_back(val);\\n            }\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBounds(vector<vector<int>>& grid, vector<pair<int, int>>& v)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for(auto pt : v)\\n        {\\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n)\\n            {\\n                return false;\\n            }\\n        } \\n\\n        return true;\\n    }\\n\\n    bool getAllVertices(vector<vector<int>>& grid, vector<pair<int, int>>& v, pair<int, int> centre, int& delta)\\n    {\\n        pair<int, int> A(centre.first - delta, centre.second);\\n        pair<int, int> B(centre.first, centre.second + delta);\\n        pair<int, int> C(centre.first + delta, centre.second);\\n        pair<int, int> D(centre.first, centre.second - delta);\\n\\n        v[0] = A;\\n        v[1] = B;\\n        v[2] = C;\\n        v[3] = D;\\n\\n        if (checkBounds(grid, v)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void getAllSum(vector<vector<int>>& grid, int& cx, int& cy, priority_queue<int>& pq)\\n    {\\n        int delta = 0;\\n        vector<pair<int, int>> v(4);\\n        while (getAllVertices(grid, v, make_pair(cx, cy), delta))\\n        {\\n            int csum = 0;\\n\\n            // Loop for the side from A to B\\n            for (int i = 0; i <= delta; ++i)\\n            {\\n                csum += grid[v[0].first + i][v[0].second + i];\\n            }\\n\\n            // Loop for the side from B to C\\n            for (int i = 1; i <= delta; ++i)\\n            {\\n                csum += grid[v[1].first + i][v[1].second - i];\\n            }\\n\\n            // Loop for the side from C to D\\n            for (int i = 1; i <= delta; ++i)\\n            {\\n                csum += grid[v[2].first - i][v[2].second - i];\\n            }\\n\\n            // Loop for the side from D to A\\n            for (int i = 1; i < delta; ++i)\\n            {\\n                csum += grid[v[3].first - i][v[3].second + i];\\n            }\\n\\n            pq.push(csum);\\n            ++delta;\\n        }\\n    }\\n\\n    bool canPush(vector<int>& res, int& val)\\n    {\\n        for (auto it : res)\\n        {\\n            if (it == val) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int k = 3;\\n        vector<int> res;\\n        priority_queue<int> pq;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                getAllSum(grid, i, j, pq);\\n            }\\n        }\\n\\n        while (pq.size() > 0 && res.size() < k)\\n        {\\n            int val = pq.top();\\n            if (canPush(res, val)) {\\n                res.push_back(val);\\n            }\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765482,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool getVertices(vector<vector<int>>& grid, int i, int j, int delta, vector<pair<int, int>> &vertices){\\n           int m = grid.size();\\n\\n           int n = grid[0].size();\\n\\n           if(i+delta >= m || i - delta < 0 || j + delta >= n || j - delta < 0) return false;\\n\\n           vertices.push_back({i-delta, j});\\n           vertices.push_back({i, j+delta});\\n           vertices.push_back({i+delta, j});\\n           vertices.push_back({i, j-delta});\\n\\n           return true;\\n\\n    }\\n\\n    void getallSum(vector<vector<int>>& grid, int i, int j, priority_queue<int> &pq){\\n\\n\\n      pq.push(grid[i][j]);\\n\\n      int delta = 1;\\n\\n      vector<pair<int, int>> vertices;\\n\\n      while(getVertices(grid, i, j, delta, vertices)){\\n\\n         pair<int, int> A = vertices[0];\\n         pair<int, int> B = vertices[1];\\n         pair<int, int> C = vertices[2];\\n         pair<int, int> D = vertices[3];\\n\\n\\n         int sum = 0;\\n\\n         // sum of line AB\\n         for(int row = 0;row < B.first - A.first;row++){\\n              sum = sum + grid[A.first+row][A.second+row];\\n         }\\n\\n        //  // sum of line BC\\n         for(int row = 0;row < C.first - B.first;row++){\\n              sum = sum + grid[B.first+row][B.second-row];\\n         }\\n\\n        //  // sum of line CD\\n         for(int row = 0;row < C.first - D.first;row++){\\n              sum = sum + grid[C.first-row][C.second-row];\\n         }\\n\\n        //  // sum of line DA\\n         for(int row = 0;row < D.first - A.first;row++){\\n              sum = sum + grid[D.first-row][D.second+row];\\n         }\\n\\n         pq.push(sum);\\n\\n         delta++;\\n        //  cout<<delta<<endl;\\n\\n         vertices.clear();\\n\\n      }\\n\\n\\n\\n\\n    }\\n\\n\\n   bool canPush(vector<int>& ans, int top){\\n       for(auto it: ans){\\n           if(it == top) return false;\\n       }\\n       return true;\\n   }\\n\\n\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n\\n        priority_queue<int> pq;\\n\\n        for(int i = 0;i<grid.size();i++){\\n            for(int j = 0;j<grid[0].size();j++){\\n                getallSum(grid, i, j, pq);\\n            }\\n        }\\n\\n        int k = 3;\\n\\n        while(!pq.empty() && k > 0){\\n            int top = pq.top(); pq.pop();\\n            //  cout<<top<<endl;\\n            if(canPush(ans, top)){\\n                ans.push_back(top); k--;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool getVertices(vector<vector<int>>& grid, int i, int j, int delta, vector<pair<int, int>> &vertices){\\n           int m = grid.size();\\n\\n           int n = grid[0].size();\\n\\n           if(i+delta >= m || i - delta < 0 || j + delta >= n || j - delta < 0) return false;\\n\\n           vertices.push_back({i-delta, j});\\n           vertices.push_back({i, j+delta});\\n           vertices.push_back({i+delta, j});\\n           vertices.push_back({i, j-delta});\\n\\n           return true;\\n\\n    }\\n\\n    void getallSum(vector<vector<int>>& grid, int i, int j, priority_queue<int> &pq){\\n\\n\\n      pq.push(grid[i][j]);\\n\\n      int delta = 1;\\n\\n      vector<pair<int, int>> vertices;\\n\\n      while(getVertices(grid, i, j, delta, vertices)){\\n\\n         pair<int, int> A = vertices[0];\\n         pair<int, int> B = vertices[1];\\n         pair<int, int> C = vertices[2];\\n         pair<int, int> D = vertices[3];\\n\\n\\n         int sum = 0;\\n\\n         // sum of line AB\\n         for(int row = 0;row < B.first - A.first;row++){\\n              sum = sum + grid[A.first+row][A.second+row];\\n         }\\n\\n        //  // sum of line BC\\n         for(int row = 0;row < C.first - B.first;row++){\\n              sum = sum + grid[B.first+row][B.second-row];\\n         }\\n\\n        //  // sum of line CD\\n         for(int row = 0;row < C.first - D.first;row++){\\n              sum = sum + grid[C.first-row][C.second-row];\\n         }\\n\\n        //  // sum of line DA\\n         for(int row = 0;row < D.first - A.first;row++){\\n              sum = sum + grid[D.first-row][D.second+row];\\n         }\\n\\n         pq.push(sum);\\n\\n         delta++;\\n        //  cout<<delta<<endl;\\n\\n         vertices.clear();\\n\\n      }\\n\\n\\n\\n\\n    }\\n\\n\\n   bool canPush(vector<int>& ans, int top){\\n       for(auto it: ans){\\n           if(it == top) return false;\\n       }\\n       return true;\\n   }\\n\\n\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int> ans;\\n\\n        priority_queue<int> pq;\\n\\n        for(int i = 0;i<grid.size();i++){\\n            for(int j = 0;j<grid[0].size();j++){\\n                getallSum(grid, i, j, pq);\\n            }\\n        }\\n\\n        int k = 3;\\n\\n        while(!pq.empty() && k > 0){\\n            int top = pq.top(); pq.pop();\\n            //  cout<<top<<endl;\\n            if(canPush(ans, top)){\\n                ans.push_back(top); k--;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3728013,
                "title": "prefix-sum-python-3-stupid-code",
                "content": "# Intuition\\nBrute force.\\n\\n# Approach\\nThis is a space-wasteful implementation, but coding-friendly. See the code below.\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        ROW, COL = len(grid), len(grid[0])\\n        # prefix sums in two diagonal directions\\n        ls1 = {i: [0]*ROW for i in range(0-(COL-1), (ROW-1)-0+1)} # \\\\, up to bottom, indexed by r-c\\n        ls2 = {i: [0]*ROW for i in range(0, (ROW-1)+(COL-1)+1)} # /, up to bottom, indexed by r+c\\n        for r in range(ROW):\\n            for c in range(COL):\\n                v = grid[r][c] if r==0 else grid[r][c] + ls1[r-c][r-1]\\n                ls1[r-c][r] = v\\n                v = grid[r][c] if r==0 else grid[r][c] + ls2[r+c][r-1]\\n                ls2[r+c][r] = v\\n        def rhombusSum(center_r, center_c, size):\\n            if size == 0:\\n                return grid[center_r][center_c]\\n            up     = (center_r - size, center_c)\\n            bottom = (center_r + size, center_c)\\n            left   = (center_r, center_c - size)\\n            right  = (center_r, center_c + size)\\n            #                up\\n            #                 o\\n            #   \"/\": ls2  e4 / \\\\ e1  \"\\\\\": ls1\\n            #               /   \\\\  \\n            #         left o     o right\\n            #               \\\\   / \\n            #   \"\\\\\": ls1  e3 \\\\ / e2  \"/\": ls2\\n            #                 o\\n            #               bottom\\n            ####################################\\n            # prefix sum lists for the egdes\\n            e1 = ls1[up[0] - up[1]]\\n            e2 = ls2[right[0] + right[1]]\\n            e3 = ls1[bottom[0] - bottom[1]]\\n            e4 = ls2[left[0] + left[1]]\\n            # sum of edges (one edge includes one vertice)\\n            s = 0\\n            s += e1[right[0]] - e1[up[0]]\\n            s += e2[bottom[0]] - e2[right[0]]\\n            s += (e3[bottom[0]-1] if bottom[0]>=1 else 0) - (e3[left[0]-1] if left[0]>=1 else 0)\\n            s += (e4[left[0]-1] if left[0]>=1 else 0) - (e4[up[0]-1] if up[0]>=1 else 0)\\n            return s\\n        # a heap of fixed size 3\\n        sums = []\\n        heapq.heapify(sums)\\n        seen = set()\\n        for r in range(ROW):\\n            for c in range(COL):\\n                for size in range(min([r, c, ROW-1-r, COL-1-c]) + 1):\\n                    r_sum = rhombusSum(r, c, size)\\n                    if r_sum in seen:\\n                        continue\\n                    seen.add(r_sum)\\n                    heapq.heappush(sums, r_sum)\\n                    if len(sums) > 3:\\n                        _ = heapq.heappop(sums)\\n        res = []\\n        while sums:\\n            res.append(heapq.heappop(sums))\\n        res.reverse()\\n        return res\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(n^3)$$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        ROW, COL = len(grid), len(grid[0])\\n        # prefix sums in two diagonal directions\\n        ls1 = {i: [0]*ROW for i in range(0-(COL-1), (ROW-1)-0+1)} # \\\\, up to bottom, indexed by r-c\\n        ls2 = {i: [0]*ROW for i in range(0, (ROW-1)+(COL-1)+1)} # /, up to bottom, indexed by r+c\\n        for r in range(ROW):\\n            for c in range(COL):\\n                v = grid[r][c] if r==0 else grid[r][c] + ls1[r-c][r-1]\\n                ls1[r-c][r] = v\\n                v = grid[r][c] if r==0 else grid[r][c] + ls2[r+c][r-1]\\n                ls2[r+c][r] = v\\n        def rhombusSum(center_r, center_c, size):\\n            if size == 0:\\n                return grid[center_r][center_c]\\n            up     = (center_r - size, center_c)\\n            bottom = (center_r + size, center_c)\\n            left   = (center_r, center_c - size)\\n            right  = (center_r, center_c + size)\\n            #                up\\n            #                 o\\n            #   \"/\": ls2  e4 / \\\\ e1  \"\\\\\": ls1\\n            #               /   \\\\  \\n            #         left o     o right\\n            #               \\\\   / \\n            #   \"\\\\\": ls1  e3 \\\\ / e2  \"/\": ls2\\n            #                 o\\n            #               bottom\\n            ####################################\\n            # prefix sum lists for the egdes\\n            e1 = ls1[up[0] - up[1]]\\n            e2 = ls2[right[0] + right[1]]\\n            e3 = ls1[bottom[0] - bottom[1]]\\n            e4 = ls2[left[0] + left[1]]\\n            # sum of edges (one edge includes one vertice)\\n            s = 0\\n            s += e1[right[0]] - e1[up[0]]\\n            s += e2[bottom[0]] - e2[right[0]]\\n            s += (e3[bottom[0]-1] if bottom[0]>=1 else 0) - (e3[left[0]-1] if left[0]>=1 else 0)\\n            s += (e4[left[0]-1] if left[0]>=1 else 0) - (e4[up[0]-1] if up[0]>=1 else 0)\\n            return s\\n        # a heap of fixed size 3\\n        sums = []\\n        heapq.heapify(sums)\\n        seen = set()\\n        for r in range(ROW):\\n            for c in range(COL):\\n                for size in range(min([r, c, ROW-1-r, COL-1-c]) + 1):\\n                    r_sum = rhombusSum(r, c, size)\\n                    if r_sum in seen:\\n                        continue\\n                    seen.add(r_sum)\\n                    heapq.heappush(sums, r_sum)\\n                    if len(sums) > 3:\\n                        _ = heapq.heappop(sums)\\n        res = []\\n        while sums:\\n            res.append(heapq.heappop(sums))\\n        res.reverse()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389338,
                "title": "c-easy-solution-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int,greater<int>> st;\\n        vector<int> v;\\n        vector<int> row{-1,1,1,-1};\\n        vector<int> col{1,1,-1,-1};\\n\\n        int maxi=0;\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                maxi=max(maxi,grid[i][j]);\\n                for(int k=0;k<50;k++){\\n                    bool flag=true;\\n                    int r=i,c=j;\\n                    int sum=grid[r][c];\\n                    for(int dir=0;dir<4;dir++){\\n                       \\n                        for(int go=0;go<k;go++){                           \\n                            \\n                            r+=row[dir];\\n                            c+=col[dir];\\n                            \\n                            if(!isValid(r,c,n,m)){\\n                                flag=false;\\n                                 break;\\n                            }else{\\n                                sum+=grid[r][c];\\n                            }\\n                        }\\n                    }\\n                    if(!flag){\\n                        break;\\n                    }\\n                    if(k!=0){\\n                        sum-=grid[i][j];\\n                    }\\n                    \\n                    st.insert(sum);\\n                    \\n                }\\n            }\\n        }\\n        \\n        if(st.size()<3){\\n            for(auto &it:st){\\n                v.push_back(it);\\n            }\\n        }else{\\n            int i=0;\\n            for(auto &it:st){\\n                if(i==3){\\n                    break;\\n                }\\n                v.push_back(it);\\n                i++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int,greater<int>> st;\\n        vector<int> v;\\n        vector<int> row{-1,1,1,-1};\\n        vector<int> col{1,1,-1,-1};\\n\\n        int maxi=0;\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                maxi=max(maxi,grid[i][j]);\\n                for(int k=0;k<50;k++){\\n                    bool flag=true;\\n                    int r=i,c=j;\\n                    int sum=grid[r][c];\\n                    for(int dir=0;dir<4;dir++){\\n                       \\n                        for(int go=0;go<k;go++){                           \\n                            \\n                            r+=row[dir];\\n                            c+=col[dir];\\n                            \\n                            if(!isValid(r,c,n,m)){\\n                                flag=false;\\n                                 break;\\n                            }else{\\n                                sum+=grid[r][c];\\n                            }\\n                        }\\n                    }\\n                    if(!flag){\\n                        break;\\n                    }\\n                    if(k!=0){\\n                        sum-=grid[i][j];\\n                    }\\n                    \\n                    st.insert(sum);\\n                    \\n                }\\n            }\\n        }\\n        \\n        if(st.size()<3){\\n            for(auto &it:st){\\n                v.push_back(it);\\n            }\\n        }else{\\n            int i=0;\\n            for(auto &it:st){\\n                if(i==3){\\n                    break;\\n                }\\n                v.push_back(it);\\n                i++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255245,
                "title": "python3-clean-and-commented-code-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain idea to have a prefix sum in both diagonal directions (left and rigth) for full Grid. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we will prepare prefix sum arrays for both diagonal directions(left and right), these would further leveraged during calculation of every rhombus boundary cells values sum.\\n\\nAfter above step, we will iterate over all cells in grid, for each cell we will try to make every possibel rhombus, including that single cell also, and then we will append area of each rhombus in an hashmap(to store only unique values). Here, cretivity is mainly is using prefix sum arrays in calculating boundary sum. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nif grid is (m x n)\\n$$O(m^2*n)$$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m^2*n)$$\\n\\n![Screenshot 2023-03-04 at 4.02.28 PM.png](https://assets.leetcode.com/users/images/2cd6fabc-be45-48b7-81d0-90f8ec5aa933_1677925969.9516308.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        all_area = set() \\n\\n        # making diagonal prefix sum\\n        right_pfsum = [[grid[i][j] for j in range(n)] for i in range(m)]\\n        left_pfsum = [[grid[i][j] for j in range(n)] for i in range(m)]\\n\\n        # for j in range(n):\\n        #     right_pfsum[0][j] = grid[0][j]\\n        #     left_pfsum[0][j] = grid[0][j]\\n        \\n        # for i in range(m):\\n        #     right_pfsum[i][0] = grid[i][0]\\n        #     left_pfsum[i][n-1] = grid[i][n-1]\\n        \\n        # populate right prefix sum\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                right_pfsum[i][j] += right_pfsum[i-1][j-1]\\n        \\n        for i in range(1, m):\\n            for j in range(n-2, -1, -1):\\n                left_pfsum[i][j] += left_pfsum[i-1][j+1]\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                all_area.add(grid[i][j])\\n                if i <= m-3:\\n                    d = 2\\n                    while(True):\\n                        bottom_x, bottom_y = i+d, j\\n                        if bottom_x >= m:\\n                            break\\n\\n                        left_x, left_y = (i + d//2), j-d//2\\n                        right_x, right_y = (i + d//2), j+d//2\\n\\n                        if left_y < 0:\\n                            break\\n                        if right_y >= n:\\n                            break\\n                        \\n                        top_right = left_pfsum[i-1][j+1] if (i-1)>=0 and (j+1)<n else 0\\n                        top_left = right_pfsum[i-1][j-1] if (i-1)>=0 and (j-1)>=0 else 0\\n\\n                        sum_left = left_pfsum[left_x][left_y] - top_right\\n                        sum_right = right_pfsum[right_x][right_y] - top_left\\n\\n                        # right_up = left_pfsum[right_x-1][right_y+1] if (right_x-1)>=0 and (right_y+1)<n else 0\\n                        # left_up = right_pfsum[left_x-1][left_y-1] if (left_x-1)>=0 and (left_y-1)>=0 else 0\\n\\n                        b_sum_left = right_pfsum[bottom_x][bottom_y] - right_pfsum[left_x][left_y]\\n                        b_sum_right = left_pfsum[bottom_x][bottom_y] - left_pfsum[right_x][right_y]\\n\\n                        t_sum = sum_left + sum_right + b_sum_left + b_sum_right - grid[i][j] - grid[bottom_x][bottom_y]\\n                        all_area.add(t_sum)\\n                        d += 2\\n        \\n        all_area = sorted(list(all_area), reverse = True)\\n        return all_area[:3]\\n\\n\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        all_area = set() \\n\\n        # making diagonal prefix sum\\n        right_pfsum = [[grid[i][j] for j in range(n)] for i in range(m)]\\n        left_pfsum = [[grid[i][j] for j in range(n)] for i in range(m)]\\n\\n        # for j in range(n):\\n        #     right_pfsum[0][j] = grid[0][j]\\n        #     left_pfsum[0][j] = grid[0][j]\\n        \\n        # for i in range(m):\\n        #     right_pfsum[i][0] = grid[i][0]\\n        #     left_pfsum[i][n-1] = grid[i][n-1]\\n        \\n        # populate right prefix sum\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                right_pfsum[i][j] += right_pfsum[i-1][j-1]\\n        \\n        for i in range(1, m):\\n            for j in range(n-2, -1, -1):\\n                left_pfsum[i][j] += left_pfsum[i-1][j+1]\\n\\n\\n        for i in range(m):\\n            for j in range(n):\\n                all_area.add(grid[i][j])\\n                if i <= m-3:\\n                    d = 2\\n                    while(True):\\n                        bottom_x, bottom_y = i+d, j\\n                        if bottom_x >= m:\\n                            break\\n\\n                        left_x, left_y = (i + d//2), j-d//2\\n                        right_x, right_y = (i + d//2), j+d//2\\n\\n                        if left_y < 0:\\n                            break\\n                        if right_y >= n:\\n                            break\\n                        \\n                        top_right = left_pfsum[i-1][j+1] if (i-1)>=0 and (j+1)<n else 0\\n                        top_left = right_pfsum[i-1][j-1] if (i-1)>=0 and (j-1)>=0 else 0\\n\\n                        sum_left = left_pfsum[left_x][left_y] - top_right\\n                        sum_right = right_pfsum[right_x][right_y] - top_left\\n\\n                        # right_up = left_pfsum[right_x-1][right_y+1] if (right_x-1)>=0 and (right_y+1)<n else 0\\n                        # left_up = right_pfsum[left_x-1][left_y-1] if (left_x-1)>=0 and (left_y-1)>=0 else 0\\n\\n                        b_sum_left = right_pfsum[bottom_x][bottom_y] - right_pfsum[left_x][left_y]\\n                        b_sum_right = left_pfsum[bottom_x][bottom_y] - left_pfsum[right_x][right_y]\\n\\n                        t_sum = sum_left + sum_right + b_sum_left + b_sum_right - grid[i][j] - grid[bottom_x][bottom_y]\\n                        all_area.add(t_sum)\\n                        d += 2\\n        \\n        all_area = sorted(list(all_area), reverse = True)\\n        return all_area[:3]\\n\\n\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250038,
                "title": "python-presum",
                "content": "first construct the presum for two type of diagonals;\\nsecond for each possible center of the shape, determine the max radius;\\nlast iterate the radius from 1 to the max radius, counting the border sum using presum.\\n\\n\\n```\\ndef getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m,n=len(grid), len(grid[0])\\n        ps1=[[0 for j in range(n)] for i in range(m)]\\n        ps2=[[0 for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ps1[i][j]=(ps1[i-1][j-1] if i-1>=0 and j-1>=0 else 0)+grid[i][j]\\n        for i in range(m):\\n            for j in range(n-1,-1,-1):\\n                ps2[i][j]=(ps2[i-1][j+1] if i-1>=0 and j+1<n else 0)+grid[i][j]\\n        s=set()##store all legal sums\\n        for i in range(m):\\n            for j in range(n):\\n                radius=min(i,j,m-1-i,n-1-j)\\n                s.add(grid[i][j])\\n                for r in range(1,radius+1):\\n                    x1,y1=i-r,j\\n                    x2,y2=i,j-r\\n                    x3,y3=i+r,j\\n                    x4,y4=i,j+r\\n                    sm=ps2[x2][y2]-ps2[x1][y1]+grid[x1][y1]\\n                    sm+=ps2[x3][y3]-ps2[x4][y4]+grid[x4][y4]\\n                    sm+=ps1[x4-1][y4-1]-ps1[x1][y1]\\n                    sm+=ps1[x3-1][y3-1]-ps1[x2][y2]\\n                    s.add(sm)\\n        s=list(s)\\n        s.sort(reverse=True)\\n        while len(s)>3:\\n            s.pop()\\n        return s",
                "solutionTags": [],
                "code": "first construct the presum for two type of diagonals;\\nsecond for each possible center of the shape, determine the max radius;\\nlast iterate the radius from 1 to the max radius, counting the border sum using presum.\\n\\n\\n```\\ndef getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m,n=len(grid), len(grid[0])\\n        ps1=[[0 for j in range(n)] for i in range(m)]\\n        ps2=[[0 for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ps1[i][j]=(ps1[i-1][j-1] if i-1>=0 and j-1>=0 else 0)+grid[i][j]\\n        for i in range(m):\\n            for j in range(n-1,-1,-1):\\n                ps2[i][j]=(ps2[i-1][j+1] if i-1>=0 and j+1<n else 0)+grid[i][j]\\n        s=set()##store all legal sums\\n        for i in range(m):\\n            for j in range(n):\\n                radius=min(i,j,m-1-i,n-1-j)\\n                s.add(grid[i][j])\\n                for r in range(1,radius+1):\\n                    x1,y1=i-r,j\\n                    x2,y2=i,j-r\\n                    x3,y3=i+r,j\\n                    x4,y4=i,j+r\\n                    sm=ps2[x2][y2]-ps2[x1][y1]+grid[x1][y1]\\n                    sm+=ps2[x3][y3]-ps2[x4][y4]+grid[x4][y4]\\n                    sm+=ps1[x4-1][y4-1]-ps1[x1][y1]\\n                    sm+=ps1[x3-1][y3-1]-ps1[x2][y2]\\n                    s.add(sm)\\n        s=list(s)\\n        s.sort(reverse=True)\\n        while len(s)>3:\\n            s.pop()\\n        return s",
                "codeTag": "Python3"
            },
            {
                "id": 3228256,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_biggest_three(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ld = grid.clone();\\n        let mut rd = grid.clone();\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        for i in 0..m {\\n            for j in 0..n {\\n                let pi = i as i32 - 1;\\n                let prevj = j as i32 - 1;\\n                if pi >= 0 && prevj >= 0 {\\n                    ld[i][j] += ld[pi as usize][prevj as usize];\\n                }\\n                let prevj = j + 1;\\n                if pi >= 0 && prevj < n {\\n                    rd[i][j] += rd[pi as usize][prevj];\\n                }\\n            }\\n        }\\n        let mut cnt = std::collections::BTreeMap::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                *cnt.entry(grid[i][j]).or_insert(0) += 1;\\n                for k in 1..=m.max(n) {\\n                    let left = j as i32 - k as i32;\\n                    let right = j as i32 + k as i32;\\n                    let bot = i as i32 + 2 * k as i32;\\n                    if left < 0 || right >= n as i32 || bot >= m as i32 {\\n                        continue;\\n                    }\\n                    let sum = rd[i + k][left as usize] - rd[i][j] + ld[i + k][right as usize] - ld[i][j]\\n                        + ld[bot as usize][j]\\n                        - ld[i + k][left as usize]\\n                        + rd[bot as usize][j]\\n                        - rd[i + k][right as usize]\\n                        + grid[i][j]\\n                        - grid[bot as usize][j];\\n                    *cnt.entry(sum).or_insert(0) += 1;\\n                }\\n                while cnt.len() > 3 {\\n                    let k = *cnt.iter().next().unwrap().0;\\n                    cnt.remove(&k);\\n                }\\n            }\\n        }\\n        let mut ans = vec![];\\n        for (&k, _) in cnt.iter().rev() {\\n            ans.push(k);\\n            if ans.len() >= 3 {\\n                return ans;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_biggest_three(grid: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ld = grid.clone();\\n        let mut rd = grid.clone();\\n        let m = grid.len();\\n        let n = grid[0].len();\\n        for i in 0..m {\\n            for j in 0..n {\\n                let pi = i as i32 - 1;\\n                let prevj = j as i32 - 1;\\n                if pi >= 0 && prevj >= 0 {\\n                    ld[i][j] += ld[pi as usize][prevj as usize];\\n                }\\n                let prevj = j + 1;\\n                if pi >= 0 && prevj < n {\\n                    rd[i][j] += rd[pi as usize][prevj];\\n                }\\n            }\\n        }\\n        let mut cnt = std::collections::BTreeMap::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                *cnt.entry(grid[i][j]).or_insert(0) += 1;\\n                for k in 1..=m.max(n) {\\n                    let left = j as i32 - k as i32;\\n                    let right = j as i32 + k as i32;\\n                    let bot = i as i32 + 2 * k as i32;\\n                    if left < 0 || right >= n as i32 || bot >= m as i32 {\\n                        continue;\\n                    }\\n                    let sum = rd[i + k][left as usize] - rd[i][j] + ld[i + k][right as usize] - ld[i][j]\\n                        + ld[bot as usize][j]\\n                        - ld[i + k][left as usize]\\n                        + rd[bot as usize][j]\\n                        - rd[i + k][right as usize]\\n                        + grid[i][j]\\n                        - grid[bot as usize][j];\\n                    *cnt.entry(sum).or_insert(0) += 1;\\n                }\\n                while cnt.len() > 3 {\\n                    let k = *cnt.iter().next().unwrap().0;\\n                    cnt.remove(&k);\\n                }\\n            }\\n        }\\n        let mut ans = vec![];\\n        for (&k, _) in cnt.iter().rev() {\\n            ans.push(k);\\n            if ans.len() >= 3 {\\n                return ans;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170333,
                "title": "recursive-code-brute-force",
                "content": "```\\nclass Solution {\\n    HashSet<Integer> info = new HashSet<>();\\n    public int[] getBiggestThree(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){ info.add(grid[i][j]);\\n                find(grid,i,j,Integer.MIN_VALUE,Integer.MIN_VALUE,0,0);}\\n        }\\n        int output[];\\n        if(info.size()>2) output= new int[3];\\n        else output = new int[info.size()];\\n        List<Integer> data = new ArrayList<>(info);\\n        Collections.sort(data,Collections.reverseOrder());\\n        for(int i=0;i<data.size();i++) { if(i>2) break;output[i] = data.get(i); }\\n        return(output);\\n    }\\n    public void find(int grid[][],int i,int j,int a,int b,int sum,int sign){\\n        if(i>=grid.length||j>=grid[0].length||i<0||j<0) return;\\n        if(a!=Integer.MIN_VALUE||b!=Integer.MIN_VALUE)\\n            if(a>=grid.length||b>=grid[0].length||a<0||b<0)\\n                return;\\n        if(a==i&&b==j) { info.add(sum+grid[i][j]); return; }\\n        int add = grid[i][j];\\n        if(a==Integer.MIN_VALUE) { a=i;b=j; }\\n        else add+=grid[a][b];\\n        if(sign!=-1) find(grid,i+1,j-1,a+1,b+1,sum+add,0);\\n        find(grid,i+1,j+1,a+1,b-1,sum+add,-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    HashSet<Integer> info = new HashSet<>();\\n    public int[] getBiggestThree(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){ info.add(grid[i][j]);\\n                find(grid,i,j,Integer.MIN_VALUE,Integer.MIN_VALUE,0,0);}",
                "codeTag": "Java"
            },
            {
                "id": 3105834,
                "title": "c-good-code-quality-brute-force-clear-explanations",
                "content": "# Intuition\\nWhen constraints are low it indicates such problem can be solved with brute force.\\n\\n# Approach\\nSince we need distinct values a set is a perfect choice of weapon. A set is also sorted so it also helps us in getting the biggest three values. \\nNow loop through each point except corners of matrix because these corners cannot make rhombus.\\nFrom every point we will find the maximum length rhombus side can be made and we build every rhombus and record its sum and store it in set.\\nFinally get the 3 distinct values inside a vector and return it.\\n\\n# Complexity\\n- Time complexity: $$O(m*n*min(m,n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {1,1,-1,-1};\\n    int dy[4] = {1,-1,-1,1};\\n\\n    int getRhombusSum(int row,int col,vector<vector<int>>& grid,int side){\\n        int sum=0;\\n        int k=0;\\n        if((grid.size()-row-1)<side*2) return -1;\\n        while(k<side*4){\\n            sum+=grid[row][col];\\n            row+=dx[k/side];\\n            col+=dy[k/side];\\n            k++;\\n        }\\n        return sum;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<int> result;\\n        set<int> sums;\\n        for(int i=0;i<rows;++i){\\n            for(int j=0;j<cols;++j){\\n                sums.insert(grid[i][j]);\\n                if(j==0 || j==cols-1) continue;\\n                int maxLength = min(j,cols-j-1);\\n                for(int side=1;side<=maxLength;++side){\\n                    int rhombusSum = getRhombusSum(i,j,grid,side);\\n                    if(rhombusSum!=-1) sums.insert(rhombusSum);\\n                }\\n            }\\n        }\\n        for(auto it=sums.rbegin();it!=sums.rend();++it){\\n            if(result.size()==3) break;\\n            result.push_back(*it);\\n        }\\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1,1,-1,-1};\\n    int dy[4] = {1,-1,-1,1};\\n\\n    int getRhombusSum(int row,int col,vector<vector<int>>& grid,int side){\\n        int sum=0;\\n        int k=0;\\n        if((grid.size()-row-1)<side*2) return -1;\\n        while(k<side*4){\\n            sum+=grid[row][col];\\n            row+=dx[k/side];\\n            col+=dy[k/side];\\n            k++;\\n        }\\n        return sum;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<int> result;\\n        set<int> sums;\\n        for(int i=0;i<rows;++i){\\n            for(int j=0;j<cols;++j){\\n                sums.insert(grid[i][j]);\\n                if(j==0 || j==cols-1) continue;\\n                int maxLength = min(j,cols-j-1);\\n                for(int side=1;side<=maxLength;++side){\\n                    int rhombusSum = getRhombusSum(i,j,grid,side);\\n                    if(rhombusSum!=-1) sums.insert(rhombusSum);\\n                }\\n            }\\n        }\\n        for(auto it=sums.rbegin();it!=sums.rend();++it){\\n            if(result.size()==3) break;\\n            result.push_back(*it);\\n        }\\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080891,
                "title": "simple-fast-c-solution-easy-understanding-priority-queue",
                "content": "# Approach\\nIdea is that we iterate through every grid cell, and find all possible rhombus sum, which can be make by assuming this cell as centre of the rhombus.\\n\\n# Complexity\\n- Time complexity:  O(n * m * (min(n,m)));\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                pq.push(grid[i][j]);\\n                int t = min(i, min(j, min(n-1-i, m-1-j)));\\n                int x = i-t, x0=i+t;\\n                while(x != i){\\n                    int x1 = x;\\n                    int sum = 0, k=0;\\n                    while(x1 <= i){\\n                        if(!k){\\n                            sum += grid[x1][j-k];\\n                        }\\n                        else{\\n                            sum += grid[x1][j-k]+grid[x1][j+k];\\n                        }\\n                        k++, x1++;\\n                    }\\n                    x1 = x0, k=0;\\n                    while(x1 != i){\\n                        if(!k){\\n                            sum += grid[x1][j-k];\\n                        }\\n                        else{\\n                            sum += grid[x1][j-k]+grid[x1][j+k];\\n                        }\\n                        k--, x1--;\\n                    }\\n                    pq.push(sum); \\n                    x++, x0--;  \\n                }\\n            }\\n        }\\n        vector<int> res;\\n        while(res.size()!=3 && !pq.empty()){\\n            int x = pq.top(); pq.pop();\\n            bool f=true;\\n            for(auto a : res){\\n                if(a == x){\\n                    f=false;\\n                }\\n            }\\n            if(f){\\n                res.push_back(x);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                pq.push(grid[i][j]);\\n                int t = min(i, min(j, min(n-1-i, m-1-j)));\\n                int x = i-t, x0=i+t;\\n                while(x != i){\\n                    int x1 = x;\\n                    int sum = 0, k=0;\\n                    while(x1 <= i){\\n                        if(!k){\\n                            sum += grid[x1][j-k];\\n                        }\\n                        else{\\n                            sum += grid[x1][j-k]+grid[x1][j+k];\\n                        }\\n                        k++, x1++;\\n                    }\\n                    x1 = x0, k=0;\\n                    while(x1 != i){\\n                        if(!k){\\n                            sum += grid[x1][j-k];\\n                        }\\n                        else{\\n                            sum += grid[x1][j-k]+grid[x1][j+k];\\n                        }\\n                        k--, x1--;\\n                    }\\n                    pq.push(sum); \\n                    x++, x0--;  \\n                }\\n            }\\n        }\\n        vector<int> res;\\n        while(res.size()!=3 && !pq.empty()){\\n            int x = pq.top(); pq.pop();\\n            bool f=true;\\n            for(auto a : res){\\n                if(a == x){\\n                    f=false;\\n                }\\n            }\\n            if(f){\\n                res.push_back(x);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066021,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n     let rsums = new Set();\\n     let rows=grid.length\\n     let cols=grid[0].length\\n     for(let i=0;i<rows;i++){\\n        for(let j=0; j< cols; j++){\\n            let maxr = Math.min(i-0,j-0,rows-1-i, cols-1-j)\\n            for(let k=0; k<=maxr;k++){\\n                //console.log(`${i},${j},${k}`)\\n                let sum=0;\\n                let r1=i-k,r2=i+k\\n                for(let y=r1; y<=r2; y++){\\n                     let dx =k-Math.abs(y-i)   \\n                    let x1= j-dx\\n                    let x2 =j+dx\\n                    //console.log(` y,x1,x2 ${y} ${x1} ${x2}`)\\n                \\n                    sum+= grid[y][x1] + (x1 !=x2? grid[y][x2]:0)\\n                }\\n                //console.log(sum)\\n                rsums.add(sum)\\n            }\\n        }    \\n     }\\n     let arr =[...rsums]\\n     arr.sort((a,b)=>b-a)\\n     \\n     return arr.splice(0,3)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n     let rsums = new Set();\\n     let rows=grid.length\\n     let cols=grid[0].length\\n     for(let i=0;i<rows;i++){\\n        for(let j=0; j< cols; j++){\\n            let maxr = Math.min(i-0,j-0,rows-1-i, cols-1-j)\\n            for(let k=0; k<=maxr;k++){\\n                //console.log(`${i},${j},${k}`)\\n                let sum=0;\\n                let r1=i-k,r2=i+k\\n                for(let y=r1; y<=r2; y++){\\n                     let dx =k-Math.abs(y-i)   \\n                    let x1= j-dx\\n                    let x2 =j+dx\\n                    //console.log(` y,x1,x2 ${y} ${x1} ${x2}`)\\n                \\n                    sum+= grid[y][x1] + (x1 !=x2? grid[y][x2]:0)\\n                }\\n                //console.log(sum)\\n                rsums.add(sum)\\n            }\\n        }    \\n     }\\n     let arr =[...rsums]\\n     arr.sort((a,b)=>b-a)\\n     \\n     return arr.splice(0,3)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032253,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int maxi=0;\\n        set<int> st;\\n        for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                   st.insert(grid[i][j]);\\n                }\\n            }\\n        for(int i=1;i<m-1;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                for(int s=1;s<50;s++)\\n                {\\n                    if(i-s<0 || j-s<0 || i+s>=m||j+s>=n)\\n                    break;\\n                    int rt=grid[i][j+s],lt=grid[i][j-s],tp=grid[i-s][j],dn=grid[i+s][j];\\n                    int tp_x=i-s,tp_y=j;\\n                    int lt_x=i,lt_y=j-s;\\n                    int rt_x=i,rt_y=j+s;\\n                    int dn_x=i+s,dn_y=j;\\n                    int lt_sum=0;\\n                    int tp_x_c=tp_x,tp_y_c=tp_y;\\n                    while(tp_x_c<=lt_x && tp_y_c>=lt_y)\\n                    {\\n                        lt_sum+=grid[tp_x_c][tp_y_c];\\n                        tp_x_c++;tp_y_c--;\\n                    }\\n                    int rt_sum=0;\\n                    tp_x_c=tp_x;tp_y_c=tp_y;\\n                    while(tp_x_c<=rt_x && tp_y_c<=rt_y)\\n                    {\\n                        rt_sum+=grid[tp_x_c][tp_y_c];\\n                        tp_x_c++;tp_y_c++;\\n                    }\\n                    int dn_rt_sum=0;\\n                    int dn_x_c=dn_x,dn_y_c=dn_y;\\n                    while(dn_x_c>=rt_x && dn_y_c<=rt_y)\\n                    {\\n                        dn_rt_sum+=grid[dn_x_c][dn_y_c];\\n                        dn_x_c--;dn_y_c++;\\n                    }\\n                    int dn_lt_sum=0;\\n                    dn_x_c=dn_x;dn_y_c=dn_y;\\n                    while(dn_x_c>=lt_x && dn_y_c>=lt_y)\\n                    {\\n                        dn_lt_sum+=grid[dn_x_c][dn_y_c];\\n                        dn_x_c--;dn_y_c--;\\n                    }\\n                    int bin=lt_sum+rt_sum+dn_rt_sum+dn_lt_sum-rt-lt-dn-tp;\\n                    st.insert(bin);\\n                }\\n            }\\n        }\\n        vector<int>l;int c=0;\\n        priority_queue<int>pq;\\n        for(auto v=st.begin();v!=st.end();v++)\\n        {\\n            pq.push(*v);\\n        }\\n        while(!pq.empty() && c<3)\\n        {\\n            l.push_back(pq.top());\\n            pq.pop();c++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int maxi=0;\\n        set<int> st;\\n        for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                   st.insert(grid[i][j]);\\n                }\\n            }\\n        for(int i=1;i<m-1;i++)\\n        {\\n            for(int j=1;j<n-1;j++)\\n            {\\n                for(int s=1;s<50;s++)\\n                {\\n                    if(i-s<0 || j-s<0 || i+s>=m||j+s>=n)\\n                    break;\\n                    int rt=grid[i][j+s],lt=grid[i][j-s],tp=grid[i-s][j],dn=grid[i+s][j];\\n                    int tp_x=i-s,tp_y=j;\\n                    int lt_x=i,lt_y=j-s;\\n                    int rt_x=i,rt_y=j+s;\\n                    int dn_x=i+s,dn_y=j;\\n                    int lt_sum=0;\\n                    int tp_x_c=tp_x,tp_y_c=tp_y;\\n                    while(tp_x_c<=lt_x && tp_y_c>=lt_y)\\n                    {\\n                        lt_sum+=grid[tp_x_c][tp_y_c];\\n                        tp_x_c++;tp_y_c--;\\n                    }\\n                    int rt_sum=0;\\n                    tp_x_c=tp_x;tp_y_c=tp_y;\\n                    while(tp_x_c<=rt_x && tp_y_c<=rt_y)\\n                    {\\n                        rt_sum+=grid[tp_x_c][tp_y_c];\\n                        tp_x_c++;tp_y_c++;\\n                    }\\n                    int dn_rt_sum=0;\\n                    int dn_x_c=dn_x,dn_y_c=dn_y;\\n                    while(dn_x_c>=rt_x && dn_y_c<=rt_y)\\n                    {\\n                        dn_rt_sum+=grid[dn_x_c][dn_y_c];\\n                        dn_x_c--;dn_y_c++;\\n                    }\\n                    int dn_lt_sum=0;\\n                    dn_x_c=dn_x;dn_y_c=dn_y;\\n                    while(dn_x_c>=lt_x && dn_y_c>=lt_y)\\n                    {\\n                        dn_lt_sum+=grid[dn_x_c][dn_y_c];\\n                        dn_x_c--;dn_y_c--;\\n                    }\\n                    int bin=lt_sum+rt_sum+dn_rt_sum+dn_lt_sum-rt-lt-dn-tp;\\n                    st.insert(bin);\\n                }\\n            }\\n        }\\n        vector<int>l;int c=0;\\n        priority_queue<int>pq;\\n        for(auto v=st.begin();v!=st.end();v++)\\n        {\\n            pq.push(*v);\\n        }\\n        while(!pq.empty() && c<3)\\n        {\\n            l.push_back(pq.top());\\n            pq.pop();c++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3025195,
                "title": "c-solution-using-set-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rhombusSum(vector<vector<int>>& grid,int l,int r,int u,int d){\\n        int c1 = (l+r)/2,c2=(l+r)/2,sum=0;\\n        bool expand = true;\\n\\n        for(int row = u;row<=d;row++){\\n            if(c1 == c2) sum += grid[row][c1];\\n            else sum += grid[row][c1] + grid[row][c2];\\n\\n//if c1==l then c2 automatically equal r no need to write both but its okay to write both        \\n            if(c1 == l && c2==r) expand = false;\\n\\n            if(expand) c1--,c2++;\\n            else c1++,c2--;\\n        }\\n\\n        return sum;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size();\\n        set<int> pq;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l=j,r=j,d=i; // left,right,down\\n                while(l>=0 && r<n && d<m){\\n                    int sum = rhombusSum(grid,l,r,i,d);\\n                    l--; r++; d += 2;\\n                    if(pq.size() < 3) pq.insert(sum);\\n                    else if(pq.size() == 3 && pq.count(sum)==0 && sum > *(pq.begin())) {\\n                        pq.erase(pq.begin());\\n                        pq.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        for(int it : pq){\\n            ans.push_back(it);\\n        }\\n\\n        //already sorted so reverse it to get decreasing order\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rhombusSum(vector<vector<int>>& grid,int l,int r,int u,int d){\\n        int c1 = (l+r)/2,c2=(l+r)/2,sum=0;\\n        bool expand = true;\\n\\n        for(int row = u;row<=d;row++){\\n            if(c1 == c2) sum += grid[row][c1];\\n            else sum += grid[row][c1] + grid[row][c2];\\n\\n//if c1==l then c2 automatically equal r no need to write both but its okay to write both        \\n            if(c1 == l && c2==r) expand = false;\\n\\n            if(expand) c1--,c2++;\\n            else c1++,c2--;\\n        }\\n\\n        return sum;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size();\\n        set<int> pq;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l=j,r=j,d=i; // left,right,down\\n                while(l>=0 && r<n && d<m){\\n                    int sum = rhombusSum(grid,l,r,i,d);\\n                    l--; r++; d += 2;\\n                    if(pq.size() < 3) pq.insert(sum);\\n                    else if(pq.size() == 3 && pq.count(sum)==0 && sum > *(pq.begin())) {\\n                        pq.erase(pq.begin());\\n                        pq.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        for(int it : pq){\\n            ans.push_back(it);\\n        }\\n\\n        //already sorted so reverse it to get decreasing order\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025193,
                "title": "c-solution-using-set-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rhombusSum(vector<vector<int>>& grid,int l,int r,int u,int d){\\n        int c1 = (l+r)/2,c2=(l+r)/2,sum=0;\\n        bool expand = true;\\n\\n        for(int row = u;row<=d;row++){\\n            if(c1 == c2) sum += grid[row][c1];\\n            else sum += grid[row][c1] + grid[row][c2];\\n\\n//if c1==l then c2 automatically equal r no need to write both but its okay to write both        \\n            if(c1 == l && c2==r) expand = false;\\n\\n            if(expand) c1--,c2++;\\n            else c1++,c2--;\\n        }\\n\\n        return sum;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size();\\n        set<int> pq;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l=j,r=j,d=i; // left,right,down\\n                while(l>=0 && r<n && d<m){\\n                    int sum = rhombusSum(grid,l,r,i,d);\\n                    l--; r++; d += 2;\\n                    if(pq.size() < 3) pq.insert(sum);\\n                    else if(pq.size() == 3 && pq.count(sum)==0 && sum > *(pq.begin())) {\\n                        pq.erase(pq.begin());\\n                        pq.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        for(int it : pq){\\n            ans.push_back(it);\\n        }\\n\\n        //already sorted so reverse it to get decreasing order\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rhombusSum(vector<vector<int>>& grid,int l,int r,int u,int d){\\n        int c1 = (l+r)/2,c2=(l+r)/2,sum=0;\\n        bool expand = true;\\n\\n        for(int row = u;row<=d;row++){\\n            if(c1 == c2) sum += grid[row][c1];\\n            else sum += grid[row][c1] + grid[row][c2];\\n\\n//if c1==l then c2 automatically equal r no need to write both but its okay to write both        \\n            if(c1 == l && c2==r) expand = false;\\n\\n            if(expand) c1--,c2++;\\n            else c1++,c2--;\\n        }\\n\\n        return sum;\\n    }\\n\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size(),n=grid[0].size();\\n        set<int> pq;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l=j,r=j,d=i; // left,right,down\\n                while(l>=0 && r<n && d<m){\\n                    int sum = rhombusSum(grid,l,r,i,d);\\n                    l--; r++; d += 2;\\n                    if(pq.size() < 3) pq.insert(sum);\\n                    else if(pq.size() == 3 && pq.count(sum)==0 && sum > *(pq.begin())) {\\n                        pq.erase(pq.begin());\\n                        pq.insert(sum);\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        for(int it : pq){\\n            ans.push_back(it);\\n        }\\n\\n        //already sorted so reverse it to get decreasing order\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975263,
                "title": "python-diagonal-prefix-sums-o-mn-min-m-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        RD = [[defaultdict(int) for j in range(n)] for i in range(m)]\\n        LD = [[defaultdict(int) for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                k = 1\\n                while 0 <= i + k < m and 0 <= j + k < n:\\n                    RD[i][j][k] = RD[i][j][k-1] + grid[i+k][j+k]\\n                    k += 1\\n                k = 1\\n                while 0 <= i + k < m and 0 <= j - k < n:\\n                    LD[i][j][k] = LD[i][j][k-1] + grid[i+k][j-k]\\n                    k += 1\\n        res = set()\\n        for i in range(m):\\n            for j in range(n):\\n                tmp = grid[i][j]\\n                res.add(tmp)\\n                ld = 0\\n                rd = 0\\n                k = 1\\n                while 0 <= i+2*k < m and 0 <= j-k < n and 0 <= j+k < n:\\n                    rd += grid[i+k][j+k]\\n                    ld += grid[i+k][j-k]\\n                    res.add(rd + ld + tmp + RD[i+k][j-k][k] + LD[i+k][j+k][k] - grid[i+2*k][j])\\n                    k += 1\\n        return sorted(res)[::-1][:3]\\n\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        RD = [[defaultdict(int) for j in range(n)] for i in range(m)]\\n        LD = [[defaultdict(int) for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                k = 1\\n                while 0 <= i + k < m and 0 <= j + k < n:\\n                    RD[i][j][k] = RD[i][j][k-1] + grid[i+k][j+k]\\n                    k += 1\\n                k = 1\\n                while 0 <= i + k < m and 0 <= j - k < n:\\n                    LD[i][j][k] = LD[i][j][k-1] + grid[i+k][j-k]\\n                    k += 1\\n        res = set()\\n        for i in range(m):\\n            for j in range(n):\\n                tmp = grid[i][j]\\n                res.add(tmp)\\n                ld = 0\\n                rd = 0\\n                k = 1\\n                while 0 <= i+2*k < m and 0 <= j-k < n and 0 <= j+k < n:\\n                    rd += grid[i+k][j+k]\\n                    ld += grid[i+k][j-k]\\n                    res.add(rd + ld + tmp + RD[i+k][j-k][k] + LD[i+k][j+k][k] - grid[i+2*k][j])\\n                    k += 1\\n        return sorted(res)[::-1][:3]\\n\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846424,
                "title": "brute-force-in-java",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int[] sums = {0, 0, 0};        \\n        for (int side = 1; side <= (Math.min(grid.length, grid[0].length) + 1) / 2; side++) {\\n            for (int v = 0; v <= grid.length - 2 * side + 1; v++) {\\n                for (int h = side - 1; h <= grid[0].length - side; h++) {\\n                    int sum = 0;\\n                    if (side == 1) {\\n                        sum = grid[v][h];\\n                    } else {                        \\n                        for (int i = 0; i <= side - 2; i++) {\\n                            sum += grid[v + i][h - i];\\n                            sum += grid[v + side - 1 + i][h - side + 1 + i];\\n                            sum += grid[v + 2 * (side - 1) - i][h + i];\\n                            sum += grid[v + side - 1 - i][h + side - 1 - i];\\n                        }\\n                    }\\n                    \\n                    boolean doesExist = false;\\n                    for (int i = 0; i < sums.length; i++) {\\n                        doesExist = doesExist || sum == sums[i];\\n                        if (!doesExist && sum > sums[i]) {\\n                            for (int j = sums.length - 1; j >= i + 1; j--) {\\n                               sums[j] = sums[j - 1];\\n                            }\\n                            sums[i] = sum;\\n                            break;\\n                        }\\n                    }                           \\n                }               \\n            }\\n        }\\n        \\n        int length = 0;\\n        for (int i = 0; i < sums.length; i++) {\\n            if (sums[i] > 0) length++;\\n        }\\n        int[] ans = new int[length];\\n        for (int i = 0; i < length; i++) {\\n            ans[i] = sums[i];\\n        }        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int[] sums = {0, 0, 0};        \\n        for (int side = 1; side <= (Math.min(grid.length, grid[0].length) + 1) / 2; side++) {\\n            for (int v = 0; v <= grid.length - 2 * side + 1; v++) {\\n                for (int h = side - 1; h <= grid[0].length - side; h++) {\\n                    int sum = 0;\\n                    if (side == 1) {\\n                        sum = grid[v][h];\\n                    } else {                        \\n                        for (int i = 0; i <= side - 2; i++) {\\n                            sum += grid[v + i][h - i];\\n                            sum += grid[v + side - 1 + i][h - side + 1 + i];\\n                            sum += grid[v + 2 * (side - 1) - i][h + i];\\n                            sum += grid[v + side - 1 - i][h + side - 1 - i];\\n                        }\\n                    }\\n                    \\n                    boolean doesExist = false;\\n                    for (int i = 0; i < sums.length; i++) {\\n                        doesExist = doesExist || sum == sums[i];\\n                        if (!doesExist && sum > sums[i]) {\\n                            for (int j = sums.length - 1; j >= i + 1; j--) {\\n                               sums[j] = sums[j - 1];\\n                            }\\n                            sums[i] = sum;\\n                            break;\\n                        }\\n                    }                           \\n                }               \\n            }\\n        }\\n        \\n        int length = 0;\\n        for (int i = 0; i < sums.length; i++) {\\n            if (sums[i] > 0) length++;\\n        }\\n        int[] ans = new int[length];\\n        for (int i = 0; i < length; i++) {\\n            ans[i] = sums[i];\\n        }        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812902,
                "title": "ruby",
                "content": "\\n# Code\\n```\\n# @param {Integer[][]} grid\\n# @return {Integer[]}\\ndef get_biggest_three(grid)\\n    m = grid.size\\n    n = grid[0].size\\n    l = [m,n].min\\n    i = 0\\n    ans = []\\n    while i*2+1 <= l      \\n        k = i\\n        for nn in (k...n-k)\\n            for mm in (k...m-k)\\n                temp = 0\\n                x = 1\\n                for r in (0..k*2)             \\n                    if r == 0 \\n                        temp += grid[mm-k+r][nn]                   \\n                    elsif r <= k and r >= 1\\n                        temp += grid[mm-k+r][nn-r] \\n                        temp += grid[mm-k+r][nn+r]\\n                    \\n                    elsif r > k and r < k*2\\n                        # x = 1 if x == 0\\n                        temp += grid[mm-k+r][nn-k+x] \\n                        temp += grid[mm-k+r][nn+k-x]\\n                        x += 1\\n                     \\n                    elsif r == k*2\\n                        temp += grid[mm-k+r][nn]\\n                    end \\n                end \\n                ans << temp\\n            end \\n        end \\n        i += 1     \\n    end\\n    ans.uniq.sort.reverse[0...3] \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer[]}\\ndef get_biggest_three(grid)\\n    m = grid.size\\n    n = grid[0].size\\n    l = [m,n].min\\n    i = 0\\n    ans = []\\n    while i*2+1 <= l      \\n        k = i\\n        for nn in (k...n-k)\\n            for mm in (k...m-k)\\n                temp = 0\\n                x = 1\\n                for r in (0..k*2)             \\n                    if r == 0 \\n                        temp += grid[mm-k+r][nn]                   \\n                    elsif r <= k and r >= 1\\n                        temp += grid[mm-k+r][nn-r] \\n                        temp += grid[mm-k+r][nn+r]\\n                    \\n                    elsif r > k and r < k*2\\n                        # x = 1 if x == 0\\n                        temp += grid[mm-k+r][nn-k+x] \\n                        temp += grid[mm-k+r][nn+k-x]\\n                        x += 1\\n                     \\n                    elsif r == k*2\\n                        temp += grid[mm-k+r][nn]\\n                    end \\n                end \\n                ans << temp\\n            end \\n        end \\n        i += 1     \\n    end\\n    ans.uniq.sort.reverse[0...3] \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2726709,
                "title": "python-super-easy-to-understand-calculate-all-rhombus-sums-around-cell",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        \\n        def rhombus(i, j):\\n                \\n            max_size = min(n-i-1,i,j,m-j-1)\\n            ans = [grid[i][j]]\\n            for size in range(1, max_size+1):\\n                l_x = j-size\\n                l_y = i\\n\\n                t_x = j\\n                t_y = i-size\\n\\n\\n                r_x = j+size\\n                r_y = i\\n\\n\\n                b_x = j\\n                b_y = i+size\\n                s = 0\\n\\n                x, y = l_x, l_y\\n                while x != t_x and y != t_y:\\n                    s += grid[y][x]\\n                    y -=1\\n                    x +=1\\n                    \\n                x, y = t_x, t_y\\n                while x != r_x and y != r_y:\\n                    s += grid[y][x]\\n                    y +=1\\n                    x +=1\\n                    \\n                x, y = r_x, r_y\\n                while x != b_x and y != b_y:\\n                    s += grid[y][x]\\n                    y +=1\\n                    x -=1\\n                    \\n                x, y = b_x, b_y\\n                while x != l_x and y != l_y:\\n                    s += grid[y][x]\\n                    y -=1\\n                    x -=1\\n        \\n                ans.append(s)\\n            return ans\\n                \\n                \\n        ans = []\\n        for i in range(n):\\n            for j in range(m):\\n                ans += rhombus(i, j)\\n\\n                \\n        return list(sorted(set(ans), reverse = True))[:3]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        \\n        def rhombus(i, j):\\n                \\n            max_size = min(n-i-1,i,j,m-j-1)\\n            ans = [grid[i][j]]\\n            for size in range(1, max_size+1):\\n                l_x = j-size\\n                l_y = i\\n\\n                t_x = j\\n                t_y = i-size\\n\\n\\n                r_x = j+size\\n                r_y = i\\n\\n\\n                b_x = j\\n                b_y = i+size\\n                s = 0\\n\\n                x, y = l_x, l_y\\n                while x != t_x and y != t_y:\\n                    s += grid[y][x]\\n                    y -=1\\n                    x +=1\\n                    \\n                x, y = t_x, t_y\\n                while x != r_x and y != r_y:\\n                    s += grid[y][x]\\n                    y +=1\\n                    x +=1\\n                    \\n                x, y = r_x, r_y\\n                while x != b_x and y != b_y:\\n                    s += grid[y][x]\\n                    y +=1\\n                    x -=1\\n                    \\n                x, y = b_x, b_y\\n                while x != l_x and y != l_y:\\n                    s += grid[y][x]\\n                    y -=1\\n                    x -=1\\n        \\n                ans.append(s)\\n            return ans\\n                \\n                \\n        ans = []\\n        for i in range(n):\\n            for j in range(m):\\n                ans += rhombus(i, j)\\n\\n                \\n        return list(sorted(set(ans), reverse = True))[:3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716710,
                "title": "c",
                "content": "Runtime: 124 ms, faster than 100.00% of C online submissions for Get Biggest Three Rhombus Sums in a Grid.\\nMemory Usage: 7 MB, less than 100.00% of C online submissions for Get Biggest Three Rhombus Sums in a Grid.\\n```\\nint minVal(int a, int b, int c){\\n    return fmin( fmin(a, b), c );\\n}\\n\\nint Sum(int** grid, int r, int c, int n){\\n    if(n == 0)\\n        return grid[r][c];\\n    int ans = 0;\\n    int R = r;\\n    int C = c;\\n    ans += grid[R][C];\\n    for(int i = 1; i <= n; i++){\\n        ans += grid[R+i][C-i];\\n        ans += grid[R+i][C+i];\\n    }\\n    R = r + 2 * n;\\n    C = c;\\n    ans += grid[R][C];\\n    for(int i = 1; i < n; i++){\\n        ans += grid[R-i][C-i];\\n        ans += grid[R-i][C+i];\\n    }\\n\\n    return ans;\\n}\\n\\nint* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    int* ans = calloc(3 , sizeof(int));\\n\\n    for(int i = 0;  i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            int radis = minVal(j, n- 1- j, (m -1 -i)/2);\\n            for(int k = 0; k <=radis; k++ ){\\n                int a = Sum(grid, i, j, k);\\n                if(a > ans[0]){\\n                    ans[2] = ans[1];\\n                    ans[1] = ans[0];\\n                    ans[0] = a;\\n                }\\n                else if(a != ans[0] && a > ans[1]){\\n                    ans[2] = ans[1];\\n                    ans[1] = a;  \\n                }\\n                else if(a != ans[0] && a != ans[1] && a > ans[2])\\n                    ans[2] = a;\\n            }           \\n        }\\n    }\\n\\n    if(ans[1] == 0)\\n        *returnSize = 1;\\n    else if(ans[2] == 0)\\n        *returnSize = 2;\\n    else\\n        *returnSize = 3;\\n        \\n    return ans;\\n}   \\n```",
                "solutionTags": [],
                "code": "```\\nint minVal(int a, int b, int c){\\n    return fmin( fmin(a, b), c );\\n}\\n\\nint Sum(int** grid, int r, int c, int n){\\n    if(n == 0)\\n        return grid[r][c];\\n    int ans = 0;\\n    int R = r;\\n    int C = c;\\n    ans += grid[R][C];\\n    for(int i = 1; i <= n; i++){\\n        ans += grid[R+i][C-i];\\n        ans += grid[R+i][C+i];\\n    }\\n    R = r + 2 * n;\\n    C = c;\\n    ans += grid[R][C];\\n    for(int i = 1; i < n; i++){\\n        ans += grid[R-i][C-i];\\n        ans += grid[R-i][C+i];\\n    }\\n\\n    return ans;\\n}\\n\\nint* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    int* ans = calloc(3 , sizeof(int));\\n\\n    for(int i = 0;  i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            int radis = minVal(j, n- 1- j, (m -1 -i)/2);\\n            for(int k = 0; k <=radis; k++ ){\\n                int a = Sum(grid, i, j, k);\\n                if(a > ans[0]){\\n                    ans[2] = ans[1];\\n                    ans[1] = ans[0];\\n                    ans[0] = a;\\n                }\\n                else if(a != ans[0] && a > ans[1]){\\n                    ans[2] = ans[1];\\n                    ans[1] = a;  \\n                }\\n                else if(a != ans[0] && a != ans[1] && a > ans[2])\\n                    ans[2] = a;\\n            }           \\n        }\\n    }\\n\\n    if(ans[1] == 0)\\n        *returnSize = 1;\\n    else if(ans[2] == 0)\\n        *returnSize = 2;\\n    else\\n        *returnSize = 3;\\n        \\n    return ans;\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2417723,
                "title": "brute-force-approach",
                "content": "\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        sizeY: int = len(grid)\\n        sizeX: int = len(grid[0])\\n\\n        largestVals = [0]\\n        \\n        \\n        for y in range(sizeY):\\n            for x in range(sizeX):\\n                size = 0\\n\\n                while size < min(sizeY,sizeX):\\n                    tBound = y-size\\n                    bBound = y+size\\n                    lBound = x-size\\n                    rBound = x+size\\n                    value = 0\\n                    \\n                    if (tBound < 0 or bBound >= sizeY):\\n                        size = sizeY\\n                        continue\\n                    elif (lBound < 0 or rBound >= sizeX):\\n                        size = sizeY\\n                        continue \\n                    elif (size == 0):\\n                        value = grid[y][x]\\n                    else:\\n                        currentLeftX = x\\n                        currentRightX = x\\n                        currentY = tBound\\n                        opening = True\\n                        while currentY <= bBound:\\n                            if currentLeftX == currentRightX:\\n                                value += grid[currentY][currentLeftX]\\n                            else:\\n                                value += grid[currentY][currentLeftX]\\n                                value += grid[currentY][currentRightX]\\n                                \\n                            if currentY == y:\\n                                opening = False \\n                                \\n                            if opening == True:\\n                                currentLeftX -= 1\\n                                currentRightX += 1\\n                            else:\\n                                currentLeftX += 1\\n                                currentRightX -= 1\\n\\n                            currentY +=1\\n                        #print(value)\\n                    \\n                    if not(value in largestVals):\\n                        length = len(largestVals)\\n                        if length == 1 and largestVals[0] == 0:\\n                            largestVals[0] = value\\n                        elif length == 1 or length == 2:\\n                            largestVals.append(value)\\n                            largestVals.sort()\\n                        elif value > largestVals[0]:\\n                            largestVals.pop(0)\\n                            largestVals.append(value)\\n                            largestVals.sort()\\n                    \\n                    size += 1\\n        \\n        largestVals.reverse()\\n        return largestVals",
                "solutionTags": [],
                "code": "\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        sizeY: int = len(grid)\\n        sizeX: int = len(grid[0])\\n\\n        largestVals = [0]\\n        \\n        \\n        for y in range(sizeY):\\n            for x in range(sizeX):\\n                size = 0\\n\\n                while size < min(sizeY,sizeX):\\n                    tBound = y-size\\n                    bBound = y+size\\n                    lBound = x-size\\n                    rBound = x+size\\n                    value = 0\\n                    \\n                    if (tBound < 0 or bBound >= sizeY):\\n                        size = sizeY\\n                        continue\\n                    elif (lBound < 0 or rBound >= sizeX):\\n                        size = sizeY\\n                        continue \\n                    elif (size == 0):\\n                        value = grid[y][x]\\n                    else:\\n                        currentLeftX = x\\n                        currentRightX = x\\n                        currentY = tBound\\n                        opening = True\\n                        while currentY <= bBound:\\n                            if currentLeftX == currentRightX:\\n                                value += grid[currentY][currentLeftX]\\n                            else:\\n                                value += grid[currentY][currentLeftX]\\n                                value += grid[currentY][currentRightX]\\n                                \\n                            if currentY == y:\\n                                opening = False \\n                                \\n                            if opening == True:\\n                                currentLeftX -= 1\\n                                currentRightX += 1\\n                            else:\\n                                currentLeftX += 1\\n                                currentRightX -= 1\\n\\n                            currentY +=1\\n                        #print(value)\\n                    \\n                    if not(value in largestVals):\\n                        length = len(largestVals)\\n                        if length == 1 and largestVals[0] == 0:\\n                            largestVals[0] = value\\n                        elif length == 1 or length == 2:\\n                            largestVals.append(value)\\n                            largestVals.sort()\\n                        elif value > largestVals[0]:\\n                            largestVals.pop(0)\\n                            largestVals.append(value)\\n                            largestVals.sort()\\n                    \\n                    size += 1\\n        \\n        largestVals.reverse()\\n        return largestVals",
                "codeTag": "Python3"
            },
            {
                "id": 2404705,
                "title": "java-understandable-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                int k = 1;\\n                int sum = grid[i][j]; // add top center\\n                pq.add(sum);\\n                while(j-k >= 0 && j+k < grid[0].length && i+2*k < grid.length){\\n                    sum += grid[i+k][j+k] + grid[i+k][j-k] + grid[i+2*k][j]; // add top diagonals and bottom center\\n                    for(int l=1; l<k; l++) sum += grid[i+k+l][j-k+l] + grid[i+k+l][j+k-l]; // add bottom diagonals\\n                    pq.add(sum);\\n                    sum -= grid[i+2*k][j]; // remove bottom center\\n                    for(int l=1; l<k; l++) sum -= grid[i+k+l][j-k+l] + grid[i+k+l][j+k-l]; // remove bottom diagonals\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        List<Integer> resList = new ArrayList<>();\\n        while(!pq.isEmpty()){\\n            int popped = pq.remove();\\n            if(resList.size() == 0 || resList.size() > 0 && resList.get(resList.size()-1) != popped) resList.add(popped);\\n            if(resList.size() == 3) break;\\n        }\\n        \\n        int[] res = new int[resList.size()];\\n        for(int i=0; i<resList.size(); i++){\\n            res[i] = resList.get(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                int k = 1;\\n                int sum = grid[i][j]; // add top center\\n                pq.add(sum);\\n                while(j-k >= 0 && j+k < grid[0].length && i+2*k < grid.length){\\n                    sum += grid[i+k][j+k] + grid[i+k][j-k] + grid[i+2*k][j]; // add top diagonals and bottom center\\n                    for(int l=1; l<k; l++) sum += grid[i+k+l][j-k+l] + grid[i+k+l][j+k-l]; // add bottom diagonals\\n                    pq.add(sum);\\n                    sum -= grid[i+2*k][j]; // remove bottom center\\n                    for(int l=1; l<k; l++) sum -= grid[i+k+l][j-k+l] + grid[i+k+l][j+k-l]; // remove bottom diagonals\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        List<Integer> resList = new ArrayList<>();\\n        while(!pq.isEmpty()){\\n            int popped = pq.remove();\\n            if(resList.size() == 0 || resList.size() > 0 && resList.get(resList.size()-1) != popped) resList.add(popped);\\n            if(resList.size() == 3) break;\\n        }\\n        \\n        int[] res = new int[resList.size()];\\n        for(int i=0; i<resList.size(); i++){\\n            res[i] = resList.get(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397215,
                "title": "c-python-max-heap-brute-force",
                "content": "# C++ Code\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> getBiggestThree(vector<vector<int>>& grid) {\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\n\\t\\t\\tfor(int i=0; i<m; i++){\\n\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\tfor(int k=0; i+k<m && i-k>=0 && j+2*k<n; k++){\\n\\t\\t\\t\\t\\t\\tint si=i, sj=j, ti=i-k, tj=j+k, di=i+k, dj=j+k, ri=i, rj = j+2*k;\\n\\t\\t\\t\\t\\t\\tint s1=0, s2=0, s3=0, s4=0;\\n\\t\\t\\t\\t\\t\\tfor(int l=0;l<k;l++){\\n\\t\\t\\t\\t\\t\\t\\ts1 += grid[si-l][sj+l];                        \\n\\t\\t\\t\\t\\t\\t\\ts2 += grid[ti+l][tj+l];\\n\\t\\t\\t\\t\\t\\t\\ts3 += grid[ri+l][rj-l];\\n\\t\\t\\t\\t\\t\\t\\ts4 += grid[di-l][dj-l];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint s = s1+s2+s3+s4;\\n\\t\\t\\t\\t\\t\\tpq.push(max(s,grid[i][j]));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\twhile(!pq.empty() && ans.size()<3){\\n\\t\\t\\t\\tif(!ans.empty() && pq.top() == ans.back()){\\n\\t\\t\\t\\t\\tpq.pop();                \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tans.push_back(pq.top());\\n\\t\\t\\t\\t\\tpq.pop();   \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n# Python Code\\n\\n\\tclass Solution:\\n\\t\\tdef getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n\\t\\t\\tm, n = len(grid), len(grid[0])\\n\\t\\t\\tpq = []\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\t\\twhile i+k<m and i-k>=0 and j+2*k<n:\\n\\t\\t\\t\\t\\t\\tsi,sj,ti,tj,di,dj,ri,rj = i,j,i-k,j+k,i+k,j+k,i,j+2*k\\n\\t\\t\\t\\t\\t\\ts1,s2,s3,s4 = 0,0,0,0\\n\\t\\t\\t\\t\\t\\tfor l in range(k):\\n\\t\\t\\t\\t\\t\\t\\ts1 += grid[si-l][sj+l]                        \\n\\t\\t\\t\\t\\t\\t\\ts2 += grid[ti+l][tj+l]\\n\\t\\t\\t\\t\\t\\t\\ts3 += grid[ri+l][rj-l]\\n\\t\\t\\t\\t\\t\\t\\ts4 += grid[di-l][dj-l]\\n\\n\\t\\t\\t\\t\\t\\ts = s1 + s2 + s3 + s4\\n\\t\\t\\t\\t\\t\\theappush(pq, min(-grid[i][j], -s))\\n\\t\\t\\t\\t\\t\\tk+=1\\n\\n\\t\\t\\tans = []\\n\\t\\t\\t# print(pq)\\n\\t\\t\\twhile pq and len(ans) < 3:\\n\\t\\t\\t\\tif ans and ans[-1] == -pq[0]: heappop(pq)\\n\\t\\t\\t\\telse: ans.append(-heappop(pq))\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> getBiggestThree(vector<vector<int>>& grid) {\\n\\t\\t\\tpriority_queue<int> pq;\\n\\t\\t\\tint m = grid.size(), n = grid[0].size();\\n\\n\\t\\t\\tfor(int i=0; i<m; i++){\\n\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\tfor(int k=0; i+k<m && i-k>=0 && j+2*k<n; k++){\\n\\t\\t\\t\\t\\t\\tint si=i, sj=j, ti=i-k, tj=j+k, di=i+k, dj=j+k, ri=i, rj = j+2*k;\\n\\t\\t\\t\\t\\t\\tint s1=0, s2=0, s3=0, s4=0;\\n\\t\\t\\t\\t\\t\\tfor(int l=0;l<k;l++){\\n\\t\\t\\t\\t\\t\\t\\ts1 += grid[si-l][sj+l];                        \\n\\t\\t\\t\\t\\t\\t\\ts2 += grid[ti+l][tj+l];\\n\\t\\t\\t\\t\\t\\t\\ts3 += grid[ri+l][rj-l];\\n\\t\\t\\t\\t\\t\\t\\ts4 += grid[di-l][dj-l];\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2382789,
                "title": "python-my-soln",
                "content": "class Solution:\\n\\n    def getBiggestThree(self, grid):\\n        def calc(l, r, i, d):\\n            sum_ = 0\\n            c1 = c2 = (l + r) // 2 \\n            expand = True\\n            for row in range(i, d + 1):\\n                \\n                if c1 == c2:\\n                    sum_ += grid[row][c1]\\n                    \\n                else:\\n                    sum_ += grid[row][c1] + grid[row][c2]\\n                    \\n                    \\n                if c1 == l:\\n                    expand = False\\n                    \\n                if expand:\\n                    c1 -= 1\\n                    c2 += 1\\n                    \\n                else:\\n                    c1 += 1\\n                    c2 -= 1\\n                    \\n            return sum_\\n            \\n            \\n            \\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        pq = []\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                l = r = j\\n                d = i\\n                while l >= 0 and r <= n - 1 and d <= m - 1:\\n                    sum_ = calc(l, r, i, d)\\n                    l -= 1\\n                    r += 1\\n                    d += 2\\n                    \\n                    if len(pq) < 3:\\n                        if sum_ not in pq:\\n                            heapq.heappush(pq, sum_)\\n                    \\n                    else: \\n                        if sum_ not in pq and sum_ > pq[0]:\\n                            heapq.heappop(pq)\\n                            heapq.heappush(pq, sum_)\\n                            \\n        pq.sort(reverse=True)                   \\n        return pq\\n                            \\n                        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def getBiggestThree(self, grid):\\n        def calc(l, r, i, d):\\n            sum_ = 0\\n            c1 = c2 = (l + r) // 2 \\n            expand = True\\n            for row in range(i, d + 1):\\n                \\n                if c1 == c2:\\n                    sum_ += grid[row][c1]\\n                    \\n                else:\\n                    sum_ += grid[row][c1] + grid[row][c2]\\n                    \\n                    \\n                if c1 == l:\\n                    expand = False\\n                    \\n                if expand:\\n                    c1 -= 1\\n                    c2 += 1\\n                    \\n                else:\\n                    c1 += 1\\n                    c2 -= 1\\n                    \\n            return sum_\\n            \\n            \\n            \\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        pq = []\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                l = r = j\\n                d = i\\n                while l >= 0 and r <= n - 1 and d <= m - 1:\\n                    sum_ = calc(l, r, i, d)\\n                    l -= 1\\n                    r += 1\\n                    d += 2\\n                    \\n                    if len(pq) < 3:\\n                        if sum_ not in pq:\\n                            heapq.heappush(pq, sum_)\\n                    \\n                    else: \\n                        if sum_ not in pq and sum_ > pq[0]:\\n                            heapq.heappop(pq)\\n                            heapq.heappush(pq, sum_)\\n                            \\n        pq.sort(reverse=True)                   \\n        return pq\\n                            \\n                        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2371261,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N X M + number of squares)\\n */\\n// Runtime: 431 ms, faster than 31.25% of JavaScript online submissions for Get Biggest Three Rhombus Sums in a Grid.\\n// Memory Usage: 50.9 MB, less than 18.75% of JavaScript online submissions for Get Biggest Three Rhombus Sums in a Grid.\\nconst getBiggestThree = grid => {\\n\\tconst set = new Set();\\n\\n\\tconst N = grid.length;\\n\\tconst M = grid[0].length;\\n\\n\\tconst length = Math.floor(N / 2);\\n\\tconst width = Math.floor(M / 2);\\n\\n\\tlet square = Math.min(length, width); // max possile size of square\\n\\n\\t// decrement size of square to find max sum\\n\\twhile (square > 0) {\\n\\t\\tfor (let i = 0; i < grid.length - square * 2; i++) {\\n\\t\\t\\tfor (let j = square; j < grid[0].length - square; j++) {\\n\\t\\t\\t\\tlet sum = 0;\\n\\t\\t\\t\\tlet z = 0;\\n\\n\\t\\t\\t\\t// find sum of area\\n\\t\\t\\t\\twhile (z < square) {\\n\\t\\t\\t\\t\\tconst top = grid[i + z][j + z]; \\n\\t\\t\\t\\t\\tconst right = grid[i + square + z][j + square - z];\\n\\t\\t\\t\\t\\tconst bot = grid[i + square + square - z][j - z];\\n\\t\\t\\t\\t\\tconst left = grid[i + square - z][j - square + z];\\n\\n\\t\\t\\t\\t\\tsum += top + right + bot + left;\\n\\t\\t\\t\\t\\tz++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tset.add(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsquare--;\\n\\t}\\n\\n\\t// add square with area of 0\\n\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\tfor (let j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tset.add(grid[i][j]);\\n\\t\\t}\\n\\t}\\n\\n\\t// covert set to array, sort descending and return top 3 max values\\n\\tconst output = Array.from(set)\\n\\t\\t.sort((a, b) => b - a)\\n\\t\\t.slice(0, 3);\\n\\n\\treturn output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N X M + number of squares)\\n */\\n// Runtime: 431 ms, faster than 31.25% of JavaScript online submissions for Get Biggest Three Rhombus Sums in a Grid.\\n// Memory Usage: 50.9 MB, less than 18.75% of JavaScript online submissions for Get Biggest Three Rhombus Sums in a Grid.\\nconst getBiggestThree = grid => {\\n\\tconst set = new Set();\\n\\n\\tconst N = grid.length;\\n\\tconst M = grid[0].length;\\n\\n\\tconst length = Math.floor(N / 2);\\n\\tconst width = Math.floor(M / 2);\\n\\n\\tlet square = Math.min(length, width); // max possile size of square\\n\\n\\t// decrement size of square to find max sum\\n\\twhile (square > 0) {\\n\\t\\tfor (let i = 0; i < grid.length - square * 2; i++) {\\n\\t\\t\\tfor (let j = square; j < grid[0].length - square; j++) {\\n\\t\\t\\t\\tlet sum = 0;\\n\\t\\t\\t\\tlet z = 0;\\n\\n\\t\\t\\t\\t// find sum of area\\n\\t\\t\\t\\twhile (z < square) {\\n\\t\\t\\t\\t\\tconst top = grid[i + z][j + z]; \\n\\t\\t\\t\\t\\tconst right = grid[i + square + z][j + square - z];\\n\\t\\t\\t\\t\\tconst bot = grid[i + square + square - z][j - z];\\n\\t\\t\\t\\t\\tconst left = grid[i + square - z][j - square + z];\\n\\n\\t\\t\\t\\t\\tsum += top + right + bot + left;\\n\\t\\t\\t\\t\\tz++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tset.add(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsquare--;\\n\\t}\\n\\n\\t// add square with area of 0\\n\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\tfor (let j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tset.add(grid[i][j]);\\n\\t\\t}\\n\\t}\\n\\n\\t// covert set to array, sort descending and return top 3 max values\\n\\tconst output = Array.from(set)\\n\\t\\t.sort((a, b) => b - a)\\n\\t\\t.slice(0, 3);\\n\\n\\treturn output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362396,
                "title": "hint-1-is-very-helpful",
                "content": "Hint 1 is very helpful",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2278102,
                "title": "94-100-python-solution",
                "content": "```class Solution(object):\\n    def getBiggestThree(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = set()\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                res.add(grid[r][c])\\n                \\n                res = list(res)\\n                res.sort(reverse = True)\\n                if len(res) > 3:\\n                    res.pop()    \\n                res = set(res)\\n                \\n                cur = r+1\\n                bottom, left, right = r+2, c-1, c+1\\n                topSum = grid[r][c]\\n                while bottom < rows and -1 < left and right < cols:\\n                    topSum += grid[cur][left] + grid[cur][right]\\n                    botSum = 0\\n                    for i in range(1, bottom - cur + 1):\\n                        botSum += grid[cur+i][left+i]\\n                    for i in range(1, bottom - cur):\\n                        botSum += grid[cur+i][right-i]\\n                        \\n                    res.add(topSum+botSum)\\n                    res = list(res)\\n                    res.sort(reverse = True)\\n                    if len(res) > 3:    \\n                        res.pop()\\n                    res = set(res)\\n         \\n                    bottom += 2\\n                    left -= 1\\n                    right += 1\\n                    cur += 1\\n                    \\n        res = list(res)\\n        res.sort(reverse = True)\\n        return res```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def getBiggestThree(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = set()\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                res.add(grid[r][c])\\n                \\n                res = list(res)\\n                res.sort(reverse = True)\\n                if len(res) > 3:\\n                    res.pop()    \\n                res = set(res)\\n                \\n                cur = r+1\\n                bottom, left, right = r+2, c-1, c+1\\n                topSum = grid[r][c]\\n                while bottom < rows and -1 < left and right < cols:\\n                    topSum += grid[cur][left] + grid[cur][right]\\n                    botSum = 0\\n                    for i in range(1, bottom - cur + 1):\\n                        botSum += grid[cur+i][left+i]\\n                    for i in range(1, bottom - cur):\\n                        botSum += grid[cur+i][right-i]\\n                        \\n                    res.add(topSum+botSum)\\n                    res = list(res)\\n                    res.sort(reverse = True)\\n                    if len(res) > 3:    \\n                        res.pop()\\n                    res = set(res)\\n         \\n                    bottom += 2\\n                    left -= 1\\n                    right += 1\\n                    cur += 1\\n                    \\n        res = list(res)\\n        res.sort(reverse = True)\\n        return res```",
                "codeTag": "Java"
            },
            {
                "id": 2187914,
                "title": "java-brute-force-95",
                "content": "Brute force with Integer[] to maintain the distinct max values.\\n\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        Integer[] arr = new Integer[3];\\n        int ext = Math.min(m, n) / 2;\\n            \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t// add the single point\\n                addDistinct(arr, grid[i][j]);\\n                for(int k = 1; k <= ext; k++) {\\n                    int top = i - k, bottom = i + k, left = j - k, right = j + k;\\n                    if(top < 0 || bottom >= m || left < 0 || right >= n) break;\\n                    \\n\\t\\t\\t\\t\\t// get the sum of the four sides\\n                    int sum = 0;\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[top + l][j - l];\\n                    }\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[i + l][left + l];\\n                    }\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[bottom - l][j + l];\\n                    }\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[i - l][right - l];\\n                    }\\n                    addDistinct(arr, sum);\\n                }\\n            }\\n        }\\n        \\n        int size = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] == null) break;\\n            size++;\\n        }\\n        \\n        int[] res = new int[size];\\n        for(int i = 0; i < size; i++) {\\n            res[i] = arr[i];\\n        }\\n        return res;\\n    }\\n    \\n\\t// only maintain the three distinct max values\\n    private void addDistinct(Integer[] arr, int val) {\\n        if(arr[0] != null && arr[0] == val || arr[1] != null && arr[1] == val || arr[2] != null && arr[2] == val) return;\\n        \\n        if(arr[0] == null || val > arr[0]) {\\n            arr[2] = arr[1];\\n            arr[1] = arr[0];\\n            arr[0] = val;\\n        } else if(arr[1] == null || val > arr[1]) {\\n            arr[2] = arr[1];\\n            arr[1] = val;\\n        } else if(arr[2] == null || val > arr[2]) {\\n            arr[2] = val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        Integer[] arr = new Integer[3];\\n        int ext = Math.min(m, n) / 2;\\n            \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t// add the single point\\n                addDistinct(arr, grid[i][j]);\\n                for(int k = 1; k <= ext; k++) {\\n                    int top = i - k, bottom = i + k, left = j - k, right = j + k;\\n                    if(top < 0 || bottom >= m || left < 0 || right >= n) break;\\n                    \\n\\t\\t\\t\\t\\t// get the sum of the four sides\\n                    int sum = 0;\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[top + l][j - l];\\n                    }\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[i + l][left + l];\\n                    }\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[bottom - l][j + l];\\n                    }\\n                    for(int l = 0; l < k; l++) {\\n                        sum += grid[i - l][right - l];\\n                    }\\n                    addDistinct(arr, sum);\\n                }\\n            }\\n        }\\n        \\n        int size = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] == null) break;\\n            size++;\\n        }\\n        \\n        int[] res = new int[size];\\n        for(int i = 0; i < size; i++) {\\n            res[i] = arr[i];\\n        }\\n        return res;\\n    }\\n    \\n\\t// only maintain the three distinct max values\\n    private void addDistinct(Integer[] arr, int val) {\\n        if(arr[0] != null && arr[0] == val || arr[1] != null && arr[1] == val || arr[2] != null && arr[2] == val) return;\\n        \\n        if(arr[0] == null || val > arr[0]) {\\n            arr[2] = arr[1];\\n            arr[1] = arr[0];\\n            arr[0] = val;\\n        } else if(arr[1] == null || val > arr[1]) {\\n            arr[2] = arr[1];\\n            arr[1] = val;\\n        } else if(arr[2] == null || val > arr[2]) {\\n            arr[2] = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144572,
                "title": "java-brute-force-70-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxLen = grid.length / 2;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {                \\n                if(!visited.contains(grid[i][j])){\\n                    visited.add(grid[i][j]);\\n                    pq.add(grid[i][j]);\\n                }\\n                if (pq.size() > 3) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < m - 2; i++){\\n            for(int j = 1; j < n - 1; j++){                \\n                int colSize = Math.min(j-0,n-j-1);\\n                int rowSize = 0;\\n                if((m-i) % 2 == 0){\\n                    rowSize = (m-i)/2 - 1;\\n                }\\n                else{\\n                    rowSize = (m -1- i)/2;\\n                }\\n                \\n                int maxSize = Math.min(colSize,rowSize);\\n                for(int size = 1; size <= maxSize; size++){\\n                    int sum = 0;\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        j--;\\n                        i++;                   \\n                    }\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        i++;\\n                        j++;                    \\n                    }\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        j++;\\n                        i--;                    \\n                    }\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        i--;\\n                        j--;                    \\n                    }\\n                    if(!visited.contains(sum)){\\n                        visited.add(sum);\\n                        pq.add(sum);\\n                    }               \\n                    if (pq.size() > 3) {\\n                        pq.poll();\\n                    }\\n                }\\n                \\n            }        \\n        }\\n        int[] res = new int[pq.size()];\\n        int a = pq.size()-1;\\n        while(!pq.isEmpty()){\\n            res[a] = pq.poll();\\n            a--;\\n        }\\n        return res;          \\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxLen = grid.length / 2;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {                \\n                if(!visited.contains(grid[i][j])){\\n                    visited.add(grid[i][j]);\\n                    pq.add(grid[i][j]);\\n                }\\n                if (pq.size() > 3) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < m - 2; i++){\\n            for(int j = 1; j < n - 1; j++){                \\n                int colSize = Math.min(j-0,n-j-1);\\n                int rowSize = 0;\\n                if((m-i) % 2 == 0){\\n                    rowSize = (m-i)/2 - 1;\\n                }\\n                else{\\n                    rowSize = (m -1- i)/2;\\n                }\\n                \\n                int maxSize = Math.min(colSize,rowSize);\\n                for(int size = 1; size <= maxSize; size++){\\n                    int sum = 0;\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        j--;\\n                        i++;                   \\n                    }\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        i++;\\n                        j++;                    \\n                    }\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        j++;\\n                        i--;                    \\n                    }\\n                    for(int cn = 0; cn<size; cn++) {\\n                        sum+=grid[i][j];\\n                        i--;\\n                        j--;                    \\n                    }\\n                    if(!visited.contains(sum)){\\n                        visited.add(sum);\\n                        pq.add(sum);\\n                    }               \\n                    if (pq.size() > 3) {\\n                        pq.poll();\\n                    }\\n                }\\n                \\n            }        \\n        }\\n        int[] res = new int[pq.size()];\\n        int a = pq.size()-1;\\n        while(!pq.isEmpty()){\\n            res[a] = pq.poll();\\n            a--;\\n        }\\n        return res;          \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091678,
                "title": "simply-traverse-it-75",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int>pq;\\n        for(int i =0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                for(int k =0;i+k<grid.size() && j+2*k<grid[i].size() && i-k>=0; k++){\\n                    int si = i,sj =j,ti = i-k, tj = j+k, ri = i, rj = j + 2*k, di = i+k, dj = j+k;\\n                    int sum0 = 0,sum1 = 0,sum2 =0 ,sum3 =0;\\n                    for(int l = 0;l<k;l++){\\n                       sum0+= grid[si-l][sj+l];\\n                       sum1+= grid[ti+l][tj+l];\\n                       sum2+= grid[ri+l][rj-l];\\n                       sum3+= grid[di-l][dj-l];\\n                    }\\n                    int sum = sum0+sum1+sum2+sum3;\\n                    pq.push(max(sum,grid[i][j]));\\n                }\\n            }\\n        }\\n        vector<int>v;\\n        while(pq.size()>0 && v.size()<3){\\n            if(v.size()>0 && pq.top() == v[v.size()-1]){\\n                pq.pop();                \\n            } else {\\n                v.push_back(pq.top());\\n                pq.pop();   \\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int>pq;\\n        for(int i =0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                for(int k =0;i+k<grid.size() && j+2*k<grid[i].size() && i-k>=0; k++){\\n                    int si = i,sj =j,ti = i-k, tj = j+k, ri = i, rj = j + 2*k, di = i+k, dj = j+k;\\n                    int sum0 = 0,sum1 = 0,sum2 =0 ,sum3 =0;\\n                    for(int l = 0;l<k;l++){\\n                       sum0+= grid[si-l][sj+l];\\n                       sum1+= grid[ti+l][tj+l];\\n                       sum2+= grid[ri+l][rj-l];\\n                       sum3+= grid[di-l][dj-l];\\n                    }\\n                    int sum = sum0+sum1+sum2+sum3;\\n                    pq.push(max(sum,grid[i][j]));\\n                }\\n            }\\n        }\\n        vector<int>v;\\n        while(pq.size()>0 && v.size()<3){\\n            if(v.size()>0 && pq.top() == v[v.size()-1]){\\n                pq.pop();                \\n            } else {\\n                v.push_back(pq.top());\\n                pq.pop();   \\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080217,
                "title": "concise-python-solution-without-heap-o-min-m-n-m-n-time-and-o-2-m-n-space-complexity",
                "content": "```\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        prefix = [[(0, 0) for _ in range(n+2)] for _ in range(m+1)]\\n        for i, j in product(range(m), range(n)):\\n            prefix[i+1][j+1] = [grid[i][j] + prefix[i][j][0], grid[i][j] + prefix[i][j+2][1]]\\n            \\n        p1, p2, p3 = 0, 0, 0\\n        for r in range(min(m,n)//2 + 1):\\n            for i, j in product(range(r, m - r), range(r, n - r)):\\n                if r == 0:\\n                    p = grid[i][j]\\n                else:\\n                    lt = prefix[i+1][j-r+1][1] - prefix[i-r+1][j+1][1]\\n                    rt = prefix[i+1][j+r+1][0] - prefix[i-r][j][0]\\n                    br = prefix[i+r+1][j+1][1] - prefix[i+1][j+r+1][1]\\n                    bl = prefix[i+r][j][0] - prefix[i+1][j-r+1][0]\\n                    p = lt + rt + br + bl\\n                    \\n                if p > p1 and p not in {p1, p2, p3}:\\n                    if p > p3:\\n                        p1, p2, p3 = p2, p3, p\\n                    elif p > p2:\\n                        p1, p2 = p2, p\\n                    else:\\n                        p1 = p\\n                        \\n        return [p for p in [p3, p2, p1] if p > 0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        m, n = len(grid), len(grid[0])\\n        prefix = [[(0, 0) for _ in range(n+2)] for _ in range(m+1)]\\n        for i, j in product(range(m), range(n)):\\n            prefix[i+1][j+1] = [grid[i][j] + prefix[i][j][0], grid[i][j] + prefix[i][j+2][1]]\\n            \\n        p1, p2, p3 = 0, 0, 0\\n        for r in range(min(m,n)//2 + 1):\\n            for i, j in product(range(r, m - r), range(r, n - r)):\\n                if r == 0:\\n                    p = grid[i][j]\\n                else:\\n                    lt = prefix[i+1][j-r+1][1] - prefix[i-r+1][j+1][1]\\n                    rt = prefix[i+1][j+r+1][0] - prefix[i-r][j][0]\\n                    br = prefix[i+r+1][j+1][1] - prefix[i+1][j+r+1][1]\\n                    bl = prefix[i+r][j][0] - prefix[i+1][j-r+1][0]\\n                    p = lt + rt + br + bl\\n                    \\n                if p > p1 and p not in {p1, p2, p3}:\\n                    if p > p3:\\n                        p1, p2, p3 = p2, p3, p\\n                    elif p > p2:\\n                        p1, p2 = p2, p\\n                    else:\\n                        p1 = p\\n                        \\n        return [p for p in [p3, p2, p1] if p > 0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2059608,
                "title": "71-74-python-prefix-sum",
                "content": "Using prefix sum to accelerate calculating diameter. \\n```python\\nfrom typing import List\\nfrom heapq import heappush, heappop\\n\\n\\ndef printMatrix(matrix):\\n    for row in matrix:\\n        print(row)\\n\\n\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        N = len(grid)\\n        M = len(grid[0])\\n        heap_ = []\\n        diagPrefix = [[0] * M for _ in range(N)]\\n        rDiagPrefix = [[0] * M for _ in range(N)]\\n        for h in range(M - 1, -1, -1):\\n            curPos = (0, h)\\n            diagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] + 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] + 1\\n                diagPrefix[curPos[0]][curPos[1]] = diagPrefix[curPos[0] - 1][curPos[1] - 1] + grid[curPos[0]][curPos[1]]\\n        for v in range(1, N):\\n            curPos = (v, 0)\\n            diagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] + 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] + 1\\n                diagPrefix[curPos[0]][curPos[1]] = diagPrefix[curPos[0] - 1][curPos[1] - 1] + grid[curPos[0]][curPos[1]]\\n        for h in range(M):\\n            curPos = (0, h)\\n            rDiagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] - 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] - 1\\n                rDiagPrefix[curPos[0]][curPos[1]] = rDiagPrefix[curPos[0] - 1][curPos[1] + 1] + grid[curPos[0]][\\n                    curPos[1]]\\n        for h in range(1, N):\\n            curPos = (h, M - 1)\\n            rDiagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] - 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] - 1\\n                rDiagPrefix[curPos[0]][curPos[1]] = rDiagPrefix[curPos[0] - 1][curPos[1] + 1] + grid[curPos[0]][\\n                    curPos[1]]\\n        for i in range(N):\\n            for j in range(M):\\n                maxLength = min(i + 1, j + 1, N - i, M - j)\\n                for length in range(maxLength, 0, -1):\\n                    if length == 1:\\n                        D = grid[i][j]\\n                        # print(D)\\n                        heappush(heap_, (-D, D))\\n                        continue\\n                    left = (i, j - length + 1)\\n                    right = (i, j + length - 1)\\n                    top = (i - length + 1, j)\\n                    bot = (i + length - 1, j)\\n                    if 0 <= right[0] - 1 < N and 0 <= right[1] + 1 < M:\\n                        botRightLine = rDiagPrefix[bot[0]][bot[1]] - rDiagPrefix[right[0] - 1][right[1] + 1]\\n                    else:\\n                        botRightLine = rDiagPrefix[bot[0]][bot[1]]\\n\\n                    if 0 <= top[0] - 1 < N and 0 <= top[1] + 1 < M:\\n                        topLeftLine = rDiagPrefix[left[0]][left[1]] - rDiagPrefix[top[0] - 1][top[1] + 1]\\n                    else:\\n                        topLeftLine = rDiagPrefix[left[0]][left[1]]\\n\\n                    if 0 <= left[0] - 1 < N and 0 <= left[1] - 1 < M:\\n                        leftBotLine = diagPrefix[bot[0]][bot[1]] - diagPrefix[left[0] - 1][left[1] - 1]\\n                    else:\\n                        leftBotLine = diagPrefix[bot[0]][bot[1]]\\n                    if 0 <= top[0] - 1 < N and 0 <= top[1] - 1 < M:\\n                        topRightLine = diagPrefix[right[0]][right[1]] - diagPrefix[top[0] - 1][top[1] - 1]\\n                    else:\\n                        topRightLine = diagPrefix[right[0]][right[1]]\\n                    D = topLeftLine + topRightLine + botRightLine + leftBotLine - grid[left[0]][left[1]] - grid[top[0]][\\n                        top[1]] - grid[bot[0]][bot[1]] - grid[right[0]][right[1]]\\n                    heappush(heap_, (-D, D))\\n        res = []\\n        for i in range(3):\\n            while res and heap_ and heap_[0][1] == res[-1]:\\n                heappop(heap_)\\n            if not heap_:\\n                break\\n            res.append(heappop(heap_)[1])\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom typing import List\\nfrom heapq import heappush, heappop\\n\\n\\ndef printMatrix(matrix):\\n    for row in matrix:\\n        print(row)\\n\\n\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        N = len(grid)\\n        M = len(grid[0])\\n        heap_ = []\\n        diagPrefix = [[0] * M for _ in range(N)]\\n        rDiagPrefix = [[0] * M for _ in range(N)]\\n        for h in range(M - 1, -1, -1):\\n            curPos = (0, h)\\n            diagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] + 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] + 1\\n                diagPrefix[curPos[0]][curPos[1]] = diagPrefix[curPos[0] - 1][curPos[1] - 1] + grid[curPos[0]][curPos[1]]\\n        for v in range(1, N):\\n            curPos = (v, 0)\\n            diagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] + 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] + 1\\n                diagPrefix[curPos[0]][curPos[1]] = diagPrefix[curPos[0] - 1][curPos[1] - 1] + grid[curPos[0]][curPos[1]]\\n        for h in range(M):\\n            curPos = (0, h)\\n            rDiagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] - 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] - 1\\n                rDiagPrefix[curPos[0]][curPos[1]] = rDiagPrefix[curPos[0] - 1][curPos[1] + 1] + grid[curPos[0]][\\n                    curPos[1]]\\n        for h in range(1, N):\\n            curPos = (h, M - 1)\\n            rDiagPrefix[curPos[0]][curPos[1]] = grid[curPos[0]][curPos[1]]\\n            while 0 <= curPos[0] + 1 < N and 0 <= curPos[1] - 1 < M:\\n                curPos = curPos[0] + 1, curPos[1] - 1\\n                rDiagPrefix[curPos[0]][curPos[1]] = rDiagPrefix[curPos[0] - 1][curPos[1] + 1] + grid[curPos[0]][\\n                    curPos[1]]\\n        for i in range(N):\\n            for j in range(M):\\n                maxLength = min(i + 1, j + 1, N - i, M - j)\\n                for length in range(maxLength, 0, -1):\\n                    if length == 1:\\n                        D = grid[i][j]\\n                        # print(D)\\n                        heappush(heap_, (-D, D))\\n                        continue\\n                    left = (i, j - length + 1)\\n                    right = (i, j + length - 1)\\n                    top = (i - length + 1, j)\\n                    bot = (i + length - 1, j)\\n                    if 0 <= right[0] - 1 < N and 0 <= right[1] + 1 < M:\\n                        botRightLine = rDiagPrefix[bot[0]][bot[1]] - rDiagPrefix[right[0] - 1][right[1] + 1]\\n                    else:\\n                        botRightLine = rDiagPrefix[bot[0]][bot[1]]\\n\\n                    if 0 <= top[0] - 1 < N and 0 <= top[1] + 1 < M:\\n                        topLeftLine = rDiagPrefix[left[0]][left[1]] - rDiagPrefix[top[0] - 1][top[1] + 1]\\n                    else:\\n                        topLeftLine = rDiagPrefix[left[0]][left[1]]\\n\\n                    if 0 <= left[0] - 1 < N and 0 <= left[1] - 1 < M:\\n                        leftBotLine = diagPrefix[bot[0]][bot[1]] - diagPrefix[left[0] - 1][left[1] - 1]\\n                    else:\\n                        leftBotLine = diagPrefix[bot[0]][bot[1]]\\n                    if 0 <= top[0] - 1 < N and 0 <= top[1] - 1 < M:\\n                        topRightLine = diagPrefix[right[0]][right[1]] - diagPrefix[top[0] - 1][top[1] - 1]\\n                    else:\\n                        topRightLine = diagPrefix[right[0]][right[1]]\\n                    D = topLeftLine + topRightLine + botRightLine + leftBotLine - grid[left[0]][left[1]] - grid[top[0]][\\n                        top[1]] - grid[bot[0]][bot[1]] - grid[right[0]][right[1]]\\n                    heappush(heap_, (-D, D))\\n        res = []\\n        for i in range(3):\\n            while res and heap_ and heap_[0][1] == res[-1]:\\n                heappop(heap_)\\n            if not heap_:\\n                break\\n            res.append(heappop(heap_)[1])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024125,
                "title": "java-ugly-but-beat-90-presum",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] d = new int[m+1][n+1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int ii = i - 1;\\n                int jj = j + 1;\\n                d[i][j] = grid[i-1][j];\\n                if (ii < 1 || jj < 0 || ii > m || jj >= n) {\\n                    continue;\\n                }\\n                d[i][j] += d[ii][jj];\\n            }\\n        }\\n        \\n        int[][] d1 = new int[m+1][n+1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int ii = i - 1;\\n                int jj = j - 1;\\n                d1[i][j] = grid[i-1][j-1];\\n                if (ii < 1 || jj < 1 || ii >= m || jj >= n) {\\n                    continue;\\n                }\\n                d1[i][j] += d1[ii][jj];\\n            }\\n        }\\n        \\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        Set<Long> set = new HashSet<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int k = 0;\\n                while (true) {\\n                    int ti = i - k;\\n                    int lj = j - k;\\n                    int rj = j + k;\\n                    int bi = i + k;\\n                    if (ti < 0 || bi >= m || lj < 0 || rj >= n) \\n                    {\\n                        k++;\\n                        break;\\n                    }\\n                    int tj = j;\\n                    int bj = j;\\n                    int li = i;\\n                    int ri = i;\\n                    long sum = k == 0 \\n                        ? grid[i][j]\\n                        : d[li+1][lj] - d[ti][tj+1] + d[bi+1][bj] - d[ri][rj+1]\\n                        + d1[ri+1][rj+1] - d1[ti][tj] + d1[bi+1][bj+1] - d1[li][lj]\\n                        - grid[ti][tj] - grid[li][lj] - grid[bi][bj] - grid[ri][rj];\\n                    if (pq.size() < 3) {\\n                        if (!set.contains(sum)) {\\n                            pq.offer(sum);\\n                            set.add(sum);\\n                        }\\n                    }\\n                    else if (pq.peek() < sum) {\\n                        if (!set.contains(sum)) {\\n                            set.remove(pq.poll());\\n                            pq.offer(sum);\\n                            set.add(sum);\\n                        }\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return Set\\n            .copyOf(pq)\\n            .stream()\\n            .map(i->(int)(long)i)\\n            .sorted(Collections.reverseOrder())\\n            .mapToInt(i -> i)\\n            .toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] d = new int[m+1][n+1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int ii = i - 1;\\n                int jj = j + 1;\\n                d[i][j] = grid[i-1][j];\\n                if (ii < 1 || jj < 0 || ii > m || jj >= n) {\\n                    continue;\\n                }\\n                d[i][j] += d[ii][jj];\\n            }\\n        }\\n        \\n        int[][] d1 = new int[m+1][n+1];\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int ii = i - 1;\\n                int jj = j - 1;\\n                d1[i][j] = grid[i-1][j-1];\\n                if (ii < 1 || jj < 1 || ii >= m || jj >= n) {\\n                    continue;\\n                }\\n                d1[i][j] += d1[ii][jj];\\n            }\\n        }\\n        \\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        Set<Long> set = new HashSet<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int k = 0;\\n                while (true) {\\n                    int ti = i - k;\\n                    int lj = j - k;\\n                    int rj = j + k;\\n                    int bi = i + k;\\n                    if (ti < 0 || bi >= m || lj < 0 || rj >= n) \\n                    {\\n                        k++;\\n                        break;\\n                    }\\n                    int tj = j;\\n                    int bj = j;\\n                    int li = i;\\n                    int ri = i;\\n                    long sum = k == 0 \\n                        ? grid[i][j]\\n                        : d[li+1][lj] - d[ti][tj+1] + d[bi+1][bj] - d[ri][rj+1]\\n                        + d1[ri+1][rj+1] - d1[ti][tj] + d1[bi+1][bj+1] - d1[li][lj]\\n                        - grid[ti][tj] - grid[li][lj] - grid[bi][bj] - grid[ri][rj];\\n                    if (pq.size() < 3) {\\n                        if (!set.contains(sum)) {\\n                            pq.offer(sum);\\n                            set.add(sum);\\n                        }\\n                    }\\n                    else if (pq.peek() < sum) {\\n                        if (!set.contains(sum)) {\\n                            set.remove(pq.poll());\\n                            pq.offer(sum);\\n                            set.add(sum);\\n                        }\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return Set\\n            .copyOf(pq)\\n            .stream()\\n            .map(i->(int)(long)i)\\n            .sorted(Collections.reverseOrder())\\n            .mapToInt(i -> i)\\n            .toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004665,
                "title": "python-faster-than-100",
                "content": "\\n#758 ms - faster than 100% \\n```\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        negSums, posSums = [], []    # negative slope,  positive slope\\n        sums = set()\\n        \\n        for r in range(0, len(grid)):\\n            negSums.append(grid[r][:])\\n            posSums.append(grid[r][:])\\n            \\n            for c in range(0, len(negSums[0])):\\n                sums.add(grid[r][c])\\n                \\n                if 0 < r:\\n                    if 0 < c:\\n                        negSums[r][c]+= negSums[r-1][c-1]\\n                    if c < len(negSums[0])-1:\\n                        posSums[r][c] += posSums[r-1][c+1]\\n                \\n        def getSum(r,c,delta):\\n            sum = negSums[r][c+delta] if r-delta == 0 else (negSums[r][c+delta] - negSums[r-delta-1][c-1])   #top right side\\n            sum+= negSums[r+delta][c] if c-delta == 0 else (negSums[r+delta][c] - negSums[r-1][c-delta-1])   #bottom left side\\n            \\n            if delta > 1:\\n                sum+= posSums[r-1][c-delta+1] - posSums[r-delta][c]   #top left side (excluding edges)\\n                sum+= posSums[r+delta-1][c+1] - posSums[r][c+delta]   #bottom right side (excluding edges)\\n\\n            return sum\\n        \\n        \\n        \\n        for row in range(1, len(grid)-1):\\n            for col in range(1, len(grid[0])-1):\\n                delta = 1   #distance away from rhombus center point\\n                while delta <= row < len(grid)-delta and delta <= col < len(grid[0])-delta:\\n                    sums.add(getSum(row,col, delta))\\n                    delta+=1\\n        \\n        return sorted(list(sums), reverse = True)[:3]\\n```",
                "solutionTags": [],
                "code": "```\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        negSums, posSums = [], []    # negative slope,  positive slope\\n        sums = set()\\n        \\n        for r in range(0, len(grid)):\\n            negSums.append(grid[r][:])\\n            posSums.append(grid[r][:])\\n            \\n            for c in range(0, len(negSums[0])):\\n                sums.add(grid[r][c])\\n                \\n                if 0 < r:\\n                    if 0 < c:\\n                        negSums[r][c]+= negSums[r-1][c-1]\\n                    if c < len(negSums[0])-1:\\n                        posSums[r][c] += posSums[r-1][c+1]\\n                \\n        def getSum(r,c,delta):\\n            sum = negSums[r][c+delta] if r-delta == 0 else (negSums[r][c+delta] - negSums[r-delta-1][c-1])   #top right side\\n            sum+= negSums[r+delta][c] if c-delta == 0 else (negSums[r+delta][c] - negSums[r-1][c-delta-1])   #bottom left side\\n            \\n            if delta > 1:\\n                sum+= posSums[r-1][c-delta+1] - posSums[r-delta][c]   #top left side (excluding edges)\\n                sum+= posSums[r+delta-1][c+1] - posSums[r][c+delta]   #bottom right side (excluding edges)\\n\\n            return sum\\n        \\n        \\n        \\n        for row in range(1, len(grid)-1):\\n            for col in range(1, len(grid[0])-1):\\n                delta = 1   #distance away from rhombus center point\\n                while delta <= row < len(grid)-delta and delta <= col < len(grid[0])-delta:\\n                    sums.add(getSum(row,col, delta))\\n                    delta+=1\\n        \\n        return sorted(list(sums), reverse = True)[:3]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1944265,
                "title": "why-case-93-wrong-answer",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n    const getRhombus = ({size, x, y}) => {\\n        if (size === 0) {\\n            return [grid[y][x]]\\n        }\\n        let rhombus = [];\\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+i]?.[x+i]);\\n        }\\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+i+size]?.[x+size-i]);\\n        }\\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+size+size-i]?.[x-i]);\\n        }\\n        \\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+size-i]?.[x+i-size]);\\n        }\\n        if (rhombus.every(e => e)) {\\n            return rhombus;\\n        }\\n        return null;\\n    }\\n    let sums = new Set();\\n    for (let i=0; i<grid.length; i++) {\\n        for (let k=0; k<grid.length; k++) {\\n            for (let l=0; l<grid.length; l++) {\\n                let rhombus = getRhombus({\\n                    size: i,\\n                    x: k,\\n                    y: l,\\n                });\\n                if (rhombus) {\\n                    sums.add(rhombus.reduce((a,b) => a+b));\\n                }\\n            }\\n        }     \\n    }\\n    let sumsArray = Array.from(sums);\\n    sumsArray.sort((a,b) => {\\n        return b - a;\\n    })\\n    return sumsArray.slice(0, 3);\\n};\\n```\\nInput: https://leetcode.com/submissions/detail/679762906/testcase/\\nOutput: [1382782,1323455,1308108]\\nExpected: [1382782,1379532,1323455]",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(grid) {\\n    const getRhombus = ({size, x, y}) => {\\n        if (size === 0) {\\n            return [grid[y][x]]\\n        }\\n        let rhombus = [];\\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+i]?.[x+i]);\\n        }\\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+i+size]?.[x+size-i]);\\n        }\\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+size+size-i]?.[x-i]);\\n        }\\n        \\n        for (let i=0; i<size; i++) {\\n            rhombus.push(grid[y+size-i]?.[x+i-size]);\\n        }\\n        if (rhombus.every(e => e)) {\\n            return rhombus;\\n        }\\n        return null;\\n    }\\n    let sums = new Set();\\n    for (let i=0; i<grid.length; i++) {\\n        for (let k=0; k<grid.length; k++) {\\n            for (let l=0; l<grid.length; l++) {\\n                let rhombus = getRhombus({\\n                    size: i,\\n                    x: k,\\n                    y: l,\\n                });\\n                if (rhombus) {\\n                    sums.add(rhombus.reduce((a,b) => a+b));\\n                }\\n            }\\n        }     \\n    }\\n    let sumsArray = Array.from(sums);\\n    sumsArray.sort((a,b) => {\\n        return b - a;\\n    })\\n    return sumsArray.slice(0, 3);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1917379,
                "title": "javascript-solution-traverse-it",
                "content": "```\\nvar getBiggestThree = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const set = new Set();\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            let sum = grid[i][j];\\n           \\n            set.add(sum)\\n            \\n            let len = 1;\\n            let row = i;\\n            let col = j;\\n            \\n            while (withinBound(row + 1, col - 1)) {\\n                ++len;\\n                ++row;\\n                --col;\\n\\n                traverse(i, j, row, col, sum, len, 0, \"botRight\");\\n                sum += grid[row][col];\\n            }\\n        }\\n    }\\n    \\n    let max1;\\n    let max2;\\n    let max3;\\n    \\n    for (const num of set) {\\n        if (max1 == null || num > max1) {\\n            max3 = max2;\\n            max2 = max1;\\n            max1 = num;\\n        }\\n        else if (max2 == null || num > max2) {\\n            max3 = max2;\\n            max2 = num;\\n        }\\n        else if (max3 == null || num > max3) {\\n            max3 = num;\\n        }\\n    }\\n\\n    const res = [];\\n    \\n    if (max1) res[0] = max1;\\n    if (max2) res[1] = max2;\\n    if (max3) res[2] = max3;\\n  \\n    return res;\\n    \\n    \\n    \\n    function traverse(destRow, destCol, currRow, currCol, totSum, lenSize, currLen, currDir) {\\n        if (currRow === destRow && currCol === destCol) {\\n            set.add(totSum);\\n            return;\\n        }\\n\\n        totSum += grid[currRow][currCol];\\n        ++currLen;\\n\\n        if (currDir === \"botRight\") {\\n            if (currLen < lenSize) {\\n                if (!withinBound(currRow + 1, currCol + 1)) return;\\n\\n                traverse(destRow, destCol, currRow + 1, currCol + 1, totSum, lenSize, currLen, currDir);\\n            }\\n            else if (currLen === lenSize) {\\n                if (!withinBound(currRow - 1, currCol + 1)) return;\\n\\n                traverse(destRow, destCol, currRow - 1, currCol + 1, totSum, lenSize, 1, \"topRight\");\\n            }\\n        }\\n        else if (currDir === \"topRight\") {\\n            if (currLen < lenSize) {\\n                if (!withinBound(currRow - 1, currCol + 1)) return;\\n\\n                traverse(destRow, destCol, currRow - 1, currCol + 1, totSum, lenSize, currLen, \"topRight\");\\n            }\\n            else if (currLen === lenSize) {\\n                if (!withinBound(currRow - 1, currCol - 1)) return;\\n\\n                traverse(destRow, destCol, currRow - 1, currCol - 1, totSum, lenSize, 1, \"topLeft\");\\n            }\\n        }\\n        else if (currDir === \"topLeft\") {\\n            if (!withinBound(currRow - 1, currCol - 1)) return;\\n\\n            traverse(destRow, destCol, currRow - 1, currCol - 1, totSum, lenSize, currLen, \"topLeft\");\\n        }\\n    }\\n    \\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < m && col < n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getBiggestThree = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const set = new Set();\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            let sum = grid[i][j];\\n           \\n            set.add(sum)\\n            \\n            let len = 1;\\n            let row = i;\\n            let col = j;\\n            \\n            while (withinBound(row + 1, col - 1)) {\\n                ++len;\\n                ++row;\\n                --col;\\n\\n                traverse(i, j, row, col, sum, len, 0, \"botRight\");\\n                sum += grid[row][col];\\n            }\\n        }\\n    }\\n    \\n    let max1;\\n    let max2;\\n    let max3;\\n    \\n    for (const num of set) {\\n        if (max1 == null || num > max1) {\\n            max3 = max2;\\n            max2 = max1;\\n            max1 = num;\\n        }\\n        else if (max2 == null || num > max2) {\\n            max3 = max2;\\n            max2 = num;\\n        }\\n        else if (max3 == null || num > max3) {\\n            max3 = num;\\n        }\\n    }\\n\\n    const res = [];\\n    \\n    if (max1) res[0] = max1;\\n    if (max2) res[1] = max2;\\n    if (max3) res[2] = max3;\\n  \\n    return res;\\n    \\n    \\n    \\n    function traverse(destRow, destCol, currRow, currCol, totSum, lenSize, currLen, currDir) {\\n        if (currRow === destRow && currCol === destCol) {\\n            set.add(totSum);\\n            return;\\n        }\\n\\n        totSum += grid[currRow][currCol];\\n        ++currLen;\\n\\n        if (currDir === \"botRight\") {\\n            if (currLen < lenSize) {\\n                if (!withinBound(currRow + 1, currCol + 1)) return;\\n\\n                traverse(destRow, destCol, currRow + 1, currCol + 1, totSum, lenSize, currLen, currDir);\\n            }\\n            else if (currLen === lenSize) {\\n                if (!withinBound(currRow - 1, currCol + 1)) return;\\n\\n                traverse(destRow, destCol, currRow - 1, currCol + 1, totSum, lenSize, 1, \"topRight\");\\n            }\\n        }\\n        else if (currDir === \"topRight\") {\\n            if (currLen < lenSize) {\\n                if (!withinBound(currRow - 1, currCol + 1)) return;\\n\\n                traverse(destRow, destCol, currRow - 1, currCol + 1, totSum, lenSize, currLen, \"topRight\");\\n            }\\n            else if (currLen === lenSize) {\\n                if (!withinBound(currRow - 1, currCol - 1)) return;\\n\\n                traverse(destRow, destCol, currRow - 1, currCol - 1, totSum, lenSize, 1, \"topLeft\");\\n            }\\n        }\\n        else if (currDir === \"topLeft\") {\\n            if (!withinBound(currRow - 1, currCol - 1)) return;\\n\\n            traverse(destRow, destCol, currRow - 1, currCol - 1, totSum, lenSize, currLen, \"topLeft\");\\n        }\\n    }\\n    \\n    \\n    function withinBound(row, col) {\\n        return row >= 0 && col >= 0 && row < m && col < n;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865297,
                "title": "clean-python-solution",
                "content": "Time complexity will be <img src=\"https://render.githubusercontent.com/render/math?math=\\\\mathcal{O}(mn^2)\"> (check the bounds of the loop containing the side_length variable to confirm this).\\n\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        rhombus_sums = []\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        neg_slope_sums = copy.deepcopy(grid)\\n        pos_slope_sums = copy.deepcopy(grid)\\n        \\n        # Initialize neg_slope_sums top-down, left to right\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                    neg_slope_sums[i][j] += neg_slope_sums[i - 1][j - 1]\\n        \\n        # Initialize pos_slope_sums bottom-up, right to left\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n - 1, 0, -1):\\n                    pos_slope_sums[i][j] += pos_slope_sums[i + 1][j - 1]\\n        \\n        def inBounds(row: int, col: int) -> bool:\\n            return (0 <= row < m) and (0 <= col < n)\\n        \\n        # Get sum of right-and-down diagonal from (start_row, start_col) -> (end_row, end_col) inclusive\\n        def getNegativeSlopeSideSum(start_row: int, start_col: int, end_row: int, end_col: int) -> int:\\n            return neg_slope_sums[end_row][end_col] - neg_slope_sums[start_row][start_col] + grid[start_row][start_col]\\n        \\n        # Get sum of right-and-up diagonal from (start_row, start_col) -> (end_row, end_col) inclusive\\n        def getPositiveSlopeSideSum(start_row: int, start_col: int, end_row: int, end_col: int) -> int:\\n            return pos_slope_sums[end_row][end_col] - pos_slope_sums[start_row][start_col] + grid[start_row][start_col]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                for side_length in range(n - j + 1):\\n                    if not (\\n\\t\\t\\t\\t\\t\\t# Right vertex\\n                        inBounds(i + side_length, j + side_length) and\\n\\t\\t\\t\\t\\t\\t# Left vertex\\n                        inBounds(i + side_length, j - side_length) and\\n\\t\\t\\t\\t\\t\\t# Bottom vertex\\n                        inBounds(i + 2 * side_length, j)\\n                    ):\\n                        break\\n                    \\n                    if side_length == 0:\\n                        rhombus_sum = grid[i][j]\\n                    else:\\n                        # Top vertex to just above right vertex\\n                        side1_sum = getNegativeSlopeSideSum(\\n                            start_row=i, \\n                            start_col=j, \\n                            end_row=i + side_length - 1, \\n                            end_col=j + side_length - 1,\\n                        )\\n                        # Left vertex to just above bottom vertex\\n                        side2_sum = getNegativeSlopeSideSum(\\n                            start_row=i + side_length, \\n                            start_col=j - side_length, \\n                            end_row=i + 2 * side_length - 1, \\n                            end_col=j - 1,\\n                        )\\n                        # Just above left vertex to just below top vertex\\n                        side3_sum = getPositiveSlopeSideSum(\\n                            start_row=i + side_length - 1, \\n                            start_col=j - side_length + 1, \\n                            end_row=i + 1, \\n                            end_col=j - 1,\\n                        )\\n                        # Bottom vertex to right vertex\\n                        side4_sum = getPositiveSlopeSideSum(\\n                            start_row=i + 2 * side_length, \\n                            start_col=j, \\n                            end_row=i + side_length, \\n                            end_col=j + side_length,\\n                        )\\n                        rhombus_sum = side1_sum + side2_sum + side3_sum + side4_sum\\n                    \\n                    # Ensuring rhombus_sums are distinct and in descending order\\n                    if rhombus_sum not in rhombus_sums:\\n                        rhombus_sums.append(rhombus_sum)\\n                        rhombus_sums.sort(reverse=True)\\n                        if len(rhombus_sums) == 4:\\n                            rhombus_sums.pop()\\n          \\n        return rhombus_sums\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        rhombus_sums = []\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        neg_slope_sums = copy.deepcopy(grid)\\n        pos_slope_sums = copy.deepcopy(grid)\\n        \\n        # Initialize neg_slope_sums top-down, left to right\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                    neg_slope_sums[i][j] += neg_slope_sums[i - 1][j - 1]\\n        \\n        # Initialize pos_slope_sums bottom-up, right to left\\n        for i in range(m - 2, -1, -1):\\n            for j in range(n - 1, 0, -1):\\n                    pos_slope_sums[i][j] += pos_slope_sums[i + 1][j - 1]\\n        \\n        def inBounds(row: int, col: int) -> bool:\\n            return (0 <= row < m) and (0 <= col < n)\\n        \\n        # Get sum of right-and-down diagonal from (start_row, start_col) -> (end_row, end_col) inclusive\\n        def getNegativeSlopeSideSum(start_row: int, start_col: int, end_row: int, end_col: int) -> int:\\n            return neg_slope_sums[end_row][end_col] - neg_slope_sums[start_row][start_col] + grid[start_row][start_col]\\n        \\n        # Get sum of right-and-up diagonal from (start_row, start_col) -> (end_row, end_col) inclusive\\n        def getPositiveSlopeSideSum(start_row: int, start_col: int, end_row: int, end_col: int) -> int:\\n            return pos_slope_sums[end_row][end_col] - pos_slope_sums[start_row][start_col] + grid[start_row][start_col]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                for side_length in range(n - j + 1):\\n                    if not (\\n\\t\\t\\t\\t\\t\\t# Right vertex\\n                        inBounds(i + side_length, j + side_length) and\\n\\t\\t\\t\\t\\t\\t# Left vertex\\n                        inBounds(i + side_length, j - side_length) and\\n\\t\\t\\t\\t\\t\\t# Bottom vertex\\n                        inBounds(i + 2 * side_length, j)\\n                    ):\\n                        break\\n                    \\n                    if side_length == 0:\\n                        rhombus_sum = grid[i][j]\\n                    else:\\n                        # Top vertex to just above right vertex\\n                        side1_sum = getNegativeSlopeSideSum(\\n                            start_row=i, \\n                            start_col=j, \\n                            end_row=i + side_length - 1, \\n                            end_col=j + side_length - 1,\\n                        )\\n                        # Left vertex to just above bottom vertex\\n                        side2_sum = getNegativeSlopeSideSum(\\n                            start_row=i + side_length, \\n                            start_col=j - side_length, \\n                            end_row=i + 2 * side_length - 1, \\n                            end_col=j - 1,\\n                        )\\n                        # Just above left vertex to just below top vertex\\n                        side3_sum = getPositiveSlopeSideSum(\\n                            start_row=i + side_length - 1, \\n                            start_col=j - side_length + 1, \\n                            end_row=i + 1, \\n                            end_col=j - 1,\\n                        )\\n                        # Bottom vertex to right vertex\\n                        side4_sum = getPositiveSlopeSideSum(\\n                            start_row=i + 2 * side_length, \\n                            start_col=j, \\n                            end_row=i + side_length, \\n                            end_col=j + side_length,\\n                        )\\n                        rhombus_sum = side1_sum + side2_sum + side3_sum + side4_sum\\n                    \\n                    # Ensuring rhombus_sums are distinct and in descending order\\n                    if rhombus_sum not in rhombus_sums:\\n                        rhombus_sums.append(rhombus_sum)\\n                        rhombus_sums.sort(reverse=True)\\n                        if len(rhombus_sums) == 4:\\n                            rhombus_sums.pop()\\n          \\n        return rhombus_sums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846818,
                "title": "python-reused-half-of-the-calculation",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        x, y  = 0, 0\\n        M, N = len(grid), len(grid[0])\\n        MAXLEN = min(M, N) // 2 + 1\\n        pq = []\\n        for x in range(M):\\n            for y in range(N):\\n                cursum, bhalf = 0, 0\\n                ux, uy = x, y\\n                for l in range(MAXLEN):\\n                    # print(\"l\", l)\\n                    lx, ly = x + l, y - l\\n                    rx, ry = x + l, y + l\\n                    bx, by = x + 2*l, y\\n                    if x+2*l >= M or y-l < 0 or y + l  >= N: \\n                        break # not expanding anymore\\n                    if l == 0:\\n                        cursum = grid[x][y]\\n                    else:\\n                        # print(\"bhalf\", bhalf)\\n                        cursum -= bhalf \\n                        cursum += (grid[lx][ly] + grid[rx][ry])\\n                        \\n                        bhalf = grid[bx][by]\\n                        i = 1\\n                        while by - i > ly and by + i < ry:\\n                            bhalf += grid[bx-i][by-i] \\n                            bhalf += grid[bx-i][by+i]\\n                            i += 1\\n                        # print(\"bhalf\", bhalf)\\n                            \\n                        cursum += bhalf\\n                    \\n                    if cursum not in pq:\\n                        heappush(pq, cursum)\\n                    if len(pq) > 3:\\n                        heappop(pq)\\n        pq.sort(reverse=True)\\n        return pq\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        x, y  = 0, 0\\n        M, N = len(grid), len(grid[0])\\n        MAXLEN = min(M, N) // 2 + 1\\n        pq = []\\n        for x in range(M):\\n            for y in range(N):\\n                cursum, bhalf = 0, 0\\n                ux, uy = x, y\\n                for l in range(MAXLEN):\\n                    # print(\"l\", l)\\n                    lx, ly = x + l, y - l\\n                    rx, ry = x + l, y + l\\n                    bx, by = x + 2*l, y\\n                    if x+2*l >= M or y-l < 0 or y + l  >= N: \\n                        break # not expanding anymore\\n                    if l == 0:\\n                        cursum = grid[x][y]\\n                    else:\\n                        # print(\"bhalf\", bhalf)\\n                        cursum -= bhalf \\n                        cursum += (grid[lx][ly] + grid[rx][ry])\\n                        \\n                        bhalf = grid[bx][by]\\n                        i = 1\\n                        while by - i > ly and by + i < ry:\\n                            bhalf += grid[bx-i][by-i] \\n                            bhalf += grid[bx-i][by+i]\\n                            i += 1\\n                        # print(\"bhalf\", bhalf)\\n                            \\n                        cursum += bhalf\\n                    \\n                    if cursum not in pq:\\n                        heappush(pq, cursum)\\n                    if len(pq) > 3:\\n                        heappop(pq)\\n        pq.sort(reverse=True)\\n        return pq\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1821641,
                "title": "c-optimal-solution-searching-only-valid-rhombus",
                "content": "```\\nint findSum(vector<vector<int>> &grid,int i,int j,int s){\\n        if(s==1) return grid[i][j];\\n        if(s==2) return grid[i-1][j] + grid[i][j-1] + grid[i+1][j] +grid[i][j+1];\\n        pair<int,int> t = {i-s+1,j};\\n        pair<int,int> l = {i,j-s+1};\\n        pair<int,int> b = {i+s-1,j};\\n        pair<int,int> r = {i,j+s-1};\\n        int sum = 0;\\n        i = t.first, j = t.second;\\n        while(i<=r.first){\\n            sum += grid[i][j];\\n            i++;\\n            j++;\\n        }\\n        i = l.first, j = l.second;\\n        while(i<=b.first){\\n            sum += grid[i][j];\\n            i++;\\n            j++;\\n        }\\n        i = l.first-1,j=l.second+1;\\n        while(j<t.second){\\n            sum += grid[i][j];\\n            i--;\\n            j++;\\n        }\\n        i = b.first-1,j=b.second+1;\\n        while(j<r.second){\\n            sum += grid[i][j];\\n            i--;\\n            j++;\\n        }\\n        return sum;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int max_rohum_size = (min(m,n)+1)/2; //Maximum size of rhombus\\n        set<int, greater<int> > st; //Storing only top 3 area vise rhombus\\n        \\n        for(int s=1;s<=max_rohum_size;s++){\\n            int sr = s-1, er = m -s + 1; //sr is top left center of rhombus and er is bottom left\\n            int sc = s-1, ec = n -s + 1;  //sc(starting column) is top left center of rhombus and ec is top right\\n            for(int i=sr;i<er;i++){\\n                for(int j=sc;j<ec;j++){\\n                    auto rh_sum = findSum(grid,i,j,s);\\n                    st.insert(rh_sum);\\n                    if(st.size()>3){\\n                        auto it = st.erase(--st.end());\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto v:st){\\n            ans.push_back(v);\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\nint findSum(vector<vector<int>> &grid,int i,int j,int s){\\n        if(s==1) return grid[i][j];\\n        if(s==2) return grid[i-1][j] + grid[i][j-1] + grid[i+1][j] +grid[i][j+1];\\n        pair<int,int> t = {i-s+1,j};\\n        pair<int,int> l = {i,j-s+1};\\n        pair<int,int> b = {i+s-1,j};\\n        pair<int,int> r = {i,j+s-1};\\n        int sum = 0;\\n        i = t.first, j = t.second;\\n        while(i<=r.first){\\n            sum += grid[i][j];\\n            i++;\\n            j++;\\n        }\\n        i = l.first, j = l.second;\\n        while(i<=b.first){\\n            sum += grid[i][j];\\n            i++;\\n            j++;\\n        }\\n        i = l.first-1,j=l.second+1;\\n        while(j<t.second){\\n            sum += grid[i][j];\\n            i--;\\n            j++;\\n        }\\n        i = b.first-1,j=b.second+1;\\n        while(j<r.second){\\n            sum += grid[i][j];\\n            i--;\\n            j++;\\n        }\\n        return sum;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int max_rohum_size = (min(m,n)+1)/2; //Maximum size of rhombus\\n        set<int, greater<int> > st; //Storing only top 3 area vise rhombus\\n        \\n        for(int s=1;s<=max_rohum_size;s++){\\n            int sr = s-1, er = m -s + 1; //sr is top left center of rhombus and er is bottom left\\n            int sc = s-1, ec = n -s + 1;  //sc(starting column) is top left center of rhombus and ec is top right\\n            for(int i=sr;i<er;i++){\\n                for(int j=sc;j<ec;j++){\\n                    auto rh_sum = findSum(grid,i,j,s);\\n                    st.insert(rh_sum);\\n                    if(st.size()>3){\\n                        auto it = st.erase(--st.end());\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto v:st){\\n            ans.push_back(v);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766319,
                "title": "c-with-some-comments",
                "content": "\\n    public int[] GetBiggestThree(int[][] grid) {\\n        int n=grid.Length;\\n        if (n==0)\\n            return new int[0];\\n        int m=grid[0].Length;\\n        \\n       List<int> output=new List<int>();\\n       //for each cell find max expansion radius since it will expand symmetrically from center\\n       for (int i=0;i<n;i++)\\n       {\\n           for (int j=0;j<m;j++)\\n           {\\n               int minI=Math.Min(i, n-1-i);\\n               int minJ=Math.Min(j, m-1-j);\\n               int expansionRadius=Math.Min(minI, minJ);\\n\\n               //if expansion radius is 0, element itself is a sum\\n               if (expansionRadius==0)\\n                output.Add(grid[i][j]);\\n               \\n                //for every level of expansion radius calculate sum\\n               else\\n                   for (int exp=1;exp<=expansionRadius;exp++)\\n                   {\\n                       int sump=0;\\n                       //Calculate corner points\\n                       int top=i+exp;\\n                       int bottom=i-exp;\\n                       int left=j-exp;\\n                       int right=j+exp;\\n                       \\n                        //Calculate sum of corner points\\n                       sump=grid[top][j]+grid[bottom][j]\\n                         +grid[i][right]+grid[i][left];\\n                       \\n                       //Calculate sum of diagonals if expansion raious is more than 2\\n                       for (int within=1;within<exp;within++)\\n                       {\\n                           int moveRight=j+within;\\n                           int moveLeft=j-within;\\n                           sump+=grid[bottom+within][moveRight]+ //upper left\\n                                  grid[bottom+within][moveLeft]+ //upper right\\n                                  grid[top-within][moveRight]+ //lower right\\n                                  grid[top-within][moveLeft]; //lower left\\n\\n                       }\\n                       output.Add(sump);\\n                }\\n           }\\n       }\\n    if (output.Count<3)\\n         return output.Distinct().OrderByDescending(x=>x).ToArray();\\n    return output.Distinct().OrderByDescending(x=>x).Take(3).ToArray();\\n        \\n}",
                "solutionTags": [],
                "code": "\\n    public int[] GetBiggestThree(int[][] grid) {\\n        int n=grid.Length;\\n        if (n==0)\\n            return new int[0];\\n        int m=grid[0].Length;\\n        \\n       List<int> output=new List<int>();\\n       //for each cell find max expansion radius since it will expand symmetrically from center\\n       for (int i=0;i<n;i++)\\n       {\\n           for (int j=0;j<m;j++)\\n           {\\n               int minI=Math.Min(i, n-1-i);\\n               int minJ=Math.Min(j, m-1-j);\\n               int expansionRadius=Math.Min(minI, minJ);\\n\\n               //if expansion radius is 0, element itself is a sum\\n               if (expansionRadius==0)\\n                output.Add(grid[i][j]);\\n               \\n                //for every level of expansion radius calculate sum\\n               else\\n                   for (int exp=1;exp<=expansionRadius;exp++)\\n                   {\\n                       int sump=0;\\n                       //Calculate corner points\\n                       int top=i+exp;\\n                       int bottom=i-exp;\\n                       int left=j-exp;\\n                       int right=j+exp;\\n                       \\n                        //Calculate sum of corner points\\n                       sump=grid[top][j]+grid[bottom][j]\\n                         +grid[i][right]+grid[i][left];\\n                       \\n                       //Calculate sum of diagonals if expansion raious is more than 2\\n                       for (int within=1;within<exp;within++)\\n                       {\\n                           int moveRight=j+within;\\n                           int moveLeft=j-within;\\n                           sump+=grid[bottom+within][moveRight]+ //upper left\\n                                  grid[bottom+within][moveLeft]+ //upper right\\n                                  grid[top-within][moveRight]+ //lower right\\n                                  grid[top-within][moveLeft]; //lower left\\n\\n                       }\\n                       output.Add(sump);\\n                }\\n           }\\n       }\\n    if (output.Count<3)\\n         return output.Distinct().OrderByDescending(x=>x).ToArray();\\n    return output.Distinct().OrderByDescending(x=>x).Take(3).ToArray();\\n        \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1762348,
                "title": "c-simple",
                "content": "\\n```\\n        public int[] GetBiggestThree(int[][] grid)\\n        {\\n            if(grid.Length == 1){ \\n                return grid[0].Distinct().OrderByDescending(o => o).Take(3).ToArray() ;\\n            }\\n            \\n            List<int> myList = new List<int>();\\n            for (int i = 0; i < grid.Count(); ++i)\\n                for (int j = 0; j < grid[0].Count(); ++j)\\n                    for (int sz = 0; i + sz < grid.Count() && i - sz >= 0 && j + 2 * sz < grid[0].Count(); ++sz)\\n                    {\\n                        int x = i, y = j, r_sum = 0;\\n                        do r_sum += grid[x++][y++]; while (x < i + sz);\\n                        if (sz > 0)\\n                        {\\n                            do r_sum += grid[x--][y++]; while (y < j + 2 * sz);\\n                            do r_sum += grid[x--][y--]; while (x > i - sz);\\n                            do r_sum += grid[x++][y--]; while (x < i);\\n                        }\\n                        myList.Add(r_sum);\\n                    }\\n\\n            return myList.Distinct().OrderByDescending(o => o).Take(3).ToArray();\\n\\n        }\\n```\\n\\nNot sure if this image is helpful, but I\\'ve stepped through the code to show the first 18 loops and noted which values are added to r_sum\\n![image](https://assets.leetcode.com/users/images/d9b4cc34-c6e0-4645-bba7-0e2e50a79eb7_1644565357.0809112.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n        public int[] GetBiggestThree(int[][] grid)\\n        {\\n            if(grid.Length == 1){ \\n                return grid[0].Distinct().OrderByDescending(o => o).Take(3).ToArray() ;\\n            }\\n            \\n            List<int> myList = new List<int>();\\n            for (int i = 0; i < grid.Count(); ++i)\\n                for (int j = 0; j < grid[0].Count(); ++j)\\n                    for (int sz = 0; i + sz < grid.Count() && i - sz >= 0 && j + 2 * sz < grid[0].Count(); ++sz)\\n                    {\\n                        int x = i, y = j, r_sum = 0;\\n                        do r_sum += grid[x++][y++]; while (x < i + sz);\\n                        if (sz > 0)\\n                        {\\n                            do r_sum += grid[x--][y++]; while (y < j + 2 * sz);\\n                            do r_sum += grid[x--][y--]; while (x > i - sz);\\n                            do r_sum += grid[x++][y--]; while (x < i);\\n                        }\\n                        myList.Add(r_sum);\\n                    }\\n\\n            return myList.Distinct().OrderByDescending(o => o).Take(3).ToArray();\\n\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737731,
                "title": "golang-dfs",
                "content": "```\\nvar summs []int\\nvar n int\\nvar m int\\n\\nfunc getBiggestThree(grid [][]int) []int {\\n    summs = make([]int, 0) // All possible Sums\\n    ans := make([]int, 0)\\n    n=len(grid)\\n    m=len(grid[0])\\n    \\n    for i:=0; i < n; i++{\\n        for j:=0; j < m; j++{\\n            summs = append(summs, grid[i][j])\\n            dfs(1, i, j , grid)\\n        }\\n    }\\n    \\n    //Get 3 max sum from summs and return\\n    sort.Ints(summs)     \\n    k:= len(summs)\\n    ans = append(ans, summs[k-1])\\n    for i:=k-2; i >= 0; i--{\\n        if len(ans) == 3{\\n            break\\n        }\\n        if summs[i] != ans[len(ans)-1]{\\n            ans = append(ans, summs[i])\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc dfs(level int, i int, j int, grid [][]int){\\n    if i - level < 0 || level + i >=n || j - level < 0 || j + level >= m{//out of grid\\n        return\\n    }\\n    sum := 0//sum of rhombus\\n    for x:= i-level; x <= i+level; x++{// level -> size of the rhombus\\n        for y:= j-level; y <= j + level; y++{\\n            if Abs(x-i) + Abs(y-j) == level{\\n                sum+= grid[x][y]\\n            }\\n        } \\n    }\\n    summs = append(summs, sum)\\n    dfs(level+1, i, j, grid)//same center, try to increase size of the rombus\\n}\\n\\nfunc Abs(a int) int{\\n    if a > 0{\\n        return a\\n    }\\n    return -a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar summs []int\\nvar n int\\nvar m int\\n\\nfunc getBiggestThree(grid [][]int) []int {\\n    summs = make([]int, 0) // All possible Sums\\n    ans := make([]int, 0)\\n    n=len(grid)\\n    m=len(grid[0])\\n    \\n    for i:=0; i < n; i++{\\n        for j:=0; j < m; j++{\\n            summs = append(summs, grid[i][j])\\n            dfs(1, i, j , grid)\\n        }\\n    }\\n    \\n    //Get 3 max sum from summs and return\\n    sort.Ints(summs)     \\n    k:= len(summs)\\n    ans = append(ans, summs[k-1])\\n    for i:=k-2; i >= 0; i--{\\n        if len(ans) == 3{\\n            break\\n        }\\n        if summs[i] != ans[len(ans)-1]{\\n            ans = append(ans, summs[i])\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc dfs(level int, i int, j int, grid [][]int){\\n    if i - level < 0 || level + i >=n || j - level < 0 || j + level >= m{//out of grid\\n        return\\n    }\\n    sum := 0//sum of rhombus\\n    for x:= i-level; x <= i+level; x++{// level -> size of the rhombus\\n        for y:= j-level; y <= j + level; y++{\\n            if Abs(x-i) + Abs(y-j) == level{\\n                sum+= grid[x][y]\\n            }\\n        } \\n    }\\n    summs = append(summs, sum)\\n    dfs(level+1, i, j, grid)//same center, try to increase size of the rombus\\n}\\n\\nfunc Abs(a int) int{\\n    if a > 0{\\n        return a\\n    }\\n    return -a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629132,
                "title": "python3-time-o-n-3",
                "content": "![image](https://assets.leetcode.com/users/images/ced613db-156b-4e19-b36a-67354a6dc466_1639508833.8469822.png)\\n\\n\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n, m = len(grid), len(grid[0])\\n        sumD1 = [[grid[i][j] for j in range(m)] for i in range(n)]\\n        sumD2 = [[grid[i][j] for j in range(m)] for i in range(n)]\\n        \\n        ans = set([grid[i][j] for i in range(n) for j in range(m)])\\n        ans = list(ans)\\n        ans.sort(reverse = True)\\n        ans = ans[:3]\\n        \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                sumD1[i][j] += sumD1[i - 1][j - 1]\\n        \\n        for i in range(1, n):\\n            for j in range(m - 1):\\n                sumD2[i][j] += sumD2[i - 1][j + 1]\\n        \\n        for i in range(1, n - 1):\\n            for j in range(1, m - 1):                \\n                d = 1\\n                while 0 <= i - d and i + d < n and 0 <= j - d and j + d < m: \\n                    TR = sumD1[i][j + d]\\n                    TR -= sumD1[i - d - 1][j - 1] if j - 1 >= 0 and i - d - 1 >= 0 else 0 \\n                    \\n                    BL = sumD1[i + d][j]\\n                    BL -= sumD1[i - 1][j - d - 1] if i - 1 >= 0 and j - d - 1 >= 0 else 0\\n                    \\n                    TL = sumD2[i - 1][j - d + 1] - sumD2[i - d][j] \\n                    \\n                    BR = sumD2[i + d - 1][j + 1] - sumD2[i][j + d]\\n                    \\n                    perimeter = TR + BL + TL + BR\\n                    \\n                    if perimeter not in ans: \\n                        ans.append(perimeter)\\n                        ans.sort(reverse = True)\\n                        ans = ans[:3]\\n                    d += 1\\n               \\n        return ans\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n, m = len(grid), len(grid[0])\\n        sumD1 = [[grid[i][j] for j in range(m)] for i in range(n)]\\n        sumD2 = [[grid[i][j] for j in range(m)] for i in range(n)]\\n        \\n        ans = set([grid[i][j] for i in range(n) for j in range(m)])\\n        ans = list(ans)\\n        ans.sort(reverse = True)\\n        ans = ans[:3]\\n        \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                sumD1[i][j] += sumD1[i - 1][j - 1]\\n        \\n        for i in range(1, n):\\n            for j in range(m - 1):\\n                sumD2[i][j] += sumD2[i - 1][j + 1]\\n        \\n        for i in range(1, n - 1):\\n            for j in range(1, m - 1):                \\n                d = 1\\n                while 0 <= i - d and i + d < n and 0 <= j - d and j + d < m: \\n                    TR = sumD1[i][j + d]\\n                    TR -= sumD1[i - d - 1][j - 1] if j - 1 >= 0 and i - d - 1 >= 0 else 0 \\n                    \\n                    BL = sumD1[i + d][j]\\n                    BL -= sumD1[i - 1][j - d - 1] if i - 1 >= 0 and j - d - 1 >= 0 else 0\\n                    \\n                    TL = sumD2[i - 1][j - d + 1] - sumD2[i - d][j] \\n                    \\n                    BR = sumD2[i + d - 1][j + 1] - sumD2[i][j + d]\\n                    \\n                    perimeter = TR + BL + TL + BR\\n                    \\n                    if perimeter not in ans: \\n                        ans.append(perimeter)\\n                        ans.sort(reverse = True)\\n                        ans = ans[:3]\\n                    d += 1\\n               \\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617663,
                "title": "c-brute-force-with-prefix-sums-commented-with-complexity-90-faster-79-less-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    int rhombusSum(int topR, int topC, int sideLen, vector<vector<int>>& grid, \\n                     vector<vector<int>>& sumDownR, vector<vector<int>>& sumDownL) {\\n        // returns rhombus sum with top vertex grid[topR][topC] and side length sideLen\\n        // approach: sums rhombus values across each side, then subtracts double counted corners\\n        // time: O(1)\\n        // space: O(1)\\n        \\n        int sum = 0;\\n        \\n        if (sideLen == 0) // get rid of edge case (no differences)\\n            return grid[topR][topC];\\n        \\n        // sums that stretch from [topR][topC] to middle vertices\\n        int downRUpperSum = sumDownR[topR+sideLen][topC+sideLen] - \\n                        ((topR > 0) ? sumDownR[topR - 1][topC - 1] : 0); // && topC > 0\\n        int downLUpperSum = sumDownL[topR + sideLen][topC - sideLen] -\\n                        ((topR > 0) ? sumDownL[topR - 1][topC + 1] : 0); // && topC < cols - 1\\n        \\n        // sums that stretch from middle vertices to bottommost vertex\\n        int downRLowerSum, downLLowerSum; \\n        downRLowerSum = sumDownR[topR + 2*sideLen][topC] - \\n                        ((topC - sideLen > 0) ? sumDownR[topR + sideLen - 1][topC - sideLen - 1] : 0); \\n        downLLowerSum = sumDownL[topR + 2*sideLen][topC] -\\n                        ((topC + sideLen < grid[0].size() - 1) \\n                            ? sumDownL[topR + sideLen - 1][topC + sideLen + 1] : 0);\\n        \\n        // return sum, accounting for double counted corners\\n        return downRUpperSum + downLUpperSum + downRLowerSum + downLLowerSum \\n                    - grid[topR + sideLen][topC + sideLen] - grid[topR + sideLen][topC - sideLen]\\n                    - grid[topR][topC] - grid[topR + 2*sideLen][topC]; \\n    }\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        // M = grid.size(), N = grid[0].size()\\n        // time: O(M*N*min(M,N))\\n        // space: O(M*N)\\n        // time iterates across MN maxSideLen times where maxSideLen is proportional to min(M,N)\\n        // stores two arrays of equal size to grid as well as constant extra space for set + vector\\n        \\n        set<int> topSumSet;\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        // prefix sums moving down-right and down-left\\n        vector<vector<int>> sumDownR(rows, vector<int>(cols, 0));\\n        vector<vector<int>> sumDownL(rows, vector<int>(cols, 0));\\n        // fill in down-right prefix sums\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n            {\\n                if (r == 0 || c == 0)\\n                    sumDownR[r][c] = grid[r][c];\\n                else\\n                    sumDownR[r][c] = grid[r][c] + sumDownR[r-1][c-1];\\n            }\\n        // fill in down-left prefix sums\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = cols - 1; c >= 0; --c)\\n            {\\n                if (r == 0 || c == cols - 1)\\n                    sumDownL[r][c] = grid[r][c];\\n                else\\n                    sumDownL[r][c] = grid[r][c] + sumDownL[r-1][c+1];\\n            }\\n        \\n        \\n        // considering side lengths as row or column distance, not absolute distance between vertices\\n        int maxSideLen = (min(rows, cols) - 1) / 2;\\n        // iterate over all possible rhombus side lengths\\n        for (int s = 0; s <= maxSideLen; ++s)\\n            // [r][c] represents indices of topmost vertex of rhombos\\n            // c starts sideLen in, end sideLen from edge\\n            // r starts at 0, ends 2*sideLEn from edge\\n            for (int r = 0; r < rows - 2*s; ++r)\\n                for (int c = s; c < cols - s; ++c)\\n                {\\n                    // calculate current rhombus sum\\n                    int curSum = rhombusSum(r, c, s, grid, sumDownR, sumDownL);\\n                    \\n                    // add to set if set doesn\\'t have 3 sums or new top 3 sum\\n                    if (topSumSet.size() < 3 || curSum > *topSumSet.begin()) {\\n                        topSumSet.insert(curSum);\\n                        if (topSumSet.size() > 3) // remove first element if size exceeds limit\\n                            topSumSet.erase(topSumSet.begin());\\n                    }\\n                }\\n        \\n        vector<int> topSums(topSumSet.size(), 0); // allocate new vector for return\\n        topSums.assign(topSumSet.begin(), topSumSet.end()); // move set to vector\\n        reverse(topSums.begin(), topSums.end()); // descending order\\n        return topSums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int rhombusSum(int topR, int topC, int sideLen, vector<vector<int>>& grid, \\n                     vector<vector<int>>& sumDownR, vector<vector<int>>& sumDownL) {\\n        // returns rhombus sum with top vertex grid[topR][topC] and side length sideLen\\n        // approach: sums rhombus values across each side, then subtracts double counted corners\\n        // time: O(1)\\n        // space: O(1)\\n        \\n        int sum = 0;\\n        \\n        if (sideLen == 0) // get rid of edge case (no differences)\\n            return grid[topR][topC];\\n        \\n        // sums that stretch from [topR][topC] to middle vertices\\n        int downRUpperSum = sumDownR[topR+sideLen][topC+sideLen] - \\n                        ((topR > 0) ? sumDownR[topR - 1][topC - 1] : 0); // && topC > 0\\n        int downLUpperSum = sumDownL[topR + sideLen][topC - sideLen] -\\n                        ((topR > 0) ? sumDownL[topR - 1][topC + 1] : 0); // && topC < cols - 1\\n        \\n        // sums that stretch from middle vertices to bottommost vertex\\n        int downRLowerSum, downLLowerSum; \\n        downRLowerSum = sumDownR[topR + 2*sideLen][topC] - \\n                        ((topC - sideLen > 0) ? sumDownR[topR + sideLen - 1][topC - sideLen - 1] : 0); \\n        downLLowerSum = sumDownL[topR + 2*sideLen][topC] -\\n                        ((topC + sideLen < grid[0].size() - 1) \\n                            ? sumDownL[topR + sideLen - 1][topC + sideLen + 1] : 0);\\n        \\n        // return sum, accounting for double counted corners\\n        return downRUpperSum + downLUpperSum + downRLowerSum + downLLowerSum \\n                    - grid[topR + sideLen][topC + sideLen] - grid[topR + sideLen][topC - sideLen]\\n                    - grid[topR][topC] - grid[topR + 2*sideLen][topC]; \\n    }\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        // M = grid.size(), N = grid[0].size()\\n        // time: O(M*N*min(M,N))\\n        // space: O(M*N)\\n        // time iterates across MN maxSideLen times where maxSideLen is proportional to min(M,N)\\n        // stores two arrays of equal size to grid as well as constant extra space for set + vector\\n        \\n        set<int> topSumSet;\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        // prefix sums moving down-right and down-left\\n        vector<vector<int>> sumDownR(rows, vector<int>(cols, 0));\\n        vector<vector<int>> sumDownL(rows, vector<int>(cols, 0));\\n        // fill in down-right prefix sums\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n            {\\n                if (r == 0 || c == 0)\\n                    sumDownR[r][c] = grid[r][c];\\n                else\\n                    sumDownR[r][c] = grid[r][c] + sumDownR[r-1][c-1];\\n            }\\n        // fill in down-left prefix sums\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = cols - 1; c >= 0; --c)\\n            {\\n                if (r == 0 || c == cols - 1)\\n                    sumDownL[r][c] = grid[r][c];\\n                else\\n                    sumDownL[r][c] = grid[r][c] + sumDownL[r-1][c+1];\\n            }\\n        \\n        \\n        // considering side lengths as row or column distance, not absolute distance between vertices\\n        int maxSideLen = (min(rows, cols) - 1) / 2;\\n        // iterate over all possible rhombus side lengths\\n        for (int s = 0; s <= maxSideLen; ++s)\\n            // [r][c] represents indices of topmost vertex of rhombos\\n            // c starts sideLen in, end sideLen from edge\\n            // r starts at 0, ends 2*sideLEn from edge\\n            for (int r = 0; r < rows - 2*s; ++r)\\n                for (int c = s; c < cols - s; ++c)\\n                {\\n                    // calculate current rhombus sum\\n                    int curSum = rhombusSum(r, c, s, grid, sumDownR, sumDownL);\\n                    \\n                    // add to set if set doesn\\'t have 3 sums or new top 3 sum\\n                    if (topSumSet.size() < 3 || curSum > *topSumSet.begin()) {\\n                        topSumSet.insert(curSum);\\n                        if (topSumSet.size() > 3) // remove first element if size exceeds limit\\n                            topSumSet.erase(topSumSet.begin());\\n                    }\\n                }\\n        \\n        vector<int> topSums(topSumSet.size(), 0); // allocate new vector for return\\n        topSums.assign(topSumSet.begin(), topSumSet.end()); // move set to vector\\n        reverse(topSums.begin(), topSums.end()); // descending order\\n        return topSums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540372,
                "title": "golang-brute-force-double-100-solution",
                "content": "```go\\nfunc getBiggestThree(grid [][]int) []int {\\n\\tbig1, big2, big3 := 0, 0, 0\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[r] {\\n\\t\\t\\tfor wide := 1; wide < 100; wide++ {\\n\\t\\t\\t\\tif value, ok := calculate(grid, r, c, wide); ok {\\n\\t\\t\\t\\t\\tif value == big1 || value == big2 || value == big3 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif value > big1 {\\n\\t\\t\\t\\t\\t\\tbig1, big2, big3 = value, big1, big2\\n\\t\\t\\t\\t\\t} else if value > big2 {\\n\\t\\t\\t\\t\\t\\tbig2, big3 = value, big2\\n\\t\\t\\t\\t\\t} else if value > big3 {\\n\\t\\t\\t\\t\\t\\tbig3 = value\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tresult := make([]int, 0)\\n\\tif big1 != 0 {\\n\\t\\tresult = append(result, big1)\\n\\t}\\n\\tif big2 != 0 {\\n\\t\\tresult = append(result, big2)\\n\\t}\\n\\tif big3 != 0 {\\n\\t\\tresult = append(result, big3)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc calculate(grid [][]int, row, col, wide int) (int, bool) {\\n\\tif col - wide + 1 < 0 || col + wide - 1 >= len(grid[0]) || row + 2 * wide - 2 >= len(grid) {\\n\\t\\treturn 0, false\\n\\t}\\n\\tif wide == 1 {\\n\\t\\treturn grid[row][col], true\\n\\t}\\n\\ttotal := 0\\n\\tfor i := 0; i < wide-1; i++ {\\n\\t\\ttotal += grid[row+i][col+i]\\n\\t\\ttotal += grid[row+wide-1+i][col+wide-1-i]\\n\\t\\ttotal += grid[row+wide+wide-2-i][col-i]\\n\\t\\ttotal += grid[row+wide-1-i][col-wide+1+i]\\n\\t}\\n\\treturn total, true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getBiggestThree(grid [][]int) []int {\\n\\tbig1, big2, big3 := 0, 0, 0\\n\\tfor r := range grid {\\n\\t\\tfor c := range grid[r] {\\n\\t\\t\\tfor wide := 1; wide < 100; wide++ {\\n\\t\\t\\t\\tif value, ok := calculate(grid, r, c, wide); ok {\\n\\t\\t\\t\\t\\tif value == big1 || value == big2 || value == big3 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif value > big1 {\\n\\t\\t\\t\\t\\t\\tbig1, big2, big3 = value, big1, big2\\n\\t\\t\\t\\t\\t} else if value > big2 {\\n\\t\\t\\t\\t\\t\\tbig2, big3 = value, big2\\n\\t\\t\\t\\t\\t} else if value > big3 {\\n\\t\\t\\t\\t\\t\\tbig3 = value\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tresult := make([]int, 0)\\n\\tif big1 != 0 {\\n\\t\\tresult = append(result, big1)\\n\\t}\\n\\tif big2 != 0 {\\n\\t\\tresult = append(result, big2)\\n\\t}\\n\\tif big3 != 0 {\\n\\t\\tresult = append(result, big3)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc calculate(grid [][]int, row, col, wide int) (int, bool) {\\n\\tif col - wide + 1 < 0 || col + wide - 1 >= len(grid[0]) || row + 2 * wide - 2 >= len(grid) {\\n\\t\\treturn 0, false\\n\\t}\\n\\tif wide == 1 {\\n\\t\\treturn grid[row][col], true\\n\\t}\\n\\ttotal := 0\\n\\tfor i := 0; i < wide-1; i++ {\\n\\t\\ttotal += grid[row+i][col+i]\\n\\t\\ttotal += grid[row+wide-1+i][col+wide-1-i]\\n\\t\\ttotal += grid[row+wide+wide-2-i][col-i]\\n\\t\\ttotal += grid[row+wide-1-i][col-wide+1+i]\\n\\t}\\n\\treturn total, true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536752,
                "title": "java-solution-easy-to-understand",
                "content": "```class Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int maxLen = grid.length / 2;\\n        PriorityQueue<Integer> pq = new PriorityQueue();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (!set.contains(grid[i][j])) {\\n                    set.add(grid[i][j]);\\n                    pq.add(grid[i][j]);\\n                }\\n                if (pq.size() > 3) {\\n                    pq.poll();\\n                }\\n                for (int k = 1; k <= maxLen && i >= k && j >= k && i + k < grid.length && j + k < grid[0].length; k++) {\\n                    int sum = getSum(grid, i, j, k);\\n                    if (!set.contains(sum)) {\\n                        set.add(sum);\\n                        pq.add(sum);\\n                    }\\n                    if (pq.size() > 3) {\\n                        pq.poll();\\n                    }\\n                }\\n            }\\n        }\\n        int[] threeMaxSums = new int[pq.size()];\\n        int pos = pq.size() - 1;\\n        while (!pq.isEmpty()) {\\n            threeMaxSums[pos] = pq.poll();\\n            pos--;\\n        }\\n        return threeMaxSums;\\n    }\\n    \\n    public int getSum(int[][] grid, int i, int j, int k) {\\n        int count = 0;\\n        for (int l = 0; l < k + 1; l++) {\\n            count += grid[i + l][j - k + l] + grid[i + l][j + k - l] + grid[i - l][j - k + l] + grid[i - l][j + k - l];\\n        }\\n        count -= grid[i + k][j] + grid[i - k][j] + grid[i][j + k] + grid[i][j - k];\\n        return count;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int maxLen = grid.length / 2;\\n        PriorityQueue<Integer> pq = new PriorityQueue();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (!set.contains(grid[i][j])) {\\n                    set.add(grid[i][j]);\\n                    pq.add(grid[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1468403,
                "title": "python3-iterate-over-all-cells-treating-them-as-top-vertex-of-rhombus",
                "content": "class Solution:\\n\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calculateSum(l,r,u,d):\\n            sums,expand=0,True\\n            c1=c2=(l+r)//2\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sums+=grid[row][c1]\\n                else:\\n                    sums+=grid[row][c1]+grid[row][c2]\\n                if c1==l:\\n                    expand=False\\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sums\\n        \\n        m,n=len(grid),len(grid[0])\\n        li=[]\\n        tempSum=0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<n and d<m:\\n                    tempSum=calculateSum(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if tempSum not in li:\\n                        if len(li)<3:\\n                            heapq.heappush(li,tempSum)\\n                        elif tempSum>li[0]:\\n                            heapq.heappop(li)\\n                            heapq.heappush(li,tempSum)\\n        \\n        return sorted(li,reverse=True)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calculateSum(l,r,u,d):\\n            sums,expand=0,True\\n            c1=c2=(l+r)//2\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sums+=grid[row][c1]\\n                else:\\n                    sums+=grid[row][c1]+grid[row][c2]\\n                if c1==l:\\n                    expand=False\\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sums\\n        \\n        m,n=len(grid),len(grid[0])\\n        li=[]\\n        tempSum=0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<n and d<m:\\n                    tempSum=calculateSum(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if tempSum not in li:\\n                        if len(li)<3:\\n                            heapq.heappush(li,tempSum)\\n                        elif tempSum>li[0]:\\n                            heapq.heappop(li)\\n                            heapq.heappush(li,tempSum)\\n        \\n        return sorted(li,reverse=True)",
                "codeTag": "Java"
            },
            {
                "id": 1463534,
                "title": "python3-passes-116-117-cases-please-help",
                "content": "Hi! My code passes 116/117 cases. I guess it\\'d be considered brute force.\\n\\nThe code at any given cell in the grid calculates all the rhombuses that can be made around that point.\\n\\nTest case input:\\n```\\n[[36240,48571,27490,60162,40204,50509,15320,42101,77019,9805,98928,2042,5848,93087,2764,47869,33723,66911,42230,23825,2054,47527,63422,90294,3422,37587,5535,50312,2420,55972,74213,21803,68059,48566,99041,2202,8970,63132,74608,83637,99211,55109],[1040,31600,34922,13026,82358,59800,20400,78747,58747,20472,9464,11540,56766,12329,43511,54906,44902,26442,78256,4352,59283,23708,97711,2292,88767,65648,61017,85166,85968,12111,42539,54422,62539,57289,32999,39349,11055,99079,35112,34942,67459,52346],[35704,89140,24275,54200,5306,72870,61281,34392,36722,43914,68899,83381,70549,13586,7643,95877,83532,61617,20276,52050,65049,90193,70080,86869,47584,93763,90814,5030,8337,49767,71713,6820,82537,83757,11443,29829,88287,83295,23362,78250,45930,3426],[92722,37999,94677,73634,71863,69121,78417,65878,80397,93327,92222,59385,21091,15142,11578,73837,64437,94523,56408,12058,18710,56836,2064,34689,12538,69190,13809,22399,73505,70141,88834,12034,90801,16011,87870,45371,49551,57316,50891,2613,98999,86617],[8318,29376,99217,13935,66104,49447,12245,30647,48786,8122,5083,291,59596,84698,48356,50774,48154,80104,25768,94651,85878,60158,21878,27600,79397,58174,79624,73785,93861,36046,45429,13183,29430,86366,85764,56383,58617,56126,96613,37411,83208,39342],[68120,97199,52652,5678,23603,71864,11569,15879,5552,25338,25944,39091,5221,53057,44218,21960,61320,23254,72164,61883,18699,58334,7006,56373,4664,86053,77569,53558,86126,24206,39809,35413,72461,63615,93774,67613,84307,1836,79669,61014,81274,54674],[77300,77140,40907,97722,89128,17007,51848,47024,9764,43068,82262,19335,55964,18294,11310,13167,53846,78534,58332,25147,50750,35832,75082,95790,66361,20086,56389,77485,20293,91672,53245,15882,21742,71672,70833,4142,65389,70260,54708,70017,17929,32641],[32881,35838,45013,92446,48958,33926,81036,87635,63370,42598,11663,98862,24911,36648,57404,6477,3005,51651,95662,43094,4266,4964,72556,27319,88135,64313,5286,23902,54141,48421,90531,45611,48083,23942,90493,87395,50718,59057,69568,16293,8102,89775],[79302,89523,6985,3507,36702,45028,80238,91260,28379,93840,64792,3971,75594,51157,65153,3362,14172,27826,24881,28707,96827,30175,39380,86285,86960,19456,91147,2309,97618,35609,29449,60472,9419,95747,19351,67691,34361,21784,32004,25005,75022,77945],[26808,18852,56279,93416,31014,67510,67659,90872,57975,1335,59989,33583,14919,50181,19164,29600,97100,29671,63929,22585,11047,31024,96684,73843,63290,246,46297,29080,91427,69999,17127,33892,11231,62669,21735,73378,23797,25906,40538,99561,2414,94879],[42554,12653,35022,79649,4130,5492,57954,73142,38149,39544,12278,48076,63129,57540,25172,30967,18620,1460,4608,52417,1573,50437,29897,96893,87106,95910,78178,46361,76415,10202,44297,6952,21756,38573,47334,29555,65907,77288,58226,49790,38590,42884],[96589,24854,57964,50845,37537,57204,24956,72357,73980,77569,2655,90559,48420,5096,56260,85576,64680,5,13501,83607,40359,56414,81284,69861,51859,93054,89896,58016,29394,47356,73161,6687,24787,6381,86269,79803,65824,79543,90751,69919,42857,58466],[30196,31830,58028,66603,62045,87695,74325,2973,19902,3035,36245,34424,56814,46791,71449,25809,60418,82327,24611,66623,84292,75983,41674,825,80061,43090,47768,20570,85088,38011,35727,77088,71042,25909,24016,19413,98034,1913,63045,69495,61770,44372],[21845,63032,44268,1090,3051,85020,15562,59370,48255,35076,20100,26030,26980,30455,45339,96697,135,61032,69035,55445,29188,69168,43385,47799,19993,17206,60950,88549,73864,64713,49729,23276,28560,79100,52459,82316,48067,10235,32917,33470,80652,30337],[23994,28119,75877,43465,57445,85179,97854,23796,64685,6246,2475,29514,59434,81390,17119,41515,81745,81273,41078,42848,14385,63788,24869,97924,66957,50769,84264,92013,7556,20790,27159,88085,66675,40583,49363,99345,4606,69340,36004,56774,17883,84265],[49557,32279,87024,17161,45931,41079,91936,73073,96501,55368,70868,48433,88385,81033,17949,38501,92352,17745,14265,42419,10666,39443,76348,33672,71930,8669,46201,75239,22464,36131,44531,94547,14511,25614,60854,52768,41494,81581,69313,28995,79753,36794],[18737,82859,16620,45595,84826,58583,27703,54143,82141,65064,75734,79490,3627,41219,42711,46767,64930,39041,93374,22394,93264,16315,28412,88164,57995,9111,28498,51157,96382,88747,22780,45999,57920,51675,2473,34068,96541,57586,87275,34124,87123,50930],[93041,17820,37823,35416,69473,2469,50123,6011,23794,16426,3892,15319,86658,17800,61762,66789,60318,27551,26071,55937,53949,82141,80266,76650,51360,25967,97103,56904,81123,50788,39314,47748,83644,26171,79645,93206,38435,1297,68768,37963,39738,30305],[86284,30978,73784,70964,38254,96097,40908,68999,49195,7210,90361,71733,50936,54231,72373,26697,36144,64393,15197,50008,59629,7564,62989,89738,79372,60340,7417,88339,85545,76800,16103,90729,25392,31341,83774,11637,26298,37658,10564,19850,54609,70093],[11395,40099,93599,99242,17373,97536,11119,27663,87075,90280,87325,47637,6294,67306,80978,62512,72410,32505,79685,6910,38085,46877,27628,42307,19632,8130,36459,18046,66016,19661,20667,33527,19734,91793,33779,55326,9134,7962,86523,63650,65911,22978],[26039,54161,46435,96872,64475,90986,16090,12524,97148,73847,22244,89350,25573,14647,56038,689,72507,88801,73397,28700,81350,29413,50364,19160,27722,93211,32116,11309,31627,36239,27910,87175,86575,66227,83721,26564,47285,65339,19849,31053,26174,28383],[23173,11867,35677,27438,69323,95732,44756,35635,66078,22046,939,43435,25603,21950,42655,52069,92138,59976,90160,86940,76158,50236,80359,27314,33571,60043,89778,31786,27526,44957,91524,35806,22220,28679,92492,43984,67829,3336,58305,61607,9802,77613],[52369,25849,81431,95384,41983,33289,81652,59973,38571,71470,36258,16420,11873,6581,9315,58169,91777,36109,14559,34834,44297,19351,8115,7029,24347,96815,8043,31486,98053,17387,89869,83292,88532,755,17955,32382,93513,77111,91469,94820,36234,17524],[52964,11611,18519,2780,95207,39394,770,89120,81579,41649,35710,78853,28114,88316,17804,4554,31205,4177,87678,93701,11849,85569,24485,94833,10723,79787,72224,90971,56295,37832,52323,52118,10957,40120,44235,67640,79291,18157,34860,20087,45395,26642],[11030,42923,40492,6954,64226,34145,76203,54830,1934,15851,71088,50198,86672,85675,40693,29353,33766,57441,73316,11573,13473,42584,38188,81587,41052,98810,40432,65200,53644,471,29250,344,97736,31681,14138,49690,55027,32612,20213,22836,35769,34040],[80474,9105,10533,19897,1128,71622,83060,81897,43106,87263,85160,7421,92309,22073,93706,99577,41020,39588,39228,45373,35927,12928,19274,63113,94472,60071,63280,62412,60477,47039,84557,31157,18685,90684,46755,75592,53540,20621,12554,77625,77427,51796],[99225,55904,58913,27553,51675,41185,45490,15834,17059,81377,21253,82877,80980,34049,31712,98841,44747,34155,46409,36962,75362,16116,44473,55919,94104,80899,5656,3999,16996,77776,80845,3064,17135,22130,38677,22876,24101,77539,96823,31693,22145,77217],[80798,46928,90,46160,70418,63411,44044,59787,22275,9728,69409,97205,86944,36526,34257,39331,89572,93128,88466,31879,16631,17180,22589,26246,12855,39784,76189,26099,51132,63681,4759,35266,91525,33493,27787,10626,68192,31026,84083,92625,28865,45401],[86234,85004,28642,58488,76812,64896,65546,22829,30305,77262,67407,35487,59652,16399,78492,51422,48703,30322,71903,54352,3085,50484,41200,19173,14959,85275,34604,93426,648,95661,53032,33825,98176,61224,38685,14091,92944,25519,47708,79337,3200,87164],[1268,19692,86723,25772,12819,69150,20155,99018,61564,79214,92623,52370,57598,94080,75748,90457,50999,45149,17395,26656,22972,33960,1925,40751,50949,81628,24136,43540,19692,53030,78593,90785,78804,60977,81681,24717,42687,30429,66084,56565,44650,66696],[67056,92182,94300,57902,95920,81574,68442,37001,68977,31854,74537,24443,91895,4928,83915,95163,1336,36124,43856,62439,65558,7371,46986,11931,34266,60154,23548,32104,27567,80511,33636,45212,83581,80674,88683,80090,11541,30388,6884,70392,14737,93295],[3821,47253,78528,13320,53349,19323,17685,12580,95472,50138,33050,75447,74424,38545,17237,19767,20191,30619,85127,94317,40955,24486,93550,83530,20170,58586,50108,34030,11407,72846,27326,16079,33373,16540,18217,1626,24216,28822,89467,86521,37079,25762],[79536,13578,73135,755,12177,73833,97374,66936,2032,2215,81746,54222,65177,65827,19913,69887,796,18393,55486,70282,423,23601,55998,52104,89452,40835,75408,68013,14829,92697,11616,51756,4263,94333,45691,30244,58847,37924,44839,32936,90963,12801],[53500,58416,90359,38077,93916,22183,39517,36702,93686,44422,11247,65553,66669,25317,93321,91809,14432,76029,64550,74529,47212,49594,27317,89411,16521,32740,62255,71402,65090,73762,67566,1543,64715,80246,97938,71122,47174,70236,74273,8899,3837,41175],[24528,19121,70558,31712,53290,93907,29900,9828,77759,17083,63818,27207,13615,77182,4135,37696,73611,7591,32617,84649,37055,66928,48511,74678,20347,69157,26469,33865,49788,42647,75178,12142,18744,43428,25584,10689,99116,96436,59970,90832,25112,25262],[41759,69031,35452,3828,43760,55304,45701,75956,48754,70551,21817,66660,76613,46607,14581,41753,2086,86487,43244,84903,68918,22931,17670,534,2391,59537,11093,31712,46066,4908,27120,70909,40598,62115,85057,35816,87664,48564,96576,30068,51487,76794],[73512,23219,43116,8134,22743,30395,5563,34053,48673,27298,51829,81878,53615,45459,2906,24641,8344,56696,86438,30986,45035,12765,97880,5027,49177,97961,13930,70650,97998,89261,65959,32741,70458,24774,46768,71643,77253,67565,52021,69914,48387,67366],[54707,42019,54674,13308,43074,27833,74210,65897,97599,4984,75442,67038,76462,13998,51030,49165,79887,40973,61358,3370,94872,40714,56637,4010,72201,22496,71334,37354,94100,89994,70793,68434,16745,14646,68680,99055,80384,67118,17714,55186,64417,76353],[72387,80995,1937,40083,82586,74291,91856,25072,18583,56958,9412,89359,41412,65026,51587,99435,30618,81933,26447,39617,63769,73641,52215,18151,87817,36749,86526,81736,98888,44071,42621,10610,94075,83227,43018,66592,17820,11259,40247,41302,96749,75769],[79048,40978,87094,43149,83485,61412,26245,13018,28999,2420,50839,99598,42774,76219,74776,13495,80177,33924,38580,41647,62880,83886,33295,31309,96719,82987,95793,78357,93671,18739,12489,3529,4031,92113,1589,73861,85397,39600,69446,10175,6974,98549],[26351,53499,49201,99189,54334,21742,51542,35429,79134,20060,37432,23230,3396,12215,98853,19718,41840,97011,11862,74418,36109,3301,22463,82922,41751,62639,34932,23367,78356,89790,52605,14615,70867,73346,51627,94906,76350,55466,25418,85179,42642,2037]]\\n```\\n\\nMy output:\\n```\\n[4052871,3882896,3877586]\\n```\\n\\nExpected output:\\n```\\n[4052871,3922280,3882896]\\n```\\n\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        run = set()\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        # Loop through every grid item\\n        for i in range(n):\\n            for j in range(m):\\n                # Calculate the max rhombus around the current grid item\\n                res = self.count(grid, i, j, len(grid), len(grid[0]))\\n                # Add to list of sums\\n                run.add(res)\\n        \\n        res = []\\n        # Stupid way of getting biggest 3,\\n        # a heap would work better but the problem\\n        # isn\\'t here\\n        return sorted(run, reverse=True)[:3]\\n    \\n    # This function calculates the width of the largest\\n    # rhombus that can be made around the given grid row and col.\\n    \\n    # Then it calculates each rhombus that can be made up until that max width,\\n    # keeping track of what the largest sum is amongst all the created rhombuses,\\n    # and returns the max\\n    def count(self, grid, row, col, n, m):\\n        # Calculate how wide the largest rhombus can be.\\n        # it is the smaller number of how close are you to the \\n        # nearest edge of row, or nearest edge of column\\n        distance = min(n - row, m - col)\\n        \\n        # set the max perimeter sum to the current number\\n        global_max = grid[row][col]\\n        \\n        # From 1 to the width of the biggest rhombus that can be made\\n        for i in range(1, distance):\\n            # check 4 corners, if not 4 corners, no rhombus can be made at current distance\\n            if row - i >= 0 and row + i < n and col - i >= 0 and col + i < m:\\n                top_point = row - i\\n                bottom_point = row + i\\n                \\n                # Add up the vertices (points)\\n                local_max = grid[row-i][col] + grid[row+i][col] + grid[row][col-i] + grid[row][col+i]\\n                \\n                # For 1 up to the width of the current rhombus,\\n                # add up the perimeter\\n                for j in range(1,i):\\n                    local_max += grid[top_point + j][col - j] + grid[top_point + j][col+j]\\n                    local_max += grid[bottom_point - j][col-j] + grid[bottom_point - j][col + j]\\n                \\n                # Save the bigger perimeter sum\\n                global_max = max(global_max, local_max)\\n            else:\\n                break\\n        return global_max\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n[[36240,48571,27490,60162,40204,50509,15320,42101,77019,9805,98928,2042,5848,93087,2764,47869,33723,66911,42230,23825,2054,47527,63422,90294,3422,37587,5535,50312,2420,55972,74213,21803,68059,48566,99041,2202,8970,63132,74608,83637,99211,55109],[1040,31600,34922,13026,82358,59800,20400,78747,58747,20472,9464,11540,56766,12329,43511,54906,44902,26442,78256,4352,59283,23708,97711,2292,88767,65648,61017,85166,85968,12111,42539,54422,62539,57289,32999,39349,11055,99079,35112,34942,67459,52346],[35704,89140,24275,54200,5306,72870,61281,34392,36722,43914,68899,83381,70549,13586,7643,95877,83532,61617,20276,52050,65049,90193,70080,86869,47584,93763,90814,5030,8337,49767,71713,6820,82537,83757,11443,29829,88287,83295,23362,78250,45930,3426],[92722,37999,94677,73634,71863,69121,78417,65878,80397,93327,92222,59385,21091,15142,11578,73837,64437,94523,56408,12058,18710,56836,2064,34689,12538,69190,13809,22399,73505,70141,88834,12034,90801,16011,87870,45371,49551,57316,50891,2613,98999,86617],[8318,29376,99217,13935,66104,49447,12245,30647,48786,8122,5083,291,59596,84698,48356,50774,48154,80104,25768,94651,85878,60158,21878,27600,79397,58174,79624,73785,93861,36046,45429,13183,29430,86366,85764,56383,58617,56126,96613,37411,83208,39342],[68120,97199,52652,5678,23603,71864,11569,15879,5552,25338,25944,39091,5221,53057,44218,21960,61320,23254,72164,61883,18699,58334,7006,56373,4664,86053,77569,53558,86126,24206,39809,35413,72461,63615,93774,67613,84307,1836,79669,61014,81274,54674],[77300,77140,40907,97722,89128,17007,51848,47024,9764,43068,82262,19335,55964,18294,11310,13167,53846,78534,58332,25147,50750,35832,75082,95790,66361,20086,56389,77485,20293,91672,53245,15882,21742,71672,70833,4142,65389,70260,54708,70017,17929,32641],[32881,35838,45013,92446,48958,33926,81036,87635,63370,42598,11663,98862,24911,36648,57404,6477,3005,51651,95662,43094,4266,4964,72556,27319,88135,64313,5286,23902,54141,48421,90531,45611,48083,23942,90493,87395,50718,59057,69568,16293,8102,89775],[79302,89523,6985,3507,36702,45028,80238,91260,28379,93840,64792,3971,75594,51157,65153,3362,14172,27826,24881,28707,96827,30175,39380,86285,86960,19456,91147,2309,97618,35609,29449,60472,9419,95747,19351,67691,34361,21784,32004,25005,75022,77945],[26808,18852,56279,93416,31014,67510,67659,90872,57975,1335,59989,33583,14919,50181,19164,29600,97100,29671,63929,22585,11047,31024,96684,73843,63290,246,46297,29080,91427,69999,17127,33892,11231,62669,21735,73378,23797,25906,40538,99561,2414,94879],[42554,12653,35022,79649,4130,5492,57954,73142,38149,39544,12278,48076,63129,57540,25172,30967,18620,1460,4608,52417,1573,50437,29897,96893,87106,95910,78178,46361,76415,10202,44297,6952,21756,38573,47334,29555,65907,77288,58226,49790,38590,42884],[96589,24854,57964,50845,37537,57204,24956,72357,73980,77569,2655,90559,48420,5096,56260,85576,64680,5,13501,83607,40359,56414,81284,69861,51859,93054,89896,58016,29394,47356,73161,6687,24787,6381,86269,79803,65824,79543,90751,69919,42857,58466],[30196,31830,58028,66603,62045,87695,74325,2973,19902,3035,36245,34424,56814,46791,71449,25809,60418,82327,24611,66623,84292,75983,41674,825,80061,43090,47768,20570,85088,38011,35727,77088,71042,25909,24016,19413,98034,1913,63045,69495,61770,44372],[21845,63032,44268,1090,3051,85020,15562,59370,48255,35076,20100,26030,26980,30455,45339,96697,135,61032,69035,55445,29188,69168,43385,47799,19993,17206,60950,88549,73864,64713,49729,23276,28560,79100,52459,82316,48067,10235,32917,33470,80652,30337],[23994,28119,75877,43465,57445,85179,97854,23796,64685,6246,2475,29514,59434,81390,17119,41515,81745,81273,41078,42848,14385,63788,24869,97924,66957,50769,84264,92013,7556,20790,27159,88085,66675,40583,49363,99345,4606,69340,36004,56774,17883,84265],[49557,32279,87024,17161,45931,41079,91936,73073,96501,55368,70868,48433,88385,81033,17949,38501,92352,17745,14265,42419,10666,39443,76348,33672,71930,8669,46201,75239,22464,36131,44531,94547,14511,25614,60854,52768,41494,81581,69313,28995,79753,36794],[18737,82859,16620,45595,84826,58583,27703,54143,82141,65064,75734,79490,3627,41219,42711,46767,64930,39041,93374,22394,93264,16315,28412,88164,57995,9111,28498,51157,96382,88747,22780,45999,57920,51675,2473,34068,96541,57586,87275,34124,87123,50930],[93041,17820,37823,35416,69473,2469,50123,6011,23794,16426,3892,15319,86658,17800,61762,66789,60318,27551,26071,55937,53949,82141,80266,76650,51360,25967,97103,56904,81123,50788,39314,47748,83644,26171,79645,93206,38435,1297,68768,37963,39738,30305],[86284,30978,73784,70964,38254,96097,40908,68999,49195,7210,90361,71733,50936,54231,72373,26697,36144,64393,15197,50008,59629,7564,62989,89738,79372,60340,7417,88339,85545,76800,16103,90729,25392,31341,83774,11637,26298,37658,10564,19850,54609,70093],[11395,40099,93599,99242,17373,97536,11119,27663,87075,90280,87325,47637,6294,67306,80978,62512,72410,32505,79685,6910,38085,46877,27628,42307,19632,8130,36459,18046,66016,19661,20667,33527,19734,91793,33779,55326,9134,7962,86523,63650,65911,22978],[26039,54161,46435,96872,64475,90986,16090,12524,97148,73847,22244,89350,25573,14647,56038,689,72507,88801,73397,28700,81350,29413,50364,19160,27722,93211,32116,11309,31627,36239,27910,87175,86575,66227,83721,26564,47285,65339,19849,31053,26174,28383],[23173,11867,35677,27438,69323,95732,44756,35635,66078,22046,939,43435,25603,21950,42655,52069,92138,59976,90160,86940,76158,50236,80359,27314,33571,60043,89778,31786,27526,44957,91524,35806,22220,28679,92492,43984,67829,3336,58305,61607,9802,77613],[52369,25849,81431,95384,41983,33289,81652,59973,38571,71470,36258,16420,11873,6581,9315,58169,91777,36109,14559,34834,44297,19351,8115,7029,24347,96815,8043,31486,98053,17387,89869,83292,88532,755,17955,32382,93513,77111,91469,94820,36234,17524],[52964,11611,18519,2780,95207,39394,770,89120,81579,41649,35710,78853,28114,88316,17804,4554,31205,4177,87678,93701,11849,85569,24485,94833,10723,79787,72224,90971,56295,37832,52323,52118,10957,40120,44235,67640,79291,18157,34860,20087,45395,26642],[11030,42923,40492,6954,64226,34145,76203,54830,1934,15851,71088,50198,86672,85675,40693,29353,33766,57441,73316,11573,13473,42584,38188,81587,41052,98810,40432,65200,53644,471,29250,344,97736,31681,14138,49690,55027,32612,20213,22836,35769,34040],[80474,9105,10533,19897,1128,71622,83060,81897,43106,87263,85160,7421,92309,22073,93706,99577,41020,39588,39228,45373,35927,12928,19274,63113,94472,60071,63280,62412,60477,47039,84557,31157,18685,90684,46755,75592,53540,20621,12554,77625,77427,51796],[99225,55904,58913,27553,51675,41185,45490,15834,17059,81377,21253,82877,80980,34049,31712,98841,44747,34155,46409,36962,75362,16116,44473,55919,94104,80899,5656,3999,16996,77776,80845,3064,17135,22130,38677,22876,24101,77539,96823,31693,22145,77217],[80798,46928,90,46160,70418,63411,44044,59787,22275,9728,69409,97205,86944,36526,34257,39331,89572,93128,88466,31879,16631,17180,22589,26246,12855,39784,76189,26099,51132,63681,4759,35266,91525,33493,27787,10626,68192,31026,84083,92625,28865,45401],[86234,85004,28642,58488,76812,64896,65546,22829,30305,77262,67407,35487,59652,16399,78492,51422,48703,30322,71903,54352,3085,50484,41200,19173,14959,85275,34604,93426,648,95661,53032,33825,98176,61224,38685,14091,92944,25519,47708,79337,3200,87164],[1268,19692,86723,25772,12819,69150,20155,99018,61564,79214,92623,52370,57598,94080,75748,90457,50999,45149,17395,26656,22972,33960,1925,40751,50949,81628,24136,43540,19692,53030,78593,90785,78804,60977,81681,24717,42687,30429,66084,56565,44650,66696],[67056,92182,94300,57902,95920,81574,68442,37001,68977,31854,74537,24443,91895,4928,83915,95163,1336,36124,43856,62439,65558,7371,46986,11931,34266,60154,23548,32104,27567,80511,33636,45212,83581,80674,88683,80090,11541,30388,6884,70392,14737,93295],[3821,47253,78528,13320,53349,19323,17685,12580,95472,50138,33050,75447,74424,38545,17237,19767,20191,30619,85127,94317,40955,24486,93550,83530,20170,58586,50108,34030,11407,72846,27326,16079,33373,16540,18217,1626,24216,28822,89467,86521,37079,25762],[79536,13578,73135,755,12177,73833,97374,66936,2032,2215,81746,54222,65177,65827,19913,69887,796,18393,55486,70282,423,23601,55998,52104,89452,40835,75408,68013,14829,92697,11616,51756,4263,94333,45691,30244,58847,37924,44839,32936,90963,12801],[53500,58416,90359,38077,93916,22183,39517,36702,93686,44422,11247,65553,66669,25317,93321,91809,14432,76029,64550,74529,47212,49594,27317,89411,16521,32740,62255,71402,65090,73762,67566,1543,64715,80246,97938,71122,47174,70236,74273,8899,3837,41175],[24528,19121,70558,31712,53290,93907,29900,9828,77759,17083,63818,27207,13615,77182,4135,37696,73611,7591,32617,84649,37055,66928,48511,74678,20347,69157,26469,33865,49788,42647,75178,12142,18744,43428,25584,10689,99116,96436,59970,90832,25112,25262],[41759,69031,35452,3828,43760,55304,45701,75956,48754,70551,21817,66660,76613,46607,14581,41753,2086,86487,43244,84903,68918,22931,17670,534,2391,59537,11093,31712,46066,4908,27120,70909,40598,62115,85057,35816,87664,48564,96576,30068,51487,76794],[73512,23219,43116,8134,22743,30395,5563,34053,48673,27298,51829,81878,53615,45459,2906,24641,8344,56696,86438,30986,45035,12765,97880,5027,49177,97961,13930,70650,97998,89261,65959,32741,70458,24774,46768,71643,77253,67565,52021,69914,48387,67366],[54707,42019,54674,13308,43074,27833,74210,65897,97599,4984,75442,67038,76462,13998,51030,49165,79887,40973,61358,3370,94872,40714,56637,4010,72201,22496,71334,37354,94100,89994,70793,68434,16745,14646,68680,99055,80384,67118,17714,55186,64417,76353],[72387,80995,1937,40083,82586,74291,91856,25072,18583,56958,9412,89359,41412,65026,51587,99435,30618,81933,26447,39617,63769,73641,52215,18151,87817,36749,86526,81736,98888,44071,42621,10610,94075,83227,43018,66592,17820,11259,40247,41302,96749,75769],[79048,40978,87094,43149,83485,61412,26245,13018,28999,2420,50839,99598,42774,76219,74776,13495,80177,33924,38580,41647,62880,83886,33295,31309,96719,82987,95793,78357,93671,18739,12489,3529,4031,92113,1589,73861,85397,39600,69446,10175,6974,98549],[26351,53499,49201,99189,54334,21742,51542,35429,79134,20060,37432,23230,3396,12215,98853,19718,41840,97011,11862,74418,36109,3301,22463,82922,41751,62639,34932,23367,78356,89790,52605,14615,70867,73346,51627,94906,76350,55466,25418,85179,42642,2037]]\\n```\n```\\n[4052871,3882896,3877586]\\n```\n```\\n[4052871,3922280,3882896]\\n```\n```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        run = set()\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        # Loop through every grid item\\n        for i in range(n):\\n            for j in range(m):\\n                # Calculate the max rhombus around the current grid item\\n                res = self.count(grid, i, j, len(grid), len(grid[0]))\\n                # Add to list of sums\\n                run.add(res)\\n        \\n        res = []\\n        # Stupid way of getting biggest 3,\\n        # a heap would work better but the problem\\n        # isn\\'t here\\n        return sorted(run, reverse=True)[:3]\\n    \\n    # This function calculates the width of the largest\\n    # rhombus that can be made around the given grid row and col.\\n    \\n    # Then it calculates each rhombus that can be made up until that max width,\\n    # keeping track of what the largest sum is amongst all the created rhombuses,\\n    # and returns the max\\n    def count(self, grid, row, col, n, m):\\n        # Calculate how wide the largest rhombus can be.\\n        # it is the smaller number of how close are you to the \\n        # nearest edge of row, or nearest edge of column\\n        distance = min(n - row, m - col)\\n        \\n        # set the max perimeter sum to the current number\\n        global_max = grid[row][col]\\n        \\n        # From 1 to the width of the biggest rhombus that can be made\\n        for i in range(1, distance):\\n            # check 4 corners, if not 4 corners, no rhombus can be made at current distance\\n            if row - i >= 0 and row + i < n and col - i >= 0 and col + i < m:\\n                top_point = row - i\\n                bottom_point = row + i\\n                \\n                # Add up the vertices (points)\\n                local_max = grid[row-i][col] + grid[row+i][col] + grid[row][col-i] + grid[row][col+i]\\n                \\n                # For 1 up to the width of the current rhombus,\\n                # add up the perimeter\\n                for j in range(1,i):\\n                    local_max += grid[top_point + j][col - j] + grid[top_point + j][col+j]\\n                    local_max += grid[bottom_point - j][col-j] + grid[bottom_point - j][col + j]\\n                \\n                # Save the bigger perimeter sum\\n                global_max = max(global_max, local_max)\\n            else:\\n                break\\n        return global_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461931,
                "title": "plz-tell-whats-the-error-in-my-python-code",
                "content": "It works for couple of test cases\\n\\nLOGIC- \\n0 1 2 i 4 5 6\\n0 1 i 3 i 5 6\\n0 i 2 3 4 i 6\\ni 1 2 - 4 5 i\\n0 i 2 3 4 i 6\\n0 1 i 3 i 5 6\\n0 1 2 i 4 5 6\\n\\ncenter = 3,3\\npoints = (0,3), (1,2), (2,1), (3,0), (4,1), (5,2), (6,3), (5,4), (4,5), (3,6), (2,5), (1,4)\\n         <-------+1,-1------------>  <------+1,+1-------> <-------- -1,+1----> <--- -1,-1-->\\nsize = 3\\n\\n\\n```\\nclass Solution:\\n    def getBiggestThree(self, grid):\\n        grid_sum = []\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                size = 1\\n                while size+i<n and size+j<m and size<=min(i,j)+1:\\n                    total = 0 # i=1,j=1 and size=1\\n                    ith = i-size # ith = 0\\n                    jth = j # jth = 1\\n                    #top to left\\n                    while ith<=i and jth>=j-size: # ith<=1 and jth>=0\\n                        total += grid[ith][jth] # adds the top\\n                        #print(\"1\")\\n                        ith += 1 # ith = 1\\n                        jth -= 1 # jth = 0\\n                    ith -= 1\\n                    jth += 1\\n                    #left to bottom\\n                    while ith<=i+size and jth<=j: # ith<=2 and jth<=1\\n                        total += grid[ith][jth]\\n                        #print(\"2\")\\n                        ith += 1 # \\n                        jth += 1\\n                    ith -= 1\\n                    jth -= 1\\n                    #bottom to right\\n                    while ith<=i+size and jth<=j+size:\\n                        total += grid[ith][jth]\\n                        #print(\"3\")\\n                        ith -= 1\\n                        jth += 1\\n                    ith += 1\\n                    jth -= 1\\n                    #right to top\\n                    while ith>=i-size and jth>=j:\\n                        total += grid[ith][jth]\\n                        #print(\"4\")\\n                        ith -= 1\\n                        jth -= 1\\n                    grid_sum.append(total//2)\\n                    size+=1\\n        grid_sum.sort()\\n        if len(grid_sum)>=3:\\n            return grid_sum[-1:-4:-1]\\n        else:\\n            max_three= []\\n            for i in grid:\\n                for j in i:\\n                    max_three.append(j)\\n            remaining = 3-len(grid_sum)\\n            max_three.sort()\\n            for i in max_three[-remaining:]:\\n                grid_sum.append(i)\\n            return grid_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid):\\n        grid_sum = []\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                size = 1\\n                while size+i<n and size+j<m and size<=min(i,j)+1:\\n                    total = 0 # i=1,j=1 and size=1\\n                    ith = i-size # ith = 0\\n                    jth = j # jth = 1\\n                    #top to left\\n                    while ith<=i and jth>=j-size: # ith<=1 and jth>=0\\n                        total += grid[ith][jth] # adds the top\\n                        #print(\"1\")\\n                        ith += 1 # ith = 1\\n                        jth -= 1 # jth = 0\\n                    ith -= 1\\n                    jth += 1\\n                    #left to bottom\\n                    while ith<=i+size and jth<=j: # ith<=2 and jth<=1\\n                        total += grid[ith][jth]\\n                        #print(\"2\")\\n                        ith += 1 # \\n                        jth += 1\\n                    ith -= 1\\n                    jth -= 1\\n                    #bottom to right\\n                    while ith<=i+size and jth<=j+size:\\n                        total += grid[ith][jth]\\n                        #print(\"3\")\\n                        ith -= 1\\n                        jth += 1\\n                    ith += 1\\n                    jth -= 1\\n                    #right to top\\n                    while ith>=i-size and jth>=j:\\n                        total += grid[ith][jth]\\n                        #print(\"4\")\\n                        ith -= 1\\n                        jth -= 1\\n                    grid_sum.append(total//2)\\n                    size+=1\\n        grid_sum.sort()\\n        if len(grid_sum)>=3:\\n            return grid_sum[-1:-4:-1]\\n        else:\\n            max_three= []\\n            for i in grid:\\n                for j in i:\\n                    max_three.append(j)\\n            remaining = 3-len(grid_sum)\\n            max_three.sort()\\n            for i in max_three[-remaining:]:\\n                grid_sum.append(i)\\n            return grid_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454741,
                "title": "c-easy-to-understand-w-helper-functions-brute-force",
                "content": "Commented code has general idea\\n\\n```\\nclass Solution {\\npublic:\\n    struct coord {\\n        int x, y;\\n    };\\n    \\n    // for each square\\n    //    try increasingly bigger valid rhombus, if sum > 3rd biggest, add to set \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> nums;\\n        \\n        for (int i = 0; i < grid.size(); i++) { \\n            for (int j = 0; j < grid[0].size(); j++) {\\n                int area = 0;\\n                int rhomb_sum = 0;\\n                \\n                while (validRhombus(i, j, area, grid)) {\\n                    rhomb_sum = computeRhombusSum(i, j, area, grid);\\n                    \\n                    if (nums.size() < 3 || rhomb_sum > *nums.begin()) {\\n                        nums.insert(rhomb_sum);\\n                        \\n                        if (nums.size() > 3)\\n                            nums.erase(nums.begin());\\n                    }\\n                    \\n                    area++;\\n                }\\n            }\\n        }\\n        \\n        return vector<int>(nums.rbegin(), nums.rend());\\n    }\\n    \\n    bool validRhombus(int i, int j, int area, vector<vector<int>>& grid) {\\n        if (i - area < 0 || i + area >= grid.size()) return false;\\n        if (j - area < 0 || j + area >= grid[0].size()) return false;\\n        \\n        return true;\\n    }\\n    \\n    int computeRhombusSum(int x, int y, int area, vector<vector<int>>& grid) {\\n        if (!area) return grid[x][y];\\n        \\n        int sum = 0;\\n        \\n        // start from left and up, compute \\\\ diagonals\\n        //  start from left, down, compute / diagonals \\n        coord left = {x, y - area};  \\n        coord right = {x, y + area};\\n        coord up = {x - area, y};\\n        coord down = {x + area, y};\\n        \\n        for (int i = left.x, j = left.y; i <= down.x && j <= down.y; i++, j++)  {\\n            sum += grid[i][j];\\n        }\\n        \\n        for (int i = up.x, j = up.y; i <= right.x && j <= right.y; i++, j++)  {\\n            sum += grid[i][j];\\n        }\\n        \\n        for (int i = left.x - 1, j = left.y + 1; i > up.x && j < up.y; i--, j++) {\\n            sum += grid[i][j];\\n        }\\n            \\n        for (int i = down.x - 1, j = down.y + 1; i > right.x && j < right.y; i--, j++) {\\n            sum += grid[i][j];\\n        }\\n            \\n        return sum;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct coord {\\n        int x, y;\\n    };\\n    \\n    // for each square\\n    //    try increasingly bigger valid rhombus, if sum > 3rd biggest, add to set \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> nums;\\n        \\n        for (int i = 0; i < grid.size(); i++) { \\n            for (int j = 0; j < grid[0].size(); j++) {\\n                int area = 0;\\n                int rhomb_sum = 0;\\n                \\n                while (validRhombus(i, j, area, grid)) {\\n                    rhomb_sum = computeRhombusSum(i, j, area, grid);\\n                    \\n                    if (nums.size() < 3 || rhomb_sum > *nums.begin()) {\\n                        nums.insert(rhomb_sum);\\n                        \\n                        if (nums.size() > 3)\\n                            nums.erase(nums.begin());\\n                    }\\n                    \\n                    area++;\\n                }\\n            }\\n        }\\n        \\n        return vector<int>(nums.rbegin(), nums.rend());\\n    }\\n    \\n    bool validRhombus(int i, int j, int area, vector<vector<int>>& grid) {\\n        if (i - area < 0 || i + area >= grid.size()) return false;\\n        if (j - area < 0 || j + area >= grid[0].size()) return false;\\n        \\n        return true;\\n    }\\n    \\n    int computeRhombusSum(int x, int y, int area, vector<vector<int>>& grid) {\\n        if (!area) return grid[x][y];\\n        \\n        int sum = 0;\\n        \\n        // start from left and up, compute \\\\ diagonals\\n        //  start from left, down, compute / diagonals \\n        coord left = {x, y - area};  \\n        coord right = {x, y + area};\\n        coord up = {x - area, y};\\n        coord down = {x + area, y};\\n        \\n        for (int i = left.x, j = left.y; i <= down.x && j <= down.y; i++, j++)  {\\n            sum += grid[i][j];\\n        }\\n        \\n        for (int i = up.x, j = up.y; i <= right.x && j <= right.y; i++, j++)  {\\n            sum += grid[i][j];\\n        }\\n        \\n        for (int i = left.x - 1, j = left.y + 1; i > up.x && j < up.y; i--, j++) {\\n            sum += grid[i][j];\\n        }\\n            \\n        for (int i = down.x - 1, j = down.y + 1; i > right.x && j < right.y; i--, j++) {\\n            sum += grid[i][j];\\n        }\\n            \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446969,
                "title": "messy-brute-force-java",
                "content": "```\\nclass Solution {\\n    class Coord{\\n        int x;\\n        int y;\\n        public Coord(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    Set<Integer> totalSet = new HashSet<>();\\n    public int[] getBiggestThree(int[][] grid) {\\n        Queue<Integer> queue = new PriorityQueue<Integer>((a,b) -> a - b);\\n        for(int x=0;x<grid.length;x++){\\n            for(int y=0;y<grid[x].length;y++){\\n                if(!totalSet.contains(grid[x][y])){\\n                    queue.add(grid[x][y]);\\n                }\\n                totalSet.add(grid[x][y]);\\n                if(x - 1 >= 0 && y-1 >= 0 && x + 1<grid.length && y+1 <grid[x].length){\\n                    queue.addAll(calculateSize(grid,x,y));\\n                }\\n                while(queue.size() > 3){\\n                    queue.poll();\\n                }\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        while(!queue.isEmpty()){\\n            result.add(queue.poll());\\n        }\\n        return result.stream().sorted(Collections.reverseOrder()).mapToInt(a -> a).toArray();\\n    }\\n    \\n    public Set<Integer> calculateSize(int[][] grid, int x,int y){\\n        int xSize = Math.min(x,grid.length - x -1);\\n        int ySize = Math.min(y,grid[0].length -y -1);\\n        int size = 0;\\n        int min = Math.min(xSize,ySize);\\n        size = min;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i =1; i<=size;i++){\\n            Coord top = new Coord(x-i,y);\\n            Coord bot = new Coord(x+i,y);\\n            Coord left = new Coord(x,y-i);\\n            Coord right = new Coord(x,y+i);\\n            //top -> right\\n            int sum = 0;\\n            int xIter = top.x;\\n            int yIter = top.y;\\n            for(int j = top.y; j<=top.y + Math.abs(right.y - top.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter++;\\n            }\\n            //top -> left\\n            xIter = top.x;\\n            yIter = top.y;\\n            for(int j = top.y; j<=top.y + Math.abs(left.y - top.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter--;\\n            }\\n            sum -= grid[top.x][top.y];\\n            //left -> bot\\n            xIter = left.x;\\n            yIter = left.y;\\n            for(int j = left.y; j<=left.y + Math.abs(left.y - bot.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter++;\\n            }\\n            sum -= grid[left.x][left.y];\\n            //right -> bot\\n            xIter = right.x;\\n            yIter = right.y;\\n            for(int j = right.y; j<=right.y + Math.abs(right.y - bot.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter--;\\n            }\\n            sum -= grid[bot.x][bot.y];\\n            sum -= grid[right.x][right.y];\\n            if(!totalSet.contains(sum)){\\n                set.add(sum);\\n            }\\n            totalSet.add(sum);\\n        }\\n        return set;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Coord{\\n        int x;\\n        int y;\\n        public Coord(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    Set<Integer> totalSet = new HashSet<>();\\n    public int[] getBiggestThree(int[][] grid) {\\n        Queue<Integer> queue = new PriorityQueue<Integer>((a,b) -> a - b);\\n        for(int x=0;x<grid.length;x++){\\n            for(int y=0;y<grid[x].length;y++){\\n                if(!totalSet.contains(grid[x][y])){\\n                    queue.add(grid[x][y]);\\n                }\\n                totalSet.add(grid[x][y]);\\n                if(x - 1 >= 0 && y-1 >= 0 && x + 1<grid.length && y+1 <grid[x].length){\\n                    queue.addAll(calculateSize(grid,x,y));\\n                }\\n                while(queue.size() > 3){\\n                    queue.poll();\\n                }\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        while(!queue.isEmpty()){\\n            result.add(queue.poll());\\n        }\\n        return result.stream().sorted(Collections.reverseOrder()).mapToInt(a -> a).toArray();\\n    }\\n    \\n    public Set<Integer> calculateSize(int[][] grid, int x,int y){\\n        int xSize = Math.min(x,grid.length - x -1);\\n        int ySize = Math.min(y,grid[0].length -y -1);\\n        int size = 0;\\n        int min = Math.min(xSize,ySize);\\n        size = min;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i =1; i<=size;i++){\\n            Coord top = new Coord(x-i,y);\\n            Coord bot = new Coord(x+i,y);\\n            Coord left = new Coord(x,y-i);\\n            Coord right = new Coord(x,y+i);\\n            //top -> right\\n            int sum = 0;\\n            int xIter = top.x;\\n            int yIter = top.y;\\n            for(int j = top.y; j<=top.y + Math.abs(right.y - top.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter++;\\n            }\\n            //top -> left\\n            xIter = top.x;\\n            yIter = top.y;\\n            for(int j = top.y; j<=top.y + Math.abs(left.y - top.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter--;\\n            }\\n            sum -= grid[top.x][top.y];\\n            //left -> bot\\n            xIter = left.x;\\n            yIter = left.y;\\n            for(int j = left.y; j<=left.y + Math.abs(left.y - bot.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter++;\\n            }\\n            sum -= grid[left.x][left.y];\\n            //right -> bot\\n            xIter = right.x;\\n            yIter = right.y;\\n            for(int j = right.y; j<=right.y + Math.abs(right.y - bot.y);j++){\\n                sum += grid[xIter][yIter];\\n                xIter++;\\n                yIter--;\\n            }\\n            sum -= grid[bot.x][bot.y];\\n            sum -= grid[right.x][right.y];\\n            if(!totalSet.contains(sum)){\\n                set.add(sum);\\n            }\\n            totalSet.add(sum);\\n        }\\n        return set;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439179,
                "title": "java-solution-brute-force-o-mn-min-m-n-using-prefixsum",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        TreeSet<Integer> s = new TreeSet<>(); \\n        int min = 0;\\n        \\n        int[][] diag1 = new int[m][n];\\n        int[][] diag2 = new int[m][n];\\n        for(int i = 0 ; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                diag1[i][j] = grid[i][j];\\n                diag2[i][j] = grid[i][j];\\n                if(i > 0 && j > 0){\\n                    diag2[i][j] += diag2[i - 1][j - 1];\\n                }\\n\\n                if(i > 0 && j < n - 1){\\n                    diag1[i][j] += diag1[i - 1][j + 1];\\n                }\\n                \\n                s.add(grid[i][j]);\\n                if(s.size() > 3){\\n                    s.pollFirst();\\n                }\\n            }\\n           \\n        }\\n\\n        for(int i = 1; i <= Math.min(m,n)/2; i++){\\n            for(int row = 0 ; row + 2*i < m; row++){\\n                for(int col = i; col + i < n; col++){\\n                    \\n                    int sum = 0;\\n                    sum += diag2[row + i][col + i];\\n                    if(row > 0){\\n                        sum -= diag2[row - 1][col - 1];\\n                    }\\n                    \\n                    sum += diag2[row + 2*i][col];\\n                    if(col > i){\\n                       sum -= diag2[row + i - 1][col - i - 1]; \\n                    }\\n                    \\n                    sum += diag1[row + i - 1][col - i + 1];\\n                    sum -= diag1[row][col];\\n                    \\n                    sum += diag1[row + 2*i - 1][col + 1];\\n                    sum -= diag1[row + i][col + i];\\n                    \\n                    s.add(sum);\\n                    if(s.size() > 3){\\n                        s.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        int[] ans = new int[s.size()];\\n\\n        Iterator<Integer> iter = s.iterator();\\n        for(int i = ans.length - 1; i >= 0; i--){\\n            ans[i] = iter.next();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        TreeSet<Integer> s = new TreeSet<>(); \\n        int min = 0;\\n        \\n        int[][] diag1 = new int[m][n];\\n        int[][] diag2 = new int[m][n];\\n        for(int i = 0 ; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                diag1[i][j] = grid[i][j];\\n                diag2[i][j] = grid[i][j];\\n                if(i > 0 && j > 0){\\n                    diag2[i][j] += diag2[i - 1][j - 1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430063,
                "title": "c-solution-brute-force",
                "content": "Constraints are really small and brute force works, yet, its the implementation that really hard to understand.\\nSo what I did was first creating a priority queue (max-heap) and inserting all the single grid values into it (in case rhombus of size 1 is biggest). Now take 3 counters->\\nk = height of the rhombus (which shall be limited to either of the dimensions)\\ni = row counter\\nj = col counter\\nNow, x helps us in traversing the rhombus, Given that the current point is our \\nThis is the starting state of the rhombus:\\nUpper vertex at (i,j+k)\\nLeft vertex at (i+k, j)\\nRight vertex at (i+k, j+2 * k)\\nLower vertex at (i+2 * k, j+k)\\nTraversing in 4 direction and increment the sum.\\nPush sum values in pq and atlast insert those values into a vector, while checking for duplicates and return vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n                pq.push(grid[i][j]);\\n        }\\n        for(int k=1; k<min(m, n); k++) //the height of the rhombus\\n        {\\n            for(int i=0; i+2*k<m; i++)\\n            {\\n                for(int j=0; j+2*k<n;j++)\\n                {\\n                    int sum=0;\\n                    for(int x=0; x<k; x++)\\n                    {\\n                        sum+=grid[i+k-x][j+x]; //left to up\\n                        sum+=grid[i+x][j+k+x]; //top to right\\n                        sum+=grid[i+k+x][j+2*k-x]; //right to down\\n                        sum+=grid[i+2*k-x][j+k-x]; //bottom to left\\n                    }\\n                    pq.push(sum);\\n                }\\n            }\\n        }\\n        vector<int> ret;\\n        while(!pq.empty())\\n        {\\n            if(ret.empty()||ret.back()!=pq.top()) //for distinct values\\n                ret.push_back(pq.top());\\n            if(ret.size()==3)\\n                return ret;\\n            pq.pop();\\n        }\\n        return ret;\\n    }\\n};\\n```\\nTime complexity: O(M * N * min(N, M) ^ 2)\\nSpace complexity: O(M * N * min(N, M))",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n                pq.push(grid[i][j]);\\n        }\\n        for(int k=1; k<min(m, n); k++) //the height of the rhombus\\n        {\\n            for(int i=0; i+2*k<m; i++)\\n            {\\n                for(int j=0; j+2*k<n;j++)\\n                {\\n                    int sum=0;\\n                    for(int x=0; x<k; x++)\\n                    {\\n                        sum+=grid[i+k-x][j+x]; //left to up\\n                        sum+=grid[i+x][j+k+x]; //top to right\\n                        sum+=grid[i+k+x][j+2*k-x]; //right to down\\n                        sum+=grid[i+2*k-x][j+k-x]; //bottom to left\\n                    }\\n                    pq.push(sum);\\n                }\\n            }\\n        }\\n        vector<int> ret;\\n        while(!pq.empty())\\n        {\\n            if(ret.empty()||ret.back()!=pq.top()) //for distinct values\\n                ret.push_back(pq.top());\\n            if(ret.size()==3)\\n                return ret;\\n            pq.pop();\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425724,
                "title": "python-very-simple-check-valid-then-check-4-directions",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        maxWidth = min(len(grid), len(grid[0]))//2\\n        maxSizes = []\\n        \\n        for row in range(len(grid)):\\n\\n            for col in range(len(grid[0])):\\n                    \\n                for dist in range(maxWidth+1):\\n\\n                    rhombus = self.getSize(grid, row, col, dist)\\n                    \\n                    if rhombus > 0:\\n                        \\n                        if rhombus not in maxSizes:\\n                            heapq.heappush(maxSizes, rhombus)\\n\\n                        if len(maxSizes) > 3:\\n                            heapq.heappop(maxSizes)\\n        \\n        res = []\\n        \\n        while maxSizes:\\n            res.append(heapq.heappop(maxSizes))\\n        \\n        return res[::-1]\\n\\n    \\n    def getSize(self, grid, row, col, dist):\\n        \\n        if dist == 0:\\n            return grid[row][col]\\n        \\n        summ = 0\\n        \\n        if col-dist < 0 or col+dist >= len(grid[0]) or row+(2*dist) >= len(grid):\\n            return 0\\n        \\n        for left in range(1, dist+1):\\n            summ += grid[row+left][col-left]\\n        \\n        row += dist\\n        col -= dist\\n        \\n        for bot in range(1, dist+1):\\n            summ += grid[row+bot][col+bot]\\n        \\n        row += dist\\n        col += dist\\n        \\n        for right in range(1, dist+1):\\n            summ += grid[row-right][col+right]\\n        \\n        row -= dist\\n        col += dist\\n        \\n        for top in range(1, dist+1):\\n            summ += grid[row-top][col-top]\\n        \\n        return summ\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        maxWidth = min(len(grid), len(grid[0]))//2\\n        maxSizes = []\\n        \\n        for row in range(len(grid)):\\n\\n            for col in range(len(grid[0])):\\n                    \\n                for dist in range(maxWidth+1):\\n\\n                    rhombus = self.getSize(grid, row, col, dist)\\n                    \\n                    if rhombus > 0:\\n                        \\n                        if rhombus not in maxSizes:\\n                            heapq.heappush(maxSizes, rhombus)\\n\\n                        if len(maxSizes) > 3:\\n                            heapq.heappop(maxSizes)\\n        \\n        res = []\\n        \\n        while maxSizes:\\n            res.append(heapq.heappop(maxSizes))\\n        \\n        return res[::-1]\\n\\n    \\n    def getSize(self, grid, row, col, dist):\\n        \\n        if dist == 0:\\n            return grid[row][col]\\n        \\n        summ = 0\\n        \\n        if col-dist < 0 or col+dist >= len(grid[0]) or row+(2*dist) >= len(grid):\\n            return 0\\n        \\n        for left in range(1, dist+1):\\n            summ += grid[row+left][col-left]\\n        \\n        row += dist\\n        col -= dist\\n        \\n        for bot in range(1, dist+1):\\n            summ += grid[row+bot][col+bot]\\n        \\n        row += dist\\n        col += dist\\n        \\n        for right in range(1, dist+1):\\n            summ += grid[row-right][col+right]\\n        \\n        row -= dist\\n        col += dist\\n        \\n        for top in range(1, dist+1):\\n            summ += grid[row-top][col-top]\\n        \\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403671,
                "title": "swift-elegant-solution-it-has-a-bug-but-i-don-t-rlly-care-tbh-xd-just-giving-the-idea",
                "content": "```\\nfunc getBiggestThree(_ grid: [[Int]]) -> [Int] {\\n    \\n    if grid.isEmpty { return [] }\\n    if grid[0].isEmpty { return [] }\\n    var answer = [0,0,0]\\n    var smallest = 0\\n    \\n    // Grid is not large enough to host a Rhombus\\n    if grid.count < 3 || grid[0].count < 3 {\\n        checkLargestValue(from: grid, &answer)\\n        return returnAnswerWithoutRepetition(answer)\\n    }\\n    \\n    let xMaxValue = grid[0].count - 1\\n    let yMaxValue = grid.count - 1\\n    \\n    for y in 0...yMaxValue {\\n        for x in 0...xMaxValue {\\n            let cellValue = grid[y][x]\\n            if cellValue > smallest {\\n                smallest = addNewAnswer(&answer, cellValue)\\n            }\\n            guard cellCanHostRhombus(at:(x,y), inside: (xMaxValue, yMaxValue)) else { continue }\\n            let size = calculateRhombusSize(origin: (x,y), limits: (xMaxValue, yMaxValue))\\n            let sum = calculateRhombusSum(origin: (x,y), grid: grid, size: size)\\n            if sum > smallest {\\n                smallest = addNewAnswer(&answer, sum)\\n            }\\n        }\\n    }\\n    return returnAnswerWithoutRepetition(answer)\\n}\\n\\n// Check if this cell can be the origin on a Rhombus\\nprivate func cellCanHostRhombus(at coordenates: (x: Int, y: Int), inside limits: (x: Int, y: Int)) -> Bool {\\n    if coordenates.x - 1 < 0 ||\\n       coordenates.x + 1 > limits.x ||\\n       coordenates.y + 2 > limits.y { return false }\\n    return true\\n}\\n\\nprivate func calculateRhombusSize(origin: (x: Int, y: Int), limits: (x: Int, y: Int)) -> Int {\\n    let maxHeight = (limits.y - origin.y)/2\\n    var maxWidth: Int\\n    if origin.x <= limits.x/2 {\\n        maxWidth = origin.x\\n    } else {\\n        maxWidth = limits.x - origin.x\\n    }\\n    return min(maxWidth, maxHeight)\\n}\\n\\nprivate func calculateRhombusSum(origin: (x: Int, y: Int), grid: [[Int]], size: Int) -> Int {\\n    var currentCell = origin\\n    var sum = 0\\n    \\n    // Navigate diagonaly from top left to bottom right\\n    for _ in 1...size {\\n        currentCell.x += 1\\n        currentCell.y += 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    // Navigate diagonaly from top right to bottom left\\n    for _ in 1...size {\\n        currentCell.x -= 1\\n        currentCell.y += 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    // Navigate diagonaly from bottom right to top left\\n    for _ in 1...size {\\n        currentCell.x -= 1\\n        currentCell.y -= 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    // Navigate diagonaly from bottom left to top right\\n    for _ in 1...size {\\n        currentCell.x += 1\\n        currentCell.y -= 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    return sum\\n}\\n\\nprivate func checkLargestValue(from grid: [[Int]], _ answerArr: inout [Int]) {\\n    var smallest = 0\\n    \\n    for arr in grid {\\n        for value in arr {\\n            if value > smallest {\\n                smallest = addNewAnswer(&answerArr, value)\\n            }\\n        }\\n    }\\n}\\n\\nprivate func returnAnswerWithoutRepetition(_ arr: [Int]) -> [Int] {\\n    let set = Set(arr)\\n    var answer = Array(set)\\n    answer.sort(by: {$0 > $1})\\n    return answer\\n}\\n\\n\\n// This is Constant Time because the Array will always have 4 values when sorting\\n// I would implement a maxHeap for an interview (or at least mention it)... but this will do\\nprivate func addNewAnswer(_ arr: inout [Int], _ value: Int) -> Int {\\n    arr.append(value)\\n    arr.sort(by: {$0 > $1})\\n    arr.removeLast()\\n    // This is safe to force unwrap because we know there\\'s 3 always values at this point\\n    return arr.last!\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getBiggestThree(_ grid: [[Int]]) -> [Int] {\\n    \\n    if grid.isEmpty { return [] }\\n    if grid[0].isEmpty { return [] }\\n    var answer = [0,0,0]\\n    var smallest = 0\\n    \\n    // Grid is not large enough to host a Rhombus\\n    if grid.count < 3 || grid[0].count < 3 {\\n        checkLargestValue(from: grid, &answer)\\n        return returnAnswerWithoutRepetition(answer)\\n    }\\n    \\n    let xMaxValue = grid[0].count - 1\\n    let yMaxValue = grid.count - 1\\n    \\n    for y in 0...yMaxValue {\\n        for x in 0...xMaxValue {\\n            let cellValue = grid[y][x]\\n            if cellValue > smallest {\\n                smallest = addNewAnswer(&answer, cellValue)\\n            }\\n            guard cellCanHostRhombus(at:(x,y), inside: (xMaxValue, yMaxValue)) else { continue }\\n            let size = calculateRhombusSize(origin: (x,y), limits: (xMaxValue, yMaxValue))\\n            let sum = calculateRhombusSum(origin: (x,y), grid: grid, size: size)\\n            if sum > smallest {\\n                smallest = addNewAnswer(&answer, sum)\\n            }\\n        }\\n    }\\n    return returnAnswerWithoutRepetition(answer)\\n}\\n\\n// Check if this cell can be the origin on a Rhombus\\nprivate func cellCanHostRhombus(at coordenates: (x: Int, y: Int), inside limits: (x: Int, y: Int)) -> Bool {\\n    if coordenates.x - 1 < 0 ||\\n       coordenates.x + 1 > limits.x ||\\n       coordenates.y + 2 > limits.y { return false }\\n    return true\\n}\\n\\nprivate func calculateRhombusSize(origin: (x: Int, y: Int), limits: (x: Int, y: Int)) -> Int {\\n    let maxHeight = (limits.y - origin.y)/2\\n    var maxWidth: Int\\n    if origin.x <= limits.x/2 {\\n        maxWidth = origin.x\\n    } else {\\n        maxWidth = limits.x - origin.x\\n    }\\n    return min(maxWidth, maxHeight)\\n}\\n\\nprivate func calculateRhombusSum(origin: (x: Int, y: Int), grid: [[Int]], size: Int) -> Int {\\n    var currentCell = origin\\n    var sum = 0\\n    \\n    // Navigate diagonaly from top left to bottom right\\n    for _ in 1...size {\\n        currentCell.x += 1\\n        currentCell.y += 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    // Navigate diagonaly from top right to bottom left\\n    for _ in 1...size {\\n        currentCell.x -= 1\\n        currentCell.y += 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    // Navigate diagonaly from bottom right to top left\\n    for _ in 1...size {\\n        currentCell.x -= 1\\n        currentCell.y -= 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    // Navigate diagonaly from bottom left to top right\\n    for _ in 1...size {\\n        currentCell.x += 1\\n        currentCell.y -= 1\\n        sum += grid[currentCell.y][currentCell.x]\\n    }\\n    \\n    return sum\\n}\\n\\nprivate func checkLargestValue(from grid: [[Int]], _ answerArr: inout [Int]) {\\n    var smallest = 0\\n    \\n    for arr in grid {\\n        for value in arr {\\n            if value > smallest {\\n                smallest = addNewAnswer(&answerArr, value)\\n            }\\n        }\\n    }\\n}\\n\\nprivate func returnAnswerWithoutRepetition(_ arr: [Int]) -> [Int] {\\n    let set = Set(arr)\\n    var answer = Array(set)\\n    answer.sort(by: {$0 > $1})\\n    return answer\\n}\\n\\n\\n// This is Constant Time because the Array will always have 4 values when sorting\\n// I would implement a maxHeap for an interview (or at least mention it)... but this will do\\nprivate func addNewAnswer(_ arr: inout [Int], _ value: Int) -> Int {\\n    arr.append(value)\\n    arr.sort(by: {$0 > $1})\\n    arr.removeLast()\\n    // This is safe to force unwrap because we know there\\'s 3 always values at this point\\n    return arr.last!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398702,
                "title": "java-pre-sum-priorityqueue",
                "content": "```\\nclass Solution \\n{\\n    /*\\n        PriorityQueue + Presum\\n        T -> O(m * n * min(m, n)/2) S -> O(m *n)\\n    */\\n    public int[] getBiggestThree(int[][] grid) \\n    {\\n        int capicity = 3;\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        int m = grid.length, n = grid[0].length;\\n        int[][][] preSum = new int[m][n][2];   // [r][c][0] : bottom-right to top-left diagonal, [r][c][1] : bottom-left to top-right diagonal\\n        int maxLen = Math.min(m, n) / 2;\\n        \\n        // Calculate presum of two diagonals for each point\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                addToMinHeap(minHeap, grid[r][c], capicity);\\n                preSum[r][c][0] += valid(m, n, r-1, c-1) ? grid[r][c] + preSum[r-1][c-1][0] : grid[r][c];\\n                preSum[r][c][1] += valid(m, n, r-1, c+1) ? grid[r][c] + preSum[r-1][c+1][1] : grid[r][c];\\n            }\\n        }\\n        \\n        \\n        // Calculate all possible rhombus for each point\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                for (int l = 1; l <= maxLen; l++)\\n                {\\n                    if (!valid(m, n, r - l, c - l) || !valid(m, n, r - l, c + l) || !valid(m, n, r - 2*l, c))\\n                        break;\\n                    \\n                    int rhombus = preSum[r][c][0] - preSum[r-l][c-l][0];\\n                    rhombus += preSum[r][c][1] - preSum[r-l][c+l][1];\\n                    rhombus += preSum[r-l][c-l][1] - preSum[r-2*l][c][1];\\n                    rhombus += preSum[r-l][c+l][0] - preSum[r-2*l][c][0];\\n                    rhombus += -grid[r][c] + grid[r-2*l][c]; \\n                    \\n                    addToMinHeap(minHeap, rhombus, capicity);\\n                }\\n            }\\n        }\\n        \\n        int size = minHeap.size();\\n        int[] res = new int[size];\\n        for (int i = size-1; i >= 0; i--)\\n            res[i] = minHeap.poll();\\n        return res;\\n    }\\n    \\n    private void addToMinHeap(PriorityQueue<Integer> minHeap, int num, int capicity)\\n    {\\n        if (minHeap.size() == 0 || (minHeap.size() < capicity && !minHeap.contains(num)))\\n            minHeap.offer(num);\\n        else\\n        {\\n            if (num > minHeap.peek() && !minHeap.contains(num))\\n            {\\n                minHeap.poll();\\n                minHeap.offer(num);\\n            }\\n        }\\n    }\\n    \\n    private boolean valid (int m, int n, int r, int c)\\n    {\\n        return 0 <= r && r < m && 0 <= c && c < n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /*\\n        PriorityQueue + Presum\\n        T -> O(m * n * min(m, n)/2) S -> O(m *n)\\n    */\\n    public int[] getBiggestThree(int[][] grid) \\n    {\\n        int capicity = 3;\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        int m = grid.length, n = grid[0].length;\\n        int[][][] preSum = new int[m][n][2];   // [r][c][0] : bottom-right to top-left diagonal, [r][c][1] : bottom-left to top-right diagonal\\n        int maxLen = Math.min(m, n) / 2;\\n        \\n        // Calculate presum of two diagonals for each point\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                addToMinHeap(minHeap, grid[r][c], capicity);\\n                preSum[r][c][0] += valid(m, n, r-1, c-1) ? grid[r][c] + preSum[r-1][c-1][0] : grid[r][c];\\n                preSum[r][c][1] += valid(m, n, r-1, c+1) ? grid[r][c] + preSum[r-1][c+1][1] : grid[r][c];\\n            }\\n        }\\n        \\n        \\n        // Calculate all possible rhombus for each point\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                for (int l = 1; l <= maxLen; l++)\\n                {\\n                    if (!valid(m, n, r - l, c - l) || !valid(m, n, r - l, c + l) || !valid(m, n, r - 2*l, c))\\n                        break;\\n                    \\n                    int rhombus = preSum[r][c][0] - preSum[r-l][c-l][0];\\n                    rhombus += preSum[r][c][1] - preSum[r-l][c+l][1];\\n                    rhombus += preSum[r-l][c-l][1] - preSum[r-2*l][c][1];\\n                    rhombus += preSum[r-l][c+l][0] - preSum[r-2*l][c][0];\\n                    rhombus += -grid[r][c] + grid[r-2*l][c]; \\n                    \\n                    addToMinHeap(minHeap, rhombus, capicity);\\n                }\\n            }\\n        }\\n        \\n        int size = minHeap.size();\\n        int[] res = new int[size];\\n        for (int i = size-1; i >= 0; i--)\\n            res[i] = minHeap.poll();\\n        return res;\\n    }\\n    \\n    private void addToMinHeap(PriorityQueue<Integer> minHeap, int num, int capicity)\\n    {\\n        if (minHeap.size() == 0 || (minHeap.size() < capicity && !minHeap.contains(num)))\\n            minHeap.offer(num);\\n        else\\n        {\\n            if (num > minHeap.peek() && !minHeap.contains(num))\\n            {\\n                minHeap.poll();\\n                minHeap.offer(num);\\n            }\\n        }\\n    }\\n    \\n    private boolean valid (int m, int n, int r, int c)\\n    {\\n        return 0 <= r && r < m && 0 <= c && c < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357738,
                "title": "python-brute-force-faster-than-74-smaller-than-85",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        first = 0\\n        second = 0\\n        third = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                side_len = 0\\n                last_first_half_sum = None\\n                while i + 2*side_len < len(grid) and j - side_len >= 0 and j + side_len < len(grid[0]):\\n                    rho_sum = 0\\n                    if last_first_half_sum is None:\\n                        for k in range(2*side_len+1):\\n                            if k == 0 or k == 2*side_len:\\n                                rho_sum += grid[i+k][j]\\n                            else:\\n                                if k <= side_len:\\n                                    rho_sum += grid[i+k][j-k]\\n                                    rho_sum += grid[i+k][j+k]\\n                                    if k == side_len:\\n                                        last_first_half_sum = rho_sum\\n                                else:\\n                                    rho_sum += grid[i+k][j-(2*side_len-k)]\\n                                    rho_sum += grid[i+k][j+(2*side_len-k)]\\n                    else:\\n                        rho_sum = last_first_half_sum\\n                        for k in range(side_len, 2*side_len+1):\\n                            if k == 2*side_len:\\n                                rho_sum += grid[i+k][j]\\n                            elif k == side_len:\\n                                rho_sum += grid[i+k][j-k]\\n                                rho_sum += grid[i+k][j+k]\\n                                last_first_half_sum = rho_sum\\n                            else:\\n                                rho_sum += grid[i+k][j-(2*side_len-k)]\\n                                rho_sum += grid[i+k][j+(2*side_len-k)]\\n                    if rho_sum > first:\\n                        third = second\\n                        second = first\\n                        first = rho_sum\\n                    elif rho_sum > second and rho_sum != first:\\n                        third = second\\n                        second = rho_sum\\n                    elif rho_sum > third and rho_sum != first and rho_sum != second:\\n                        third = rho_sum\\n                    side_len += 1\\n        output = [first, second, third]\\n        output = [i for i in output if i > 0]\\n        return output\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        first = 0\\n        second = 0\\n        third = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                side_len = 0\\n                last_first_half_sum = None\\n                while i + 2*side_len < len(grid) and j - side_len >= 0 and j + side_len < len(grid[0]):\\n                    rho_sum = 0\\n                    if last_first_half_sum is None:\\n                        for k in range(2*side_len+1):\\n                            if k == 0 or k == 2*side_len:\\n                                rho_sum += grid[i+k][j]\\n                            else:\\n                                if k <= side_len:\\n                                    rho_sum += grid[i+k][j-k]\\n                                    rho_sum += grid[i+k][j+k]\\n                                    if k == side_len:\\n                                        last_first_half_sum = rho_sum\\n                                else:\\n                                    rho_sum += grid[i+k][j-(2*side_len-k)]\\n                                    rho_sum += grid[i+k][j+(2*side_len-k)]\\n                    else:\\n                        rho_sum = last_first_half_sum\\n                        for k in range(side_len, 2*side_len+1):\\n                            if k == 2*side_len:\\n                                rho_sum += grid[i+k][j]\\n                            elif k == side_len:\\n                                rho_sum += grid[i+k][j-k]\\n                                rho_sum += grid[i+k][j+k]\\n                                last_first_half_sum = rho_sum\\n                            else:\\n                                rho_sum += grid[i+k][j-(2*side_len-k)]\\n                                rho_sum += grid[i+k][j+(2*side_len-k)]\\n                    if rho_sum > first:\\n                        third = second\\n                        second = first\\n                        first = rho_sum\\n                    elif rho_sum > second and rho_sum != first:\\n                        third = second\\n                        second = rho_sum\\n                    elif rho_sum > third and rho_sum != first and rho_sum != second:\\n                        third = rho_sum\\n                    side_len += 1\\n        output = [first, second, third]\\n        output = [i for i in output if i > 0]\\n        return output\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1267554,
                "title": "c-44ms-7-1mb-brute-force-maybe-not-so-fast-but-it-pretty-much-easy",
                "content": "Simply check each possible (i.e. every single data & every rhombus sums)\\nAnd recorded the biggest three values to return\\nIf there\\'s less than three values, return the maximum all we had recorded.\\n\\n```\\n\\nint* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    \\n    int i, j, k;\\n    int max1 = 0, max2 = 0, max3 = 0, temp, sum;\\n    for(i = 0; i < gridSize; i++)\\n        for(j = 0; j < (*gridColSize); j++){\\n\\t\\t\\n            if(grid[i][j] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = grid[i][j];\\n            }else if(grid[i][j] > max2 && grid[i][j] != max1){\\n                max3 = max2;\\n                max2 = grid[i][j];\\n            }else if(grid[i][j] > max3 && grid[i][j] != max2 && grid[i][j] != max1) max3 = grid[i][j];\\n\\t\\t\\t\\n            temp = 1;\\n            while( (j - temp >= 0) && (j + temp < (*gridColSize)) && ((i + 2 * temp) < gridSize)){\\n                sum = grid[i][j];\\n                for(k = 1; k < temp; k++) sum += (grid[i + k][j - k] + grid[i + k][j + k] + grid[i + 2 * temp - k][j - k] + grid[i + 2 * temp - k][j + k]);\\n                sum += (grid[i + k][j - k] + grid[i + k][j + k]);\\n                sum += grid[i + 2 * temp][j];\\n                if(sum > max1){\\n                    max3 = max2;\\n                    max2 = max1;\\n                    max1 = sum;\\n                }else if(sum > max2 && sum != max1){\\n                    max3 = max2;\\n                    max2 = sum;\\n                }else if(sum > max3 && sum != max2 && sum != max1) max3 = sum;\\n                temp++;\\n            }\\n        }\\n    \\n    int* answer;\\n    if(max3 == 0 && max2 == 0){\\n        *returnSize = 1;\\n        answer = (int*)malloc(sizeof(int));\\n        answer[0] = max1;\\n    }else if(max3 == 0){\\n        *returnSize = 2;\\n        answer = (int*)malloc(sizeof(int) * 2);\\n        answer[0] = max1;\\n        answer[1] = max2;\\n    }else{\\n        *returnSize = 3;\\n        answer = (int*)malloc(sizeof(int) * 3);\\n        answer[0] = max1;\\n        answer[1] = max2;\\n        answer[2] = max3;\\n    }\\n    \\n    return answer;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    \\n    int i, j, k;\\n    int max1 = 0, max2 = 0, max3 = 0, temp, sum;\\n    for(i = 0; i < gridSize; i++)\\n        for(j = 0; j < (*gridColSize); j++){\\n\\t\\t\\n            if(grid[i][j] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = grid[i][j];\\n            }else if(grid[i][j] > max2 && grid[i][j] != max1){\\n                max3 = max2;\\n                max2 = grid[i][j];\\n            }else if(grid[i][j] > max3 && grid[i][j] != max2 && grid[i][j] != max1) max3 = grid[i][j];\\n\\t\\t\\t\\n            temp = 1;\\n            while( (j - temp >= 0) && (j + temp < (*gridColSize)) && ((i + 2 * temp) < gridSize)){\\n                sum = grid[i][j];\\n                for(k = 1; k < temp; k++) sum += (grid[i + k][j - k] + grid[i + k][j + k] + grid[i + 2 * temp - k][j - k] + grid[i + 2 * temp - k][j + k]);\\n                sum += (grid[i + k][j - k] + grid[i + k][j + k]);\\n                sum += grid[i + 2 * temp][j];\\n                if(sum > max1){\\n                    max3 = max2;\\n                    max2 = max1;\\n                    max1 = sum;\\n                }else if(sum > max2 && sum != max1){\\n                    max3 = max2;\\n                    max2 = sum;\\n                }else if(sum > max3 && sum != max2 && sum != max1) max3 = sum;\\n                temp++;\\n            }\\n        }\\n    \\n    int* answer;\\n    if(max3 == 0 && max2 == 0){\\n        *returnSize = 1;\\n        answer = (int*)malloc(sizeof(int));\\n        answer[0] = max1;\\n    }else if(max3 == 0){\\n        *returnSize = 2;\\n        answer = (int*)malloc(sizeof(int) * 2);\\n        answer[0] = max1;\\n        answer[1] = max2;\\n    }else{\\n        *returnSize = 3;\\n        answer = (int*)malloc(sizeof(int) * 3);\\n        answer[0] = max1;\\n        answer[1] = max2;\\n        answer[2] = max3;\\n    }\\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1264003,
                "title": "idk-what-am-i-doing-but-it-passed-java-brute-force",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pq.offer(grid[i][j]);\\n                for (int x = 1; i + x < n && i - x >= 0 && j + x < m && j - x >= 0; x++) {\\n                    int sum = 0;\\n                    sum += grid[i][j + x];\\n                    sum += grid[i][j - x];\\n                    sum += grid[i - x][j];\\n                    sum += grid[i + x][j];\\n                    for (int a = 1; a < x; a++) {\\n                        sum += grid[i + x - a][j + a];\\n                        sum += grid[i + x - a][j - a];\\n                        sum += grid[i - x + a][j - a];\\n                        sum += grid[i - x + a][j + a];\\n                    }\\n                    pq.offer(sum);\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        int j = 0;\\n        while (j < 3) {\\n            while (j > 0 && !pq.isEmpty() && pq.peek().equals(res.get(j - 1))) {\\n                pq.poll();\\n            }\\n            if (pq.isEmpty()) {\\n                break;\\n            }\\n            res.add(pq.poll());\\n            j++;\\n        }\\n        int[] ans = new int[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pq.offer(grid[i][j]);\\n                for (int x = 1; i + x < n && i - x >= 0 && j + x < m && j - x >= 0; x++) {\\n                    int sum = 0;\\n                    sum += grid[i][j + x];\\n                    sum += grid[i][j - x];\\n                    sum += grid[i - x][j];\\n                    sum += grid[i + x][j];\\n                    for (int a = 1; a < x; a++) {\\n                        sum += grid[i + x - a][j + a];\\n                        sum += grid[i + x - a][j - a];\\n                        sum += grid[i - x + a][j - a];\\n                        sum += grid[i - x + a][j + a];\\n                    }\\n                    pq.offer(sum);\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        int j = 0;\\n        while (j < 3) {\\n            while (j > 0 && !pq.isEmpty() && pq.peek().equals(res.get(j - 1))) {\\n                pq.poll();\\n            }\\n            if (pq.isEmpty()) {\\n                break;\\n            }\\n            res.add(pq.poll());\\n            j++;\\n        }\\n        int[] ans = new int[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262323,
                "title": "brute-force-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> store;\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int mxSize=(min(m,n)+1)/2;\\n        \\n        for(int sz=1;sz<=mxSize;sz++)\\n        {\\n            int r=sz-1;\\n            \\n            \\n            int cl=n-sz*2+1;\\n            int rl=m-sz;\\n            while(r<=rl)\\n            {\\n                int c=0;\\n                while(c<=cl)\\n                {\\n                    int sum=grid[r][c];\\n                    \\n                    int tr=r-1,tc=c+1,tsz=sz-1;\\n                    \\n                    while(tsz--)\\n                        sum+=grid[tr--][tc++];\\n \\n                    tr+=2;tsz=sz-1;\\n                    \\n                    while(tsz--)\\n                       sum+=grid[tr++][tc++];\\n                    \\n                    tc-=2;tsz=sz-1;\\n                    \\n                    while(tsz--)\\n                        sum+=grid[tr++][tc--];\\n                    \\n                    tr-=2;tsz=sz-2;\\n                    \\n                    while(tsz>0){\\n                        sum+=grid[tr--][tc--];\\n                        tsz--;\\n                    }\\n                    \\n                    store.insert(sum);\\n                  \\n                    c++;\\n                }\\n                r++;\\n            }\\n        \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto n:store)\\n            ans.push_back(n);\\n          sort(ans.begin(),ans.end(),greater<int>());\\n        if(ans.size()>3)\\n            ans.resize(3);\\n        \\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> store;\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int mxSize=(min(m,n)+1)/2;\\n        \\n        for(int sz=1;sz<=mxSize;sz++)\\n        {\\n            int r=sz-1;\\n            \\n            \\n            int cl=n-sz*2+1;\\n            int rl=m-sz;\\n            while(r<=rl)\\n            {\\n                int c=0;\\n                while(c<=cl)\\n                {\\n                    int sum=grid[r][c];\\n                    \\n                    int tr=r-1,tc=c+1,tsz=sz-1;\\n                    \\n                    while(tsz--)\\n                        sum+=grid[tr--][tc++];\\n \\n                    tr+=2;tsz=sz-1;\\n                    \\n                    while(tsz--)\\n                       sum+=grid[tr++][tc++];\\n                    \\n                    tc-=2;tsz=sz-1;\\n                    \\n                    while(tsz--)\\n                        sum+=grid[tr++][tc--];\\n                    \\n                    tr-=2;tsz=sz-2;\\n                    \\n                    while(tsz>0){\\n                        sum+=grid[tr--][tc--];\\n                        tsz--;\\n                    }\\n                    \\n                    store.insert(sum);\\n                  \\n                    c++;\\n                }\\n                r++;\\n            }\\n        \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto n:store)\\n            ans.push_back(n);\\n          sort(ans.begin(),ans.end(),greater<int>());\\n        if(ans.size()>3)\\n            ans.resize(3);\\n        \\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258796,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        sums = set()\\n        length = min((len(grid)+1)//2, (len(grid[0])+1)//2)\\n        h = {}\\n        for l in range(1, length+1):\\n            h[l] = set()\\n            for val in range(l):\\n                curr =(val, l-1-val)\\n                h[l].add((curr[0], curr[1]))\\n                h[l].add((curr[0], -curr[1]))\\n                h[l].add((-curr[0], curr[1]))\\n                h[l].add((-curr[0], -curr[1]))\\n        for l in range(1, length+1):\\n            for i in range(l-1, len(grid)-l+1):\\n                for j in range(l-1, len(grid[0])-l+1):\\n                    curr_sum = 0\\n                    for d in list(h[l]):\\n                        curr_sum += grid[i+d[0]][j+d[1]]\\n                    sums.add(curr_sum)\\n        sums = sorted(list(sums))\\n        sums.reverse()\\n        vol = min(3, len(sums))\\n        return (sums[:vol])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        sums = set()\\n        length = min((len(grid)+1)//2, (len(grid[0])+1)//2)\\n        h = {}\\n        for l in range(1, length+1):\\n            h[l] = set()\\n            for val in range(l):\\n                curr =(val, l-1-val)\\n                h[l].add((curr[0], curr[1]))\\n                h[l].add((curr[0], -curr[1]))\\n                h[l].add((-curr[0], curr[1]))\\n                h[l].add((-curr[0], -curr[1]))\\n        for l in range(1, length+1):\\n            for i in range(l-1, len(grid)-l+1):\\n                for j in range(l-1, len(grid[0])-l+1):\\n                    curr_sum = 0\\n                    for d in list(h[l]):\\n                        curr_sum += grid[i+d[0]][j+d[1]]\\n                    sums.add(curr_sum)\\n        sums = sorted(list(sums))\\n        sums.reverse()\\n        vol = min(3, len(sums))\\n        return (sums[:vol])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254712,
                "title": "python-cumulative-sum-on-diagonal-heap-o-m-n-max-m-n-o-n-3-for-square",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        return self.v1(grid)\\n    \\n    def v1(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        d1, d2 = self.create_diagonal_sums(grid)  # Will use this to calculate sum for rhombus in O(1) given a rhombus\\n        h = []\\n        for i in range(m):\\n            for j in range(n):\\n                max_r = min(min(min(i, m-1-i), j), n-1-j)  # i,j  is centerpoint, max_r is max possible size of 45deg rhombus possible\\n                for l in range(0, max_r+1):\\n                    r_sum = (d1[i+l][j] - d1[i][j-l]) + (d1[i][j+l] - d1[i-l][j]) + (d2[i][j-l] - d2[i-l][j]) + (d2[i+l][j] - d2[i][j+l]) - grid[i+l][j] + grid[i-l][j] if l!= 0 else grid[i][j]  # 1st four terms are sum on each diagonal, next 2 terms are removing bottom corner once(counted twice) and add top corner(not counted). Else condition is for base condition when l==0\\n                    heappush(h, -1 * r_sum)   # max heap\\n        ans = set()\\n        while(len(ans) < 3 and len(h) > 0):\\n            c = heappop(h)\\n            if c not in ans:\\n                ans.add(c)\\n        return sorted([-1*x for x in ans], reverse=True) # size of ans is 3, so this is O(1) operation\\n    \\n    def create_diagonal_sums(self, grid): # Create two matrices (d1, d2) where d1[i][j] contains cumulative sum of elements on main diagonal till i,j. Similarly d2 is for alternate diagonal\\n        m = len(grid)\\n        n = len(grid[0])\\n        d1sum, d2sum = list(), list()\\n        for i in range(m):\\n            row1, row2 = list(), list()\\n            for j in range(n):\\n                row1.append(grid[i][j] + (d1sum[i-1][j-1] if (i>= 1 and j>=1) else 0))\\n                row2.append(grid[i][j] + (d2sum[i-1][j+1] if (i >= 1 and j<n-1) else 0))\\n            d1sum.append(row1)\\n            d2sum.append(row2)\\n        return (d1sum, d2sum)\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        return self.v1(grid)\\n    \\n    def v1(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        d1, d2 = self.create_diagonal_sums(grid)  # Will use this to calculate sum for rhombus in O(1) given a rhombus\\n        h = []\\n        for i in range(m):\\n            for j in range(n):\\n                max_r = min(min(min(i, m-1-i), j), n-1-j)  # i,j  is centerpoint, max_r is max possible size of 45deg rhombus possible\\n                for l in range(0, max_r+1):\\n                    r_sum = (d1[i+l][j] - d1[i][j-l]) + (d1[i][j+l] - d1[i-l][j]) + (d2[i][j-l] - d2[i-l][j]) + (d2[i+l][j] - d2[i][j+l]) - grid[i+l][j] + grid[i-l][j] if l!= 0 else grid[i][j]  # 1st four terms are sum on each diagonal, next 2 terms are removing bottom corner once(counted twice) and add top corner(not counted). Else condition is for base condition when l==0\\n                    heappush(h, -1 * r_sum)   # max heap\\n        ans = set()\\n        while(len(ans) < 3 and len(h) > 0):\\n            c = heappop(h)\\n            if c not in ans:\\n                ans.add(c)\\n        return sorted([-1*x for x in ans], reverse=True) # size of ans is 3, so this is O(1) operation\\n    \\n    def create_diagonal_sums(self, grid): # Create two matrices (d1, d2) where d1[i][j] contains cumulative sum of elements on main diagonal till i,j. Similarly d2 is for alternate diagonal\\n        m = len(grid)\\n        n = len(grid[0])\\n        d1sum, d2sum = list(), list()\\n        for i in range(m):\\n            row1, row2 = list(), list()\\n            for j in range(n):\\n                row1.append(grid[i][j] + (d1sum[i-1][j-1] if (i>= 1 and j>=1) else 0))\\n                row2.append(grid[i][j] + (d2sum[i-1][j+1] if (i >= 1 and j<n-1) else 0))\\n            d1sum.append(row1)\\n            d2sum.append(row2)\\n        return (d1sum, d2sum)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250294,
                "title": "java-faster-solution-iteration-on-odd-dimension-submatrices",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        var res = new TreeMap<Integer,Integer>();\\n        int minLen = Math.min(grid.length, grid[0].length), sum;\\n        \\n        //iterate odd dimension square submatrices\\n        for(int size=1; size<= minLen; size+=2){\\n            //iterate all square submatrices of size \"size\"\\n            for(int i=size-1; i<grid.length; i++){\\n                for(int j=size-1; j<grid[0].length; j++){\\n                    sum = grid[i][j];\\n                    if(size > 1){\\n                        sum = sumBorder(grid, i, j, size);\\n                    }\\n                    if(res.containsKey(sum))\\n                        continue;//only distinct areas required\\n                    \\n                    res.put(sum,sum);\\n                    if(res.size() > 3)\\n                        res.pollFirstEntry();\\n                }\\n            }\\n        }\\n        int result[] = new int[res.size()],index = 0;\\n        while(!res.isEmpty())\\n            result[index++] = res.pollLastEntry().getKey();\\n        \\n        return result; \\n    }\\n    private int sumBorder(int[][] grid,int x, int y, int size){\\n        \\n        int mid = size/2;\\n        //from bottom mid cell to left mid cell\\n        int i = x, j = y-mid, sum = 0;\\n        int count = 0;\\n        while(count++ < mid)\\n            sum += grid[--i][--j];\\n        \\n        //from left mid cell to top mid cell\\n        count = 0;\\n        while(count++ <mid)\\n            sum += grid[--i][++j];\\n        \\n        //from top mid cell to right mid cell\\n        count = 0;\\n        while(count++ <mid)\\n            sum += grid[++i][++j];\\n        \\n        //from right mid to bottom mid\\n        count = 0; \\n        while(count++ < mid)\\n            sum += grid[++i][--j];\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        var res = new TreeMap<Integer,Integer>();\\n        int minLen = Math.min(grid.length, grid[0].length), sum;\\n        \\n        //iterate odd dimension square submatrices\\n        for(int size=1; size<= minLen; size+=2){\\n            //iterate all square submatrices of size \"size\"\\n            for(int i=size-1; i<grid.length; i++){\\n                for(int j=size-1; j<grid[0].length; j++){\\n                    sum = grid[i][j];\\n                    if(size > 1){\\n                        sum = sumBorder(grid, i, j, size);\\n                    }\\n                    if(res.containsKey(sum))\\n                        continue;//only distinct areas required\\n                    \\n                    res.put(sum,sum);\\n                    if(res.size() > 3)\\n                        res.pollFirstEntry();\\n                }\\n            }\\n        }\\n        int result[] = new int[res.size()],index = 0;\\n        while(!res.isEmpty())\\n            result[index++] = res.pollLastEntry().getKey();\\n        \\n        return result; \\n    }\\n    private int sumBorder(int[][] grid,int x, int y, int size){\\n        \\n        int mid = size/2;\\n        //from bottom mid cell to left mid cell\\n        int i = x, j = y-mid, sum = 0;\\n        int count = 0;\\n        while(count++ < mid)\\n            sum += grid[--i][--j];\\n        \\n        //from left mid cell to top mid cell\\n        count = 0;\\n        while(count++ <mid)\\n            sum += grid[--i][++j];\\n        \\n        //from top mid cell to right mid cell\\n        count = 0;\\n        while(count++ <mid)\\n            sum += grid[++i][++j];\\n        \\n        //from right mid to bottom mid\\n        count = 0; \\n        while(count++ < mid)\\n            sum += grid[++i][--j];\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250184,
                "title": "python-using-circle-and-short-circuit",
                "content": "```\\nclass Solution(object):\\n    def getBiggestThree(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        ROW = len(grid)\\n        COL = len(grid[0])\\n        \\n\\t\\t#four directions \\n        DIRS = ((1,-1),(1,1),(-1,1),(-1,-1))\\n\\t\\t\\n        def valid(i,j):\\n            return -1 < i < ROW and -1 < j < COL\\n\\t\\t\\t\\n        res = []\\n        \\n        for r in range(ROW):\\n            for c in range(COL):\\n                if grid[r][c] not in res:\\n                    res.append(grid[r][c])\\n                \\n                t = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# length is radius of circle\\n                for length in range(1,ROW/2+1):\\n\\t\\t\\t\\t#first check the validness\\n                    if not valid(r+length,c-length) or not valid(r+length,c+length) or not valid(r+2*length, c):\\n                        break\\n                        \\n                    r_t = r\\n                    c_t = c \\n                    t = 0\\n                    for d in DIRS:\\n                        for n in range(length):\\n                            r_t += d[0]\\n                            c_t += d[1]\\n                            t += grid[r_t][c_t]\\n\\t\\t\\t\\t\\t\\t\\t\\n                    if t not in res:\\n                        res.append(t)\\n\\t\\t\\t\\t\\t\\t\\n                if len(res) > 3:\\n                    res.sort()\\n                    while len(res) > 3:\\n                        res.pop(0)\\n\\n        res.sort()\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getBiggestThree(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        ROW = len(grid)\\n        COL = len(grid[0])\\n        \\n\\t\\t#four directions \\n        DIRS = ((1,-1),(1,1),(-1,1),(-1,-1))\\n\\t\\t\\n        def valid(i,j):\\n            return -1 < i < ROW and -1 < j < COL\\n\\t\\t\\t\\n        res = []\\n        \\n        for r in range(ROW):\\n            for c in range(COL):\\n                if grid[r][c] not in res:\\n                    res.append(grid[r][c])\\n                \\n                t = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# length is radius of circle\\n                for length in range(1,ROW/2+1):\\n\\t\\t\\t\\t#first check the validness\\n                    if not valid(r+length,c-length) or not valid(r+length,c+length) or not valid(r+2*length, c):\\n                        break\\n                        \\n                    r_t = r\\n                    c_t = c \\n                    t = 0\\n                    for d in DIRS:\\n                        for n in range(length):\\n                            r_t += d[0]\\n                            c_t += d[1]\\n                            t += grid[r_t][c_t]\\n\\t\\t\\t\\t\\t\\t\\t\\n                    if t not in res:\\n                        res.append(t)\\n\\t\\t\\t\\t\\t\\t\\n                if len(res) > 3:\\n                    res.sort()\\n                    while len(res) > 3:\\n                        res.pop(0)\\n\\n        res.sort()\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249810,
                "title": "python-chore-coding-precalc-sum-task-time-98-mem-78",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        nRows = len(grid)\\n        nCols = len(grid[0])\\n        \\n\\t\\t# precalc Upper Left to Bottom Right diag sums\\n        ulbrSums = [[0] * nCols for _ in range(nRows)]\\n        ulbrSums[0][0] = grid[0][0]\\n        sqCnt = min(nRows, nCols)\\n        dCnt = sqCnt + (sqCnt - 1) + abs(nRows - nCols)\\n        for di in range(1, dCnt):\\n            if di < nRows:\\n                ulbrSums[di][0] = grid[di][0]\\n                ciStart = 1\\n            else:\\n                ciStart = di - nRows + 1\\n                \\n            if di < nCols:\\n                ulbrSums[0][di] = grid[0][di]\\n                ciStop = di + 1\\n            else:\\n                ciStop = nCols\\n            \\n            \\n            for ci in range(ciStart, ciStop):\\n                ri = di - ci\\n                ulbrSums[ri][ci] = ulbrSums[ri - 1][ci - 1] + grid[ri][ci]\\n        # print(ulbrSums)\\n        \\n        # precalc Upper Right to Bottom Left diag sums\\n        urblSums = [[0] * nCols for _ in range(nRows)]\\n        urblSums[0][-1] = grid[0][-1]\\n        for di in range(1, dCnt):\\n            if di < nRows:\\n                urblSums[di][-1] = grid[di][-1]\\n                ciStart = nCols - 2\\n            else:\\n                ciStart = nCols - 1 - (di - nRows + 1)\\n                \\n            if di < nCols:\\n                urblSums[0][-1 - di] = grid[0][-1 - di]\\n                ciStop = nCols - di - 1\\n            else:\\n                ciStop = -1\\n            \\n            # print(\"diag\", di, ciStart, ciStop)\\n            for ci in range(ciStart, ciStop, -1):\\n                ri = di - (nCols - 1 - ci)\\n                # print(di, ci, ri)\\n                urblSums[ri][ci] = urblSums[ri - 1][ci + 1] + grid[ri][ci]\\n        # print(urblSums)\\n\\t\\t\\n\\t\\t# setup a heap for the top 3 values\\n        h = []\\n        hSet = set()\\n        \\n\\t\\t# run for every top of the rhombus\\n        for uri in range(nRows):\\n            for mci in range(nCols):\\n\\t\\t\\t\\t# take the 0 len rhombus\\n                v = grid[uri][mci]\\n                if v not in hSet:\\n                    hSet.add(v)\\n                    if len(h) < 3:\\n                        heappush(h, v)\\n                    else:\\n                        hSet.remove(heappushpop(h, v))\\n                # run to the max possible rhombus\\n                for l in range(1, min(nRows, nCols)):\\n                    mri = uri + l\\n                    if mri >= nRows:\\n                        break\\n                    lri = mri + l\\n                    if lri >= nRows:\\n                        break\\n                    lci = mci - l\\n                    if lci < 0:\\n                        break\\n                    rci = mci + l\\n                    if rci >= nCols:\\n                        break\\n                    #print(uri, mri, lri)\\n                    #print(lci, mci, rci)\\n\\t\\t\\t\\t\\t# get the sum from the calculated prefixes\\n                    v = ulbrSums[mri][rci] - ulbrSums[uri][mci] + ulbrSums[lri][mci] - ulbrSums[mri][lci]\\n                    v += urblSums[lri][mci] - urblSums[mri][rci] + urblSums[mri][lci] - urblSums[uri][mci]\\n                    v += grid[uri][mci] - grid[lri][mci]\\n                    # print(v)\\n                    # add to the heap if new number\\n                    if v not in hSet:\\n                        hSet.add(v)\\n                        if len(h) < 3:\\n                            heappush(h, v)\\n                        else:\\n                            hSet.remove(heappushpop(h, v))\\n                        \\n                    \\n        \\n        return sorted(h, reverse=True)\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        nRows = len(grid)\\n        nCols = len(grid[0])\\n        \\n\\t\\t# precalc Upper Left to Bottom Right diag sums\\n        ulbrSums = [[0] * nCols for _ in range(nRows)]\\n        ulbrSums[0][0] = grid[0][0]\\n        sqCnt = min(nRows, nCols)\\n        dCnt = sqCnt + (sqCnt - 1) + abs(nRows - nCols)\\n        for di in range(1, dCnt):\\n            if di < nRows:\\n                ulbrSums[di][0] = grid[di][0]\\n                ciStart = 1\\n            else:\\n                ciStart = di - nRows + 1\\n                \\n            if di < nCols:\\n                ulbrSums[0][di] = grid[0][di]\\n                ciStop = di + 1\\n            else:\\n                ciStop = nCols\\n            \\n            \\n            for ci in range(ciStart, ciStop):\\n                ri = di - ci\\n                ulbrSums[ri][ci] = ulbrSums[ri - 1][ci - 1] + grid[ri][ci]\\n        # print(ulbrSums)\\n        \\n        # precalc Upper Right to Bottom Left diag sums\\n        urblSums = [[0] * nCols for _ in range(nRows)]\\n        urblSums[0][-1] = grid[0][-1]\\n        for di in range(1, dCnt):\\n            if di < nRows:\\n                urblSums[di][-1] = grid[di][-1]\\n                ciStart = nCols - 2\\n            else:\\n                ciStart = nCols - 1 - (di - nRows + 1)\\n                \\n            if di < nCols:\\n                urblSums[0][-1 - di] = grid[0][-1 - di]\\n                ciStop = nCols - di - 1\\n            else:\\n                ciStop = -1\\n            \\n            # print(\"diag\", di, ciStart, ciStop)\\n            for ci in range(ciStart, ciStop, -1):\\n                ri = di - (nCols - 1 - ci)\\n                # print(di, ci, ri)\\n                urblSums[ri][ci] = urblSums[ri - 1][ci + 1] + grid[ri][ci]\\n        # print(urblSums)\\n\\t\\t\\n\\t\\t# setup a heap for the top 3 values\\n        h = []\\n        hSet = set()\\n        \\n\\t\\t# run for every top of the rhombus\\n        for uri in range(nRows):\\n            for mci in range(nCols):\\n\\t\\t\\t\\t# take the 0 len rhombus\\n                v = grid[uri][mci]\\n                if v not in hSet:\\n                    hSet.add(v)\\n                    if len(h) < 3:\\n                        heappush(h, v)\\n                    else:\\n                        hSet.remove(heappushpop(h, v))\\n                # run to the max possible rhombus\\n                for l in range(1, min(nRows, nCols)):\\n                    mri = uri + l\\n                    if mri >= nRows:\\n                        break\\n                    lri = mri + l\\n                    if lri >= nRows:\\n                        break\\n                    lci = mci - l\\n                    if lci < 0:\\n                        break\\n                    rci = mci + l\\n                    if rci >= nCols:\\n                        break\\n                    #print(uri, mri, lri)\\n                    #print(lci, mci, rci)\\n\\t\\t\\t\\t\\t# get the sum from the calculated prefixes\\n                    v = ulbrSums[mri][rci] - ulbrSums[uri][mci] + ulbrSums[lri][mci] - ulbrSums[mri][lci]\\n                    v += urblSums[lri][mci] - urblSums[mri][rci] + urblSums[mri][lci] - urblSums[uri][mci]\\n                    v += grid[uri][mci] - grid[lri][mci]\\n                    # print(v)\\n                    # add to the heap if new number\\n                    if v not in hSet:\\n                        hSet.add(v)\\n                        if len(h) < 3:\\n                            heappush(h, v)\\n                        else:\\n                            hSet.remove(heappushpop(h, v))\\n                        \\n                    \\n        \\n        return sorted(h, reverse=True)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246677,
                "title": "c-brute-force-solution",
                "content": "In this case, we simply try to generate all the rhombus possible with a fixed cell as center. As soon as the rhombus cannot fit in the grid, we move to the next cell.\\n\\nCode :-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int,greater<int>> res; //Holding all sums derived\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i=0;i<m;++i)\\n        {\\n            for(int j=0;j<n;++j)\\n            {\\n                res.insert(grid[i][j]);\\n                int dis = 1;\\n                while(1)\\n                {\\n                    if(j-dis>=0 && j+dis<n && i-dis>=0 && i+dis<m)\\n                    {\\n                        //Another bigger rhombus possible\\n                        //Calculate sum and add to vector\\n                                         \\n                        int d = 0;\\n                        int sum =0;\\n                        for(int k = i-dis;k<=i;++k)\\n                        {\\n                            if(d==0)\\n                                sum+=grid[k][j];\\n                            else\\n                                sum+=(grid[k][j-d]+grid[k][j+d]);\\n                            ++d;\\n                        }\\n                        d-=2;\\n                        for(int k = i+1;k<=i+dis;++k)\\n                        {\\n                            if(d==0)\\n                                sum+=grid[k][j];\\n                            else\\n                                sum+=(grid[k][j-d]+grid[k][j+d]);\\n                            --d;\\n                        }\\n                        res.insert(sum);\\n                        //Update dis\\n                        ++dis;\\n                    }\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int c=0;\\n        for(auto elem:res)\\n        {\\n            ans.push_back(elem);\\n            ++c;\\n            if(c==3)\\n                break;\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int,greater<int>> res; //Holding all sums derived\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i=0;i<m;++i)\\n        {\\n            for(int j=0;j<n;++j)\\n            {\\n                res.insert(grid[i][j]);\\n                int dis = 1;\\n                while(1)\\n                {\\n                    if(j-dis>=0 && j+dis<n && i-dis>=0 && i+dis<m)\\n                    {\\n                        //Another bigger rhombus possible\\n                        //Calculate sum and add to vector\\n                                         \\n                        int d = 0;\\n                        int sum =0;\\n                        for(int k = i-dis;k<=i;++k)\\n                        {\\n                            if(d==0)\\n                                sum+=grid[k][j];\\n                            else\\n                                sum+=(grid[k][j-d]+grid[k][j+d]);\\n                            ++d;\\n                        }\\n                        d-=2;\\n                        for(int k = i+1;k<=i+dis;++k)\\n                        {\\n                            if(d==0)\\n                                sum+=grid[k][j];\\n                            else\\n                                sum+=(grid[k][j-d]+grid[k][j+d]);\\n                            --d;\\n                        }\\n                        res.insert(sum);\\n                        //Update dis\\n                        ++dis;\\n                    }\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int c=0;\\n        for(auto elem:res)\\n        {\\n            ans.push_back(elem);\\n            ++c;\\n            if(c==3)\\n                break;\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245855,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer> col = new HashSet<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int R = Math.min(i, j);\\n                R = Math.min(m - 1 - i, R);\\n                R = Math.min(n - 1 - j, R);\\n                col.add(grid[i][j]);\\n                \\n                for (int r = 1; r <= R; r++) {\\n                    int a = i - r;\\n                    int b = j;\\n                    int sum = 0;\\n                    for (int k = 0; k < r; k++) {\\n                        a += 1;\\n                        b -= 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    for (int k = 0; k < r; k++) {\\n                        a += 1;\\n                        b += 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    for (int k = 0; k < r; k++) {\\n                        a -= 1;\\n                        b += 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    for (int k = 0; k < r; k++) {\\n                        a -= 1;\\n                        b -= 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    col.add(sum);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> finalResult = col.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toCollection(ArrayList::new));\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < Math.min(3, finalResult.size()); i++) {\\n            result.add(finalResult.get(i));\\n        }\\n        \\n        return result.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer> col = new HashSet<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int R = Math.min(i, j);\\n                R = Math.min(m - 1 - i, R);\\n                R = Math.min(n - 1 - j, R);\\n                col.add(grid[i][j]);\\n                \\n                for (int r = 1; r <= R; r++) {\\n                    int a = i - r;\\n                    int b = j;\\n                    int sum = 0;\\n                    for (int k = 0; k < r; k++) {\\n                        a += 1;\\n                        b -= 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    for (int k = 0; k < r; k++) {\\n                        a += 1;\\n                        b += 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    for (int k = 0; k < r; k++) {\\n                        a -= 1;\\n                        b += 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    for (int k = 0; k < r; k++) {\\n                        a -= 1;\\n                        b -= 1;\\n                        sum += grid[a][b];\\n                    }\\n                    \\n                    col.add(sum);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> finalResult = col.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toCollection(ArrayList::new));\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < Math.min(3, finalResult.size()); i++) {\\n            result.add(finalResult.get(i));\\n        }\\n        \\n        return result.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245756,
                "title": "brute-force-with-java",
                "content": "**Simple Brute-Force Solution with Java**\\n\\nIterate through all sizes (1 to max size, which is just the smaller dimension divided by 2 rounded up).\\n\\nFor each size, go through the whole grid. For each square (starting where it is possible to have a rhombus sum, go down and right, then down and left, then up and left, then up and right. Keep track of the sum while doing so and then add it to a list. Sort the list and take only the top three.\\n\\n```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int sizeLim = (int)(Math.ceil(Math.min(r, c) / 2.0));\\n        // go through all sizes        \\n        for (int s = 1; s <= sizeLim; s++) {\\n            for (int i = 0; i < r - (2 * (s - 1)); i++) {\\n                for (int j = s - 1; j < c - s + 1; j++) {\\n                    int sum = 0;\\n                    // iterate through all sides\\n                    int currI = i;\\n                    int currJ = j;\\n                    sum += grid[currI][currJ];\\n                    for (int k = 0; k < 4; k++) {\\n                        // travel down one side\\n                        for (int l = 0; l < s - 1; l++) {                            \\n                            if (k == 0) {\\n                                currI++;\\n                                currJ++;\\n                            }\\n                            if (k == 1) {\\n                                currI++;\\n                                currJ--;\\n                            }\\n                            if (k == 2) {\\n                                currI--;\\n                                currJ--;\\n                            }\\n                            if (k == 3) {\\n                                currI--;\\n                                currJ++;\\n                            }\\n                            sum += grid[currI][currJ];\\n                        }\\n                    }\\n                    if (s > 1) {\\n                        sum -= grid[currI][currJ];\\n                    }\\n                    res.add(sum);\\n                }\\n            }\\n        }\\n        Collections.sort(res);\\n        List<Integer> ans = new ArrayList<>();\\n        int cnt = 0;\\n        for (int i = res.size() - 1; i >= 0 && cnt < 3; i--) {\\n            if (!ans.contains(res.get(i))) {\\n                ans.add(res.get(i));\\n                cnt++;\\n            }\\n        }\\n        int[] ansArr = new int[ans.size()];\\n        for (int i = 0; i < ans.size(); i++) {\\n            ansArr[i] = ans.get(i);\\n        }\\n        return ansArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        List<Integer> res = new ArrayList<>();\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int sizeLim = (int)(Math.ceil(Math.min(r, c) / 2.0));\\n        // go through all sizes        \\n        for (int s = 1; s <= sizeLim; s++) {\\n            for (int i = 0; i < r - (2 * (s - 1)); i++) {\\n                for (int j = s - 1; j < c - s + 1; j++) {\\n                    int sum = 0;\\n                    // iterate through all sides\\n                    int currI = i;\\n                    int currJ = j;\\n                    sum += grid[currI][currJ];\\n                    for (int k = 0; k < 4; k++) {\\n                        // travel down one side\\n                        for (int l = 0; l < s - 1; l++) {                            \\n                            if (k == 0) {\\n                                currI++;\\n                                currJ++;\\n                            }\\n                            if (k == 1) {\\n                                currI++;\\n                                currJ--;\\n                            }\\n                            if (k == 2) {\\n                                currI--;\\n                                currJ--;\\n                            }\\n                            if (k == 3) {\\n                                currI--;\\n                                currJ++;\\n                            }\\n                            sum += grid[currI][currJ];\\n                        }\\n                    }\\n                    if (s > 1) {\\n                        sum -= grid[currI][currJ];\\n                    }\\n                    res.add(sum);\\n                }\\n            }\\n        }\\n        Collections.sort(res);\\n        List<Integer> ans = new ArrayList<>();\\n        int cnt = 0;\\n        for (int i = res.size() - 1; i >= 0 && cnt < 3; i--) {\\n            if (!ans.contains(res.get(i))) {\\n                ans.add(res.get(i));\\n                cnt++;\\n            }\\n        }\\n        int[] ansArr = new int[ans.size()];\\n        for (int i = 0; i < ans.size(); i++) {\\n            ansArr[i] = ans.get(i);\\n        }\\n        return ansArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245000,
                "title": "bf-cpp-o-n3",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        set<int> s;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                s.insert(grid[i][j]);\\n                if(s.size() > 3){\\n                    s.erase(s.begin());\\n                }\\n                int k = 1;\\n                while(i+2*k < n and j-k >= 0 and j+k < m){\\n                    int sum = grid[i][j];\\n                    sum+=grid[i+2*k][j];\\n                    for(int p = 1 ; p < k ; p++){\\n                        sum+=grid[i+p][j-p]+grid[i+p][j+p]+grid[i+2*k-p][j-p]+grid[i+2*k-p][j+p];\\n                    }\\n                    sum+=grid[i+k][j-k] + grid[i+k][j+k];\\n                    s.insert(sum);\\n                    if(s.size() > 3){\\n                        s.erase(s.begin());\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return vector<int>(rbegin(s) , rend(s));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        set<int> s;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                s.insert(grid[i][j]);\\n                if(s.size() > 3){\\n                    s.erase(s.begin());\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1244560,
                "title": "c-faster-than-85",
                "content": "```\\nclass Solution {\\n    priority_queue<int> maxHeap;\\npublic:\\n    void solve(vector<vector<int>>& grid,int i,int j,int ii,int jj,int res){\\n        int x=ii,y=jj,n=grid.size(),m=grid[0].size();\\n        \\n        while(y!=j && x+1<n ){\\n            x++;\\n            y++;\\n            res+=grid[x][y];\\n        }\\n        if(y!=j && x+1==n) return;\\n        \\n        while(x!=ii && y+1<m){\\n            x--;\\n            y++;\\n            res+=grid[x][y];\\n        }\\n        if(x!=ii && y+1==m) return;\\n        \\n        while(x-1!=i){\\n            x--;\\n            y--;\\n            res+=grid[x][y];\\n        }\\n        \\n        maxHeap.push(res);\\n        \\n        return;\\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                maxHeap.push(grid[i][j]);\\n                \\n                int jj=j,ii=i,sum=grid[i][j];\\n                while(jj-1>=0 && ii+1<n){\\n                    jj--;\\n                    ii++;\\n                    sum+=grid[ii][jj];\\n                    solve(grid,i,j,ii,jj,sum);\\n                }\\n            }\\n        }\\n        \\n        set<int> s;\\n        vector<int> res;\\n        while(!maxHeap.empty() && s.size()!=3){\\n            int curr=maxHeap.top();\\n            if(s.find(curr)==s.end()){\\n                s.insert(curr);\\n                res.push_back(curr);\\n            }\\n            maxHeap.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    priority_queue<int> maxHeap;\\npublic:\\n    void solve(vector<vector<int>>& grid,int i,int j,int ii,int jj,int res){\\n        int x=ii,y=jj,n=grid.size(),m=grid[0].size();\\n        \\n        while(y!=j && x+1<n ){\\n            x++;\\n            y++;\\n            res+=grid[x][y];\\n        }\\n        if(y!=j && x+1==n) return;\\n        \\n        while(x!=ii && y+1<m){\\n            x--;\\n            y++;\\n            res+=grid[x][y];\\n        }\\n        if(x!=ii && y+1==m) return;\\n        \\n        while(x-1!=i){\\n            x--;\\n            y--;\\n            res+=grid[x][y];\\n        }\\n        \\n        maxHeap.push(res);\\n        \\n        return;\\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                maxHeap.push(grid[i][j]);\\n                \\n                int jj=j,ii=i,sum=grid[i][j];\\n                while(jj-1>=0 && ii+1<n){\\n                    jj--;\\n                    ii++;\\n                    sum+=grid[ii][jj];\\n                    solve(grid,i,j,ii,jj,sum);\\n                }\\n            }\\n        }\\n        \\n        set<int> s;\\n        vector<int> res;\\n        while(!maxHeap.empty() && s.size()!=3){\\n            int curr=maxHeap.top();\\n            if(s.find(curr)==s.end()){\\n                s.insert(curr);\\n                res.push_back(curr);\\n            }\\n            maxHeap.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244300,
                "title": "python3-brute-force-meet-in-the-middle",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        l = min((n + 1) // 2, (m + 1) // 2)\\n        dirs = [[1, 1], [-1, 1], [-1, -1], [1, -1]]\\n        pq = []\\n        seen = set()\\n        for i in range(n):\\n            for j in range(m):\\n                for k in range(l):\\n                    if not grid[i][j] in seen:\\n                        seen.add(grid[i][j])\\n                        heappush(pq, grid[i][j])\\n                    if len(pq) > 3:\\n                        heappop(pq)\\n                    cur = [i, j]\\n                    sum = 0\\n                    break_flag = False\\n                    for dir in dirs:\\n                        for _ in range(k):\\n                            cur[0], cur[1] = cur[0] + dir[0], cur[1] + dir[1]\\n                            if cur[0] < 0 or cur[0] == n or cur[1] < 0 or cur[1] == m:\\n                                break_flag = True\\n                                break\\n                            sum += grid[cur[0]][cur[1]]\\n                        if break_flag:\\n                            break\\n                    if not break_flag and k != 0:\\n                        if not sum in seen:\\n                            seen.add(sum)\\n                            heappush(pq, sum)\\n                        if len(pq) > 3:\\n                            heappop(pq)\\n        pq.sort(reverse=True)\\n        return pq\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        l = min((n + 1) // 2, (m + 1) // 2)\\n        dirs = [[1, 1], [-1, 1], [-1, -1], [1, -1]]\\n        pq = []\\n        seen = set()\\n        for i in range(n):\\n            for j in range(m):\\n                for k in range(l):\\n                    if not grid[i][j] in seen:\\n                        seen.add(grid[i][j])\\n                        heappush(pq, grid[i][j])\\n                    if len(pq) > 3:\\n                        heappop(pq)\\n                    cur = [i, j]\\n                    sum = 0\\n                    break_flag = False\\n                    for dir in dirs:\\n                        for _ in range(k):\\n                            cur[0], cur[1] = cur[0] + dir[0], cur[1] + dir[1]\\n                            if cur[0] < 0 or cur[0] == n or cur[1] < 0 or cur[1] == m:\\n                                break_flag = True\\n                                break\\n                            sum += grid[cur[0]][cur[1]]\\n                        if break_flag:\\n                            break\\n                    if not break_flag and k != 0:\\n                        if not sum in seen:\\n                            seen.add(sum)\\n                            heappush(pq, sum)\\n                        if len(pq) > 3:\\n                            heappop(pq)\\n        pq.sort(reverse=True)\\n        return pq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243856,
                "title": "java-easy-understand-brute-force",
                "content": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        TreeSet<Integer> set = new TreeSet();\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                for (int sz = 0; sz * 2 + r < m && c - sz >= 0 && c + sz < n; sz++) {\\n                    int x = r, y = c, sum = 0;\\n                    if (sz == 0) {\\n                        sum = grid[x][y];\\n                    } else {\\n                        while (y < c + sz) {\\n                            sum += grid[x++][y++];\\n                        }\\n                        while (y > c) {\\n                            sum += grid[x++][y--];\\n                        }\\n                        while (y > c - sz) {\\n                            sum += grid[x--][y--];\\n                        }\\n                        while (y < c) {\\n                            sum += grid[x--][y++];\\n                        }\\n                    } \\n                    set.add(sum);\\n                    if (set.size() > 3) {\\n                        set.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        int idx = set.size();\\n        int[] ans = new int[idx];\\n        while (idx > 0) {\\n            ans[--idx] = set.pollFirst();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getBiggestThree(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        TreeSet<Integer> set = new TreeSet();\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                for (int sz = 0; sz * 2 + r < m && c - sz >= 0 && c + sz < n; sz++) {\\n                    int x = r, y = c, sum = 0;\\n                    if (sz == 0) {\\n                        sum = grid[x][y];\\n                    } else {\\n                        while (y < c + sz) {\\n                            sum += grid[x++][y++];\\n                        }\\n                        while (y > c) {\\n                            sum += grid[x++][y--];\\n                        }\\n                        while (y > c - sz) {\\n                            sum += grid[x--][y--];\\n                        }\\n                        while (y < c) {\\n                            sum += grid[x--][y++];\\n                        }\\n                    } \\n                    set.add(sum);\\n                    if (set.size() > 3) {\\n                        set.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        int idx = set.size();\\n        int[] ans = new int[idx];\\n        while (idx > 0) {\\n            ans[--idx] = set.pollFirst();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243734,
                "title": "simple-cpp-solution-with-explanation-o-n-4-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    //Update the result variable with current sum\\n    void updateMax(vector<int> &res, int sum)\\n    {\\n        if(sum > res[0] && sum != res[1] && sum != res[2])\\n        {\\n            res[2] = res[1];\\n            res[1] = res[0];\\n            res[0] = sum;\\n        }\\n        else if(sum > res[1] && sum != res[0] && sum != res[2])\\n        {\\n            res[2] = res[1];\\n            res[1] = sum;\\n        }\\n        else if(sum > res[2] && sum != res[0] && sum != res[1])\\n            res[2] = sum;\\n    }\\n    \\n    //calculate sum of the boarder of rhombus formed from {row,col} with sideLen\\n    int calculateArea(vector<vector<int>> &grid, int row, int col, int sideLen)\\n    {\\n        int sum = 0;\\n        \\n        //keep going down-right and add sideLen number of elements to sum\\n        for(int i = 0; i < sideLen; i++) sum += grid[row++][col++];\\n        \\n        //Go down-left\\n        for(int i = 0; i < sideLen; i++) sum += grid[row++][col--];\\n        \\n        //Go up-left\\n        for(int i = 0; i < sideLen; i++) sum += grid[row--][col--];\\n        \\n        //Go up-right\\n        for(int i = 0; i < sideLen; i++) sum += grid[row--][col++];\\n        \\n        return sum;\\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int rowSize = grid.size(), colSize = grid[0].size();\\n        vector<int> res = {INT_MIN, INT_MIN, INT_MIN};\\n        int smallestLen = min(rowSize, colSize);\\n        \\n        //Each cell is considered to be rhombus of area = 0. So, take first 3 max elements from matrix.\\n        for(auto vec : grid)\\n        {\\n            for(auto i : vec)\\n                updateMax(res, i);\\n        }\\n        \\n        //Start with rhombus of side length = 1. The max side length our rhombus can have is smallestLen/2.\\n        for(int sideLen = 1; sideLen <= smallestLen / 2; sideLen++)\\n        {\\n            //Start iterating with given limits. row < rowSize - (2 * sideLen) && col < colSize - sideLen\\n            for(int i = 0; i < rowSize - (2 * sideLen); i++)\\n            {\\n                for(int j = sideLen; j < colSize - sideLen; j++)\\n                {\\n                    int area = calculateArea(grid, i, j, sideLen);\\n                    updateMax(res, area);\\n                }\\n            }\\n        }\\n        \\n        //Pop out default values from result vector if available.\\n        while(!res.empty() && res.back() == INT_MIN)\\n            res.pop_back();\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Update the result variable with current sum\\n    void updateMax(vector<int> &res, int sum)\\n    {\\n        if(sum > res[0] && sum != res[1] && sum != res[2])\\n        {\\n            res[2] = res[1];\\n            res[1] = res[0];\\n            res[0] = sum;\\n        }\\n        else if(sum > res[1] && sum != res[0] && sum != res[2])\\n        {\\n            res[2] = res[1];\\n            res[1] = sum;\\n        }\\n        else if(sum > res[2] && sum != res[0] && sum != res[1])\\n            res[2] = sum;\\n    }\\n    \\n    //calculate sum of the boarder of rhombus formed from {row,col} with sideLen\\n    int calculateArea(vector<vector<int>> &grid, int row, int col, int sideLen)\\n    {\\n        int sum = 0;\\n        \\n        //keep going down-right and add sideLen number of elements to sum\\n        for(int i = 0; i < sideLen; i++) sum += grid[row++][col++];\\n        \\n        //Go down-left\\n        for(int i = 0; i < sideLen; i++) sum += grid[row++][col--];\\n        \\n        //Go up-left\\n        for(int i = 0; i < sideLen; i++) sum += grid[row--][col--];\\n        \\n        //Go up-right\\n        for(int i = 0; i < sideLen; i++) sum += grid[row--][col++];\\n        \\n        return sum;\\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int rowSize = grid.size(), colSize = grid[0].size();\\n        vector<int> res = {INT_MIN, INT_MIN, INT_MIN};\\n        int smallestLen = min(rowSize, colSize);\\n        \\n        //Each cell is considered to be rhombus of area = 0. So, take first 3 max elements from matrix.\\n        for(auto vec : grid)\\n        {\\n            for(auto i : vec)\\n                updateMax(res, i);\\n        }\\n        \\n        //Start with rhombus of side length = 1. The max side length our rhombus can have is smallestLen/2.\\n        for(int sideLen = 1; sideLen <= smallestLen / 2; sideLen++)\\n        {\\n            //Start iterating with given limits. row < rowSize - (2 * sideLen) && col < colSize - sideLen\\n            for(int i = 0; i < rowSize - (2 * sideLen); i++)\\n            {\\n                for(int j = sideLen; j < colSize - sideLen; j++)\\n                {\\n                    int area = calculateArea(grid, i, j, sideLen);\\n                    updateMax(res, area);\\n                }\\n            }\\n        }\\n        \\n        //Pop out default values from result vector if available.\\n        while(!res.empty() && res.back() == INT_MIN)\\n            res.pop_back();\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243326,
                "title": "python3-brute-force",
                "content": "```\\ndef getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        max_sums = [0, 0, 0]\\n        s = 0   \\n        \\n        # increment from 0 to grid side length / 2 for the maximal rhombus dims\\n        while s <= int(len(grid) / 2):\\n            # this loop gives us the center of the rhombus\\n            for i in range(0 + s, len(grid) - s):\\n                for j in range(0 + s, len(grid[0]) - s):\\n                    # sum up the values at the indices of the rhombus edges\\n                    if s > 0:\\n                        cs = grid[i - s][j] + grid[i + s][j]\\n                        for l in range(1, s):\\n                            cs += grid[i - (s - l)][j - l]\\n                            cs += grid[i - (s - l)][j + l]\\n                            cs += grid[i + (s - l)][j - l]\\n                            cs += grid[i + (s - l)][j + l]\\n                        cs += grid[i][j - s] + grid[i][j + s]\\n                    else:\\n                        cs = grid[i][j]\\n                    \\n                    # update max_sums\\n                    for v in range(len(max_sums)):\\n                        if max_sums[v] < cs:\\n                            cs, max_sums[v] = max_sums[v], cs\\n                        elif max_sums[v] == cs:\\n                            break\\n            # increment rhombus side length\\n            s += 1\\n        # solution does not want zeroes\\n        return [x for x in max_sums if x]\\n```",
                "solutionTags": [],
                "code": "```\\ndef getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        max_sums = [0, 0, 0]\\n        s = 0   \\n        \\n        # increment from 0 to grid side length / 2 for the maximal rhombus dims\\n        while s <= int(len(grid) / 2):\\n            # this loop gives us the center of the rhombus\\n            for i in range(0 + s, len(grid) - s):\\n                for j in range(0 + s, len(grid[0]) - s):\\n                    # sum up the values at the indices of the rhombus edges\\n                    if s > 0:\\n                        cs = grid[i - s][j] + grid[i + s][j]\\n                        for l in range(1, s):\\n                            cs += grid[i - (s - l)][j - l]\\n                            cs += grid[i - (s - l)][j + l]\\n                            cs += grid[i + (s - l)][j - l]\\n                            cs += grid[i + (s - l)][j + l]\\n                        cs += grid[i][j - s] + grid[i][j + s]\\n                    else:\\n                        cs = grid[i][j]\\n                    \\n                    # update max_sums\\n                    for v in range(len(max_sums)):\\n                        if max_sums[v] < cs:\\n                            cs, max_sums[v] = max_sums[v], cs\\n                        elif max_sums[v] == cs:\\n                            break\\n            # increment rhombus side length\\n            s += 1\\n        # solution does not want zeroes\\n        return [x for x in max_sums if x]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1243140,
                "title": "c-clean-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        set<int> bestOfThree;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                getMaxRhomSum(i, j, m, n, grid, bestOfThree);\\n            }   \\n        }\\n        vector<int> result(rbegin(bestOfThree), rend(bestOfThree));\\n        return result;\\n    }\\n    \\n    void updateBestOfThree(set<int> &bestOfThree, int &curSum) {\\n        // Update set\\n        bestOfThree.insert(curSum);\\n        if (bestOfThree.size() > 3) {\\n            bestOfThree.erase(bestOfThree.begin());\\n        }\\n    }\\n    \\n    // Returns maximum rhombus sum for given point\\n    void getMaxRhomSum(int i, int j, int &m, int &n, vector<vector<int>> &grid, set<int> &bestOfThree) {\\n        // Update set, Include single point as well\\n        updateBestOfThree(bestOfThree, grid[i][j]);\\n                                        //   up          down          left         right\\n        vector<vector<int>> points = { { i - 1, j }, { i + 1, j }, { i, j - 1 }, { i, j + 1 } };\\n        while (inside(points, m, n)) {\\n            // Get square sum for current four points\\n                                         // up        down       left      right\\n            int squareSum = getSquareSum(points[0], points[1], points[2], points[3], grid);\\n            \\n            // Update set\\n            updateBestOfThree(bestOfThree, squareSum);\\n            \\n            // Update points\\n            points[0][0] -= 1;\\n            points[1][0] += 1;\\n            points[2][1] -= 1;\\n            points[3][1] += 1;\\n        }\\n    }\\n    \\n    // Calculates rhomsum for given square rotated 45 degree\\n    int getSquareSum(vector<int> up, vector<int> down, vector<int> left, vector<int> right, vector<vector<int>> &grid) {\\n        int squareSum = 0;\\n        for (int stepsLeft = (down[0] - up[0]) / 2; stepsLeft > 0; stepsLeft--) {\\n            squareSum += grid[up[0]++][up[1]++];\\n            squareSum += grid[down[0]--][down[1]--];\\n            squareSum += grid[left[0]--][left[1]++];\\n            squareSum += grid[right[0]++][right[1]--];\\n        }\\n        return squareSum;\\n    }\\n    \\n    // Checks if given point is inside of the grid\\n    bool inside(vector<vector<int>> &points, int &m, int &n) {\\n        for (vector<int> &point : points) {\\n            if (point[0] >= m || point[0] < 0 || point[1] >= n || point[1] < 0 ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        set<int> bestOfThree;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                getMaxRhomSum(i, j, m, n, grid, bestOfThree);\\n            }   \\n        }\\n        vector<int> result(rbegin(bestOfThree), rend(bestOfThree));\\n        return result;\\n    }\\n    \\n    void updateBestOfThree(set<int> &bestOfThree, int &curSum) {\\n        // Update set\\n        bestOfThree.insert(curSum);\\n        if (bestOfThree.size() > 3) {\\n            bestOfThree.erase(bestOfThree.begin());\\n        }\\n    }\\n    \\n    // Returns maximum rhombus sum for given point\\n    void getMaxRhomSum(int i, int j, int &m, int &n, vector<vector<int>> &grid, set<int> &bestOfThree) {\\n        // Update set, Include single point as well\\n        updateBestOfThree(bestOfThree, grid[i][j]);\\n                                        //   up          down          left         right\\n        vector<vector<int>> points = { { i - 1, j }, { i + 1, j }, { i, j - 1 }, { i, j + 1 } };\\n        while (inside(points, m, n)) {\\n            // Get square sum for current four points\\n                                         // up        down       left      right\\n            int squareSum = getSquareSum(points[0], points[1], points[2], points[3], grid);\\n            \\n            // Update set\\n            updateBestOfThree(bestOfThree, squareSum);\\n            \\n            // Update points\\n            points[0][0] -= 1;\\n            points[1][0] += 1;\\n            points[2][1] -= 1;\\n            points[3][1] += 1;\\n        }\\n    }\\n    \\n    // Calculates rhomsum for given square rotated 45 degree\\n    int getSquareSum(vector<int> up, vector<int> down, vector<int> left, vector<int> right, vector<vector<int>> &grid) {\\n        int squareSum = 0;\\n        for (int stepsLeft = (down[0] - up[0]) / 2; stepsLeft > 0; stepsLeft--) {\\n            squareSum += grid[up[0]++][up[1]++];\\n            squareSum += grid[down[0]--][down[1]--];\\n            squareSum += grid[left[0]--][left[1]++];\\n            squareSum += grid[right[0]++][right[1]--];\\n        }\\n        return squareSum;\\n    }\\n    \\n    // Checks if given point is inside of the grid\\n    bool inside(vector<vector<int>> &points, int &m, int &n) {\\n        for (vector<int> &point : points) {\\n            if (point[0] >= m || point[0] < 0 || point[1] >= n || point[1] < 0 ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242607,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(matrix) {\\n    const rowC = matrix.length\\n    const colC = matrix[0].length\\n    \\n    // sum => val[]\\n    const sumMap = new Map()\\n    // diff => val[]\\n    const diffMap = new Map()\\n    \\n    let results = new Set()\\n    for (const [i, row] of matrix.entries()) {\\n        for (const [j, val] of row.entries()) {\\n            const sum = i + j, diff = i - j\\n            if (!sumMap.has(sum))   sumMap.set(sum, [])\\n            if (!diffMap.has(diff)) diffMap.set(diff, [])\\n            \\n            sumMap.get(sum).push(val)\\n            diffMap.get(diff).push(val)\\n            results.add(val)\\n        }\\n    }\\n    \\n    \\n    function toSumSF(list) {\\n        const len = list.length\\n        let result = new Array(len)\\n        result[-1] = 0\\n        \\n        for (const [i, val] of list.entries())\\n            result[i] = val + result[-1 + i]\\n        \\n        return result\\n    }\\n    \\n    for (const [key, list] of sumMap.entries())\\n        sumMap.set(key, toSumSF(list))\\n    for (const [key, list] of diffMap.entries())\\n        diffMap.set(key, toSumSF(list))\\n        \\n        \\n    function getMaxSide(upI, upJ) {\\n        let leftResult = 1 + upJ\\n        let rightResult = colC - upJ\\n        let downResult = 1 + Math.floor((rowC - upI - 1) / 2)\\n        \\n        let result = Math.min(leftResult, rightResult, downResult)\\n        return result\\n    }\\n    \\n    function getStartIOfSum(sum) {\\n        if (sum < colC) return 0\\n        else return sum - colC + 1\\n    }\\n    \\n    function getStartIOfDiff(diff) {\\n        if (diff <= 0)  return 0\\n        else return diff\\n    }\\n    \\n    \\n    for (let upI = 0; upI < rowC; upI++) {\\n        for (let upJ = 0; upJ < colC; upJ++) {\\n            const maxSide = getMaxSide(upI, upJ)\\n            for (let side = 2; side <= maxSide; side++) {\\n                const delta = side - 1\\n                const leftI = upI + delta\\n                const leftJ = upJ - delta\\n                const rightI = upI + delta\\n                const rightJ = upJ + delta\\n                const downI = upI + delta * 2\\n                const downJ = upJ\\n                \\n                const upVal = matrix[upI][upJ]\\n                const leftVal = matrix[leftI][leftJ]\\n                const rightVal = matrix[rightI][rightJ]\\n                const downVal = matrix[downI][downJ]\\n                \\n                const sumA = upI + upJ, sumB = downI + downJ\\n                const diffA = upI - upJ, diffB = downI - downJ\\n                const sumListA = sumMap.get(sumA)\\n                const sumListB = sumMap.get(sumB)\\n                const diffListA = diffMap.get(diffA)\\n                const diffListB = diffMap.get(diffB)\\n                \\n                const sideUpLeft = sumListA[leftI - getStartIOfSum(sumA)] - sumListA[-1 + upI - getStartIOfSum(sumA)]\\n                const sideDownRight = sumListB[downI - getStartIOfSum(sumB)] - sumListB[-1 + rightI - getStartIOfSum(sumB)]\\n                const sideUpRight = diffListA[rightI - getStartIOfDiff(diffA)] - diffListA[-1 + upI - getStartIOfDiff(diffA)]\\n                const sideDownLeft = diffListB[downI - getStartIOfDiff(diffB)] - diffListB[-1 + leftI - getStartIOfDiff(diffB)]\\n                \\n                let outcome = (sideUpLeft + sideDownRight + sideUpRight + sideDownLeft) -\\n                    (upVal + leftVal + rightVal + downVal)\\n                results.add(outcome)\\n            }\\n        }\\n    }\\n    \\n    \\n    results = [...results]\\n    results.sort((a, b) => b - a)\\n    results = results.slice(0, 3)\\n    return results\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number[]}\\n */\\nvar getBiggestThree = function(matrix) {\\n    const rowC = matrix.length\\n    const colC = matrix[0].length\\n    \\n    // sum => val[]\\n    const sumMap = new Map()\\n    // diff => val[]\\n    const diffMap = new Map()\\n    \\n    let results = new Set()\\n    for (const [i, row] of matrix.entries()) {\\n        for (const [j, val] of row.entries()) {\\n            const sum = i + j, diff = i - j\\n            if (!sumMap.has(sum))   sumMap.set(sum, [])\\n            if (!diffMap.has(diff)) diffMap.set(diff, [])\\n            \\n            sumMap.get(sum).push(val)\\n            diffMap.get(diff).push(val)\\n            results.add(val)\\n        }\\n    }\\n    \\n    \\n    function toSumSF(list) {\\n        const len = list.length\\n        let result = new Array(len)\\n        result[-1] = 0\\n        \\n        for (const [i, val] of list.entries())\\n            result[i] = val + result[-1 + i]\\n        \\n        return result\\n    }\\n    \\n    for (const [key, list] of sumMap.entries())\\n        sumMap.set(key, toSumSF(list))\\n    for (const [key, list] of diffMap.entries())\\n        diffMap.set(key, toSumSF(list))\\n        \\n        \\n    function getMaxSide(upI, upJ) {\\n        let leftResult = 1 + upJ\\n        let rightResult = colC - upJ\\n        let downResult = 1 + Math.floor((rowC - upI - 1) / 2)\\n        \\n        let result = Math.min(leftResult, rightResult, downResult)\\n        return result\\n    }\\n    \\n    function getStartIOfSum(sum) {\\n        if (sum < colC) return 0\\n        else return sum - colC + 1\\n    }\\n    \\n    function getStartIOfDiff(diff) {\\n        if (diff <= 0)  return 0\\n        else return diff\\n    }\\n    \\n    \\n    for (let upI = 0; upI < rowC; upI++) {\\n        for (let upJ = 0; upJ < colC; upJ++) {\\n            const maxSide = getMaxSide(upI, upJ)\\n            for (let side = 2; side <= maxSide; side++) {\\n                const delta = side - 1\\n                const leftI = upI + delta\\n                const leftJ = upJ - delta\\n                const rightI = upI + delta\\n                const rightJ = upJ + delta\\n                const downI = upI + delta * 2\\n                const downJ = upJ\\n                \\n                const upVal = matrix[upI][upJ]\\n                const leftVal = matrix[leftI][leftJ]\\n                const rightVal = matrix[rightI][rightJ]\\n                const downVal = matrix[downI][downJ]\\n                \\n                const sumA = upI + upJ, sumB = downI + downJ\\n                const diffA = upI - upJ, diffB = downI - downJ\\n                const sumListA = sumMap.get(sumA)\\n                const sumListB = sumMap.get(sumB)\\n                const diffListA = diffMap.get(diffA)\\n                const diffListB = diffMap.get(diffB)\\n                \\n                const sideUpLeft = sumListA[leftI - getStartIOfSum(sumA)] - sumListA[-1 + upI - getStartIOfSum(sumA)]\\n                const sideDownRight = sumListB[downI - getStartIOfSum(sumB)] - sumListB[-1 + rightI - getStartIOfSum(sumB)]\\n                const sideUpRight = diffListA[rightI - getStartIOfDiff(diffA)] - diffListA[-1 + upI - getStartIOfDiff(diffA)]\\n                const sideDownLeft = diffListB[downI - getStartIOfDiff(diffB)] - diffListB[-1 + leftI - getStartIOfDiff(diffB)]\\n                \\n                let outcome = (sideUpLeft + sideDownRight + sideUpRight + sideDownLeft) -\\n                    (upVal + leftVal + rightVal + downVal)\\n                results.add(outcome)\\n            }\\n        }\\n    }\\n    \\n    \\n    results = [...results]\\n    results.sort((a, b) => b - a)\\n    results = results.slice(0, 3)\\n    return results\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242464,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        set<int> v;\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                v.insert(grid[i][j]);\\n            }\\n        }\\n        for (int k = 1; k<=n/2;k++)\\n        {\\n            for (int i = 0 ; i < n ; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (pos(n,m,i,j,k))\\n                        v.insert(getSum(grid,i,j,k));\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (const auto & i : v)\\n        {\\n            ans.push_back(i);\\n        }\\n        int k1 = ans.size();\\n        reverse(ans.begin(), ans.end());\\n        \\n        if (k1<3)\\n            return ans;\\n        ans.resize(3);\\n        return ans;\\n    }\\n    bool pos(int n, int m, int i, int j, int s)\\n    {\\n        return i+2*s<n && j+s<m && j-s>=0;\\n    }\\n    int getSum(vector<vector<int>>& grid, int i, int j, int s)\\n    {\\n        int ans = 0;\\n        int i1 = i, j1 = j;\\n        while(i1<=i+s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1++;\\n        }\\n         i1 = i, j1 = j;\\n        while(i1<=i+s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1--;\\n        }\\n         i1 = i+s, j1 = j-s;\\n        while(i1<=i+2*s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1++;\\n        }\\n         i1 = i+s, j1 = j+s;\\n        while(i1<=i+2*s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1--;\\n        }\\n        ans = ans-grid[i][j]-grid[i+2*s][j]-grid[i+s][j-s]-grid[i+s][j+s];\\n        //cout<<i<<\" \"<<j<<\" \"<<s<<\" \"<<ans<<endl;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        set<int> v;\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                v.insert(grid[i][j]);\\n            }\\n        }\\n        for (int k = 1; k<=n/2;k++)\\n        {\\n            for (int i = 0 ; i < n ; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (pos(n,m,i,j,k))\\n                        v.insert(getSum(grid,i,j,k));\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (const auto & i : v)\\n        {\\n            ans.push_back(i);\\n        }\\n        int k1 = ans.size();\\n        reverse(ans.begin(), ans.end());\\n        \\n        if (k1<3)\\n            return ans;\\n        ans.resize(3);\\n        return ans;\\n    }\\n    bool pos(int n, int m, int i, int j, int s)\\n    {\\n        return i+2*s<n && j+s<m && j-s>=0;\\n    }\\n    int getSum(vector<vector<int>>& grid, int i, int j, int s)\\n    {\\n        int ans = 0;\\n        int i1 = i, j1 = j;\\n        while(i1<=i+s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1++;\\n        }\\n         i1 = i, j1 = j;\\n        while(i1<=i+s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1--;\\n        }\\n         i1 = i+s, j1 = j-s;\\n        while(i1<=i+2*s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1++;\\n        }\\n         i1 = i+s, j1 = j+s;\\n        while(i1<=i+2*s)\\n        {\\n            ans += grid[i1][j1];\\n            i1++;j1--;\\n        }\\n        ans = ans-grid[i][j]-grid[i+2*s][j]-grid[i+s][j-s]-grid[i+s][j+s];\\n        //cout<<i<<\" \"<<j<<\" \"<<s<<\" \"<<ans<<endl;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1242275,
                "title": "java-mirroring-approach-with-early-termination-56ms",
                "content": "```\\nclass Solution {\\n    int n, m;\\n    int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int[][] mirrors = {{1,1},{-1,-1},{-1,1},{1,-1}};\\n    void sort3(TreeSet<Integer> ans, int num) {\\n        ans.add(num);\\n        if (ans.size()>3)\\n            ans.pollFirst();\\n    }\\n    \\n    boolean inRagne(int x, int y, int size) {\\n        for (int[] dir: dirs) {\\n            int xx = x+dir[0]*size, yy=y+dir[1]*size;\\n            if (xx<0 || yy<0 || xx>=n || yy>=m) return false;\\n        }   \\n        return true;\\n    }\\n    \\n    int findSum(int[][] grid, int x, int y, int size) {\\n        if (size==0) return grid[x][y];\\n        int sum = 0;\\n        for (int i=1, j=size-i; j>=1; i++, j--) \\n            for (int[] mirror: mirrors) \\n                sum += grid[x+i*mirror[0]][y+j*mirror[1]];\\n            \\n        for (int[] dir: dirs) \\n            sum += grid[x+size*dir[0]][y+size*dir[1]];\\n    \\n        return sum;\\n    }\\n    \\n    public int[] getBiggestThree(int[][] grid) {\\n        this.n = grid.length;\\n        this.m = grid[0].length;     \\n        TreeSet<Integer> ans = new TreeSet<>();\\n        for (int i=0; i<n; i++) \\n            for (int j=0; j<m; j++) \\n                for (int l=0; l<Math.min(n, m); l++) \\n                    if (inRagne(i,j,l))\\n                        sort3(ans, findSum(grid, i, j, l));\\n                    else break; // early termination\\n                \\n        return ans.descendingSet().stream().mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int[][] mirrors = {{1,1},{-1,-1},{-1,1},{1,-1}};\\n    void sort3(TreeSet<Integer> ans, int num) {\\n        ans.add(num);\\n        if (ans.size()>3)\\n            ans.pollFirst();\\n    }\\n    \\n    boolean inRagne(int x, int y, int size) {\\n        for (int[] dir: dirs) {\\n            int xx = x+dir[0]*size, yy=y+dir[1]*size;\\n            if (xx<0 || yy<0 || xx>=n || yy>=m) return false;\\n        }   \\n        return true;\\n    }\\n    \\n    int findSum(int[][] grid, int x, int y, int size) {\\n        if (size==0) return grid[x][y];\\n        int sum = 0;\\n        for (int i=1, j=size-i; j>=1; i++, j--) \\n            for (int[] mirror: mirrors) \\n                sum += grid[x+i*mirror[0]][y+j*mirror[1]];\\n            \\n        for (int[] dir: dirs) \\n            sum += grid[x+size*dir[0]][y+size*dir[1]];\\n    \\n        return sum;\\n    }\\n    \\n    public int[] getBiggestThree(int[][] grid) {\\n        this.n = grid.length;\\n        this.m = grid[0].length;     \\n        TreeSet<Integer> ans = new TreeSet<>();\\n        for (int i=0; i<n; i++) \\n            for (int j=0; j<m; j++) \\n                for (int l=0; l<Math.min(n, m); l++) \\n                    if (inRagne(i,j,l))\\n                        sort3(ans, findSum(grid, i, j, l));\\n                    else break; // early termination\\n                \\n        return ans.descendingSet().stream().mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242236,
                "title": "c",
                "content": "similar to accumulated sum, use dp and dp1 to store the accumulated sum in diagonal. So we can caculate a Rhomobus in O(1).\\n\\n                        sum = dp[i1][j1] + dp[x1][y1] - dp[x][y] - dp[i][j]; \\n                        sum += dp1[x][y] + dp1[i1][j1] - dp1[x1][y1] - dp1[i][j];\\n                        sum += grid[i][j] - grid[i1][j1];\\nThen cacualte all the rhombus sum.\\n\\nAnother thing worth mention is that this problem does not allow duplication, so better use a set instead of heap or priority_queue.\\n\\t\\t\\t\\t\\t\\n```\\nstruct cmp\\n{\\n    bool operator() (long long l, long long r)\\n    {\\n        return l > r;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    bool valid(int x, int y)\\n    {\\n        if (x >= 0 && x < n && y >= 0 && y < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<long long>>(n, vector<long long>(m, 0));\\n        dp1 = vector<vector<long long>>(n, vector<long long>(m, 0));\\n        //cout << \"ep1\" << endl;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                int x = i -1;\\n                int y = j -1;\\n                long long cur = grid[i][j];\\n                if (valid(x, y))\\n                {\\n                    cur += dp[x][y];\\n                }\\n                dp[i][j] = cur;\\n                \\n                \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = m -1; j >= 0; j--)\\n            {\\n                int x1 = i - 1;\\n                int y1 = j + 1;\\n                long long cur = grid[i][j];\\n                if (valid(x1, y1))\\n                {\\n                    cur += dp1[x1][y1];\\n                }\\n                dp1[i][j] = cur;\\n            }\\n        }\\n         //cout << \"ep1\" << endl;\\n        set<int> q;\\n        \\n        for (int l = 0; l < n; l += 2)\\n        {\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int i1 = i + l;\\n                    int j1 = j;\\n                    int d = l / 2;\\n                    \\n                    int x = (i + i1) / 2;\\n                    int y = j - d;\\n                    \\n                    int x1 = x;\\n                    int y1 = j + d;\\n                    long long sum = 0;\\n                    if (l == 0)\\n                    {\\n                        sum = grid[i][j];\\n                    }\\n                    else if (\\n                        valid(i1, j1) &&\\n                        valid(x, y) &&\\n                        valid(x1, y1)\\n                    )\\n                    {\\n                        sum = dp[i1][j1] + dp[x1][y1] - dp[x][y] - dp[i][j]; \\n                        sum += dp1[x][y] + dp1[i1][j1] - dp1[x1][y1] - dp1[i][j];\\n                        sum += grid[i][j] - grid[i1][j1];\\n                    }\\n                    if (sum > 0)\\n                    {\\n                        q.insert(sum);\\n                        if (q.size() > 3)\\n                        {\\n                            // int sm = *q.begin();\\n                            q.erase(q.begin());\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int s = q.size();\\n        vector<int> ans;\\n        int i = 0;\\n        auto iter = q.rbegin();\\n        while (iter != q.rend())\\n        {\\n            i++;\\n            ans.push_back(*iter);\\n            iter++;\\n            if (i >=3)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct cmp\\n{\\n    bool operator() (long long l, long long r)\\n    {\\n        return l > r;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    bool valid(int x, int y)\\n    {\\n        if (x >= 0 && x < n && y >= 0 && y < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<long long>>(n, vector<long long>(m, 0));\\n        dp1 = vector<vector<long long>>(n, vector<long long>(m, 0));\\n        //cout << \"ep1\" << endl;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                int x = i -1;\\n                int y = j -1;\\n                long long cur = grid[i][j];\\n                if (valid(x, y))\\n                {\\n                    cur += dp[x][y];\\n                }\\n                dp[i][j] = cur;\\n                \\n                \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = m -1; j >= 0; j--)\\n            {\\n                int x1 = i - 1;\\n                int y1 = j + 1;\\n                long long cur = grid[i][j];\\n                if (valid(x1, y1))\\n                {\\n                    cur += dp1[x1][y1];\\n                }\\n                dp1[i][j] = cur;\\n            }\\n        }\\n         //cout << \"ep1\" << endl;\\n        set<int> q;\\n        \\n        for (int l = 0; l < n; l += 2)\\n        {\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int i1 = i + l;\\n                    int j1 = j;\\n                    int d = l / 2;\\n                    \\n                    int x = (i + i1) / 2;\\n                    int y = j - d;\\n                    \\n                    int x1 = x;\\n                    int y1 = j + d;\\n                    long long sum = 0;\\n                    if (l == 0)\\n                    {\\n                        sum = grid[i][j];\\n                    }\\n                    else if (\\n                        valid(i1, j1) &&\\n                        valid(x, y) &&\\n                        valid(x1, y1)\\n                    )\\n                    {\\n                        sum = dp[i1][j1] + dp[x1][y1] - dp[x][y] - dp[i][j]; \\n                        sum += dp1[x][y] + dp1[i1][j1] - dp1[x1][y1] - dp1[i][j];\\n                        sum += grid[i][j] - grid[i1][j1];\\n                    }\\n                    if (sum > 0)\\n                    {\\n                        q.insert(sum);\\n                        if (q.size() > 3)\\n                        {\\n                            // int sm = *q.begin();\\n                            q.erase(q.begin());\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int s = q.size();\\n        vector<int> ans;\\n        int i = 0;\\n        auto iter = q.rbegin();\\n        while (iter != q.rend())\\n        {\\n            i++;\\n            ans.push_back(*iter);\\n            iter++;\\n            if (i >=3)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1241955,
                "title": "c-expanding-rhombus-brute-force",
                "content": "```\\npublic class Solution {\\n    public int[] GetBiggestThree(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n        int maxSize = Math.Max(0, Math.Min(m, n) - 2);\\n        HashSet<int> r = new HashSet<int>();\\n        for (int i = 0; i <= maxSize; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    int sum = GetSum(grid, i, j, k);\\n                    if (sum != -1) r.Add(sum);\\n                }\\n            }\\n        }\\n        return r.GroupBy(x => x).Select(y => y.First()).ToList().OrderByDescending(j => j).Take(3).ToArray();\\n    }\\n    \\n    public int GetSum(int[][] g, int s, int i, int j) {\\n        if (s == 0) return g[i][j];\\n\\n        int r = g[i][j], m = g.Length, n = g[0].Length;\\n        int li = i, lj = j, ri = i, rj = j, cs = 0;\\n        while (cs < s) {\\n            li++;\\n            lj--;\\n            ri++;\\n            rj++;\\n            if (li >= m || lj < 0 || ri >= m || rj >= n) return -1;\\n            r += g[li][lj] + g[ri][rj];\\n            cs++;\\n        }\\n        \\n        while (cs > 0) {\\n            li++;\\n            lj++;\\n            ri++;\\n            rj--;\\n            if (li >= m || lj < 0 || ri >= m || rj >= n) return -1;\\n            r = lj == rj ? r + g[li][lj] : r + g[li][lj] + g[ri][rj];\\n            cs--;\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] GetBiggestThree(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n        int maxSize = Math.Max(0, Math.Min(m, n) - 2);\\n        HashSet<int> r = new HashSet<int>();\\n        for (int i = 0; i <= maxSize; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    int sum = GetSum(grid, i, j, k);\\n                    if (sum != -1) r.Add(sum);\\n                }\\n            }\\n        }\\n        return r.GroupBy(x => x).Select(y => y.First()).ToList().OrderByDescending(j => j).Take(3).ToArray();\\n    }\\n    \\n    public int GetSum(int[][] g, int s, int i, int j) {\\n        if (s == 0) return g[i][j];\\n\\n        int r = g[i][j], m = g.Length, n = g[0].Length;\\n        int li = i, lj = j, ri = i, rj = j, cs = 0;\\n        while (cs < s) {\\n            li++;\\n            lj--;\\n            ri++;\\n            rj++;\\n            if (li >= m || lj < 0 || ri >= m || rj >= n) return -1;\\n            r += g[li][lj] + g[ri][rj];\\n            cs++;\\n        }\\n        \\n        while (cs > 0) {\\n            li++;\\n            lj++;\\n            ri++;\\n            rj--;\\n            if (li >= m || lj < 0 || ri >= m || rj >= n) return -1;\\n            r = lj == rj ? r + g[li][lj] : r + g[li][lj] + g[ri][rj];\\n            cs--;\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241836,
                "title": "java-explained-solution",
                "content": "Please Up-vote if you find the solution helpful!\\n```\\nclass Solution {\\n     public static HashSet<Integer>h1;\\n    public int[] getBiggestThree(int[][] grid) { \\n        PriorityQueue<Integer>q=new PriorityQueue<>((a,b)->(a-b));/*min-heap which contains 3 largest values.peak would be the least which would be pop-ed out if larger element found*/\\n        \\n        HashSet<Integer>h=new HashSet<>();\\n        h1=new HashSet<>();\\n       \\n        //adding 0 area rhombus to min-heap\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                if(!h1.contains(grid[i][j]))\\n                {\\n                    q.add(grid[i][j]);\\n                    balance(q,3);\\n                    h1.add(grid[i][j]);\\n                }\\n                \\n            }\\n        }\\n       \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                isRhombus(i,j,grid,q);\\n            }\\n        }\\n        \\n        /*Result array to be initialzed as number of unique unique values present in the queue & did not want to sort the array @here would not make a differnce as array size (Result) is of size 3 .I have reintialized the queue as max-heap and added the values from HashSet and pop-ed the value from max-heap to result array*/\\n        int i=0;\\n        while(q.size()>0)\\n        {\\n           \\n            h.add(q.poll());\\n            \\n        }\\n        \\n        q=new PriorityQueue<>((a,b)->(b-a));\\n        int ans[]=new int[h.size()];\\n        \\n        for(int key:h)\\n        {\\n            q.add(key);\\n        }\\n        for(i=0;i<h.size();i++)\\n        {\\n            ans[i]=q.poll();\\n        }\\n        return ans;\\n        \\n    }\\n    //function to find all rhombus possible from that point\\n    public void isRhombus(int x, int y, int [][]grid,PriorityQueue<Integer>q)\\n    {\\n        int curr=grid[x][y];\\n        int i=x;\\n        int j=y;\\n        \\n       //restricting to 50 as grid size max would be 50X50\\n        for(int p=1;p<50;p++)\\n        {\\n            int up=i-p;\\n            int down=i+p;\\n            int right=j+p;\\n            int left=j-p;\\n            long sum=0;\\n            int u=i;\\n            int d=i;\\n            int l=j;\\n            int r=j;\\n            boolean b=true;\\n            \\n            while(u>=up&&left<=j)//UpperLeft border part of rhombus\\n            {\\n                if(check(u,left,grid))\\n                {\\n                    sum+=grid[u][left];\\n                        \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    u--;\\n                    left++;\\n                \\n            }\\n            \\n            u=i;\\n            while(u>=up&&right>=j)//UpperRight border part of rhombus\\n            {\\n                if(check(u,right,grid))\\n                {\\n                    sum+=grid[u][right];\\n                          \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    u--;\\n                    right--;\\n                     \\n            }\\n            left=j-p;\\n            right=j+p;\\n              \\n           \\n            while(d<=down&&left<=j)//BottomLeft border part of rhombus\\n            {\\n                if(check(d,left,grid))\\n                {\\n                    sum+=grid[d][left];\\n                       \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    d++;\\n                    left++;\\n                    \\n            }\\n            d=i;\\n              \\n            while(d<=down&&right>=j)//BottomRight border part of rhombus\\n            {\\n                if(check(d,right,grid))\\n                {\\n                    sum+=grid[d][right];\\n               \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    d++;\\n                    right--;\\n            }\\n          \\n            //Re-initializing as for removing the 4-border values of rhombus\\n             up=i-p;\\n             down=i+p;\\n             right=j+p;\\n             left=j-p;\\n           \\n          \\n            if(b)\\n            {\\n                //Removing the 4-border points of rhombus as they are already calculated\\n                    long extra=0;\\n                    extra+=grid[up][j];\\n                    extra+=grid[down][j];\\n                    extra+=grid[i][left];\\n                    extra+=grid[i][right];\\n                \\n                //distinct 3 values (using HashSet)\\n                if(!h1.contains((int)(sum-extra)))\\n                {\\n                    h1.add((int)(sum-extra));\\n                    q.add((int)(sum-extra));\\n                    balance(q,3);\\n                }\\n               \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n    }\\n    }\\n    public void balance(PriorityQueue<Integer>q,int k)\\n    {\\n        if(q.size()>3)\\n        {\\n            q.poll();\\n        }\\n        \\n    }\\n    public boolean check(int x, int y, int [][]grid)\\n    {\\n        if(x>=0&&y>=0&&x<grid.length&&y<grid[0].length)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public static HashSet<Integer>h1;\\n    public int[] getBiggestThree(int[][] grid) { \\n        PriorityQueue<Integer>q=new PriorityQueue<>((a,b)->(a-b));/*min-heap which contains 3 largest values.peak would be the least which would be pop-ed out if larger element found*/\\n        \\n        HashSet<Integer>h=new HashSet<>();\\n        h1=new HashSet<>();\\n       \\n        //adding 0 area rhombus to min-heap\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                if(!h1.contains(grid[i][j]))\\n                {\\n                    q.add(grid[i][j]);\\n                    balance(q,3);\\n                    h1.add(grid[i][j]);\\n                }\\n                \\n            }\\n        }\\n       \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                isRhombus(i,j,grid,q);\\n            }\\n        }\\n        \\n        /*Result array to be initialzed as number of unique unique values present in the queue & did not want to sort the array @here would not make a differnce as array size (Result) is of size 3 .I have reintialized the queue as max-heap and added the values from HashSet and pop-ed the value from max-heap to result array*/\\n        int i=0;\\n        while(q.size()>0)\\n        {\\n           \\n            h.add(q.poll());\\n            \\n        }\\n        \\n        q=new PriorityQueue<>((a,b)->(b-a));\\n        int ans[]=new int[h.size()];\\n        \\n        for(int key:h)\\n        {\\n            q.add(key);\\n        }\\n        for(i=0;i<h.size();i++)\\n        {\\n            ans[i]=q.poll();\\n        }\\n        return ans;\\n        \\n    }\\n    //function to find all rhombus possible from that point\\n    public void isRhombus(int x, int y, int [][]grid,PriorityQueue<Integer>q)\\n    {\\n        int curr=grid[x][y];\\n        int i=x;\\n        int j=y;\\n        \\n       //restricting to 50 as grid size max would be 50X50\\n        for(int p=1;p<50;p++)\\n        {\\n            int up=i-p;\\n            int down=i+p;\\n            int right=j+p;\\n            int left=j-p;\\n            long sum=0;\\n            int u=i;\\n            int d=i;\\n            int l=j;\\n            int r=j;\\n            boolean b=true;\\n            \\n            while(u>=up&&left<=j)//UpperLeft border part of rhombus\\n            {\\n                if(check(u,left,grid))\\n                {\\n                    sum+=grid[u][left];\\n                        \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    u--;\\n                    left++;\\n                \\n            }\\n            \\n            u=i;\\n            while(u>=up&&right>=j)//UpperRight border part of rhombus\\n            {\\n                if(check(u,right,grid))\\n                {\\n                    sum+=grid[u][right];\\n                          \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    u--;\\n                    right--;\\n                     \\n            }\\n            left=j-p;\\n            right=j+p;\\n              \\n           \\n            while(d<=down&&left<=j)//BottomLeft border part of rhombus\\n            {\\n                if(check(d,left,grid))\\n                {\\n                    sum+=grid[d][left];\\n                       \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    d++;\\n                    left++;\\n                    \\n            }\\n            d=i;\\n              \\n            while(d<=down&&right>=j)//BottomRight border part of rhombus\\n            {\\n                if(check(d,right,grid))\\n                {\\n                    sum+=grid[d][right];\\n               \\n                }\\n                else\\n                {\\n                    b=false;\\n                    break;\\n                }\\n                \\n                    d++;\\n                    right--;\\n            }\\n          \\n            //Re-initializing as for removing the 4-border values of rhombus\\n             up=i-p;\\n             down=i+p;\\n             right=j+p;\\n             left=j-p;\\n           \\n          \\n            if(b)\\n            {\\n                //Removing the 4-border points of rhombus as they are already calculated\\n                    long extra=0;\\n                    extra+=grid[up][j];\\n                    extra+=grid[down][j];\\n                    extra+=grid[i][left];\\n                    extra+=grid[i][right];\\n                \\n                //distinct 3 values (using HashSet)\\n                if(!h1.contains((int)(sum-extra)))\\n                {\\n                    h1.add((int)(sum-extra));\\n                    q.add((int)(sum-extra));\\n                    balance(q,3);\\n                }\\n               \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n    }\\n    }\\n    public void balance(PriorityQueue<Integer>q,int k)\\n    {\\n        if(q.size()>3)\\n        {\\n            q.poll();\\n        }\\n        \\n    }\\n    public boolean check(int x, int y, int [][]grid)\\n    {\\n        if(x>=0&&y>=0&&x<grid.length&&y<grid[0].length)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241112,
                "title": "swift-100-100",
                "content": "```\\nclass Solution {\\n    var big1 = Int.min\\n    var big2 = Int.min\\n    var big3 = Int.min\\n    \\n    func getBiggestThree(_ grid: [[Int]]) -> [Int] {\\n        if(grid.count == 1 && grid[0].count == 1) { return [grid[0][0]] }\\n        \\n        for i in 0..<grid.count {\\n            for j in 0..<grid[0].count {\\n                getRhomsAt(grid, i, j)\\n            }\\n        }\\n        \\n        if(big2 == Int.min) { return [big1] }\\n        if(big3 == Int.min) { return [big1, big2] }\\n        return [big1, big2, big3]\\n    }\\n    \\n    func getRhomsAt(_ arr:[[Int]], _ i:Int, _ j:Int) {\\n        checkBig(arr[i][j])\\n        if(j == 0 || j == arr[0].count - 1 || i == 0 || i == arr.count - 1) { return }\\n        \\n        var mini = min(i, arr.count - 1 - i)\\n        var minj = min(j, arr[0].count - 1 - j)\\n        \\n        var maxToEdge = min(mini, minj)\\n        \\n        for size in 1...maxToEdge {\\n            checkBig(getRhom(arr, size, i, j))\\n        }\\n    }\\n    \\n    func getRhom(_ arr: [[Int]], _ size:Int, _ i:Int, _ j:Int) -> Int {\\n        if(i < 0 || i > arr.count - 1 || j < 0 || j > arr[0].count - 1) { return 0 }\\n        var total = arr[i + size][j] + arr[i - size][j] + arr[i][j + size] + arr[i][j - size]\\n        if(size == 1) { return total }\\n        for x in 1...(size - 1) {\\n            total +=   arr[i + size - x][j - x] + arr[i + size - x][j + x] + arr[i - size + x][j - x] + arr[i - size + x][j + x]\\n        }\\n        return total\\n    }\\n    \\n    func checkBig(_ num:Int) {\\n        if(num > big1) { \\n            big3 = big2\\n            big2 = big1\\n            big1 = num \\n        } \\n        else if(num == big1) {}\\n        else if(num > big2) {\\n            big3 = big2\\n            big2 = num \\n        }\\n        else if(num == big2) {}\\n        else if(num > big3) { big3 = num }\\n        else if(num == big3) {}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var big1 = Int.min\\n    var big2 = Int.min\\n    var big3 = Int.min\\n    \\n    func getBiggestThree(_ grid: [[Int]]) -> [Int] {\\n        if(grid.count == 1 && grid[0].count == 1) { return [grid[0][0]] }\\n        \\n        for i in 0..<grid.count {\\n            for j in 0..<grid[0].count {\\n                getRhomsAt(grid, i, j)\\n            }\\n        }\\n        \\n        if(big2 == Int.min) { return [big1] }\\n        if(big3 == Int.min) { return [big1, big2] }\\n        return [big1, big2, big3]\\n    }\\n    \\n    func getRhomsAt(_ arr:[[Int]], _ i:Int, _ j:Int) {\\n        checkBig(arr[i][j])\\n        if(j == 0 || j == arr[0].count - 1 || i == 0 || i == arr.count - 1) { return }\\n        \\n        var mini = min(i, arr.count - 1 - i)\\n        var minj = min(j, arr[0].count - 1 - j)\\n        \\n        var maxToEdge = min(mini, minj)\\n        \\n        for size in 1...maxToEdge {\\n            checkBig(getRhom(arr, size, i, j))\\n        }\\n    }\\n    \\n    func getRhom(_ arr: [[Int]], _ size:Int, _ i:Int, _ j:Int) -> Int {\\n        if(i < 0 || i > arr.count - 1 || j < 0 || j > arr[0].count - 1) { return 0 }\\n        var total = arr[i + size][j] + arr[i - size][j] + arr[i][j + size] + arr[i][j - size]\\n        if(size == 1) { return total }\\n        for x in 1...(size - 1) {\\n            total +=   arr[i + size - x][j - x] + arr[i + size - x][j + x] + arr[i - size + x][j - x] + arr[i - size + x][j + x]\\n        }\\n        return total\\n    }\\n    \\n    func checkBig(_ num:Int) {\\n        if(num > big1) { \\n            big3 = big2\\n            big2 = big1\\n            big1 = num \\n        } \\n        else if(num == big1) {}\\n        else if(num > big2) {\\n            big3 = big2\\n            big2 = num \\n        }\\n        else if(num == big2) {}\\n        else if(num > big3) { big3 = num }\\n        else if(num == big3) {}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240970,
                "title": "can-anyone-check-my-code-it-is-failing-on-test-case",
                "content": "Code - \\nBasic idea is checking the max rohmbas for each element in grid throught size of each rohmbus \\n```\\nclass Solution {\\npublic:\\n    int makeR(int row,int column ,int p,int startR,int startC,vector<vector<int>>& grid,int size){\\n        int i=row,j=column;\\n        if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n            return INT_MIN;\\n        int ans = 0;\\n        int current = 0;\\n        if(p==1){\\n            ans = max(ans,current + makeR(i+1,j+1,p+1,startR,startC,grid,0));\\n            int s = 1;\\n            while(i<grid.size() and j <grid[0].size()){\\n                current+= grid[i][j];\\n                ans = max(ans,current + makeR(i+1,j+1,p+1,startR,startC,grid,s));\\n                s++;\\n                i++;\\n                j++;\\n            }\\n        }else if (p==2){\\n            int s = size;\\n             while(size){\\n                  if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n                    return INT_MIN;\\n                   current+= grid[i][j];\\n                \\n                 size--;\\n                i++;\\n                j--;\\n            }\\n            ans = current+ makeR(i,j,p+1,startR,startC,grid,s);\\n        }else if (p==3){\\n            int s = size;\\n             while(size){\\n                  if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n            return INT_MIN;\\n                   current+= grid[i][j];\\n                \\n                 size--;\\n                i--;\\n                j--;\\n            }\\n            ans = current+ makeR(i,j,p+1,startR,startC,grid,s);\\n        }else if(p==4){\\n            ans = 0;\\n             while(size){\\n                  if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n                    return INT_MIN;\\n                current+= grid[i][j];\\n                 size--;\\n                i--;\\n                j++;\\n            }\\n            ans =  current;\\n        }\\n        return ans;\\n        \\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int,vector<int>,greater<int>> minHeap;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                int ans = makeR(i,j,1,i,j,grid,0);\\n                minHeap.push(max(grid[i][j],ans));\\n                if(minHeap.size()>3)\\n                    minHeap.pop();\\n            }\\n        }\\n        set<int> s;\\n        while(!minHeap.empty()){\\n            s.insert(minHeap.top());\\n            minHeap.pop();\\n        }\\n        \\n        vector<int> vec;\\n        for(auto i : s)\\n            vec.push_back(i);\\n        reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n};\\n```\\nTest Case \\n```\\n[[40039,36788,65171,57696,22419,5751,24037,31913,24167,54995,33013,68399,1905,69152,23190,31495,11811],[71265,17745,33806,89851,60842,92999,92069,56043,45917,89029,2642,1162,23117,11472,83561,78259,31587],[14304,60713,95496,52628,87245,42788,77158,65451,82043,68323,14596,17515,75778,98026,26922,46865,5640],[39534,48861,35631,50154,30182,81322,44562,81502,71815,77662,30064,92979,13437,5636,56218,88011,68789],[78305,90394,1086,86629,57988,11395,96846,38918,23515,73105,89477,15725,40067,4893,13830,78759,51856],[32259,61633,2247,98013,48167,90333,81020,36397,83880,91331,1781,28162,22497,33007,96538,68240,41378],[8597,63005,57839,92469,96292,1162,49932,16595,39865,83382,13598,63955,53287,58376,83631,33150,4382],[89189,46675,9873,65656,86960,94910,70637,32242,50520,7640,57879,40868,80925,29862,36248,63395,88567],[36939,30469,90648,23723,59183,87713,44796,98097,80302,54313,3282,67436,90297,44270,33524,39793,7448],[40081,38016,43333,74807,80072,97651,92137,75496,75362,43612,56029,35744,90702,41418,72608,7592,90217],[39808,18535,75592,49229,37042,36298,80265,81658,49663,93723,43225,4795,60483,22795,63630,65661,43185],[26774,76389,56275,75771,9553,46895,5250,73905,31476,9964,7525,97438,66490,50375,56659,60483,17678],[76011,79935,39956,87785,90749,76739,28319,23075,55703,48029,11331,23418,31218,5282,80484,46023,60024],[3801,25748,40020,54543,37006,82324,80892,62044,80684,23749,65282,69777,64414,12209,22756,41983,64191],[93848,32057,59158,3927,90944,39407,802,85103,44660,34777,56454,63798,94221,84006,60587,71191,78494],[10340,83882,80025,80113,4462,3163,35971,50852,27482,78222,14716,58919,26423,58749,46452,22590,64772],[35235,96053,4914,25769,45882,22760,69986,73413,91222,96651,6732,45521,29977,37410,54380,10193,48135],[76146,16753,16559,26982,27496,89572,78486,13457,69180,42445,81720,46474,62552,37478,548,12589,91821],[42459,99928,3339,92356,57742,54137,58689,55831,78349,22150,2141,95047,4962,11506,35432,96757,16374],[37611,75635,71908,49897,66475,11113,45643,34007,61666,6218,58063,84208,42673,3229,61276,78527,33529],[98591,26281,95294,13618,30451,79901,64917,83082,2260,23007,75397,17711,92963,26301,65927,18723,94662],[50391,74741,75816,63978,46461,64389,40352,59829,8460,78342,70072,50674,79153,64618,56680,83633,99938],[20935,95943,87985,76918,48643,76134,38419,20274,70525,36590,98960,43961,75446,55404,40057,46447,35205],[55671,10519,50529,87827,26100,84788,26178,70087,83044,88120,38645,27950,50624,15747,31738,25584,74705],[32753,53850,6719,18950,64653,70076,74636,87642,88916,87667,53696,70421,13888,57227,78338,26482,82020]]\\n```\\nPlease check and let me know if there are any issue",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeR(int row,int column ,int p,int startR,int startC,vector<vector<int>>& grid,int size){\\n        int i=row,j=column;\\n        if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n            return INT_MIN;\\n        int ans = 0;\\n        int current = 0;\\n        if(p==1){\\n            ans = max(ans,current + makeR(i+1,j+1,p+1,startR,startC,grid,0));\\n            int s = 1;\\n            while(i<grid.size() and j <grid[0].size()){\\n                current+= grid[i][j];\\n                ans = max(ans,current + makeR(i+1,j+1,p+1,startR,startC,grid,s));\\n                s++;\\n                i++;\\n                j++;\\n            }\\n        }else if (p==2){\\n            int s = size;\\n             while(size){\\n                  if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n                    return INT_MIN;\\n                   current+= grid[i][j];\\n                \\n                 size--;\\n                i++;\\n                j--;\\n            }\\n            ans = current+ makeR(i,j,p+1,startR,startC,grid,s);\\n        }else if (p==3){\\n            int s = size;\\n             while(size){\\n                  if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n            return INT_MIN;\\n                   current+= grid[i][j];\\n                \\n                 size--;\\n                i--;\\n                j--;\\n            }\\n            ans = current+ makeR(i,j,p+1,startR,startC,grid,s);\\n        }else if(p==4){\\n            ans = 0;\\n             while(size){\\n                  if(i<0 or i>=grid.size() or j <0 or j>=grid[0].size())\\n                    return INT_MIN;\\n                current+= grid[i][j];\\n                 size--;\\n                i--;\\n                j++;\\n            }\\n            ans =  current;\\n        }\\n        return ans;\\n        \\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int,vector<int>,greater<int>> minHeap;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                int ans = makeR(i,j,1,i,j,grid,0);\\n                minHeap.push(max(grid[i][j],ans));\\n                if(minHeap.size()>3)\\n                    minHeap.pop();\\n            }\\n        }\\n        set<int> s;\\n        while(!minHeap.empty()){\\n            s.insert(minHeap.top());\\n            minHeap.pop();\\n        }\\n        \\n        vector<int> vec;\\n        for(auto i : s)\\n            vec.push_back(i);\\n        reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n};\\n```\n```\\n[[40039,36788,65171,57696,22419,5751,24037,31913,24167,54995,33013,68399,1905,69152,23190,31495,11811],[71265,17745,33806,89851,60842,92999,92069,56043,45917,89029,2642,1162,23117,11472,83561,78259,31587],[14304,60713,95496,52628,87245,42788,77158,65451,82043,68323,14596,17515,75778,98026,26922,46865,5640],[39534,48861,35631,50154,30182,81322,44562,81502,71815,77662,30064,92979,13437,5636,56218,88011,68789],[78305,90394,1086,86629,57988,11395,96846,38918,23515,73105,89477,15725,40067,4893,13830,78759,51856],[32259,61633,2247,98013,48167,90333,81020,36397,83880,91331,1781,28162,22497,33007,96538,68240,41378],[8597,63005,57839,92469,96292,1162,49932,16595,39865,83382,13598,63955,53287,58376,83631,33150,4382],[89189,46675,9873,65656,86960,94910,70637,32242,50520,7640,57879,40868,80925,29862,36248,63395,88567],[36939,30469,90648,23723,59183,87713,44796,98097,80302,54313,3282,67436,90297,44270,33524,39793,7448],[40081,38016,43333,74807,80072,97651,92137,75496,75362,43612,56029,35744,90702,41418,72608,7592,90217],[39808,18535,75592,49229,37042,36298,80265,81658,49663,93723,43225,4795,60483,22795,63630,65661,43185],[26774,76389,56275,75771,9553,46895,5250,73905,31476,9964,7525,97438,66490,50375,56659,60483,17678],[76011,79935,39956,87785,90749,76739,28319,23075,55703,48029,11331,23418,31218,5282,80484,46023,60024],[3801,25748,40020,54543,37006,82324,80892,62044,80684,23749,65282,69777,64414,12209,22756,41983,64191],[93848,32057,59158,3927,90944,39407,802,85103,44660,34777,56454,63798,94221,84006,60587,71191,78494],[10340,83882,80025,80113,4462,3163,35971,50852,27482,78222,14716,58919,26423,58749,46452,22590,64772],[35235,96053,4914,25769,45882,22760,69986,73413,91222,96651,6732,45521,29977,37410,54380,10193,48135],[76146,16753,16559,26982,27496,89572,78486,13457,69180,42445,81720,46474,62552,37478,548,12589,91821],[42459,99928,3339,92356,57742,54137,58689,55831,78349,22150,2141,95047,4962,11506,35432,96757,16374],[37611,75635,71908,49897,66475,11113,45643,34007,61666,6218,58063,84208,42673,3229,61276,78527,33529],[98591,26281,95294,13618,30451,79901,64917,83082,2260,23007,75397,17711,92963,26301,65927,18723,94662],[50391,74741,75816,63978,46461,64389,40352,59829,8460,78342,70072,50674,79153,64618,56680,83633,99938],[20935,95943,87985,76918,48643,76134,38419,20274,70525,36590,98960,43961,75446,55404,40057,46447,35205],[55671,10519,50529,87827,26100,84788,26178,70087,83044,88120,38645,27950,50624,15747,31738,25584,74705],[32753,53850,6719,18950,64653,70076,74636,87642,88916,87667,53696,70421,13888,57227,78338,26482,82020]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240857,
                "title": "python3-100-simple-brute-force",
                "content": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                \\n                res.append(grid[i][j])\\n                \\n                for k in range(1, j+1):\\n                    if i+k*2 < len(grid) and j-k >= 0 and j+k < len(grid[0]):\\n                        \\n                        current = 0\\n                        \\n                        for l in range(1,k+1):\\n                            current += grid[i+l][j+l]\\n                            current += grid[i+l][j-l]\\n                            current += grid[i+l+k][j+k-l]\\n                            current += grid[i+l+k][j-k+l]\\n                            \\n                        current -= grid[i+2*k][j]\\n                        current += grid[i][j]\\n                            \\n                        res.append(current)\\n                        \\n        res = list(set(res))\\n        res.sort(reverse=True)\\n        \\n        return res[:3]\\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                \\n                res.append(grid[i][j])\\n                \\n                for k in range(1, j+1):\\n                    if i+k*2 < len(grid) and j-k >= 0 and j+k < len(grid[0]):\\n                        \\n                        current = 0\\n                        \\n                        for l in range(1,k+1):\\n                            current += grid[i+l][j+l]\\n                            current += grid[i+l][j-l]\\n                            current += grid[i+l+k][j+k-l]\\n                            current += grid[i+l+k][j-k+l]\\n                            \\n                        current -= grid[i+2*k][j]\\n                        current += grid[i][j]\\n                            \\n                        res.append(current)\\n                        \\n        res = list(set(res))\\n        res.sort(reverse=True)\\n        \\n        return res[:3]\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240744,
                "title": "brute-force-creating-rohmus-one-by-one",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int isValid(int i, int j, int k, vector<vector<int>>& grid)\\n    {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        int sum=grid[i][j];\\n        int ti=i,tj=j;\\n        for(int t=1;t<=k;t++)//br= bottom right\\n        {\\n            if(i+t >n-1 || j+t > m-1) return INT_MIN;\\n            sum+=grid[i+t][j+t];\\n        }i+=k; j+=k;\\n        \\n        for(int t=1;t<=k;t++)//bl\\n        {\\n            if(i+t >n-1 || j-t < 0) return INT_MIN;\\n            sum+=grid[i+t][j-t];\\n        }i+=k;j-=k;\\n        \\n        for(int t=1;t<=k;t++)//tl=top left\\n        {\\n            if(i-t<0 || j-t <0) return INT_MIN;\\n            sum+=grid[i-t][j-t];\\n        }i-=k; j-=k;\\n        \\n        for(int t=1;t<k;t++)//tr\\n        {\\n            if(i-t <0 || j+t > m-1) return INT_MIN;\\n            sum+=grid[i-t][j+t];\\n        }i-=k;j+=k;\\n        //if here then a rohmbus was created\\n        return sum;\\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> mah;\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                \\n                for(int k=1;k<=min(grid.size()/2,grid[0].size()/2);k++)\\n                {\\n                    int temp=isValid(i,j,k,grid);\\n                    mah.push(temp);\\n                }\\n                //store ofr 0 area rohmbus later\\n                mah.push(grid[i][j]);\\n            }\\n        }\\n        vector<int> ans;\\n        set<int,greater<int>> ans1;\\n        int x=3;\\n        while(ans1.size()!=3 && !mah.empty())\\n        {\\n            // cout<<mah.top()<<endl;\\n            ans1.insert(mah.top()); mah.pop();\\n        }\\n        for(auto it=ans1.begin();it!=ans1.end();it++)\\n            ans.push_back(*it);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int isValid(int i, int j, int k, vector<vector<int>>& grid)\\n    {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        int sum=grid[i][j];\\n        int ti=i,tj=j;\\n        for(int t=1;t<=k;t++)//br= bottom right\\n        {\\n            if(i+t >n-1 || j+t > m-1) return INT_MIN;\\n            sum+=grid[i+t][j+t];\\n        }i+=k; j+=k;\\n        \\n        for(int t=1;t<=k;t++)//bl\\n        {\\n            if(i+t >n-1 || j-t < 0) return INT_MIN;\\n            sum+=grid[i+t][j-t];\\n        }i+=k;j-=k;\\n        \\n        for(int t=1;t<=k;t++)//tl=top left\\n        {\\n            if(i-t<0 || j-t <0) return INT_MIN;\\n            sum+=grid[i-t][j-t];\\n        }i-=k; j-=k;\\n        \\n        for(int t=1;t<k;t++)//tr\\n        {\\n            if(i-t <0 || j+t > m-1) return INT_MIN;\\n            sum+=grid[i-t][j+t];\\n        }i-=k;j+=k;\\n        //if here then a rohmbus was created\\n        return sum;\\n    }\\n    \\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        priority_queue<int> mah;\\n        int n=grid.size(),m=grid[0].size();\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                \\n                for(int k=1;k<=min(grid.size()/2,grid[0].size()/2);k++)\\n                {\\n                    int temp=isValid(i,j,k,grid);\\n                    mah.push(temp);\\n                }\\n                //store ofr 0 area rohmbus later\\n                mah.push(grid[i][j]);\\n            }\\n        }\\n        vector<int> ans;\\n        set<int,greater<int>> ans1;\\n        int x=3;\\n        while(ans1.size()!=3 && !mah.empty())\\n        {\\n            // cout<<mah.top()<<endl;\\n            ans1.insert(mah.top()); mah.pop();\\n        }\\n        for(auto it=ans1.begin();it!=ans1.end();it++)\\n            ans.push_back(*it);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1240623,
                "title": "c-simple-iteration-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkRhombus(int i, int j, vector<vector<int>> &grid, int k)\\n    {\\n        int cond=grid.size()-2*k;\\n        return ((i<(cond)) && (j>k-1 && j<grid[0].size()-k));\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) \\n    {\\n        vector<int> ans;\\n        // cout<<ans.size()<<endl;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                ans.push_back(grid[i][j]);\\n                int k=1;\\n                while(checkRhombus(i,j,grid,k))\\n                {\\n                    int area=grid[i][j];\\n                    int m=1;\\n                    while(m<=k)\\n                    {\\n                        area+=grid[i+m][j-m]+grid[i+m][j+m];\\n                        m++;\\n                    }\\n                    while(m<2*k)\\n                    {\\n                        area+=grid[i+m][j-(2*k-m)]+grid[i+m][j+(2*k-m)];\\n                        m++;\\n                    }\\n                    area+=grid[i+2*k][j];\\n                    ans.push_back(area);\\n                    k++;\\n                }\\n                \\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        vector<int> result;\\n        int lastArea=-1;\\n        while(!ans.empty() and result.size()!=3)\\n        {\\n            if(lastArea==-1 or lastArea!=ans.back())\\n            {\\n                lastArea=ans.back();\\n                result.push_back(lastArea);\\n            }\\n            ans.pop_back();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkRhombus(int i, int j, vector<vector<int>> &grid, int k)\\n    {\\n        int cond=grid.size()-2*k;\\n        return ((i<(cond)) && (j>k-1 && j<grid[0].size()-k));\\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) \\n    {\\n        vector<int> ans;\\n        // cout<<ans.size()<<endl;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                ans.push_back(grid[i][j]);\\n                int k=1;\\n                while(checkRhombus(i,j,grid,k))\\n                {\\n                    int area=grid[i][j];\\n                    int m=1;\\n                    while(m<=k)\\n                    {\\n                        area+=grid[i+m][j-m]+grid[i+m][j+m];\\n                        m++;\\n                    }\\n                    while(m<2*k)\\n                    {\\n                        area+=grid[i+m][j-(2*k-m)]+grid[i+m][j+(2*k-m)];\\n                        m++;\\n                    }\\n                    area+=grid[i+2*k][j];\\n                    ans.push_back(area);\\n                    k++;\\n                }\\n                \\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        vector<int> result;\\n        int lastArea=-1;\\n        while(!ans.empty() and result.size()!=3)\\n        {\\n            if(lastArea==-1 or lastArea!=ans.back())\\n            {\\n                lastArea=ans.back();\\n                result.push_back(lastArea);\\n            }\\n            ans.pop_back();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1240610,
                "title": "c-92-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>&grid, int row, int col, int side)\\n    {\\n        if(!side)\\n            return grid[row][col];\\n        int sum = 0;\\n        sum += grid[row][col] + grid[row + 2*side][col];\\n        for(int row_i = 1, col_i = 0; row_i < 2*side; row_i++)\\n        {\\n            if(row_i <= side)\\n                col_i = row_i;\\n            else \\n                col_i = 2*side - row_i;\\n            sum += grid[row+row_i][col+col_i] + grid[row+row_i][col-col_i];\\n        }\\n        return sum;   \\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int> rhombus_sum;\\n        set<int> s;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int max_side = min(m,n)/2;\\n        int side = 0;\\n        while(side <= max_side)\\n        {\\n            for(int row = 0; row + 2 *side < m; row++)\\n                for(int col = side; col + side < n; col++)\\n                {\\n                    s.insert(calc(grid, row, col, side));\\n                    if(s.size() > 3) s.erase(s.begin());\\n                }\\n            side++;\\n        }\\n        rhombus_sum.insert(rhombus_sum.begin(), s.rbegin(), s.rend());\\n        return rhombus_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>&grid, int row, int col, int side)\\n    {\\n        if(!side)\\n            return grid[row][col];\\n        int sum = 0;\\n        sum += grid[row][col] + grid[row + 2*side][col];\\n        for(int row_i = 1, col_i = 0; row_i < 2*side; row_i++)\\n        {\\n            if(row_i <= side)\\n                col_i = row_i;\\n            else \\n                col_i = 2*side - row_i;\\n            sum += grid[row+row_i][col+col_i] + grid[row+row_i][col-col_i];\\n        }\\n        return sum;   \\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        vector<int> rhombus_sum;\\n        set<int> s;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int max_side = min(m,n)/2;\\n        int side = 0;\\n        while(side <= max_side)\\n        {\\n            for(int row = 0; row + 2 *side < m; row++)\\n                for(int col = side; col + side < n; col++)\\n                {\\n                    s.insert(calc(grid, row, col, side));\\n                    if(s.size() > 3) s.erase(s.begin());\\n                }\\n            side++;\\n        }\\n        rhombus_sum.insert(rhombus_sum.begin(), s.rbegin(), s.rend());\\n        return rhombus_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240334,
                "title": "easy-intuitive-c-clean-code-with-explanation-and-comments",
                "content": "Below is the easy implementation of clean c++ code just go to every index and start creating rhombus and expand it\\'s boundaries until possible sum the sides in respective cells and push them in set . Return the max 3 .\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    void helper(vector<vector<int>>& grid, int x, int y,set<int>& st){\\n        \\n\\n        st.insert(grid[x][y]);\\n        int k=1;   // will use to set the neigbouring 4 corners of cell then expand the corners\\n        while((x+k)<grid.size() &&(x-k)>=0 && (y+k)<grid[0].size() && (y-k)>=0) {\\n            \\n            int s=0;    // current sum\\n            int l=y-k;   // left of rhombus\\n            int r=y+k;    // right of rhombus\\n        \\n            for(int i=x,j=l;j<=y;i--,j++){      // going from left to top adding left-top side\\n                s+=grid[i][j];\\n               // cout<<s<<endl;\\n            }\\n            for(int j=r,i=x;j>y;i--,j--)     // going from right to top  adding right-top side\\n                s+=grid[i][j];\\n            for(int j=l+1,i=x+1;j<=y;i++,j++)    // going from left to down  adding left-down side\\n                s+=grid[i][j];\\n            for(int j=r-1,i=x+1;j>y;j--,i++)    // going from right to down  adding right-down side\\n                s+=grid[i][j];\\n            st.insert(s);\\n            k++;\\n        }\\n        \\n    }\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int> s;\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n               helper(grid,i,j,s);\\n            }\\n        }\\n        vector<int> ans;\\n       // for(auto itr:s){\\n       //     cout<<itr<<\" \";\\n       // }\\n        for(int i=0;i<3;i++){\\n            int val=*s.rbegin();\\n            ans.push_back(val);\\n            s.erase(*s.rbegin());\\n            if(s.empty())\\n                break;\\n        }\\n      \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    void helper(vector<vector<int>>& grid, int x, int y,set<int>& st){\\n        \\n\\n        st.insert(grid[x][y]);\\n        int k=1;   // will use to set the neigbouring 4 corners of cell then expand the corners\\n        while((x+k)<grid.size() &&(x-k)>=0 && (y+k)<grid[0].size() && (y-k)>=0) {\\n            \\n            int s=0;    // current sum\\n            int l=y-k;   // left of rhombus\\n            int r=y+k;    // right of rhombus\\n        \\n            for(int i=x,j=l;j<=y;i--,j++){      // going from left to top adding left-top side\\n                s+=grid[i][j];\\n               // cout<<s<<endl;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1240219,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int leftv[n][m];\\n      int rightv[n][m];\\n      \\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          leftv[i][j]=grid[i][j];\\n          rightv[i][j]=grid[i][j];\\n          if(i>=1){\\n            leftv[i][j] +=((j-1>=0)?leftv[i-1][j-1]:0);\\n            rightv[i][j]+=((j+1<m)?rightv[i-1][j+1]:0); \\n          }\\n        }\\n      }\\n      \\n    int ans=0;\\n    set<int>s;\\n    for(int i=0;i<n;i++){\\n      for(int j=0;j<m;j++){\\n        s.insert(grid[i][j]);\\n        for(int h=1;h<min(n,m);h++){\\n          pair<int,int>top={i-h,j};\\n          pair<int,int>left={i,j-h};\\n          pair<int,int>right={i,j+h};\\n          pair<int,int>bottom={i+h,j};\\n          if(i-h>=0 &&j-h>=0 && j+h<m && i+h<n){\\n            int ans=0;\\n            //top left\\n            int tx=top.first-1;\\n            int ty=top.second+1;\\n            ans+= rightv[left.first][left.second]-   ((tx>=0 && ty<m)?rightv[tx][ty]:0);\\n            //bottom left\\n            ans+= leftv[bottom.first][bottom.second]-leftv[left.first][left.second];\\n            //top right\\n            ans+= leftv[right.first][right.second]-leftv[top.first][top.second];\\n            //bottom right\\n            int bx=bottom.first-1;\\n            int by=bottom.second+1;\\n            ans+= rightv[bx][by]-rightv[right.first][right.second];\\n            s.insert(ans);\\n            \\n          }\\n          \\n        }\\n      }\\n    }\\n        \\n   vector<int>v{begin(s),end(s)};\\n   if(v.size()<=3){\\n     reverse(begin(v),end(v));\\n      return v;\\n   }\\n   vector<int>res;\\n   int sz=v.size();\\n   for(int i=sz-1;i>=sz-3;i--){\\n     res.push_back(v[i]);\\n   }\\n    \\n      \\n    return res;\\n      \\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int leftv[n][m];\\n      int rightv[n][m];\\n      \\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          leftv[i][j]=grid[i][j];\\n          rightv[i][j]=grid[i][j];\\n          if(i>=1){\\n            leftv[i][j] +=((j-1>=0)?leftv[i-1][j-1]:0);\\n            rightv[i][j]+=((j+1<m)?rightv[i-1][j+1]:0); \\n          }\\n        }\\n      }\\n      \\n    int ans=0;\\n    set<int>s;\\n    for(int i=0;i<n;i++){\\n      for(int j=0;j<m;j++){\\n        s.insert(grid[i][j]);\\n        for(int h=1;h<min(n,m);h++){\\n          pair<int,int>top={i-h,j};\\n          pair<int,int>left={i,j-h};\\n          pair<int,int>right={i,j+h};\\n          pair<int,int>bottom={i+h,j};\\n          if(i-h>=0 &&j-h>=0 && j+h<m && i+h<n){\\n            int ans=0;\\n            //top left\\n            int tx=top.first-1;\\n            int ty=top.second+1;\\n            ans+= rightv[left.first][left.second]-   ((tx>=0 && ty<m)?rightv[tx][ty]:0);\\n            //bottom left\\n            ans+= leftv[bottom.first][bottom.second]-leftv[left.first][left.second];\\n            //top right\\n            ans+= leftv[right.first][right.second]-leftv[top.first][top.second];\\n            //bottom right\\n            int bx=bottom.first-1;\\n            int by=bottom.second+1;\\n            ans+= rightv[bx][by]-rightv[right.first][right.second];\\n            s.insert(ans);\\n            \\n          }\\n          \\n        }\\n      }\\n    }\\n        \\n   vector<int>v{begin(s),end(s)};\\n   if(v.size()<=3){\\n     reverse(begin(v),end(v));\\n      return v;\\n   }\\n   vector<int>res;\\n   int sz=v.size();\\n   for(int i=sz-1;i>=sz-3;i--){\\n     res.push_back(v[i]);\\n   }\\n    \\n      \\n    return res;\\n      \\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240203,
                "title": "c-time-complexity-o-n-3-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n      \\n      vector<vector<int>> l(begin(grid), end(grid)), r(begin(grid), end(grid));\\n      \\n      int n = grid.size(), m = grid[0].size();\\n\\t\\n\\t// precompute the diagonal sum from left to right\\n      for (int i = 1; i < n; ++i)\\n          for (int j = 1; j < m; ++j)\\n              l[i][j] += l[i - 1][j - 1];\\n\\t\\t\\t  \\n\\t// precompute the diagonal sum from right to left\\n      for (int i = 1; i < n; ++i)\\n          for (int j = 0; j < m - 1; ++j)\\n              r[i][j] += r[i - 1][j + 1];\\n\\t\\n\\t// logic for maintaining largest element is copied from votrubac\\'s solution\\n\\t// HERE https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238660/Brute-Force\\n      set<int> s;\\n\\t\\n\\t// main loops\\n      for (int i = 0; i < n; ++i)\\n      {\\n          for (int j = 0; j < m; ++j)\\n          {\\n              for (int k = 0; i + 2 * k < n and j - k >= 0 and j + k < m; ++k)\\n              {\\n                  int temp = 0;\\n                  temp += l[i+k][j+k] - l[i][j]; // edge -> 0\\n                  temp += r[i+k][j-k] - r[i][j]; // edge -> 1\\n                  temp += grid[i][j];                      \\n                  temp += r[i+2*k][j] - r[i+k][j+k];// edge -> 2\\n                  temp += l[i+2*k][j] - l[i+k][j-k]; // edge -> 3\\n\\t\\t\\t\\t  // when k == 0 we don\\'t need to remove this element \\n\\t\\t\\t\\t  // otherwise rhombus with side length 1 will not be calculated\\n                  temp -= grid[i+2*k][j]*bool(k);  \\n                  s.insert(temp);\\n                  if(s.size() > 3)\\n                      s.erase(s.begin());\\n              }\\n          }\\n      }\\n\\n      return vector<int>(rbegin(s), rend(s));\\n    }\\n};\\n```\\n\\n```\\n\\t// logic for the main loops\\n\\t// temp += l[i+k][j+k] - l[i][j]; // edge -> 0\\n\\t// edge -> 0 is (i+t, j+t) where  k belongs to [1,4]  diagonally from left to right\\n\\t\\n\\t// temp += r[i+k][j-k] - r[i][j]; // edge -> 1\\n\\t// edge -> 1 is (i+t, j-t) where  k belongs to [1,4]   diagonally from right to left\\n    \\n\\t//temp += grid[i][j];                      \\n\\t// now as we dont have element grid[i][j] we add it\\n\\t\\n\\t// similarly edge 2 and 3\\n\\t\\n\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t (EDGE 1)    (i,j) (EDGE 0)\\n\\t\\t\\t\\t\\t\\t\\t (EDGE 1)  (i+1,j-1)\\t     (i+1,j+1)  (EDGE 0)            \\n\\t\\t\\t\\t (EDGE 1) (i+2,j-2)                               (i+2,j+2)  (EDGE 0)\\n\\t (EDGE 1)(i+3,j-3)                                                        (i+3,j+3) (EDGE 0)\\n\\t\\t\\t\\t(EDGE 3)  (i+4,j-2)                               (i+4,j+2) (EDGE 2)\\n\\t\\t\\t\\t\\t\\t\\t(EDGE 3)   (i+5,j-1)         (i+5,j+1) (EDGE 2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   (EDGE 3)  (i+6,j) (EDGE 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n      \\n      vector<vector<int>> l(begin(grid), end(grid)), r(begin(grid), end(grid));\\n      \\n      int n = grid.size(), m = grid[0].size();\\n\\t\\n\\t// precompute the diagonal sum from left to right\\n      for (int i = 1; i < n; ++i)\\n          for (int j = 1; j < m; ++j)\\n              l[i][j] += l[i - 1][j - 1];\\n\\t\\t\\t  \\n\\t// precompute the diagonal sum from right to left\\n      for (int i = 1; i < n; ++i)\\n          for (int j = 0; j < m - 1; ++j)\\n              r[i][j] += r[i - 1][j + 1];\\n\\t\\n\\t// logic for maintaining largest element is copied from votrubac\\'s solution\\n\\t// HERE https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/discuss/1238660/Brute-Force\\n      set<int> s;\\n\\t\\n\\t// main loops\\n      for (int i = 0; i < n; ++i)\\n      {\\n          for (int j = 0; j < m; ++j)\\n          {\\n              for (int k = 0; i + 2 * k < n and j - k >= 0 and j + k < m; ++k)\\n              {\\n                  int temp = 0;\\n                  temp += l[i+k][j+k] - l[i][j]; // edge -> 0\\n                  temp += r[i+k][j-k] - r[i][j]; // edge -> 1\\n                  temp += grid[i][j];                      \\n                  temp += r[i+2*k][j] - r[i+k][j+k];// edge -> 2\\n                  temp += l[i+2*k][j] - l[i+k][j-k]; // edge -> 3\\n\\t\\t\\t\\t  // when k == 0 we don\\'t need to remove this element \\n\\t\\t\\t\\t  // otherwise rhombus with side length 1 will not be calculated\\n                  temp -= grid[i+2*k][j]*bool(k);  \\n                  s.insert(temp);\\n                  if(s.size() > 3)\\n                      s.erase(s.begin());\\n              }\\n          }\\n      }\\n\\n      return vector<int>(rbegin(s), rend(s));\\n    }\\n};\\n```\n```\\n\\t// logic for the main loops\\n\\t// temp += l[i+k][j+k] - l[i][j]; // edge -> 0\\n\\t// edge -> 0 is (i+t, j+t) where  k belongs to [1,4]  diagonally from left to right\\n\\t\\n\\t// temp += r[i+k][j-k] - r[i][j]; // edge -> 1\\n\\t// edge -> 1 is (i+t, j-t) where  k belongs to [1,4]   diagonally from right to left\\n    \\n\\t//temp += grid[i][j];                      \\n\\t// now as we dont have element grid[i][j] we add it\\n\\t\\n\\t// similarly edge 2 and 3\\n\\t\\n\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t (EDGE 1)    (i,j) (EDGE 0)\\n\\t\\t\\t\\t\\t\\t\\t (EDGE 1)  (i+1,j-1)\\t     (i+1,j+1)  (EDGE 0)            \\n\\t\\t\\t\\t (EDGE 1) (i+2,j-2)                               (i+2,j+2)  (EDGE 0)\\n\\t (EDGE 1)(i+3,j-3)                                                        (i+3,j+3) (EDGE 0)\\n\\t\\t\\t\\t(EDGE 3)  (i+4,j-2)                               (i+4,j+2) (EDGE 2)\\n\\t\\t\\t\\t\\t\\t\\t(EDGE 3)   (i+5,j-1)         (i+5,j+1) (EDGE 2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   (EDGE 3)  (i+6,j) (EDGE 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240176,
                "title": "explaination-java-upper-and-lower-triangles-with-a-type-of-prefix-sum-and-dp",
                "content": "This is a good problem to learn about arrays. There are 2 ways to solve this problem in O(nm*min(m,n)) complexity.\\n\\n1. Lower and upper cut of rhombus.\\n2. Two diagonals of a matrix\\n\\nBoth solutions come up from the understanding of rhombus shape. I will explain 1st as 2nd is already in many answers.\\n\\nIf you look at a rhombus, it is combination of 2 triangles set upon each other. If we know the sum of boundary of 2 sides upper triangle and that of lower triangle of this rhombus, we can calculate the sum of sides of rhombus.\\n\\nFor a rhombus of length l having top at (i,j) we need the upper triangle at (i,j) of length (l-1). It\\'s bottom will lie at (i+2l, j), so we need lower triangle of length (l-1) at (i+2l, j). We also need the two side points of rhombus which are at (i+l, j-l) and (i+l, j+l).\\nRhombus(i,j,l) = upper(i, j, l-1) + lower(i+2l, j, l-1) + grid(i+l, j-l) + grid(i+l, j+l)\\n\\nNow, we need upper(i,j,l) and lower(i,j,l).\\n\\nFor l=1\\nupper(i,j,1) = grid(i,j) & lower(i,j,1) = grid(i,j)\\n\\nFor l>1\\nupper(i,j,l) = upper(i,j,l-1) + grid(i+l,j-l) + grid(i+l,j+l)\\nlower(i,j,l) = lower(i,j,l-1) + grid(i-l,j-l) + grid(i-l,j+l)\\n\\n```\\nclass Solution {\\n    \\n    int m1, m2, m3;\\n    \\n    void setMax3(int v){\\n        if(v > m1) {m3 = m2; m2 = m1; m1 = v;}\\n        else if(v > m2 && v != m1) {m3 = m2; m2 = v;}\\n        else if(v > m3 && v != m1 && v != m2) {m3 = v;}\\n    }\\n    \\n    public int[] getBiggestThree(int[][] grid) {\\n\\t\\tif(grid.length == 0) return new int[0];\\n        int n = grid.length, m = grid[0].length, x = Math.min(n, m);\\n        int upper1[][] = new int[n][m], upper2[][] = new int[n][m];\\n        int lower1[][] = new int[n][m], lower2[][] = new int[n][m];\\n        m1 = Integer.MIN_VALUE; m2 = Integer.MIN_VALUE; m3 = Integer.MIN_VALUE;\\n        \\n        // length 0\\n        for(int i=0; i<n; i++) \\n        \\tfor(int j=0; j<m; j++) {\\n        \\t\\tsetMax3(grid[i][j]);\\n        \\t}\\n        lower1 = upper1 = grid;\\n        \\n        for(int l=1; l<=x/2+1; l++) {\\n        \\tfor(int i=0; i<n; i++) {\\n            \\tfor(int j=0; j<m; j++) {\\n            \\t\\tif(i>=l && j>=l && j+l<m) \\n            \\t\\t\\tupper2[i][j] = upper1[i][j] + grid[i-l][j-l] + grid[i-l][j+l];\\n                    if(i+l<n && j>=l && j+l<m)\\n            \\t\\t\\tlower2[i][j] = lower1[i][j] + grid[i+l][j-l] + grid[i+l][j+l];\\n            \\t\\tif(i+2*l<n && j>=l && j+l<m) {\\n            \\t\\t\\tsetMax3(lower1[i][j] + grid[i+l][j-l] + grid[i+l][j+l] + upper1[i+2*l][j]);\\n            \\t\\t}\\n                }\\n            }\\n        \\tupper1 = upper2; lower1 = lower2; \\n            upper2 = new int[n][m]; lower2 = new int[n][m];\\n        }\\n        \\n        if((m1 == m2 && m1 == m3) || m2 == Integer.MIN_VALUE) return new int[] {m1};\\n        if(m1 == m2 && m3 != Integer.MIN_VALUE) return new int[] {m1, m3};\\n        if(m1 == m3 || m2 == m3 || m3 == Integer.MIN_VALUE) return new int[] {m1, m2};\\n        return new int[] {m1,m2,m3};\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int m1, m2, m3;\\n    \\n    void setMax3(int v){\\n        if(v > m1) {m3 = m2; m2 = m1; m1 = v;}\\n        else if(v > m2 && v != m1) {m3 = m2; m2 = v;}\\n        else if(v > m3 && v != m1 && v != m2) {m3 = v;}\\n    }\\n    \\n    public int[] getBiggestThree(int[][] grid) {\\n\\t\\tif(grid.length == 0) return new int[0];\\n        int n = grid.length, m = grid[0].length, x = Math.min(n, m);\\n        int upper1[][] = new int[n][m], upper2[][] = new int[n][m];\\n        int lower1[][] = new int[n][m], lower2[][] = new int[n][m];\\n        m1 = Integer.MIN_VALUE; m2 = Integer.MIN_VALUE; m3 = Integer.MIN_VALUE;\\n        \\n        // length 0\\n        for(int i=0; i<n; i++) \\n        \\tfor(int j=0; j<m; j++) {\\n        \\t\\tsetMax3(grid[i][j]);\\n        \\t}\\n        lower1 = upper1 = grid;\\n        \\n        for(int l=1; l<=x/2+1; l++) {\\n        \\tfor(int i=0; i<n; i++) {\\n            \\tfor(int j=0; j<m; j++) {\\n            \\t\\tif(i>=l && j>=l && j+l<m) \\n            \\t\\t\\tupper2[i][j] = upper1[i][j] + grid[i-l][j-l] + grid[i-l][j+l];\\n                    if(i+l<n && j>=l && j+l<m)\\n            \\t\\t\\tlower2[i][j] = lower1[i][j] + grid[i+l][j-l] + grid[i+l][j+l];\\n            \\t\\tif(i+2*l<n && j>=l && j+l<m) {\\n            \\t\\t\\tsetMax3(lower1[i][j] + grid[i+l][j-l] + grid[i+l][j+l] + upper1[i+2*l][j]);\\n            \\t\\t}\\n                }\\n            }\\n        \\tupper1 = upper2; lower1 = lower2; \\n            upper2 = new int[n][m]; lower2 = new int[n][m];\\n        }\\n        \\n        if((m1 == m2 && m1 == m3) || m2 == Integer.MIN_VALUE) return new int[] {m1};\\n        if(m1 == m2 && m3 != Integer.MIN_VALUE) return new int[] {m1, m3};\\n        if(m1 == m3 || m2 == m3 || m3 == Integer.MIN_VALUE) return new int[] {m1, m2};\\n        return new int[] {m1,m2,m3};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240163,
                "title": "c-brute-force-o-m-n-max-m-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //T: O( (mn) * (max(m,n) ^ 2) )\\n    //S: O(1)\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        //Use set for auto sorting and we pick the top3 items in a reversed sequence in the end.\\n        set<int> s;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        //i,j is the position of rhombus\\'s top peak.\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                //delta: the ammount of squares from pos(i,j) (exclusive) to the center square of the rhombus(inclusive).\\n                //(the delta should cover the larger side length) -> max(m,n)\\n                for (int delta = 0; delta <= max(m, n); delta++) {\\n                    int leftMost = j - delta, rightMost = j + delta, bottomMost = i + 2 * delta;\\n                    if (leftMost < 0 || rightMost >= n || bottomMost >= m) {\\n                        break;\\n                    }\\n                    //mapping to Coordinate System \\uFF08m length side should be y,  n length side should be x)\\n                    int px = j, py = i, curSum = 0;\\n                    curSum = grid[py][px];\\n                    while (px + 1 <= rightMost && py + 1 <= bottomMost) curSum += grid[++py][++px];\\n                    while (px - 1 >= leftMost && py + 1 <= bottomMost)   curSum += grid[++py][--px]; \\n                    while (px - 1 >= leftMost && py - 1 >= i)  curSum += grid[--py][--px];\\n                    while (px + 1 < j && py - 1 >= i)  curSum += grid[--py][++px];\\n                    \\n                    s.insert(curSum);\\n                    if (s.size() > 3) {\\n                        s.erase(s.begin());\\n                    }\\n                }\\n            }\\n        }\\n        return vector<int>(s.rbegin(), s.rend());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //T: O( (mn) * (max(m,n) ^ 2) )\\n    //S: O(1)\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        \\n        //Use set for auto sorting and we pick the top3 items in a reversed sequence in the end.\\n        set<int> s;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        //i,j is the position of rhombus\\'s top peak.\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                //delta: the ammount of squares from pos(i,j) (exclusive) to the center square of the rhombus(inclusive).\\n                //(the delta should cover the larger side length) -> max(m,n)\\n                for (int delta = 0; delta <= max(m, n); delta++) {\\n                    int leftMost = j - delta, rightMost = j + delta, bottomMost = i + 2 * delta;\\n                    if (leftMost < 0 || rightMost >= n || bottomMost >= m) {\\n                        break;\\n                    }\\n                    //mapping to Coordinate System \\uFF08m length side should be y,  n length side should be x)\\n                    int px = j, py = i, curSum = 0;\\n                    curSum = grid[py][px];\\n                    while (px + 1 <= rightMost && py + 1 <= bottomMost) curSum += grid[++py][++px];\\n                    while (px - 1 >= leftMost && py + 1 <= bottomMost)   curSum += grid[++py][--px]; \\n                    while (px - 1 >= leftMost && py - 1 >= i)  curSum += grid[--py][--px];\\n                    while (px + 1 < j && py - 1 >= i)  curSum += grid[--py][++px];\\n                    \\n                    s.insert(curSum);\\n                    if (s.size() > 3) {\\n                        s.erase(s.begin());\\n                    }\\n                }\\n            }\\n        }\\n        return vector<int>(s.rbegin(), s.rend());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240161,
                "title": "python-sortedset-solution",
                "content": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        res=SortedSet([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                total=grid[i][j]\\n                res.add(total)\\n                diff=min(i, len(grid)-i-1, j, len(grid[i])-1-j)\\n                for diff2 in range(diff, 0, -1):\\n                    total2=0\\n                    left=[i, j-diff2]\\n                    right=[i, j+diff2]\\n                    up=[i-diff2, j]\\n                    down=[i+diff2, j]\\n                    for k in range(diff2):\\n                        for m,n in [left, right, up, down]:\\n                            total2+=grid[m][n]\\n                        left[0], left[1]=left[0]-1, left[1]+1\\n                        right[0], right[1]=right[0]+1, right[1]-1\\n                        up[0], up[1]=up[0]+1, up[1]+1\\n                        down[0], down[1]=down[0]-1, down[1]-1\\n                    res.add(total2)\\n                if len(res)>3:\\n                    del res[:len(res)-3]\\n        return [i for i in res][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        res=SortedSet([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                total=grid[i][j]\\n                res.add(total)\\n                diff=min(i, len(grid)-i-1, j, len(grid[i])-1-j)\\n                for diff2 in range(diff, 0, -1):\\n                    total2=0\\n                    left=[i, j-diff2]\\n                    right=[i, j+diff2]\\n                    up=[i-diff2, j]\\n                    down=[i+diff2, j]\\n                    for k in range(diff2):\\n                        for m,n in [left, right, up, down]:\\n                            total2+=grid[m][n]\\n                        left[0], left[1]=left[0]-1, left[1]+1\\n                        right[0], right[1]=right[0]+1, right[1]-1\\n                        up[0], up[1]=up[0]+1, up[1]+1\\n                        down[0], down[1]=down[0]-1, down[1]-1\\n                    res.add(total2)\\n                if len(res)>3:\\n                    del res[:len(res)-3]\\n        return [i for i in res][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240156,
                "title": "simple-c-solution-brute-force",
                "content": "```\\nvector<int> getBiggestThree(vector<vector<int>>& grid) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tset<int> res;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int sz = 0; i - sz >= 0 && i + sz < m && j + 2 * sz < n; sz++) {\\n\\t\\t\\t\\tint cur = grid[i][j];\\n\\t\\t\\t\\tint x = i, y = j;\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[--x][++y];\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[++x][++y];\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[++x][--y];\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz - 1; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[--x][--y];\\n\\t\\t\\t\\tres.insert(cur);\\n\\t\\t\\t\\tif (res.size() > 3)\\n\\t\\t\\t\\t\\tres.erase(res.begin());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn vector<int>(res.rbegin(), res.rend());\\n}\\n```\\nPlease upvote if you like the solution.",
                "solutionTags": [],
                "code": "```\\nvector<int> getBiggestThree(vector<vector<int>>& grid) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tset<int> res;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int sz = 0; i - sz >= 0 && i + sz < m && j + 2 * sz < n; sz++) {\\n\\t\\t\\t\\tint cur = grid[i][j];\\n\\t\\t\\t\\tint x = i, y = j;\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[--x][++y];\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[++x][++y];\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[++x][--y];\\n\\t\\t\\t\\tfor (int cnt = 0; cnt < sz - 1; cnt++)\\n\\t\\t\\t\\t\\tcur += grid[--x][--y];\\n\\t\\t\\t\\tres.insert(cur);\\n\\t\\t\\t\\tif (res.size() > 3)\\n\\t\\t\\t\\t\\tres.erase(res.begin());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn vector<int>(res.rbegin(), res.rend());\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564761,
                "content": [
                    {
                        "username": "dastrondev",
                        "content": "Imagine studying for over 2 months after work and covering differnt topics ranging from arrays, binary trees to recusrion, dynamyc programming etc. and then taking a whole day off from your vacation with your current employer and then on the day of interview some a$$h0le who hates his job and miserable in his life gives you this problem. Personally if this ever happens to me and the interviewer is gonna be in the same team I would be joining then I would run the oppisite direction. I don\\'t wanna work with this kind of people.\\n\\nIf i was interviewing someone I would never give such porblems to solve. It would be something that tests their basic ds and algo knowledge and how they process their thoughts to come up with the solution."
                    },
                    {
                        "username": "deleted_user_",
                        "content": "I might misunderstand something, but I see little difference of this one compared to other problems. It\\'s just another one that requires to exploit constraints. I see these from time to time. "
                    },
                    {
                        "username": "Tiga_to",
                        "content": "Guys explayn me how its possible to have rhombus with sum of points more than 80 if max number in the grid is 20?\\n\\nInput:\\n[[20,17,9,13,5,2,9,1,5],[14,9,9,9,16,18,3,4,12],[18,15,10,20,19,20,15,12,11],[19,16,19,18,8,13,15,14,11],[4,19,5,2,19,17,7,2,2]]\\n\\nExpected:\\n[107,103,102]"
                    },
                    {
                        "username": "vishnuganeshan",
                        "content": "you have to calculate the sum of all the boxes on which rhombus\\'s border lies, it can be more than 4 also "
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "why is this question under Medium Category?"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Why not? It\\'s definitely not \"easy\", but neither it\\'s a hard problem. Just another \"exploit the constraints\" kind of question, I\\'ve seen similar in \"medium\" category."
                    },
                    {
                        "username": "gsahu07",
                        "content": "People who ask such questions in the interview are just sadists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hated this question :( Hope I never have to see this again."
                    },
                    {
                        "username": "user9112KI",
                        "content": "#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int, greater<int>> sums;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 1; k <= min(m, n)/2; k++) {\\n                    if (i-k < 0 || i+k >= m || j-k < 0 || j+k >= n) break;\\n                    int sum = 0;\\n                    for (int p = i-k, q = j; p <= i; p++, q++) sum += grid[p][q]; // upper half\\n                    for (int p = i, q = j+k; q > j; p++, q--) sum += grid[p][q]; // right half\\n                    for (int p = i+k, q = j; p > i; p--, q++) sum += grid[p][q]; // bottom half\\n                    for (int p = i, q = j-k; q < j; p--, q++) sum += grid[p][q]; // left half\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (auto sum : sums) {\\n            ans.push_back(sum);\\n            if (ans.size() == 3) break;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1575329,
                "content": [
                    {
                        "username": "dastrondev",
                        "content": "Imagine studying for over 2 months after work and covering differnt topics ranging from arrays, binary trees to recusrion, dynamyc programming etc. and then taking a whole day off from your vacation with your current employer and then on the day of interview some a$$h0le who hates his job and miserable in his life gives you this problem. Personally if this ever happens to me and the interviewer is gonna be in the same team I would be joining then I would run the oppisite direction. I don\\'t wanna work with this kind of people.\\n\\nIf i was interviewing someone I would never give such porblems to solve. It would be something that tests their basic ds and algo knowledge and how they process their thoughts to come up with the solution."
                    },
                    {
                        "username": "deleted_user_",
                        "content": "I might misunderstand something, but I see little difference of this one compared to other problems. It\\'s just another one that requires to exploit constraints. I see these from time to time. "
                    },
                    {
                        "username": "Tiga_to",
                        "content": "Guys explayn me how its possible to have rhombus with sum of points more than 80 if max number in the grid is 20?\\n\\nInput:\\n[[20,17,9,13,5,2,9,1,5],[14,9,9,9,16,18,3,4,12],[18,15,10,20,19,20,15,12,11],[19,16,19,18,8,13,15,14,11],[4,19,5,2,19,17,7,2,2]]\\n\\nExpected:\\n[107,103,102]"
                    },
                    {
                        "username": "vishnuganeshan",
                        "content": "you have to calculate the sum of all the boxes on which rhombus\\'s border lies, it can be more than 4 also "
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "why is this question under Medium Category?"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Why not? It\\'s definitely not \"easy\", but neither it\\'s a hard problem. Just another \"exploit the constraints\" kind of question, I\\'ve seen similar in \"medium\" category."
                    },
                    {
                        "username": "gsahu07",
                        "content": "People who ask such questions in the interview are just sadists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hated this question :( Hope I never have to see this again."
                    },
                    {
                        "username": "user9112KI",
                        "content": "#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int, greater<int>> sums;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 1; k <= min(m, n)/2; k++) {\\n                    if (i-k < 0 || i+k >= m || j-k < 0 || j+k >= n) break;\\n                    int sum = 0;\\n                    for (int p = i-k, q = j; p <= i; p++, q++) sum += grid[p][q]; // upper half\\n                    for (int p = i, q = j+k; q > j; p++, q--) sum += grid[p][q]; // right half\\n                    for (int p = i+k, q = j; p > i; p--, q++) sum += grid[p][q]; // bottom half\\n                    for (int p = i, q = j-k; q < j; p--, q++) sum += grid[p][q]; // left half\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (auto sum : sums) {\\n            ans.push_back(sum);\\n            if (ans.size() == 3) break;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1754644,
                "content": [
                    {
                        "username": "dastrondev",
                        "content": "Imagine studying for over 2 months after work and covering differnt topics ranging from arrays, binary trees to recusrion, dynamyc programming etc. and then taking a whole day off from your vacation with your current employer and then on the day of interview some a$$h0le who hates his job and miserable in his life gives you this problem. Personally if this ever happens to me and the interviewer is gonna be in the same team I would be joining then I would run the oppisite direction. I don\\'t wanna work with this kind of people.\\n\\nIf i was interviewing someone I would never give such porblems to solve. It would be something that tests their basic ds and algo knowledge and how they process their thoughts to come up with the solution."
                    },
                    {
                        "username": "deleted_user_",
                        "content": "I might misunderstand something, but I see little difference of this one compared to other problems. It\\'s just another one that requires to exploit constraints. I see these from time to time. "
                    },
                    {
                        "username": "Tiga_to",
                        "content": "Guys explayn me how its possible to have rhombus with sum of points more than 80 if max number in the grid is 20?\\n\\nInput:\\n[[20,17,9,13,5,2,9,1,5],[14,9,9,9,16,18,3,4,12],[18,15,10,20,19,20,15,12,11],[19,16,19,18,8,13,15,14,11],[4,19,5,2,19,17,7,2,2]]\\n\\nExpected:\\n[107,103,102]"
                    },
                    {
                        "username": "vishnuganeshan",
                        "content": "you have to calculate the sum of all the boxes on which rhombus\\'s border lies, it can be more than 4 also "
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "why is this question under Medium Category?"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Why not? It\\'s definitely not \"easy\", but neither it\\'s a hard problem. Just another \"exploit the constraints\" kind of question, I\\'ve seen similar in \"medium\" category."
                    },
                    {
                        "username": "gsahu07",
                        "content": "People who ask such questions in the interview are just sadists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hated this question :( Hope I never have to see this again."
                    },
                    {
                        "username": "user9112KI",
                        "content": "#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int, greater<int>> sums;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 1; k <= min(m, n)/2; k++) {\\n                    if (i-k < 0 || i+k >= m || j-k < 0 || j+k >= n) break;\\n                    int sum = 0;\\n                    for (int p = i-k, q = j; p <= i; p++, q++) sum += grid[p][q]; // upper half\\n                    for (int p = i, q = j+k; q > j; p++, q--) sum += grid[p][q]; // right half\\n                    for (int p = i+k, q = j; p > i; p--, q++) sum += grid[p][q]; // bottom half\\n                    for (int p = i, q = j-k; q < j; p--, q++) sum += grid[p][q]; // left half\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (auto sum : sums) {\\n            ans.push_back(sum);\\n            if (ans.size() == 3) break;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 2049077,
                "content": [
                    {
                        "username": "dastrondev",
                        "content": "Imagine studying for over 2 months after work and covering differnt topics ranging from arrays, binary trees to recusrion, dynamyc programming etc. and then taking a whole day off from your vacation with your current employer and then on the day of interview some a$$h0le who hates his job and miserable in his life gives you this problem. Personally if this ever happens to me and the interviewer is gonna be in the same team I would be joining then I would run the oppisite direction. I don\\'t wanna work with this kind of people.\\n\\nIf i was interviewing someone I would never give such porblems to solve. It would be something that tests their basic ds and algo knowledge and how they process their thoughts to come up with the solution."
                    },
                    {
                        "username": "deleted_user_",
                        "content": "I might misunderstand something, but I see little difference of this one compared to other problems. It\\'s just another one that requires to exploit constraints. I see these from time to time. "
                    },
                    {
                        "username": "Tiga_to",
                        "content": "Guys explayn me how its possible to have rhombus with sum of points more than 80 if max number in the grid is 20?\\n\\nInput:\\n[[20,17,9,13,5,2,9,1,5],[14,9,9,9,16,18,3,4,12],[18,15,10,20,19,20,15,12,11],[19,16,19,18,8,13,15,14,11],[4,19,5,2,19,17,7,2,2]]\\n\\nExpected:\\n[107,103,102]"
                    },
                    {
                        "username": "vishnuganeshan",
                        "content": "you have to calculate the sum of all the boxes on which rhombus\\'s border lies, it can be more than 4 also "
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "why is this question under Medium Category?"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Why not? It\\'s definitely not \"easy\", but neither it\\'s a hard problem. Just another \"exploit the constraints\" kind of question, I\\'ve seen similar in \"medium\" category."
                    },
                    {
                        "username": "gsahu07",
                        "content": "People who ask such questions in the interview are just sadists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hated this question :( Hope I never have to see this again."
                    },
                    {
                        "username": "user9112KI",
                        "content": "#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int, greater<int>> sums;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 1; k <= min(m, n)/2; k++) {\\n                    if (i-k < 0 || i+k >= m || j-k < 0 || j+k >= n) break;\\n                    int sum = 0;\\n                    for (int p = i-k, q = j; p <= i; p++, q++) sum += grid[p][q]; // upper half\\n                    for (int p = i, q = j+k; q > j; p++, q--) sum += grid[p][q]; // right half\\n                    for (int p = i+k, q = j; p > i; p--, q++) sum += grid[p][q]; // bottom half\\n                    for (int p = i, q = j-k; q < j; p--, q++) sum += grid[p][q]; // left half\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (auto sum : sums) {\\n            ans.push_back(sum);\\n            if (ans.size() == 3) break;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1878389,
                "content": [
                    {
                        "username": "dastrondev",
                        "content": "Imagine studying for over 2 months after work and covering differnt topics ranging from arrays, binary trees to recusrion, dynamyc programming etc. and then taking a whole day off from your vacation with your current employer and then on the day of interview some a$$h0le who hates his job and miserable in his life gives you this problem. Personally if this ever happens to me and the interviewer is gonna be in the same team I would be joining then I would run the oppisite direction. I don\\'t wanna work with this kind of people.\\n\\nIf i was interviewing someone I would never give such porblems to solve. It would be something that tests their basic ds and algo knowledge and how they process their thoughts to come up with the solution."
                    },
                    {
                        "username": "deleted_user_",
                        "content": "I might misunderstand something, but I see little difference of this one compared to other problems. It\\'s just another one that requires to exploit constraints. I see these from time to time. "
                    },
                    {
                        "username": "Tiga_to",
                        "content": "Guys explayn me how its possible to have rhombus with sum of points more than 80 if max number in the grid is 20?\\n\\nInput:\\n[[20,17,9,13,5,2,9,1,5],[14,9,9,9,16,18,3,4,12],[18,15,10,20,19,20,15,12,11],[19,16,19,18,8,13,15,14,11],[4,19,5,2,19,17,7,2,2]]\\n\\nExpected:\\n[107,103,102]"
                    },
                    {
                        "username": "vishnuganeshan",
                        "content": "you have to calculate the sum of all the boxes on which rhombus\\'s border lies, it can be more than 4 also "
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "why is this question under Medium Category?"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Why not? It\\'s definitely not \"easy\", but neither it\\'s a hard problem. Just another \"exploit the constraints\" kind of question, I\\'ve seen similar in \"medium\" category."
                    },
                    {
                        "username": "gsahu07",
                        "content": "People who ask such questions in the interview are just sadists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hated this question :( Hope I never have to see this again."
                    },
                    {
                        "username": "user9112KI",
                        "content": "#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int, greater<int>> sums;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 1; k <= min(m, n)/2; k++) {\\n                    if (i-k < 0 || i+k >= m || j-k < 0 || j+k >= n) break;\\n                    int sum = 0;\\n                    for (int p = i-k, q = j; p <= i; p++, q++) sum += grid[p][q]; // upper half\\n                    for (int p = i, q = j+k; q > j; p++, q--) sum += grid[p][q]; // right half\\n                    for (int p = i+k, q = j; p > i; p--, q++) sum += grid[p][q]; // bottom half\\n                    for (int p = i, q = j-k; q < j; p--, q++) sum += grid[p][q]; // left half\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (auto sum : sums) {\\n            ans.push_back(sum);\\n            if (ans.size() == 3) break;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1837598,
                "content": [
                    {
                        "username": "dastrondev",
                        "content": "Imagine studying for over 2 months after work and covering differnt topics ranging from arrays, binary trees to recusrion, dynamyc programming etc. and then taking a whole day off from your vacation with your current employer and then on the day of interview some a$$h0le who hates his job and miserable in his life gives you this problem. Personally if this ever happens to me and the interviewer is gonna be in the same team I would be joining then I would run the oppisite direction. I don\\'t wanna work with this kind of people.\\n\\nIf i was interviewing someone I would never give such porblems to solve. It would be something that tests their basic ds and algo knowledge and how they process their thoughts to come up with the solution."
                    },
                    {
                        "username": "deleted_user_",
                        "content": "I might misunderstand something, but I see little difference of this one compared to other problems. It\\'s just another one that requires to exploit constraints. I see these from time to time. "
                    },
                    {
                        "username": "Tiga_to",
                        "content": "Guys explayn me how its possible to have rhombus with sum of points more than 80 if max number in the grid is 20?\\n\\nInput:\\n[[20,17,9,13,5,2,9,1,5],[14,9,9,9,16,18,3,4,12],[18,15,10,20,19,20,15,12,11],[19,16,19,18,8,13,15,14,11],[4,19,5,2,19,17,7,2,2]]\\n\\nExpected:\\n[107,103,102]"
                    },
                    {
                        "username": "vishnuganeshan",
                        "content": "you have to calculate the sum of all the boxes on which rhombus\\'s border lies, it can be more than 4 also "
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "why is this question under Medium Category?"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Why not? It\\'s definitely not \"easy\", but neither it\\'s a hard problem. Just another \"exploit the constraints\" kind of question, I\\'ve seen similar in \"medium\" category."
                    },
                    {
                        "username": "gsahu07",
                        "content": "People who ask such questions in the interview are just sadists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hated this question :( Hope I never have to see this again."
                    },
                    {
                        "username": "user9112KI",
                        "content": "#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\\n        set<int, greater<int>> sums;\\n        int m = grid.size(), n = grid[0].size();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sums.insert(grid[i][j]);\\n                for (int k = 1; k <= min(m, n)/2; k++) {\\n                    if (i-k < 0 || i+k >= m || j-k < 0 || j+k >= n) break;\\n                    int sum = 0;\\n                    for (int p = i-k, q = j; p <= i; p++, q++) sum += grid[p][q]; // upper half\\n                    for (int p = i, q = j+k; q > j; p++, q--) sum += grid[p][q]; // right half\\n                    for (int p = i+k, q = j; p > i; p--, q++) sum += grid[p][q]; // bottom half\\n                    for (int p = i, q = j-k; q < j; p--, q++) sum += grid[p][q]; // left half\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (auto sum : sums) {\\n            ans.push_back(sum);\\n            if (ans.size() == 3) break;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            }
        ]
    }
]