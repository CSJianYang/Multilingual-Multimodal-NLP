[
    {
        "title": "Climbing Stairs",
        "question_content": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 45",
        "solutions": [
            {
                "id": 25299,
                "title": "basically-it-s-a-fibonacci",
                "content": "The problem seems to be a *dynamic programming* one. **Hint**: the tag also suggests that! \\nHere are the steps to get the solution incrementally. \\n\\n- Base cases:  \\nif n <= 0, then the number of ways should be zero. \\nif n == 1, then there is only way to climb the stair. \\nif n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. \\n\\n- The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points `[n-1]` and `[n-2]` respectively, denoted as `n1` and `n2` , then the total ways to get to the point `[n]` is `n1 + n2`. Because from the `[n-1]` point, we can take one single step to reach `[n]`. And from the `[n-2]` point, we could take two steps to get there.\\n\\n- The solutions calculated by the above approach are ***complete*** and ***non-redundant***. The two solution sets (`n1`  and `n2`) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step. \\n\\nNow given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. \\n\\nThe implementation in Java as follows: \\n\\n    public int climbStairs(int n) {\\n        // base cases\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int one_step_before = 2;\\n        int two_steps_before = 1;\\n        int all_ways = 0;\\n        \\n        for(int i=2; i<n; i++){\\n        \\tall_ways = one_step_before + two_steps_before;\\n        \\ttwo_steps_before = one_step_before;\\n\\t        one_step_before = all_ways;\\n        }\\n        return all_ways;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The problem seems to be a *dynamic programming* one. **Hint**: the tag also suggests that! \\nHere are the steps to get the solution incrementally. \\n\\n- Base cases:  \\nif n <= 0, then the number of ways should be zero. \\nif n == 1, then there is only way to climb the stair. \\nif n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. \\n\\n- The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points `[n-1]` and `[n-2]` respectively, denoted as `n1` and `n2` , then the total ways to get to the point `[n]` is `n1 + n2`. Because from the `[n-1]` point, we can take one single step to reach `[n]`. And from the `[n-2]` point, we could take two steps to get there.\\n\\n- The solutions calculated by the above approach are ***complete*** and ***non-redundant***. The two solution sets (`n1`  and `n2`) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step. \\n\\nNow given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. \\n\\nThe implementation in Java as follows: \\n\\n    public int climbStairs(int n) {\\n        // base cases\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int one_step_before = 2;\\n        int two_steps_before = 1;\\n        int all_ways = 0;\\n        \\n        for(int i=2; i<n; i++){\\n        \\tall_ways = one_step_before + two_steps_before;\\n        \\ttwo_steps_before = one_step_before;\\n\\t        one_step_before = all_ways;\\n        }\\n        return all_ways;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1531764,
                "title": "python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp",
                "content": "#####\\n### General inutution\\n##### \\t-> Intution : the next distinict way of climbing stairs is euqal to the sum of the last two distinict way of climbing\\n##### \\t\\tdistinct(n) = distinict(n-1) + distinict(n-2)\\n##### This intution can be applied using the following three approach --> ordered from easy to difficult approach\\n#####\\n##### \\n##### \\n#### Idea 1 : pure recursive (Can\\'t pass the test case :does not work for big number, result time-exced limit)\\n##### \\t- The base case will be when only 1 or 2 steps left\\n##### \\t- Result time-exced limit\\n##### \\n        \\n\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n    \\n```\\n#####     \\n#####         \\'\\'\\'\\n####         Idea 2 : use dictionary (look-up table) to memorize repeating recursion\\n#####             - The memory start with the base case and recored every recurssion\\n#####         \\'\\'\\'\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\\n    \\n#####         \\'\\'\\'\\n###         Idea 3 : Dynamic programming \\n#####             --> store the distinct ways in a dynamic table\\n#####             climb = [climb(0), climb(1), climb(2)=climb(0)+climb(1), climb(3)=climb(2)+climb(1),......climb(n)=climb(n-1)+climb(n-2)]\\n#####             dp = [   0,           1,            2,                               3,                      5,                           dp(i-1)+dp(i-2])]\\n#####             return dp[n]\\n#####         \\'\\'\\'\\n\\tdef climb(n):\\n        #edge cases\\n        if n==0: return 0\\n        if n==1: return 1\\n        if n==2: return 2\\n        dp = [0]*(n+1) # considering zero steps we need n+1 places\\n        dp[1]= 1\\n        dp[2] = 2\\n        for i in range(3,n+1):\\n            dp[i] = dp[i-1] +dp[i-2]\\n        print(dp)\\n        return dp[n]\\n\\t\\t\\t\\n### ******  upvote as a sign of appriatation *****",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n    \\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708750,
                "title": "4-method-s-beat-s-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nTo calculate the number of ways to climb the stairs, we can observe that when we are on the nth stair, \\nwe have two options: \\n1. either we climbed one stair from the (n-1)th stair or \\n2. we climbed two stairs from the (n-2)th stair. \\n\\nBy leveraging this observation, we can break down the problem into smaller subproblems and apply the concept of the Fibonacci series. \\nThe base cases are when we are on the 1st stair (only one way to reach it) and the 2nd stair (two ways to reach it). \\nBy summing up the number of ways to reach the (n-1)th and (n-2)th stairs, we can compute the total number of ways to climb the stairs. This allows us to solve the problem efficiently using various dynamic programming techniques such as recursion, memoization, tabulation, or space optimization.\\n\\n# Approach 1: Recursion ```\\u274C TLE \\u274C```\\n**Explanation**: The recursive solution uses the concept of Fibonacci numbers to solve the problem. It calculates the number of ways to climb the stairs by recursively calling the `climbStairs` function for (n-1) and (n-2) steps. However, this solution has exponential time complexity (O(2^n)) due to redundant calculations.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\\n\\n# Approach 2: Memoization\\n**Explanation**: The memoization solution improves the recursive solution by introducing memoization, which avoids redundant calculations. We use an unordered map (`memo`) to store the already computed results for each step `n`. Before making a recursive call, we check if the result for the given `n` exists in the memo. If it does, we return the stored value; otherwise, we compute the result recursively and store it in the memo for future reference.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n, unordered_map<int, int>& memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (memo.find(n) == memo.end()) {\\n            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n        }\\n        return memo[n];\\n    }\\n\\n    int climbStairs(int n) {\\n        unordered_map<int, int> memo;\\n        return climbStairs(n, memo);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return climbStairs(n, memo);\\n    }\\n    \\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (!memo.containsKey(n)) {\\n            memo.put(n, climbStairs(n-1, memo) + climbStairs(n-2, memo));\\n        }\\n        return memo.get(n);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        memo = {}\\n        return self.helper(n, memo)\\n    \\n    def helper(self, n: int, memo: dict[int, int]) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        if n not in memo:\\n            memo[n] = self.helper(n-1, memo) + self.helper(n-2, memo)\\n        return memo[n]\\n```\\n\\n# Approach 3: Tabulation\\n**Explanation**: The tabulation solution eliminates recursion and uses a bottom-up approach to solve the problem iteratively. It creates a DP table (`dp`) of size n+1 to store the number of ways to reach each step. The base cases (0 and 1 steps) are initialized to 1 since there is only one way to reach them. Then, it iterates from 2 to n, filling in the DP table by summing up the values for the previous two steps. Finally, it returns the value in the last cell of the DP table, which represents the total number of ways to reach the top.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n\\n        dp = [0] * (n+1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[n]\\n```\\n\\n# Approach 4: Space Optimization\\n**Explanation**: The space-optimized solution further reduces the space complexity by using only two variables (`prev` and `curr`) instead of an entire DP table. It initializes `prev` and `curr` to 1 since there is only one way to reach the base cases (0 and 1 steps). Then, in each iteration, it updates `prev` and `curr` by shifting their values. `curr` becomes the sum of the previous two values, and `prev` stores the previous value of `curr`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        prev, curr = 1, 1\\n        for i in range(2, n+1):\\n            temp = curr\\n            curr = prev + curr\\n            prev = temp\\n        return curr\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/f7f5193b-c407-4cc3-93ac-969a8ab8aacf_1688305654.6101635.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\u274C TLE \\u274C```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n, unordered_map<int, int>& memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (memo.find(n) == memo.end()) {\\n            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n        }\\n        return memo[n];\\n    }\\n\\n    int climbStairs(int n) {\\n        unordered_map<int, int> memo;\\n        return climbStairs(n, memo);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return climbStairs(n, memo);\\n    }\\n    \\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (!memo.containsKey(n)) {\\n            memo.put(n, climbStairs(n-1, memo) + climbStairs(n-2, memo));\\n        }\\n        return memo.get(n);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        memo = {}\\n        return self.helper(n, memo)\\n    \\n    def helper(self, n: int, memo: dict[int, int]) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        if n not in memo:\\n            memo[n] = self.helper(n-1, memo) + self.helper(n-2, memo)\\n        return memo[n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n\\n        dp = [0] * (n+1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        prev, curr = 1, 1\\n        for i in range(2, n+1):\\n            temp = curr\\n            curr = prev + curr\\n            prev = temp\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25296,
                "title": "3-4-short-lines-in-every-language",
                "content": "Same simple algorithm written in every offered language. Variable `a` tells you the number of ways to reach the current step, and `b` tells you the number of ways to reach the next step. So for the situation one step further up, the old `b` becomes the new `a`, and the new `b` is the old `a+b`, since that new step can be reached by climbing 1 step from what `b` represented or 2 steps from what `a` represented.\\n\\nRuby wins, and *\"the C languages\"* all look the same.\\n\\n**Ruby** (60 ms)\\n\\n    def climb_stairs(n)\\n        a = b = 1\\n        n.times { a, b = b, a+b }\\n        a\\n    end\\n\\n**C++** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Java** (208 ms)\\n\\n    public int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Python** (52 ms)\\n\\n    def climbStairs(self, n):\\n        a = b = 1\\n        for _ in range(n):\\n            a, b = b, a + b\\n        return a\\n\\n**C** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**C#** (48 ms)\\n\\n    public int ClimbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Javascript** (116 ms)\\n\\n    var climbStairs = function(n) {\\n        a = b = 1\\n        while (n--)\\n            a = (b += a) - a\\n        return a\\n    };",
                "solutionTags": [],
                "code": "Same simple algorithm written in every offered language. Variable `a` tells you the number of ways to reach the current step, and `b` tells you the number of ways to reach the next step. So for the situation one step further up, the old `b` becomes the new `a`, and the new `b` is the old `a+b`, since that new step can be reached by climbing 1 step from what `b` represented or 2 steps from what `a` represented.\\n\\nRuby wins, and *\"the C languages\"* all look the same.\\n\\n**Ruby** (60 ms)\\n\\n    def climb_stairs(n)\\n        a = b = 1\\n        n.times { a, b = b, a+b }\\n        a\\n    end\\n\\n**C++** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Java** (208 ms)\\n\\n    public int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Python** (52 ms)\\n\\n    def climbStairs(self, n):\\n        a = b = 1\\n        for _ in range(n):\\n            a, b = b, a + b\\n        return a\\n\\n**C** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**C#** (48 ms)\\n\\n    public int ClimbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Javascript** (116 ms)\\n\\n    var climbStairs = function(n) {\\n        a = b = 1\\n        while (n--)\\n            a = (b += a) - a\\n        return a\\n    };",
                "codeTag": "Python3"
            },
            {
                "id": 3213547,
                "title": "c-python-beats-100-using-dp-2-ways-recursion-memorization-tabulation-space-opt",
                "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963994,
                "title": "java-from-recursion-to-dp",
                "content": "**Recustion (Top Down Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Recustion + Memorization (Top Down Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\\n\\n**DP (Bottom Up Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**DP + Optimization (Bottom Up Approach)**\\n\\nTo calculate the new value we only leverage the previous two values. So we don\\'t need to use an array to store all the previous values.\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25313,
                "title": "python-different-solutions-bottom-up-top-down",
                "content": "    \\n    # Top down - TLE\\n    def climbStairs1(self, n):\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        return self.climbStairs(n-1)+self.climbStairs(n-2)\\n     \\n    # Bottom up, O(n) space\\n    def climbStairs2(self, n):\\n        if n == 1:\\n            return 1\\n        res = [0 for i in xrange(n)]\\n        res[0], res[1] = 1, 2\\n        for i in xrange(2, n):\\n            res[i] = res[i-1] + res[i-2]\\n        return res[-1]\\n    \\n    # Bottom up, constant space\\n    def climbStairs3(self, n):\\n        if n == 1:\\n            return 1\\n        a, b = 1, 2\\n        for i in xrange(2, n):\\n            tmp = b\\n            b = a+b\\n            a = tmp\\n        return b\\n        \\n    # Top down + memorization (list)\\n    def climbStairs4(self, n):\\n        if n == 1:\\n            return 1\\n        dic = [-1 for i in xrange(n)]\\n        dic[0], dic[1] = 1, 2\\n        return self.helper(n-1, dic)\\n        \\n    def helper(self, n, dic):\\n        if dic[n] < 0:\\n            dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n        return dic[n]\\n        \\n    # Top down + memorization (dictionary)  \\n    def __init__(self):\\n        self.dic = {1:1, 2:2}\\n        \\n    def climbStairs(self, n):\\n        if n not in self.dic:\\n            self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n        return self.dic[n]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n    # Top down - TLE\\n    def climbStairs1(self, n):\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        return self.climbStairs(n-1)+self.climbStairs(n-2)\\n     \\n    # Bottom up, O(n) space\\n    def climbStairs2(self, n):\\n        if n == 1:\\n            return 1\\n        res = [0 for i in xrange(n)]\\n        res[0], res[1] = 1, 2\\n        for i in xrange(2, n):\\n            res[i] = res[i-1] + res[i-2]\\n        return res[-1]\\n    \\n    # Bottom up, constant space\\n    def climbStairs3(self, n):\\n        if n == 1:\\n            return 1\\n        a, b = 1, 2\\n        for i in xrange(2, n):\\n            tmp = b\\n            b = a+b\\n            a = tmp\\n        return b\\n        \\n    # Top down + memorization (list)\\n    def climbStairs4(self, n):\\n        if n == 1:\\n            return 1\\n        dic = [-1 for i in xrange(n)]\\n        dic[0], dic[1] = 1, 2\\n        return self.helper(n-1, dic)\\n        \\n    def helper(self, n, dic):\\n        if dic[n] < 0:\\n            dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n        return dic[n]\\n        \\n    # Top down + memorization (dictionary)  \\n    def __init__(self):\\n        self.dic = {1:1, 2:2}\\n        \\n    def climbStairs(self, n):\\n        if n not in self.dic:\\n            self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n        return self.dic[n]",
                "codeTag": "Python3"
            },
            {
                "id": 1792723,
                "title": "python-in-depth-walkthrough-explanation-dp-top-down-bottom-up",
                "content": "## Intuition and Approach\\nWe can climb $$n$$ stairs by going up 1 or 2 steps at a time. So if we\\'re currently on step $$i$$, the only places we could get to in one iteration would be steps $$i + 1$$ (if we take 1 step) and $$i + 2$$ (if we take 2 steps).\\n\\nThis means that if we are currently on step $$n$$, our final destination, we could have only gotten there in one of two ways:\\n1. From step $$n - 1$$ , having gone up 1 step to $$n$$\\n2. From step $$n - 2$$, having gone up 2 steps to $$n$$\\n\\nThis highlights that the number of ways to reach step $$n$$ depends on the number of ways to get to step $$n - 1$$ **and** the number of ways to get to step $$n - 2$$. Since both of the above possibilities are valid choices, the number of ways to get to $$n$$ is going to be their **sum**. Thus, we have the following relationship (formally called a **recurrence relation**): $$ways(n) = ways(n - 1) + ways(n - 2)$$\\n\\nLooking at the problem constraints, we see that the smallest possible value of $$n$$ is 1. If we are asked to climb 1 step, the above relationship will not work because $$ways(0)$$ and $$ways(-1)$$ are not defined. More formally, we haven\\'t defined our recurrence\\'s **base case(s)**. We calculate this base case manually: there\\'s only 1 way to climb a singular step - just climb that step! We couldn\\'t possibly take 2 steps in this situation, because then we\\'d be climbing more steps than there are to climb. We notice that if $$n = 2$$, the relationship will also not hold because $$ways(0)$$ is still undefined. Calculating this base case is slightly more involved, but still easy: we can either climb the 2 steps by taking 2 steps, or climb 1 step twice, for a total of 2 ways to climb.\\n\\nTo recap, we have the following relationship, depending on the value of $$n$$:\\n- $$ways(1) = 1 \\\\text{ for } n = 1$$\\n- $$ways(2) = 2 \\\\text{ for } n = 2$$\\n- $$ways(n) = ways(n - 1) + ways(n - 2) \\\\text{ for } n > 2$$\\n\\n\\n---\\n\\n\\n## **Implementation**\\nWe\\'ll explore multiple approaches from simple to more complex, incrementally improving upon each solution. \\n\\n##### **1. Naive recursion**\\nWe can translate the recurrence we came up with earlier into code, as follows:\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\n\\nHowever, running this yields Time Limit Exceeded. Why is it so inefficient? Let\\'s think about calculating the ways to climb 6 stairs,  `climbStairs(6)`.\\n```\\n                                       climbStairs(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tcS(5)       +          cS(4)\\n\\t\\t\\t\\t\\t           /    \\\\                  /    \\\\\\n\\t\\t\\t               cS(4)   +   cS(3)         cS(3) + cS(2)\\n\\t\\t\\t\\t\\t\\t   /  \\\\        /   \\\\         /   \\\\\\n\\t\\t\\t\\t      cS(3) + cS(2) cS(2) + cS(1) cS(2) + cS(1)\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t     cS(2) + cS(1)\\n\\t\\t\\t\\n\\t\\n```\\n\\nAs you can see from the recursion tree above, we are calculating `climbStairs(4)` and `climbStairs(3)` multiple times. Specifically, `climbStairs(4)` is being recalculated twice, while `climbStairs(3)` is being recalculated 3 times. If you think about what happens for larger values of `n`, you can see that we are recalculating a lot of values! \\n\\n**Complexity**\\n* **Time**: Each additional level in the recursion tree is going to have double the amount of calls to `climbingStairs` than the one above it. For $$n$$, this gives us a staggering $$2^n$$ function calls, for a $$O(2^n)$$ time complexity. No wonder we get TLE!\\n* **Space**: We aren\\'t storing any additional variables, so that\\'s a $$O(1)$$ space complexity.\\n\\n\\nCan we avoid repeated computation?\\n\\n##### **2. Memoization (Top-Down DP)** \\nWhat if instead of recomputing each value of `climbStairs`, we made sure to save the unique values (such as `climbingStairs(5)`), trading space for time? That\\'s what a top-down dynamic programming approach called **memoization** is. We make use of a dictionary `memo` in which we store the values of `climbStairs` that we have computed, and if we ever have to compute that value again we just check `memo` in (average) $$O(1)$$ time instead of doing the work all over again. \\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def climb(n):  # inner function to make code simpler\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = climb(n-1) + climb(n-2)\\n                return memo[n]\\n        memo = {1: 1, 2: 2}  # base cases\\n        return climb(n)\\n```\\n\\nWe can also make use of Python\\'s handy `@cache` function decorator that does this for us in the background like so:\\n\\n```\\nclass Solution:\\n\\t@cache\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\n\\nThis top-down paradigm works well when we approach the problem from the top of the stairs (the last step we needed to climb, $$n$$) down. \\n\\n**Complexity**\\n* **Time**: There are $$O(n)$$ distinct subproblems to solve, each requiring only $$O(1)$$ amount of work of getting the values of smaller subproblems from `memo` and adding them together. When we encounter a subproblem we\\'ve already solved, we can get the answer in $$O(1)$$ time.\\n* **Space**: We are using an additional `memo` dictionary that will store the answer to each subproblem, so $$O(n)$$ space complexity.\\n\\nCan we be even more efficient and avoid the overhead of recursion?\\n\\n\\n**3. Bottom-Up DP**\\nTurns out we can build the solution from the ground up (quite literally in this case). From our recurrence relation, we saw that the number of ways to climb $$n$$ stairs depends on the number of ways to climb $$n - 1$$ and $$n - 2$$ stairs. So instead of approaching the problem top-down and computing these values recursively, we compute them bottom-up, starting with the base cases and building upon the previous values until we reach $$n$$. We use a `dp` array of length $$n + 1$$ (to accomodate for the 0-based indexing of Python; we could just have it be length $$n$$ and return `dp[n - 1]` but in this way we are aligning the step numbers with the indices) and successively build up each index from the previous two.\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        dp = [-1] * (n + 1)  # to accomodate for 0-based indexing \\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n            \\n```\\n\\n**Complexity**\\n* **Time**: As before, we are computing each subproblem once and each subproblem requires constant amount of work (just the addition of the previous 2 elements of the array). That\\'s $$O(n)$$time complexity.\\n* **Space**: Since we are storing the answers to previous subproblems in the `dp` array, this will be $$O(n)$$ too.\\n\\nCan we do even better?\\n\\n**4. Optimizied Bottom-Up DP**\\nWhile the above works well enough, we can optimize our approach even further by making a simple but important observation: we are only utilizing the last 2 subproblem answers when solving each subproblem. If you look at the recurrence again, you can see that the only pieces information we use are $$ways(n - 1)$$ and $$ways(n - 2)$$. Since we\\'re computing from bottom-up, once we compute those answers, the smaller subproblems (such as $$ways(n - 3)$$) are not needed anymore. Thus, instead of keeping the entire `dp` array, we can save some space and just maintain 2 variables that track our last 2 subproblem answers!\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        ways = 0\\n\\t\\t# base cases\\n        two_below_curr = 1  # 2 steps below 3 - ways to take 1 step: 1\\n        one_below_curr = 2  # 1 step below 3 - ways to take 2 steps: 2\\n        for i in range(3, n + 1):\\n            # compute number of ways for i\\n            ways = one_below_curr + two_below_curr\\n            # step up to i + 1   \\n            # 1 step below becomes 2 steps below\\n            # current number of ways becomes 1 step below\\n            two_below_curr, one_below_curr = one_below_curr, ways\\n    \\n        return ways\\n```\\n\\n**Complexity**\\n* **Time**: As before, we are computing each subproblem once and each subproblem requires constant amount of work (just the addition of the previous 2 number of ways). That\\'s $$O(n)$$ time complexity.\\n* **Space**: $$O(1)$$ since we are maintaining 3 extra variables only!\\n\\nAnd that\\'s it! We went from a TLE solution to an elegant and optimized version.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\n                                       climbStairs(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tcS(5)       +          cS(4)\\n\\t\\t\\t\\t\\t           /    \\\\                  /    \\\\\\n\\t\\t\\t               cS(4)   +   cS(3)         cS(3) + cS(2)\\n\\t\\t\\t\\t\\t\\t   /  \\\\        /   \\\\         /   \\\\\\n\\t\\t\\t\\t      cS(3) + cS(2) cS(2) + cS(1) cS(2) + cS(1)\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t     cS(2) + cS(1)\\n\\t\\t\\t\\n\\t\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def climb(n):  # inner function to make code simpler\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = climb(n-1) + climb(n-2)\\n                return memo[n]\\n        memo = {1: 1, 2: 2}  # base cases\\n        return climb(n)\\n```\n```\\nclass Solution:\\n\\t@cache\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        dp = [-1] * (n + 1)  # to accomodate for 0-based indexing \\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n            \\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        ways = 0\\n\\t\\t# base cases\\n        two_below_curr = 1  # 2 steps below 3 - ways to take 1 step: 1\\n        one_below_curr = 2  # 1 step below 3 - ways to take 2 steps: 2\\n        for i in range(3, n + 1):\\n            # compute number of ways for i\\n            ways = one_below_curr + two_below_curr\\n            # step up to i + 1   \\n            # 1 step below becomes 2 steps below\\n            # current number of ways becomes 1 step below\\n            two_below_curr, one_below_curr = one_below_curr, ways\\n    \\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205775,
                "title": "0ms-java-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/b84f646e-53f9-4218-a2dc-fb26bcf4746b_1676808521.7800605.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137892,
                "title": "dp-easy-js-sol-approachable-code",
                "content": "# Intuition\\n\\n-     Dynamic Programming by implementing the Fibonacci Sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The approach of the below code is to solve the problem of counting the number of ways to climb stairs using **`Dynamic Programming by implementing the Fibonacci Sequence`**.\\n2. The function calculates the nth number in the fibonacci sequence using a for loop, where n is the number of stairs. \\n3. The first two numbers in the sequence are initialized as 1 and the next numbers are calculated as the sum of the previous two numbers.\\n4. The result, the nth number, is returned as the answer to the number of ways to climb stairs.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the number of stairs.\\n2. Because as it uses a for loop to calculate the fibonacci sequence, it has $$O(n)$$ time complexity.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because as it only uses a constant amount of extra memory to store a few variables.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/af110665-c61e-46b7-9325-161eacdd66f3_1675453763.6499822.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25345,
                "title": "easy-solutions-for-suggestions",
                "content": "Hi guys, I come up with this arithmetic way. Find the inner logic relations and get the answer.\\n\\n\\n    public class Solution {\\n    \\n    public int climbStairs(int n) {\\n        if(n == 0 || n == 1 || n == 2){return n;}\\n        int[] mem = new int[n];\\n        mem[0] = 1;\\n        mem[1] = 2;\\n        for(int i = 2; i < n; i++){\\n            mem[i] = mem[i-1] + mem[i-2];\\n        }\\n        return mem[n-1];\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int climbStairs(int n) {\\n        if(n == 0 || n == 1 || n == 2){return n;}",
                "codeTag": "Java"
            },
            {
                "id": 3306307,
                "title": "dynamic-programming-python3",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp=[-1]*(n+2)\\n        def solve(i):\\n            if i==0 or i==1:\\n                return 1\\n            if dp[i]!=-1:\\n                return dp[i]\\n            left=solve(i-1)\\n            right=solve(i-2)\\n            dp[i]=left+right\\n            return left+right\\n        return solve(n)\\n```\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one+two\\n            one=two\\n            two=temp\\n        return two\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp=[-1]*(n+2)\\n        def solve(i):\\n            if i==0 or i==1:\\n                return 1\\n            if dp[i]!=-1:\\n                return dp[i]\\n            left=solve(i-1)\\n            right=solve(i-2)\\n            dp[i]=left+right\\n            return left+right\\n        return solve(n)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one+two\\n            one=two\\n            two=temp\\n        return two\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147963,
                "title": "4-solutions-recursion-memoization-dp-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFibonacci series\\n\\n# Approach\\n\\n\\n\\n- Using the top-down approach of recursion,try to reach stair 0 standing from n.\\n- There are two possible ways at each stair =>take 1 step or 2 steps at a time.\\n- This problem is similar to fibonacci problem.Because the recurrence relation of both these problem is exactly the same.\\n- The base case is:\\n1. When standing at stair 1 or 0 there is only 1 possible way to come to 0.\\n\\n\\n```\\nif(n==0 or n==1) {\\n    return 1\\n}\\nreturn f(n-1)+f(n-2)\\n```\\n\\n# 1.Recursion:(TLE)\\n- For the above recurrence relation, the recusive solution is:\\n```\\nclass Solution {\\npublic:\\n    int findWays(int n){\\n        if(n<=1) return 1; //base case\\n        return findWays(n-1)+findWays(n-2);\\n    }\\n\\n    int climbStairs(int n) {\\n        return findWays(n);\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(2^n)= Exponential time complexity\\n- Space complexity:O(n)=if recursion depth is considered,else:O(1) \\n\\n\\n# 2.Memoization: (Accepted)\\n- In above recusrion, the same subproblems are solved again and again.\\n- This is recomputaion and to avoid it store the results of subproblems which are already solved in dp array.\\n- So when a problem needs to be solved, if it is already solved then directly return the anwswer stored in dp array instead of again computing it.\\n```\\nclass Solution {\\npublic:\\n    int findWays(int n, vector<int> &dp)\\n    {\\n        if (n <= 1) return 1;\\n        if (dp[n] != -1) return dp[n];//already solved subproblems\\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1); //fill all values with -1\\n        return findWays(n,dp);\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(n)= Linear time complexity\\n- Space complexity:O(n)+O(N)= extra space of size n(dp) and recursion depth n \\n\\n\\n# 3.Dynamic Programming: (Accepted)\\n- The above approach requires recursive stack space.\\n- To optimize that space, use bottom-up approach of TABULATION.\\n- Start from base case and based on previous results gradually build the result.\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n         vector<int>dp(n+1,-1);\\n         dp[0]=1,dp[1]=1; //base cases\\n         for(int i=2;i<=n;++i){\\n             dp[i]=dp[i-1]+dp[i-2];\\n         }\\n        return dp[n];\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(n)= Linear time complexity\\n- Space complexity:O(n) = Extra space of size n and no recusrion stack space used. \\n\\n\\n# 4. Space Optimzation of DP (OPTIMAL SOLUTION)\\n- If we carefully observe above tabulation, we only need previous two values to fill current index rather than whole dp array.\\n- So we just maintain only those two values in 2 variables and update them accordingly for subsequent iterations.\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int prev2=1,prev1=1; //initally at 0th and 1st index\\n        \\n        for(int i=2;i<=n;i++){\\n            int curr=prev1+prev2;\\n            prev2=prev1; //update pointers\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n};\\n\\n```\\n---\\n\\n- *Please Leave a like if you found the solution or explanation helpful.*\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif(n==0 or n==1) {\\n    return 1\\n}\\nreturn f(n-1)+f(n-2)\\n```\n```\\nclass Solution {\\npublic:\\n    int findWays(int n){\\n        if(n<=1) return 1; //base case\\n        return findWays(n-1)+findWays(n-2);\\n    }\\n\\n    int climbStairs(int n) {\\n        return findWays(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findWays(int n, vector<int> &dp)\\n    {\\n        if (n <= 1) return 1;\\n        if (dp[n] != -1) return dp[n];//already solved subproblems\\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1); //fill all values with -1\\n        return findWays(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n         vector<int>dp(n+1,-1);\\n         dp[0]=1,dp[1]=1; //base cases\\n         for(int i=2;i<=n;++i){\\n             dp[i]=dp[i-1]+dp[i-2];\\n         }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int prev2=1,prev1=1; //initally at 0th and 1st index\\n        \\n        for(int i=2;i<=n;i++){\\n            int curr=prev1+prev2;\\n            prev2=prev1; //update pointers\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25652,
                "title": "5-lines-of-python",
                "content": "It's essentially Fibonacci number:\\n     \\n    def climbStairs(self, n):\\n        a, b = 1, 1\\n        for i in range(n):\\n            a, b = b, a + b\\n        return a",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's essentially Fibonacci number:\\n     \\n    def climbStairs(self, n):\\n        a, b = 1, 1\\n        for i in range(n):\\n            a, b = b, a + b\\n        return a",
                "codeTag": "Python3"
            },
            {
                "id": 1504255,
                "title": "c-simple-and-easy-fibonacci-solution-with-explanation",
                "content": "**Idea - this is just simple fibonacci!**\\nThe base cases are: \\n* n = 0 -> 0\\n* n = 1 -> 1\\n* n = 2 -> 2\\n\\nThen, for each step `i`, the number of ways to get to it is: either the last step was of 1 step, so we have `prev`, or it was a 2 step, and that\\'s `prev2`, so all together the number of ways to get to our current step is `prev + prev2`.\\nIf we check the first few, we can see clearly that it comes out a fibonacci sequence.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25315,
                "title": "my-dp-solution-in-c-with-explanation",
                "content": "     int climbStairs(int n) \\n    {\\n         vector<int> steps(n,0);\\n         steps[0]=1;\\n         steps[1]=2;\\n         for(int i=2;i<n;i++)\\n         {\\n             steps[i]=steps[i-2]+steps[i-1];\\n         }\\n         return steps[n-1];\\n     }\\n\\nArray 'steps' stands for how many distinct ways to climb to each level (index from 0,  so 0 means level 1, 1 means level 2 and so on.... ).   It's trivial to know it has 1 distinct way to climb to stair 1 , and 2 distinct ways to climb to stair 2 .   For stair level n (n>=3) ,   you can either (1) climb to stair n-2 , and climb 2 more steps to reach n  ,  OR (2) climb to stair n-1, and climb 1 more step to reach n.   That said ,  steps[n]=steps[n-1]+steps[n-2].     In another word,  the number of distinct ways to reach level n is the sum of  number of distinct ways to reach level n-1 and n-2.",
                "solutionTags": [],
                "code": "     int climbStairs(int n) \\n    {\\n         vector<int> steps(n,0);\\n         steps[0]=1;\\n         steps[1]=2;\\n         for(int i=2;i<n;i++)\\n         {\\n             steps[i]=steps[i-2]+steps[i-1];\\n         }\\n         return steps[n-1];\\n     }\\n\\nArray 'steps' stands for how many distinct ways to climb to each level (index from 0,  so 0 means level 1, 1 means level 2 and so on.... ).   It's trivial to know it has 1 distinct way to climb to stair 1 , and 2 distinct ways to climb to stair 2 .   For stair level n (n>=3) ,   you can either (1) climb to stair n-2 , and climb 2 more steps to reach n  ,  OR (2) climb to stair n-1, and climb 1 more step to reach n.   That said ,  steps[n]=steps[n-1]+steps[n-2].     In another word,  the number of distinct ways to reach level n is the sum of  number of distinct ways to reach level n-1 and n-2.",
                "codeTag": "Unknown"
            },
            {
                "id": 3091065,
                "title": "java-no-recursion-100-faster",
                "content": "Initially, i wrote this code :\\n```\\npublic int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-2)+climbStairs(n-1);\\n    }\\n```\\nBut, It yields error as **Time limit Exceeded**. Because this is tree recursion and it is too expensive for this problem. \\nInstead of it, I wrote this code that is very cheapier than the first.\\n\\n```\\nplease upvote, if you found it useful\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-2)+climbStairs(n-1);\\n    }\\n```\n```\\nplease upvote, if you found it useful\\n```\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428533,
                "title": "3-lines-code-faster-than-100-beginner-friendly-detailed-explanation-of-approach",
                "content": "first make a dp array of size (1 more than the maximum value of n)\\nif the value at nth index of dp array is not equal to 0 then simply return it.\\nif the value of n=1 then we can clearlt say that the number of ways are 1 and if n=2 then we can clearly sat that the number of ways of climbing stairs is 2(1+1 , 2)\\nthen make a recursive step of dp\\nthe ways of climbing n staits equal to the sum of climbing (n-1) and (n-2) stairs.\\nthen return dp[n].\\n\\nint dp[46];\\n    int climbStairs(int n) {\\n      \\n      if(dp[n]!=0) return dp[n];\\n      \\n      if(n==1 || n==2) return n;\\n      dp[n]=climbStairs(n-1)+climbStairs(n-2);\\n      return dp[n];\\n      \\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.and comment if you dont able to understand it\\n\\t\\n\\t//Happy Coding Guys",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "first make a dp array of size (1 more than the maximum value of n)\\nif the value at nth index of dp array is not equal to 0 then simply return it.\\nif the value of n=1 then we can clearlt say that the number of ways are 1 and if n=2 then we can clearly sat that the number of ways of climbing stairs is 2(1+1 , 2)\\nthen make a recursive step of dp\\nthe ways of climbing n staits equal to the sum of climbing (n-1) and (n-2) stairs.\\nthen return dp[n].\\n\\nint dp[46];\\n    int climbStairs(int n) {\\n      \\n      if(dp[n]!=0) return dp[n];\\n      \\n      if(n==1 || n==2) return n;\\n      dp[n]=climbStairs(n-1)+climbStairs(n-2);\\n      return dp[n];\\n      \\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.and comment if you dont able to understand it\\n\\t\\n\\t//Happy Coding Guys",
                "codeTag": "Unknown"
            },
            {
                "id": 241466,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Approach**\\n\\nBase cases:\\nif `n == 0`, then the number of ways should be `zero`.\\nif `n == 1`, then there is only `one` way to climb the stair.\\nif `n == 2`, then there are `two` ways to climb the stairs. One solution is `one` step by another; the other one is `two` steps at one time.\\n\\n- We can reach `i`th step in one of the two ways:\\n1. Taking a single step from `(i - 1)`th step\\n2. Taking a step of two from `(i - 2)`th step.\\n- So, the total number of ways to reach `i`th step is equal to sum of ways of reaching `(i - 1)`th step and ways of reaching `(i - 2)`th step.\\n\\nTime complexity: `O(2^n)` - since size of recursion tree will be `2^n`\\nSpace Complexity: `O(n)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else\\n            return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Solution 2: Dynamic Programming**\\n\\n- This similar to `Solution1`, but here we cache the intermediate results in an array for the performance improvement.\\n- Let `dp[i]` denotes the number of ways to reach on `i`th step, then\\n`dp[i] = dp[i - 1] + dp[i - 2]`\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n\\n**Top-Down Approach**\\n```\\nclass Solution\\n{\\n    int[] cache = new int[46];\\n    \\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else if(cache[n] != 0)\\n            return cache[n];\\n        else\\n            return cache[n] = climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Bottom-Up Approach**\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Solution 3: Fibonacci Number**\\n\\n- In the above approach of `Solution2`, we have used an array where `dp[i] = dp[i - 1] + dp[i - 2]`. It can be easily analyzed that `dp[i]` is nothing but `i`th Fibonacci number.\\n`Fib(n) = Fib(n - 1) + Fib(n - 2)`\\n- So now we just have to find `n`th number of the Fibonacci series having `1` and `2` as their first and second term respectively, \\ni.e. `Fib(1) = 1` and `Fib(2) = 2`.\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int a = 1;\\n        int b = 2;\\n\\n\\t\\tfor(int i = 3; i <= n; i++)\\n\\t\\t{\\n            int sum = a + b;\\n            a = b;\\n            b = sum;\\n        }\\n        return b;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else\\n            return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    int[] cache = new int[46];\\n    \\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else if(cache[n] != 0)\\n            return cache[n];\\n        else\\n            return cache[n] = climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int a = 1;\\n        int b = 2;\\n\\n\\t\\tfor(int i = 3; i <= n; i++)\\n\\t\\t{\\n            int sum = a + b;\\n            a = b;\\n            b = sum;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861147,
                "title": "clean-python-fibonacci-growth",
                "content": "**Clean Python | Fibonacci Growth**\\n\\nPython solution similar to the Approach N\\xBA 4 (Fibonacci Growth) discussed in the official LeetCode solution:\\n\\nWe basically consider all steps from 1 to n: ```x=[1,2,3,4,...]```. Here we note that we can only reach step number ```x[i]``` by advancing one step from ```x[i-1]``` or two steps from ```x[i-2]```. Based on this insight, we can say with confidence that the total number of alternatives to reach step number ```x[i]``` is ```N[i] = N[i-1]+N[i-2]``` (sum of alternatives at previous steps). This gives us a Fibonacci growth sequence.\\n\\nThe steps ```[i-1]``` and ```[i-2]``` receive the names ```a``` and ```b``` in the code. If we advance in the array ```[...,b,a]```, we can say that new element in the array will be ```c = a+b```. Therefore, we get ```[..., ,b,a,a+b]```. If we iterate in the loop, we note that our variables are updated as ```b,a = a,a+b```, or reversing the order: ```a,b = a+b,a``` (this is what appears in the code).\\n\\nWe return the value of ```a``` at the end of the function, because this is our last step taken. Now regarding the initialization ```a,b=1,0```, this can be a bit tricky. One way to sense of this would be to think that initially we are at ```n=0``` (before taking one step), but ```n=-1``` is nonsense, so we have one alternative at ```n=0``` and zero alternatives at ```n=-1```. If you follow the first elements in the sequence ```[0,1,...]```, you will see that the upcoming sequence ```[1,2,3,...]``` is formed perfectly with this initialization :)\\n\\nTo be honest, I first thought about this initialization as a small hack to get the code running without if-clauses, because I knew the first element would be ```c = a+b = 1+0 = 1``` for ```n=1```, and then having the initial elements ```[1,1]```, the rest of the code would work perfectly lol.\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        a,b = 1,0\\n        for _ in range(n):\\n            a,b = a+b,a\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```x=[1,2,3,4,...]```\n```x[i]```\n```x[i-1]```\n```x[i-2]```\n```x[i]```\n```N[i] = N[i-1]+N[i-2]```\n```[i-1]```\n```[i-2]```\n```a```\n```b```\n```[...,b,a]```\n```c = a+b```\n```[..., ,b,a,a+b]```\n```b,a = a,a+b```\n```a,b = a+b,a```\n```a```\n```a,b=1,0```\n```n=0```\n```n=-1```\n```n=0```\n```n=-1```\n```[0,1,...]```\n```[1,2,3,...]```\n```c = a+b = 1+0 = 1```\n```n=1```\n```[1,1]```\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        a,b = 1,0\\n        for _ in range(n):\\n            a,b = a+b,a\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838261,
                "title": "dynamic-programming-soln-in-c",
                "content": "**Recursive Approach(TLE)**\\n```\\nint climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n```\\n\\n**Top Down Approach**\\n```\\nint t[46]={0};\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1) {t[n]=1; return 1;}\\n        if(n==2) {t[n]=2; return 2;}\\n        else if(t[n]!=0) return t[n];\\n        t[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return t[n];\\n    }\\n};\\n```\\n\\n**Bottom up Approach**\\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        for(int i=0;i<=n;i++) t[i]=0;\\n        t[1]=1;\\n        if(n>=2) t[2]=2;\\n        for(int i=3;i<=n;i++){\\n             t[i] = t[i-1]+t[i-2];    \\n        }\\n        return t[n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n```\n```\\nint t[46]={0};\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1) {t[n]=1; return 1;}\\n        if(n==2) {t[n]=2; return 2;}\\n        else if(t[n]!=0) return t[n];\\n        t[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return t[n];\\n    }\\n};\\n```\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        for(int i=0;i<=n;i++) t[i]=0;\\n        t[1]=1;\\n        if(n>=2) t[2]=2;\\n        for(int i=3;i<=n;i++){\\n             t[i] = t[i-1]+t[i-2];    \\n        }\\n        return t[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044200,
                "title": "c-solution-three-approaches-with-explanation-easy-to-understand",
                "content": "**Approach 1 : (Recursion)**\\n\\n**Recursion** is a programming technique using function or algorithm which calls itself directly or indirectly until a suitable condition is met. In this method, we repeatedly call the function within the same function, and it has a base case and a recursive condition.\\n\\n**It gives us Time Limit Exceeded (TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<0) return 0;\\n        if(n==0 || n==1) return 1;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\\n\\n**Approach 2 : (DP - Memoization / Top Down)**\\n\\n**Memoization** is a technique for improving the performance of recursive algorithms. It involves rewriting the recursive algorithm so that as answers to problems are found, they are stored in an array. Recursive calls can look up results in the array rather than having to recalculate them.\\n\\nWe start our journey from the top most destination state and compute its answer by taking in count the values of states that can reach the destination state, till we reach the bottom-most base state. Hence, it is also called as **Top-Down Approach**\\n\\n**Runtime: 0 ms\\nMemory Usage: 6.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &dp,int n){\\n        if(n<0) return 0;\\n        if(n==0 || n==1)    return 1;\\n        if(dp[n]!=-1)   return dp[n];\\n        return dp[n]=helper(dp,n-1)+helper(dp,n-2);\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(dp,n);\\n    }\\n};\\n```\\n\\n**Approach 3 :(DP - Bottom Up / Tabulation)**\\n\\n**Tabulation** is a bottom-up method for solving DP problems.\\nIt goes one level up and combines the solutions it previously obtained to construct the optimal solutions to more complex problems. Eventually, tabulation combines the solutions of the original problem\\'s subproblems and finds its optimal solution.\\n\\n**Runtime: 3 ms\\nMemory Usage: 6.3 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++)   \\n            dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**If you liked the solution and understood the approaches well , then please upvote, it motivates me to write more solutions that can help others to understand the concepts well \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<0) return 0;\\n        if(n==0 || n==1) return 1;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &dp,int n){\\n        if(n<0) return 0;\\n        if(n==0 || n==1)    return 1;\\n        if(dp[n]!=-1)   return dp[n];\\n        return dp[n]=helper(dp,n-1)+helper(dp,n-2);\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(dp,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++)   \\n            dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914779,
                "title": "dp-recursion-w-memo-two-js-solutions",
                "content": "```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612132,
                "title": "easy-solution-in-c-all-approaches-discussed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount manually and find dependencies of solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we observe the pattern by counting manually. For n<=2, the answer is n itself. For n>2, the solution is obtained by adding the solutions to previous two subproblems. So we obtain the recurrenece relation **F(n)=F(n-1)+F(n-2) for n>2.** The naive approach would be to apply recursion. That is, no doubt absolutely correct but not a very fast solution. Applying recursion would give TLE.\\n\\nThe second approach would be to apply recursion and adding memoization, i.e., storing the solution of smaller problems so that we don\\'t have to calculate them again and again while solving the bigger problem. But that also will give TLE.\\n\\nThe third approach is tabulation method. That is basically iterating manually for values 0 to n. The base cases are known to us(n=0,1,2) and we can simply iterate for values over 2 and store them in the vector named dp. This is the fastest solution and gives the correct answer.\\n\\nHowever, the third approach is still not the best one. We store all the values in an additional vector, using space. We know that our solution depends upon the previous two solutions. So instead of storing all the solutions in a vector, we keep the track of the solutions using three variables - prev1, prev2 and prev3. Initially prev1 = 0(n=0 case), prev2=1(n=1 case) and prev3=2(n=2 case). We take another variable curr and run a loop from i=3 to n, updating each variable acccoringly. This is the best solution, as alongwith being the fastest, it does not take up any extra space as well.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRecursive Solution - O(2^n)\\nRecursion + Memoization Solution - O(n)\\nTabulation Solution - O(n)\\nTabulation + Space Optimization Solution - O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRecursive Solution - O(n), due to recursive stack\\nRecursion + Memoization Solution - O(n)+O(n)=O(n), due to recursive stack and dp array\\nTabulation Solution - O(n), due to dp array\\nTabulation + Space Optimization Solution - O(1), as no extra space is being used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //RECURSIVE\\n    int solve(int n) {\\n        if(n<=2) return n;\\n\\n        return solve(n-1)+solve(n-2);\\n    }\\n\\n    //RECURSION+MEMOIZATION - TOP DOWN\\n    int solveTD(int n, vector<int> &dp) {\\n        if(n<=2) return n;\\n        if(dp[n]!=-1) return dp[n];\\n        dp[n]=solve(n-1)+solve(n-2);\\n\\n        return dp[n];\\n    }\\n\\n    //BOTTOM UP APPROACH\\n    int solveBU(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        if(n==0) return dp[0];\\n        dp[1]=1;\\n        if(n==1) return dp[1];\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];\\n\\n        return dp[n];\\n    }\\n\\n    int solveBUSpace(int n) {\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 2;\\n        int curr;\\n\\n        if(n==0) return prev1;\\n        if(n==1) return prev2;\\n        if(n==2) return prev3;\\n\\n        for(int i=3;i<=n;i++) {\\n            curr=prev2+prev3;\\n            prev1=prev2;\\n            prev2=prev3;\\n            prev3=curr;\\n        }\\n        return curr;\\n    }\\n\\n    int climbStairs(int n) {\\n        \\n        //RECURSIVE CALL\\n        // return solve(n);\\n\\n        //TOP DOWN CALL\\n        // vector<int> dp(n+1,-1);\\n        // return solveTD(n,dp);\\n\\n        //BOTTOM UP CALL\\n        // return solveBU(n);\\n\\n        //BOTTOM UP WITH SPACE OPTIMIZATION\\n        return solveBUSpace(n);\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/6bf23c95-e4dd-4836-9464-c2c640159868_1686204613.032207.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //RECURSIVE\\n    int solve(int n) {\\n        if(n<=2) return n;\\n\\n        return solve(n-1)+solve(n-2);\\n    }\\n\\n    //RECURSION+MEMOIZATION - TOP DOWN\\n    int solveTD(int n, vector<int> &dp) {\\n        if(n<=2) return n;\\n        if(dp[n]!=-1) return dp[n];\\n        dp[n]=solve(n-1)+solve(n-2);\\n\\n        return dp[n];\\n    }\\n\\n    //BOTTOM UP APPROACH\\n    int solveBU(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        if(n==0) return dp[0];\\n        dp[1]=1;\\n        if(n==1) return dp[1];\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];\\n\\n        return dp[n];\\n    }\\n\\n    int solveBUSpace(int n) {\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 2;\\n        int curr;\\n\\n        if(n==0) return prev1;\\n        if(n==1) return prev2;\\n        if(n==2) return prev3;\\n\\n        for(int i=3;i<=n;i++) {\\n            curr=prev2+prev3;\\n            prev1=prev2;\\n            prev2=prev3;\\n            prev3=curr;\\n        }\\n        return curr;\\n    }\\n\\n    int climbStairs(int n) {\\n        \\n        //RECURSIVE CALL\\n        // return solve(n);\\n\\n        //TOP DOWN CALL\\n        // vector<int> dp(n+1,-1);\\n        // return solveTD(n,dp);\\n\\n        //BOTTOM UP CALL\\n        // return solveBU(n);\\n\\n        //BOTTOM UP WITH SPACE OPTIMIZATION\\n        return solveBUSpace(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25436,
                "title": "using-the-fibonacci-formular-to-get-the-answer-directly",
                "content": "    \\nThis is Fibonacci number, and the world has already worked out an formula that\\n\\n![enter image description here][1]\\n\\nand where \\n\\n![enter image description here][2]\\n\\nor you can check the wiki [Fibonacci Number][3]\\n\\nand noticed the Fibonacci begins with F(0)=0, F(1)=1, F(2)=1, F(3)=2\\n\\nbut this problem begins with F'(1)=1, F'(2)=2\\n\\nSo we need a (n++) at the beginning to match the Fibonacci formula\\n\\n    int climbStairs(int n) {\\n        n++;\\n        double root5 = pow(5, 0.5);\\n        double result = 1/root5*( pow((1+root5)/2, n) - pow((1-root5)/2, n) );\\n        return (int)(result);\\n    }\\n\\n\\n  [1]: https://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png\\n  [2]: https://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png\\n  [3]: https://en.wikipedia.org/wiki/Fibonacci_number",
                "solutionTags": [],
                "code": "    \\nThis is Fibonacci number, and the world has already worked out an formula that\\n\\n![enter image description here][1]\\n\\nand where \\n\\n![enter image description here][2]\\n\\nor you can check the wiki [Fibonacci Number][3]\\n\\nand noticed the Fibonacci begins with F(0)=0, F(1)=1, F(2)=1, F(3)=2\\n\\nbut this problem begins with F'(1)=1, F'(2)=2\\n\\nSo we need a (n++) at the beginning to match the Fibonacci formula\\n\\n    int climbStairs(int n) {\\n        n++;\\n        double root5 = pow(5, 0.5);\\n        double result = 1/root5*( pow((1+root5)/2, n) - pow((1-root5)/2, n) );\\n        return (int)(result);\\n    }\\n\\n\\n  [1]: https://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png\\n  [2]: https://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png\\n  [3]: https://en.wikipedia.org/wiki/Fibonacci_number",
                "codeTag": "Unknown"
            },
            {
                "id": 2760912,
                "title": "plain-and-simple-explaination-100-fast-and-beginner-friendly-please-vote-if-understood",
                "content": "\\n![Screenshot (936).png](https://assets.leetcode.com/users/images/855c97e9-296a-48a8-b3d9-79304a71d5c4_1667155951.7405477.png)\\n\\n\\n# Approach\\nif there is x ways of climbing n-2 stairs and y ways of climbing n-1 stairs, we can say that there are x+y ways of climbing n stairs. we can take 1 step from (n-1)th stair or 2 steps from (n-2)th stair to get to the nth stair.\\n\\nSo ans(n) = ans(n-1)+ans(n-2) i.e. Fibonacci situation.\\n\\nNow we have to calculate for n>=3 only so n=1 and n=2 are already solved cases.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) { //FIBONACCI\\n        if(n<=2)\\n            return n;\\n        int one =1;\\n        int two =2;\\n        for(int i = 3;i<=n;i++){\\n            int temp = one;\\n            one = two;\\n            two+=temp;\\n        }\\n        return two;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) { //FIBONACCI\\n        if(n<=2)\\n            return n;\\n        int one =1;\\n        int two =2;\\n        for(int i = 3;i<=n;i++){\\n            int temp = one;\\n            one = two;\\n            two+=temp;\\n        }\\n        return two;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691420,
                "title": "100-faster-solution-without-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[46];  // because Constraints are: 1 <= n <= 45\\n        arr[0] = 1; // oth stairs should be 1\\n        arr[1] = 1; // 1th stair should be 1\\n        arr[2] = 2; // 2nd stair should be 2\\n        for(int i=3; i<=n; i++){\\n            arr[i] = arr[i-1] + arr[i-2];\\n        }\\n        return arr[n]; // finally returning the answer\\n    }\\n};\\n```\\n\\nIf you like it then pls don\\'t forget to give it a reputation!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[46];  // because Constraints are: 1 <= n <= 45\\n        arr[0] = 1; // oth stairs should be 1\\n        arr[1] = 1; // 1th stair should be 1\\n        arr[2] = 2; // 2nd stair should be 2\\n        for(int i=3; i<=n; i++){\\n            arr[i] = arr[i-1] + arr[i-2];\\n        }\\n        return arr[n]; // finally returning the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725940,
                "title": "js-fibonacci-without-recursion-with-explanation-4-solutions",
                "content": "Solving this problem does not require an understanding of Fibonacci numbers. The Fibonacci numbers are the numbers in the next integer sequence.\\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ........\\n\\n**Fn = Fn-1 + Fn-2**\\n\\nRecursion is often used to solve the problem, but it is not very efficient with large fibonacci numbers, and the complexity of such a program can be very disappointing.\\nTherefore, we will **use dynamic programming.**\\n\\n**Recursive solution example:**\\n```\\n    function fib(n) {\\n    if (n <= 1)\\n        return n;\\n    return fib(n-1) + fib(n-2);\\n}\\n```\\n\\n**Dynamic programming** is basically an optimization of regular recursion. Wherever we see a recursive solution, we can optimize it with dynamic programming. The idea is to simply store the results of the subtasks so that we don\\'t have to recalculate them later when needed. This simple optimization reduces the time complexity from exponential to polynomial.\\n\\nSo, instead of recursing, we\\'ll create variables with the first Fibonacci numbers (1, 1), **not including 0**, and with a simple iteration, we\\'ll update them until we get what we want. \\n\\nWe also add a check, if the values are less than 4, return n, since the Fibonacci number 1 is \\'1\\', 2 is \\'2\\', 3 is \\'3\\', and only starting from 4, we will get a distinctive value.\\n\\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let a = 1, b = 1, fib;\\n    for(let i = 2; i <= n; i++) {\\n        fib = a + b;\\n        a = b;\\n        b = fib;\\n    }\\n    return fib;\\n};\\n```\\n**Time complexity: O(n)\\nExtra space: O(1)**\\n\\nThis solution looks more understandable, but takes up more space than the first one.\\n\\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let fib = [1, 1];\\n    for (let i = 2; i <= n; i++) {\\n        fib[i] = fib[i - 1] + fib[i - 2];\\n    }\\n    return fib[n];\\n};\\n```\\n**Time complexity: O(n) for given n;\\nAuxiliary space: O(n);**\\n\\nAlso, to obtain Fibonacci numbers, you can use the matrix method, it is considered one of the most effective.\\n```\\nconst mul = (\\n    [[a1, a2],[a3, a4]],\\n    [[b1, b2],[b3, b4]]) =>\\n    [[a1 * b1 + a2 * b3, a1 * b2 + a2 * b4],\\n     [a3 * b1 + a4 * b3, a3 * b2 + a4 * b4]];\\n\\nconst matrix = [[0, 1],[1, 1]];\\n\\nconst id = [[1, 0],[0, 1]]\\n\\nvar climbStairs = function(n) {\\n    let result = id;\\n    const bits = (n + 1).toString(2);\\n\\n    for(const bit of bits){\\n        result = mul(result, result);\\n        if(bit === \"1\"){\\n            result = mul(result, matrix);\\n        }\\n    }\\n    return result[1][0];\\n}\\n```\\n**Time complexity: O(Log n)\\nAdditional space: O(Log n)** when considering the size of the function call stack, O(1) otherwise.\\nAnd this is very cool - if, of course, this complexity is really so important to us.\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\n    function fib(n) {\\n    if (n <= 1)\\n        return n;\\n    return fib(n-1) + fib(n-2);\\n}\\n```\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let a = 1, b = 1, fib;\\n    for(let i = 2; i <= n; i++) {\\n        fib = a + b;\\n        a = b;\\n        b = fib;\\n    }\\n    return fib;\\n};\\n```\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let fib = [1, 1];\\n    for (let i = 2; i <= n; i++) {\\n        fib[i] = fib[i - 1] + fib[i - 2];\\n    }\\n    return fib[n];\\n};\\n```\n```\\nconst mul = (\\n    [[a1, a2],[a3, a4]],\\n    [[b1, b2],[b3, b4]]) =>\\n    [[a1 * b1 + a2 * b3, a1 * b2 + a2 * b4],\\n     [a3 * b1 + a4 * b3, a3 * b2 + a4 * b4]];\\n\\nconst matrix = [[0, 1],[1, 1]];\\n\\nconst id = [[1, 0],[0, 1]]\\n\\nvar climbStairs = function(n) {\\n    let result = id;\\n    const bits = (n + 1).toString(2);\\n\\n    for(const bit of bits){\\n        result = mul(result, result);\\n        if(bit === \"1\"){\\n            result = mul(result, matrix);\\n        }\\n    }\\n    return result[1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25459,
                "title": "memoization-with-recursion-top-down-approach-dynamic-programming-bottom-up",
                "content": "This problem is nothing but a Fibonacci Sequence.\\n\\nLet\\u2019s define a function T(n) for the number of choices available with n stairs(n steps).There are 2 choices for the first step: One choice is to climb only one stair, and has T(n-1) choices for the remaining n-1 stairs. The other one is to jump two stairs at the first step, and has T(n-2) choices for the remaining n-2 stairs. Therefore, the total number of choices for n stairs is T(n) = T(n-1) + T(n- 2), which is the nothing but Fibonacci Sequence.\\n\\nFor example, there are three choices to climb up a stair with three levels: (1) climb in three steps, one stair for each climb; (2) climb in two steps, one level for the first step and two levels for the second; or (3) climb with two steps, two levels for the first step and one level for the last jump.\\n\\nNow if we code a recursive function T(n) = T(n-1) + T(n-2), each recursive call is called twice for large n, making 2^n calls. This is not recommended. Instead, we save result from each call and check if its available before triggering another call. \\n\\nThis type of saving the intermediate results to get final result is called Memoization. Here we follow top-down approach.\\n\\n    int f(int n, int *arr)\\n    {\\n    \\tif (n == 0 || n == 1) return 1;\\n    \\tif (arr[n] != 0) return arr[n];\\n    \\telse{\\n    \\t  arr[n] = f(n - 1, arr) + f(n - 2, arr);\\n    \\t  return arr[n];\\n    \\t}\\n    }\\n\\n    int climbStairs(int n) {\\n    \\tint *p = (int *)malloc(sizeof(int) * (n + 1));\\n    \\tint res, i;\\n    \\t\\n    \\tif (n == 0 || n == 1) p[n] = 1;  //Base condition\\n    \\t\\n    \\tfor (i = 2; i <= n; i++) p[i] = 0; //For memoization, defaulting all values to 0\\n    \\t\\n    \\tres = f(n, p);\\n    \\tfree(p);\\n    \\t\\n    \\treturn res;\\n    }\\n\\nNow this even can be simplified, what we call as 'Dynamic Programming'. Instead of going from top down, we will do bottom up approach. Calculate T(n) for small values and build larger values using them.\\nThe code looks something like this...\\n\\n    ....\\n    store[0] = 1;\\n    store[1] = 1;\\n    for (i = 2; i <=n; i++)\\n        store[i] = store[i - 1] + store[i - 2];\\n    return store[n];\\n    ...",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "This problem is nothing but a Fibonacci Sequence.\\n\\nLet\\u2019s define a function T(n) for the number of choices available with n stairs(n steps).There are 2 choices for the first step: One choice is to climb only one stair, and has T(n-1) choices for the remaining n-1 stairs. The other one is to jump two stairs at the first step, and has T(n-2) choices for the remaining n-2 stairs. Therefore, the total number of choices for n stairs is T(n) = T(n-1) + T(n- 2), which is the nothing but Fibonacci Sequence.\\n\\nFor example, there are three choices to climb up a stair with three levels: (1) climb in three steps, one stair for each climb; (2) climb in two steps, one level for the first step and two levels for the second; or (3) climb with two steps, two levels for the first step and one level for the last jump.\\n\\nNow if we code a recursive function T(n) = T(n-1) + T(n-2), each recursive call is called twice for large n, making 2^n calls. This is not recommended. Instead, we save result from each call and check if its available before triggering another call. \\n\\nThis type of saving the intermediate results to get final result is called Memoization. Here we follow top-down approach.\\n\\n    int f(int n, int *arr)\\n    {\\n    \\tif (n == 0 || n == 1) return 1;\\n    \\tif (arr[n] != 0) return arr[n];\\n    \\telse{\\n    \\t  arr[n] = f(n - 1, arr) + f(n - 2, arr);\\n    \\t  return arr[n];\\n    \\t}\\n    }\\n\\n    int climbStairs(int n) {\\n    \\tint *p = (int *)malloc(sizeof(int) * (n + 1));\\n    \\tint res, i;\\n    \\t\\n    \\tif (n == 0 || n == 1) p[n] = 1;  //Base condition\\n    \\t\\n    \\tfor (i = 2; i <= n; i++) p[i] = 0; //For memoization, defaulting all values to 0\\n    \\t\\n    \\tres = f(n, p);\\n    \\tfree(p);\\n    \\t\\n    \\treturn res;\\n    }\\n\\nNow this even can be simplified, what we call as 'Dynamic Programming'. Instead of going from top down, we will do bottom up approach. Calculate T(n) for small values and build larger values using them.\\nThe code looks something like this...\\n\\n    ....\\n    store[0] = 1;\\n    store[1] = 1;\\n    for (i = 2; i <=n; i++)\\n        store[i] = store[i - 1] + store[i - 2];\\n    return store[n];\\n    ...",
                "codeTag": "Unknown"
            },
            {
                "id": 914746,
                "title": "easy-js-solution-memoization-and-recursion-in-3-lines",
                "content": "```\\nvar climbStairs = function(n, memo = {1:1, 2:2}) {\\n   if (memo[n] !== undefined) return memo[n];   \\n   memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n   return memo[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar climbStairs = function(n, memo = {1:1, 2:2}) {\\n   if (memo[n] !== undefined) return memo[n];   \\n   memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n   return memo[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25338,
                "title": "fibonacci-sequence-solution-in-java",
                "content": "public class Solution {\\n\\n    public int climbStairs(int n) {\\n        if(n < 0)\\n            return 0;\\n        if(n == 1)\\n            return 1;\\n            \\n        int[] store = new int[n];\\n        \\n        store[0] = 1;\\n        store[1] = 2;\\n        \\n        for(int i = 2; i < n; ++i)\\n            store[i] = store[i-1] + store[i-2];\\n            \\n        return store[n-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int climbStairs(int n) {\\n        if(n < 0)\\n            return 0;\\n        if(n == 1)\\n            return 1;\\n            \\n        int[] store = new int[n];\\n        \\n        store[0] = 1;\\n        store[1] = 2;\\n        \\n        for(int i = 2; i < n; ++i)\\n            store[i] = store[i-1] + store[i-2];\\n            \\n        return store[n-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 25609,
                "title": "simple-and-clear-2ms-solution-in-c-without-recursion",
                "content": "    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int StepOne = 1;\\n            int StepTwo = 0;\\n            int ret = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                ret = StepOne + StepTwo;\\n                StepTwo = StepOne;\\n                StepOne = ret;\\n            }\\n            return ret;\\n        }\\n    };\\n\\nThis problem is a Fibonacci problem.\\nF(n)=F(n-1)+F(n-2);\\nSolving this problem by recursion ,we will do a lot of same recursion.\\nExample:\\nF(10)=F(9)+F(8);\\nF(9)=F(8)+F(7);\\nwe calculate F(8) twice,when n is large,this will increase as a rate of n's exponent.\\n\\nSo a more efficient way to solve this problem is from Bottom to Top.\\nCalculate F(0) ,F(1);\\nthen F(2).........",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int StepOne = 1;\\n            int StepTwo = 0;\\n            int ret = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                ret = StepOne + StepTwo;\\n                StepTwo = StepOne;\\n                StepOne = ret;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 346943,
                "title": "simple-understandable-fibonacci-solution",
                "content": "This is fibonacci without recurrsion.\\n\\n```\\nvar climbStairs = function(n) {    \\n    let prev = 0;\\n    let cur = 1;\\n    let temp;\\n    \\n    for (let i = 0; i < n; i++) {\\n        temp = prev;\\n        prev = cur;\\n        cur += temp; \\n    }\\n    return cur;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar climbStairs = function(n) {    \\n    let prev = 0;\\n    let cur = 1;\\n    let temp;\\n    \\n    for (let i = 0; i < n; i++) {\\n        temp = prev;\\n        prev = cur;\\n        cur += temp; \\n    }\\n    return cur;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791210,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677712,
                "title": "python-4-approaches-with-time-and-space-complexity",
                "content": "Approach 1:- ***Recursion***\\nTC:- ***Exponential (2^n)***\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n        \\n            wayone=stairs(i-1)\\n            waytwo=stairs(i-2)\\n            \\n            return wayone+waytwo\\n        \\n    \\n        return stairs(n)\\n```\\nApproach 2:- ***Recursion+Memoization(Top Down DP)***\\nTC:- ***O(N)*** but space complexity will still have ***stack space*** involved along with ***O(N) Dp array***.\\n\\n```\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i,dp):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            \\n            if dp[i]!=-1:\\n                return dp[i]\\n        \\n            wayone=stairs(i-1,dp)\\n            waytwo=stairs(i-2,dp)\\n            \\n            dp[i]= wayone+waytwo\\n            \\n            return dp[i]\\n        \\n        dp=[-1]*(n+1)\\n        return stairs(n,dp)\\n```\\nApproach 3:- ***Bottom Up DP*** \\nTC:- ***O(N)*** with ***no stack space*** involved but with a **O(n)  dp array**.\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n,dp):\\n            for i in range(2,n+1):\\n                dp[i]=dp[i-1]+dp[i-2]\\n                \\n            return dp[n]\\n            \\n        dp=[-1]*(n+1)\\n        dp[0]=1\\n        dp[1]=1\\n        return stairs(n,dp)\\n```\\nApproach 4:- ***Space Optimisation technique!!!***\\nTC:- ***O(N) with NO EXTRA SPACE!!!***\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n):\\n            if n==0 or n==1:\\n                return 1\\n                \\n            a=1\\n            b=1\\n            for i in range(2,n+1):\\n                c=a+b\\n                a=b\\n                b=c\\n                \\n            return c\\n           \\n            \\n         return stairs(n)\\n```\\n\\t\\t \\n****Do upvote. :)****\\n    \\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n        \\n            wayone=stairs(i-1)\\n            waytwo=stairs(i-2)\\n            \\n            return wayone+waytwo\\n        \\n    \\n        return stairs(n)\\n```\n```\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i,dp):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            \\n            if dp[i]!=-1:\\n                return dp[i]\\n        \\n            wayone=stairs(i-1,dp)\\n            waytwo=stairs(i-2,dp)\\n            \\n            dp[i]= wayone+waytwo\\n            \\n            return dp[i]\\n        \\n        dp=[-1]*(n+1)\\n        return stairs(n,dp)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n,dp):\\n            for i in range(2,n+1):\\n                dp[i]=dp[i-1]+dp[i-2]\\n                \\n            return dp[n]\\n            \\n        dp=[-1]*(n+1)\\n        dp[0]=1\\n        dp[1]=1\\n        return stairs(n,dp)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n):\\n            if n==0 or n==1:\\n                return 1\\n                \\n            a=1\\n            b=1\\n            for i in range(2,n+1):\\n                c=a+b\\n                a=b\\n                b=c\\n                \\n            return c\\n           \\n            \\n         return stairs(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282043,
                "title": "python-easy-4-line-dp-36-ms-faster-than-77-83",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        steps = [1,1]\\n        for i in range(2,n+1):\\n            steps.append(steps[i-1] + steps[i-2])\\n        return steps[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        steps = [1,1]\\n        for i in range(2,n+1):\\n            steps.append(steps[i-1] + steps[i-2])\\n        return steps[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764938,
                "title": "cpp-recursive-memoization-dp-three-solution-easy-to-understand",
                "content": "**Three Solutions step by step \\nfrom recursion to DP**\\n\\n**1. Recursive Solution**\\n**It will give TLE but for better understanding to memoization we have to write it**\\n```\\nclass Solution {\\npublic:\\n    int mk(int n)\\n    {\\n         if(n<0) return 0;\\n         if(n==0) return 1;\\n         return mk(n-1)+mk(n-2); \\n    } \\n    int climbStairs(int n) {\\n        return mk(n);\\n    }\\n};\\n```\\n\\n**2. Memoization of Recursive Solution**\\n\\n**Runtime: 0 ms .\\nMemory Usage: 6.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int mk(int n,vector<int> &memo)\\n    {     \\n         if(n<0) return 0;\\n         if(memo[n]!=-1) return memo[n];\\n         if(n==0) return 1;\\n         return memo[n]=mk(n-1,memo)+mk(n-2,memo);\\n    }\\n     \\n    int climbStairs(int n) {\\n        vector<int> memo(n+1,-1);\\n        return mk(n,memo);\\n    }\\n};\\n```\\n\\n**3. Convert Memoization into dp**\\n\\n**Runtime: 4 ms\\nMemory Usage: 5.9 MB**\\n\\n```\\n class Solution {\\npublic:\\n    \\n    int climbStairs(int n) {\\n\\t    if(n<1) return 0;\\n        int a[100];\\n        a[0]=1;\\n        a[1]=2;\\n        for(int i=2;i<n;i++)\\n            a[i]=a[i-1]+a[i-2];\\n        return a[n-1];\\n    }\\n};\\n```\\n\\n**If any improvement , Kindly comment.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mk(int n)\\n    {\\n         if(n<0) return 0;\\n         if(n==0) return 1;\\n         return mk(n-1)+mk(n-2); \\n    } \\n    int climbStairs(int n) {\\n        return mk(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mk(int n,vector<int> &memo)\\n    {     \\n         if(n<0) return 0;\\n         if(memo[n]!=-1) return memo[n];\\n         if(n==0) return 1;\\n         return memo[n]=mk(n-1,memo)+mk(n-2,memo);\\n    }\\n     \\n    int climbStairs(int n) {\\n        vector<int> memo(n+1,-1);\\n        return mk(n,memo);\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    \\n    int climbStairs(int n) {\\n\\t    if(n<1) return 0;\\n        int a[100];\\n        a[0]=1;\\n        a[1]=2;\\n        for(int i=2;i<n;i++)\\n            a[i]=a[i-1]+a[i-2];\\n        return a[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399534,
                "title": "one-liner-javascript-typescript-solution-with-recursion",
                "content": "# Complexity\\n- Time complexity: 59 ms\\n- Space complexity: 43.3 MB\\n\\n# Code\\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 \\n        ? n \\n        : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\\n\\n# Explanation\\n\\nIf we start making outputs for n starting from 1:\\n\\n### n = 1, Output: 1\\n1. 1 step\\n\\n### n = 2, Output: 2\\n1. 1 step + 1 step\\n2. 2 steps\\n\\n### n = 3, Output: 3\\n1. 1 step + 1 step + 1 step\\n2. 1 step + 2 steps\\n3. 2 steps + 1 step\\n\\n### n = 4, Output: 5\\n1. 1 step + 1 step + 1 step + 1 step\\n2. 1 step + 1 step + 2 steps\\n3. 1 step + 2 steps + 1 step\\n4. 2 steps + 1 step + 1 step\\n5. 2 steps + 2 steps\\n\\nOn a closer look, we can see that these 5 ways are actually:\\n1. 1 step + (1st case of n = 3)\\n2. 1 step + (2nd case of n = 3)\\n3. 1 step + (3rd case of n = 3)\\n4. 2 steps + (1st case of n = 2)\\n5. 2 steps + (2nd case of n = 2)\\n\\ni.e. the output is: (Output for n = 3) + (Output for n = 2)\\n\\n### n = 5, Output: 8\\n1. 1 step + 1 step + 1 step + 1 step + 1 step\\n2. 1 step + 1 step + 1 step + 2 steps\\n3. 1 step + 1 step + 2 steps + 1 step\\n4. 1 step + 2 steps + 1 step + 1 step\\n5. 1 step + 2 steps + 2 steps\\n6. 2 steps + 1 step + 1 step + 1 step\\n7. 2 steps + 1 step + 2 steps\\n8. 2 steps + 2 steps + 1 step\\n\\nSimilarly again, we can see that these 8 ways are actually:\\n1. 1 step + (1st case of n = 4)\\n2. 1 step + (2nd case of n = 4)\\n3. 1 step + (3rd case of n = 4)\\n4. 1 step + (4th case of n = 4)\\n5. 1 step + (5th case of n = 4)\\n6. 2 steps + (1st case of n = 3)\\n7. 2 steps + (2nd case of n = 3)\\n8. 2 steps + (3rd case of n = 3)\\n\\ni.e. the output is: (Output for n = 4) + (Output for n = 3)\\n\\n### Formula\\nSo from above cases, we can see that the output for n = 1 and n = 2 is n. And for n = 3 or > 3 it is: (Output for n - 1) + (Output for n - 2).\\n\\nBecause, for any given n stairs (n >= 3), \\n- if we take 1 step, then we will be left with n - 1 stairs.\\n- and if we take 2 steps, then we will be left with n - 2 stairs.\\n\\nSo, our output will always be: \\n`distinct ways for n stairs = distinct ways for n-1 + distinct ways for n-2`\\n\\nAs our function name is climbStairs, so we can make the formaula using that:\\n`climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)`\\n\\nSo, the code will be like:\\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 2) {\\n        return n;\\n    }\\n    return climbStairs(n - 1) + climbStairs(n - 2);\\n}\\n```\\n\\nIf we submit this solution, it throws runtime error. So we can try to simplify it more:\\n`climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)`\\n`climbStairs(n) = (climbStairs(n-2) + climbStairs(n-3)) + climbStairs(n-2)`\\n(because climbStairs(n-1) = climbStairs(n-2) + climbStairs(n-3))\\n\\nAs the code is doing recursion and here we can see it was calling climbStairs twice for n-2 case in our code. So, to reduce execution time, we can just call it once and multiply it\\'s answer with 2.\\ni.e.\\n`climbStairs(n) = 2 * climbStairs(n-2) + climbStairs(n-3)`\\n\\nMoreover, as we saw for n = 3 case, that the output is 3 i.e. n. So, we can change our if condition to n <= 3, to reduce execution time more.\\n\\n### Final Code\\nSo this makes our solution:\\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 3) {\\n        return n;\\n    }\\n    return 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\\n\\nwhich can be simplified to:\\n\\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 ? n : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 \\n        ? n \\n        : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 2) {\\n        return n;\\n    }\\n    return climbStairs(n - 1) + climbStairs(n - 2);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 3) {\\n        return n;\\n    }\\n    return 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 ? n : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915720,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25368,
                "title": "dynamic-programming-solution-using-java",
                "content": "\\n\\n    /*\\n     * Ideas:\\n     * Use Dynamic Programming,\\n     * for each step, the stair could ether combine with the previous one or as a single step.\\n     * Ways to climb to ith stair is W(i) = W(i-1) + W(i-2)\\n     * where W(i-1) is when the ith stair is as a single step\\n     * and W(i-2) is when the ith stair is paired with the previous one.\\n     */\\n    public int climbStairs(int n) {\\n            int[] tmp = new int[n];\\n            if (n < 2){\\n                return 1;\\n            }\\n            tmp[0] = 1;\\n            tmp[1] = 2;\\n            for (int i = 2; i < n; i++){\\n                tmp[i] = tmp[i-1] + tmp[i-2];\\n            }\\n            return tmp[n-1];\\n        }",
                "solutionTags": [],
                "code": "\\n\\n    /*\\n     * Ideas:\\n     * Use Dynamic Programming,\\n     * for each step, the stair could ether combine with the previous one or as a single step.\\n     * Ways to climb to ith stair is W(i) = W(i-1) + W(i-2)\\n     * where W(i-1) is when the ith stair is as a single step\\n     * and W(i-2) is when the ith stair is paired with the previous one.\\n     */\\n    public int climbStairs(int n) {\\n            int[] tmp = new int[n];\\n            if (n < 2){\\n                return 1;\\n            }\\n            tmp[0] = 1;\\n            tmp[1] = 2;\\n            for (int i = 2; i < n; i++){\\n                tmp[i] = tmp[i-1] + tmp[i-2];\\n            }\\n            return tmp[n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1515325,
                "title": "java-tc-o-logn-sc-o-1-matrix-multiplication-space-optimized-dp-solutions",
                "content": "**Binets Method (Using Matrix Multiplication to find the Fibonacci Number)**\\n\\n```java\\n/**\\n * Binets Method (Using Matrix Multiplication to find the Fibonacci Number)\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1) -> Uses constant complexity\\n *\\n * N = Input number n\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n\\t\\tint[][] q = { { 1, 1 }, { 1, 0 } };\\n        int[][] result = q;\\n        n--; // As we have already solved for n = 1. q[0][0] points to 2nd Fibonacci Number.\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result = multiplyMatrix(result, q);\\n                if (n == 1) {\\n                    break;\\n                }\\n                n--;\\n            }\\n\\n            q = multiplyMatrix(q, q);\\n            n /= 2;\\n        }\\n\\n        return result[0][0];\\n    }\\n\\n    private int[][] multiplyMatrix(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\n---\\n**Space Optimized Dynamic Programming**\\n\\n```java\\n/**\\n * Space Optimized Dynamic Programming\\n *\\n * DP[i] = DP[i-1] + DP[i-2]\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n        int pre = 1; // n == 1\\n        int cur = 2; // n == 2\\n        for (int i = 3; i <= n; i++) {\\n            int sum = cur + pre;1\\n            pre = cur;\\n            cur = sum;\\n        }\\n        return cur;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Binets Method (Using Matrix Multiplication to find the Fibonacci Number)\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1) -> Uses constant complexity\\n *\\n * N = Input number n\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n\\t\\tint[][] q = { { 1, 1 }, { 1, 0 } };\\n        int[][] result = q;\\n        n--; // As we have already solved for n = 1. q[0][0] points to 2nd Fibonacci Number.\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result = multiplyMatrix(result, q);\\n                if (n == 1) {\\n                    break;\\n                }\\n                n--;\\n            }\\n\\n            q = multiplyMatrix(q, q);\\n            n /= 2;\\n        }\\n\\n        return result[0][0];\\n    }\\n\\n    private int[][] multiplyMatrix(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\n```java\\n/**\\n * Space Optimized Dynamic Programming\\n *\\n * DP[i] = DP[i-1] + DP[i-2]\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n        int pre = 1; // n == 1\\n        int cur = 2; // n == 2\\n        for (int i = 3; i <= n; i++) {\\n            int sum = cur + pre;1\\n            pre = cur;\\n            cur = sum;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271911,
                "title": "python-dp-fibonacci",
                "content": "To each a specific stair ```x```, we can either climb 1 stair from ```x-1```, or 2 stairs from ```x-2```. Therefore, suppose ```dp[i]``` records the number of ways to reach stair ```i```, ```dp[i] = dp[i-1]+dp[i-2]```. And it\\'s a Fibonacci Array.\\nThe base case is to reach the first stair, we only have one way to do it so dp[1] = 1.\\nBesides, since only dp elements we used is most recent two elements, we can use two pointer to save using of dp array. So space complexity is O(1)/\\n```\\ndef climbStairs(n):\\n\\tcurr = prev = 1\\n\\tfor _ in range(n-1):\\n\\t\\tcurr, prev = curr + prev, curr\\n\\treturn curr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```x```\n```x-1```\n```x-2```\n```dp[i]```\n```i```\n```dp[i] = dp[i-1]+dp[i-2]```\n```\\ndef climbStairs(n):\\n\\tcurr = prev = 1\\n\\tfor _ in range(n-1):\\n\\t\\tcurr, prev = curr + prev, curr\\n\\treturn curr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765140,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236863,
                "title": "climbing-stairs-all-approaches-well-explained-faster-than-100",
                "content": "**I have shared all four  approaches for the question**\\n**Recursive solution:- Gives TLE if n>=44**\\nt.c-O(2^n)\\ns.c-O(n)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\\n\\n**Memoization method:- Top-Down Approach**\\nt.c-O(n)\\ns.c-O(n) + O(n)\\n```\\nclass Solution {\\npublic:\\n    int calc(int n,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0 || n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        int left = calc(n-1,dp);\\n        int right = calc(n-2,dp);\\n        return dp[n] = left + right;\\n        \\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calc(n,dp);\\n    }\\n};\\n```\\n**Tabulation method:- Bottom-up approach**\\nt.c-O(n)\\ns.c-O(n)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Optimal Approach**\\nt.c-O(n)\\ns.c-O(1)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n==2)\\n        {\\n            return n;\\n        }\\n        int a = 1;\\n        int b = 2;\\n        int c = 0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```\\nIf you like please upvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calc(int n,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0 || n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        int left = calc(n-1,dp);\\n        int right = calc(n-2,dp);\\n        return dp[n] = left + right;\\n        \\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calc(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n==2)\\n        {\\n            return n;\\n        }\\n        int a = 1;\\n        int b = 2;\\n        int c = 0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764847,
                "title": "python-2-solution-dp-fibonacci-math-explained",
                "content": "### Solution 1:\\n\\nWe can climb either `1` or `2` steps, and we are interested how many ways to climb ladder with `n` stairs. How can we reach step number `n`:\\n1. Making step with size `1`, so from step with number `n-1`\\n2. Making step with size `2`, so from step with number `n-2`.\\n\\nSo, if we denote `F[n]` numbers of ways to reach step number `n`, we can write equation: `F[n] = F[n-1] + F[n-2]`. But it is not enough, we also need to define starting cases: `F[1] = 1` and `F[2] = 2`. Or we can say, that `F[0] = 1` and `F[1] = 1`.\\n\\nNow, everything is ready to write our dynamic programming problem.\\n\\n**Complexity**: time complexity is `O(n)` and space complexity is `O(1)`.\\n\\n\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        dp = (1, 1)\\n        for i in range(n-1):\\n            dp = (dp[1], dp[0] + dp[1])\\n        return dp[1]\\n```\\n\\n### Solution 2\\n\\nIf we look carefully at equation `F[n] = F[n-1] + F[n-2]` and starting points, we can see, that we have nothing else, than Fibonacci sequence:\\n\\n`1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`\\n\\nNote however, that it is shifted by one position. So, what we need to do is to use Binet formula: https://en.wikipedia.org/wiki/Fibonacci_number#Binet\\'s_formula, where we use computation by rounding.\\n\\n**Complexity**: both time and memory is `O(1)` if we assume that number in `int32` range and if we assume complexity of `**` as `O(1)`.\\n\\n```\\nreturn round((0.5+sqrt(5)/2)**(n+1)/sqrt(5))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n):\\n        dp = (1, 1)\\n        for i in range(n-1):\\n            dp = (dp[1], dp[0] + dp[1])\\n        return dp[1]\\n```\n```\\nreturn round((0.5+sqrt(5)/2)**(n+1)/sqrt(5))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302571,
                "title": "fastest-possible-solution-c-professors-hate-him",
                "content": "# Intuition\\nThey don\\'t teach you this at school\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI AM SPEED\\n\\n# Complexity\\n- Time complexity:O(0)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(45)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\\n\\n        return (int)fast[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\\n\\n        return (int)fast[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893345,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nconst cache: number[] = []\\n\\nfunction climbStairs(n: number): number {\\n  if (n <= 2) return n\\n  if (!cache[n]) { cache[n] = climbStairs(n - 2) + climbStairs(n - 1) }\\n  return cache[n]\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst cache: number[] = []\\n\\nfunction climbStairs(n: number): number {\\n  if (n <= 2) return n\\n  if (!cache[n]) { cache[n] = climbStairs(n - 2) + climbStairs(n - 1) }\\n  return cache[n]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379365,
                "title": "bored-of-long-solution-try-mine-pls-upvote-if-helpful",
                "content": "```\\nclass Solution:\\n    d={1:1,2:2}\\n    def climbStairs(self, n: int) -> int:\\n        if self.d.get(n,0):return self.d.get(n)\\n        self.d[n]=self.climbStairs(n-1)+self.climbStairs(n-2)\\n        return self.d[n]\\n```\\nSee pattern:\\nn=1, output=1\\nn=2, output=2\\nn=3, output=3\\nn=4, output=5\\nn=5, output=8\\n.....\\nBasically, answers are coming in the form of fibonacci series f(n)=f(n-1)+f(n-2).\\nWhat we are doing is storing the value of f(n) at every recursion step in the form of dictionary and we don\\'t need to go to base case for every step. We are just checking at every recursion call if that value of f(n-1) or f(n-2) called by f(n) is already there in dictionary if it\\'s there we reduce number of steps and return the answer to further function call.\\nFor example, take n=6\\ncalls going like this:\\n![image](https://assets.leetcode.com/users/images/85d9f775-a841-4ed8-b29b-52e8ae9bdf39_1627966437.362527.png)\\nI think this might help.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    d={1:1,2:2}\\n    def climbStairs(self, n: int) -> int:\\n        if self.d.get(n,0):return self.d.get(n)\\n        self.d[n]=self.climbStairs(n-1)+self.climbStairs(n-2)\\n        return self.d[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385821,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int dp[n+1];\\n        dp[1]=1;\\n        dp[0]=1;\\n        for(int i=2;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/dca7255e-0637-4e64-b0ea-eba1eb0291b9_1680770553.0661306.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int dp[n+1];\\n        dp[1]=1;\\n        dp[0]=1;\\n        for(int i=2;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609648,
                "title": "100-faster-solution-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n# Iterative solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        int x=1, y=2;\\n        \\n        for(int i=3; i<n; i++){ // if i<=n\\n            int temp = y;\\n            y += x;\\n            x = temp;\\n        }\\n        return x+y; // return y\\n    }\\n};\\n```\\n\\n# Recursive solution: (*will give TLE*)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        return climbStairs(n-1)+ climbStairs(n-2);\\n    }\\n};\\n```\\n# DP solution:\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int t[n+1];\\n        \\n        t[1]=1;\\n        if(n>=2) t[2]=2; //if we don\\'t give the condition then it will give runtime error for i/p 1\\n        \\n        for(int i=3; i<=n; i++)\\n            t[i]= t[i-1]+t[i-2];\\n        \\n        return t[n];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        int x=1, y=2;\\n        \\n        for(int i=3; i<n; i++){ // if i<=n\\n            int temp = y;\\n            y += x;\\n            x = temp;\\n        }\\n        return x+y; // return y\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        return climbStairs(n-1)+ climbStairs(n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434721,
                "title": "c-100-o-n-with-explanation",
                "content": "#To climb a stair we have to check the recurrence relation:\\n\\n              climb(n) = climb(n-1) + climb(n-2);   //arr[0]=1&&arr[1]=1; (to reach ground and\\n\\t\\t\\t                                         //first stair we have to take one step only).\\n\\t\\t\\t  \\nwe can either take 1 step or 2 step at once.....so to reach suppose 3rd stair we can either jump 2 steps from 1st stair or 1 step from 2nd stair......so total ways to reach 3rd stair will be sum of total ways to reach 1st stair + 2nd stair.\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint climbStairs(int n) {\\n\\t\\t\\t\\tint arr[n+1];\\n\\t\\t\\t\\tarr[0]=1;\\n\\t\\t\\t\\tarr[1]=1;\\n\\t\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\t\\tarr[i]=arr[i-1]+arr[i-2];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn arr[n];\\n\\t\\t}\\n\\t};                  \\n\\t                  //please upvote if i helped",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint climbStairs(int n) {\\n\\t\\t\\t\\tint arr[n+1];\\n\\t\\t\\t\\tarr[0]=1;\\n\\t\\t\\t\\tarr[1]=1;\\n\\t\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\t\\tarr[i]=arr[i-1]+arr[i-2];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 417563,
                "title": "javascript-very-short",
                "content": "```\\nvar climbStairs = function(n) {\\n    let a = 1, b = 2, next;\\n    \\n    for(let i = 3; i <= n; i++) {\\n        next = a + b;\\n        a = b;\\n        b = next;\\n    }\\n    return n === 1 ? a : b;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar climbStairs = function(n) {\\n    let a = 1, b = 2, next;\\n    \\n    for(let i = 3; i <= n; i++) {\\n        next = a + b;\\n        a = b;\\n        b = next;\\n    }\\n    return n === 1 ? a : b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231911,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-c-javascript-java",
                "content": "\\n# Approach\\nIn that firstly we created an array that consists of two possibilties just like we did in fibnocci series and then we loop through it and added value in to the index which will be increased on every iteration. At the end we are returning the second last number from the array and this is our expected result we want very simple logic you can clealy understand the code.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code by using For Loop\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let arr = [1,2];\\n    for(let i =2; i <= n; i++){\\n        arr[i] = arr[i - 1] + arr[i - 2]\\n    }\\n    return arr[n-1]\\n};\\n```\\n# Code By using Recursion\\n# Approach\\nwe can also did it by using recursion but in leetcode this is not acceptable due to the big out input when we passed some big number init it will taked time to execute so due to this reason Maximum time is exceeded on leetcode editor you can try it on another editor.\\n```\\nvar climbStairs = (n) => {\\n    if(n <= 1) return 1;\\n    return climbStairs(n - 1) + climbStairs(n - 2)\\n}\\n```\\n\\n##### I am working hard for you guys...\\n##### Please upvote if you found any help with this code...",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let arr = [1,2];\\n    for(let i =2; i <= n; i++){\\n        arr[i] = arr[i - 1] + arr[i - 2]\\n    }\\n    return arr[n-1]\\n};\\n```\n```\\nvar climbStairs = (n) => {\\n    if(n <= 1) return 1;\\n    return climbStairs(n - 1) + climbStairs(n - 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2810612,
                "title": "4-ways-to-solve-with-detailed-diagrams-no-memoization-beats-100-time-memory",
                "content": "For the lazy one\\'s... here\\'s your solution:\\n\\n# Hackers Approach:\\n```go\\nfunc climbStairs(n int) int {\\n    next, secondNext := 0, 1\\n    for ; n > 0; n-- {\\n        next, secondNext = secondNext, next + secondNext\\n    }\\n    return secondNext\\n}\\n```\\n\\nBut for the more curious types read below for the detailed explaination...\\n\\n\\n# Intuition\\n*Some much necessary research to come up with the solution:*\\n![Untitled4.png](https://assets.leetcode.com/users/images/23dc8877-f265-49b1-b372-3b3b46db7759_1695038975.7068937.png)\\n\\n\\n![Untitled2.png](https://assets.leetcode.com/users/images/8e65a7d5-7dcb-4bcb-b13d-32aaf1fbf9a6_1695038994.3318722.png)\\n\\n![Untitled3.png](https://assets.leetcode.com/users/images/7bca2cec-0a9c-42c0-8368-b1f9a10262f0_1695039072.5319896.png)\\n\\nSample runs:\\n```\\n1 stairs --> [(1)] --> 1 way\\n2 stairs --> [(1,1); (2)] --> 2 ways\\n3 stairs --> [(1,1,1);(2,1); (1,2)] --> 3 ways\\n4 stairs --> [(1,1,1,1);(2,1,1);(1,2,1); (1,1,2);(2,2)] --> 5 ways\\n... so on\\n```\\nwe see the pattern, the ways to climb N stairs is sum total of ways to climb (N-1) stairs plus (N-2) stairs.\\n```\\nways(1) = 1\\nways(2) = 2\\nways(3) = 3 = 2+1 = [1step first => ways(2)] + [2steps first => ways(1)]\\nways(4) = 5 = 3+2 = [1step first => ways(3)] + [2steps first => ways(2)]\\n... so on\\n...\\nways(n) = ways(n-1) + ways(n-2)\\n```\\n\\nLet\\'s appreciate the fact that we\\'ve all solved a **fibonacci** before and this is not much different.\\n\\n\\n# Recursive Approach\\nBased on our intuition, we come up with the following algo:\\n\\n***Recursive solution: O(2^n) time and O(n) space for call stack***\\n```go\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    }\\n    \\n    return climbStairs(n-1) + climbStairs(n-2)    \\n}\\n```\\n\\n> However, the above solution would result in TLE(time limit exceeded) as we will keep on calculating some already calculated values again and again. So, maybe we could store the previous results. Memoization to the rescue.\\nWe can achieve this by modifying the above implementation, like so:\\n\\n# DP Approach\\n***Dynamic Programming solution: O(n) time and O(n) space***\\n![Screenshot 2023-09-18 at 6.06.35 PM.png](https://assets.leetcode.com/users/images/6ddbc852-d2bf-4a7c-a054-16451276cb5e_1695040633.4257736.png)\\n\\n```\\nvar mem map[int]int = map[int]int{}\\n\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    } else if val, ok := mem[n]; ok {\\n        return val\\n    }\\n\\n    res := climbStairs(n-1) + climbStairs(n-2)\\n    mem[n] = res\\n    return res\\n}\\n```\\n\\n> However, this is just waste of space. At any given point, all we need is the previous two calculated results, not all. \\n![IMG_0252.jpg](https://assets.leetcode.com/users/images/f30555a5-0507-4c54-8526-eb0978b31d57_1695040666.829807.jpeg)\\nNot to mention the space needed for the recursion call stack. We can avoid an O(2n) space by getting rid of the recursion and unused memoized values in the above implementation, like so:\\n\\n\\n# Iterative Approach\\n***Iterative Solution: O(n) time and O(1) space***\\n\\n\\n```\\nfunc climbStairs(n int) int {\\n    res := 0\\n    \\n    secondNext := 0\\n    next := 0\\n    for i := 1; i <= n; i++ {\\n        if i == 1 {\\n            res = 1\\n        } else if i == 2 {\\n            res = 2\\n        } else {\\n            res = secondNext + next\\n        }\\n        \\n        next = secondNext\\n        secondNext = res\\n    }\\n    \\n    return res\\n}\\n```\\n\\n> a few more hacks to slim down this code above and you\\'ll end up with the concise code shared at the top...\\nOr, we could come up with this algo directly, without needing to build upon all the above iterations. Let\\'s answer a few questions for that:\\n\\n_Q: How many ways are there to climb up to the floor?_\\n_A: Duh! Zero_\\n\\n_Q: How many ways can I climb up to the first step?_\\n_A: One. Yeah just One._\\n\\n_Q: How many ways can I climb up to the 2nd step?_\\n_A: Uhmm! Either I take 2 steps from the floor or, I take 1 step from the 1st step._\\n\\n_Q: So how many ways is that?_\\n_A: Two_\\n\\n_Q: Cool, now how many ways can I climb up to the 3rd step?_\\n_A: 2 Ways. Either I take 2 steps from the 1st step or, I take 1 step from the 2nd step._\\n\\n_Q: Nope, to take 1 step from the 2nd step, you need to first reach the 2nd step, and there are more than 1 ways to reach. We need to consider all those ways too. We already calculated it earlier. So how many now?_\\n_A: X ways to reach step 1st step + Y ways to reach 2nd step_\\n_That should be `1 + 2 = 3`_\\n\\n_Q: Great, Now to reach 4th step...?_\\n_A: 1 step from the 3rd step or 2 steps from the 2nd step_\\n_that is, `ways to reach 3rd step + ways to reach 2nd step = 3 + 2 = 5`_\\n\\n_Q: Awesome, can we generalize it?_\\n_A: Yes, `ways to reach given step = ways to reach last step + ways to reach second-last step`_\\n\\n_Q: How can we find ways to reach the `N-th` step?_\\n_A: Simple, we use the result from previous 2 runs and repeat this process N times._\\n\\n_Q: A where do we start?_\\n_A: from the floor. lol. `secondLast=0` and `last=1`.\\n\\n_Q: Can we write the code now?_\\n_A: Ofcourse_\\n```go\\nfunc climbStairs(n int) int {\\n    secondLast, last := 0, 1\\n    for i:=1; i<=n; i++ {\\n        secondLast, last = last, secondLast + last\\n    }\\n    return last\\n}\\n```\\n\\n\\n\\n#### PS: Please upvote if you liked the explanatoin and appreciate my effort, helps it reaching others who need it. Thanks :)\\nStay motivated. \\n\\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc climbStairs(n int) int {\\n    next, secondNext := 0, 1\\n    for ; n > 0; n-- {\\n        next, secondNext = secondNext, next + secondNext\\n    }\\n    return secondNext\\n}\\n```\n```\\n1 stairs --> [(1)] --> 1 way\\n2 stairs --> [(1,1); (2)] --> 2 ways\\n3 stairs --> [(1,1,1);(2,1); (1,2)] --> 3 ways\\n4 stairs --> [(1,1,1,1);(2,1,1);(1,2,1); (1,1,2);(2,2)] --> 5 ways\\n... so on\\n```\n```\\nways(1) = 1\\nways(2) = 2\\nways(3) = 3 = 2+1 = [1step first => ways(2)] + [2steps first => ways(1)]\\nways(4) = 5 = 3+2 = [1step first => ways(3)] + [2steps first => ways(2)]\\n... so on\\n...\\nways(n) = ways(n-1) + ways(n-2)\\n```\n```go\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    }\\n    \\n    return climbStairs(n-1) + climbStairs(n-2)    \\n}\\n```\n```\\nvar mem map[int]int = map[int]int{}\\n\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    } else if val, ok := mem[n]; ok {\\n        return val\\n    }\\n\\n    res := climbStairs(n-1) + climbStairs(n-2)\\n    mem[n] = res\\n    return res\\n}\\n```\n```\\nfunc climbStairs(n int) int {\\n    res := 0\\n    \\n    secondNext := 0\\n    next := 0\\n    for i := 1; i <= n; i++ {\\n        if i == 1 {\\n            res = 1\\n        } else if i == 2 {\\n            res = 2\\n        } else {\\n            res = secondNext + next\\n        }\\n        \\n        next = secondNext\\n        secondNext = res\\n    }\\n    \\n    return res\\n}\\n```\n```go\\nfunc climbStairs(n int) int {\\n    secondLast, last := 0, 1\\n    for i:=1; i<=n; i++ {\\n        secondLast, last = last, secondLast + last\\n    }\\n    return last\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712423,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677807,
                "title": "comprehensive-python-explanation",
                "content": "The key here is that we can climb 1 or 2 steps at each point. Therefore, the number of ways to climb ```n``` steps is equal to the number of ways to climb ```n-1``` steps + the number of ways to climb ```n-2``` steps since we can reach the ```n```th step from either of these two previous steps. This is actually the exact same as the fibonnaci sequence, meaning we can solve this problem exactly like we would solve [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/?envType=study-plan&id=level-1).\\n\\n**Basic Recursion Solution; Time: O(2^N), Space: O(1) --> TLE**\\n```\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\\nThis is the most basic solution, taking advantage of the recursive relationship we explored above. However, it is quite slow and results in a time limit exception because it has a time complextiy of ```O(2^N)``` since we need to make 2 recursive calls at each point and those recursive calls make recursive calls of their own. This can be illustrated with the following diagram about the fibonnaci sequence (credit to [Prateek Narang](https://www.scaler.com/topics/fibonacci-series-in-c/)):\\n![image](https://assets.leetcode.com/users/images/0b8e23d2-abd9-4553-b622-5efb833ba81a_1665202511.7852473.png)\\nTo improve on this solution, we can use memoization, one of the core DP techniques. Memoization just means storing our previous results. One way to do this is with python\\'s built in ```@cache```, which stores previous return values from a function call.\\n\\n**Cache Memoization Solution: Time: O(N), Space: O(N)**\\n```\\n@cache # store previous results\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\\nThe time complexity is now ```O(N)``` since we only need to make one calculation for every value from ```1``` to ```n```. The space is also ```O(N)``` since we are now storing the answers to recursive calls to ```climbStairs```. This solution is probably not what an interviewer wants though, so let\\'s store the results ourselves by using a list where the ```i```th index corresponds to the result of ```climbStairs(i+1)```.\\n\\n**List Memoization Solution; Time: O(N), Space: O(N)**\\n```\\ndef climbStairs(self, n):\\n\\tdistinct_ways = [1,2] # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways.append(distinct_ways[-1] + distinct_ways[-2]) # can come from either of the last two steps\\n\\treturn distinct_ways[n-1] # how many ways to go up n stairs\\n```\\nThis is a great solution, but we can do even better! When we add the newest number to ```distinct_ways``` , we actually only need to access the previous numbers in ```distinct_ways```, so we can just use a tuple to store the last two!\\n\\n**Optimized Memoization Solution; Time: O(N), Space: O(1)**\\n```\\ndef climbStairs(self, n):\\n\\tif n == 1: # only 1 way to go up 1 step\\n\\t\\treturn 1\\n\\tdistinct_ways = (1,2) # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways = (distinct_ways[1], distinct_ways[0] + distinct_ways[1]) # the previous number of ways becomes the second previous number of ways and the previous number of ways becomes the sum of the last two\\n\\treturn distinct_ways[1] # how many ways to go up n stairs\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```n```\n```n-1```\n```n-2```\n```n```\n```\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\n```O(2^N)```\n```@cache```\n```\\n@cache # store previous results\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\n```O(N)```\n```1```\n```n```\n```O(N)```\n```climbStairs```\n```i```\n```climbStairs(i+1)```\n```\\ndef climbStairs(self, n):\\n\\tdistinct_ways = [1,2] # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways.append(distinct_ways[-1] + distinct_ways[-2]) # can come from either of the last two steps\\n\\treturn distinct_ways[n-1] # how many ways to go up n stairs\\n```\n```distinct_ways```\n```distinct_ways```\n```\\ndef climbStairs(self, n):\\n\\tif n == 1: # only 1 way to go up 1 step\\n\\t\\treturn 1\\n\\tdistinct_ways = (1,2) # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways = (distinct_ways[1], distinct_ways[0] + distinct_ways[1]) # the previous number of ways becomes the second previous number of ways and the previous number of ways becomes the sum of the last two\\n\\treturn distinct_ways[1] # how many ways to go up n stairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2383701,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n* *** Java ***\\n\\nRecustion (Top Down Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\nRecustion + Memorization (Top Down Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\\n\\nDP (Bottom Up Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\nDP + Optimization (Bottom Up Approach)\\n\\nTo calculate the new value we only leverage the previous two values. So we don\\'t need to use an array to store all the previous values.\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\\n* *** Python ***\\n\\n```\\n\\n# Top down - TLE\\ndef climbStairs1(self, n):\\n    if n == 1:\\n        return 1\\n    if n == 2:\\n        return 2\\n    return self.climbStairs(n-1)+self.climbStairs(n-2)\\n \\n# Bottom up, O(n) space\\ndef climbStairs2(self, n):\\n    if n == 1:\\n        return 1\\n    res = [0 for i in xrange(n)]\\n    res[0], res[1] = 1, 2\\n    for i in xrange(2, n):\\n        res[i] = res[i-1] + res[i-2]\\n    return res[-1]\\n\\n# Bottom up, constant space\\ndef climbStairs3(self, n):\\n    if n == 1:\\n        return 1\\n    a, b = 1, 2\\n    for i in xrange(2, n):\\n        tmp = b\\n        b = a+b\\n        a = tmp\\n    return b\\n    \\n# Top down + memorization (list)\\ndef climbStairs4(self, n):\\n    if n == 1:\\n        return 1\\n    dic = [-1 for i in xrange(n)]\\n    dic[0], dic[1] = 1, 2\\n    return self.helper(n-1, dic)\\n    \\ndef helper(self, n, dic):\\n    if dic[n] < 0:\\n        dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n    return dic[n]\\n    \\n# Top down + memorization (dictionary)  \\ndef __init__(self):\\n    self.dic = {1:1, 2:2}\\n    \\ndef climbStairs(self, n):\\n    if n not in self.dic:\\n        self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n    return self.dic[n]\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\\n* *** C++ ***\\n\\n**Idea - this is just simple fibonacci!**\\nThe base cases are:\\n\\n* n = 0 -> 0\\n* n = 1 -> 1\\n* n = 2 -> 2\\n\\nThen, for each step i, the number of ways to get to it is: either the last step was of 1 step, so we have prev, or it was a 2 step, and that\\'s prev2, so all together the number of ways to get to our current step is prev + prev2.\\nIf we check the first few, we can see clearly that it comes out a fibonacci sequence.\\n\\nTime Complexity: **O(n)**\\nSpace Complexity: **O(1)**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\\n* *** JavaScript ***\\n\\n```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\\n* *** Python3 ***\\n\\n\\nGeneral inutution\\n-> Intution : the next distinict way of climbing stairs is euqal to the sum of the last two distinict way of climbing\\ndistinct(n) = distinict(n-1) + distinict(n-2)\\nThis intution can be applied using the following three approach --> ordered from easy to difficult approach\\n\\n\\n\\nIdea 1 : pure recursive (Can\\'t pass the test case :does not work for big number, result time-exced limit)\\n- The base case will be when only 1 or 2 steps left\\n- Result time-exced limit\\n\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n```\\n\\n\\'\\'\\'\\nIdea 2 : use dictionary (look-up table) to memorize repeating recursion\\n- The memory start with the base case and recored every recurssion\\n\\'\\'\\'\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\\n\\'\\'\\'\\nIdea 3 : Dynamic programming\\n--> store the distinct ways in a dynamic table\\nclimb = [climb(0), climb(1), climb(2)=climb(0)+climb(1), climb(3)=climb(2)+climb(1),......climb(n)=climb(n-1)+climb(n-2)]\\ndp = [ 0, 1, 2, 3, 5, dp(i-1)+dp(i-2])]\\nreturn dp[n]\\n\\'\\'\\'\\n```\\ndef climb(n):\\n    #edge cases\\n    if n==0: return 0\\n    if n==1: return 1\\n    if n==2: return 2\\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\\n    dp[1]= 1\\n    dp[2] = 2\\n    for i in range(3,n+1):\\n        dp[i] = dp[i-1] +dp[i-2]\\n    print(dp)\\n    return dp[n]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\\n* *** Kotlin ***\\n\\n\\n```\\n\\nfun climbStairs(n: Int): Int {\\n      tailrec fun fib(i: Int, first: Int, second: Int): Int =\\n          if (i == n)\\n              first + second\\n          else\\n              fib(i + 1, first = second, second = first + second)\\n\\n      return fib(1, 0, 1)\\n}\\n\\n```\\n\\n* Base case: First steir - we have just 1 option, Second stair - same, only one option.\\n* Starting from 3rd stair Iterate over stairs,\\nnumber of posiible stair options - is a sum of possible options for previous stair + pre-previous, since we can move by 2 stairs in one step.\\n\\n```\\nTime complexity - O(n) - iterate through all n stairs\\nSpace complexity - O(n+1) - space for dp array\\n```\\n\\n```\\nfun climbStairs(n: Int): Int {\\n    val dp = IntArray(n + 1)\\n\\n    dp[0] = 1\\n    dp[1] = 1\\n\\n    for (i in 2..n) {\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    }\\n    return dp[n]\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\\n* *** Swift ***\\n\\n\\n```\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\\n* *** PHP ***\\n\\n\\n```\\n\\nfunction climbStairs($n) {\\n\\n    $arr = [NULL, 1, 2];\\n    for($i = 3; $i <= $n; $i++)\\n      $arr[$i] = $arr[$i-1] + $arr[$i-2];\\n\\n    return $arr[$n];\\n}\\n\\n```\\n\\n```\\nfunction climbStairs($n) {\\n            return round(pow((sqrt(5)+1)/2, $n+1) / sqrt(5));\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\\n* *** C ***\\n\\n\\n```\\n\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n\\n```\\n\\n```\\nint climbStairs(int n){\\n    if(n==1) return 1;\\n    else if(n==2) return 2;\\n    else\\n    {\\n        int sum = 0,s1 = 1,s2 = 2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            sum=s1+s2;\\n            s1 = s2;\\n            s2 = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\n# Top down - TLE\\ndef climbStairs1(self, n):\\n    if n == 1:\\n        return 1\\n    if n == 2:\\n        return 2\\n    return self.climbStairs(n-1)+self.climbStairs(n-2)\\n \\n# Bottom up, O(n) space\\ndef climbStairs2(self, n):\\n    if n == 1:\\n        return 1\\n    res = [0 for i in xrange(n)]\\n    res[0], res[1] = 1, 2\\n    for i in xrange(2, n):\\n        res[i] = res[i-1] + res[i-2]\\n    return res[-1]\\n\\n# Bottom up, constant space\\ndef climbStairs3(self, n):\\n    if n == 1:\\n        return 1\\n    a, b = 1, 2\\n    for i in xrange(2, n):\\n        tmp = b\\n        b = a+b\\n        a = tmp\\n    return b\\n    \\n# Top down + memorization (list)\\ndef climbStairs4(self, n):\\n    if n == 1:\\n        return 1\\n    dic = [-1 for i in xrange(n)]\\n    dic[0], dic[1] = 1, 2\\n    return self.helper(n-1, dic)\\n    \\ndef helper(self, n, dic):\\n    if dic[n] < 0:\\n        dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n    return dic[n]\\n    \\n# Top down + memorization (dictionary)  \\ndef __init__(self):\\n    self.dic = {1:1, 2:2}\\n    \\ndef climbStairs(self, n):\\n    if n not in self.dic:\\n        self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n    return self.dic[n]\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\n```\\ndef climb(n):\\n    #edge cases\\n    if n==0: return 0\\n    if n==1: return 1\\n    if n==2: return 2\\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\\n    dp[1]= 1\\n    dp[2] = 2\\n    for i in range(3,n+1):\\n        dp[i] = dp[i-1] +dp[i-2]\\n    print(dp)\\n    return dp[n]\\n```\n```\\n```\n```\\n```\n```\\n\\nfun climbStairs(n: Int): Int {\\n      tailrec fun fib(i: Int, first: Int, second: Int): Int =\\n          if (i == n)\\n              first + second\\n          else\\n              fib(i + 1, first = second, second = first + second)\\n\\n      return fib(1, 0, 1)\\n}\\n\\n```\n```\\nTime complexity - O(n) - iterate through all n stairs\\nSpace complexity - O(n+1) - space for dp array\\n```\n```\\nfun climbStairs(n: Int): Int {\\n    val dp = IntArray(n + 1)\\n\\n    dp[0] = 1\\n    dp[1] = 1\\n\\n    for (i in 2..n) {\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    }\\n    return dp[n]\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nfunction climbStairs($n) {\\n\\n    $arr = [NULL, 1, 2];\\n    for($i = 3; $i <= $n; $i++)\\n      $arr[$i] = $arr[$i-1] + $arr[$i-2];\\n\\n    return $arr[$n];\\n}\\n\\n```\n```\\nfunction climbStairs($n) {\\n            return round(pow((sqrt(5)+1)/2, $n+1) / sqrt(5));\\n    }\\n```\n```\\n```\n```\\n```\n```\\n\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n\\n```\n```\\nint climbStairs(int n){\\n    if(n==1) return 1;\\n    else if(n==2) return 2;\\n    else\\n    {\\n        int sum = 0,s1 = 1,s2 = 2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            sum=s1+s2;\\n            s1 = s2;\\n            s2 = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567398,
                "title": "go-solution",
                "content": "```\\nfunc climbStairs(n int) int {\\n    a, b := 1, 1\\n    for ; n > 1; n-- {\\n        a, b = b, a + b\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc climbStairs(n int) int {\\n    a, b := 1, 1\\n    for ; n > 1; n-- {\\n        a, b = b, a + b\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283874,
                "title": "simple-dp-javascript-fibonacci-solution-js",
                "content": "```\\nvar climbStairs = function(n) {\\n    if (n < 3) return n;\\n    let first = 1;\\n    let second = 2;\\n    for (let i = 3; i <= n; i++) {\\n        const current = first + second;\\n\\t\\t// Update first and second for next loop\\n        first = second;\\n        second = current;\\n    }\\n\\t// When loop fininshes, second is pointing to the result of the last index, which is the result of the whole function\\n    return second;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar climbStairs = function(n) {\\n    if (n < 3) return n;\\n    let first = 1;\\n    let second = 2;\\n    for (let i = 3; i <= n; i++) {\\n        const current = first + second;\\n\\t\\t// Update first and second for next loop\\n        first = second;\\n        second = current;\\n    }\\n\\t// When loop fininshes, second is pointing to the result of the last index, which is the result of the whole function\\n    return second;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686525,
                "title": "c-0ms-100-faster-solution-using-dp",
                "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        int c = solve(n+1,dp);\\n        return c;\\n    }\\n    \\npublic:\\n    int solve(int n,vector<int>dp)\\n    {\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i = 2;i < n; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        int c = solve(n+1,dp);\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2567823,
                "title": "java-100-fast-4-lines-code-climbing-stairs",
                "content": "**If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have any queries or any improvements please feel free to comment and share your views.**\\n\\nNOTE : its acutally a fibanacci pattern,\\n1 step = 1 stair, 2 step = 2 stair, 3 step = 3 stair , 4 step = 5 stair, 5 step = 8 stair , etc..\\nfibannaci pattern : 0,1,1,2,3,5,8,13...... \\n\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int a =0;\\n        int b=1;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            sum=a+b;\\n            a=b;\\n            b=sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int a =0;\\n        int b=1;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            sum=a+b;\\n            a=b;\\n            b=sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25298,
                "title": "python-solution-beats-96-with-factorial",
                "content": "The basic idea is to get all possible permutations of fixed # of 1 and 2 \\n```\\nfrom math import factorial\\ndef climbStairs(self, n):\\n    res= 0\\n    two = n//2\\n\\n    for i in range(two+1):\\n        t = i           # number of twos\\n        o = n-t*2       # number of ones\\n        res += factorial(t+o)/(factorial(t)*factorial(o))     # (two+one)!/ (two!*one!)\\n            \\n    return res\\n```\\n\\ne.g.\\n5 stairs in total, so we get:\\n1) 0 two, 5 ones  -> 1 permutation \\n2) 1 two, 3 ones  -> (3+1)!/(3!*1!) = 4 permutations\\n3) 2 twos, 1 one -> (2+1)!/(2!*1!) = 3 permutations\\n\\n1+4+3 = 8 in total\\n\\nThis is my first time to post...\\nHope you like my solution :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import factorial\\ndef climbStairs(self, n):\\n    res= 0\\n    two = n//2\\n\\n    for i in range(two+1):\\n        t = i           # number of twos\\n        o = n-t*2       # number of ones\\n        res += factorial(t+o)/(factorial(t)*factorial(o))     # (two+one)!/ (two!*one!)\\n            \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25522,
                "title": "0ms-o-n-constant-space-java-solution",
                "content": "      public int climbStairs(int n) {\\n        if(n==1||n==0)\\n            return n;\\n        int count1=1;\\n        int count2=1;\\n        \\n        \\n        for(int i=2; i<=n; i++){\\n            int temp = count2;\\n            count2 = temp+count1;\\n            count1 = temp;\\n        }\\n        return count2;\\n        }",
                "solutionTags": [],
                "code": "      public int climbStairs(int n) {\\n        if(n==1||n==0)\\n            return n;\\n        int count1=1;\\n        int count2=1;\\n        \\n        \\n        for(int i=2; i<=n; i++){\\n            int temp = count2;\\n            count2 = temp+count1;\\n            count1 = temp;\\n        }\\n        return count2;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2903888,
                "title": "one-line-math-javascript-time-o-log-n-space-o-1",
                "content": "# Intuition\\nBinet\\'s Formula. Please upvote if you found something interesting :)\\n\\n![image.png](https://assets.leetcode.com/users/images/833a64f1-7fda-4783-a20e-a369dd73d258_1670839810.799308.png)\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n,s=Math.sqrt(5)) {\\n  return (Math.pow((1+s)/2,n+1)-Math.pow((1-s)/2,n+1))/s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n,s=Math.sqrt(5)) {\\n  return (Math.pow((1+s)/2,n+1)-Math.pow((1-s)/2,n+1))/s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903557,
                "title": "c-dynamic-programming-modified-version",
                "content": "**Please vote if my solution was helpful ;)**\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n# Optimized Solution -  O(1) space complexity\\n\\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int first = 1;\\n        int second = 2;\\n        int output = second;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            output = first + second;\\n            first = second;\\n            second = output;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int first = 1;\\n        int second = 2;\\n        int output = second;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            output = first + second;\\n            first = second;\\n            second = output;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212257,
                "title": "java-100-faster-and-cleaner-two-approaches",
                "content": "![image](https://assets.leetcode.com/users/images/d5df59c3-02b5-499d-95f1-69e6b350c940_1662187370.809809.jpeg)\\nHaving doubts? Ask me in the comment section. If you find this solution helpful please leave an upvote. Thanks for visiting! Happy Coding ; )\\n\\n# Bottom-up approach\\nthis is like a combination problem\\nIt is given you can can either climb `1` or `2` steps\\nMeaning, if you are at stair number `i`, from here you can only jump to stair `i+1` or stair `i+2`, now like this you can have multiple ways to reach your target stair.\\n\\nSo, consider these stairs as different levels of a game.\\nSee this picture, to reach round 1, you have two ways, like this at every point, you have two ways to reach the next round\\nIf your final round is `3`,total number of possible paths would be 5.\\n\\nIntuition: `total ways to reach from i to n` = `total ways to reach from i+1 to n` + `total ways to reach from i+2 to n`\\n\\nAlso, `use an array to store already calculated paths, to save time`.--> important!\\n\\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n        x = n;\\n        return util(0);\\n    }\\n    private int util(int n) {\\n        if(n == x) {\\n            return 1;\\n        }\\n        if(n > x) {\\n            return 0;\\n        }\\n        if(data[n] == 0) {\\n            data[n] = util(n+1) + util(n+2);\\n        }\\n        return data[n];\\n    }\\n}\\n```\\n\\n# Top-down approach\\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n       if(n < 3) {\\n           return n;\\n       } \\n       if(data[n] == 0) {\\n           data[n] = climbStairs(n-1) + climbStairs(n-2);\\n       }\\n       return data[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n        x = n;\\n        return util(0);\\n    }\\n    private int util(int n) {\\n        if(n == x) {\\n            return 1;\\n        }\\n        if(n > x) {\\n            return 0;\\n        }\\n        if(data[n] == 0) {\\n            data[n] = util(n+1) + util(n+2);\\n        }\\n        return data[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n       if(n < 3) {\\n           return n;\\n       } \\n       if(data[n] == 0) {\\n           data[n] = climbStairs(n-1) + climbStairs(n-2);\\n       }\\n       return data[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599466,
                "title": "python-dp-solution-with-explanation",
                "content": "This problem is actually a problem of finding Fibonacci series. But realizing the connection between those two requires some exploration first.\\n\\nThe problem statement has one restriction: you can take 1 step or 2 steps. During the actual interview, you may be asked to solve a problem with different step parameter. The solution will change accordingly but your thinking process will be pretty much the same.\\n\\n* For a stair with no steps: we can assume that we can go to the top in 1 step. (Actually this is a good thing to confirm with the interviewer)\\n* For a stair with 1 step: we can assume that we can go to the top in 1 step. \\n\\nThese two will be in the base case `dp` mapping.\\n\\n* For a stair with two steps: there are 2 ways to get to the top. (take one step at a time, or just take 2 steps)\\n* For a stair with three steps: there are 3 ways to get to the top. (take one step at a time, or take 2 steps first followed by one step, or take 1 step followed by two steps)\\n\\t* Here you should start to make an important observation: for a stair with three steps, you can think of taking a stair of 2 steps followed by a stair of 1 step **OR** you think of taking a stair of 1 step followed by a stair of 2 steps. Since addition is commutative, we are okay with thinking in just one way.\\n\\t* In fact, you can start to make this observation even with the stair with two steps. That is, you have to take a stair of 1 step followed by another stair of 1 step. But sometimes, trival cases can be more confusing so it is more convenient to start observing at stair with 3 steps.\\n\\n* For a stair with four steps: you can first get to step 3 using the solution from stair of 3 steps and then you can make one jump *OR* you get to step 2 using the solution from stair of 2 steps and then making 2 jumps from there.\\n\\t* If your interviewer changes the jump parameter to 3 or 4, this observation will help you modify the algorithm.\\n\\n``` python\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2: # Trival base cases\\n            return 1\\n        i = 2\\n        dp = {\\n\\t\\t\\t\\t  0: 1,\\n\\t\\t\\t\\t  1: 1\\n\\t\\t\\t\\t } #Base case DP table\\n        while i < n+1:\\n            dp[i] = dp[i-1] + dp[i-2]\\n            i += 1\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "``` python\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2: # Trival base cases\\n            return 1\\n        i = 2\\n        dp = {\\n\\t\\t\\t\\t  0: 1,\\n\\t\\t\\t\\t  1: 1\\n\\t\\t\\t\\t } #Base case DP table\\n        while i < n+1:\\n            dp[i] = dp[i-1] + dp[i-2]\\n            i += 1\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386129,
                "title": "solution-in-python-3-beats-90-three-lines-fibonacci",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n    \\ta, b = 1, 1\\n    \\tfor i in range(n): a, b = b, a + b\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n    \\ta, b = 1, 1\\n    \\tfor i in range(n): a, b = b, a + b\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 25477,
                "title": "o-logn-c-python-solutions-using-matrix-power",
                "content": "**Updates**: Thank StefanPochmann for posting a concise Python implementation of this `O(logn)` idea using matrix power in the first answer. \\n \\n**Note**: If you feel unwilling to read the long codes, just take the idea with you. The codes are unnecessarily long due to the inconvenient handle of matrices. \\n\\nWell, a classic and interesting problem. The recursion is simply `f(n) = f(n - 1) + f(n - 2)`, which means that we can either climb to `n - 1` and then climb `1` step or climb to `n - 2` and then climb `2` steps. So this problem is actually asking for the `n`-th Fibonacci number. However, if you code it in such a recursive way, it will meet TLE due to the large number of overlapping sub-problems. \\n \\nThere are mainly two ways to solve this problem. The first one uses the above formula in a bottom-up manner and takes `O(n)` time. [This link][1] shares the `O(n)` solution in all the supported languages of the LeetCode OJ. You may take a look at it and appreciate the appetite of each language :-)\\n \\nNow I will focus on another solution, which takes `O(logn)` time. The idea is to use the matrix power. In fact, `[f(n), f(n - 1); f(n - 1), f(n - 2)] = [1, 1; 1, 0] ^ n` for `n >= 2`. And similar to the problem **Pow(x, n)**, the power of a matrix can be computed in `O(logn)` time.\\n  \\nThe C++ and Python codes are shown below. Note that the computation of the power of the matrix `[1, 1; 1, 0]` is hard-coded. Since it is a bit trickier to handle matrix multiplications, the codes become much longer. \\n \\n----------\\n**C++**\\n \\n\\n    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n    \\t\\tif (n < 2) return n;\\n            vector<int> fibs = {1, 1, 1, 0};\\n            vector<int> ans = fibPower(fibs, n);\\n            return ans[0];\\n        }\\n    private:\\n        vector<int> matrixProd(vector<int>& l, vector<int>& r) {\\n            vector<int> ans(4, 0);\\n            ans[0] = l[0] * r[0] + l[1] * r[2];\\n            ans[1] = l[0] * r[1] + l[1] * r[3];\\n            ans[2] = l[2] * r[0] + l[3] * r[2];\\n            ans[3] = l[2] * r[1] + l[3] * r[3]; \\n            return ans;\\n        }\\n        vector<int> fibPower(vector<int>& fibs, int n){\\n    \\t\\tif (n == 1) return fibs;\\n            vector<int> half = fibPower(fibs, n / 2);\\n            vector<int> ans = matrixProd(half, half);\\n            if (n % 2 == 0) return ans;\\n            ans[1] = (ans[0] += ans[1]) - ans[1];\\n            ans[3] = (ans[2] += ans[3]) - ans[3];\\n            return ans;\\n        }\\n    };\\n\\n----------\\n**Python**\\n\\n    class Solution:\\n        # @param {integer} n\\n        # @return {integer}\\n        def climbStairs(self, n):\\n            if n  < 2:\\n                return n\\n            fibs = [1, 1, 1, 0]\\n            ans = self.fibsPower(fibs, n)\\n            return ans[0]\\n        \\n        def matrixProd(self, l, r):\\n            ans = [0] * 4\\n            ans[0] = l[0] * r[0] + l[1] * r[2]\\n            ans[1] = l[0] * r[1] + l[1] * r[3]\\n            ans[2] = l[2] * r[0] + l[3] * r[2]\\n            ans[3] = l[2] * r[1] + l[3] * r[3]\\n            return ans\\n            \\n        def fibsPower(self, fibs, n):\\n            if n == 1:\\n                return fibs\\n            half = self.fibsPower(fibs, n / 2)\\n            ans = self.matrixProd(half, half)\\n            if n % 2 == 0:\\n                return ans\\n            ans[0], ans[1], ans[2], ans[3] = ans[0] + ans[1], ans[0], ans[2] + ans[3], ans[2]\\n            return ans\\n\\n  [1]: https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n    \\t\\tif (n < 2) return n;\\n            vector<int> fibs = {1, 1, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2903478,
                "title": "python-c-it-s-fibonacci-explained-bonus-one-liners",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n****\\n\\n**Comment.** For every step, we are asked to calculate the sum of the number of ways for the previous two steps. That\\'s a Fibonacci sequence.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def climbStairs(self, n: int, a: int = 1, b: int = 0) -> int:\\n        for _ in range(n): a, b = a + b, a\\n        return a\\n```\\n\\n**C++ #1.** Explicit Fibonacci calculation.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n) \\n    {\\n        int w1 = 1, w2 = 0, tmp;\\n        for (int i = 0; i < n; ++i)\\n            tmp = w1, w1 += w2, w2 = tmp;\\n        return w1;\\n    }\\n};\\n```\\n\\n**C++ #2.** A more compact version of it.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n, int a = 1, int b = 0) \\n    {\\n        while (n--)\\n            a = a + b, b = a - b;\\n        return a;\\n    }\\n};\\n```\\n\\n**C++ #3.** Almost a one-liner with a slightly different computational scheme.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(long n, long a = 1, long b = 1) \\n    {\\n        while (n--) b = (a += b) - b;\\n        return b;\\n    }\\n};\\n```\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python #1.** One-liner: recursion with memoization.\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def climbStairs(self, n: int) -> int:\\n        return self.climbStairs(n-2) + self.climbStairs(n-1) if n > 1 else 1\\n```\\n\\n**Python #2.** One-liner: [**computation by rounding**](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        return int(((1 + sqrt(5)) / 2) ** (n+1) / sqrt(5) + 0.5)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int, a: int = 1, b: int = 0) -> int:\\n        for _ in range(n): a, b = a + b, a\\n        return a\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n) \\n    {\\n        int w1 = 1, w2 = 0, tmp;\\n        for (int i = 0; i < n; ++i)\\n            tmp = w1, w1 += w2, w2 = tmp;\\n        return w1;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n, int a = 1, int b = 0) \\n    {\\n        while (n--)\\n            a = a + b, b = a - b;\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(long n, long a = 1, long b = 1) \\n    {\\n        while (n--) b = (a += b) - b;\\n        return b;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def climbStairs(self, n: int) -> int:\\n        return self.climbStairs(n-2) + self.climbStairs(n-1) if n > 1 else 1\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        return int(((1 + sqrt(5)) / 2) ** (n+1) / sqrt(5) + 0.5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789848,
                "title": "standard-decision-the-same-as-in-fibonacci-numbers-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used the same method that in the Fibonacci numbers task. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created the basic array which contain [1, 2] (this is the resulrs of the  first 2 case when the inputs are 1 and 2). \\nThan I am adding into the array new element, which is sum from the previus two numbers. We start to add new elements from the 3rd positions (becouse we already have the first two).  \\nThe last added num will be our needed result.\\n\\nRuntime: 95ms (beats 46.99%)\\nMemory: 42.1mb (beats 18.7%)\\n\\n\\n# Complexity\\n- complexity:  O(n)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let noOfWays = [1, 2]\\n\\n    for(let i = 2; i < n; i++) {\\n        noOfWays[i] = noOfWays[i - 1] + noOfWays[i - 2]\\n    }\\n\\n    return noOfWays[n - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let noOfWays = [1, 2]\\n\\n    for(let i = 2; i < n; i++) {\\n        noOfWays[i] = noOfWays[i - 1] + noOfWays[i - 2]\\n    }\\n\\n    return noOfWays[n - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545778,
                "title": "c-dp-recursive-explained-solution",
                "content": "```\\n// please upvote if understand.\\n\\n// recursive solution \\napproach -\\nsuppose if we are at nth stair and we have only two types of move 1 & 2, \\nthen we will get result easily from the previous steps result.\\nex. for 4, we will find the result for 3 stair, In how many ways I can take 3 stair and for three we find the result for 2 stair since 1st stair is our base case that we can take only one step for 1st stair.\\nwe recursively call for n-1th stairs and n-2th stairs and we will increase ways by 1 when we reach at ground or n will become 0.\\n\\n\\nclass Solution {\\npublic:\\n    void solve(int n, int &ans){\\n        if(n == 0){\\n            ans += 1;\\n        }\\n        if(n < 0) return ;\\n        solve(n-1, ans);\\n        solve(n-2, ans);\\n    }\\n    int climbStairs(int n) {\\n        int ans = 0;\\n        solve(n, ans);\\n        return ans;\\n    }\\n};\\n\\n\\nDP solution - \\nif we break our recursive solution then previous two stairs ways summation will become our result.\\nbecause we can reach n th stair with possibly two moves either from n-1th stair or from n-2th stair, then using memoization we will use bottom up approach to find our result.\\nfor, n = 7\\nfirst two stair will be our base case \\nn = 1, only single way\\nn = 2, we have only two ways either take 1 1 step or single step of 2 steps.\\n\\n1  2  3  5  8  13  21\\nfor 7th stair we will watch in how many ways i have taken 6 stairs and 5th stair.\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2){\\n            return n;\\n        }\\n        vector<int> v;\\n        v.push_back(1);\\n        v.push_back(2);\\n        for(int i = 2; i<n; i++){\\n            int num = v[i-1]+v[i-2];\\n            v.push_back(num);\\n        }\\n        return v.back();\\n    }\\n};\\n\\n// please upvote if understand.\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void solve(int n, int &ans){\\n        if(n == 0){\\n            ans += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1799067,
                "title": "dp-based-c-solution-100-faster-with-0-ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int climb(int dp[],int n)\\n    {\\n        \\n        \\n        if(n==0 || n==1 || n==2)\\n         return n;\\n        if(dp[n]>0)\\n            return dp[n];\\n       int output = climb(dp,n-1)+climb(dp,n-2);\\n        dp[n]=output;\\n        return output;\\n        \\n    }\\n    \\n    int climbStairs(int n) {\\n          if(n==0 || n==1 || n==2)\\n            return n;\\n     int *dp = new int[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=0;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n     int x=climb(dp,n);\\n        delete [] dp;\\n        return x;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```\\n***If you like solution, then please upvote it.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int climb(int dp[],int n)\\n    {\\n        \\n        \\n        if(n==0 || n==1 || n==2)\\n         return n;\\n        if(dp[n]>0)\\n            return dp[n];\\n       int output = climb(dp,n-1)+climb(dp,n-2);\\n        dp[n]=output;\\n        return output;\\n        \\n    }\\n    \\n    int climbStairs(int n) {\\n          if(n==0 || n==1 || n==2)\\n            return n;\\n     int *dp = new int[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=0;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n     int x=climb(dp,n);\\n        delete [] dp;\\n        return x;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329446,
                "title": "solution-swift-climbing-stairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func climbStairs(_ n: Int) -> Int {\\n        var zero = 1, one = 1, step = 2\\n        while step <= n {\\n            let temp = zero + one\\n            zero = one\\n            one = temp\\n            step += 1\\n        }\\n        return one\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two ways to climb to the top.\\n    /// 1. 1 step + 1 step\\n    /// 2. 2 steps\\n    func test0() {\\n        let value = solution.climbStairs(2)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// There are three ways to climb to the top.\\n    /// 1. 1 step + 1 step + 1 step\\n    /// 2. 1 step + 2 steps\\n    /// 3. 2 steps + 1 step\\n    func test1() {\\n        let value = solution.climbStairs(3)\\n        XCTAssertEqual(value, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func climbStairs(_ n: Int) -> Int {\\n        var zero = 1, one = 1, step = 2\\n        while step <= n {\\n            let temp = zero + one\\n            zero = one\\n            one = temp\\n            step += 1\\n        }\\n        return one\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two ways to climb to the top.\\n    /// 1. 1 step + 1 step\\n    /// 2. 2 steps\\n    func test0() {\\n        let value = solution.climbStairs(2)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// There are three ways to climb to the top.\\n    /// 1. 1 step + 1 step + 1 step\\n    /// 2. 1 step + 2 steps\\n    /// 3. 2 steps + 1 step\\n    func test1() {\\n        let value = solution.climbStairs(3)\\n        XCTAssertEqual(value, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861070,
                "title": "progression-of-python-solutions",
                "content": "Approach 1: Naive backtracking\\nintuition: to calculate how many ways to reach nth step, we add up how many ways to reach (n-1)th and (n-2)th step, since from (n-1)th step we take a 1-step to get to nth and similarly from (n-2)th step. \\n\\nN = the input\\ntime: recursion tree of depth N, branching factor of 2, runtime is recursion trees is typically O(branching_factor^depth), plugging in we get O(2^N) as our upper bound for runtime. \\nspace: O(N), b/c of depth of recursion stack \\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Naive backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\\n\\nApproach 2: top down memoization\\nintuition: if we draw out the recursion tree we see a lot of repeated work. we are able to see this repeated work because nodes with the same parameters mean that the exact same subproblem is getting recomputed. Drawing out the recursion tree, we see many nodes with the same parameters:\\n\\n![image](https://assets.leetcode.com/users/images/f4e6230d-b0ce-4b07-ac35-6e29feeaeab7_1600885828.9303908.png)\\n\\nthis repeated work is a strong indicator that caching can help us here. We make use of python\\'s lru_cache to do caching for us here, based on what arguments are passed into the function. if we want to avoid usage of python\\'s lru cache, we can just as easily mimic this functionality using a dictionary (shown in approach 3).\\n\\n```\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n        \\n```\\n\\nApproach 3: top down memoization (without lru cache)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        \\n        cache={}\\n        def helper(n):\\n            if n in cache: return cache[n]\\n            if n == 0 or n == 1: return 1\\n            cache[n] = helper(n-1) + helper(n-2)\\n            return cache[n]\\n        \\n        return helper(n)\\n```\\n\\nAnalysis for approach 2 and 3:\\nN=input\\ntime: O(N). we get O(N) time complexity because each subproblem is only solved once, and then the subresult is cached for future use if we need it again. So analyzing time complexity here boils down to how many subproblems are there? Since our input is N, we have N subproblems (1, 2, ..., N-1, N). For analyzing time complexity of these types of problems, it is best to think in terms of what parameters define the subproblems, and use that intuition to figure out how many unique subproblems there are (how many unique parameter sets there are, since parameters define the subproblems).\\nspace: O(N). Space is O(N) because the recursion tree can still hit a depth of O(N) (1-step each time), and also the cache stores O(N) subproblems, so we get a total space complexity of O(N).\\n\\nApproach 4: Dynamic programming (not optimized)\\nintuition:\\n- from thinking about the top down solution, it is clear that in order to get the solution for climbStairs(i), we need the solutions for climbStairs(i-1) and climbStairs(i-2). At first we look at this top down in terms of the recursion tree, but we can instead flip our viewpoint and go from the bottom up. Since we know that at any point i, we need the subproblems for i-1 and i-2, let\\'s just go ahead and calculate the subproblems in order from bottom to top. So we start with the base cases and we build to the solution, instead of starting with the solution we want and figuring out which subproblems we need to solve. \\n\\nanalysis:\\ntime: O(N)\\nspace: O(N)\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Dynamic programming solution\\n        \\'\\'\\'\\n        stepsToReachIthPosn=[1] * (n+1)\\n        for i in range(2, n+1):\\n            stepsToReachIthPosn[i] = stepsToReachIthPosn[i-1]+stepsToReachIthPosn[i-2]\\n        return stepsToReachIthPosn[n]\\n```\\nApproach 5: optimized dynamic programming solution\\nintuition:\\n- notice that in our dp solution, we only require the subproblems of i-1 and i-2 in order to solve for ith subproblem. So why waste space and store the whole array when instead we could just store i-1th answer and i-2th answer? and then we just update correspondingly\\n\\ntime: O(N)\\nspace: O(1)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Optimized dynamic programming solution\\n        \\'\\'\\'\\n        oneBack=1\\n        twoBack=1\\n        if n <= 1: return 1\\n        for i in range(2, n+1):\\n            cur=oneBack+twoBack\\n            twoBack=oneBack\\n            oneBack=cur\\n        return oneBack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Naive backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\n```\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n        \\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        \\n        cache={}\\n        def helper(n):\\n            if n in cache: return cache[n]\\n            if n == 0 or n == 1: return 1\\n            cache[n] = helper(n-1) + helper(n-2)\\n            return cache[n]\\n        \\n        return helper(n)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Dynamic programming solution\\n        \\'\\'\\'\\n        stepsToReachIthPosn=[1] * (n+1)\\n        for i in range(2, n+1):\\n            stepsToReachIthPosn[i] = stepsToReachIthPosn[i-1]+stepsToReachIthPosn[i-2]\\n        return stepsToReachIthPosn[n]\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Optimized dynamic programming solution\\n        \\'\\'\\'\\n        oneBack=1\\n        twoBack=1\\n        if n <= 1: return 1\\n        for i in range(2, n+1):\\n            cur=oneBack+twoBack\\n            twoBack=oneBack\\n            oneBack=cur\\n        return oneBack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25643,
                "title": "o-log-n-solution-with-matrix-multiplication",
                "content": "\\nI saw most solutions posted in discussion are DP with runtime O(n) and O(1) space which is accepted by OJ.\\n\\nThe only O(log(n)) solution so far is **lucastan's** using Binet's formula.\\n\\nThere actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).\\n\\n\\n\\n\\n\\n        public int climbStairs1(int n) {\\n        int[][] a = {{0, 1}, {1, 1}};\\n        int[][] m = pow(a, n - 1);\\n        return m[0][1] + m[1][1];\\n    }\\n\\n    private int[][] pow(int[][] a, int n) {\\n        int[][] ret = {{1, 0}, {0, 1}};\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ret = multiply(ret, a);\\n            }\\n            n >>= 1;\\n            a = multiply(a, a);\\n        }\\n        return ret;\\n    }\\n\\n    private int[][] multiply(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "\\nI saw most solutions posted in discussion are DP with runtime O(n) and O(1) space which is accepted by OJ.\\n\\nThe only O(log(n)) solution so far is **lucastan's** using Binet's formula.\\n\\nThere actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).\\n\\n\\n\\n\\n\\n        public int climbStairs1(int n) {\\n        int[][] a = {{0, 1}, {1, 1}};\\n        int[][] m = pow(a, n - 1);\\n        return m[0][1] + m[1][1];\\n    }\\n\\n    private int[][] pow(int[][] a, int n) {\\n        int[][] ret = {{1, 0}, {0, 1}};\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ret = multiply(ret, a);\\n            }\\n            n >>= 1;\\n            a = multiply(a, a);\\n        }\\n        return ret;\\n    }\\n\\n    private int[][] multiply(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2853027,
                "title": "70-climbing-stairs-three-solutions",
                "content": "All the 3 solutions listed \\nIf you find my Solutions helpful then An upvote would be an O(N) Decision :)\\n\\n1. recursive sol \\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\n if(n==0) // at 0 do nothing yes that\\'s also a step:)\\nreturn 1;\\nif(n==1) // when we are taking two steps back then from 2 to 0 is 1 way only \\nreturn 1;\\n return climbStairs(n-1) +climbStairs( n-2);   \\n }\\n}\\n```\\n\\n2. now tabulation\\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\nif (n <= 1) {\\n return 1;\\n  }\\nint dp[]=new int [n+1];\\ndp[1]=1;\\ndp[2]=2;\\nfor(int i=3;i<=n;i++) {\\n   dp[i]=dp[i-1] + dp[i-2];\\n}\\nreturn dp[n];\\n}\\n}\\n\\n```\\n\\n3.memoization \\n```\\nclass Solution {\\n public int climbStairs(int n) {\\n     return memoDp(new int [n+1],n);\\n }\\n    int memoDp(int dp[],int n){ \\n        if(n==0 || n==1)\\n           return 1; \\n        if (dp[n]!=0)\\n            return dp[n];\\n        int step=memoDp(dp,n-1) +memoDp(dp,n-2);\\n        dp[n]=step;\\n        return dp[n];\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic int climbStairs(int n) {\\n if(n==0) // at 0 do nothing yes that\\'s also a step:)\\nreturn 1;\\nif(n==1) // when we are taking two steps back then from 2 to 0 is 1 way only \\nreturn 1;\\n return climbStairs(n-1) +climbStairs( n-2);   \\n }\\n}\\n```\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\nif (n <= 1) {\\n return 1;\\n  }\\nint dp[]=new int [n+1];\\ndp[1]=1;\\ndp[2]=2;\\nfor(int i=3;i<=n;i++) {\\n   dp[i]=dp[i-1] + dp[i-2];\\n}\\nreturn dp[n];\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935980,
                "title": "javascript-all-approaches",
                "content": "```javascript\\n// recursive\\nvar climbStairs = function(n) {\\n   if (n <= 2) return n;\\n    return climbStairs(n - 2) + climbStairs(n - 1);\\n};\\n\\n// recursive top down (memoization)\\nconst climbStairs = (n) => {\\n    const memo = new Map();\\n    \\n    return climbStairsMemo(n, memo);\\n};\\n\\nconst climbStairsMemo = (n, memo) => {\\n    if(n <= 2) return n;\\n    if(!memo.has(n)) {\\n        memo.set(n, climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo))\\n    }\\n    \\n    return memo.get(n);\\n};\\n\\n// iterative bottom-up\\nconst climbStairs = (n) => {\\n    const memo = new Array(n + 1).fill(0);\\n    memo[0] = 0;\\n    memo[1] = 1;\\n    memo[2] = 2;\\n    for(let i = 3; i <= n; i++) {\\n        memo[i] = memo[i -1] + memo[i - 2];\\n    }\\n    \\n    return memo[n];\\n};\\n\\n// iterative space-saver\\nconst climbStairs = (n) => {\\n    if(n <= 2) return n;\\n    \\n    let prev2 = 1;\\n    let prev1 = 2;\\n    let curr = 0;\\n    for(let i = 3; i <= n; i++) {\\n        curr = prev2 + prev1;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    \\n    return curr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```javascript\\n// recursive\\nvar climbStairs = function(n) {\\n   if (n <= 2) return n;\\n    return climbStairs(n - 2) + climbStairs(n - 1);\\n};\\n\\n// recursive top down (memoization)\\nconst climbStairs = (n) => {\\n    const memo = new Map();\\n    \\n    return climbStairsMemo(n, memo);\\n};\\n\\nconst climbStairsMemo = (n, memo) => {\\n    if(n <= 2) return n;\\n    if(!memo.has(n)) {\\n        memo.set(n, climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo))\\n    }\\n    \\n    return memo.get(n);\\n};\\n\\n// iterative bottom-up\\nconst climbStairs = (n) => {\\n    const memo = new Array(n + 1).fill(0);\\n    memo[0] = 0;\\n    memo[1] = 1;\\n    memo[2] = 2;\\n    for(let i = 3; i <= n; i++) {\\n        memo[i] = memo[i -1] + memo[i - 2];\\n    }\\n    \\n    return memo[n];\\n};\\n\\n// iterative space-saver\\nconst climbStairs = (n) => {\\n    if(n <= 2) return n;\\n    \\n    let prev2 = 1;\\n    let prev1 = 2;\\n    let curr = 0;\\n    for(let i = 3; i <= n; i++) {\\n        curr = prev2 + prev1;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    \\n    return curr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910653,
                "title": "java-dynamic-programming-solution-memoization-with-explanation",
                "content": "If n= 0 the answer is = 0\\nIf n= 1 the answer is = 1\\nIf n= 2 the answer is = 2\\nIf n= 3 the answer is = (n-1) + (n-2)\\nand so on\\n\\nIn every n we store we store the answer into memo array.\\n\\nIf we consider n = 5 then \\n![image](https://assets.leetcode.com/users/images/e2034166-f069-4973-ac7a-a0efa6f5923e_1648992757.1789904.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\n    int[] memo;\\n    public int climbStairs(int n) {\\n        memo = new int[n+1];\\n        for(int i =0;i<=n;i++) memo[i] = -1;\\n        return climbStairsRec(n);\\n    }\\n    \\n    public int climbStairsRec(int n){\\n        if(memo[n]==-1){\\n            int r;\\n            if(n==0 || n==1 || n==2) r = n;\\n            else{\\n                r = climbStairsRec(n-1) + climbStairsRec(n-2);\\n            }\\n            memo[n] = r;\\n        }\\n        return memo[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[] memo;\\n    public int climbStairs(int n) {\\n        memo = new int[n+1];\\n        for(int i =0;i<=n;i++) memo[i] = -1;\\n        return climbStairsRec(n);\\n    }\\n    \\n    public int climbStairsRec(int n){\\n        if(memo[n]==-1){\\n            int r;\\n            if(n==0 || n==1 || n==2) r = n;\\n            else{\\n                r = climbStairsRec(n-1) + climbStairsRec(n-2);\\n            }\\n            memo[n] = r;\\n        }\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668980,
                "title": "this-is-nothing-but-fibonacci-only-2-approachs",
                "content": "Approach 1 : **Memoization**\\n\\n```\\nclass Solution {\\npublic:\\n    int step(int n,vector<int>&dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n] != -1)return dp[n];\\n        if(n>=2){\\n            return dp[n] = step(n-1,dp)+step(n-2,dp);\\n        }\\n            return dp[n] = step(n-1,dp)+0;\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        step(n,dp);\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Tc : O(N) Sc:O(N)**\\n\\n**Optimization**\\n*we can reduce the space complexity*\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)return 1;\\n        else if(n==2)return 2;\\n        int ans = 0;\\n        int a = 1,b = 2;\\n        for(int i=3;i<=n;i++){\\n            ans = a+b;\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Sc : O(1)**\\n\\n*If you like the post then please upvote it keeps me motivating \\uD83D\\uDE01\\uD83C\\uDF88*\\n**:) happy coding**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int step(int n,vector<int>&dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n] != -1)return dp[n];\\n        if(n>=2){\\n            return dp[n] = step(n-1,dp)+step(n-2,dp);\\n        }\\n            return dp[n] = step(n-1,dp)+0;\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        step(n,dp);\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)return 1;\\n        else if(n==2)return 2;\\n        int ans = 0;\\n        int a = 1,b = 2;\\n        for(int i=3;i<=n;i++){\\n            ans = a+b;\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998650,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2: return n\\n        c1, c2, c3 = 0, 1, 2\\n        while n > 2:\\n            c1, c2 = c2, c3\\n            c3 = c1 + c2\\n            n -= 1\\n        return c3\\n```\\nfor more questions: https://github.com/vanigupta20024/Programming-Challenges/tree/master",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2: return n\\n        c1, c2, c3 = 0, 1, 2\\n        while n > 2:\\n            c1, c2 = c2, c3\\n            c3 = c1 + c2\\n            n -= 1\\n        return c3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628462,
                "title": "python-js-java-go-c-o-n-dp-fibonacci-w-hint",
                "content": "Python/JS/Go/C++ O(n) DP // Fibonacci\\n\\n[My tutorial with DP problem solving framework to climbing stairs in English](https://medium.com/@cutesciuridae/dive-into-dp-take-climbing-stairs-for-example-4e3c1344e73c)\\n\\n[My tutorial with DP problem solving framework to climbing stairs in Chinese](https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5climbing-stairs-%E7%82%BA%E4%BE%8B-45716ab7f555)\\n\\n[My tutorial with DP solution to climbing stairs in Chinese \\u4E2D\\u6587\\u5F71\\u7247\\u8B1B\\u89E3](https://youtu.be/SUeaLvIOScY)\\n\\n---\\n\\n**Abstract model & visualization**\\n\\n<img src=\"https://assets.leetcode.com/users/images/90e639e3-0c19-478d-acca-79c11eb77c0b_1641029846.7747073.png\" width=\"600\" height=\"400\" border=\"10\"/>\\n\\n\\n---\\n\\n**Hint**:\\n\\nThink of **fibanacci series** and **recursion**.\\n\\nClimbing Stairs can be described as following:\\n\\n**Method to level n** = **Method to level (n-1)** + **Method to level (n-2)**\\n\\nIt\\'s the same as the one of Fibonacci series\\n\\nf( n ) = f( n - 1 ) + f( n - 2 ) \\n\\nwith f( 0 ) = 1 and f( 1 ) = 1\\n\\n---\\n\\n```\\n# Base case, aka stop condition:\\n\\ndp(0) = 1\\ndp(1) = 1\\n```\\n\\n---\\n\\n```\\n# General cases:\\n\\ndp(n) = dp( n-1 ) + dp( n-2 ) for n >= 2\\n```\\n\\n---\\n\\n**Implementation** by top-down DP in Python\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        \\n        self.cache = {}\\n    \\n    def climbStairs(self, n: int) -> int:    \\n        \\n        if n in self.cache:\\n            return self.cache[n]\\n        \\n        if n == 0 or n == 1:\\n            return 1\\n        \\n        else:\\n            result = self.climbStairs(n-1) + self.climbStairs(n-2)\\n            self.cache[n] = result\\n            return result\\n```\\n\\n---\\n\\nShare similar implementation with python built-in decorator\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution:\\n\\n    def climbStairs(self, n: int) -> int:\\n    \\n        #--------------------------\\n        @cache\\n        def dp(i):\\n            \\n            # base case\\n            if i == 0 or i == 1:\\n                return 1\\n            \\n            # general cases\\n            return dp(i-1) + dp(i-2)\\n        \\n        # -------------------------\\n        return dp(n)\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **Java**:\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution {\\n\\n    public Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo.put(0, 1);   // reach floor_0 by doing nothing\\n        climbMethodTo.put(1, 1);   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo.containsKey( n ) ){\\n            return climbMethodTo.get(n);\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo.put(n, climbStairs(n-1) + climbStairs(n-2) );\\n        \\n        return climbMethodTo.get(n);\\n    }\\n    \\n\\n    private HashMap<Integer, Integer> climbMethodTo = new HashMap<Integer, Integer>();\\n}\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **JavaScript**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nvar climbStairs = function(n) {\\n  \\n    // create array of length n+1\\n    var memo = new Array(n+1);\\n    \\n    // Initialization on base case\\n    memo[0] = 1;\\n    memo[1] = 1;\\n    \\n    var climb = function( i ){\\n        \\n        if( i <= 1 ){\\n            // base case\\n            return memo[i];\\n            \\n        }else if( memo[i] != undefined ) {\\n            // climb(i) has been computed before, directly look-up memo\\n            return memo[i];\\n        }\\n        else{\\n            // general cases:\\n            memo[i] = (climb(i-1) + climb(i-2));\\n            return memo[i];\\n        }\\n    }\\n    \\n    return climb(n);\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **Go**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nfunc climbStairs(n int) int {\\n    \\n    // key: stair i\\n    // value: method count of climbing to stair i\\n    memo := make(map[int]int)\\n    \\n    // initialization on base case\\n    memo[0] = 1\\n    memo[1] = 1\\n    \\n    // define inenr function: climb\\n    var climb func(int)int \\n    climb = func(i int)int{\\n        \\n        if i <= 1 {\\n            // base case\\n            return memo[i]\\n            \\n        }else if val, exist := memo[i]; exist{\\n            \\n            // climb(i) has been computed before, directly look-up memo\\n            return val\\n            \\n        }else{\\n            // general cases\\n            memo[i] = climb(i-1) + climb(i-2)\\n            return memo[i]\\n        }\\n        \\n    }\\n    \\n    return climb( n )\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **C++**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo[0] = 1;   // reach floor_0 by doing nothing\\n        climbMethodTo[1] = 1;   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo[n] ){\\n            return climbMethodTo[n];\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo[n] = climbStairs(n-1) + climbStairs(n-2);\\n        \\n        return climbMethodTo[n];\\n    }\\n    \\nprivate:\\n    map<int, int> climbMethodTo;\\n};\\n```\\n\\n</details>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\n# Base case, aka stop condition:\\n\\ndp(0) = 1\\ndp(1) = 1\\n```\n```\\n# General cases:\\n\\ndp(n) = dp( n-1 ) + dp( n-2 ) for n >= 2\\n```\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        \\n        self.cache = {}\\n    \\n    def climbStairs(self, n: int) -> int:    \\n        \\n        if n in self.cache:\\n            return self.cache[n]\\n        \\n        if n == 0 or n == 1:\\n            return 1\\n        \\n        else:\\n            result = self.climbStairs(n-1) + self.climbStairs(n-2)\\n            self.cache[n] = result\\n            return result\\n```\n```\\nclass Solution:\\n\\n    def climbStairs(self, n: int) -> int:\\n    \\n        #--------------------------\\n        @cache\\n        def dp(i):\\n            \\n            # base case\\n            if i == 0 or i == 1:\\n                return 1\\n            \\n            # general cases\\n            return dp(i-1) + dp(i-2)\\n        \\n        # -------------------------\\n        return dp(n)\\n```\n```\\nclass Solution {\\n\\n    public Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo.put(0, 1);   // reach floor_0 by doing nothing\\n        climbMethodTo.put(1, 1);   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo.containsKey( n ) ){\\n            return climbMethodTo.get(n);\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo.put(n, climbStairs(n-1) + climbStairs(n-2) );\\n        \\n        return climbMethodTo.get(n);\\n    }\\n    \\n\\n    private HashMap<Integer, Integer> climbMethodTo = new HashMap<Integer, Integer>();\\n}\\n```\n```\\nvar climbStairs = function(n) {\\n  \\n    // create array of length n+1\\n    var memo = new Array(n+1);\\n    \\n    // Initialization on base case\\n    memo[0] = 1;\\n    memo[1] = 1;\\n    \\n    var climb = function( i ){\\n        \\n        if( i <= 1 ){\\n            // base case\\n            return memo[i];\\n            \\n        }else if( memo[i] != undefined ) {\\n            // climb(i) has been computed before, directly look-up memo\\n            return memo[i];\\n        }\\n        else{\\n            // general cases:\\n            memo[i] = (climb(i-1) + climb(i-2));\\n            return memo[i];\\n        }\\n    }\\n    \\n    return climb(n);\\n```\n```\\nfunc climbStairs(n int) int {\\n    \\n    // key: stair i\\n    // value: method count of climbing to stair i\\n    memo := make(map[int]int)\\n    \\n    // initialization on base case\\n    memo[0] = 1\\n    memo[1] = 1\\n    \\n    // define inenr function: climb\\n    var climb func(int)int \\n    climb = func(i int)int{\\n        \\n        if i <= 1 {\\n            // base case\\n            return memo[i]\\n            \\n        }else if val, exist := memo[i]; exist{\\n            \\n            // climb(i) has been computed before, directly look-up memo\\n            return val\\n            \\n        }else{\\n            // general cases\\n            memo[i] = climb(i-1) + climb(i-2)\\n            return memo[i]\\n        }\\n        \\n    }\\n    \\n    return climb( n )\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo[0] = 1;   // reach floor_0 by doing nothing\\n        climbMethodTo[1] = 1;   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo[n] ){\\n            return climbMethodTo[n];\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo[n] = climbStairs(n-1) + climbStairs(n-2);\\n        \\n        return climbMethodTo[n];\\n    }\\n    \\nprivate:\\n    map<int, int> climbMethodTo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207575,
                "title": "javascript-top-down-bottom-up-5-different-solutions-3-faster-than-100-o-n",
                "content": "recursive solution - stepping down\\n*** this unfortunately times out ***\\n```\\nconst climbStairs  = n => {\\n    if (n <= 3) return n;\\n    return climbStairs(n-1) + climbStairs(n-2);\\n}\\n```\\n\\n\\nrecursive solution with memoization - stepping down\\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(n, cache);\\n};\\n\\nconst climb = (n, cache) => {\\n    if (n in cache) {\\n        return cache[n];\\n    } else {\\n        if (n <= 3) return n;\\n        else {\\n            cache[n] = climb(n-1, cache) + climb(n-2, cache);\\n            return cache[n];\\n        }\\n    }\\n};\\n```\\n\\n\\niterative solution - stepping up\\n```\\nconst climbStairs = n => {\\n    // we know that 3 steps returns 3\\n    if (n <= 3) return n;\\n    let arr = [1,2,3];\\n    for (let i = 3; i < n; i++) {\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr.pop();\\n}\\n```\\n\\nrecursive solution - stepping up\\n*** this unfortunately times out ***\\n```\\nconst climbStairs = n => {\\n    return climb(0, n);\\n}\\n    \\nconst climb = (step, destination) => {\\n    if (step > destination) return 0;\\n    if (step === destination) return 1;\\n    return climb(step+1, destination) + climb(step+2, destination);\\n};\\n```\\n\\n\\nrecursive solution with memoization - stepping up\\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(0, n, cache);\\n};\\n\\nconst climb = (step, destination, cache) => {\\n    if (step in cache) {\\n        return cache[step];\\n    } else {\\n        if (step > destination) return 0;\\n        if (step === destination) return 1;\\n        else {\\n            cache[step] = \\n                climb(step+1, destination, cache) + \\n                climb(step+2, destination, cache);\\n            return cache[step];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst climbStairs  = n => {\\n    if (n <= 3) return n;\\n    return climbStairs(n-1) + climbStairs(n-2);\\n}\\n```\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(n, cache);\\n};\\n\\nconst climb = (n, cache) => {\\n    if (n in cache) {\\n        return cache[n];\\n    } else {\\n        if (n <= 3) return n;\\n        else {\\n            cache[n] = climb(n-1, cache) + climb(n-2, cache);\\n            return cache[n];\\n        }\\n    }\\n};\\n```\n```\\nconst climbStairs = n => {\\n    // we know that 3 steps returns 3\\n    if (n <= 3) return n;\\n    let arr = [1,2,3];\\n    for (let i = 3; i < n; i++) {\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr.pop();\\n}\\n```\n```\\nconst climbStairs = n => {\\n    return climb(0, n);\\n}\\n    \\nconst climb = (step, destination) => {\\n    if (step > destination) return 0;\\n    if (step === destination) return 1;\\n    return climb(step+1, destination) + climb(step+2, destination);\\n};\\n```\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(0, n, cache);\\n};\\n\\nconst climb = (step, destination, cache) => {\\n    if (step in cache) {\\n        return cache[step];\\n    } else {\\n        if (step > destination) return 0;\\n        if (step === destination) return 1;\\n        else {\\n            cache[step] = \\n                climb(step+1, destination, cache) + \\n                climb(step+2, destination, cache);\\n            return cache[step];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25292,
                "title": "python-solution-in-one-line",
                "content": "Since we know that the answer should be Fibonacci Number, we can directly calculate the Fibonacci Number with mathematical expressions.\\n```\\nreturn int(round(1/5**0.5 * (((1+5**0.5)/2.0)**(n+1) - ((1-5**0.5)/2.0)**(n+1))))\\n```\\nDone.^^",
                "solutionTags": [],
                "code": "```\\nreturn int(round(1/5**0.5 * (((1+5**0.5)/2.0)**(n+1) - ((1-5**0.5)/2.0)**(n+1))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25481,
                "title": "1ms-java-solution-easy-to-understand-with-dp",
                "content": "public class Solution {\\n    \\n    int result;\\n    HashMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n    \\n    public int climbStairs(int n) {\\n        if(n < 2) {\\n            return 1;\\n        }\\n        if(memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        result = climbStairs(n-1) + climbStairs(n-2);\\n        memo.put(n,result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    int result;\\n    HashMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n    \\n    public int climbStairs(int n) {\\n        if(n < 2) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 25560,
                "title": "1-liner-formula",
                "content": "I didn't see anyone using [this formula](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding) yet, so here it is (in Python).\\n\\n    def climbStairs(self, n):\\n        return int(((1 + 5**.5) / 2) ** -~n / 5**.5 + .5)\\n\\n(No, I would not be able to recall that formula in an interview. There I would do [my normal solution](https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language) or maybe the [matrix solution](https://leetcode.com/discuss/45797/o-logn-c-python-solutions-using-matrix-power?show=46059#a46059), which is not that hard to remember)\\n\\nIf you're wondering about `-~n`, that's just short for `(n+1)`. Apparently I was in golfing mode.",
                "solutionTags": [
                    "Python"
                ],
                "code": "I didn't see anyone using [this formula](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding) yet, so here it is (in Python).\\n\\n    def climbStairs(self, n):\\n        return int(((1 + 5**.5) / 2) ** -~n / 5**.5 + .5)\\n\\n(No, I would not be able to recall that formula in an interview. There I would do [my normal solution](https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language) or maybe the [matrix solution](https://leetcode.com/discuss/45797/o-logn-c-python-solutions-using-matrix-power?show=46059#a46059), which is not that hard to remember)\\n\\nIf you're wondering about `-~n`, that's just short for `(n+1)`. Apparently I was in golfing mode.",
                "codeTag": "Python3"
            },
            {
                "id": 25549,
                "title": "simplest-answer-in-c",
                "content": "    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        for (int i = 1;i < n;i++) {\\n            b += a;\\n            a = b - a;\\n        }\\n        return b;\\n    }",
                "solutionTags": [],
                "code": "    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        for (int i = 1;i < n;i++) {\\n            b += a;\\n            a = b - a;\\n        }\\n        return b;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3418402,
                "title": "beats-100-easiest-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n            n+=2;\\n            int fib[n];\\n            fib[0]=0;fib[1]=1;\\n\\n            for(int i=2;i<n;i++){\\n                fib[i]=fib[i-1]+fib[i-2];\\n            }\\n            \\n            return fib[n-1];\\n    }\\n};\\nDO UPVOTE if you Like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n            n+=2;\\n            int fib[n];\\n            fib[0]=0;fib[1]=1;\\n\\n            for(int i=2;i<n;i++){\\n                fib[i]=fib[i-1]+fib[i-2];\\n            }\\n            \\n            return fib[n-1];\\n    }\\n};\\nDO UPVOTE if you Like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051988,
                "title": "super-fast-0ms-beat-100-and-super-small-space-complexity-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nList the all possible ways for the step from 1 to 6;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can see that for the step 1 stair --one way;the step 2 stairs, there are 2ways;step 3, 3ways; step 4, 5ways; step 5, 8ways; and step 6, 13ways.\\n\\nWhat do u find?\\n\\n1, 2, 3, 5, 8, 13......\\n\\nIt is the Fibonacci sequence!\\nAnd , the answer is easy...\\n\\n\\nThe first attempt i use recursive, unfortunately, it waste a lot of time!!\\n\\nWe only need 3 ints, which are first, second, and third.\\nAnd just use the nature of Fibonacci, the third number equals the sum of the first and the second number. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n<2)\\n        return 1;\\n        int first=1;\\n        int second=1;\\n        int third=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            third=first+second;\\n            first=second;\\n            second=third;\\n        }\\n        return third;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n<2)\\n        return 1;\\n        int first=1;\\n        int second=1;\\n        int third=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            third=first+second;\\n            first=second;\\n            second=third;\\n        }\\n        return third;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354896,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n        if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n        // Create an array to store the answer...\\n        int[] ans = new int[n];\\n        for(int i=1;i<=n;i++) {\\n            if(i==1) {\\n                ans[0]=1;\\n            }\\n            if(i==2) {\\n                ans[1]=2;\\n            }\\n            // There are two options...\\n            // 1.we came from (i-1)th step\\n            // 2.we came from (i-2)th step\\n            if(i>2) {\\n                ans[i-1] = ans[i-2] + ans[i-3];\\n            }\\n        }\\n        return ans[n-1];    // Return the answer...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int pre = 1;\\n        int curr = 1;\\n        int temp = 0;\\n        for (int i = 1; i < n; i++) {\\n            temp = curr;\\n            curr = curr + pre;\\n            pre = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar climbStairs = function(n) {\\n    if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n    if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n    // Create an array to store the answer...\\n    let ans = [n];\\n    for(let i=1;i<=n;i++) {\\n        if(i==1) {\\n            ans[0]=1;\\n        }\\n        if(i==2) {\\n            ans[1]=2;\\n        }\\n        // There are two options when we reach ith step:\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        if(i>2) {\\n            ans[i-1] = ans[i-2] + ans[i-3];\\n        }\\n    }\\n    return ans[n-1];    // Return the answer...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n        if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n        // Create an array to store the answer...\\n        int[] ans = new int[n];\\n        for(int i=1;i<=n;i++) {\\n            if(i==1) {\\n                ans[0]=1;\\n            }\\n            if(i==2) {\\n                ans[1]=2;\\n            }\\n            // There are two options...\\n            // 1.we came from (i-1)th step\\n            // 2.we came from (i-2)th step\\n            if(i>2) {\\n                ans[i-1] = ans[i-2] + ans[i-3];\\n            }\\n        }\\n        return ans[n-1];    // Return the answer...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int pre = 1;\\n        int curr = 1;\\n        int temp = 0;\\n        for (int i = 1; i < n; i++) {\\n            temp = curr;\\n            curr = curr + pre;\\n            pre = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\n```\\nvar climbStairs = function(n) {\\n    if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n    if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n    // Create an array to store the answer...\\n    let ans = [n];\\n    for(let i=1;i<=n;i++) {\\n        if(i==1) {\\n            ans[0]=1;\\n        }\\n        if(i==2) {\\n            ans[1]=2;\\n        }\\n        // There are two options when we reach ith step:\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        if(i>2) {\\n            ans[i-1] = ans[i-2] + ans[i-3];\\n        }\\n    }\\n    return ans[n-1];    // Return the answer...\\n};\\n```\n```\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275058,
                "title": "c-representation-solution-with-comments-space-optimisation",
                "content": "***\\n***Please Upvote if it Helps......***\\n***\\n***\\n***Solution :***\\n***\\n***How to Identify a DP problem?***\\n\\nWhen we see a problem, it is very important to identify it as a dynamic programming problem. Generally (but not limited to) if the problem statement asks for the following:\\n\\n* Count the total number of ways\\n* Given multiple ways of doing a task, which way will give the minimum or the maximum output.\\n\\nWe can try to apply recursion. Once we get the recursive solution, we can go ahead to convert it to a dynamic programming one.\\n***\\n***Steps To Solve The Problem After Identification***\\n***\\nOnce the problem has been identified, the following three steps comes handy in solving the problem:\\n\\n* Try to represent the problem in terms of indexes.\\n* Try all possible choices/ways at every index according to the problem statement.\\n* If the question states\\n    * Count all the ways \\u2013 return sum of all choices/ways.\\n    * Find maximum/minimum- return the choice/way with maximum/minimum output.\\n***\\n***Using these steps to solve the problem \\u201CClimbing Stairs\\u201D***\\n\\nStep 1: We will assume n stairs as indexes from 0 to N.\\n![image](https://assets.leetcode.com/users/images/0e2588c0-6c6e-4fc3-9e0a-a65e3daadbdf_1657686866.9534023.png)\\n\\n\\nStep 2: At a single time, we have 2 choices: Jump one step or jump two steps. We will try both of these options at every index.\\n\\n![image](https://assets.leetcode.com/users/images/97b90fad-e603-403a-9865-df049c300187_1657686879.0325246.png)\\n\\nStep 3: As the problem statement asks to count the total number of distinct ways, we will return the sum of all the choices in our recursive function.\\n\\nThe base case will be when we want to go to the 0th stair, then we have only one option.\\n\\nThe basic pseudo-code for the problem will be given as:\\n\\n![image](https://assets.leetcode.com/users/images/9dca5aef-77eb-421f-b492-b9a24e356710_1657686889.5174844.png)\\n\\nThere will be one more edge-case when n=1, if we call f(n-2) we will reach stair numbered -1 which is not defined, therefore we add an extra test case to return 1 ( the only way) when n=1.\\n![image](https://assets.leetcode.com/users/images/6c70d64c-8a25-44f8-a201-58042f4801be_1657686900.0129309.png)\\n\\n***\\n***\\n\\n***Steps for the Tabulation approach.***\\n***\\n* Declare a dp[] array of size n+1.\\n* First initialize the base condition values, i.e i=0 and i=1 of the dp array as 1.\\n* Set an iterative loop which traverses the array( from index 2 to n) and for every index set its value as dp[i-1] + dp[i-2]. \\n***\\n***\\n***C++ Code***\\n***\\n```\\n  vector<int> dp(n+1,-1);\\n  \\n  dp[0]= 1;\\n  dp[1]= 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      dp[i] = dp[i-1]+ dp[i-2];\\n  }\\n  return dp[n];\\n  \\n```\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n**Reason:** We are running a simple iterative loop\\n\\n***Space Complexity: O(N)***\\n\\n**Reason:** We are using an external array of size \\u2018n+1\\u2019.\\n***\\n***\\n***Part 3: Space Optimization***\\n\\nIf we closely look the relation,\\n\\n***dp[i] =  dp[i-1] + dp[i-2]***\\n\\nwe see that for any i, we do need only the last two values in the array. So is there a need to maintain a whole array for it? \\n\\nThe answer is \\u2018No\\u2019. Let us call dp[i-1] as prev and dp[i-2] as prev2. Now understand the following illustration.\\n![image](https://assets.leetcode.com/users/images/cd60c07a-aa40-4d39-b069-de5538f334fe_1657687029.7320123.png)\\n\\n\\n* Each iteration\\u2019s cur_i and prev becomes the next iteration\\u2019s prev and prev2 respectively.\\n* Therefore after calculating cur_i, if we update prev and prev2 according to the next step, we will always get the answer. \\n* After the iterative loop has ended we can simply return prev as our answer.\\n***\\n***\\n\\n***C++ Code***\\n```\\n  int prev2 = 1;\\n  int prev = 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      int cur_i = prev2+ prev;\\n      prev2 = prev;\\n      prev= cur_i;\\n  }\\n  return prev;\\n```\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using any extra space.\\n***\\n***Please Upvote if it Helps......***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n  vector<int> dp(n+1,-1);\\n  \\n  dp[0]= 1;\\n  dp[1]= 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      dp[i] = dp[i-1]+ dp[i-2];\\n  }\\n  return dp[n];\\n  \\n```\n```\\n  int prev2 = 1;\\n  int prev = 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      int cur_i = prev2+ prev;\\n      prev2 = prev;\\n      prev= cur_i;\\n  }\\n  return prev;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504269,
                "title": "java-easy-solution-and-runtime-0-ms-faster-than-100-used-fibonacci-series",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466915,
                "title": "two-simple-c-solutions-using-top-down-and-bottom-up-dp",
                "content": "```\\n// solution 1\\nclass Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        if(n <= 2) return n;\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        return climb(n, dp);\\n    }\\n    int climb(int n, vector<int> &dp){\\n        \\n        if(dp[n] > 0) return dp[n];\\n        return dp[n] = climb(n-1, dp) + climb(n-2, dp);\\n    }\\n};\\n\\n\\n\\n// solution 2\\nclass Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        \\n        if(n<=2) return n;\\n        vector<int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i<=n; i++){\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        if(n <= 2) return n;\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        return climb(n, dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1098633,
                "title": "climbing-stairs-all-three-approaches-recursion-top-down-memoization-bottom-up-tabulation",
                "content": "**In this post, I am going to talk about all the three approaches involved to solve this problem**\\n\\n#1 Recursion\\n\\nThis solution is the most simplest one among three but yes it will give TLE due to its fairly exponential time complexity.... Not a suggested way but its surely the first step and the basic step to move towards DP i.e. optimised solution...\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //  Recursive\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n#2 Memoization (Top-Down)\\n\\nAn optimisation to the recursive approach... In this recursion is still present but here what we do is store the overlapping subproblems results in hand... as the main problem with recursive approach was that we were solving many sub problems repeatedly.... and so memoization comes into play... In this we store our results in a dp table(here its 1-D) and that would bring reduce the complexity O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static int helper(int n,int *dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n]=helper(n-1,dp) + helper(n-2,dp);\\n    }\\n    \\n    int climbStairs(int n) {\\n        //  Memoized\\n        \\n        int dp[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=-1;\\n        }\\n        return helper(n,dp);\\n    }\\n};\\n```\\n\\n#3 Tabulation (Bottom-up)\\n\\nSame as memoization but here iteratively result is evaluated and this method is preferred over memoization due to various stack calls in Top down.... \\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //DP\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //  Recursive\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    static int helper(int n,int *dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n]=helper(n-1,dp) + helper(n-2,dp);\\n    }\\n    \\n    int climbStairs(int n) {\\n        //  Memoized\\n        \\n        int dp[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=-1;\\n        }\\n        return helper(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //DP\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353923,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int n2 = 1, n1 = 2, all = 0;\\n        \\n        for(int i = 2; i < n; i++){\\n            all = n2 + n1;\\n            n2 = n1;\\n            n1 = all;\\n        }\\n        return all;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Climbing Stairs.\\nMemory Usage: 32.8 MB, less than 5.26% of Java online submissions for Climbing Stairs.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int n2 = 1, n1 = 2, all = 0;\\n        \\n        for(int i = 2; i < n; i++){\\n            all = n2 + n1;\\n            n2 = n1;\\n            n1 = all;\\n        }\\n        return all;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300652,
                "title": "javascript",
                "content": "```\\nvar climbStairs = function(n) {\\n    let arr = [0,1,2,3];\\n    for(let i = 4; i <= n; i++){\\n        arr[i] = arr[ i - 1] + arr[i - 2];\\n    }\\n    return arr[n];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar climbStairs = function(n) {\\n    let arr = [0,1,2,3];\\n    for(let i = 4; i <= n; i++){\\n        arr[i] = arr[ i - 1] + arr[i - 2];\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25646,
                "title": "my-solution-considering-odd-and-even",
                "content": "    public int climbStairs(int n){\\n\\t\\tif(n <= 0) return 0;\\n\\t\\tint [] stairs = {1,2};\\n\\t\\tfor(int i = 2;i < n;i++){\\n\\t\\t\\tstairs[i%2] = stairs[0]+stairs[1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn n % 2 == 0 ? stairs[1]:stairs[0];\\n\\t}\\n\\n\\n\\nconsiding f(n) = f(n-1)+f(n-2),that is: \\n\\n\\n----------\\n\\n\\nf(1) = 1\\n\\n\\n----------\\nf(2) = 2\\n\\n\\n----------\\n\\n\\nf(3) = f(2)+f(1)\\n\\n\\n----------\\n\\n\\nf(4) = f(3)+f(2)\\n\\n\\n----------\\n\\n\\n...\\n\\n\\n----------\\n\\n\\nand the values before f(2) will never use again,so we can use an array with two elements to store the tmp values",
                "solutionTags": [],
                "code": "    public int climbStairs(int n){\\n\\t\\tif(n <= 0) return 0;\\n\\t\\tint [] stairs = {1,2};\\n\\t\\tfor(int i = 2;i < n;i++){\\n\\t\\t\\tstairs[i%2] = stairs[0]+stairs[1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn n % 2 == 0 ? stairs[1]:stairs[0];\\n\\t}\\n\\n\\n\\nconsiding f(n) = f(n-1)+f(n-2),that is: \\n\\n\\n----------\\n\\n\\nf(1) = 1\\n\\n\\n----------\\nf(2) = 2\\n\\n\\n----------\\n\\n\\nf(3) = f(2)+f(1)\\n\\n\\n----------\\n\\n\\nf(4) = f(3)+f(2)\\n\\n\\n----------\\n\\n\\n...\\n\\n\\n----------\\n\\n\\nand the values before f(2) will never use again,so we can use an array with two elements to store the tmp values",
                "codeTag": "Unknown"
            },
            {
                "id": 25608,
                "title": "my-divide-and-conquer-way-to-solve-this-problem-java",
                "content": "Hi guys, here is my solution:\\n\\n    public class Solution {\\n        public int climbStairs(int n) {\\n            //bottom case\\n            if(n < 1){\\n                return 0;\\n            }\\n            \\n            if(n == 1){\\n                return 1;\\n            }\\n            if(n == 2){\\n                return 2;\\n            }\\n            if(n == 3){\\n                return 3;\\n            }\\n            \\n            return climbStairs(n/2)*climbStairs(n - n/2) + climbStairs(n/2 - 1) * climbStairs(n - n/2 - 1);\\n            \\n        }\\n    }\\n\\nEach time we cut n stairs in the middle:\\n\\ntotal case(n) = total case(head half of n) * total case(tail half of n) + additional case.\\n\\nAbout the additional case: The border on head half and tail half contribute an \\'1\\', then we form a \\'2\\' in the middle. So total case of additional case should = total case(head half - 1) * total case(tail half -1).\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public int climbStairs(int n) {\\n            //bottom case\\n            if(n < 1){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3956051,
                "title": "java-runtime-0-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to solving this problem involves considering the fact that reaching the \\'n\\'th step can be achieved by either taking a single step from the \\'n-1\\'th step or taking two steps from the \\'n-2\\'th step. Therefore, the number of distinct ways to reach the \\'n\\'th step is the sum of the ways to reach the \\'n-1\\'th and \\'n-2\\'th steps.\\n\\n# Approach\\nI will use a recursive approach with memoization to calculate the total number of distinct ways to climb the staircase of \\'n\\' steps. I\\'ll create a memoization array to store the results for already calculated steps, which will help avoid redundant calculations. Starting from the base cases where \\'n\\' is 1 or 2, I\\'ll recursively calculate the number of ways to reach the \\'n\\' step by summing the ways from \\'n-1\\' and \\'n-2\\' steps. I\\'ll store the results in the memoization array and return the final result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm calculates each distinct step\\'s number of ways only once due to memoization, so the time complexity is linear, where \\'n\\' is the input value.\\n\\n- Space complexity: O(n)\\n  The algorithm uses extra space for the memoization array, which stores the number of ways for each step.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return calculateWays(n, memo);\\n    }\\n    \\n    private int calculateWays(int n, int[] memo) {\\n        if (n == 1 || n == 2) {\\n            return n;\\n        }\\n        \\n        if (memo[n] != 0) {\\n            return memo[n];\\n        }\\n        \\n        memo[n] = calculateWays(n - 1, memo) + calculateWays(n - 2, memo);\\n        return memo[n];\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return calculateWays(n, memo);\\n    }\\n    \\n    private int calculateWays(int n, int[] memo) {\\n        if (n == 1 || n == 2) {\\n            return n;\\n        }\\n        \\n        if (memo[n] != 0) {\\n            return memo[n];\\n        }\\n        \\n        memo[n] = calculateWays(n - 1, memo) + calculateWays(n - 2, memo);\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831506,
                "title": "easiest-and-optimized-code-explained-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- After observation one can realize that this nothis just a fibbonacci sequence.\\n- We can also implement this in simple manner. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        int res;\\n        \\n        if(n<=3)return n;\\n        int prev=3;\\n        int uska_prev = 2;\\n        \\n        for(int i=4;i<=n;i++){\\n            \\n            res = prev + uska_prev;\\n            uska_prev = prev;\\n            prev = res;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        int res;\\n        \\n        if(n<=3)return n;\\n        int prev=3;\\n        int uska_prev = 2;\\n        \\n        for(int i=4;i<=n;i++){\\n            \\n            res = prev + uska_prev;\\n            uska_prev = prev;\\n            prev = res;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675671,
                "title": "beginner-friendly-detailed-explanation-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitively, the code utilizes a dynamic programming approach to solve the problem. It keeps track of the counts for the current step and the next step, updating them iteratively based on the counts of the previous steps. By the end of the loop, the value of b represents the total number of distinct ways to reach the top of the staircase with n steps.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code is implementing a method climbStairs in the Solution class. This method calculates the number of distinct ways to climb to the top of a staircase with n steps, where each time you can either climb 1 or 2 steps at a time.\\n\\nHere\\'s how the code works:\\n\\nThe method initializes two variables, a and b, to keep track of the number of distinct ways to reach the current step and the next step, respectively. Initially, a is set to 0 and b is set to 1.\\nUsing a for loop, the code iterates n times, representing each step in the staircase.\\nIn each iteration, the code updates a and b by swapping their values and assigning a + b to b. This step effectively calculates the number of distinct ways to reach the current step (a) and updates the number of distinct ways to reach the next step (b) based on the previous steps\\' counts.\\nAfter the loop finishes executing n times, the method returns the value of b, which represents the number of distinct ways to reach the top of the staircase with n steps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the number of steps in the staircase. This is because the code iterates n times in the for loop.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) since the code only uses a constant amount of additional space to store the variables a and b, regardless of the input size.\\n# Code\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a, b = 0, 1\\n        for i in range(n):\\n\\t        a, b = b, a + b         \\n        return b\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a, b = 0, 1\\n        for i in range(n):\\n\\t        a, b = b, a + b         \\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085426,
                "title": "rust-0ms-100-faster-by-cheating-with-your-friendly-lut",
                "content": "A long time ago, my mechanical engineering teacher told me a story about how his team manage to make one of the fastest robot-arm firmware by pre-computing a table of square root values. \\n\\nThis problem is a typical case were we can apply this cheat. We don\\'t have to use the most sofisticated algorithm to compute every value of N, since we just have to compute it once :) .\\n\\n\\n# Code\\n```rust\\nconst LUT: &[i32] = &[\\n    0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\\n    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,\\n    433494437, 701408733, 1134903170, 1836311903,\\n];\\n\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        return LUT[n as usize];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```rust\\nconst LUT: &[i32] = &[\\n    0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\\n    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,\\n    433494437, 701408733, 1134903170, 1836311903,\\n];\\n\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        return LUT[n as usize];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798735,
                "title": "climbing-stairs-solution-recursion-memoization-tabulation",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n    //Recursion\\n        //if(n==1)return 1;\\n        //if(n==0)return 1;                   // stand at 0th stair\\n          //return climbStairs(n-1) + climbStairs(n-2);\\n        \\n    //Memoization\\n        //  int dp[] = new int[n+1];\\n        //  for(int i=0; i<n+1; i++)\\n        //      dp[i]=-1;\\n        // return memo(n,dp);\\n    //Dp\\n        return dp(n);\\n    }\\n    public int memo(int n, int dp[]){\\n        if(n==1)return 1;\\n        if(n==0)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        \\n        dp[n] = memo(n-1,dp) + memo(n-2,dp);\\n        return dp[n];\\n    }\\n    public int dp(int n){\\n       int dp[] = new int[n+1]; \\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=2; i<n+1; i++)\\n            dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n    //Recursion\\n        //if(n==1)return 1;\\n        //if(n==0)return 1;                   // stand at 0th stair\\n          //return climbStairs(n-1) + climbStairs(n-2);\\n        \\n    //Memoization\\n        //  int dp[] = new int[n+1];\\n        //  for(int i=0; i<n+1; i++)\\n        //      dp[i]=-1;\\n        // return memo(n,dp);\\n    //Dp\\n        return dp(n);\\n    }\\n    public int memo(int n, int dp[]){\\n        if(n==1)return 1;\\n        if(n==0)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        \\n        dp[n] = memo(n-1,dp) + memo(n-2,dp);\\n        return dp[n];\\n    }\\n    public int dp(int n){\\n       int dp[] = new int[n+1]; \\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=2; i<n+1; i++)\\n            dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703084,
                "title": "climbing-stairs-using-fibonacci",
                "content": "**DON\\'T FORGOT TO UPVOTE**\\nIt is basically fibonacci.\\nFor 0 stair : 1 way\\nFor 1 stair : 1 way\\nFor 2 stairs : 2 ways ((1+1), (2))\\nFor 3 stairs : 3 ways ((1+1+1), (1+2), (2+1))\\nFor 4 stairs : 5 ways ((1+1+1+1), (1+1+2), (2+1+1), (1+2+1), (2+2))\\nFor 5 stairs : 8 ways ((1+1+1+1+1), (1+1+1+2), (2+1+1+1), (1+2+1+1), (1+1+2+1), (2+2+1), (2+1+2), (1+2+2))\\n...\\n1 , 1, 2, 3, 5, 8, 13, 21, ...\\n\\nBottom-Up Approach:\\n```\\nint climbStairs(int n) {\\n     if(n <= 1) {\\n\\t\\t return 1;\\n     }\\n     int arr[n];\\n     arr[0] = arr[1] = 1;\\n     for(int i = 2; i < n; i++) {\\n\\t\\t arr[i] = arr[i-1] + arr[i-2];\\n     }\\n\\t return arr[n-1] + arr[n-2];\\n }\\n```\\nTop-Down Approach:\\n```\\nint solve(int n, vector<int>& dp) {\\n\\tif(n <= 1) return 1;\\n    if(dp[n] != -1) return dp[n];\\n    return dp[n] = solve(n-1, dp) + solve(n-2, dp);\\n}\\nint climbStairs(int n) {   \\n    if(n == 1) return 1;\\n    vector<int> dp(n+1, -1);\\n    return solve(n, dp);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint climbStairs(int n) {\\n     if(n <= 1) {\\n\\t\\t return 1;\\n     }\\n     int arr[n];\\n     arr[0] = arr[1] = 1;\\n     for(int i = 2; i < n; i++) {\\n\\t\\t arr[i] = arr[i-1] + arr[i-2];\\n     }\\n\\t return arr[n-1] + arr[n-2];\\n }\\n```\n```\\nint solve(int n, vector<int>& dp) {\\n\\tif(n <= 1) return 1;\\n    if(dp[n] != -1) return dp[n];\\n    return dp[n] = solve(n-1, dp) + solve(n-2, dp);\\n}\\nint climbStairs(int n) {   \\n    if(n == 1) return 1;\\n    vector<int> dp(n+1, -1);\\n    return solve(n, dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851337,
                "title": "it-s-literally-the-fibonacci-numbers",
                "content": "[Leetcode](https://leetcode.com/) [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/).\\n\\nIn fact, it\\'s a [Fibonacci Numbers](https://en.wikipedia.org/wiki/Fibonacci_number), the sequence is as follows:\\n\\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, \\\\dots$\\n\\nTo find out the $nth$ **Fibonacci Numbers**, we can use such algorithms: [9 Fibonacci Algorithms | The Most Complete Solutions | Image Explanation](https://leetcode.com/problems/fibonacci-number/solutions/1854398/9-fibonacci-algorithms-the-most-complete-solutions-image-explanation/)\\n\\nor visit the discuss:\\n[Leetcode Discuss: Fibonacci Numbers](https://leetcode.com/discuss/study-guide/1854405/9-fibonacci-algorithms-the-most-complete-solutions-all-in-one-easy-to-understand) .\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "[Leetcode](https://leetcode.com/) [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/).\\n\\nIn fact, it\\'s a [Fibonacci Numbers](https://en.wikipedia.org/wiki/Fibonacci_number), the sequence is as follows:\\n\\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, \\\\dots$\\n\\nTo find out the $nth$ **Fibonacci Numbers**, we can use such algorithms: [9 Fibonacci Algorithms | The Most Complete Solutions | Image Explanation](https://leetcode.com/problems/fibonacci-number/solutions/1854398/9-fibonacci-algorithms-the-most-complete-solutions-image-explanation/)\\n\\nor visit the discuss:\\n[Leetcode Discuss: Fibonacci Numbers](https://leetcode.com/discuss/study-guide/1854405/9-fibonacci-algorithms-the-most-complete-solutions-all-in-one-easy-to-understand) .\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1504370,
                "title": "python-3-solution-comparison-3-approaches",
                "content": "# Solution #1\\nClassical DP solution\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [1,1] + [0]*(n-1)\\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[-1]\\n```\\nThe first solution is faster than **60.32%** of others and requires memory of less than **42.71%**.\\n# Solution #2\\nClassical DP solution without array\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return n\\n        p = pp = 1\\n        for i in range(2, n+1):\\n            res = p + pp\\n            pp = p\\n            p = res\\n        return res\\n```\\nThe second solution is faster than **60.32%** of others and requires memory of less than **42.71%**.\\n# Solution #3\\nRecursion solution with memorization by using a dictionary mem\\n```\\nclass Solution:\\n    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:\\n        if n in mem:\\n            return mem[n]\\n        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)\\n        return mem[n]\\n```\\nThe third solution is faster than **95.02%** of others and requires memory of less than **90.49%**.\\n# Conclusion:\\n- The first and second solutions don\\'t differ either in speed or execution time, therefore it makes no sense to avoid using the classic dp array.\\n- Tip: If it\\'s important for you to overtake your rivals, then you can set as many initial values as possible, which will significantly speed up the execution. \\nFor example,` dp = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...]`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [1,1] + [0]*(n-1)\\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return n\\n        p = pp = 1\\n        for i in range(2, n+1):\\n            res = p + pp\\n            pp = p\\n            p = res\\n        return res\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:\\n        if n in mem:\\n            return mem[n]\\n        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)\\n        return mem[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327557,
                "title": "rust-one-liner-fibbonacci-numbers",
                "content": "```\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        (0..n)\\n            .fold((1, 0), |(res, prev), _| (res + prev, res))\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        (0..n)\\n            .fold((1, 0), |(res, prev), _| (res + prev, res))\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791308,
                "title": "javascript-solution-70",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet climbStairs = function(n) {\\n    let arr=[];\\n    arr[1]=1;\\n    arr[2]=2;\\n    for(let i=3;i<=n;i++){\\n        arr[i]=arr[i-1]+arr[i-2];\\n    }\\n    return arr[n];\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 64.59% of JavaScript online submissions for Climbing Stairs.**\\n\\n**Memory Usage: 36.4 MB, less than 34.63% of JavaScript online submissions for Climbing Stairs.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet climbStairs = function(n) {\\n    let arr=[];\\n    arr[1]=1;\\n    arr[2]=2;\\n    for(let i=3;i<=n;i++){\\n        arr[i]=arr[i-1]+arr[i-2];\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25350,
                "title": "both-bottom-up-and-top-down-dynamic-programming-style-java-code-good-for-learners",
                "content": "\\nThe bottom-up approach is provided as following. \\nThe idea is that we consider from `stair level 0` and `stair level 1`, which are the base cases. And we use an array N to record the number of distinct ways for each level. \\nObviously, for `level 0` and `level 1`, the number of distinct ways are 1. After that, for each level `i` where `i` is greater than `0` and `1`, we have 2 possible way to step on it: The first one is to go from  `level i - 1` (i.e. climb 1 steps); the second one is to go from `level i - 2` (i.e. climb 2 steps). Thus for each level `i` where `i` is greater than  `1`, `N[i] = N[i - 1] + N[i - 2]`.\\nAnd hence, `N[n]` stores the total number of distinct ways to climb `n` stairs after the `for` loop.  \\n```\\n/*\\nbottom-up approach\\n*/\\n\\npublic int climbStairs(int n){\\n    if (n == 0){\\n        return 1;\\n    }\\n    else{\\n        int[] N = new int[n + 1];\\n        N[0] = 1;\\n        N[1] = 1;\\n        for (int i = 2; i <= n; i ++){\\n            N[i] = N [ i - 1] + N[i - 2];\\n        }\\n        return N[n];\\n    }\\n}\\n```\\n\\nThe top down approach is showed as following. \\nIn the top down approach, we actually consider from the top, which is `stair level n`. And the recursive equation is still `N[i] = N[i - 1] + N[i - 2]`. Hence we get the so-called optimal substructures in `Dynamic programming`. Thus, by recursively calculate each level from `n` to base case, which is `0` and `1` and memorize the intermediate, we can still get the total number of distinct ways to go to stair `n`. \\n```\\n/*\\ntop-down approach\\n*/\\n\\n\\npublic int climbStairs(int n) {\\n    int[] N = new int[n];\\n    for (int i = 0; i < n; i++){\\n        N[i] = -1;\\n    }\\n    \\n    return topdownclimbStairs(n, N);\\n}\\n\\nprivate int topdownclimbStairs(int n, int[] N){\\n    if (n == 0 || n == 1){\\n        return 1;\\n    }\\n    \\n    if (N[n - 1] >= 0){\\n        return N[n - 1];\\n    }\\n\\n    else {\\n        N[n - 1] = topdownclimbStairs(n-1, N) + topdownclimbStairs(n - 2, N);\\n        return N[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nbottom-up approach\\n*/\\n\\npublic int climbStairs(int n){\\n    if (n == 0){\\n        return 1;\\n    }\\n    else{\\n        int[] N = new int[n + 1];\\n        N[0] = 1;\\n        N[1] = 1;\\n        for (int i = 2; i <= n; i ++){\\n            N[i] = N [ i - 1] + N[i - 2];\\n        }\\n        return N[n];\\n    }\\n}\\n```\n```\\n/*\\ntop-down approach\\n*/\\n\\n\\npublic int climbStairs(int n) {\\n    int[] N = new int[n];\\n    for (int i = 0; i < n; i++){\\n        N[i] = -1;\\n    }\\n    \\n    return topdownclimbStairs(n, N);\\n}\\n\\nprivate int topdownclimbStairs(int n, int[] N){\\n    if (n == 0 || n == 1){\\n        return 1;\\n    }\\n    \\n    if (N[n - 1] >= 0){\\n        return N[n - 1];\\n    }\\n\\n    else {\\n        N[n - 1] = topdownclimbStairs(n-1, N) + topdownclimbStairs(n - 2, N);\\n        return N[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25624,
                "title": "this-is-essentially-a-fibonacci-sequence",
                "content": "Solution to this problem makes a Fibonacci sequence. We can understand it better if we start from the end. To reach to Step N, you can either reach to step N-1 and take 1 step from there or take 2 step from N - 2. \\nTherefore it can be summarized as:\\nF(N) = F(N-1) + F(N-2)\\n\\nOnce you have recognized the pattern, it is very easy to write the code:\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def climbStairs(self, n):\\n        if n < 1:\\n            return 0\\n        prev = 1\\n        curr = 1\\n        while n > 1:\\n            prev, curr = curr, prev + curr\\n            n -=1\\n        return curr",
                "solutionTags": [],
                "code": "Solution to this problem makes a Fibonacci sequence. We can understand it better if we start from the end. To reach to Step N, you can either reach to step N-1 and take 1 step from there or take 2 step from N - 2. \\nTherefore it can be summarized as:\\nF(N) = F(N-1) + F(N-2)\\n\\nOnce you have recognized the pattern, it is very easy to write the code:\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def climbStairs(self, n):\\n        if n < 1:\\n            return 0\\n        prev = 1\\n        curr = 1\\n        while n > 1:\\n            prev, curr = curr, prev + curr\\n            n -=1\\n        return curr",
                "codeTag": "Java"
            },
            {
                "id": 3436390,
                "title": "fibo-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 1) {\\n            return n;\\n        }\\n\\n        int n1 = 1;\\n        int n2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int next = n1;\\n            n1 = n2;\\n            n2 = next + n2;\\n        }\\n\\n        return n2;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 1) {\\n            return n;\\n        }\\n\\n        int n1 = 1;\\n        int n2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int next = n1;\\n            n1 = n2;\\n            n2 = next + n2;\\n        }\\n\\n        return n2;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252887,
                "title": "explanation-of-the-idea-of-dp-o-n-time-space-c",
                "content": "\\n# Climbing Stairs problem\\n\\n\\n\\n- We are given a staircase which has **\\u2018n\\u2019 steps/floors**.\\n- Each time, on each step, **we can either take 1 step or 2 steps at a time**.\\n- We need to **find the number of distinct ways in which we can reach the top step/floor.**\\n\\n- Let n = 3, meaning we have 3 steps or floors to climb to as shown below :\\n![stairs_0.PNG](https://assets.leetcode.com/users/images/6a78b919-b75a-4b00-a995-041a9e540e9a_1677862570.6098013.png)\\n\\n\\n- One way to climb the stairs is : 1 step + 1 step + 1 step , as shown below :\\n\\n![stairs_1.PNG](https://assets.leetcode.com/users/images/8c9c1e95-6a83-4c7b-afe4-1c8fcf09089f_1677862584.8530686.png)\\n\\n- Another way would be  : 2 step + 1 step :\\n\\n![stairs_3.PNG](https://assets.leetcode.com/users/images/4ca71d7c-5257-4f5e-89a6-38feb75fc9f3_1677862653.4234407.png)\\n\\n- Another way would be : 1 step + 2 step as shown below :\\n\\n![stairs_2.PNG](https://assets.leetcode.com/users/images/22f620cc-2f44-40ca-bc3c-d9d61bda7d38_1677862666.0298843.png)\\n\\n\\n- So total number of distinct ways to climb n = 3 floors = 1 + 1 + 1 = 3.\\n\\n## Explanation:\\n\\n- For n = 2 , we know there are following 2 ways in which we can climb :\\n\\n![stairs_4.PNG](https://assets.leetcode.com/users/images/04cc0ecb-a6e3-4cec-b29b-99c557271f74_1677862691.0310204.png)\\n\\n- We can either go 1 step + 1 step , or 2 step directly.\\n\\n- Now , we can define an **array \\u2018dp\\u2019** of size \\u2018n\\u2019, ie the number of floors.\\n\\n```cpp\\n**dp[i] ==> number of  distinct ways climb to the \\'ith\\' floor from \\'0th\\' floor**\\n```\\n\\n- So ultimately we need to find **dp[n] ie the number of distinct ways in which we can climb \\u2018n\\u2019 floors.**\\n- So what is **dp[i] ?**\\n\\n \\n\\n- Say, there is some ith floor to which we need to count number of ways to climb.\\n![stairs_5.PNG](https://assets.leetcode.com/users/images/a6352348-80a2-4410-b343-c77df8a92034_1677862714.0218048.png)\\n\\n- **To reach to the ith floor, either of the two options must have happened**\\n    - **took 1 step from (i-1)th floor**\\n    - **took 2 step from (i-2)ith floo**r\\n\\n![stairs_6.PNG](https://assets.leetcode.com/users/images/27460725-01f5-4020-90ed-62a4d7c83456_1677862732.8335752.png)\\n\\n- So, dp[i] can be written as :\\n![stairs_7.PNG](https://assets.leetcode.com/users/images/8a09b1c9-a78f-4087-8e59-53ec45f9128e_1677862751.7524385.png)\\n\\n- So , what are the **base cases** :\\n    - **dp[1] = 1** , because to climb to floor = 1 , there is only 1 way ie to take 1 step\\n    - **dp[2] = 2** , because to climb to floor = 2, there are 2 ways : 1 step + 1 step OR 2 step.\\n    \\n\\n![stairs_8.PNG](https://assets.leetcode.com/users/images/3a140591-2427-44d2-a375-967ccd4dd26d_1677862771.3870678.png)\\n\\n### Let\\u2019s do a case for n = 4.\\n\\n![stairs_9.PNG](https://assets.leetcode.com/users/images/784c008f-2c41-4bfa-85c4-a4267f7c5a0e_1677862791.054674.png)\\n\\n\\n- dp[1] = 1 and dp[2] = 2.\\n- Let\\u2019s **find dp[3]** then.\\n- Our formula is :\\n\\n```cpp\\n         dp[i] = dp[i-1] + dp[i-2]\\n\\nhere, i = 3 ,\\ndp[3] = dp[2] + dp[1] \\ndp[3] = 2 + 1\\ndp[3] = 3\\n```\\n![stairs_10.PNG](https://assets.leetcode.com/users/images/eda4eef1-fd19-4e5e-9422-526bf06eb677_1677862805.104596.png)\\n\\n- Therefore **dp[3] = 2 + 1 = 3 , therefore there are 3 distinct ways to reach the 3rd floor using 1 step and 2 step.**\\n\\n![stairs_11.PNG](https://assets.leetcode.com/users/images/7e99c5f2-1e53-44da-b6a7-fd71892748a0_1677862821.0890055.png)\\n\\n\\n- Now, for **dp[4] :**\\n\\n```cpp\\n\\t\\t\\t\\tdp[i] = dp[i-1] + dp[i-2]\\ni = 4,\\ndp[4] = dp[3] + dp[2]\\ndp[4] = 3 + 2\\ndp[4] = 5\\n```\\n\\n![1.PNG](https://assets.leetcode.com/users/images/d09f400d-19b6-4d0d-bfc2-1ece3c2e326a_1677862837.9587646.png)\\n\\n![2.PNG](https://assets.leetcode.com/users/images/1ab2836a-d21f-42a7-83bb-52210f793a16_1677862876.0183854.png)\\n\\n\\n![3.PNG](https://assets.leetcode.com/users/images/46e50134-09a2-4aa4-8423-ce984d5c3d86_1677862902.4442675.png)\\n\\n![4.PNG](https://assets.leetcode.com/users/images/2bb6a386-9567-455a-bfb8-b0b6f545b460_1677862915.397574.png)\\n\\n\\n![5.PNG](https://assets.leetcode.com/users/images/31a97205-4239-41cb-bddd-942c3853cb30_1677862928.6362588.png)\\n\\n- Therefore there are **5 distinct ways to reach 4th floor.**\\n# Code\\n```\\n \\nclass Solution \\n{\\n public :\\n int climbStairs(int n)\\n {\\n    if(n<=1)\\n        return 1;\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    dp[2] = 2;\\n    for(int i = 3 ; i <= n ; i++ )\\n        dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n**dp[i] ==> number of  distinct ways climb to the \\'ith\\' floor from \\'0th\\' floor**\\n```\n```cpp\\n         dp[i] = dp[i-1] + dp[i-2]\\n\\nhere, i = 3 ,\\ndp[3] = dp[2] + dp[1] \\ndp[3] = 2 + 1\\ndp[3] = 3\\n```\n```cpp\\n\\t\\t\\t\\tdp[i] = dp[i-1] + dp[i-2]\\ni = 4,\\ndp[4] = dp[3] + dp[2]\\ndp[4] = 3 + 2\\ndp[4] = 5\\n```\n```\\n \\nclass Solution \\n{\\n public :\\n int climbStairs(int n)\\n {\\n    if(n<=1)\\n        return 1;\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    dp[2] = 2;\\n    for(int i = 3 ; i <= n ; i++ )\\n        dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164321,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      const int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 3:\\n            return n\\n\\n        cur = 2\\n        prev = 1\\n\\n        for _ in range(3, n + 1):\\n            cur, prev = cur + prev, cur\\n        \\n        return cur\\n```\\n\\n```Java []\\nclass Solution {\\n  public int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      final int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      const int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 3:\\n            return n\\n\\n        cur = 2\\n        prev = 1\\n\\n        for _ in range(3, n + 1):\\n            cur, prev = cur + prev, cur\\n        \\n        return cur\\n```\n```Java []\\nclass Solution {\\n  public int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      final int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902866,
                "title": "java-explained-in-detail-simple-fast-solution-dynamic-programming",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n# Java - Recursive & Memoization\\n\\n## Approach\\nThis problem is the same as the Fibonacci number sequence, where the number of ways is the sum of the ways for \\'n - 1\\' and \\'n - 2\\'.\\n\\nWhen we are on step i, we can only be at i + 1 or i + 2 for one iteration.\\n\\nConversely, when we are at step n, we can only have taken the route from i - 1 or i - 2.\\n\\nThe same applies to the route to arrive at i - 1 and i - 2 respectively.\\n\\nThus, ways(n) = ways(n - 1) + ways(n - 2).\\n\\nHere, we use the recursive method, using the \\'memo\\' keep track of the calculated number to lower the time complexity.\\n\\n## Complexity\\n- Time Complexity  : O(n), as the recursive call stack is at a maximum of size \\'n\\', when climbStairs(i - 1) is called until reaching the base case.\\n\\n- Space Complexity : O(n), as we use the memo of size \\'n\\' to record the result of stairs from 1 to \\'n\\'.\\n\\n## Java - With Explanation\\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    // Wrapper method.\\n    public int climbStairs(int n) {\\n\\n        // Use an integer array as \\'memo\\' to record the results that was calculated.\\n        // This is so to not repeat the same calculation over the recursive calls.\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    // Recursive method.\\n    private int climbStairs(int n, int[] memo) {\\n\\n        // We know the ways for n == 1 and n == 2, so record it into the memo.\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        // If \\'n\\' is already in the memo, return memo[n].\\n        if (memo[n] > 0) return memo[n];\\n\\n        // If the current \\'n\\' is not in the memo, then we call the recursive method to calculate and record memo[n],\\n        // and return the result.\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\\n## Java - Clean Code\\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, int[] memo) {\\n\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        if (memo[n] > 0) return memo[n];\\n\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\\n\\n---\\n\\n# Java - Iterative & Tabulation\\n\\n## Approach\\nThis problem is the same as the Fibonacci number sequence, where the number of ways is the sum of the ways for \\'n - 1\\' and \\'n - 2\\'.\\n\\nWhen we are on step i, we can only be at i + 1 or i + 2 for one iteration.\\n\\nConversely, when we are at step n, we can only have taken the route from i - 1 or i - 2.\\n\\nThe same applies to the route to arrive at i - 1 and i - 2 respectively.\\n\\nThus, ways(n) = ways(n - 1) + ways(n - 2).\\n\\nHere, we use the iterative and tabulation method, using an array to keep track.\\n\\nNote that it is possible to use only two variables to keep track of ways(i - 1) and ways(i - 2), but this is a good practice for the tabulation method in dynamic programming.\\n\\n## Complexity\\n- Time Complexity  : O(n),\\nas we iterate from 1 to \\'n\\' to find the number of ways to climb stairs.\\n\\n- Space Complexity : O(n), \\nas we use the table of size \\'n\\' to record the result of stairs from 1 to \\'n\\'.\\nIf we use only two variable to record ways(i - 1) and ways(i - 2), then it will be O(1).\\n\\n## Java - With Explanation\\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n\\n        // Return the ways for n == 1 and n == 2, since we know the result already.\\n        if (n == 1 || n == 2) return n;\\n\\n        // When using tabulation, seed the table with the base cases for n == 1 and n == 2.\\n        // Since the array in Java is zero-indexed, we make sure to have the table of size \"n + 1\"\\n        // as we need to access index \\'n\\'.\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n        // Iterate through the table and update its values until \\'n\\'.\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n\\n        // table[n] is the result.\\n        return table[n];\\n    }\\n}\\n```\\n## Java - Clean Code\\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n        if (n == 1 || n == 2) return n;\\n\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n        return table[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic class ClimbingStairs_Recursive {\\n\\n    // Wrapper method.\\n    public int climbStairs(int n) {\\n\\n        // Use an integer array as \\'memo\\' to record the results that was calculated.\\n        // This is so to not repeat the same calculation over the recursive calls.\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    // Recursive method.\\n    private int climbStairs(int n, int[] memo) {\\n\\n        // We know the ways for n == 1 and n == 2, so record it into the memo.\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        // If \\'n\\' is already in the memo, return memo[n].\\n        if (memo[n] > 0) return memo[n];\\n\\n        // If the current \\'n\\' is not in the memo, then we call the recursive method to calculate and record memo[n],\\n        // and return the result.\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, int[] memo) {\\n\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        if (memo[n] > 0) return memo[n];\\n\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n\\n        // Return the ways for n == 1 and n == 2, since we know the result already.\\n        if (n == 1 || n == 2) return n;\\n\\n        // When using tabulation, seed the table with the base cases for n == 1 and n == 2.\\n        // Since the array in Java is zero-indexed, we make sure to have the table of size \"n + 1\"\\n        // as we need to access index \\'n\\'.\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n        // Iterate through the table and update its values until \\'n\\'.\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n\\n        // table[n] is the result.\\n        return table[n];\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n        if (n == 1 || n == 2) return n;\\n\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n        return table[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775347,
                "title": "ruby-six-approaches",
                "content": "```\\n# 70.climbing_stairs.rb\\n# @param {Integer} n\\n# @return {Integer}\\n#\\n# recursion using brute force approach\\n#\\n# time: O(2^n) the size of the recursion tree is 2^n\\n#\\n# space: O(n) where n is the height or depth of the three.\\n#\\n# climb_stair(i,n) = (i + 1, n) = climb_stair(i + 2, n)\\ndef climb_stairs(n)\\n    return climb_stair(0, n) # helper function\\n end\\n \\n # where i is the current step and n is the destination step\\n def climb_stair(i, n)\\n \\n     # base case\\n     # if i > n we walked over and we return 0\\n     return 0 if i > n \\n     # if n is 1 we can only take one step thus return 1\\n     return 1 if i == n \\n \\n     # recursive case\\n     # we climb 1 step and climb 2 steps\\n     return climb_stair(i + 1, n) + climb_stair(i + 2, n)\\n end\\n```\\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with array)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = Array.new(n + 1, 0)\\n     return climb_stair(0, n, memo) \\n end\\n  \\n def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i] > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with hash)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = {}\\n     return climb_stair(0, n, memo) \\n end\\n  \\n  def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i].to_i > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\\n```\\n \\n # with memoiztion without recursion\\n #\\n # time: O(n) we iterate over one array.\\n #\\n # space: O(n) array of size n.\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     memo    = Array.new(n + 1, 0)\\n     memo[1] = 1\\n     memo[2] = 2\\n \\n     for i in (3..n)\\n         memo[i] = memo[i - 1] + memo[i - 2]\\n     end\\n \\n     return memo[n]\\n end\\n```\\n```\\n \\n # fibonacci number approach\\n #\\n # time: O(n) single loop\\n #\\n # space: O(1) no memory space is allocated\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     first   = 1\\n     second  = 2\\n \\n     for i in (3..n)\\n         third   = first + second\\n         first   = second\\n         second  = third\\n     end\\n     \\n     return second \\n end\\n```\\n```\\n \\n # fibonacci formula\\n #\\n # time: O(log n) raising it to power of x takes log n time.\\n #\\n # space: O(1) constant space.\\n #\\n # note: credit to other programmer for this solution \\n def climb_stairs(n)\\n     sqrt5   = Math::sqrt(5)\\n     phi     = (1 + sqrt5) / 2.0\\n     psi     = (1 - sqrt5) / 2.0\\n \\n     return (((phi ** (n + 1)) - (psi ** (n + 1))) / sqrt5).to_i\\n end\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# 70.climbing_stairs.rb\\n# @param {Integer} n\\n# @return {Integer}\\n#\\n# recursion using brute force approach\\n#\\n# time: O(2^n) the size of the recursion tree is 2^n\\n#\\n# space: O(n) where n is the height or depth of the three.\\n#\\n# climb_stair(i,n) = (i + 1, n) = climb_stair(i + 2, n)\\ndef climb_stairs(n)\\n    return climb_stair(0, n) # helper function\\n end\\n \\n # where i is the current step and n is the destination step\\n def climb_stair(i, n)\\n \\n     # base case\\n     # if i > n we walked over and we return 0\\n     return 0 if i > n \\n     # if n is 1 we can only take one step thus return 1\\n     return 1 if i == n \\n \\n     # recursive case\\n     # we climb 1 step and climb 2 steps\\n     return climb_stair(i + 1, n) + climb_stair(i + 2, n)\\n end\\n```\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with array)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = Array.new(n + 1, 0)\\n     return climb_stair(0, n, memo) \\n end\\n  \\n def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i] > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with hash)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = {}\\n     return climb_stair(0, n, memo) \\n end\\n  \\n  def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i].to_i > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\n```\\n \\n # with memoiztion without recursion\\n #\\n # time: O(n) we iterate over one array.\\n #\\n # space: O(n) array of size n.\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     memo    = Array.new(n + 1, 0)\\n     memo[1] = 1\\n     memo[2] = 2\\n \\n     for i in (3..n)\\n         memo[i] = memo[i - 1] + memo[i - 2]\\n     end\\n \\n     return memo[n]\\n end\\n```\n```\\n \\n # fibonacci number approach\\n #\\n # time: O(n) single loop\\n #\\n # space: O(1) no memory space is allocated\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     first   = 1\\n     second  = 2\\n \\n     for i in (3..n)\\n         third   = first + second\\n         first   = second\\n         second  = third\\n     end\\n     \\n     return second \\n end\\n```\n```\\n \\n # fibonacci formula\\n #\\n # time: O(log n) raising it to power of x takes log n time.\\n #\\n # space: O(1) constant space.\\n #\\n # note: credit to other programmer for this solution \\n def climb_stairs(n)\\n     sqrt5   = Math::sqrt(5)\\n     phi     = (1 + sqrt5) / 2.0\\n     psi     = (1 - sqrt5) / 2.0\\n \\n     return (((phi ** (n + 1)) - (psi ** (n + 1))) / sqrt5).to_i\\n end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765329,
                "title": "fibo",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.fibnocci = [0,1,2]\\n        for i in range(3,46):\\n            self.fibnocci.append(self.fibnocci[i-1]+self.fibnocci[i-2]);\\n            \\n    def climbStairs(self, n: int) -> int:\\n        return self.fibnocci[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.fibnocci = [0,1,2]\\n        for i in range(3,46):\\n            self.fibnocci.append(self.fibnocci[i-1]+self.fibnocci[i-2]);\\n            \\n    def climbStairs(self, n: int) -> int:\\n        return self.fibnocci[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735055,
                "title": "0ms-runtime-c-solution-dynamic-programming",
                "content": "This question follows the same pattern as the fibbonaci series.\\n\\nLet\\'s see how.\\n\\nFor n=1, no of solutions = 1\\nFor n=2, no of solutions = 2\\nFor n=3, no of solutions = 3  [1+2]\\nFor n=4, no of solutions = 5  [2+3]\\nFor n=5, no of solutions = 8  [3+5]\\nFor n=5, no of solutions = 13 [5+8]\\n\\nAs we can see the steps are sum of it\\'s two predecessors. We can apply the same algorithm for getting the $$n^{th}$$ sum of a fibonacci series here.\\n\\nWe store the already calculated values in a vector array to prevent calculating the same step sum again & again. This in face same a lot of time, thus bringing down the time complexity.\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    int climbStairsdp(int n, vector<int>& dp) {\\n        if (n<2) return 1;\\n        if (dp[n]) return dp[n];\\n        else return dp[n] = climbStairsdp(n-1, dp) + climbStairsdp(n-2, dp);\\n    }\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return climbStairsdp(n, dp);\\n    }\\n};\\n```\\n\\n*if this solution helped you, please do upvote it*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    int climbStairsdp(int n, vector<int>& dp) {\\n        if (n<2) return 1;\\n        if (dp[n]) return dp[n];\\n        else return dp[n] = climbStairsdp(n-1, dp) + climbStairsdp(n-2, dp);\\n    }\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return climbStairsdp(n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732425,
                "title": "o-1-time-complexity-solution",
                "content": "As many have already pointed out, this Is basically a fibonacci series implimentation and there already are good explanations of this in the discussions.\\n\\nHowever there is a direct mathematical fomula for fibonacci that you can refer to here: https://math.hmc.edu/funfacts/fibonacci-number-formula/\\n\\nMeaning its a direct answer with no loops.\\n\\n__NOTE__ - At this point the complexity of the actual operators like ** and / do start mattering so its not exactly O(1) technically speaking, but I believe this is the closest we can get to an O(1) solution.\\n\\n``` Python \\nclass Solution(object):\\n    def climbStairs(self, n):\\n        n = n+1\\n        root5 = 5**0.5\\n        Phi,phi = (1 + root5)/2,(1 - root5)/2\\n        return int((Phi**n - phi**n)/root5)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` Python \\nclass Solution(object):\\n    def climbStairs(self, n):\\n        n = n+1\\n        root5 = 5**0.5\\n        Phi,phi = (1 + root5)/2,(1 - root5)/2\\n        return int((Phi**n - phi**n)/root5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698704,
                "title": "c-java-python3-javascript-solutions-faster-than-90",
                "content": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n**Example : C# Solution1 - temporary interger**\\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        //the first example has tell us how many distinct way for 1 or 2 steps stairs\\n        int first  = 1;     \\n        int second = 2;     \\n        int tmp = 0;        \\n        \\n        if(n<=2)    //if n not more than 2 than just return the stpes it take\\n        {\\n            return n;\\n        }\\n        else\\n        {\\n            for(int i =3; i<=n;i++) //every iteration,will add the last two steps together and save as \\'second\\'\\n            {\\n                tmp = second;       \\n                second+=first;      //set second as now iteration needed steps\\n                first = tmp;        //set first as the last time needed steps\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n\\n**Example : C# Solution2 - use Array to store**\\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        if(n<2){\\n            return n;\\n        }\\n        \\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        \\n        for(int i=2;i<n;i++) {\\n            ans[i]=ans[i-1]+ans[i-2];\\n        }\\n        return ans[n-1];\\n    }\\n}\\n```\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        //the first example has tell us how many distinct way for 1 or 2 steps stairs\\n        int first  = 1;     \\n        int second = 2;     \\n        int tmp = 0;        \\n        \\n        if(n<=2)    //if n not more than 2 than just return the stpes it take\\n        {\\n            return n;\\n        }\\n        else\\n        {\\n            for(int i =3; i<=n;i++) //every iteration,will add the last two steps together and save as \\'second\\'\\n            {\\n                tmp = second;       \\n                second+=first;      //set second as now iteration needed steps\\n                first = tmp;        //set first as the last time needed steps\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        if(n<2){\\n            return n;\\n        }\\n        \\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        \\n        for(int i=2;i<n;i++) {\\n            ans[i]=ans[i-1]+ans[i-2];\\n        }\\n        return ans[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690264,
                "title": "faster-than-100",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        // simple fibonacci problem\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        // simple fibonacci problem\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437625,
                "title": "five-different-solution-c-easily-understandable",
                "content": "```\\nTime: O(2^n)  Space: O(n)\\n--> Recursion (TLE)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        int left=climbStairs(n-1);\\n        int right=climbStairs(n-2);\\n        return left+right;\\n    }\\n};\\n\\nTime: O(n)  Space: O(n)\\n--> Memoization (Top-Down)\\n\\nclass Solution {\\npublic:\\n    int dp[46]={0};\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(dp[n]!=0)\\n            return dp[n];\\n        dp[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return dp[n];\\n    }\\n};\\n\\n--> Without using Global Variable\\n\\nclass Solution {\\npublic:\\n    int f(int n,vector<int>& dp){\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(dp[n]!=0)\\n            return dp[n];\\n        int left=f(n-1,dp);\\n        int right=f(n-2,dp);\\n        return dp[n]=left+right;\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return f(n,dp);\\n    }\\n};\\n\\nTime: O(n) Space: O(n) \\n--> Tabulation (Bottom-Up)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;dp[0]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nTime: O(n)  Space: O(1)\\n--> Tabulation and Space Optimized\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<2)\\n            return 1;\\n        int a=1,b=1,c=0;\\n        for(int i=2;i<=n;i++){\\n            c=a+b;\\n            a=b;b=c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nTime: O(2^n)  Space: O(n)\\n--> Recursion (TLE)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        int left=climbStairs(n-1);\\n        int right=climbStairs(n-2);\\n        return left+right;\\n    }\\n};\\n\\nTime: O(n)  Space: O(n)\\n--> Memoization (Top-Down)\\n\\nclass Solution {\\npublic:\\n    int dp[46]={0};\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(dp[n]!=0)\\n            return dp[n];\\n        dp[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return dp[n];\\n    }\\n};\\n\\n--> Without using Global Variable\\n\\nclass Solution {\\npublic:\\n    int f(int n,vector<int>& dp){\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(dp[n]!=0)\\n            return dp[n];\\n        int left=f(n-1,dp);\\n        int right=f(n-2,dp);\\n        return dp[n]=left+right;\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return f(n,dp);\\n    }\\n};\\n\\nTime: O(n) Space: O(n) \\n--> Tabulation (Bottom-Up)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;dp[0]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nTime: O(n)  Space: O(1)\\n--> Tabulation and Space Optimized\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<2)\\n            return 1;\\n        int a=1,b=1,c=0;\\n        for(int i=2;i<=n;i++){\\n            c=a+b;\\n            a=b;b=c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334116,
                "title": "c-java-python3-javascript-solutions-faster-than-85-90",
                "content": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "codeTag": "Unknown"
            },
            {
                "id": 2191631,
                "title": "simplest-python-solution-explanation-code-dp-approach",
                "content": "**CLIMBING STAIRS PROBLEM:**\\nThis problem is very similar to [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\n\\nWe have two choices at the start: either climb the first stair or climb the 2nd stair.\\n* if we take one step from the ground, then the subproblem becomes: *climbing the nth stair from the 1st stair.*\\n\\n* if we take two step from the ground, then the subproblem becomes: *climbing the nth stair from the 2nd stair.*\\n\\nSo we can solve the given problem recursively by adding the results of sub-problems:\\n**climbStairs(0, n) = climbStairs(1, n) + climbStairs(2, n)**\\n\\n```\\ndef climbStairs(self, n: int) -> int:\\n\\t\\tif n <= 2:\\n            return n\\n        \\n        dp = [0] * (n+1)\\n\\t\\t\\n        dp[1] = 1\\n        dp[2] = 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        \\n        return dp[n]\\n```\\n\\n**Another more efficient approach could be:**\\n```\\ndef climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        \\n        dp = [0, 1, 2]\\n        \\n        for i in range(3, n+1):\\n            dp[i%3] = dp[(i-1) % 3] + dp[(i-2) % 3]\\n        \\n        return dp[n % 3]\\n        \\n```\\n\\nFeel free to ask the doubts and please upvote!(^_^)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef climbStairs(self, n: int) -> int:\\n\\t\\tif n <= 2:\\n            return n\\n        \\n        dp = [0] * (n+1)\\n\\t\\t\\n        dp[1] = 1\\n        dp[2] = 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        \\n        return dp[n]\\n```\n```\\ndef climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        \\n        dp = [0, 1, 2]\\n        \\n        for i in range(3, n+1):\\n            dp[i%3] = dp[(i-1) % 3] + dp[(i-2) % 3]\\n        \\n        return dp[n % 3]\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2176954,
                "title": "java-solution-in-depth-explanation-w-mathmatical-proof",
                "content": "This is a very good DP problem based on mathematical proof. I believe many people have the same questions in their mind like I do. Why it\\'s `(n-1)` step + `(n-2)` step, but not `(n-1)` step + `(n-2)` step + `1` since we need to do an additional step to get to stair `n`? I would use [@WX-78](https://leetcode.com/WX-78) \\'s idea to explain. \\n  Think about what happens on the `n`-th step. We can get to stair `n` from `(n-1)` step or from `(n-2)` step. Also, we know there are `x` distinct ways to get to `(n-1)` step, and `y` distinct ways to get to `(n-2)` steps.\\n\\n  1. For `(n-1)`, we just need to add 1 on `x` paths to get to `n` step. It doesn\\'t change the number of `x` paths required to get `(n-1)` step.\\n  2. For `(n-2)`, we need to add 2 on `y` paths to get to `n` step. It also doesn\\'t change the number of `y` paths required to get to `(n-2)` step.\\n  Therefore, we just need to add `(n-1)` step and `(n-2)` step together to get all the possible ways to `n` step. I believe it is still unclear at this point so let\\'s look the **examples** below.\\n\\nFor example 1, what are all the paths leading to `3`:\\n`[1 + 1 + 1]`\\n`    [2 + 1]`\\n`    [1 + 2]`\\nTo get to `5`, we simply need to add `2` to all the possible paths:\\n`[1 + 1 + 1] + 2`\\n`    [2 + 1] + 2`\\n`    [1 + 2] + 2`\\nNow we can see how the magic works here. The number of ways to get from `3` to `5` does not change with this operation, right? We are adding `2`to each sequence, but it just makes each sequence longer **not making more of possible sequences**.\\n\\nLet\\'s look at another example, just in case it\\'s still not clear enough.\\n\\nFor example 2, for `4` we have five possible ways to get to there:\\n`[1 + 1 + 1 + 1]`\\n`    [1 + 1 + 2]`\\n`    [1 + 2 + 1]`\\n`    [2 + 1 + 1]`\\n`        [2 + 2]`\\nTo get to `5`, we need to add `1` to all the possible sequence so we will have:\\n`[1 + 1 + 1 + 1] + 1`\\n`    [1 + 1 + 2] + 1`\\n`    [1 + 2 + 1] + 1`\\n`    [2 + 1 + 1] + 1`\\n`        [2 + 2] + 1`\\nAgain, we can see how the magic works here. With the adding operation, it doesn\\'t change the number of possible ways to get to `5`. Hence, the total number of paths to get to `5` is the total number of path to get to `3` + the total number of path to get to `4`.\\n\\n  Below is my solution in Java.\\n```\\nclass Solution \\n{\\n    public int climbStairs(int n) \\n    {\\n        // O(n) time | O(n) space\\n        if(n == 0)  return 1;\\n        if(n == 1)  return 1;\\n        \\n        int[] stairs = new int[n];\\n        \\n        stairs[0] = 1;\\n        stairs[1] = 2;\\n        \\n        for(int i = 2; i < n; i++)\\n            stairs[i] = stairs[i-1] + stairs[i-2];\\n        \\n        return stairs[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int climbStairs(int n) \\n    {\\n        // O(n) time | O(n) space\\n        if(n == 0)  return 1;\\n        if(n == 1)  return 1;\\n        \\n        int[] stairs = new int[n];\\n        \\n        stairs[0] = 1;\\n        stairs[1] = 2;\\n        \\n        for(int i = 2; i < n; i++)\\n            stairs[i] = stairs[i-1] + stairs[i-2];\\n        \\n        return stairs[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851979,
                "title": "illustrated-explanation",
                "content": "<<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3c78e85c-e538-4392-a13b-ae1d1bb04642_1647355317.703214.png)\\n\\n    @functools.cache\\n    def climbStairs(self, n: int) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        return self.climbStairs(n - 2) + self.climbStairs(n - 1) if n > 2 else n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "<<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3c78e85c-e538-4392-a13b-ae1d1bb04642_1647355317.703214.png)\\n\\n    @functools.cache\\n    def climbStairs(self, n: int) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        return self.climbStairs(n - 2) + self.climbStairs(n - 1) if n > 2 else n",
                "codeTag": "Python3"
            },
            {
                "id": 1822442,
                "title": "climbing-stairs-easy-java-solution",
                "content": "***IF YOU LIKE IT, PLS PLS UPVOTE IT :)***\\n![image](https://assets.leetcode.com/users/images/dd1f3bc6-3040-42ab-871f-8f2660595ceb_1646499781.8532014.jpeg)\\n\\n```\\n//A type of fibonacci number problem\\n//I\\'m gonna use memoization here\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        //to store the value of recursive call\\n        int[] dp=new int[n+1];\\n        return  countSteps(n,dp); \\n    \\n    }\\n    \\n    static int countSteps(int n,int[] dp){\\n\\n\\n        //BASE CASE\\n        //I can only jump on the last stair can\\'t go next\\n        if(n==0){return 1;}\\n        //I can go till 0th stair from 1st stair\\n        if(n==1) {return 1;}\\n        \\n        //to check if I have computed this value earlier or not!\\n        if(dp[n]!=0){\\n            return dp[n];\\n        }\\n        //I can either jump one step or two step!\\n        int lh=countSteps(n-1,dp);\\n        int rh=countSteps(n-2,dp);\\n        \\n        //sum of both side\\n        return dp[n]=lh+rh;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//A type of fibonacci number problem\\n//I\\'m gonna use memoization here\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        //to store the value of recursive call\\n        int[] dp=new int[n+1];\\n        return  countSteps(n,dp); \\n    \\n    }\\n    \\n    static int countSteps(int n,int[] dp){\\n\\n\\n        //BASE CASE\\n        //I can only jump on the last stair can\\'t go next\\n        if(n==0){return 1;}\\n        //I can go till 0th stair from 1st stair\\n        if(n==1) {return 1;}\\n        \\n        //to check if I have computed this value earlier or not!\\n        if(dp[n]!=0){\\n            return dp[n];\\n        }\\n        //I can either jump one step or two step!\\n        int lh=countSteps(n-1,dp);\\n        int rh=countSteps(n-2,dp);\\n        \\n        //sum of both side\\n        return dp[n]=lh+rh;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671910,
                "title": "python-detailed-explanation-o-n-time-o-n-space-beats-92-05-time",
                "content": "So the first intution here is going to be approaching this as a dfs problem similar to the [combination sum](https://leetcode.com/problems/combination-sum/) problem, except now this time, we\\'re only looking at the amount of ways we can sum n with only 1 and 2. \\n\\nSo we begin by drawing a graph of the problem to figure out our next steps and see if we can find a particular pattern. Let\\'s take 4 for example:\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     2            3\\n\\t\\t\\t\\t\\t\\t\\t       / \\t\\\\       /    \\\\\\n\\t\\t\\t\\t\\t\\t           1    0      2      1\\n\\t\\t\\t\\t\\t\\t         /           /   \\\\      \\\\ \\n\\t\\t\\t\\t\\t            0           1     0       0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0\\n```\\nFirst things first, we realize we can use 1 and 2 as our base case, since it\\'s a relatively simple answer, and every branch will always end in a 1 or a 2. \\n\\nThe second thing we can realize is that we can sort of start looking at every solution less than 4 below it. The right hand hand side of the tree gives us the solution of 3, and left hand side gives us the solution for 2. Then the branches of 3 gives us the solution for 2 and 1. We also realize that the sum of the solutions of both sides of the tree gives us the final answer for the root.  So we begin plotting out for funtion f:\\n```\\nf(5) = f(4) + f(3)\\nf(4) = f(3) + f(4)\\nf(3) = f(2) + f(1)\\n```\\nThus we see that for n in range [2, inf]:\\n```\\nf(n) = f(n - 1) + f(n - 2)\\n```\\nWhich should look familiar, because this is just a fibonacci sequence!\\nUsing this information, we can create some simple code similiar to the code of the classic fib sequence problem:\\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n in {1, 2}:\\n            return n\\n        \\n        return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\nIn this solution, since the longest branch is going to be us just repeatingly subtracting 1 from n, n is going to be our tree height, and thus our space complexity from our stack will be O(n). \\nSince for n tree height we are going to have a worst case of 2^n nodes (you can test this out yourself by drawing a tree, with each node having exactly two children), then the time complexity for this solution is O(2^n). \\n\\nThis solution is clearly not an efficient one, so we are going to try to see how we can speed things up. One thing we can usually do whenever we are dealing with recursion is memoizing. And since we have a bunch of branches that repeat, this is the perfect opportunity to utalize it. \\n\\nSo if we are calculating a large number like 45, instead of calculating the solution for any n less than 44 multiple times, we can just calculate it once, and hold the solution we find in a dictionary. That way, whenever we come accross the need to find the solution for the same number in the future, we can solve it in O(1) time. \\n\\nSince recursion sort of works like dfs, and we are doing n - 1 first, we\\'re going to have the solution for every number up to n before we even start going to any of the right branches. Since at that point all of the solutions for the right branches are found and only require O(1) lookup time, the only calculations we\\'re doing is the left branches which are made up of n nodes. \\nThus, our new time complexity should be O(n), all while our space complexity should stay the same, since we\\'re only storing up to n solutions in the dictionary.\\n\\nAwesomely enough, we can achieve this through just a few edits of our old code:\\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\n\\nclass Solution:\\n    def climbStairs(self, n: int, memo = {1:1, 2:2}) -> int:\\n        if n in memo:\\n            return memo[n]\\n        \\n        memo[n] = self.climbStairs(n - 1, memo) + self.climbStairs(n - 2, memo)\\n        \\n        return memo[n]\\n```\\n\\nLet me know if there are any questions or sugestions!\\nIf you want to look further into it, I recommend looking at the first problem solved in the dynamic programming video offered by freecodecamp.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     2            3\\n\\t\\t\\t\\t\\t\\t\\t       / \\t\\\\       /    \\\\\\n\\t\\t\\t\\t\\t\\t           1    0      2      1\\n\\t\\t\\t\\t\\t\\t         /           /   \\\\      \\\\ \\n\\t\\t\\t\\t\\t            0           1     0       0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0\\n```\n```\\nf(5) = f(4) + f(3)\\nf(4) = f(3) + f(4)\\nf(3) = f(2) + f(1)\\n```\n```\\nf(n) = f(n - 1) + f(n - 2)\\n```\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n in {1, 2}:\\n            return n\\n        \\n        return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\n\\nclass Solution:\\n    def climbStairs(self, n: int, memo = {1:1, 2:2}) -> int:\\n        if n in memo:\\n            return memo[n]\\n        \\n        memo[n] = self.climbStairs(n - 1, memo) + self.climbStairs(n - 2, memo)\\n        \\n        return memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591139,
                "title": "javascript-python-beat-96-fibonacci-sequence-simple-readable",
                "content": "```\\n/* \\n1 -> 1\\n2 -> 2 (1+1 | 2+0)\\n3 -> 3 (1+1+1 | 2+1 | 1+2)\\n4 -> 5 (1+1+1+1 | 2+1+1 | 2+2 | 1+2+1 | 1+1+2)\\nand so on\\n\\nThis is exactly a fibonacci sequence\\nEach next amount of steps equals to sum of previous 2\\n1 -> 2 -> 3 -> 5 -> 8 -> 13\\n*/\\n```\\n\\nJavascript\\n```\\nvar climbStairs = function(n) {\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 0; i < n; i++) {\\n    [a, b] = [b, a + b];\\n  }\\n  return b;\\n};\\n```\\n\\nPython\\n```\\nclass Solution:\\n  def climbStairs(self, n: int) -> int:\\n    a, b = 0, 1;\\n    for i in range(1, n + 1):\\n      b, a = a + b, b;\\n\\n    return b;\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/* \\n1 -> 1\\n2 -> 2 (1+1 | 2+0)\\n3 -> 3 (1+1+1 | 2+1 | 1+2)\\n4 -> 5 (1+1+1+1 | 2+1+1 | 2+2 | 1+2+1 | 1+1+2)\\nand so on\\n\\nThis is exactly a fibonacci sequence\\nEach next amount of steps equals to sum of previous 2\\n1 -> 2 -> 3 -> 5 -> 8 -> 13\\n*/\\n```\n```\\nvar climbStairs = function(n) {\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 0; i < n; i++) {\\n    [a, b] = [b, a + b];\\n  }\\n  return b;\\n};\\n```\n```\\nclass Solution:\\n  def climbStairs(self, n: int) -> int:\\n    a, b = 0, 1;\\n    for i in range(1, n + 1):\\n      b, a = a + b, b;\\n\\n    return b;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563121,
                "title": "c-2-solutions-memoization-tabulation-dp",
                "content": "**1. Memoization**\\n```\\n    int climbStairsHelper(int n, vector<int>& t){\\n        if(n<=1) return 1;\\n        if(t[n] != -1) return t[n];\\n        else return t[n] = climbStairsHelper(n-1, t) + climbStairsHelper(n-2, t);\\n    }\\n    int climbStairs(int n) {\\n        if(n<=1) return 1;\\n        vector<int> t(n+1,-1);\\n        return climbStairsHelper(n,t);\\n    }\\n```\\n\\n**2. Tabulation (DP)**\\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        t[0] =1;\\n        t[1] = 1;\\n        for(int i=2; i<n+1; i++) t[i] = t[i-1] + t[i-2];\\n        return t[n];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    int climbStairsHelper(int n, vector<int>& t){\\n        if(n<=1) return 1;\\n        if(t[n] != -1) return t[n];\\n        else return t[n] = climbStairsHelper(n-1, t) + climbStairsHelper(n-2, t);\\n    }\\n    int climbStairs(int n) {\\n        if(n<=1) return 1;\\n        vector<int> t(n+1,-1);\\n        return climbStairsHelper(n,t);\\n    }\\n```\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        t[0] =1;\\n        t[1] = 1;\\n        for(int i=2; i<n+1; i++) t[i] = t[i-1] + t[i-2];\\n        return t[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514782,
                "title": "js-solution",
                "content": "# js solution\\n```\\nvar climbStairs = function(n) {\\n    if(n == 1) return 1;\\n    if(n==2) return 2;\\n    let arr = [1,2]\\n    for(let i=2; i<n;i++) {\\n    arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr[arr.length -1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar climbStairs = function(n) {\\n    if(n == 1) return 1;\\n    if(n==2) return 2;\\n    let arr = [1,2]\\n    for(let i=2; i<n;i++) {\\n    arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr[arr.length -1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435924,
                "title": "java-solution",
                "content": "When thinking about this problem, I started by taking a look at how many possible ways you could climb up N stairs..\\n\\n```\\nN = 1 -> [1] -> 1 way\\nN = 2 -> [1 + 1, 2] -> 2 ways\\nN = 3 -> [1+1+1, 1+2, 2+1] -> 3 ways\\nN = 4 -> [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] -> 5 ways\\nN = 5 -> [1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1] -> 8 ways\\n\\n```\\n\\nAt this point, it became pretty clear that a pattern was forming where the maximum number of ways you could climb up N stairs was equivalent to the MAX[N - 1] + MAX[N - 2].\\n\\nHowever, if N == 1 or N == 2 this doesn\\'t work, its simply 1 or 2.\\n\\nSolution (recursive):\\n```\\n    public int climbStairs(int n) {\\n        if(n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n```\\n\\nThats really bad when N becomes large.. but we can use store the previous values in an array as we calculate to avoid the recursive call.\\n\\nSolution (Dynamic Programming):\\n\\n```\\n    public int climbStairs(int n) {\\n        if (n < 1) {\\n            return 0;\\n        } else if (n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n        int[] steps = new int[n];\\n        steps[0] = 1;\\n        steps[1] = 2;\\n        for (int i = 2; i < n; i++) {\\n            steps[i] = steps[i - 1] + steps[i - 2];\\n        }\\n        return steps[n - 1];\\n    }\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nN = 1 -> [1] -> 1 way\\nN = 2 -> [1 + 1, 2] -> 2 ways\\nN = 3 -> [1+1+1, 1+2, 2+1] -> 3 ways\\nN = 4 -> [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] -> 5 ways\\nN = 5 -> [1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1] -> 8 ways\\n\\n```\n```\\n    public int climbStairs(int n) {\\n        if(n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n```\n```\\n    public int climbStairs(int n) {\\n        if (n < 1) {\\n            return 0;\\n        } else if (n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n        int[] steps = new int[n];\\n        steps[0] = 1;\\n        steps[1] = 2;\\n        for (int i = 2; i < n; i++) {\\n            steps[i] = steps[i - 1] + steps[i - 2];\\n        }\\n        return steps[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415908,
                "title": "python3-24ms-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one\\n            one=one+two\\n            two=temp\\n        return one\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one\\n            one=one+two\\n            two=temp\\n        return one\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316496,
                "title": "python-top-down-recursive-with-memo-bottom-up-iterative-with-tab",
                "content": "\\n\\n**1. Top-down recursive | Without memoization**\\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\treturn recurse(n-1) + recurse(n-2)\\n\\n\\t# main\\n\\treturn recurse(n)\\n\\n```\\n\\n**2. Top-down recursive | With memoization**\\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\tif n in d:\\n\\t\\t\\treturn d[n]\\n\\t\\td[n] = recurse(n-1) + recurse(n-2)\\n\\t\\treturn d[n]\\n\\n\\t# main\\n\\td = {}\\n\\treturn recurse(n)\\n```\\n\\n**3. Bottom-up itertaive with tabulization**\\n```\\ndef climbStairs(n):       \\n\\n\\ttable = [0]*(n+1) # this stores how many ways to arrive at each index/step - NOTE [1]\\n\\t\\n\\ttable[0] = 1 # only one way to arrive at index 0 (this is basically the starting point aka ground level)\\n\\ttable[1] = 1 # only one way to arrive at index 1 (first step)\\n\\n\\t# for remaining steps/indicies, each can be arrived at from: a) 1 step away, b) 2 steps away\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\treturn table[n]\\n\\t\\n# NOTE [1]\\n# Use (n+1) so that we can have index 0 for when person is at the ground level still\\n```\\n\\n- v2.0\\n\\n```\\ndef climbStairs(n):       \\n\\tif n == 0 or n == 1:\\n\\t\\treturn 1\\n\\tif n == 2:\\n\\t\\treturn 2\\n\\n\\ttable = [0]*n\\n\\ttable[0] = 1\\n\\ttable[1] = 2\\n\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\tprint(table)\\n\\treturn table[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\treturn recurse(n-1) + recurse(n-2)\\n\\n\\t# main\\n\\treturn recurse(n)\\n\\n```\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\tif n in d:\\n\\t\\t\\treturn d[n]\\n\\t\\td[n] = recurse(n-1) + recurse(n-2)\\n\\t\\treturn d[n]\\n\\n\\t# main\\n\\td = {}\\n\\treturn recurse(n)\\n```\n```\\ndef climbStairs(n):       \\n\\n\\ttable = [0]*(n+1) # this stores how many ways to arrive at each index/step - NOTE [1]\\n\\t\\n\\ttable[0] = 1 # only one way to arrive at index 0 (this is basically the starting point aka ground level)\\n\\ttable[1] = 1 # only one way to arrive at index 1 (first step)\\n\\n\\t# for remaining steps/indicies, each can be arrived at from: a) 1 step away, b) 2 steps away\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\treturn table[n]\\n\\t\\n# NOTE [1]\\n# Use (n+1) so that we can have index 0 for when person is at the ground level still\\n```\n```\\ndef climbStairs(n):       \\n\\tif n == 0 or n == 1:\\n\\t\\treturn 1\\n\\tif n == 2:\\n\\t\\treturn 2\\n\\n\\ttable = [0]*n\\n\\ttable[0] = 1\\n\\ttable[1] = 2\\n\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\tprint(table)\\n\\treturn table[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307722,
                "title": "fibonacci-turned-stairs",
                "content": "The given question is actually a variation of Fibonacci Numbers using DP. If one has faced the Fibonacci one, the this one is a piece of cake. \\n\\nThe following is the recursive code to build your intuition. It is clearly visible that this is similar to fibo code:\\n\\n\\tint climbStairs(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }//Gives TLE for your info., hence the DP solution\\n\\nNow as per general conception, the only thing needed to do here inorder to convert it into a DP solution is to just replace the recursive calls to elements of the dp table :\\n\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;                                 //Initialization--> if n is 0 or 1 then only one way is possible\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-2] + dp[i-1];             //Update the current value\\n        }\\n        return dp[n];                              //Answer is stored at the last index o the **dp** array \\n    }\\n\\nGive a star if u liked it :)\\nThanks!!\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "The given question is actually a variation of Fibonacci Numbers using DP. If one has faced the Fibonacci one, the this one is a piece of cake. \\n\\nThe following is the recursive code to build your intuition. It is clearly visible that this is similar to fibo code:\\n\\n\\tint climbStairs(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }//Gives TLE for your info., hence the DP solution\\n\\nNow as per general conception, the only thing needed to do here inorder to convert it into a DP solution is to just replace the recursive calls to elements of the dp table :\\n\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;                                 //Initialization--> if n is 0 or 1 then only one way is possible\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-2] + dp[i-1];             //Update the current value\\n        }\\n        return dp[n];                              //Answer is stored at the last index o the **dp** array \\n    }\\n\\nGive a star if u liked it :)\\nThanks!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 974032,
                "title": "java-top-down-dp-explaination-w-video",
                "content": "Video walkthough\\nhttps://www.youtube.com/watch?v=aquoXtYMUME\\n\\nTop Down DP is an optimization built on top of a brute force recursive problem.\\n\\nNot even thinking about DP, how would we solve the problem? The answer is to use a brute force recursive backtracking solution to try every single path we can take.\\n\\nHere\\'s a visualization at N=4\\n\\n![image](https://assets.leetcode.com/users/images/557539f6-041c-4937-b5b2-08c6a28d8b39_1608097912.1572409.png)\\n\\nStarting from N=4, we will try every combination until we reach either 0 or a negative answer. We will then count the number of answers that we found.\\n\\nSpecifically we have:\\n* Base case: N=0, return 1, we found a unique path\\n* Base Case: N < 0, return 0, invalid path\\n* Recursive Case: Stairs(N-1) + Stairs(N-2)\\n\\nThe code for this is here:\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n == 0) {\\n            // base case where we arrived at an answer\\n            return 1;\\n        } else if (n < 0) {\\n            // base case where we went too far\\n            return 0;  \\n        } else {\\n            // recursive case where we try taking 1 step\\n            // and 2 steps, adding the unique permuation\\n            // of steps back\\n            return helper(n-1) + helper(n-2);\\n        }\\n    }\\n}\\n```\\n\\nNow if you look back at the graph, you might notice that we have repeated calculations that we make, like n=1 or n=2:\\n![image](https://assets.leetcode.com/users/images/f634ccc0-09ca-4bfd-99fb-3b8a98f5b163_1608098166.53452.png)\\n\\nThe goal of DP is to save the answers we calculated at each of these sub-problems and re-use them if we ever see them again. We accomplish this by using an array to store the number of path at each stair. For example n=1 will always have 1 unique path.\\n\\nBy re-using the answer that we\\'ve calculated, we can save on runtime complexity which makes DP so powerful\\n![image](https://assets.leetcode.com/users/images/67cd3722-9e9a-4c74-ac0d-60fc510402f8_1608098320.1190197.png)\\n\\nThe only big change to our brute force recursive code is that we use an array to store the answers to each step that we calculate in the recursive case and that reuse it if we ever see it again as one of our base cases.\\n\\nHere\\'s what the code looks like:\\n```\\nclass Solution {\\n    private int[] memo; \\n    public int climbStairs(int n) {\\n        // instantiate the datastructure to cache the calculation\\n        // to each of our subproblems. i.e. what step we are on\\n        memo = new int[n+1];\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n < 0) {\\n            return 0;\\n        } else if (memo[n] != 0) {\\n            // If we stored something in our cache reuse it and avoid\\n            // recalculating everything\\n            return memo[n];\\n        } else if (n == 0) {\\n            return 1;\\n        } else {\\n            // store our calculation inside our cache so we don\\'t \\n            // have to recalculate it again for memo[n]\\n            memo[n] = helper(n-1) + helper(n-2);\\n            return memo[n];\\n        }\\n    }\\n}\\n```\\n\\nAs you can see, DP problems aren\\'t too hard. Once you can think of a recursive backtracking solution, you can easily implement DP to make your algorithm run faster.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n == 0) {\\n            // base case where we arrived at an answer\\n            return 1;\\n        } else if (n < 0) {\\n            // base case where we went too far\\n            return 0;  \\n        } else {\\n            // recursive case where we try taking 1 step\\n            // and 2 steps, adding the unique permuation\\n            // of steps back\\n            return helper(n-1) + helper(n-2);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] memo; \\n    public int climbStairs(int n) {\\n        // instantiate the datastructure to cache the calculation\\n        // to each of our subproblems. i.e. what step we are on\\n        memo = new int[n+1];\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n < 0) {\\n            return 0;\\n        } else if (memo[n] != 0) {\\n            // If we stored something in our cache reuse it and avoid\\n            // recalculating everything\\n            return memo[n];\\n        } else if (n == 0) {\\n            return 1;\\n        } else {\\n            // store our calculation inside our cache so we don\\'t \\n            // have to recalculate it again for memo[n]\\n            memo[n] = helper(n-1) + helper(n-2);\\n            return memo[n];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717739,
                "title": "c-yet-another-dp",
                "content": "```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n        if (n <= 2)\\n            return n;\\n        \\n        int[] res = new int[n + 1];\\n        \\n        res[1] = 1;\\n        res[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++)\\n            res[i] = res[i - 1] + res[i - 2];\\n        \\n        return res[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ClimbStairs(int n) {\\n        if (n <= 2)\\n            return n;\\n        \\n        int[] res = new int[n + 1];\\n        \\n        res[1] = 1;\\n        res[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++)\\n            res[i] = res[i - 1] + res[i - 2];\\n        \\n        return res[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 647444,
                "title": "c-beats-93-56",
                "content": "Runtime: 36 ms, faster than 93.56% of C# online submissions for Climbing Stairs.\\nMemory Usage: 14.4 MB, less than 5.88% of C# online submissions for Climbing Stairs.\\n```\\npublic class Solution\\n{\\n    public int ClimbStairs(int n)\\n    {\\n        if (n < 3)\\n            return n;\\n\\n        int n_2 = 2;\\n        int n_1 = 1;\\n        int res = 0;\\n\\n        int i = 3;\\n        while(i++ <= n)\\n        {\\n            res = n_2 + n_1;\\n            n_1 = n_2;\\n            n_2 = res;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int ClimbStairs(int n)\\n    {\\n        if (n < 3)\\n            return n;\\n\\n        int n_2 = 2;\\n        int n_1 = 1;\\n        int res = 0;\\n\\n        int i = 3;\\n        while(i++ <= n)\\n        {\\n            res = n_2 + n_1;\\n            n_1 = n_2;\\n            n_2 = res;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369330,
                "title": "ruby-fibonacci",
                "content": "```ruby\\ndef climb_stairs(n)\\n    fib = { 0 => 0, 1 => 1, 2 => 2, 3 => 3 }\\n    fib.default_proc = ->(f,n) { f[n] = f[n-1] + f[n-2] }\\n    fib[n]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef climb_stairs(n)\\n    fib = { 0 => 0, 1 => 1, 2 => 2, 3 => 3 }\\n    fib.default_proc = ->(f,n) { f[n] = f[n-1] + f[n-2] }\\n    fib[n]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183770,
                "title": "o-1-and-1-line-python",
                "content": "### Mathematician\\'s way to solve fibonacci and shock interviewer :P beats 100%\\n```\\n    def climbStairs(self, n):\\n        return int((5**.5 / 5) * (((1 + 5**.5)/2)**(n + 1) - ((1 - 5**.5)/2)**(n + 1)))\\n```\\n**How to solve fibonacci mathematically:**\\n* ![alt text](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D245/sign=456a7a09b61bb0518b24b42c037ada77/503d269759ee3d6db9e6f1e046166d224f4adefd.jpg)\\n* Wiki: https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression\\n* Baidu: https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97",
                "solutionTags": [],
                "code": "```\\n    def climbStairs(self, n):\\n        return int((5**.5 / 5) * (((1 + 5**.5)/2)**(n + 1) - ((1 - 5**.5)/2)**(n + 1)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25300,
                "title": "o-n-time-o-1-space-c",
                "content": "    int climbStairs(int n) {\\n        if(n == 0||n==1)\\n            return n;\\n       int b = 1;\\n       int a = 2;    \\n       for(int i=3;i<=n;i++){\\n           a = a+b;\\n           b = a-b; \\n       }\\n       return a; \\n    }",
                "solutionTags": [],
                "code": "    int climbStairs(int n) {\\n        if(n == 0||n==1)\\n            return n;\\n       int b = 1;\\n       int a = 2;    \\n       for(int i=3;i<=n;i++){\\n           a = a+b;\\n           b = a-b; \\n       }\\n       return a; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25517,
                "title": "my-javascript-solution-fib",
                "content": "    \\ufffcvar climbStairs = function(n) {\\n    if(n === 0)  return 0\\n    if(n === 1)  return 1\\n    if(n === 2)  return 2\\n\\n    var arr = [1,2]\\n    for(int i = 2; i < n; i++) {\\n    \\tarr[i] = arr[i-1] + arr[i-2]\\n    }\\n    return arr[n-1]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    \\ufffcvar climbStairs = function(n) {\\n    if(n === 0)  return 0\\n    if(n === 1)  return 1\\n    if(n === 2)  return 2\\n\\n    var arr = [1,2]\\n    for(int i = 2; i < n; i++) {\\n    \\tarr[i] = arr[i-1] + arr[i-2]\\n    }\\n    return arr[n-1]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 25537,
                "title": "5-lines-of-easy-code",
                "content": "    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int cur=1, pre=0;\\n            for(int i=0; i<n; i++){\\n                cur=pre+cur;\\n                pre=cur-pre;\\n            }\\n            return cur;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int cur=1, pre=0;\\n            for(int i=0; i<n; i++){\\n                cur=pre+cur;\\n                pre=cur-pre;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25529,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1 || n == 2) return n;\\n        int sum = 2, prev = 1, curr = 0;\\n        for (int i = 2; i < n; i++) {\\n            curr = sum; \\n            sum += prev;\\n            prev = curr;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1 || n == 2) return n;\\n        int sum = 2, prev = 1, curr = 0;\\n        for (int i = 2; i < n; i++) {\\n            curr = sum; \\n            sum += prev;\\n            prev = curr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3909678,
                "title": "c-four-approaches-dp-explanation-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // time complexities\\n    // recursion - O(2^n) (exponential)\\n    // for toptobottom - (  O(N))\\n    // to bottomup ( tabular ) - (O(N))\\n    // optimal - (O(N))\\n\\n    // space complexities\\n    // for recursion - O(N) ( rec calll stack)\\n    // for top down - O(N) ( for dp array ) + O(N) ( for the rec call stack)\\n    // for bottomup - O(N) ( for the array only ) // as no recursion\\n    // for optimal - (O(1)) ( as we used two variables only)\\n  \\n  // approach 1\\n\\n  int recursion(int n)\\n     { \\n         // when n becomes 0 simply it means we reached the destination and when the n becomes -ve it means we reached beyond the target\\n\\n       // make a array to store the count \\n         if(n == 0)\\n         {\\n             return 1;\\n         }\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         int ans1 = recursion(n-1);\\n         int ans2 = recursion(n-2);\\n         return (ans1 + ans2);\\n\\n     }\\n\\n// approach 2\\n\\nint topdown(int n , vector<int>& dp)\\n     {\\n         // writing the base case\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         if( n == 0)\\n         {\\n             return 1;\\n         }\\n         // check if value already exist\\n         if(dp[n]  != -1)\\n         {\\n             return dp[n];\\n         }\\n\\n         // create the value \\n         dp[n] = topdown(n-1 , dp)+ topdown(n-2,dp);\\n         return dp[n];\\n     }\\n\\n\\n// approach 3\\n\\nint  bottomup(int n)\\n    {\\n        // create array to store\\n        vector<int> dp(n+1 , -1);\\n\\n        // observe the base cases\\n        if( n ==0 )\\n        {\\n            return 0; // as we cant go\\n        }\\n        dp[1] = 1; \\n        if( n == 1)\\n        {\\n            return 1;  // as we can go by having move of 1\\n        }\\n\\n        dp[2] = 2;  \\n        // 2 is the case which needed to be handled as (0 + 1 is 1) but for 2 the ways will be 2 (1+1) and (2)\\n        \\n        for( int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n\\n //approach 4\\n\\n  int optimalsol( int n)\\n  {\\n      // if you see bottomup approach we are just using prev two values to calculate so rather then making a complete array of size n + 1 we must initilize only two variables and we will keep on updating them\\n      if( n == 0 )\\n      {\\n          return 0; // as not possible\\n      }\\n      int temp1 = 1; \\n      int temp2 = 2;\\n    if(n == 1)\\n    {\\n        return temp1;\\n    }\\n    if( n == 2)\\n    {\\n        return temp2;\\n    }\\n    int curr; // to store the current answer\\n    for( int i = 3 ; i <= n ; i++)\\n    {\\n        curr = temp1 + temp2;\\n        //update the values of temp1 and temp2\\n        temp1 = temp2;\\n        temp2 = curr;\\n    }\\n  return curr;\\n  }\\n\\n    \\n\\n\\n    int climbStairs(int n) {\\n       \\n       vector<int> dp(n+1,-1);\\n    // int ans = recursion(n);\\n    // int ans = topdown(n,dp);\\n    // int ans = bottomup(n);\\n     int ans = optimalsol(n);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time complexities\\n    // recursion - O(2^n) (exponential)\\n    // for toptobottom - (  O(N))\\n    // to bottomup ( tabular ) - (O(N))\\n    // optimal - (O(N))\\n\\n    // space complexities\\n    // for recursion - O(N) ( rec calll stack)\\n    // for top down - O(N) ( for dp array ) + O(N) ( for the rec call stack)\\n    // for bottomup - O(N) ( for the array only ) // as no recursion\\n    // for optimal - (O(1)) ( as we used two variables only)\\n  \\n  // approach 1\\n\\n  int recursion(int n)\\n     { \\n         // when n becomes 0 simply it means we reached the destination and when the n becomes -ve it means we reached beyond the target\\n\\n       // make a array to store the count \\n         if(n == 0)\\n         {\\n             return 1;\\n         }\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         int ans1 = recursion(n-1);\\n         int ans2 = recursion(n-2);\\n         return (ans1 + ans2);\\n\\n     }\\n\\n// approach 2\\n\\nint topdown(int n , vector<int>& dp)\\n     {\\n         // writing the base case\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         if( n == 0)\\n         {\\n             return 1;\\n         }\\n         // check if value already exist\\n         if(dp[n]  != -1)\\n         {\\n             return dp[n];\\n         }\\n\\n         // create the value \\n         dp[n] = topdown(n-1 , dp)+ topdown(n-2,dp);\\n         return dp[n];\\n     }\\n\\n\\n// approach 3\\n\\nint  bottomup(int n)\\n    {\\n        // create array to store\\n        vector<int> dp(n+1 , -1);\\n\\n        // observe the base cases\\n        if( n ==0 )\\n        {\\n            return 0; // as we cant go\\n        }\\n        dp[1] = 1; \\n        if( n == 1)\\n        {\\n            return 1;  // as we can go by having move of 1\\n        }\\n\\n        dp[2] = 2;  \\n        // 2 is the case which needed to be handled as (0 + 1 is 1) but for 2 the ways will be 2 (1+1) and (2)\\n        \\n        for( int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n\\n //approach 4\\n\\n  int optimalsol( int n)\\n  {\\n      // if you see bottomup approach we are just using prev two values to calculate so rather then making a complete array of size n + 1 we must initilize only two variables and we will keep on updating them\\n      if( n == 0 )\\n      {\\n          return 0; // as not possible\\n      }\\n      int temp1 = 1; \\n      int temp2 = 2;\\n    if(n == 1)\\n    {\\n        return temp1;\\n    }\\n    if( n == 2)\\n    {\\n        return temp2;\\n    }\\n    int curr; // to store the current answer\\n    for( int i = 3 ; i <= n ; i++)\\n    {\\n        curr = temp1 + temp2;\\n        //update the values of temp1 and temp2\\n        temp1 = temp2;\\n        temp2 = curr;\\n    }\\n  return curr;\\n  }\\n\\n    \\n\\n\\n    int climbStairs(int n) {\\n       \\n       vector<int> dp(n+1,-1);\\n    // int ans = recursion(n);\\n    // int ans = topdown(n,dp);\\n    // int ans = bottomup(n);\\n     int ans = optimalsol(n);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701303,
                "title": "simple-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(int n,vector<int> &dp)\\n{\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n];\\n    return dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n}\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(int n,vector<int> &dp)\\n{\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n];\\n    return dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n}\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567678,
                "title": "c-using-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//using dp\\n    int solve(int n,vector<int> &dp){\\n        if(n<=2){\\n            return n;\\n        }\\n\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n\\n};\\n\\n\\n\\n//using tabulation method\\n\\n\\n//     int climbStairs(int n) {\\n//     vector<int> dp(n+2);\\n//     dp[0]=0;\\n//     dp[1]=1;\\n//     dp[2]=2;\\n//     if(n<3){\\n//         return dp[n];\\n//     }\\n    \\n//     for(int i=3;i<=n;i++){\\n//         dp[i]=dp[i-1]+dp[i-2];\\n//     }\\n//     return dp[n];\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//using dp\\n    int solve(int n,vector<int> &dp){\\n        if(n<=2){\\n            return n;\\n        }\\n\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n\\n};\\n\\n\\n\\n//using tabulation method\\n\\n\\n//     int climbStairs(int n) {\\n//     vector<int> dp(n+2);\\n//     dp[0]=0;\\n//     dp[1]=1;\\n//     dp[2]=2;\\n//     if(n<3){\\n//         return dp[n];\\n//     }\\n    \\n//     for(int i=3;i<=n;i++){\\n//         dp[i]=dp[i-1]+dp[i-2];\\n//     }\\n//     return dp[n];\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483669,
                "title": "easy-java-solution-beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n      if(n<4)\\n      return n;\\n      int f=2,s=3,t=0;\\n      for(int i=3;i<n;i++){\\n          t=f+s;\\n          f=s;\\n          s=t;\\n      }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n      if(n<4)\\n      return n;\\n      int f=2,s=3,t=0;\\n      for(int i=3;i<n;i++){\\n          t=f+s;\\n          f=s;\\n          s=t;\\n      }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928339,
                "title": "m-o-1-t-o-n-4-different-approaches",
                "content": "# 4 Approachs\\n1. First recursion & Backtracking\\n2. Then Memorization \\n3. DP- Bottom up approach using Array\\n4. DP same as 3 but no space just 2 pointers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# /70. Climbing Stairs\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        one, two = 1, 1\\n        for _ in range(n-1):\\n            one, two = two, one+two\\n        return two\\n\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# /70. Climbing Stairs\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        one, two = 1, 1\\n        for _ in range(n-1):\\n            one, two = two, one+two\\n        return two\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908156,
                "title": "simple-java-solution-with-video-explanation",
                "content": "UPVOTE IF IT HELPS YOU, IT KEEPS ME MOTIVATED \\n```\\npublic class Solution {\\n\\n    public int climbStairs(int n) {\\n        int a = 1;\\n        int b = 1;\\n        for(int i=0; i<n-1; i++){\\n            int temp = a;\\n            a = b;\\n            b = b + temp;\\n        }\\n        return b;\\n    }\\n}\\n```\\n[https://www.youtube.com/watch?v=Y0lT9Fck7qI]()",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int climbStairs(int n) {\\n        int a = 1;\\n        int b = 1;\\n        for(int i=0; i<n-1; i++){\\n            int temp = a;\\n            a = b;\\n            b = b + temp;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905111,
                "title": "python-3-2-versions-3-lines-each-w-explanation-t-m-94-68",
                "content": "\\'\\'\\'\\nLets use `A(n)` as the answer for `n`. Obviously, then `A(1) = 1` and `A(2) = 2`. To get to the third stair, we either take one step from `2` or two steps from `1`, which implies `A3 = A1 + A2`. In general, the inductive step to determine all values then is `A(k) = A(k-1) + A(k-2)`. Thus, the problem reduces to finding the nth Fibonacci number, given `n`.  \\n\\nVersion 1: Induction\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n\\n        a, b, (d, m) = 1, 1, divmod(n,2)\\n\\n        for _ in range(d):  a,b = a+b,a+b+b\\n\\n        return b if m else a\\n```\\n[https://leetcode.com/problems/climbing-stairs/submissions/858745613/](http://)\\n\\nVersion 2: Binet\\'s Formula (The irrational numbers `phi` and `psi` below are the eigenvalues of the linear transformation `a,b = a+b,a+b+b` above. More complete explanations can be googled.) \\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n\\n        phi= (1+sqrt(5))/2\\n        psi = 1 - phi\\n\\n        return int((phi**(n+1)-psi**(n+1))/sqrt(5))\\n```\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*) on the first, and *O*(1) / *O*(1) on the second.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n\\n        a, b, (d, m) = 1, 1, divmod(n,2)\\n\\n        for _ in range(d):  a,b = a+b,a+b+b\\n\\n        return b if m else a\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n\\n        phi= (1+sqrt(5))/2\\n        psi = 1 - phi\\n\\n        return int((phi**(n+1)-psi**(n+1))/sqrt(5))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570512,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1564973,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1714182,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1887814,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567350,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567370,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1576987,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568496,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568574,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568723,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1570512,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1564973,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1714182,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1887814,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567350,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567370,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1576987,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568496,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568574,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568723,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1570203,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1566449,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1572841,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1916688,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1752782,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1568786,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1568891,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1573230,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1713807,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1575816,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1576386,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1572340,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1567839,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1814546,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1714382,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1576324,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1575721,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1575566,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1573870,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1573063,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1572626,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 1572231,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 1570607,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2074335,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2069853,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2067489,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2066431,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2066049,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2065569,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2064619,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2059430,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2057594,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2054075,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2052493,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2049763,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2043103,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2041394,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2033047,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2020621,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2020231,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2014209,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 2009119,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1999651,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1986069,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1982993,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1974310,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1973133,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1958833,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1947902,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1942506,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1942205,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1939369,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1938656,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1935802,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1925807,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1921304,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1875660,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1872889,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1866789,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1864678,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1852756,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849950,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849356,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849341,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849340,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1848019,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1840751,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1833965,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1833024,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1828889,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1825437,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1808482,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1802043,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1799955,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1799869,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1785211,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1783115,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1782032,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1781062,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1776547,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1773066,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1760092,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1752227,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1747538,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1745802,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1745683,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1740936,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1735975,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733939,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733938,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733937,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1733203,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1733201,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1732245,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1727776,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1725908,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1724331,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714501,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714352,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714347,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714322,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714309,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714280,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714237,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714178,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714116,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714081,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713959,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713955,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713783,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713748,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713739,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713729,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713695,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713659,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1711045,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1709022,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1693294,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1689605,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1688135,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1685816,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1683672,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1681575,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1679574,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1675424,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1670220,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1668813,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1665161,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1664945,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1663491,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Sum III - Data structure design",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566759,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            },
            {
                "id": 1568994,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            },
            {
                "id": 1568462,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            },
            {
                "id": 1573404,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            }
        ]
    },
    {
        "title": "Closest Binary Search Tree Value",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1880668,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 1571514,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 2056836,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 1968665,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 1685046,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            }
        ]
    },
    {
        "title": "Range Addition",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565138,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 1569272,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 1817516,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 1573554,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 2017489,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            }
        ]
    },
    {
        "title": "Implement Rand10() Using Rand7()",
        "question_content": "<p>Given the <strong>API</strong> <code>rand7()</code> that generates a uniform random integer in the range <code>[1, 7]</code>, write a function <code>rand10()</code> that generates a uniform random integer in the range <code>[1, 10]</code>. You can only call the API <code>rand7()</code>, and you shouldn&#39;t call any other API. Please <strong>do not</strong> use a language&#39;s built-in random API.</p>\n\n<p>Each test case will have one <strong>internal</strong> argument <code>n</code>, the number of times that your implemented function <code>rand10()</code> will be called while testing. Note that this is <strong>not an argument</strong> passed to <code>rand10()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> [2,8]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [3,8,10]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What is the <a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">expected value</a> for the number of calls to <code>rand7()</code> function?</li>\n\t<li>Could you minimize the number of calls to <code>rand7()</code>?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 150301,
                "title": "three-line-java-solution-the-idea-can-be-generalized-to-implement-randm-using-randn",
                "content": "Idea: ```rand7()``` -> ```rand49()``` -> ```rand40()``` -> ```rand10()```\\n```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n}\\n```\\n#\\n### **Time Complexity**\\n#\\nThe total number of iterations follows **geometric distribution**. For each iteration in the ```while``` loop, the probabilty of exiting the loop is *p* = 40/49. So the average time complexity T(n) = O(1/*p*) = O(49/40) = O(1).\\n#\\n### **Correctness**\\n#\\nNote that rand49() generates a uniform random integer in [1, 49], so any number in this range has the same probability to be generated. Suppose *k* is an integer in range [1, 40], *P*(```rand49()``` = *k*) = 1/49.\\n\\n&nbsp;&nbsp;&nbsp;*P*(result = *k*)\\n= *P*(```rand49()``` = *k* in the 1st iteration) +\\n&nbsp;&nbsp;&nbsp;*P*(```rand49()``` > 40 in the 1st iteration) * *P*(```rand49()``` = *k* in the 2nd iteration) +\\n&nbsp;&nbsp;&nbsp;*P*(```rand49()``` > 40 in the 1st iteration) * *P*(```rand49()``` > 40 in the 2nd iteration) * *P*(```rand49()``` = *k* in the 3rd iteration) +\\n&nbsp;&nbsp;&nbsp;*P*(```rand49()``` > 40 in the 1st iteration) * *P*(```rand49()``` > 40 in the 2nd iteration) * *P*(```rand49()``` > 40 in the 3rd iteration) * *P*(```rand49()``` = *k* in the 4th iteration) +\\n&nbsp;&nbsp;&nbsp;...\\n= (1/49) + (9/49) * (1/49) + (9/49)^2 * (1/49) + (9/49)^3 * (1/49) + ...\\n= (1/49) * [1 + (9/49) + (9/49)^2 + (9/49)^3 + ... ]\\n= (1/49) * [1/(1-9/49)]\\n= (1/49) * (49/40)\\n= 1/40\\n#\\n### **Generalization**\\n#\\nImplement ```randM()``` using ```randN()``` when M > N:\\n**Step 1:** Use ```randN()``` to generate ```randX()```, where X >= M. In this problem,  I use ```7 * (rand7() - 1) + (rand7() - 1)``` to generate ```rand49() - 1```.\\n**Step 2:** Use ```randX()``` to generate ```randM()```. In this problem,  I use ```rand49()``` to generate ```rand40()``` then generate ```rand10```.\\n\\n**Note:** ```N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1)``` generates ```randX() - 1```, where ```X = N^(b + 1)```.\\n#\\n### **More Examples**\\n#\\n(1) Implement ```rand11()``` using ```rand3()```: \\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\\nIdea: ```rand3()``` -> ```rand27()``` -> ```rand22``` -> ```rand11```\\nTime Comlexity: O(27/22)\\n# \\n(2) Implement ```rand9()``` using ```rand7()```: \\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\\nIdea: ```rand7()``` -> ```rand49()``` -> ```rand45()``` -> ```rand9()```\\nTime Comlexity: O(49/45)\\n# \\n(3) Implement ```rand13()``` using ```rand6()```: \\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```\\nIdea: ```rand6()``` -> ```rand36()``` -> ```rand26``` -> ```rand13()```\\nTime Comlexity: O(36/26)",
                "solutionTags": [],
                "code": "```rand7()```\n```rand49()```\n```rand40()```\n```rand10()```\n```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n}\\n```\n```while```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```randM()```\n```randN()```\n```randN()```\n```randX()```\n```7 * (rand7() - 1) + (rand7() - 1)```\n```rand49() - 1```\n```randX()```\n```randM()```\n```rand49()```\n```rand40()```\n```rand10```\n```N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1)```\n```randX() - 1```\n```X = N^(b + 1)```\n```rand11()```\n```rand3()```\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\n```rand3()```\n```rand27()```\n```rand22```\n```rand11```\n```rand9()```\n```rand7()```\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\n```rand7()```\n```rand49()```\n```rand45()```\n```rand9()```\n```rand13()```\n```rand6()```\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```\n```rand6()```\n```rand36()```\n```rand26```\n```rand13()```",
                "codeTag": "Unknown"
            },
            {
                "id": 151567,
                "title": "c-java-python-1-183-call-of-rand7-per-rand10",
                "content": "# Solution 0: Easy Solution with random 49\\n\\n`rand7()` will get random 1 ~ 7\\n`(rand7() - 1) * 7 + rand7() - 1` will get random 0 ~ 48\\nWe discard `40 ~ 48`, now we have `rand40` equals to random 0 ~ 39.\\nWe just need to return `rand40 % 10 + 1` and we get random 1 ~ 10.\\n\\nIn `9/49` cases, we need to start over again.\\nIn `40/49` cases, we call `rand7()` two times.\\n\\nOverall, we need `49/40*2 = 2.45` calls of `rand7()` per `rand10()`.\\n\\n\\n**Java:**\\n```java\\n    public int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def rand10(self):\\n        rand40 = 40\\n        while rand40 >= 40:\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1\\n        return rand40 % 10 + 1\\n```\\n<br>\\n\\n# **Intuition of Improvement**:\\nSolution 0 is a good answer and you may pass a interview with this solution.\\nThe average call of `rand7` here is 2.45 calls.\\n\\nHowever, we may think about, what is the limit?\\nIs that possible to get an average of 2 calls.\\n<br>\\n\\n# **What is the Limit**\\nIt may seem impossible, but unfortunately, even average 2 is still far from the best answer.\\n\\nThe problem is that you generate 49 random states, waste 9 of them.\\nAnd we arrange the rest 40 states into 10 states.\\nYou can see that in that solution,\\n80% of random states waste and we satisfy with only 20% efficiency.\\n\\nDid a quick math for the limit `log10 / log7 = 1.1833`,\\nwhich lead me to find the following solution.\\n<br>\\n\\n# **Solution 1: instead of 49, we use bigger pow of 7**:\\n\\n`rand10()` will consume the generated random integer from stack `cache`.\\nIf `cache` is empty, it will call function `generate()`.\\n\\nIn `generate()`, it will generate an integer in range `[0, 7^19]`.\\n7^19 = 11398895185373143, and close to an pow of 10.\\nSo in 11398895185373140 / 11398895185373143 = 99.99999999999997% cases, it will generate at least 1 integer.\\nAnd in 10000000000000000 / 11398895185373143 = 87.73% cases, it will generate 16 integers.\\n\\n`N = 19` is the best we can choose in long integer range,\\nand `N = 7` is another good choice for 32 bits integer range.\\n\\nThis solution got average 1.199 calls, it\\'s really close to theoretic limit.\\n\\n**C++:**\\n```cpp\\n    stack<int> cache;\\n    int rand10() {\\n        while (cache.size() == 0) generate();\\n        int res = cache.top(); cache.pop();\\n        return res;\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = long(pow(7, n));\\n        for (int i = 0; i < n; ++i) cur += long(pow(7, i)) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push(cur % 10 + 1);\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\\n\\n**Java:**\\n```java\\n    Stack<Integer> cache = new Stack<Integer>();\\n    public int rand10() {\\n        while (cache.empty()) generate();\\n        return cache.pop();\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = (long)Math.pow(7, n);\\n        for (int i = 0; i < n; ++i) cur += (long)Math.pow(7, i) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push((int)(cur % 10 + 1));\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\\n**Python:**\\n```python\\n    cache = []\\n    def rand10(self):\\n        while not self.cache: self.generate()\\n        return self.cache.pop()\\n\\n    def generate(self):\\n        n = 19  # 1.199\\n        cur = sum((self.rand7() - 1) * (7**i) for i in range(n))\\n        rang = 7 ** n\\n        while cur < rang / 10 * 10:\\n            self.cache.append(cur % 10 + 1)\\n            cur /= 10\\n            rang /= 10\\n```\\n\\n\\n# Solution 2: No need to decide the pow in advance\\nSomeone may have a concern,\\nhow can we find a magic pow like 19 or 7?\\n\\nActually, we don\\'t need to.\\nContinue to improve the solution 1,\\nwe cache a big random number.\\nAnd when we need a rand10, we take a part from it.\\n\\n**Python**\\n```py\\n    cache, upper = 0, 1\\n    def rand10(self):\\n        cache, upper = self.cache, self.upper\\n        while upper < 10**9:\\n            cache, upper = cache * 7 + self.rand7() - 1, upper * 7\\n        res = cache % 10 + 1\\n        self.cache, self.upper = cache / 10, upper / 10\\n        self.count10 += 1  # test\\n        self.count[res] += 1  # test\\n        return res\\n```\\nThis solution will achieve 1.183 calls of `rand7()` per `rand10()`.\\n",
                "solutionTags": [],
                "code": "```java\\n    public int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\n```cpp\\n    int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\n```python\\n    def rand10(self):\\n        rand40 = 40\\n        while rand40 >= 40:\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1\\n        return rand40 % 10 + 1\\n```\n```cpp\\n    stack<int> cache;\\n    int rand10() {\\n        while (cache.size() == 0) generate();\\n        int res = cache.top(); cache.pop();\\n        return res;\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = long(pow(7, n));\\n        for (int i = 0; i < n; ++i) cur += long(pow(7, i)) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push(cur % 10 + 1);\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\n```java\\n    Stack<Integer> cache = new Stack<Integer>();\\n    public int rand10() {\\n        while (cache.empty()) generate();\\n        return cache.pop();\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = (long)Math.pow(7, n);\\n        for (int i = 0; i < n; ++i) cur += (long)Math.pow(7, i) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push((int)(cur % 10 + 1));\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\n```python\\n    cache = []\\n    def rand10(self):\\n        while not self.cache: self.generate()\\n        return self.cache.pop()\\n\\n    def generate(self):\\n        n = 19  # 1.199\\n        cur = sum((self.rand7() - 1) * (7**i) for i in range(n))\\n        rang = 7 ** n\\n        while cur < rang / 10 * 10:\\n            self.cache.append(cur % 10 + 1)\\n            cur /= 10\\n            rang /= 10\\n```\n```py\\n    cache, upper = 0, 1\\n    def rand10(self):\\n        cache, upper = self.cache, self.upper\\n        while upper < 10**9:\\n            cache, upper = cache * 7 + self.rand7() - 1, upper * 7\\n        res = cache % 10 + 1\\n        self.cache, self.upper = cache / 10, upper / 10\\n        self.count10 += 1  # test\\n        self.count[res] += 1  # test\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 338395,
                "title": "in-depth-straightforward-detailed-explanation-short-java-solution",
                "content": "Inspired by Vivekanand Kiruban from [link](https://www.quora.com/How-do-you-design-a-rand7-function-using-a-rand5-function).\\n\\nThere are three concepts in geometric distribution you need to know before you solve these kind of questions. They are very easy to understand.\\n\\n# Expanding a zero-based `random`\\n\\nLet\\'s say you have a `random10` which return a number from 0 to 9. How would you build `random100` which return from 0 to 99? \\nYou can call `random10` to generate each digit.  Specifically, `10*random10()` will generate the tens\\' place for a two digit number, and `1*random10()` will generate the ones\\' place. Then the biggest number `10*random10() + 1*random10()`  could produce is 10*9+1*9 = 99. The smallest number is `0`\\n```\\nrandom100 = 10*random10() + 1*random10()\\nrandom1000 = 100*random10() + 10*random10() + 1*random10()\\n```\\n\\nIf we change our definition of `random`, now `random10` will return a number from 1 to 10. Can we use the above formula to generate `random100`(1 to 100)? \\n\\nThe answer is **NO**.\\n\\nIf you think about it, the `10*random10() + 1*random10()` can only return a number from ~~2 to 101~~ 11 to 110., instead of 1 to 100.\\n\\nYou need to tweak the formula a little bit. Specifically, you need to zero-based your `random`.\\n\\n```\\nrandom100 = 10*(random10()-1) + 1*(random10()-1) + 1\\n```\\n\\nNotice that we need to `add 1` in the end because `10*(random10()-1) + 1*(random10()-1)` will result in a number from 0 to 99, and what we want is actually 1 to 100.\\n\\n# Discarding and Rolling again\\nIf you have a 6 sided dice and want to use it determine \"Head or Tail\" using this side, and if you get 1, say heads, if you get 2, say tails, and if you get anything else, you discard them by rolling again. This approach will guarantee an equivalent to H/T, but notice you may be rolling the die many times.\\n\\n# Folding to Map\\nIn the above example of dice, an another solution you have is mapping the other values into `H` or `T`. For example, 1,2,3 (= heads), 4,5,6 (= tails). When it comes to implementation, we can use module operator to do that.\\nE.g,\\n```\\nrandom3 = random6 % 3 // Assuming the random here is zero-based\\n```\\n\\n# Use the three concepts\\nWhat we have right now is 1-based random7, and we need to generate random10. Here are the steps we gonna go through:\\n1. zero-based `random7`: `random7-1`(0..6)\\n2. expanding zero-based `random7` to zero-based `random49`: `(random7-1)*7 + (random7-1)`\\n3. discarding the number over 40 by rolling again, then we get zero-based `random40`: \\n\\t```\\n\\twhile(random40>=40){\\n\\t\\trandom40 = (random7-1)*7 + (random7-1)\\n\\t}\\n\\t```\\n4. folding zero-based `random40` to one-based `random10`\\n\\t```\\n\\trandom10 = random40%10+1\\n\\t```\\n\\n\\nThe complete code:\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int rand40 = Integer.MAX_VALUE;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nrandom100 = 10*random10() + 1*random10()\\nrandom1000 = 100*random10() + 10*random10() + 1*random10()\\n```\n```\\nrandom100 = 10*(random10()-1) + 1*(random10()-1) + 1\\n```\n```\\nrandom3 = random6 % 3 // Assuming the random here is zero-based\\n```\n```\\n\\twhile(random40>=40){\\n\\t\\trandom40 = (random7-1)*7 + (random7-1)\\n\\t}\\n\\t```\n```\\n\\trandom10 = random40%10+1\\n\\t```\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int rand40 = Integer.MAX_VALUE;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816210,
                "title": "python-rejection-sampling-2-lines-explained",
                "content": "What we can do here is to generate numbers between `1` and `7` and this makes this problems both easy and difficult. Easy, because you do not have a lot of choice what to do, difficult, because we need to use not very big number of generations. Can we use one number between `1` and `7` to generate number between `1` and `10`? I do not think so, we have very small choice. Can we use `2`? Yes, we can, here is the strategy:\\n1. Generate `a` from `1` to `7` and `b` from `1` to `7`, then we have `7x7 = 49` options. Let us create number `c = (a-1)*7 + b-1`, then we can show that `c` is number between `0` and `48`: substitute all possible values for `a` and `b` and you will see. \\n2. Now, let us divide these number into groups: `[0,9]; [10;19]; [20;29]; [30;39]; [40;48]`. If we get into one of the first four group we are happy: there is ten number in each group, so we just return `c%10 + 1`.\\n3. If we are in the fifth group, we are not happy, there are only `9` numbers in this group and we need `10`, use `9` is not fair. So in these case, we say, that our experiment was not working, and we just start it all over again! That is all.\\n\\n**Complexity**: what we do here is called sampling with rejection. Success of first sampling is `p = 40/49`. If first time our sampling was not working and it worked second time we have `(1-p)*p`, if it worked third time it is `(1-p)*(1-p)*p` and so on. Each time we use two `rand7()` generation. So, overall our **expectation** is `2*p + 4*(1-p)*p + 6*(1-p)^2*p + ...` How to compute it? Note, that it is nothing else than geometrical distribution: https://en.wikipedia.org/wiki/Geometric_distribution, so the answer is just `2/p` = `98/40 = 2.45`.\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        c = (rand7() - 1)*7 + rand7() - 1\\n        return self.rand10() if c >= 40 else (c % 10) + 1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        c = (rand7() - 1)*7 + rand7() - 1\\n        return self.rand10() if c >= 40 else (c % 10) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373574,
                "title": "adding-two-random-numbers-won-t-produce-a-uniformly-distributed-new-random-number",
                "content": "A very important fact here is, adding two random numbers won\\'t make a new random number that is uniformly distributed.\\ne.g. \\nrandom1: 0~3\\nrandom2: 1~7\\nrandom1+random2 doesn\\'t make a random 1~10\\nThe combinations of random1 and random2 are uniformly distributed, but their sum are not, because some different combinations can have the same sum, this increases the probability of certain sum values.\\n\\nHowever, we can make a uniformly distributed 49 from random 7 this way:\\n(random7-1)\\\\*7+random7\\n\\nActually for any random \"n\":\\n\"(randomN-1)\\\\*n+randomN\" is uniformly distributed random n^2.\\n\\nAlso be aware that \"mod\" operation on a random doesn\\'t guarante a uniformly distributed result either. \"randomN%m\" is uniformly distributed only when n%m==0, that\\'s why rand40%10 works here.\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        rand40=40\\n        while rand40>=40:\\n            rand40=(rand7()-1)*7+rand7()-1\\n        return rand40%10+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        rand40=40\\n        while rand40>=40:\\n            rand40=(rand7()-1)*7+rand7()-1\\n        return rand40%10+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150312,
                "title": "easy-solution",
                "content": "```\\nint rand10() {\\n    int i,j;\\n    while( (i = rand7()) > 6);  // P(i is even) = P(i is odd) = 0.5\\n    while( (j = rand7()) > 5);  // P(j==1) = P(j==2) = P(j==3) = P(j==4) = P(j==5) = 0.2\\n    return (i&1) ? j : j+5;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n    int i,j;\\n    while( (i = rand7()) > 6);  // P(i is even) = P(i is odd) = 0.5\\n    while( (j = rand7()) > 5);  // P(j==1) = P(j==2) = P(j==3) = P(j==4) = P(j==5) = 0.2\\n    return (i&1) ? j : j+5;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322262,
                "title": "intuition-for-magic-number-40",
                "content": "Please go through https://leetcode.com/problems/implement-rand10-using-rand7/solution/ first.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1561741290.png)\\n*Credit*: https://leetcode.com/problems/implement-rand10-using-rand7/solution/\\n\\nNow, we have 49 cells and we want to randomly pick a number from 1 to 10. That means, any number from 1 to 10 should have equal chance of being picked that is `1/10`.\\nBut we have 49 cells and only 10 numbers, so only way for uniform distribution is to number them by repeating the 1 to 10 sequences but after 40, we do not have enough cells to complete the 1 to 10 sequnce.\\nUp to 40, we have four 1\\'s and four 2\\'s...four 10\\'s so they all have equal chance namely `4/40`. So we have to discard in order to not skew the distribution (without this part, it is not fair for 8, 9, 10 as they have smaller chance compared to numbers from 1 to 7).\\n\\n```\\npublic int rand10() {\\n        int r = 0, c = 0, num = 0;\\n        do{\\n            r = rand7();\\n            c = rand7();\\n            num = c+(r-1)*7;\\n        }while(num > 40);\\n        return 1 + num % 10;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rand10() {\\n        int r = 0, c = 0, num = 0;\\n        do{\\n            r = rand7();\\n            c = rand7();\\n            num = c+(r-1)*7;\\n        }while(num > 40);\\n        return 1 + num % 10;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816213,
                "title": "c-simple-2-steps-solution-explained-100-time-60-space",
                "content": "My main intuition was that `7 == 2 + 5` and `2 * 5 == 10`.\\n\\nSeems still too abstract (or absurd)? Bear with me!\\n\\nFirst of all we declare 2 variables, `n` and `m`, settimg them initially to be `rand7()` and `7`.\\n\\nThen we make sure tha `n` is only in the `1 - 5` range and, if not, we regenerate it and assign `n - 5` to `m`, that thus would be in the `1 - 2` range. Notice that in this way `n` and `m` have the same probabiliy of still being each specific number in their own range.\\n\\nIn the second loop, we make sure that `m` has a `1 - 6` value, with similar logic of regenerating numbers until we need them.\\n\\nFinally we return `n` + either `0` or `5`, depending if `m` is even or odd, respectively.\\n\\nThis gives us perfectly distributed numbers :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int n, m;\\n    int rand10() {\\n        // initialising the values\\n\\t\\tn = rand7(), m = 7;\\n        // making sure n is in the right 1-5 range and, if we can, we settle m too\\n\\t\\twhile (n > 5) {\\n            m = n - 5;\\n            n = rand7();\\n        }\\n        // if m was not settled, we do it here\\n\\t\\twhile (m == 7) m = rand7();\\n        return (m % 2 ? 5 : 0) + n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int n, m;\\n    int rand10() {\\n        // initialising the values\\n\\t\\tn = rand7(), m = 7;\\n        // making sure n is in the right 1-5 range and, if we can, we settle m too\\n\\t\\twhile (n > 5) {\\n            m = n - 5;\\n            n = rand7();\\n        }\\n        // if m was not settled, we do it here\\n\\t\\twhile (m == 7) m = rand7();\\n        return (m % 2 ? 5 : 0) + n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175450,
                "title": "java-solution-explain-this-problem-with-2d-matrix",
                "content": "```\\npublic int rand10() {\\n        while (true) {\\n            int num = (rand7() - 1) * 7 + (rand7() - 1);\\n            if (num < 40) {\\n                return num % 10 + 1;\\n            }\\n        }\\n    }\\n```\\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    10   11   12   13\\n2    14   15   16   17   18   19   20\\n3    21   22   23   24   25   26   27\\n4    28   29   30   31   32   33   34\\n5    35   36   37   38   39   40   41\\n6    42   43   44   45   46   47   48\\n```\\nwe just do the mod operation in the first 40 element\\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    0    1    2    3\\n2    4    5    6    7    8    9    0\\n3    1    2    3    4    5    6    7\\n4    8    9    0    1    2    3    4\\n5    5    6    7    8    9    0    X\\n6    X    X    X    X    X    X    X\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int rand10() {\\n        while (true) {\\n            int num = (rand7() - 1) * 7 + (rand7() - 1);\\n            if (num < 40) {\\n                return num % 10 + 1;\\n            }\\n        }\\n    }\\n```\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    10   11   12   13\\n2    14   15   16   17   18   19   20\\n3    21   22   23   24   25   26   27\\n4    28   29   30   31   32   33   34\\n5    35   36   37   38   39   40   41\\n6    42   43   44   45   46   47   48\\n```\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    0    1    2    3\\n2    4    5    6    7    8    9    0\\n3    1    2    3    4    5    6    7\\n4    8    9    0    1    2    3    4\\n5    5    6    7    8    9    0    X\\n6    X    X    X    X    X    X    X\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817311,
                "title": "java-code-with-comments-explained-for-begineer-like-me",
                "content": "* ***Please upvote if helpful!!***\\n* This approach is known as rejection sampling.\\n```\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n      \\n        //we try to pick values in the range from 7 * 7 = 49 values\\n        //as we want 1 - 10 uniform random values. we can only go till 40 as\\n        //41- 49 only has 9 numbers and hence our uniformity will be broken.\\n        \\n        int column = rand7();\\n        int row = rand7();\\n\\n        int val = (column) + (row - 1) * 7; // if u make a grid of 7 * 7 u will observe that values from all the columns are possible\\n        // and value from last row is not possible as it belongs in the range greater than 40.\\n        //we find the value using the above formula column + (row - 1) * 7.\\n        \\n        if (val <= 40) {\\n            return (val - 1) % 10 + 1; // this needs to be done to handle edge case if we encounter 10. if we just do 10 % 10 we get 0. and we want 1-10.\\n        } else {\\n            return rand10(); //recursive call if we dont find value less than or equal to 40 for uniform distribution.\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n      \\n        //we try to pick values in the range from 7 * 7 = 49 values\\n        //as we want 1 - 10 uniform random values. we can only go till 40 as\\n        //41- 49 only has 9 numbers and hence our uniformity will be broken.\\n        \\n        int column = rand7();\\n        int row = rand7();\\n\\n        int val = (column) + (row - 1) * 7; // if u make a grid of 7 * 7 u will observe that values from all the columns are possible\\n        // and value from last row is not possible as it belongs in the range greater than 40.\\n        //we find the value using the above formula column + (row - 1) * 7.\\n        \\n        if (val <= 40) {\\n            return (val - 1) % 10 + 1; // this needs to be done to handle edge case if we encounter 10. if we just do 10 % 10 we get 0. and we want 1-10.\\n        } else {\\n            return rand10(); //recursive call if we dont find value less than or equal to 40 for uniform distribution.\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816927,
                "title": "python-generalised-solution-for-randm-using-randn",
                "content": "**Solution for creating rand10() using rand7()**\\n\\n```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        curr = 40\\n        while curr >= 40:\\n            curr = (rand7() - 1) * 7 + rand7() - 1\\n        return curr % 10 + 1\\n```\\n    \\n**Generalised solution for creating randM() using randN()**\\n\\n```python\\n# The randN() API is already defined for you.\\n# def randN():\\n# @return a random integer in the range 1 to M\\n\\nclass Solution:\\n    def randM(self, N, M):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # acceptable is the desired range which can generate required integer directly\\n        curr = acceptable = N * N - (N * N) % M \\n        # if current no is not in the acceptable range, discard it and repeat the process again\\n        while curr >= acceptable:\\n            curr = (randN() - 1) * N + randN() - 1\\n        return curr % M + 1\\n\\t\\t\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        curr = 40\\n        while curr >= 40:\\n            curr = (rand7() - 1) * 7 + rand7() - 1\\n        return curr % 10 + 1\\n```\n```python\\n# The randN() API is already defined for you.\\n# def randN():\\n# @return a random integer in the range 1 to M\\n\\nclass Solution:\\n    def randM(self, N, M):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # acceptable is the desired range which can generate required integer directly\\n        curr = acceptable = N * N - (N * N) % M \\n        # if current no is not in the acceptable range, discard it and repeat the process again\\n        while curr >= acceptable:\\n            curr = (randN() - 1) * N + randN() - 1\\n        return curr % M + 1\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278864,
                "title": "470-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named rand10() that takes no arguments and returns an integer between 1 and 10.\\n2. Use a while loop that runs indefinitely until a suitable random number is generated.\\n3. Within the loop, use the rand7() function twice to generate a random number num in the range [1, 49].\\n4. Check if num is within the range [1, 40]. If not, continue to the next iteration of the while loop.\\n5. If num is within the range [1, 40], exit the while loop and return a value between 1 and 10.\\n6. To obtain the random integer within the range [1, 10], use the modulus operator to find the remainder of dividing num by 10 and add 1 to the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice\\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus\\n        return num % 10 + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Randomized",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice\\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus\\n        return num % 10 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151045,
                "title": "generalize-implement-randm-using-randn",
                "content": "## Idea\\n\\nMore general case for this kind of problem is this: \\n\\nSuppose we are given `randM()` which generates `[1, 2, ..., M]`, we want to generate `randN()` which generates `[1, 2, ..., N]`. Here are different cases:\\n\\n1. if N < M, then we can select 1, 2, ..., N, ~~N+1, N+2, ..., M~~ from `randM()`, as we know that `[1, 2, ..., N]` each with prob `1/M`, since the algorithm terminates when the generated number less than `N+1`. Hence we have the uniform distribution. \\n2.  M < N < M^2, then we can construct `randM^2() = M * (randM()-1) + randM()`, still we can select 1, 2, M, ..., N, ~~N+1, N+2, ..., M^2~~, as we know that `[1, 2, ..., N]` each with prob `1/M^2`, since the algorithm terminates when the generated number less than `N+1`. Hence we have the uniform distribution. \\n3. ......\\n\\nThe idea is that we can construct `randM^n = M * (randM^(n-1)-1) + randM^(n-1)` recursively. And then select accordingly. \\n\\n```\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 11\\n        while res > 10:\\n            res = (rand7() - 1) * 7 + rand7()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 11\\n        while res > 10:\\n            res = (rand7() - 1) * 7 + rand7()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150700,
                "title": "very-easy-3-lines-solution-in-c-explained",
                "content": "Since `rand7()` generate `1 to 7`, I subtract `1` everytime to get numbers from `0 to 6`.\\nNow the combination `7*(rand7()-1) + rand7()-1` will generate `0 to 48`, since we are targeting `0 to 39` as a multiple of `0 to 9` ( we can add 1 later to make it `1 to 10`) we need to discard anything above `39`. In that case we regenerate the number.\\n**If you have any question, ask me in comment. Thanks.**\\n\\n```\\n        int num;\\n        \\n        while((num = (7*(rand7()-1) + rand7()-1)) >= 40) ;\\n        \\n        return (num%10 + 1);        \\n```",
                "solutionTags": [],
                "code": "```\\n        int num;\\n        \\n        while((num = (7*(rand7()-1) + rand7()-1)) >= 40) ;\\n        \\n        return (num%10 + 1);        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816612,
                "title": "python-o-1-1-call-linear-congruential-generator",
                "content": "Detail and formula referred [https://en.wikipedia.org/wiki/Linear_congruential_generator](https://en.wikipedia.org/wiki/Linear_congruential_generator)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.pre=0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        cur=(self.pre*7+rand7())%10+1\\n        self.pre=cur\\n        return cur\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.pre=0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        cur=(self.pre*7+rand7())%10+1\\n        self.pre=cur\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972843,
                "title": "c-recursion-intuition-explanation",
                "content": "# Intuition\\nFor understanding the intuition let\\'s first see why simple sampling ``` rand7()*rand7() ``` didn\\'t work:\\n![Screenshot (15).png](https://assets.leetcode.com/users/images/a8e8815a-8423-4eb6-b6bd-a54f5f35122f_1672430161.8377426.png)\\n(Note: Above example is only for intuition and consider output sample space as `[1-49]`, not just `[1-10]`)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter Trying some of the other sampling methods``` (7*(rand7()-1) + rand7())%10 + 1 ``` seemed to work really fine. Here is the comparision between the two sampling I mentioned `rand7()*rand7()` and `7*(rand7()-1) + rand7()` after applying `mod 10 + 1` operation:\\n```\\nfor (7*(rand7()-1) + rand7())%10 + 1 (uniformly distributed):\\n1 occurs : 4 times.\\n2 occurs : 5 times.\\n3 occurs : 5 times.\\n4 occurs : 5 times.\\n5 occurs : 5 times.\\n6 occurs : 5 times.\\n7 occurs : 5 times.\\n8 occurs : 5 times.\\n9 occurs : 5 times.\\n10 occurs : 5 times.\\n\\nfor (rand7()*rand7())%10 + 1 (not uniformly distributed):\\n1 occurs : 6 times.\\n2 occurs : 3 times.\\n3 occurs : 8 times.\\n4 occurs : 2 times.\\n5 occurs : 7 times.\\n6 occurs : 7 times.\\n7 occurs : 6 times.\\n8 occurs : 2 times.\\n9 occurs : 6 times.\\n10 occurs : 2 times.\\n\\n```\\n**NOTE :**\\n> **$$Question 1.$$ : All things considered, We still haven\\'t figured out why use `mod 10 + 1`?**\\n$$Answer$$ : To perform optimized Rejection Sampling!, As each of the number in our sampling has equal probability of occuring, we try to make `provability of failure(repeat the experiment) as small as possible and probability of success as much as possible`. We are doing this by decreasing the size of rejected samples. Here we are rejecting only 9 of the outputs (from 41 to 49) using `mod 10 + 1` and other `[1, 40]` are accepted, because these outputs are of same size `10 + 10 + 10 + 10`.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // probability of success -- (40/49)\\n        // probability of failure(repeat) -- (9/49)\\n        return (temp > 40 ? rand10() : temp%10 + 1);\\n    }\\n};\\n```\\n# Code 2\\n##### not performing optimized rejection sampling \\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // Simply rejecting all outputs other than [1,10];\\n        // probability of success -- (10/49)\\n        // probability of failure(repeat) -- (39/49)\\n        return (temp > 10 ? rand10() : temp);\\n    }\\n};\\n```\\n**NOTE: Here Optimization can also be thought of `probability of succes event!!!`**\\n\\nP.S. If helpful, consider upvoting\\u2763\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion",
                    "Rejection Sampling",
                    "Probability and Statistics"
                ],
                "code": "``` rand7()*rand7() ```\n``` (7*(rand7()-1) + rand7())%10 + 1 ```\n```\\nfor (7*(rand7()-1) + rand7())%10 + 1 (uniformly distributed):\\n1 occurs : 4 times.\\n2 occurs : 5 times.\\n3 occurs : 5 times.\\n4 occurs : 5 times.\\n5 occurs : 5 times.\\n6 occurs : 5 times.\\n7 occurs : 5 times.\\n8 occurs : 5 times.\\n9 occurs : 5 times.\\n10 occurs : 5 times.\\n\\nfor (rand7()*rand7())%10 + 1 (not uniformly distributed):\\n1 occurs : 6 times.\\n2 occurs : 3 times.\\n3 occurs : 8 times.\\n4 occurs : 2 times.\\n5 occurs : 7 times.\\n6 occurs : 7 times.\\n7 occurs : 6 times.\\n8 occurs : 2 times.\\n9 occurs : 6 times.\\n10 occurs : 2 times.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // probability of success -- (40/49)\\n        // probability of failure(repeat) -- (9/49)\\n        return (temp > 40 ? rand10() : temp%10 + 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // Simply rejecting all outputs other than [1,10];\\n        // probability of success -- (10/49)\\n        // probability of failure(repeat) -- (39/49)\\n        return (temp > 10 ? rand10() : temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673547,
                "title": "c-solution-2-lines-beats-92-in-the-running-time",
                "content": "Idea : \\nGenerate uniform distribution between [0, 1], Then using this distribution we can generate rand10()\\n\\n```class Solution {\\npublic:\\n    int rand10() {\\n        double b =  (49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)) /  343.0;\\n        return (int)(b * 10) + 1; \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int rand10() {\\n        double b =  (49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)) /  343.0;\\n        return (int)(b * 10) + 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373385,
                "title": "javascript-solution-straightforward",
                "content": "The idea is to play around with probalibilities (see comments in code below).\\nAdopted from [@niwota](https://leetcode.com/niwota) and [@hwei002](https://leetcode.com/hwei002) --> [here](https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150312/Easy-solution). \\n```\\nvar rand10 = function() {\\n  let i = 7;\\n  let j = 6;\\n  while (i > 6) i = rand7(); // i could be 1, 2, 3, 4, 5, or 6\\n  while (j > 5) j = rand7(); // j could be 1, 2, 3, 4, or 5\\n  if (i % 2 === 0) { // if i end up being even (50% the chance because it could be 2, 4, 6)\\n    return j; // return 1, 2, 3, 4, or 5\\n  } else { //if i end up being odd (also 50% of the chance because it could be 1, 3, 5)\\n    return j + 5; // return 6, 7, 8, 9, or 10\\n  }\\n};\\n```\\n\\nI found this solution better in terms of understanding. Hope it also helps you guys!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rand10 = function() {\\n  let i = 7;\\n  let j = 6;\\n  while (i > 6) i = rand7(); // i could be 1, 2, 3, 4, 5, or 6\\n  while (j > 5) j = rand7(); // j could be 1, 2, 3, 4, or 5\\n  if (i % 2 === 0) { // if i end up being even (50% the chance because it could be 2, 4, 6)\\n    return j; // return 1, 2, 3, 4, or 5\\n  } else { //if i end up being odd (also 50% of the chance because it could be 1, 3, 5)\\n    return j + 5; // return 6, 7, 8, 9, or 10\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826682,
                "title": "easy-python",
                "content": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        total_sum = 0\\n        \\n        for i in range(10):\\n            total_sum += rand7()\\n        \\n        return (total_sum % 10) + 1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        total_sum = 0\\n        \\n        for i in range(10):\\n            total_sum += rand7()\\n        \\n        return (total_sum % 10) + 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492184,
                "title": "wrong-solution",
                "content": "**UPD:** I figured out that this solution is wrong. My mistake was here:\\n* `6` with probability ~~`3`/9~~ `2`/8\\n\\nAnd this mistake invalidates everything. So, don\\'t read this, you will not find anything useful here. I just retain text below for history.\\n\\n---\\n---\\n---\\n\\n**Previous title:** `O(constant) worst-case. Never presented before!`\\n\\nWe know how to generate smaller `rand` using larger `rand` using rejection sampling. But can you do reverse without generating a larger `rand`? Yes, and this approach works without `O(\\u221E)` time worst-case.\\n\\nImagine you want to generate `rand3` by knowing `rand2`. We need to distribute same probabilities on `1`, on `2` and on `3`. Let\\'s call `rand2` three times and smartly map our numbers:\\n* `rand2` \\u2192 `{1, 2}` = `a`\\n* `rand2` \\u2192 `{1, 3}` = `b`\\n* `rand2` \\u2192 `{2, 3}` = `c`\\n\\nEach number in `[1, 3]` range shows exactly twice. What next can we do with these numbers? We can sum them up. If we do so, then we will get these numbers:\\n`s` = `a + b + c` =\\n* `4` with probability `1`/9\\n* `5` with probability `2`/9\\n* `6` with probability `3`/9\\n* `7` with probability `2`/9\\n* `8` with probability `1`/9\\n\\nIf we make `(s-1) % 3` then we will get these numbers and probabilities:\\n* `0` with probability `3`/9 (from `4` and `7`)\\n* `1` with probability `3`/9 (from `5` and `8`)\\n* `2` with probability `3`/9 (from `6`)\\n\\nNow you know how to generate `rand3` using `rand2` by calling it exactly 3 times!\\n\\n---\\n\\nAnd let\\'s define a **mapping matrix** for this case:\\n```\\n1 1 0\\n1 0 1\\n0 1 1\\n```\\n\\nProperties\\n* Count of ones in each row represent source random degree. \\n\\t* In this case it\\'s 2.\\n* Count of zeros represent target random degree minus source random degree. \\n\\t* In this case it\\'s 3-2 = 1.\\n* Each line is a permutation of string got from the previous two items. \\n\\t* In this case it\\'s `110`.\\n* If we sum numbers in each column, we will get the same numbers, which means that each number has the same probability to occur.\\n\\t* In this case sum equals 2.\\n* We can use this matrix to map smartly map numbers from source random generator.\\n\\t* In our case it was:\\n\\t\\t* `rand2` \\u2192 `{1, 2}` = `a`\\n\\t\\t* `rand2` \\u2192 `{1, 3}` = `b`\\n\\t\\t* `rand2` \\u2192 `{2, 3}` = `c`\\n\\n---\\n\\nNow, image if we want to generate `rand5` using `rand3`, we will get this mapping matrix:\\n```\\n00111\\n01011\\n01101\\n01110\\n10011\\n10101\\n10110\\n11001\\n11010\\n11100\\n```\\n\\nWhich are just all permutations of `00111`.\\n\\nIf you sum numbers in each column, you will get 6, which means that every number has the same probability to occur in the target sum.\\n\\nAnd by this, you can get `rand5` from `rand7` by calling it 10 times.\\n\\n---\\n\\nAnd the general formula is:\\n\\nIf we want to generate `randN` from `randK` where `K` < `N`, we will call `randK` exactly `N choose K` times( `N!/(K!*(N-K)!)`) ([combination](https://en.wikipedia.org/wiki/Combination)).\\n\\nWhich is equal to `N` when `N = K+1`, but getting worse when `K` approaches `N/2`.\\n\\nIn our original task, it will be equal to `10 choose 7 = 120`. But has no worst-case scenario! :)",
                "solutionTags": [],
                "code": "```\\n1 1 0\\n1 0 1\\n0 1 1\\n```\n```\\n00111\\n01011\\n01101\\n01110\\n10011\\n10101\\n10110\\n11001\\n11010\\n11100\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817220,
                "title": "python-2-ways-w-explanation",
                "content": "**METHOD 1: Expanding a zero based random**\\n\\nSay that the range of rand10() is [0,9], then, to produce rand100(), we would need a 2 digit number. \\nThus, we can do the follows: \\nrand100() = 10 * rand10() + rand10()\\n\\nIf the range were [1,10], the above can be modified as rand100() = 10 * ( rand10() - 1) + ( rand10() - 1)\\nUsing the same logic, rand10() using rand7() can be formulated as generating rand49() and then ensuring that it is within the output range i.e. [1,10]. \\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        rand49 = float(\\'inf\\')\\n        while rand49 >= 40:\\n            rand49 = 7 * (rand7() - 1) + (rand7() - 1)\\n        # Since rand49 % 10 => [0, 9] and the output has to be in range [1,10]\\n        return rand49 % 10 + 1 \\n```\\n\\n**METHOD 2: Mapping Rule**\\n\\nThe range of rand7() is [1,7] i.e. {1,2,3,4,5,6,7}\\nThe range of rand10() is [1,10] i.e. {1,2,3,4,5,6,7,8,9,10}\\n\\nHere, we need to map 7 values to 10 values. Thus, we divide the output values into two parts [1,5] and [6,10]. \\n(Further explanation in the code) \\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# Method 2: Mapping Rule \\n        val1, val2 = rand7(), rand7()\\n\\t\\t\\n\\t\\t# val1 : {1,2,3,4,5,6,7} : Here, {6,7} are ignored to ensure equal probability for [1,5]\\n        while val1 > 5: val1 = rand7()\\n\\t\\t\\n\\t\\t# val2: {1,2,3,4,5,6,7} : Here, [1,3] correspond to [1,5] in the output and [4,6] correspond to [6,10]\\n\\t\\t# {7} has been ignored to ensure equal probability distribution\\n        while val2 == 7: val2 = rand7()\\n\\t\\t\\n        return val1 if val2 <= 3 else val1 + 5\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        rand49 = float(\\'inf\\')\\n        while rand49 >= 40:\\n            rand49 = 7 * (rand7() - 1) + (rand7() - 1)\\n        # Since rand49 % 10 => [0, 9] and the output has to be in range [1,10]\\n        return rand49 % 10 + 1 \\n```\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# Method 2: Mapping Rule \\n        val1, val2 = rand7(), rand7()\\n\\t\\t\\n\\t\\t# val1 : {1,2,3,4,5,6,7} : Here, {6,7} are ignored to ensure equal probability for [1,5]\\n        while val1 > 5: val1 = rand7()\\n\\t\\t\\n\\t\\t# val2: {1,2,3,4,5,6,7} : Here, [1,3] correspond to [1,5] in the output and [4,6] correspond to [6,10]\\n\\t\\t# {7} has been ignored to ensure equal probability distribution\\n        while val2 == 7: val2 = rand7()\\n\\t\\t\\n        return val1 if val2 <= 3 else val1 + 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816438,
                "title": "a-simple-explanation-of-rejection-sampling",
                "content": "Generate a random number between 1 and 7. If it\\'s 1, 2, or 3, generate a number between 1 and 5 (which is explained later). If 4, 5, or 6, generate a number between 6 and 10. If 7, simply try again. It\\'s that dumb.\\n\\nNow how to generate a number between 1 and 5? The same method. Generate a number between 1 and 7. If it\\'s 1, 2, 3, 4, or 5, return it. If 6 or 7, try again.\\n\\n```golang\\nfunc rand10() int {\\n\\tx := rand7()\\n\\tif x <= 3 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn y\\n\\t}\\n\\tif x <= 6 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn 11 - y\\n\\t}\\n\\treturn rand10()\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc rand10() int {\\n\\tx := rand7()\\n\\tif x <= 3 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn y\\n\\t}\\n\\tif x <= 6 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn 11 - y\\n\\t}\\n\\treturn rand10()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816392,
                "title": "incorrect-implementation-of-rand7-in-rust",
                "content": "It seems that rand7() in Rust returns a number from 1 to 6 inclusive. To fix this just create your own rand7() function, for example like the following code:\\n```\\n// call mrand7() instead of rand7() in your solution\\nfn mrand7() -> i32 {\\n    use rand::{thread_rng, Rng};\\n    let mut rng = thread_rng();\\n    rng.gen_range(1, 8)\\n}\\n\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n\\t\\t...\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// call mrand7() instead of rand7() in your solution\\nfn mrand7() -> i32 {\\n    use rand::{thread_rng, Rng};\\n    let mut rng = thread_rng();\\n    rng.gen_range(1, 8)\\n}\\n\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n\\t\\t...\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151058,
                "title": "1-18-rand7-calls-per-rand10",
                "content": "If we assume that ```rand7()``` calls are expensive and that we need to call rand10 at least a few hundred times, we can do better than the CTCI solution, which wastes bits by applying a modulus. The tradeoff is that the startup is more expensive, since we need to call ```rand7``` multiple times and cache some results.\\n\\nIf we treat n calls to rand7() as a base 7 number, we can get an equivalent base10 number.\\n\\n```\\nd0 = 7**0*(rand7() - 1)\\nd1 = 7**1*(rand7() - 1)\\ndlast = 7**(n-1)*(rand7()-1)\\ntotal = d0+d1+...+dlast\\n```\\n\\nThis total number gives us a uniform range of ```[0, 7**n-1]```.\\n\\nTo get a uniform range of ```[0, 10**i]```, we need to throw away the top range. So we need to find a ```7**n``` that wastes the least numbers.\\n\\nOn a whiteboard, you can probably hand-wave this number. In a setting where you can run scripts, you can scan for favorable numbers by looking through this list:\\n\\n```\\nfor i in range(1000):\\n  result = 7**i\\n  if str(result).startswith(\\'100\\'):\\n\\t  print(i, result, len(str(result))) # print power, number, and the number of base 10 digits\\n```\\n\\nWe see some output:\\n\\n```510, <big number starting with 10000009>, 432```\\n\\nWhich means:\\n\\n```7**510 ~= 1.0000009*10**431```\\n\\nSo, when we call ```rand7``` 510 times, we get a uniform range ```[0, 7**510-1]``` which is ```[0, 1.0000009*10**431]```\\n\\nWhenever the result is within our designed range, we win! We got 431 ```rand10``` numbers that we can cache.\\n\\nWhenever the result is greater than or equal to ```10**431```, we throw it away and call ```rand7``` another 510 times. This is expensive, but it should happen very rarely since we chose the number of ```rand7``` calls optimally `P=0.0000009/1.0000009 ~= 1 out of 100,000 times`\\n\\nThis way, we have an efficiency of ```1.18``` ```(510/431)```, because we get 431 ```rand10()``` calls for every 510 ```rand7()``` calls.\\n\\nThe wastage is negligible because the top range is so small.\\n\\n```\\ntotal calls (510k/431)\\nk = 1 + 0.0000009^1 + 0.0000009^2 + ...\\n0.0000009k = 0.0000009^1 + 0.0000009^2 + 0.0000009^3 + ...\\n0.9999991k = 1\\nk = 1/0.9999991 ~= 1.0000009\\n510k/431 = 1.0000009*510/431 ~= 1.18\\n```\\n\\nHere\\'s the code in Python:\\n```\\nclass Entropy:\\n\\tdef __init__(self):\\n\\t\\tself._store = []\\n\\t\\n\\tdef get(self):\\n\\t\\twhile not len(self._store):\\n\\t\\t\\tself._generate()\\n\\t\\treturn self._store.pop()\\n\\t\\n\\tdef _generate(self):\\n\\t\\tresult = sum([(rand7()-1)*(7**i) for i in range(510)])\\n\\t\\tif result >= 10**431:\\n\\t\\t\\treturn\\n\\t\\tfor i in range(431):\\n\\t\\t\\tself._store.append(1+(result % 10))\\n\\t\\t\\tresult //= 10\\n\\t\\t\\t\\nclass Solution:\\n\\tdef __init__(self):\\n\\t\\tself._entropy = Entropy()\\n\\t\\n\\tdef rand10(self):\\n\\t\\treturn self._entropy.get()\\n```",
                "solutionTags": [],
                "code": "```rand7()```\n```rand7```\n```\\nd0 = 7**0*(rand7() - 1)\\nd1 = 7**1*(rand7() - 1)\\ndlast = 7**(n-1)*(rand7()-1)\\ntotal = d0+d1+...+dlast\\n```\n```[0, 7**n-1]```\n```[0, 10**i]```\n```7**n```\n```\\nfor i in range(1000):\\n  result = 7**i\\n  if str(result).startswith(\\'100\\'):\\n\\t  print(i, result, len(str(result))) # print power, number, and the number of base 10 digits\\n```\n```510, <big number starting with 10000009>, 432```\n```7**510 ~= 1.0000009*10**431```\n```rand7```\n```[0, 7**510-1]```\n```[0, 1.0000009*10**431]```\n```rand10```\n```10**431```\n```rand7```\n```rand7```\n```1.18```\n```(510/431)```\n```rand10()```\n```rand7()```\n```\\ntotal calls (510k/431)\\nk = 1 + 0.0000009^1 + 0.0000009^2 + ...\\n0.0000009k = 0.0000009^1 + 0.0000009^2 + 0.0000009^3 + ...\\n0.9999991k = 1\\nk = 1/0.9999991 ~= 1.0000009\\n510k/431 = 1.0000009*510/431 ~= 1.18\\n```\n```\\nclass Entropy:\\n\\tdef __init__(self):\\n\\t\\tself._store = []\\n\\t\\n\\tdef get(self):\\n\\t\\twhile not len(self._store):\\n\\t\\t\\tself._generate()\\n\\t\\treturn self._store.pop()\\n\\t\\n\\tdef _generate(self):\\n\\t\\tresult = sum([(rand7()-1)*(7**i) for i in range(510)])\\n\\t\\tif result >= 10**431:\\n\\t\\t\\treturn\\n\\t\\tfor i in range(431):\\n\\t\\t\\tself._store.append(1+(result % 10))\\n\\t\\t\\tresult //= 10\\n\\t\\t\\t\\nclass Solution:\\n\\tdef __init__(self):\\n\\t\\tself._entropy = Entropy()\\n\\t\\n\\tdef rand10(self):\\n\\t\\treturn self._entropy.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767851,
                "title": "easy-python-solution-with-multiple-approaches-faster-than-99",
                "content": "* **Generated Random Number without using rand7() API**\\n* ps: i just generated a random number in the range [1,10]\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    count = 0;\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        random = [1,2,3,4,5,6,7,8,9,10]\\n        self.count += 1; c = 0\\n        if (self.count & 1):\\n            for i in range(2,10,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n        else:\\n            for i in range(1,9,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n            \\n```\\n* time Complexity: O(1)  => Constant time\\n\\n* **Approach 2: Using rand7() API**\\n```\\ndef rand10(self):\\n        rand = 40\\n        while rand >= 40:\\n            rand = (rand7() - 1) * 7 + rand7() - 1\\n        return rand % 10 + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    count = 0;\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        random = [1,2,3,4,5,6,7,8,9,10]\\n        self.count += 1; c = 0\\n        if (self.count & 1):\\n            for i in range(2,10,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n        else:\\n            for i in range(1,9,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n            \\n```\n```\\ndef rand10(self):\\n        rand = 40\\n        while rand >= 40:\\n            rand = (rand7() - 1) * 7 + rand7() - 1\\n        return rand % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067513,
                "title": "python-at-max-5-rand-calls",
                "content": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        v1 = rand7()\\n        while v1 == 6 or v1 == 7:\\n            v1 = rand7()\\n            \\n        \\n        v2 = rand7()\\n        while v2 == 7:\\n            v2 = rand7()\\n            \\n        \\n        if(v2 <= 3):\\n            return v1\\n        \\n        return v1+5\\n```",
                "solutionTags": [],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        v1 = rand7()\\n        while v1 == 6 or v1 == 7:\\n            v1 = rand7()\\n            \\n        \\n        v2 = rand7()\\n        while v2 == 7:\\n            v2 = rand7()\\n            \\n        \\n        if(v2 <= 3):\\n            return v1\\n        \\n        return v1+5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816490,
                "title": "implement-rand10-using-rand7-very-simple-explanation",
                "content": "```\\n\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        #we can genearate numbers 8 to 56 using (c)= 7*rand7()+rand7()\\n        #with equal probalilty   we need to genearte    from one to 10\\n        # so all sholuld be gen with eq probailty\\n        #so to occur\"1\" there are numbers{11,21,...51} which are 5 choices when we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n**      So here we have  probability different for number \"1\" and \"8\"\\n**        # inorder to make equal we take cut of from 11 to 50\\n        \\n         #so to occur\"1\" there are numbers{11,21,...41} which are 4 choiceswhen we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {20,......50}  only 4 choices when we do mod(10)\\n        # so all 1 to 10 will equally occur\\n        val=7*rand7()+rand7()\\n        print(val)\\n        while val>50 or val<11:\\n            print(val,\"sd\")\\n            val=7*rand7()+rand7()\\n            \\n        \\n        return val%10 if val%10!=0 else 10\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        #we can genearate numbers 8 to 56 using (c)= 7*rand7()+rand7()\\n        #with equal probalilty   we need to genearte    from one to 10\\n        # so all sholuld be gen with eq probailty\\n        #so to occur\"1\" there are numbers{11,21,...51} which are 5 choices when we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n**      So here we have  probability different for number \"1\" and \"8\"\\n**        # inorder to make equal we take cut of from 11 to 50\\n        \\n         #so to occur\"1\" there are numbers{11,21,...41} which are 4 choiceswhen we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {20,......50}  only 4 choices when we do mod(10)\\n        # so all 1 to 10 will equally occur\\n        val=7*rand7()+rand7()\\n        print(val)\\n        while val>50 or val<11:\\n            print(val,\"sd\")\\n            val=7*rand7()+rand7()\\n            \\n        \\n        return val%10 if val%10!=0 else 10\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816365,
                "title": "c-super-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int res = 0;\\n        for (int i=0; i<7; i++)\\n            res += rand7();\\n        return res%10 + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int res = 0;\\n        for (int i=0; i<7; i++)\\n            res += rand7();\\n        return res%10 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816238,
                "title": "c-c-simple-solution-96-faster-with-explanation",
                "content": "```\\nint rand10() \\n{\\n    int random = 0;\\n    for(int i = 0; i < 7; i++)\\n        random += rand7();\\n        \\n\\t//random can be max 49 so if we do modulo 10 and add 1 we can get any number between 1 till 10\\n    return random % 10 + 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rand10() \\n{\\n    int random = 0;\\n    for(int i = 0; i < 7; i++)\\n        random += rand7();\\n        \\n\\t//random can be max 49 so if we do modulo 10 and add 1 we can get any number between 1 till 10\\n    return random % 10 + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758128,
                "title": "simple-c-solution-easy-to-understand-with-comments",
                "content": "```\\n// problem is like throwing a dice having 7 outcome\\n    // we want a total of 10 outcome\\n    // so we throw two time=> total outcome=>7*7=49\\n    // map first 40 outcome to 1 to 10\\n    // we can also map first 10,20,30 outcome to 1 to 10 but to get outcome in range (1 to 20) we may     // need to throw much more time\\n    // getting a number in range 1to40 is 40/49\\n    // if we take first 20 outcome ...then probability of getting a number in range 1to20 is 20/49\\n\\t\\n\\tclass Solution {\\npublic:\\n    int rand10() {\\n        int num=40;\\n        while(num>=40){\\n            num=7*(rand7()-1)+rand7()-1;\\n        }\\n        \\n        num=num%10+1;\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// problem is like throwing a dice having 7 outcome\\n    // we want a total of 10 outcome\\n    // so we throw two time=> total outcome=>7*7=49\\n    // map first 40 outcome to 1 to 10\\n    // we can also map first 10,20,30 outcome to 1 to 10 but to get outcome in range (1 to 20) we may     // need to throw much more time\\n    // getting a number in range 1to40 is 40/49\\n    // if we take first 20 outcome ...then probability of getting a number in range 1to20 is 20/49\\n\\t\\n\\tclass Solution {\\npublic:\\n    int rand10() {\\n        int num=40;\\n        while(num>=40){\\n            num=7*(rand7()-1)+rand7()-1;\\n        }\\n        \\n        num=num%10+1;\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221272,
                "title": "test-cases-do-not-test-for-randomness",
                "content": "After looking at other people\\'s submissions, I noticed that the following code (in Java) is accepted. Clearly, this code does not generate random numbers; it simply counts from 1-10 repeatedly.\\n```\\nclass Solution extends SolBase {\\n    static int spot = 0;\\n    public int rand10() {\\n        int s[] = {1,2,3,4,5,6,7,8,9,10};\\n\\t\\tspot = (spot+1)%10;\\n\\t\\treturn s[spot];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution extends SolBase {\\n    static int spot = 0;\\n    public int rand10() {\\n        int s[] = {1,2,3,4,5,6,7,8,9,10};\\n\\t\\tspot = (spot+1)%10;\\n\\t\\treturn s[spot];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210021,
                "title": "special-amazing-mathematical-solution-1-line",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        return (rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n    }\\n};\\n```\\nIt\\'s a bit slow, but it\\'s very interesting. If you can read in Chinese, you can read my [mathematical explanation](https://zhuanlan.zhihu.com/p/51057259) of this method in Zhihu. My article mainly explains this method mathematically from two perspectives \\uFF1A\\n* Algebra\\uFF1AConvergence of m-order cyclic matrices\\n* Stochastic Process\\uFF1AStationary Distribution of Markov Chains\\n\\nBecause we cannot use Latex here, this algorithm cannot be explained in more detail. Generally\\uFF0Cfor the problem like \"Implement RandM() Using RandN()\", we can use this code:\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def randM(self):\\n        k = 2333333 #an enough large number \\n        temp = 0\\n        for i in range(k):\\n            temp += randN()\\n        return temp%M+1\\n```",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        return (rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n    }\\n};\\n```\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def randM(self):\\n        k = 2333333 #an enough large number \\n        temp = 0\\n        for i in range(k):\\n            temp += randN()\\n        return temp%M+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413715,
                "title": "using-rand5-and-rand2-to-implement-rand10",
                "content": "we can generate ```randA()``` from ```randB()``` very easily when A<=B, using **discarded sampling**\\ni.e, we keep calling ```randB()``` untill it gives you a value in range ```[1, A]```. (means we discard values ```{A+1,A+2,....B}``` if we get it using ```randB()```\\n\\n```\\ndef randA():\\n\\twhile True:\\n\\t\\tans = randB()\\n\\t\\tif ans<=A:\\n\\t\\t\\treturn ans\\n```\\n\\n\\nHence, from ```rand7()```, we can generate ```rand2()``` and ```rand5()```, and use these two to get ```rand10()```. By this formula:\\n\\n`rand10() = 2*( rand5() - 1) + rand2()`\\n\\nor\\n\\n`rand10() = 5*( rand2() - 1) + rand5()`\\n\\n\\nExplaination on why this works?\\n\\n As ```rand5()``` gives values in set `{1,2,3,4,5}` with equal probability,\\n\\n```2*( rand5() - 1)``` gives values in set ```{0,2,4,6,8}``` with equal probability. (Simple magnification and translation)\\n\\nwe just need an additional randomness of `{+1,+2}`  in this set which we can get from `+rand2()`\\n\\nThus, `rand10() = 2*( rand5() - 1) + rand2()`\\nin other words: `rand({1,2,3,4,5,6,7,8,9,10}) = rand({0,2,4,6,8}) + rand({1,2})`\\n\\n\\n\\n\\n```\\ndef rand10(self):\\n        \\n\\tdef randn(n):\\n\\t\\twhile True:\\n\\t\\t\\tans = rand7()\\n\\t\\t\\tif ans<=n:\\n\\t\\t\\t\\treturn ans\\n\\n\\treturn 2*(randn(5)-1) + randn(2)\\n```\\n\\nFurther optimization: You can notice that rand2() will be slower than rand5(). We can make rand2() faster by implementing rand2() from rand6(), which is faster as it is close to 7.\\n\\nrand2() = (rand6()+2)//3",
                "solutionTags": [
                    "Python"
                ],
                "code": "```randA()```\n```randB()```\n```randB()```\n```[1, A]```\n```{A+1,A+2,....B}```\n```randB()```\n```\\ndef randA():\\n\\twhile True:\\n\\t\\tans = randB()\\n\\t\\tif ans<=A:\\n\\t\\t\\treturn ans\\n```\n```rand7()```\n```rand2()```\n```rand5()```\n```rand10()```\n```rand5()```\n```2*( rand5() - 1)```\n```{0,2,4,6,8}```\n```\\ndef rand10(self):\\n        \\n\\tdef randn(n):\\n\\t\\twhile True:\\n\\t\\t\\tans = rand7()\\n\\t\\t\\tif ans<=n:\\n\\t\\t\\t\\treturn ans\\n\\n\\treturn 2*(randn(5)-1) + randn(2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1477866,
                "title": "rand7-2-floor-div-python-99-faster-expected-calls-0-525",
                "content": "***Use knowledge of statistics***... proving any distribution is not easy...\\n\\nKey points:\\n* `rand7()` \\u2192 inclusive interval [1, 7]\\n* `7 + rand7() // 2` \\u2192 inclusive interval [7, 10]\\n* Every 1...7th call, return `rand7()`\\n* Every 8...10th call, return `7 + rand7() // 2` when this value is not `7`\\n  * Store `rand7()` in deque for 1...7th call later\\n\\nThis method calls `rand7()` nominally 7/10 times but can be further reduced by storing a duplicate each and every single time `rand7()` is called.  Intuitively, this is not a uniform distribution, but any test for uniform distribution (chi-square, KS, etc.) will ***fail to reject the null hypothesis*** that the parameter/metric of proof for this distribution is different from that of a true uniform distribution, within a certain confidence level.  Thus, the expected calls for `rand7()` is `7/10 - 7/40 = 0.525` on average due to the fact that the confidence interval for small `n` is huge, and for larger `n`, the occurrence of consecutive duplicates are no different from what would/could actually be obtained from a \"true\" uniform generator.\\n\\nThe concept for storing `rand7()` during the 8...10th calls is that the distribution of `rand7() // 2` is also uniform, and within the context of `rand7()` being in the inclusive range of [1,7], the fact that it is added to the deque only when it is `1` still has a 1 in 7 probability (aka uniform for the purpose of this problem).\\n\\nThis solution is gaming the system... just like y\\'all are trying to game the interview process \\uD83D\\uDE02\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def __init__(self):\\n        self.dq = deque(maxlen=20)\\n        self.rand10_calls = 0\\n\\n    def get_1_from_dq(self):\\n        if len(self.dq) == 0:\\n\\t\\t    #return rand7()\\n            return self.add_new_to_dq() #reduce 7/40th calls to rand7()\\n        return self.dq.popleft()\\n\\n    def add_new_to_dq(self):\\n        out = rand7()\\n        self.dq.append(out)\\n        return out\\n\\n    def rand10(self):\\n        self.rand10_calls += 1\\n        opt = self.rand10_calls % 10\\n        if opt < 7:\\n            out = self.get_1_from_dq()\\n        else:\\n            out = 7\\n            while out < 8:\\n                e0 = self.add_new_to_dq()\\n                out = 7 + e0 // 2\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def __init__(self):\\n        self.dq = deque(maxlen=20)\\n        self.rand10_calls = 0\\n\\n    def get_1_from_dq(self):\\n        if len(self.dq) == 0:\\n\\t\\t    #return rand7()\\n            return self.add_new_to_dq() #reduce 7/40th calls to rand7()\\n        return self.dq.popleft()\\n\\n    def add_new_to_dq(self):\\n        out = rand7()\\n        self.dq.append(out)\\n        return out\\n\\n    def rand10(self):\\n        self.rand10_calls += 1\\n        opt = self.rand10_calls % 10\\n        if opt < 7:\\n            out = self.get_1_from_dq()\\n        else:\\n            out = 7\\n            while out < 8:\\n                e0 = self.add_new_to_dq()\\n                out = 7 + e0 // 2\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056666,
                "title": "python-using-2-rand7-calls",
                "content": "```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 1\\n        grid = []\\n        for i in range(7):\\n            temp = []\\n            for _ in range(7):\\n                temp.append(val)\\n                val+=1\\n                if val==11:\\n                    val = 1\\n            grid.append(temp)\\n\\n        row = rand7()-1\\n        col = rand7()-1\\n\\n        if row<=4 or (row==5 and col<=4):\\n            return grid[row][col]\\n\\n        return self.rand10()\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 1\\n        grid = []\\n        for i in range(7):\\n            temp = []\\n            for _ in range(7):\\n                temp.append(val)\\n                val+=1\\n                if val==11:\\n                    val = 1\\n            grid.append(temp)\\n\\n        row = rand7()-1\\n        col = rand7()-1\\n\\n        if row<=4 or (row==5 and col<=4):\\n            return grid[row][col]\\n\\n        return self.rand10()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 817177,
                "title": "python-easy-to-understand-best-and-worst-time-o-1-worst-space-o-1-with-detailed-explaination",
                "content": "### Step #1: Realize that we can generate a random base-7 number.\\nSince we have the ability to randomly generate numbers 0-6 (rand7()-1), therefore we can randomly generate any number in base-7 number system. Since each bit correspoding to each power of 7 will be randomly generated therefore we can always trust that generated number will be truly random.\\n\\n### Step #2: Realize that we can generate a random number between 0-2400\\nWe know:\\n`0 = 0 [ 0*(7^0)+0*(7^1)+0*(7^2)+0*(7^3)]`\\n`2400 = 6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3)`\\n\\nSince `2400 = 6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3)`, we can try to randomly generate a base-7 number between 0 to 2400. In order to do so, we just have to generate a random number (0-6) 4 times, corresponding to each exponential power of 7.  Therefore:\\n\\n`rand_0_to_2400() = (7**0)*(rand7()-1)+(7**1)*(rand7()-1)+(7**2)*(rand7()-1)+(7**3)*(rand7()-1)`\\n\\n### Step #3: Convert the Random Number between 0-2400 to a random number between 0-10\\nNow since we have a random number between 0 - 2400 where each number is equally likely to occur. We can argue that last digit of this generated number is equally likely to be 0-9. So we can argue `rand_1_to_10 = rand_0_to_2400() %10 +1`\\n\\n\\n```\\nclass Solution:\\n    def rand10(self): \\n        result = 0\\n\\t\\t\\n\\t\\t# generate random 4-digit base-7 number [range 0-2800]\\n\\t\\t#  from 0*(7^0)+0*(7^1)+0*(7^2)+0*(7^3) = 0  ->  6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3) = 2400 \\n\\t\\t\\n        for i in range(4):\\n            result*=7\\n            result+=rand7()-1\\n\\t\\t# since each number from 0-2400 is equally likely to be generated\\n\\t\\t# therefore last digit of the generated number is equally likely to be any number 0-9\\n\\t\\t# calculate the modulus => we can calculate truly random number 0-9\\n        return result%10+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self): \\n        result = 0\\n\\t\\t\\n\\t\\t# generate random 4-digit base-7 number [range 0-2800]\\n\\t\\t#  from 0*(7^0)+0*(7^1)+0*(7^2)+0*(7^3) = 0  ->  6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3) = 2400 \\n\\t\\t\\n        for i in range(4):\\n            result*=7\\n            result+=rand7()-1\\n\\t\\t# since each number from 0-2400 is equally likely to be generated\\n\\t\\t# therefore last digit of the generated number is equally likely to be any number 0-9\\n\\t\\t# calculate the modulus => we can calculate truly random number 0-9\\n        return result%10+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817108,
                "title": "very-basic-4-line-accepted-solution-with-explanation",
                "content": "I was expecting this solution to give time limit exception but it was accepted!! \\n\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int ans =0;\\n        for(int i=0; i<10; i++)\\n            ans+=rand7();\\n        return (ans%10)+1;\\n    }\\n}\\n```\\n\\nlogic is simple, Im adding rand(7) 10 times, so the sum can be anything between 1 to 70 with equal probability. \\nNext Im doing % 10, which should be between 0-9. and finally ading 1 because we want range 1-10.",
                "solutionTags": [],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int ans =0;\\n        for(int i=0; i<10; i++)\\n            ans+=rand7();\\n        return (ans%10)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816611,
                "title": "simple-python-and-c-code-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=Hvx2wXMnZGg)\\nhttps://www.youtube.com/watch?v=Hvx2wXMnZGg\\n## Python\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        indx = 41\\n        while indx > 40:\\n            indx = (rand7() - 1) * 7 + rand7()\\n        return ((indx - 1) % 10) + 1\\n```\\n## C\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int indx = 41;\\n    while (indx > 40){\\n        indx = (rand7() - 1) * 7 + rand7();\\n    }\\n    return ((indx - 1) % 10) + 1;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        indx = 41\\n        while indx > 40:\\n            indx = (rand7() - 1) * 7 + rand7()\\n        return ((indx - 1) % 10) + 1\\n```\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int indx = 41;\\n    while (indx > 40){\\n        indx = (rand7() - 1) * 7 + rand7();\\n    }\\n    return ((indx - 1) % 10) + 1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816452,
                "title": "why-this-1-line-solution-works",
                "content": "\\n    int rand10() {\\n        return 1+(rand7() + rand7() + rand7() + rand7() +rand7())%10;\\n    }",
                "solutionTags": [],
                "code": "\\n    int rand10() {\\n        return 1+(rand7() + rand7() + rand7() + rand7() +rand7())%10;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 816314,
                "title": "c-yet-another-uniform-random-selection-method",
                "content": "In here, first I generate a random number to determine the number that I choose is going to be from [1-5] or [6-10]. For this purpose, I roll the rand7() and while I get 7 I will discard it and if I finally get between [1-6] I will mod it to 2. The mod result can only be 0 or 1: If the mod result is 0, then I will choose from [1-5], if the mod result is 1, I will choose from [6-10].\\n\\nOn average 2.56667 times of calling to rand7(): \\n     1 + (1/7 + 1/7 * 1/7 + .... ) +1 + (2/7+2/7 * 2/7+.....) = 2.56667\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();   // ----> Determines to choose from [1-5] or [6-10]\\n        while(x==7){   // redo the selection while the chosen number is 7.\\n            x = rand7(); // The number with equal chances will be either even (2,4,6) or odd (1,3,5). Note that 7 is excluded\\n        }\\n\\t\\tint r1_5 = rand7();  // In here I generate a number between 1 and 5\\n        while(r1_5>5){  // redo if  >5\\n            r1_5 = rand7();\\n        }\\n        return r1_5 + (x%2)*5; // return the number getting help from x%2.\\n\\t\\t\\t// So either \"r1_5 + 0\" or \"r1_5 + 5\" is the return. Meaining, either the number is going to be\\n\\t\\t\\t//Between [1,5] or [6,10]. This way, the solution has a uniform distribution.\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();   // ----> Determines to choose from [1-5] or [6-10]\\n        while(x==7){   // redo the selection while the chosen number is 7.\\n            x = rand7(); // The number with equal chances will be either even (2,4,6) or odd (1,3,5). Note that 7 is excluded\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 667487,
                "title": "rust-approach-1-not-accepted",
                "content": "Trying to get Approach 1 from the Solutions working in Rust, it\\'s working for me off-line and my distribution for 10,000 samples is pretty uniform, but it\\'s not accepted. Any ideas?\\n\\n```\\n// rand7 for testing\\nuse rand::Rng;\\nfn rand7() -> i32 {\\n    let mut rng = rand::thread_rng();\\n    return rng.gen_range(1, 8);\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        let mut val = 50;\\n        while val > 40 {\\n            let a = rand7();\\n            let b = rand7();\\n            val = a + (b-1)*7;\\n        }\\n        1 + (val - 1) % 10 // 1-indexing\\n    }\\n}\\n\\nfn test_dist() {\\n    let mut freq = vec![0; 10];\\n    let samples = 10000;\\n\\n    println!(\"Testing distribution with {:?} samples\", samples);\\n\\n    for _ in 0..samples {\\n        let bin = Solution::rand10() - 1;\\n        freq[bin as usize] += 1;\\n    }\\n\\n    for f in freq {\\n        print!(\"{} \", (f as f32)/(samples as f32));\\n    }\\n    println!();\\n}\\n\\nfn main() {\\n    test_dist();\\n}\\n```\\n\\nOutput:\\n```\\nTesting distribution with 10000 samples\\n0.0987 0.1009 0.1006 0.1025 0.1023 0.0942 0.0945 0.0977 0.1062 0.1024\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// rand7 for testing\\nuse rand::Rng;\\nfn rand7() -> i32 {\\n    let mut rng = rand::thread_rng();\\n    return rng.gen_range(1, 8);\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        let mut val = 50;\\n        while val > 40 {\\n            let a = rand7();\\n            let b = rand7();\\n            val = a + (b-1)*7;\\n        }\\n        1 + (val - 1) % 10 // 1-indexing\\n    }\\n}\\n\\nfn test_dist() {\\n    let mut freq = vec![0; 10];\\n    let samples = 10000;\\n\\n    println!(\"Testing distribution with {:?} samples\", samples);\\n\\n    for _ in 0..samples {\\n        let bin = Solution::rand10() - 1;\\n        freq[bin as usize] += 1;\\n    }\\n\\n    for f in freq {\\n        print!(\"{} \", (f as f32)/(samples as f32));\\n    }\\n    println!();\\n}\\n\\nfn main() {\\n    test_dist();\\n}\\n```\n```\\nTesting distribution with 10000 samples\\n0.0987 0.1009 0.1006 0.1025 0.1023 0.0942 0.0945 0.0977 0.1062 0.1024\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541239,
                "title": "c-solution",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int n = (rand7()-1)*7+rand7();\\n        while(n>40)\\n            n = (rand7()-1)*7+rand7();\\n        return (n-1)/4+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int n = (rand7()-1)*7+rand7();\\n        while(n>40)\\n            n = (rand7()-1)*7+rand7();\\n        return (n-1)/4+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538338,
                "title": "java-use-uniform-distribution",
                "content": "```\\n    public int rand10() {\\n        int sum = 49; // 2 rand7, even will be smaller than odd.\\n        while (sum >= 40) sum = 7 * (rand7() - 1) + rand7() - 1;\\n        return sum % 10 + 1;\\n    }\\n```\\nRef: https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22",
                "solutionTags": [],
                "code": "```\\n    public int rand10() {\\n        int sum = 49; // 2 rand7, even will be smaller than odd.\\n        while (sum >= 40) sum = 7 * (rand7() - 1) + rand7() - 1;\\n        return sum % 10 + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351302,
                "title": "solve-rand2-instead",
                "content": "Instead of solving rand10, we can solve rand2 instead: \\n\\nDefine five buckets: [1-2], [3-4], [5-6], [7-8], [9-10]. Call rand7() until you get a number between 1 and 5. Once you have such a number, you have picked one of the five buckets and must now decide which of the two numbers wins - the odd or the even number. To solve that, you call rand7() until you get a number between 1 and 6. Once you have it, you have your answer. \\n\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int f, g;\\n\\t\\t\\n\\t\\t// pick which bucket: 1-2, 3-4, ..., 9-10\\n        while ((f=rand7())>5); \\n\\t\\t\\n\\t\\t// pick odd or even\\n        while ((g=rand7())>6);\\n        \\n\\t\\t// combine the two choices\\n        return 2*f - (g%2);\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int f, g;\\n\\t\\t\\n\\t\\t// pick which bucket: 1-2, 3-4, ..., 9-10\\n        while ((f=rand7())>5); \\n\\t\\t\\n\\t\\t// pick odd or even\\n        while ((g=rand7())>6);\\n        \\n\\t\\t// combine the two choices\\n        return 2*f - (g%2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239916,
                "title": "super-easy-4-lines-solution",
                "content": "Range of `a` is from 1 to 6, range of `b` is from 1 to 5, probability of `a < 4` is 1/2, probability of `b  = 1|2|3|4|5` is 1/5. Then, `b + (a < 4 ? 5 : 0) = 1|2|...|10`, their probability is 1/10.\\n\\n```\\nvar rand10 = function() {\\n    var a = 7, b = 7\\n    while (a === 7) { a = rand7() }\\n    while (b > 5 ) { b = rand7() }\\n    return b + (a < 4 ? 5 : 0)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rand10 = function() {\\n    var a = 7, b = 7\\n    while (a === 7) { a = rand7() }\\n    while (b > 5 ) { b = rand7() }\\n    return b + (a < 4 ? 5 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237716,
                "title": "python-solution-using-matrix",
                "content": "The overall idea is to achieve a uniform chance of a number being returned. Every number returned has to have the same chance of being returned. One way to achieve this is to visualize the series of numbers in a 2 dimensional matrix containing a repeated series of numbers in the range we are looking for. Note the matrix may contain elements which are not part of a complete range of numbers 1-10. So, we need to reject those elements.\\n\\n**Steps to reach solution**\\n1. Create a matrix of size 7 x 7\\n2. Populate it with numbers 1-10 continuously\\n3. Blank out the last few elements (1-9) which do not form the full range 1-10 (optional)\\n4. In a `white True:` loop, call rand7() and get row & column indexes of the matrix\\n5. If you get a row or column in the invalid range, try calling rand7() again\\n6. Otherwise, return the value found by `matrix[row][column]`\\n```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        matrix = [[1, 2, 3, 4, 5, 6, 7],\\n                  [8, 9,10, 1, 2, 3, 4],\\n                  [5, 6, 7, 8, 9,10, 1],\\n                  [2, 3, 4, 5, 6, 7, 8],\\n                  [9,10, 1, 2, 3, 4, 5],\\n                  [6, 7, 8, 9,10, 0, 0], # Last 2 elements are invalid\\n                  [0, 0, 0, 0, 0, 0, 0]] # Entire row is invalid\\n        while True:\\n            row = rand7() - 1\\n            col = rand7() - 1\\n            if row == 5 and col >= 5:\\n                continue\\n            elif row == 6:\\n                continue\\n            return matrix[row][col]\\n```",
                "solutionTags": [],
                "code": "```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        matrix = [[1, 2, 3, 4, 5, 6, 7],\\n                  [8, 9,10, 1, 2, 3, 4],\\n                  [5, 6, 7, 8, 9,10, 1],\\n                  [2, 3, 4, 5, 6, 7, 8],\\n                  [9,10, 1, 2, 3, 4, 5],\\n                  [6, 7, 8, 9,10, 0, 0], # Last 2 elements are invalid\\n                  [0, 0, 0, 0, 0, 0, 0]] # Entire row is invalid\\n        while True:\\n            row = rand7() - 1\\n            col = rand7() - 1\\n            if row == 5 and col >= 5:\\n                continue\\n            elif row == 6:\\n                continue\\n            return matrix[row][col]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832432,
                "title": "java-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177938,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172860,
                "title": "solutions-with-examples",
                "content": "# Idea: rand7() -> rand49() -> rand40() -> rand10()\\n```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n} \\n```\\n## Time Complexity\\nThe total number of iterations follows geometric distribution. For each iteration in the while loop, the probabilty of exiting the loop is p = 40/49. So the average time complexity T(n) = O(1/p) = O(49/40) = O(1).\\n\\n### Correctness\\nNote that rand49() generates a uniform random integer in [1, 49], so any number in this range has the same probability to be generated. Suppose k is an integer in range [1, 40], P(rand49() = k) = 1/49.\\n\\n P(result = k) =>>>>>> P(rand49() = k in the 1st iteration) +\\nP(rand49() > 40 in the 1st iteration) * P(rand49() = k in the 2nd iteration) +\\nP(rand49() > 40 in the 1st iteration) * P(rand49() > 40 in the 2nd iteration) * P(rand49() = k in the 3rd iteration) +\\nP(rand49() > 40 in the 1st iteration) * P(rand49() > 40 in the 2nd iteration) * P(rand49() > 40 in the 3rd iteration) * P(rand49() = k in the 4th iteration) +\\n...\\n= (1/49) + (9/49) * (1/49) + (9/49)^2 * (1/49) + (9/49)^3 * (1/49) + ...\\n= (1/49) * [1 + (9/49) + (9/49)^2 + (9/49)^3 + ... ]\\n= (1/49) * [1/(1-9/49)]\\n= (1/49) * (49/40)\\n= 1/40\\n\\n##### Generalization\\nImplement randM() using randN() when M > N:\\nStep 1: Use randN() to generate randX(), where X >= M. In this problem, I use 7 * (rand7() - 1) + (rand7() - 1) to generate rand49() - 1.\\nStep 2: Use randX() to generate randM(). In this problem, I use rand49() to generate rand40() then generate rand10.\\n\\nNote: N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1) generates randX() - 1, where X = N^(b + 1).\\n\\n# More Examples\\n(1) Implement rand11() using rand3():\\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\\nIdea: rand3() -> rand27() -> rand22 -> rand11\\nTime Comlexity: O(27/22)\\n\\n(2) Implement rand9() using rand7():\\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\\nIdea: rand7() -> rand49() -> rand45() -> rand9()\\nTime Comlexity: O(49/45)\\n\\n(3) Implement rand13() using rand6():\\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```\\nIdea: rand6() -> rand36() -> rand26 -> rand13()\\nTime Comlexity: O(36/26)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n} \\n```\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2645999,
                "title": "o-1-average-time-o-inf-worst-case-o-1-space-rejection-sampling",
                "content": "![image](https://assets.leetcode.com/users/images/d7fce538-26d1-4b02-8609-5734134aaa82_1664630424.3960588.png)\\n\\nrecursive\\n\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n        return self.rand10() if x > 40 else (x - 1) % 10 + 1\\n\\t\\t\\niterative\\t\\t\\n\\t\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = math.inf\\n\\n        while x > 40:\\n            x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n\\n        return 1 + (x - 1) % 10  # 1+[0..9] num",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/d7fce538-26d1-4b02-8609-5734134aaa82_1664630424.3960588.png)\\n\\nrecursive\\n\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n        return self.rand10() if x > 40 else (x - 1) % 10 + 1\\n\\t\\t\\niterative\\t\\t\\n\\t\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = math.inf\\n\\n        while x > 40:\\n            x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n\\n        return 1 + (x - 1) % 10  # 1+[0..9] num",
                "codeTag": "Python3"
            },
            {
                "id": 2502829,
                "title": "python-rand2-and-rand5-because-2-5-10",
                "content": "\\n```\\nclass Solution:\\n    def rand10(self):\\n\\n        def rand2():\\n\\t\\t\\t# uniformly generate [True, False]\\n            n = rand7()\\n            while n == 4:\\n                n = rand7()\\n            return n > 4\\n\\n        def rand5():\\n\\t\\t\\t# uniformly generate 1-5\\n            n = rand7()\\n            while n in (6, 7):\\n                n = rand7()\\n            return n\\n\\t\\t\\n\\t\\t# each number between 1-10 has probablity of 1/2 * 1/5 = 1/10 to be chosen\\n        n = rand5()\\n        if rand2():\\n            n += 5\\n        return n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n\\n        def rand2():\\n\\t\\t\\t# uniformly generate [True, False]\\n            n = rand7()\\n            while n == 4:\\n                n = rand7()\\n            return n > 4\\n\\n        def rand5():\\n\\t\\t\\t# uniformly generate 1-5\\n            n = rand7()\\n            while n in (6, 7):\\n                n = rand7()\\n            return n\\n\\t\\t\\n\\t\\t# each number between 1-10 has probablity of 1/2 * 1/5 = 1/10 to be chosen\\n        n = rand5()\\n        if rand2():\\n            n += 5\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426780,
                "title": "easy-using-c-90-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        while(1)\\n        {\\n            int temp = rand7();\\n            int till_last= (rand7() - 1)*7;\\n            int ans = till_last+temp;\\n            if(ans<=40)\\n            {\\n                return (ans-1)%10 + 1;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rand10() {\\n        while(1)\\n        {\\n            int temp = rand7();\\n            int till_last= (rand7() - 1)*7;\\n            int ans = till_last+temp;\\n            if(ans<=40)\\n            {\\n                return (ans-1)%10 + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2404316,
                "title": "python-beats-91-detailed-explanation-proof-of-correctness",
                "content": "In problems like this, **there\\'s no single correct solution**. That\\'s why the solutions posted differ so much.\\nHowever, the task is not to implement *the best possible* random number generator. The task is to create a *valid* one.\\n\\nThe only criterion of validity is the uniform distribution of generated values, meaning that each value from range `[1, 10]` has an equal probability of being returned.\\n\\nNow, we are provided with a function `rand7()` that is guaranteed to have a uniform distribution, so its return values from the range `[1, 7]` satisfy the equal probability condition.\\n\\nBelow is a sample solution. Remember, there are other valid solutions, some may be more optimal, but this one is easy to analyse:\\n\\n```\\nclass Solution:\\n    def rand10(self) -> int:        \\n        while (offset := rand7()) > 5:\\n            offset = rand7()        \\n        \\n        while (segment := rand7()) == 4:\\n            segment = rand7()\\n        \\n        return 5 * (segment > 4) + offset\\n```\\nThe logic is simple: we split the range `[1, 10]` in two segments, `[1, 5]` and `[6, 10]`, then we use `rand7()` to pick one of these segments and to generate an offset within it to determine the final return value.\\n\\nFirst we call `rand7()` to generate a number between `1` and `5`. If the generator returns such a value, we just use it as an offset. Indeed, since the probability of picking any number from `[1, 5]` is the same, the distribution for the offset value is uniform.\\nThe tricky part is when `rand7()` returns either `6` or `7`. In this case *we just roll the dice again*, and keep doing it until we finally hit a number from `[1, 5]`. Since every time we call `rand7()` it picks a value randomly, there\\'s no deterministic answer to when a number from `[1, 5]` will be returned, but what\\'s important is that *the probability of each outcome is the same*.\\n\\nNow we do the same for picking one of two segments. This time we use `4` as a pivot, picking the lower segment for any value smaller than `4`, the higher one for any value greater than `4`, and rolling the dice again when it was exactly `4`. The same rules apply, since numbers from `[1, 3]` have the same probability of being picked as numbers from `[5, 7]`, the overall distribution is uniform.\\n\\nThe final step is combining two independently generated uniformly distributed random values, which is again a random number with uniform distribution. And that\\'s exactly what we needed! =)\\n\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self) -> int:        \\n        while (offset := rand7()) > 5:\\n            offset = rand7()        \\n        \\n        while (segment := rand7()) == 4:\\n            segment = rand7()\\n        \\n        return 5 * (segment > 4) + offset\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120414,
                "title": "python3-simple-rejection-sampling-based-solution-beats-85-solutions",
                "content": "```\\n\"\"\"https://leetcode.com/problems/implement-rand10-using-rand7/\"\"\"\\n\\n\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        number = -1\\n        number_not_sampled_in_range = True\\n        while number_not_sampled_in_range:\\n            number = 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 40:\\n                number_not_sampled_in_range = False\\n            # note that one can also use something like the following:\\n            \"\"\"number = 49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 340:\\n                number_not_sampled_in_range = False\"\"\"\\n\\n        return 1 + number % 10\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/implement-rand10-using-rand7/\"\"\"\\n\\n\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        number = -1\\n        number_not_sampled_in_range = True\\n        while number_not_sampled_in_range:\\n            number = 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 40:\\n                number_not_sampled_in_range = False\\n            # note that one can also use something like the following:\\n            \"\"\"number = 49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 340:\\n                number_not_sampled_in_range = False\"\"\"\\n\\n        return 1 + number % 10\\n",
                "codeTag": "Java"
            },
            {
                "id": 2119081,
                "title": "java-easy-and-efficient-solution",
                "content": "We are to map the range from 1 to 7 inclusive to a bigger range from 1 to 10 inclusive \\nSo we create a map (2d array) of the size (7x7) and distrubte the element across it, starting from 1 up to 10, after reaching 10 we start again from 1 to 10, we repeat the same process, till there\\'re no enough places to take all of our range (1-10), then we start to fill cells with zeros \\nafter that we pick a number from our distribution using uniformally distributed rand7, because of that our solution will be always unifromally distributed\\n\\n```java \\n    /**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 },\\n        { 8, 9, 10, 1, 2, 3, 4 },\\n        { 5, 6, 7, 8, 9, 10, 1}, \\n        { 2, 3, 4, 5, 6, 7, 8}, \\n        { 9, 10, 1, 2, 3, 4, 5}, \\n        { 6, 7, 8, 9, 10, 0, 0}, \\n        { 0, 0, 0, 0, 0, 0, 0}\\n    };\\n    \\n    public int rand10() {\\n\\n        \\n        int result = 0; \\n        while(result == 0) { \\n            result = vals[rand7()-1][rand7()-1];\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 }",
                "codeTag": "Java"
            },
            {
                "id": 2111196,
                "title": "python-easy-solution-faster-then-99-85",
                "content": "![image](https://assets.leetcode.com/users/images/ba28d37e-d4f9-46f6-b4d8-3378cd70902d_1654374278.167117.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/ba28d37e-d4f9-46f6-b4d8-3378cd70902d_1654374278.167117.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1831927,
                "title": "java-solution",
                "content": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int result = ((rand7() - 1)*7) + rand7();\\n        if(result > 40)\\n            return rand10();\\n        return (result%10) + 1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int result = ((rand7() - 1)*7) + rand7();\\n        if(result > 40)\\n            return rand10();\\n        return (result%10) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800231,
                "title": "return-rand7-rand7-rand7-rand7-10-1",
                "content": "```\\nreturn (rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n```\\n\\nThank you.",
                "solutionTags": [],
                "code": "```\\nreturn (rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482098,
                "title": "c-easy-to-understand-brute-force-solution",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        //We use two calls to rand(7) for 49 posssible values w/ equal chance of occuring\\n        \\n        //Example values: \"11\" \"12\" \"21\" \"77\"\\n        //Then, we can form 10 groups of 4 values for our rand10().\\n        \\n        //40 values of 49 are used as possible values for our rand generator\\n        \\n        //If we generate one of the remaining 9 values, call rand10() again\\n        int firstRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int secondRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int appendedVals = stoi(to_string(firstRandomVal) + to_string(secondRandomVal)); //11 12 13 14 15 16 17, 21 22 23 24 25 26 27, etc ...\\n        \\n        if(appendedVals >= 11 && appendedVals <= 14) {\\n            return 1;\\n        } else if(appendedVals >= 15 && appendedVals <= 21) {\\n            return 2;\\n        } else if(appendedVals >= 22 && appendedVals <= 25) {\\n            return 3;\\n        } else if(appendedVals >= 26 && appendedVals <= 32) {\\n            return 4;\\n        } else if(appendedVals >= 33 && appendedVals <= 36) {\\n            return 5;\\n        } else if(appendedVals >= 37 && appendedVals <= 43) {\\n            return 6;\\n        } else if(appendedVals >= 44 && appendedVals <= 47) {\\n            return 7;\\n        } else if(appendedVals >= 51 && appendedVals <= 54) {\\n            return 8;\\n        } else if(appendedVals >= 55 && appendedVals <= 61) {\\n            return 9;\\n        } else if(appendedVals >= 62 && appendedVals <= 65) {\\n            return 10;\\n        } else {\\n            //Remaining 9 values are \"invalid\", call our function again.\\n            return rand10();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        //We use two calls to rand(7) for 49 posssible values w/ equal chance of occuring\\n        \\n        //Example values: \"11\" \"12\" \"21\" \"77\"\\n        //Then, we can form 10 groups of 4 values for our rand10().\\n        \\n        //40 values of 49 are used as possible values for our rand generator\\n        \\n        //If we generate one of the remaining 9 values, call rand10() again\\n        int firstRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int secondRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int appendedVals = stoi(to_string(firstRandomVal) + to_string(secondRandomVal)); //11 12 13 14 15 16 17, 21 22 23 24 25 26 27, etc ...\\n        \\n        if(appendedVals >= 11 && appendedVals <= 14) {\\n            return 1;\\n        } else if(appendedVals >= 15 && appendedVals <= 21) {\\n            return 2;\\n        } else if(appendedVals >= 22 && appendedVals <= 25) {\\n            return 3;\\n        } else if(appendedVals >= 26 && appendedVals <= 32) {\\n            return 4;\\n        } else if(appendedVals >= 33 && appendedVals <= 36) {\\n            return 5;\\n        } else if(appendedVals >= 37 && appendedVals <= 43) {\\n            return 6;\\n        } else if(appendedVals >= 44 && appendedVals <= 47) {\\n            return 7;\\n        } else if(appendedVals >= 51 && appendedVals <= 54) {\\n            return 8;\\n        } else if(appendedVals >= 55 && appendedVals <= 61) {\\n            return 9;\\n        } else if(appendedVals >= 62 && appendedVals <= 65) {\\n            return 10;\\n        } else {\\n            //Remaining 9 values are \"invalid\", call our function again.\\n            return rand10();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410646,
                "title": "c-faster-than-100",
                "content": "```\\nint rand10() {\\n        int rand40 = 40;\\n        while(rand40 >= 40) {\\n            rand40 = (rand7()-1)*7 + rand7()-1;\\n        }\\n        return rand40%10 + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n        int rand40 = 40;\\n        while(rand40 >= 40) {\\n            rand40 = (rand7()-1)*7 + rand7()-1;\\n        }\\n        return rand40%10 + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385546,
                "title": "xorshift-by-rand7-with-analysis-3-lines-1-rand7-call-per-output",
                "content": "So xorshift algorithms are fairly well known for being good pseudo-random number generators (https://en.wikipedia.org/wiki/Xorshift), all I did here was replace the 3 fixed-shift operations with a single random-shift operation and got pretty good results (analysis after the code, which includes as separate implementation of rejection sampling for reference). I\\'ve implemented everything here in python, but this has also worked in c++, c#, and java with the seed 194693639, but otherwise essentially identical code (a good seed is any number with a good number of bits, and some variety in its bit string).\\n\\nBest Performance: 228 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n\\t#Generate a Number Using a Random XorShift\\n\\tseed = 10**9 + 7\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed ^= self.seed >> rand7()\\n        \\n        #Return the Random Value\\n        return 1 + self.seed%10\\n\\t\\n\\t#Generate a Number Using Rejection Sampling\\n    def rand10(self) -> int:\\n        #Select a Range\\n        r1 = rand7()\\n        while r1 == 4:\\n            r1 = rand7()\\n        \\n        #Select a Number Within that Range\\n        r2 = rand7()\\n        while r2 > 5:\\n            r2 = rand7()\\n        \\n        #Return the Number\\n        return (5 if r1 > 4 else 0) + r2\\n\\'\\'\\'\\n\\nTo evaluate any sample functions I wrote I used 2 metrics. The first is a simple histogram of the numbers produced, the second is to look at the stochastic transition matrix produced by the sample (.i.e. if the previous sample returned x how likely is the next sample to return y?). For reference, here are some plots made by generating 100000 random numbers using rejection sampling (note that I changed the range from [1-10] to be [0-9] for convenience).\\n\\n![image](https://assets.leetcode.com/users/images/e1447b26-d1c2-41d3-9c59-3c6311235eed_1628181641.656291.png)\\n![image](https://assets.leetcode.com/users/images/440bc62f-705d-4e18-97a2-41214518c283_1628181682.8810203.png)\\n\\n\\nAs you can see, the histogram is essentially flat, which indicates that all numbers have an equal chace of being drawn. Furthermore, all the transition probabilities are very close to 1/10, indicating that the output doesn\\'t have an easilly discernable pattern.\\n\\nNext, here are are some plots made by generated 100000 random numbers using my modified xorshift:\\n\\n![image](https://assets.leetcode.com/users/images/582bce58-14c2-4aab-a351-088533de79e7_1628181764.9948664.png)\\n![image](https://assets.leetcode.com/users/images/c0716b00-f47e-45d7-8456-7ea9fa6ea196_1628181886.6024754.png)\\n\\nAs you can see, by these metrics, the performance of the random xorshift is essentially identical to the performance of rejection sampling. That does not mean that this algorithm is cryptographically secure, or that it could pass BigCrush, but it was definitely random enough for LeetCode, and random enough that I couldn\\'t easilly break it! If I wanted to make it stronger I\\'d consider adding one or two fixed xor shifts, and/or use bits from the middle of the bit string to generate the outputs.\\n\\n-------------------------------------------\\nNext, just to present a something which obviously fails, here\\'s some code which also passed LeetCode\\'s test cases.\\n\\nBest Performance : 236 ms/16.9 MB : 97%/41%\\n\\'\\'\\'\\n\\n    seed = 2999\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed += 3001\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed%10\\n\\'\\'\\'\\n\\nJust by intuition we already know that this random number generator should be terrible, since it produces the exact same sequence of numbers every time, and the next number is easy to calculate from the previous number. Here are the plots it generates:\\n\\n![image](https://assets.leetcode.com/users/images/22738aee-7041-494f-ad3a-c4dc48ea47b9_1628182551.0322888.png)\\n![image](https://assets.leetcode.com/users/images/3e550cc8-3328-4b13-9789-a766c1ef3f6a_1628182825.0660825.png)\\n\\n\\nSo, it\\'s distribution is perfectly uniform (tbh it\\'s so uniform that that should be a red flag), and it\\'s transition matrix clearly indicates what\\'s happening: a pointer which is being updated by 1 (mod 10) between each sample. The fact that this still passed LeetCode\\'s test cases tells us that they\\'re probably only looking at a histogram of the numbers you generate, and whether or not the standard deviation on the height of the histogram bins is small enough. Were they using anything more sophisticated then they should\\'ve caught this.\\n\\nWhat happens if we make this a little more sophisticated though?\\n\\nBest Performance : 224 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n    seed = 9\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed = (self.seed + rand7())%10\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/abf9ca0b-78d2-4a50-a93e-103daab75eb1_1628183431.6355002.png)\\n![image](https://assets.leetcode.com/users/images/5d78c97c-1da5-4946-999f-44828b865069_1628183480.924376.png)\\n\\nThis time there isn\\'t anything obviously wrong with the histogram! But when you look at the transition matrix there\\'s an obvious pattern (so obvious that you could easilly figure out how the numbers are being generated).\\n\\nAnd actually, every other method I tried which used a single rand7 call per update failed this transition matrix test (even if it passed LeetCode\\'s test cases), except for this final solution, which I don\\'t like because it really just plays to the test (I pretty much just kept finding more old random numbers to add until it\\'s transition matrix looked decent).\\n\\nBest Performance: 272 ms/17 MB : 97%/6%\\n\\n\\'\\'\\'\\n\\n    queue = deque([1, 2, 5, 4, 3, 5, 3, 7, 7, 1])\\n    seed = 8\\n    def rand10(self) -> int:\\n        #Generate a Random Number\\n        r = rand7()\\n        \\n        #Increment the Sum\\n        self.seed = (self.seed + self.queue[self.seed] + r + self.queue[r] + self.queue.popleft())%10\\n        \\n        #Record the Latest Random Number\\n        self.queue.append(r)\\n        \\n        #Return the Random Number\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/5bf15d38-b275-4291-b8cf-122a17937016_1628188466.5762591.png)\\n![image](https://assets.leetcode.com/users/images/99048987-e6f2-4615-a3ad-851cf2cc6ce1_1628188503.325822.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "So xorshift algorithms are fairly well known for being good pseudo-random number generators (https://en.wikipedia.org/wiki/Xorshift), all I did here was replace the 3 fixed-shift operations with a single random-shift operation and got pretty good results (analysis after the code, which includes as separate implementation of rejection sampling for reference). I\\'ve implemented everything here in python, but this has also worked in c++, c#, and java with the seed 194693639, but otherwise essentially identical code (a good seed is any number with a good number of bits, and some variety in its bit string).\\n\\nBest Performance: 228 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n\\t#Generate a Number Using a Random XorShift\\n\\tseed = 10**9 + 7\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed ^= self.seed >> rand7()\\n        \\n        #Return the Random Value\\n        return 1 + self.seed%10\\n\\t\\n\\t#Generate a Number Using Rejection Sampling\\n    def rand10(self) -> int:\\n        #Select a Range\\n        r1 = rand7()\\n        while r1 == 4:\\n            r1 = rand7()\\n        \\n        #Select a Number Within that Range\\n        r2 = rand7()\\n        while r2 > 5:\\n            r2 = rand7()\\n        \\n        #Return the Number\\n        return (5 if r1 > 4 else 0) + r2\\n\\'\\'\\'\\n\\nTo evaluate any sample functions I wrote I used 2 metrics. The first is a simple histogram of the numbers produced, the second is to look at the stochastic transition matrix produced by the sample (.i.e. if the previous sample returned x how likely is the next sample to return y?). For reference, here are some plots made by generating 100000 random numbers using rejection sampling (note that I changed the range from [1-10] to be [0-9] for convenience).\\n\\n![image](https://assets.leetcode.com/users/images/e1447b26-d1c2-41d3-9c59-3c6311235eed_1628181641.656291.png)\\n![image](https://assets.leetcode.com/users/images/440bc62f-705d-4e18-97a2-41214518c283_1628181682.8810203.png)\\n\\n\\nAs you can see, the histogram is essentially flat, which indicates that all numbers have an equal chace of being drawn. Furthermore, all the transition probabilities are very close to 1/10, indicating that the output doesn\\'t have an easilly discernable pattern.\\n\\nNext, here are are some plots made by generated 100000 random numbers using my modified xorshift:\\n\\n![image](https://assets.leetcode.com/users/images/582bce58-14c2-4aab-a351-088533de79e7_1628181764.9948664.png)\\n![image](https://assets.leetcode.com/users/images/c0716b00-f47e-45d7-8456-7ea9fa6ea196_1628181886.6024754.png)\\n\\nAs you can see, by these metrics, the performance of the random xorshift is essentially identical to the performance of rejection sampling. That does not mean that this algorithm is cryptographically secure, or that it could pass BigCrush, but it was definitely random enough for LeetCode, and random enough that I couldn\\'t easilly break it! If I wanted to make it stronger I\\'d consider adding one or two fixed xor shifts, and/or use bits from the middle of the bit string to generate the outputs.\\n\\n-------------------------------------------\\nNext, just to present a something which obviously fails, here\\'s some code which also passed LeetCode\\'s test cases.\\n\\nBest Performance : 236 ms/16.9 MB : 97%/41%\\n\\'\\'\\'\\n\\n    seed = 2999\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed += 3001\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed%10\\n\\'\\'\\'\\n\\nJust by intuition we already know that this random number generator should be terrible, since it produces the exact same sequence of numbers every time, and the next number is easy to calculate from the previous number. Here are the plots it generates:\\n\\n![image](https://assets.leetcode.com/users/images/22738aee-7041-494f-ad3a-c4dc48ea47b9_1628182551.0322888.png)\\n![image](https://assets.leetcode.com/users/images/3e550cc8-3328-4b13-9789-a766c1ef3f6a_1628182825.0660825.png)\\n\\n\\nSo, it\\'s distribution is perfectly uniform (tbh it\\'s so uniform that that should be a red flag), and it\\'s transition matrix clearly indicates what\\'s happening: a pointer which is being updated by 1 (mod 10) between each sample. The fact that this still passed LeetCode\\'s test cases tells us that they\\'re probably only looking at a histogram of the numbers you generate, and whether or not the standard deviation on the height of the histogram bins is small enough. Were they using anything more sophisticated then they should\\'ve caught this.\\n\\nWhat happens if we make this a little more sophisticated though?\\n\\nBest Performance : 224 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n    seed = 9\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed = (self.seed + rand7())%10\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/abf9ca0b-78d2-4a50-a93e-103daab75eb1_1628183431.6355002.png)\\n![image](https://assets.leetcode.com/users/images/5d78c97c-1da5-4946-999f-44828b865069_1628183480.924376.png)\\n\\nThis time there isn\\'t anything obviously wrong with the histogram! But when you look at the transition matrix there\\'s an obvious pattern (so obvious that you could easilly figure out how the numbers are being generated).\\n\\nAnd actually, every other method I tried which used a single rand7 call per update failed this transition matrix test (even if it passed LeetCode\\'s test cases), except for this final solution, which I don\\'t like because it really just plays to the test (I pretty much just kept finding more old random numbers to add until it\\'s transition matrix looked decent).\\n\\nBest Performance: 272 ms/17 MB : 97%/6%\\n\\n\\'\\'\\'\\n\\n    queue = deque([1, 2, 5, 4, 3, 5, 3, 7, 7, 1])\\n    seed = 8\\n    def rand10(self) -> int:\\n        #Generate a Random Number\\n        r = rand7()\\n        \\n        #Increment the Sum\\n        self.seed = (self.seed + self.queue[self.seed] + r + self.queue[r] + self.queue.popleft())%10\\n        \\n        #Record the Latest Random Number\\n        self.queue.append(r)\\n        \\n        #Return the Random Number\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/5bf15d38-b275-4291-b8cf-122a17937016_1628188466.5762591.png)\\n![image](https://assets.leetcode.com/users/images/99048987-e6f2-4615-a3ad-851cf2cc6ce1_1628188503.325822.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 817188,
                "title": "javascript-with-beginners-explanation-of-math",
                "content": "**PREAMBLE**\\n\\nGiven rand7( ), the function alone is not enough to provide a fine-grained enough variation of integer results to directly create rand10( ). That is, if we did\\n```\\n\\tconst rand10 = () => 10*Math.round(rand7()/7);\\n```\\nthe scope of possible results taking [10*(1/7), 10*(2/7)..., 10*(7/7)] would be limited to [1,3,4,6,7,9,10], i.e. it\\'s impossible to get the numbers  [2,5,8]. If the problem was to go from some function with more fine-grained set of possibilities to a smaller one (like creating rand7( ) from rand10( )) then the above approach would potentially be viable:\\n```\\n\\tconst rand7 = () => 7*Math.round(rand10/10);\\n```\\nas it creates the results [1,1,2,3,4,4,5,6,6,7] -- all required possible outcomes 1-7 are reachable but the probability is still not totally even as it should be (some numbers occur with 2/10 frequency while others occur with 1/10 frequency) and this distribution would be exposed for large numbers of tries of rand7( ).\\n\\n**THIS PROBLEM\\'S SOLUTIONS**\\n\\nThe key is to use multiple calls of rand7( ) to generate a large enough range of numbers that can be reduced down to the integers ranging from 1 - 10 inclusive with fairly even probability consistently. This means calls of rand7( ) must be increased in such a way that the result \"gaps\" noticed before are somehow overcome without skewing the distribution unfairly.\\n\\nOne approach is to sum rand7( ) calls and combine with modulo 10, creating a larger and larger possible range of rand7( ) sums between some lower and some upper bound until the breadth and variation in possible sums produced (in combination with modulo) satisfies all the test cases like so:\\n```\\n const rand10 = () => (rand7() + rand7() + ..... + rand7()) % 10 + 1;\\n const rand10 = () => (rand7() + rand7() + rand7() + rand7() + rand7()) % 10 + 1;   //final answer from trial and error\\n```\\nwhere rand7( )\\'s are added until the submit passes. By trial and error, a minimum of five calls to rand7( ) appear to be required to pass. \\n\\nAs others have pointed out, this appears to be because this is the threshold at which the probability distribution for (7 sided die)^5 producing sums 5 to 35 (see Wolfram: https://www.wolframalpha.com/input/?i=7+sided+die+rolled+5+times+distribution ), has been divided roughly equally after the modulo 10 which groups the probabilities by their last digit.\\n\\nEach outcome from 1 to 10 for rand10( ) gets three slices of the probability distribution (sums) above, spaced roughly evenly: from a cursory visual inspection you can see that P(5) + P(15) + P(25) is about equal to P(6)+P(16)+P(26) and so on. The even spacing of each last digit group in the distribution compensates for variations in adjacent values between one digit group and the next.\\n\\nLower numbers of dice do not work because they create distributions that are not as finely divided into different sums and can not be as evenly distributed to the 10 answers. When the discrepancies are pronounced to some arbitrary extent, the runs fail.\\n\\nThe five rand7( ) calls create the minimum necessary refinement of the range of answers. Additional rand7( ) calls would further refine the range of answers beyond the requirement and still pass but represent an unnecessary expenditure of speed and memory.\\n\\nAnother approach is to square two rand7( ) calls and calculate an answer like so:\\n\\n```\\nconst rand10 = () => {\\n    let random = 41;\\n    while (random > 40) random = 7 * (rand7() - 1) + rand7();\\n    return (random % 10) + 1; \\n};\\n```\\nthe range of possible square results, before the modulo 10 step, is 1 to 49. The largest full multiple of 10 within this range is 40 and is used as a bound for rejecting samples. \\n\\nIncluding samples ranging from 41 to 49 would unfairly add outcomes for rand10 => 2 to 10 to the answer pool, so the answer is only taken when the squared value is <= 40 to maintain even probability for rand10 => 1 to 10.",
                "solutionTags": [],
                "code": "```\\n\\tconst rand10 = () => 10*Math.round(rand7()/7);\\n```\n```\\n\\tconst rand7 = () => 7*Math.round(rand10/10);\\n```\n```\\n const rand10 = () => (rand7() + rand7() + ..... + rand7()) % 10 + 1;\\n const rand10 = () => (rand7() + rand7() + rand7() + rand7() + rand7()) % 10 + 1;   //final answer from trial and error\\n```\n```\\nconst rand10 = () => {\\n    let random = 41;\\n    while (random > 40) random = 7 * (rand7() - 1) + rand7();\\n    return (random % 10) + 1; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817075,
                "title": "c-simple-solution-faster-than-97-less-memory-than-93-explained-true-1-7-probability",
                "content": "We will generate number from 1 to 5,lets call it `b`,and then,we will decide if we want to add 5,or not using one more number,we will call it `a`\\nBut that decision must have same probability,50-50.\\nSo,i will generate `a`,its range is from 1 to 7,how can we get 50-50?\\nWe can take for example next rule:\\nIf `a==1` we will not add 5\\nIf `a==2` we will add 5\\nIf `a>2` lets generate `a` again,but that is not good solution,because probability that we will need to generate `a` again is 5/7,we want it to be as small as possible.\\nSo,lets use next rule\\nIf `a<4` we will not add 5\\nIf `a>4` we will add 5\\nIf `a==4` lets generate `a` again\\n\\nSimilar solution is to generate b from 1 to 5 using rand7\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a,b;\\n        do {\\n            a = rand7();\\n        } while (a==4);\\n        do {\\n            b = rand7();\\n        } while (b>5);\\n        return a>4?b+5:b;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a,b;\\n        do {\\n            a = rand7();\\n        } while (a==4);\\n        do {\\n            b = rand7();\\n        } while (b>5);\\n        return a>4?b+5:b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816956,
                "title": "why-is-my-solution-false-for-rand10",
                "content": "So here I roll rand7() until i get an integer in a 1 to 5 range\\n\\nthen I roll again between a range of 1 to 6. if the number is between 1-3 we return the pick and if it\\'s between 4-6 we double the result\\n\\nTo me each number have equal chances to get picked, enlight me please\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        pick = 10\\n        while pick > 5:\\n            pick = rand7()\\n        double = 10\\n\\t\\twhile double > 6:\\n\\t\\t\\tdouble = rand7()\\n        if double > 3:\\n            return pick * 2\\n        return pick\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        pick = 10\\n        while pick > 5:\\n            pick = rand7()\\n        double = 10\\n\\t\\twhile double > 6:\\n\\t\\t\\tdouble = rand7()\\n        if double > 3:\\n            return pick * 2\\n        return pick\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816904,
                "title": "java-1-line-beats-100-zero-calls-to-rand7-made",
                "content": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n\\n    /**\\n    Lets take input is 1000.\\n    The count will get incremented by 1, everytime the method rand10() is called.\\n    The idea here is to distribute values 1 to 10 equally.\\n    \\n    Let\\'s say rand10() is called for 447th time.\\n    At this point c = 447\\n    and 447%10 + 1 = 7 + 1 = 8 will be returned.\\n    \\n    \\n    */\\n    int count = 1;\\n    \\n    public int rand10() {\\n        return (count++)%10 + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n\\n    /**\\n    Lets take input is 1000.\\n    The count will get incremented by 1, everytime the method rand10() is called.\\n    The idea here is to distribute values 1 to 10 equally.\\n    \\n    Let\\'s say rand10() is called for 447th time.\\n    At this point c = 447\\n    and 447%10 + 1 = 7 + 1 = 8 will be returned.\\n    \\n    \\n    */\\n    int count = 1;\\n    \\n    public int rand10() {\\n        return (count++)%10 + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816759,
                "title": "python-three-different-solutions-with-comments",
                "content": "```\\nclass Solution:\\n    # Three helper functions\\n    \\n    def rand49(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 48\\n        Expected value of rand7() calls equal to 2 (It is deterministic) \\n        \\'\\'\\'\\n        multiple = rand7() - 1\\n        remainder = rand7() - 1\\n        return 7*multiple + remainder\\n    \\n    def rand2(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 1\\n        Expected value of rand7() calls equal to 1 + 1/6 = 7/6 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x == 7:\\n            x = rand7()\\n        return x % 2\\n\\n    def rand5(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 4\\n        Expected value of rand7() calls equal to 1 + 2/5 = 7/5 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x in [6,7]:\\n            x = rand7()\\n        return x % 5\\n        \\n    # Three solutions\\n    \\n    def rand10_method_1(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2 * (9/40) = 2.45 \\n        \\'\\'\\'\\n        x = self.rand49()\\n        while x in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n            x = self.rand49()\\n        return 1 + x % 10\\n    \\n    def rand10_method_2(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2/7(7/5) + (5/7)(7/6) = 2.2(3) \\n        \\'\\'\\'\\n        x = rand7()\\n        if x in [1,2]:\\n            y = self.rand5()\\n            return 5*(x-1) + y + 1 \\n        if x in [3,4,5,6,7]:\\n            y = self.rand2()\\n            return 5*y + (x-3) + 1\\n\\n    def rand10_method_3(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 2.19(3) \\n        \\'\\'\\'\\n        while True:\\n            x = rand7() - 1 #  Uniform Distribution (UD) on 0,...,6\\n            y = rand7() - 1 # UD on 0,...,6\\n            result = (x)*7 + y # UD on 0,1,...,48\\n            if result not in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n                # result conditionally uniformly distributed on 0,...,49\\n                return result % 10 + 1 # result % 10 UD on 0,...,9 \\n            else:\\n                x = result - 40 # UD on 0,...,8\\n                y = rand7() - 1 # UD on 0,...,6\\n                result = x * 7 + y # UD on 0,...,62\\n                if result not in range(60,63): #[60,61,62]\\n                    # result conditionally uniformly distributed on 0,...,59\\n                    return result % 10 + 1 # result % 10 UD on 0,...,9\\n                else:\\n                    x = result - 60 # UD on 0,...,2\\n                    y = rand7() - 1# UD on 0,...,6\\n                    result = (x)*7 + y # UD on 0,1,...,20\\n                    if result != 20:\\n                        # conditionally uniformly distributed on 0,...,19\\n                        return result % 10 + 1 # result % 10 has uniform distribution on 0,...,9\\n                    else: continue\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Three helper functions\\n    \\n    def rand49(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 48\\n        Expected value of rand7() calls equal to 2 (It is deterministic) \\n        \\'\\'\\'\\n        multiple = rand7() - 1\\n        remainder = rand7() - 1\\n        return 7*multiple + remainder\\n    \\n    def rand2(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 1\\n        Expected value of rand7() calls equal to 1 + 1/6 = 7/6 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x == 7:\\n            x = rand7()\\n        return x % 2\\n\\n    def rand5(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 4\\n        Expected value of rand7() calls equal to 1 + 2/5 = 7/5 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x in [6,7]:\\n            x = rand7()\\n        return x % 5\\n        \\n    # Three solutions\\n    \\n    def rand10_method_1(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2 * (9/40) = 2.45 \\n        \\'\\'\\'\\n        x = self.rand49()\\n        while x in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n            x = self.rand49()\\n        return 1 + x % 10\\n    \\n    def rand10_method_2(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2/7(7/5) + (5/7)(7/6) = 2.2(3) \\n        \\'\\'\\'\\n        x = rand7()\\n        if x in [1,2]:\\n            y = self.rand5()\\n            return 5*(x-1) + y + 1 \\n        if x in [3,4,5,6,7]:\\n            y = self.rand2()\\n            return 5*y + (x-3) + 1\\n\\n    def rand10_method_3(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 2.19(3) \\n        \\'\\'\\'\\n        while True:\\n            x = rand7() - 1 #  Uniform Distribution (UD) on 0,...,6\\n            y = rand7() - 1 # UD on 0,...,6\\n            result = (x)*7 + y # UD on 0,1,...,48\\n            if result not in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n                # result conditionally uniformly distributed on 0,...,49\\n                return result % 10 + 1 # result % 10 UD on 0,...,9 \\n            else:\\n                x = result - 40 # UD on 0,...,8\\n                y = rand7() - 1 # UD on 0,...,6\\n                result = x * 7 + y # UD on 0,...,62\\n                if result not in range(60,63): #[60,61,62]\\n                    # result conditionally uniformly distributed on 0,...,59\\n                    return result % 10 + 1 # result % 10 UD on 0,...,9\\n                else:\\n                    x = result - 60 # UD on 0,...,2\\n                    y = rand7() - 1# UD on 0,...,6\\n                    result = (x)*7 + y # UD on 0,1,...,20\\n                    if result != 20:\\n                        # conditionally uniformly distributed on 0,...,19\\n                        return result % 10 + 1 # result % 10 has uniform distribution on 0,...,9\\n                    else: continue\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816505,
                "title": "video-solution-with-easy-explaination",
                "content": "https://www.youtube.com/watch?v=idQvHZPeWMI\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int noLesser40 = 41;\\n        while(noLesser40 >= 40) { // till the time it is not less than 40\\n            noLesser40 = (rand7() -1)*7 + rand7() -1; \\n        }\\n        return noLesser40% 10 + 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends SolBase {\\n    public int rand10() {\\n        int noLesser40 = 41;\\n        while(noLesser40 >= 40) { // till the time it is not less than 40\\n            noLesser40 = (rand7() -1)*7 + rand7() -1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816458,
                "title": "rand10-c-very-simple",
                "content": "```\\nstatic int num = INT_MAX;\\nclass Solution {\\npublic:\\n    int rand10() {\\n        num = num - 7;\\n        return (num + rand7()) % 10 + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int num = INT_MAX;\\nclass Solution {\\npublic:\\n    int rand10() {\\n        num = num - 7;\\n        return (num + rand7()) % 10 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816358,
                "title": "c-why-wrong",
                "content": "I just want to ask what is wrong with this solution\\n\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n      \\n        while(1){\\n              int s=0;\\n        for(int i=0;i<10;i++)\\n        s=s+rand7();\\n        if(s==70)\\n            continue;\\n            s=s-10;\\n            return s/6+1;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n      \\n        while(1){\\n              int s=0;\\n        for(int i=0;i<10;i++)\\n        s=s+rand7();\\n        if(s==70)\\n            continue;\\n            s=s-10;\\n            return s/6+1;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816281,
                "title": "expand-and-fill",
                "content": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        a = 6\\n        while a >= 6:\\n            a = rand7()\\n        b = 7\\n        while b == 7:\\n            b = rand7()\\n        return 2*a-(b%2)\\n```\\nLet `a` be one of  `{1, 2, 3, 4, 5}`\\uFF0Cthen we have `2a` being one of `{2, 4, 6, 8, 10}`, each with a probability  of `0.2`. Then find another number `b` which is not `7`, being one of `{1, 2, 3, 4, 5, 6}`, so that it has a fair chance of being even or odd. Consequently we can get a `0` or `1` out of `b` by taking its modulus of 2. Finally, subtraction of `a` and `b%2` yields an integer with in the range `[1, 10]`. The generations of `a` and `b` are independent, so the probability of each combination is `0.2*0.5=0.1`. Thus we have a uniform distribution.\\n\\nThe crux to this problem is `UNIFORM`. The most simplistic way to guarantee that is to make sure there is one and only one way to generate a specific number. So that\\'s what I did. First, you need a range `at least` as long as 10.   \\n\\nThat\\'s easy, a multiplication by 2 will do. Then you realize not all numbers in this range are accessible: 3, 9 .etc.  \\n\\nHow do we fix that ? We try to shift the result by at most 1. And that\\'s what `b` is for.  \\n\\nBy `at least`, I mean there are other ways. Like if we multiply the range by 3, it works too. The important thing here is to make sure no overlapping happens.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        a = 6\\n        while a >= 6:\\n            a = rand7()\\n        b = 7\\n        while b == 7:\\n            b = rand7()\\n        return 2*a-(b%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816248,
                "title": "python-by-random-variable-mapping-w-comment",
                "content": "**Hint**\\n\\nFirst of all, [rand7() is provided by description](https://leetcode.com/problems/implement-rand10-using-rand7/), and it is guaranteed to yield unifrom random number in 1 ~ 7.\\n\\nOur objective is to make rand10( ) from rand7( )\\n\\nThink of number representation in base 7.\\n\\nWhen we run rand7( ) once, we can get 1 ~ 7^1 = 1 ~ 7\\nRange 1 ~ 7 is too small for re-mapping to 1 ~ 10.\\n\\nWhen we run rand7( ) twice, we can get 1 ~ 7^2 = 1 ~ 49\\nRange 1 ~ 49 is large enough.\\n\\nGenerate uniform random number by invoking rand7( ) twice, called **random_num**, from 1 ~ 49\\nKeep doing so until random number is in range 1 ~ 40\\n\\nNext, map random_num from 1 ~ 40 down to 1 ~ 10 by modulo with offset ( i.e., **random_num** %10 + 1)\\n\\nFinally, we implement rand10( ) by calling rand7( ), and output number 1 ~ 10 with uniform distribution.\\n\\n---\\n\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        \\n        while True:\\n\\t\\t\\n\\t\\t\\t# generate a random number from 1 ~ 49 with uniform distribution\\n            random_num = ( rand7() - 1 ) * 7 + rand7()\\n            \\n            if random_num <= 40:\\n\\t\\t\\t\\n\\t\\t\\t    # map 1 ~ 40 to 1 ~ 10 by modulo operation with offset\\n                return random_num % 10 + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        \\n        while True:\\n\\t\\t\\n\\t\\t\\t# generate a random number from 1 ~ 49 with uniform distribution\\n            random_num = ( rand7() - 1 ) * 7 + rand7()\\n            \\n            if random_num <= 40:\\n\\t\\t\\t\\n\\t\\t\\t    # map 1 ~ 40 to 1 ~ 10 by modulo operation with offset\\n                return random_num % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693434,
                "title": "why-does-this-simple-solution-work-and-beat-60",
                "content": "I submitted this solution thinking no way this will get accepted but this beat 60% of C++ submissions.\\n\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0;i<10;i++) {\\n            sum += rand7();\\n        }\\n        return sum%10 + 1;\\n    }\\n};\\n```\\n\\nMy thought process was first make sure we can get a multiple of 10 from 7 by repeatedly adding rand7() 10 times, then if we mod that by 10 we should be getting a number from 0 to 9 with equal probability.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0;i<10;i++) {\\n            sum += rand7();\\n        }\\n        return sum%10 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635094,
                "title": "why-my-implementation-doesn-t-work",
                "content": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int out=(rand7()+rand7())%11;\\n        return out==0 ? rand10():out;\\n    }\\n}\\n```\\nwhy does this implementation fails for test case input 1000?\\nalthough it passes 7/10 test cases.\\ncan someone explain",
                "solutionTags": [],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int out=(rand7()+rand7())%11;\\n        return out==0 ? rand10():out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544599,
                "title": "quick-n-easy-ruby-solution",
                "content": "This was inspired by some other folks answers in other languages. I\\'m stiiilllll trying to wrap my head around this one, a bit, but wanted to contribute a Ruby solution since (a) there weren\\'t any yet and (b) to help myself better parse this problem.\\n\\n```ruby\\ndef rand10\\n  r = (rand7 - 1) * 7 + (rand7 - 1)\\n\\n  if r < 40\\n    return (r % 10) + 1\\n  else\\n    rand10\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef rand10\\n  r = (rand7 - 1) * 7 + (rand7 - 1)\\n\\n  if r < 40\\n    return (r % 10) + 1\\n  else\\n    rand10\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 514398,
                "title": "470-implement-rand10-using-rand7-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Radom a Greater Range then Mod**\\n| O(T): O(1) | O(S): O(1) | Rt: 340ms | \\n```python\\nclass Solution:\\n    def rand10(self):\\n        while True:\\n            #random [0, 48] or [0, 49)\\n            candidate = 7 * (rand7() - 1) + (rand7() - 1)  \\n            #random [0, 39] or [0, 40)\\n            if candidate < 40: return candidate % 10 + 1\\n```\\nReferrence: https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rand10(self):\\n        while True:\\n            #random [0, 48] or [0, 49)\\n            candidate = 7 * (rand7() - 1) + (rand7() - 1)  \\n            #random [0, 39] or [0, 40)\\n            if candidate < 40: return candidate % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483816,
                "title": "c-10",
                "content": "// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution \\n{\\n    public:\\n        \\n    int rand10()     \\n    {   \\n        while(true)\\n        {\\n            const int a1 = rand7();\\n            const int a2 = rand7();\\n            \\n            if(a1 == 1 && a2 == 1)\\n            {\\n                return 1;\\n            }\\n            else if(a1 == 1 && a2 == 2)\\n            {\\n                return 2;\\n            }\\n            else if(a1 == 1 && a2 == 3)\\n            {\\n                return 3;\\n            }\\n            else if(a1 == 1 && a2 == 4)\\n            {\\n                return 4;\\n            }\\n            else if(a1 == 1 && a2 == 5)\\n            {\\n                return 5;\\n            }\\n            else if(a1 == 1 && a2 == 6)\\n            {\\n                return 6;\\n            }\\n            else if(a1 == 1 && a2 == 7)\\n            {\\n                return 7;\\n            }\\n            else if(a1 == 2 && a2 == 7)\\n            {\\n                return 8;\\n            }\\n            else if(a1 == 3 && a2 == 7)\\n            {\\n                return 9;\\n            }\\n            else if(a1 == 4 && a2 == 7)\\n            {\\n                return 10;\\n            }\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n        \\n    int rand10()     \\n    {   \\n        while(true)\\n        {\\n            const int a1 = rand7();\\n            const int a2 = rand7();\\n            \\n            if(a1 == 1 && a2 == 1)\\n            {\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 462832,
                "title": "python3-solution-accepted-but-not-sure-why",
                "content": "it was accepted, and my simulation showed that it is uniformly distributed, but i can\\'t prove it. it\\'d be great if someone can help me to explain....\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(10):\\n            res += rand7()\\n        return res%10+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(10):\\n            res += rand7()\\n        return res%10+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443152,
                "title": "brand-new-and-easier-way-in-python3",
                "content": "This way is not that fast, because the result it need is 10/49 and other results will be throwed away. \\n```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            t1 = rand7()\\n            t2 = rand7()\\n            if t1 in range(1, 6) and t2 in range(6, 8):\\n                if t2 == 6:\\n                    return t1\\n                else:\\n                    return t1+5\\n            elif t2 in range(1, 6) and t1 in range(6, 8):\\n                if t1 == 6:\\n                    return t2\\n                else:\\n                    return t2+5\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            t1 = rand7()\\n            t2 = rand7()\\n            if t1 in range(1, 6) and t2 in range(6, 8):\\n                if t2 == 6:\\n                    return t1\\n                else:\\n                    return t1+5\\n            elif t2 in range(1, 6) and t1 in range(6, 8):\\n                if t1 == 6:\\n                    return t2\\n                else:\\n                    return t2+5\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 405451,
                "title": "can-someone-explain-why-is-this-not-a-solution",
                "content": "rand7 will generate 1..7\\nrand7 // 2 will generate 0..3\\n\\nCombine togetger we will have range from 1..10\\nBut my solution got rejected. Can someone help?\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return rand7() + (rand7() // 2)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return rand7() + (rand7() // 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336747,
                "title": "reframing-the-solution",
                "content": "Here is another way to think about it:\\n\\nYou are using `rand7` to generate each digit of a two-digit base-seven number:\\n* You evaluate `rand7() - 1` to get a random number from 0-6. Let\\'s say this number is 5. This is the first digit.\\n* You evaluate `rand7() - 1` again to get another random number. Let\\'s say this number is 3. This is the second digit.\\n* Multiply the first digit by 7 and then add the second, to get (53)<sub>7</sub> = (38)<sub>10</sub>.\\n\\nYou now have a number chosen uniformly at random from 0-(66)<sub>7</sub> inclusive, which is the same as  0-48. Why is it uniform? Because there is a one-to-one mapping from pairs of digits (x, y) to base-seven numbers (xy)<sub>7</sub>, and each pair of digits is equally likely to occur.\\n\\nTo get a number chosen uniformly at random from 0-39, we just generate numbers by the above procedure and take the first that is less than 40. Now we can floor-divide this number by 4 to get a number from 0-9, and then add one to get a number chosen uniformly at random from 1-10.\\n\\n```python\\ndef rand10():\\n\\twhile True:\\n\\t\\tx = 7*(rand7()-1) + (rand7()-1)\\n\\t\\tif x < 40:\\n\\t\\t\\tbreak\\n\\treturn (x // 4) + 1\\n```",
                "solutionTags": [],
                "code": "```python\\ndef rand10():\\n\\twhile True:\\n\\t\\tx = 7*(rand7()-1) + (rand7()-1)\\n\\t\\tif x < 40:\\n\\t\\t\\tbreak\\n\\treturn (x // 4) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 292367,
                "title": "generate-random-value-in-any-range-o-logn",
                "content": "First we generate 0 or 1 random value (rand2()) and then we can generate a random value in any range using the same function.\\n\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    \\n    // Generate 0 or 1 uniformly\\n    int rand2() {\\n        int x = 7;\\n        while (x == 7) {\\n            x = rand7();\\n        }\\n        return x <= 3;\\n    }\\n    \\n    // Generate any range random variable uniformly using rand2()\\n    int randRange(int start, int end) {\\n        int res = end;\\n        end -= start;\\n\\t\\t\\n        while (res > end) {\\n            res = 0;\\n            for (int i = 0; i <= floor(log2(end)); i++) {\\n                res |= rand2();\\n                res <<= 1;\\n            }\\n            res >>= 1;\\n        }\\n        return start + res;\\n    }\\n    \\n    int rand10() {\\n        return randRange(1, 10);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    \\n    // Generate 0 or 1 uniformly\\n    int rand2() {\\n        int x = 7;\\n        while (x == 7) {\\n            x = rand7();\\n        }\\n        return x <= 3;\\n    }\\n    \\n    // Generate any range random variable uniformly using rand2()\\n    int randRange(int start, int end) {\\n        int res = end;\\n        end -= start;\\n\\t\\t\\n        while (res > end) {\\n            res = 0;\\n            for (int i = 0; i <= floor(log2(end)); i++) {\\n                res |= rand2();\\n                res <<= 1;\\n            }\\n            res >>= 1;\\n        }\\n        return start + res;\\n    }\\n    \\n    int rand10() {\\n        return randRange(1, 10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285076,
                "title": "rejection-sampling-simple-clean-code",
                "content": "```\\nclass Solution {\\n    bool flag = false; \\npublic:\\n    int rand10() {\\n        int result;\\n        \\n        do{\\n            result = rand7();\\n        } while (result > 5);\\n        \\n        if(flag)  {\\n            flag = false;\\n            return result;\\n        }\\n        \\n        else{\\n            flag = true;\\n            return result + 5;\\n        }                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool flag = false; \\npublic:\\n    int rand10() {\\n        int result;\\n        \\n        do{\\n            result = rand7();\\n        } while (result > 5);\\n        \\n        if(flag)  {\\n            flag = false;\\n            return result;\\n        }\\n        \\n        else{\\n            flag = true;\\n            return result + 5;\\n        }                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273777,
                "title": "go-very-easy-2-57-calls",
                "content": "```\\nfunc rand10() int {\\n    base, pro := 7, 7\\n    for base > 5 {\\n      base = rand7() \\n    }\\n    for pro > 6 {\\n        pro = rand7()\\n    }\\n    pro = pro % 2\\n    return pro*5 + base\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rand10() int {\\n    base, pro := 7, 7\\n    for base > 5 {\\n      base = rand7() \\n    }\\n    for pro > 6 {\\n        pro = rand7()\\n    }\\n    pro = pro % 2\\n    return pro*5 + base\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244824,
                "title": "the-test-cases-don-t-seem-to-test-randomness-is-my-solution-actually-random",
                "content": "```\\nint rand10() { \\n    // first call map 1-3 to 1 and 4-6 to 0\\n    int first = rand7();\\n    int second = rand7();\\n    while(first > 6 || second > 5){\\n        first = rand7();\\n        second = rand7();\\n    }\\n    unsigned multiplier = first < 4 ? 0 : 1;\\n    return second + multiplier*5;\\n}\\n```\\nThe idea is that we get a number 1-5 by using a call to rand7() and rejecting 6 and 7. The we use another call to rand7() to get 1-6, rejecting 7, which we can then group into two groups 1-3 and 4-6. If the second number is in the 4-6 range then we add 5 to our first 1-5 that we got, otherwise we don\\'t.",
                "solutionTags": [],
                "code": "```\\nint rand10() { \\n    // first call map 1-3 to 1 and 4-6 to 0\\n    int first = rand7();\\n    int second = rand7();\\n    while(first > 6 || second > 5){\\n        first = rand7();\\n        second = rand7();\\n    }\\n    unsigned multiplier = first < 4 ? 0 : 1;\\n    return second + multiplier*5;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223622,
                "title": "simple-c-solution-avg-2-6-calls",
                "content": "**Fisrt step:** \\nRun rand7(). If result lies in [1,5], we consider the output corresponds to categories 1-2,3-4,5-6,7-8,9-10, respectively. If output is 6 or 7, then rerun the first step.\\n**Second step:**\\nRun rand7(). If result is odd, we consider the output corresponds to the odd number within the catetory identified as the first step. If result is even, we consider the output corresponds to the even number within the catetory identified as the first step. The only exeception is 7, in that case we rerun the second step.\\n```\\nclass Solution {\\npublic:\\n    int rand10() \\n    {\\n        int m = rand7();\\n        while (m>5)\\n            m = rand7();\\n        int n = rand7();\\n        while (n==7)\\n            n = rand7();\\n        \\n        return (m-1)*2+n%2+1;\\n    }\\n};\\n```\\nThe expected calls in the first step: ```1*5/7+2*(2/7)*5/7+3*(2/7)^2*5/7+...+k*(2/7)^(k-1)*5/7```\\nThe expected calls in the second step: ```1*6/7+2*(1/7)*6/7+3*(1/7)^2*6/7+...+k*(1/7)^(k-1)*6/7```\\nTotal expected calls needed to generate one rand10() is around 2.6",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() \\n    {\\n        int m = rand7();\\n        while (m>5)\\n            m = rand7();\\n        int n = rand7();\\n        while (n==7)\\n            n = rand7();\\n        \\n        return (m-1)*2+n%2+1;\\n    }\\n};\\n```\n```1*5/7+2*(2/7)*5/7+3*(2/7)^2*5/7+...+k*(2/7)^(k-1)*5/7```\n```1*6/7+2*(1/7)*6/7+3*(1/7)^2*6/7+...+k*(1/7)^(k-1)*6/7```",
                "codeTag": "Java"
            },
            {
                "id": 152282,
                "title": "c-2-line",
                "content": "```\\nint rand10() {\\n        auto x = (rand7()-1)*7 + rand7();\\n        return x<=40 ? x%10 +1 : rand10();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n        auto x = (rand7()-1)*7 + rand7();\\n        return x<=40 ? x%10 +1 : rand10();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150480,
                "title": "c-average-2-57-rand7-usage",
                "content": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tint rand10() {\\n\\t\\t\\t\\t\\tbool filling = 0;\\n\\t\\t\\t\\t\\tint num = 7;\\n\\t\\t\\t\\t\\twhile(num ==7) num = rand7();\\n\\t\\t\\t\\t\\tfilling = num % 2; // rand2()\\n\\t\\t\\t\\t\\tnum = 10;\\n\\t\\t\\t\\t\\twhile(num>=10) num = (rand7() - 1) * 2 + filling;\\n\\t\\t\\t\\t\\treturn num + 1;\\n\\t\\t\\t}\\n\\t};\\n```\\nHint from [this post](https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22)\\nTo get rand2() from rand7(), the expectation would be 7/6 tries.\\nTo get rand10() from rand14(), the expectation will be 7/5 tries.",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tint rand10() {\\n\\t\\t\\t\\t\\tbool filling = 0;\\n\\t\\t\\t\\t\\tint num = 7;\\n\\t\\t\\t\\t\\twhile(num ==7) num = rand7();\\n\\t\\t\\t\\t\\tfilling = num % 2; // rand2()\\n\\t\\t\\t\\t\\tnum = 10;\\n\\t\\t\\t\\t\\twhile(num>=10) num = (rand7() - 1) * 2 + filling;\\n\\t\\t\\t\\t\\treturn num + 1;\\n\\t\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150298,
                "title": "python-use-two-rand7-calls-to-generate-rand10",
                "content": "For any `M < N`, a given uniform random integer `randN()` can be used to generate `randM()` by considering the conditional probability. Specifically,\\n\\n`Prob(randN() = i | randN() <= M) = Prob(randN() = i and randN() <= M) / Prob(randN() <= M) = (1 / N) / (M / N) = 1 / M`\\n\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        def rand5():\\n            \"\"\"Generate a uniform random integer in the range 1 to 5.\"\"\"\\n            i = rand7()\\n            while True:\\n                if i < 6:\\n                    return i\\n                i = rand7()\\n                \\n            return 0\\n        \\n        # Use rand7() to generate a uniform random integer in the range\\n        # 1 to 6.\\n        group = rand7()\\n        while True:\\n            if group < 7:\\n                if group % 2 != 0:\\n                    # If it is odd, we generate a uniform random integer\\n                    # {1, 3, 5, 7, 9}.\\n                    return 2 * rand5() - 1\\n                else:\\n                    # If it is even, we generate a uniform random integer\\n                    # {2, 4, 6, 8, 10}.\\n                    return 2 * rand5()\\n            \\n            group = rand7()\\n            \\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        def rand5():\\n            \"\"\"Generate a uniform random integer in the range 1 to 5.\"\"\"\\n            i = rand7()\\n            while True:\\n                if i < 6:\\n                    return i\\n                i = rand7()\\n                \\n            return 0\\n        \\n        # Use rand7() to generate a uniform random integer in the range\\n        # 1 to 6.\\n        group = rand7()\\n        while True:\\n            if group < 7:\\n                if group % 2 != 0:\\n                    # If it is odd, we generate a uniform random integer\\n                    # {1, 3, 5, 7, 9}.\\n                    return 2 * rand5() - 1\\n                else:\\n                    # If it is even, we generate a uniform random integer\\n                    # {2, 4, 6, 8, 10}.\\n                    return 2 * rand5()\\n            \\n            group = rand7()\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097362,
                "title": "rust-5ms",
                "content": "# Code\\n```rust\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        (0..)\\n            .map(|_| (rand7() - 1) * 7 + (rand7() - 1))\\n            .skip_while(|&i| i >= 40)\\n            .map(|i| i % 10 + 1)\\n            .next()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        (0..)\\n            .map(|_| (rand7() - 1) * 7 + (rand7() - 1))\\n            .skip_while(|&i| i >= 40)\\n            .map(|i| i % 10 + 1)\\n            .next()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046148,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined for you.\\n * var rand7 = function() {}\\n * @return {number} a random integer in the range 1 to 7\\n */\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let index = Math.trunc(Math.random() * nums.length);\\n    return nums[index];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined for you.\\n * var rand7 = function() {}\\n * @return {number} a random integer in the range 1 to 7\\n */\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let index = Math.trunc(Math.random() * nums.length);\\n    return nums[index];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042878,
                "title": "simple-easy-to-understand-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int v1 = rand7(),v2 = rand7();\\n        while(v1>5) v1 = rand7();\\n        while(v2==7) v2 = rand7();\\n        return v2<=3?v1:v1+5; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Rejection Sampling",
                    "Randomized",
                    "Probability and Statistics"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int v1 = rand7(),v2 = rand7();\\n        while(v1>5) v1 = rand7();\\n        while(v2==7) v2 = rand7();\\n        return v2<=3?v1:v1+5; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020443,
                "title": "formula-based",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while(true){\\n        int row=7*(rand7()-1);\\n        int col=rand7();\\n        int curr=row+col;\\n  if(curr<=40)\\n  return curr%10+1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while(true){\\n        int row=7*(rand7()-1);\\n        int col=rand7();\\n        int curr=row+col;\\n  if(curr<=40)\\n  return curr%10+1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017571,
                "title": "beats-89-43-simple-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n\\n        int comb = (x-1)*7 + y;\\n\\n        if (comb <=40){\\n            return comb%10+1;\\n        }\\n       \\n\\n       return rand10();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n\\n        int comb = (x-1)*7 + y;\\n\\n        if (comb <=40){\\n            return comb%10+1;\\n        }\\n       \\n\\n       return rand10();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017167,
                "title": "what-about-rand7-rand7-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nrand7()+rand7()%4 = ([1, 7]+[1, 7]%4)==> ([1, 7]+[0, 3]) ==> [1, 10]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nrand7()+rand7()%4 = ([1, 7]+[1, 7]%4)==> ([1, 7]+[0, 3]) ==> [1, 10]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code",
                "codeTag": "Unknown"
            },
            {
                "id": 4001713,
                "title": "implement-rand10-using-rand7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=1;i<=10;i++)\\n        {\\n            arr.add(i);\\n        }\\n        int index = (int)(Math.random()*arr.size());\\n        return arr.get(index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=1;i<=10;i++)\\n        {\\n            arr.add(i);\\n        }\\n        int index = (int)(Math.random()*arr.size());\\n        return arr.get(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975760,
                "title": "rejecting-sampling",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used rejection sampling to get uniform random variables of [1,5]\\nand [1,2], that way we can represent 10 different numbers (which i stored in the array arr, see the code)\\nprobabilty to get one of [1,2,3,4,5] when rejecting 6 and 7 is 0.2\\nprobability to get even or odd number number in [1,2,3,4,5,6] is 0.5\\n(while rejecting 7)\\nso in total we got 0.2 * 0.5 = 0.1 probability to get all numbers from [1,10]\\n\\nexpectency calculation.\\nlet $$x$$ be random variable. as you know, if x ~ Geo(p) it means that x is the number of tries until first success, in our case probabily for success is $$5/7 $$ hence x ~ Geo(5/7), it is known that for geometry distributed random variables $$E(x) = 1/p = 7/5$$\\n\\nlet y be random variable, same as previously explained, y ~ Geo(6/7)\\nso $$E(y) = 7/6$$\\n\\ntotal $$E(X + Y) = 7/5 + 7/6 = 2.56$$\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        arr = [[1,2],[3,4],[5,6],[7,8],[9,10]]\\n        val1 = rand7()\\n        while val1 >= 6:\\n            val1 = rand7()\\n        val2 = rand7()\\n        while val2 >= 7:\\n            val2 = rand7()\\n        return arr[val1 - 1][val2 % 2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        arr = [[1,2],[3,4],[5,6],[7,8],[9,10]]\\n        val1 = rand7()\\n        while val1 >= 6:\\n            val1 = rand7()\\n        val2 = rand7()\\n        while val2 >= 7:\\n            val2 = rand7()\\n        return arr[val1 - 1][val2 % 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973579,
                "title": "best-java-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\n\\n // taken some help;\\n \\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int a = rand7();\\n        int b = rand7();\\n\\n        int val = a+(b-1)*7;\\n\\n        if(val<=40) return (val-1)%10+1;\\n        else return rand10();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\n\\n // taken some help;\\n \\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int a = rand7();\\n        int b = rand7();\\n\\n        int val = a+(b-1)*7;\\n\\n        if(val<=40) return (val-1)%10+1;\\n        else return rand10();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946272,
                "title": "rejection-sampling-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946271,
                "title": "rejection-sampling-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899919,
                "title": "rejection-sampling-easy-implementataion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x,y,num;\\n        do{\\n            x=rand7();\\n            y=rand7();\\n            num= x+(y-1)*7;\\n        }while(num>40);\\n        return 1+(num-1)%10;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x,y,num;\\n        do{\\n            x=rand7();\\n            y=rand7();\\n            num= x+(y-1)*7;\\n        }while(num>40);\\n        return 1+(num-1)%10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897671,
                "title": "python-solution-with-probability-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 iid events probility equal to pr(even1)*pr(event2)\\nso if we want generate number with rand10 mean every number from 1-10 draw with uniform probability 1/10\\nwe can think generate this event in 2 steps in sequentail:\\n1. generate event with pr=0.5\\n2. generate anther event with pr=0.2\\nso totally pr=0.5*0.2\\n\\nwhat means for rand10?think of generate number from 1-10,each with pr 1/10:\\n1. we divid 1-10 to 2 group:[1-5] and [6-10], each draw with pr=0.5, how to do?\\n  as rand7 gen 1-7 we can say, if rand7 gen 1-3 we use first group, if gen 5-7 use second one, but equal to 4 draw again until success.\\n\\n2. same ideal for draw a number from the chosen gropup except with pr=0.2\\n  with rand7 gen a number and if in [1-5] we map to one of them, ohterwise repeate.\\n\\nexpection call for rand7:\\nin 1 step need 7/6 call for rand7,and 7/5 for 2step, totally:\\n2.56 calls for rand7\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        r=rand7()\\n        while r==4:r=rand7()\\n        base=0 if r<4 else 5\\n        r=rand7()\\n        while r>5:r=rand7()\\n        return base+r\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        r=rand7()\\n        while r==4:r=rand7()\\n        base=0 if r<4 else 5\\n        r=rand7()\\n        while r>5:r=rand7()\\n        return base+r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894085,
                "title": "python3-solution",
                "content": "# Intuition\\nUse two `rand7()` to get a two-digit 7-base number $X = Y_1 + 7 Y_2$. The number is at most 49. If the number is greater than 40, regenerate another sample. Conditioning on the condition $X \\\\le 40$, $X$ is uniformly distributed in $[1, \\\\cdots, 40]$. So, $\\\\mod(X, 10)$ is uniformly distributed.\\n\\n$$P(X \\\\le 40) = \\\\frac{40}{49}$$ so on average, one needs $49/40$ number of $X$ generations.\\n\\n\\n# Complexity\\n- Time complexity:\\nSuppose `rand7()` costs $r$ numbers of operations. The total cost of `rand10()` is about $2.5 r$.\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        x = (rand7() - 1) * 7 + rand7() - 1\\n        while x >= 40:\\n            x = (rand7() - 1) * 7 + rand7() - 1\\n        return x % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        x = (rand7() - 1) * 7 + rand7() - 1\\n        while x >= 40:\\n            x = (rand7() - 1) * 7 + rand7() - 1\\n        return x % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875465,
                "title": "python-only-use-return-value",
                "content": "\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return randrange(1, 11)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return randrange(1, 11)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861982,
                "title": "javascript-easy-method-beats-100-faster-beginner-s-friendly",
                "content": "# Code\\n```\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let randomIndex = Math.trunc(Math.random() * 10);\\n   return nums[randomIndex];\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let randomIndex = Math.trunc(Math.random() * 10);\\n   return nums[randomIndex];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835506,
                "title": "beat-100-of-implementation-in-any-langage-with-this-simple-trick",
                "content": "# Intuition\\n\\nWe just abuse the fact that there is no mention of independence between the uniform random variables, and this is not tested to validate the generated data.\\n\\n# Complexity\\n\\n$$\\n\\\\mathbb{E}\\\\left[ \\\\mathrm{rand7}_\\\\mathrm{calls} \\\\right] = \\\\frac{1}{n}\\n$$\\n\\nwhere $n$ is the size of the sample to generate\\n\\n# Code python\\n```python\\nclass Solution:\\n    def __init__(self):\\n        # we still call rand7 because if we dont\\n        # the result is not random stricto sensu\\n        self.x = rand7()\\n\\n    def rand10(self):\\n        self.x = (self.x + 1) % 10\\n        return self.x + 1\\n\\n```\\n\\n# Code C\\n```c\\nint rand10() {\\n    static int initialized = 0;\\n    static int state = 0;\\n\\n    if (!initialized) {\\n        initialized = 1;\\n        state = rand7();\\n    }\\n    \\n    state += 1;\\n    state %= 10;\\n    return state + 1;\\n}```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        # we still call rand7 because if we dont\\n        # the result is not random stricto sensu\\n        self.x = rand7()\\n\\n    def rand10(self):\\n        self.x = (self.x + 1) % 10\\n        return self.x + 1\\n\\n```\n```c\\nint rand10() {\\n    static int initialized = 0;\\n    static int state = 0;\\n\\n    if (!initialized) {\\n        initialized = 1;\\n        state = rand7();\\n    }\\n    \\n    state += 1;\\n    state %= 10;\\n    return state + 1;\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3825344,
                "title": "simple-java-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817682,
                "title": "o-1-solution-in-java-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMapping rand7 with rand10.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince rand10 can produce numbers from [1 to 10] and rand7 can produce numbers from [1 to 7] we cannot map rand7 to rand10 directly because it is not possible to map smaller group [1 to 7] with a bigger group [1 to 10]. To achieve a uniform distribution of numbers between 1 and 10 using rand7(), we need to use two instances of rand7() to generate a range of numbers greater than 10. This ensures that all numbers between 1 and 10 have an equal probability of being generated.\\n\\n# Explanation\\n1. Generate two random numbers x and y using rand7().\\n\\n2. Calculate the position in a 2D matrix of size 7x7 using the formula pos = (x - 1) * 7 + y.\\n\\n3. If the generated position pos is greater than 40, we have 9 extra possibilities (41 to 49) that we don\\'t need. These extra possibilities do not have equal probability of being generated, so reject them by making a recursive call to rand10(). This ensures that we only have 40 possibilities (1 to 40) with equal probability.\\n\\n4. To get a number between 1 and 10, take the modulus of (pos - 1) with 10 and add 1. This step ensures that all numbers between 1 and 10 have an equal probability of being generated.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = (x-1)*7+y;\\n        if(pos>40) return rand10();\\n        return (pos-1)%10+1;\\n    }\\n}\\n/**\\n    0  1  2  3  4  5  6\\n    11 12 13 14 15 16 17\\n\\n    7  8  9  0  1  2  3\\n    21 22 23 24 25 26 27\\n\\n    4  5  6  7  8  9  0\\n    31 32 33 34 35 36 37\\n\\n    1  2  3  4  5  6  7\\n    41 42 43 44 45 46 47\\n\\n    8  9  0  1  2  3  4 \\n    51 52 53 54 55 56 57\\n\\n    5  6  7  8  9  0  1\\n    61 62 63 64 65 66 67\\n\\n    2  3  4  5  6  7  8\\n    71 72 73 74 75 76 77\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = (x-1)*7+y;\\n        if(pos>40) return rand10();\\n        return (pos-1)%10+1;\\n    }\\n}\\n/**\\n    0  1  2  3  4  5  6\\n    11 12 13 14 15 16 17\\n\\n    7  8  9  0  1  2  3\\n    21 22 23 24 25 26 27\\n\\n    4  5  6  7  8  9  0\\n    31 32 33 34 35 36 37\\n\\n    1  2  3  4  5  6  7\\n    41 42 43 44 45 46 47\\n\\n    8  9  0  1  2  3  4 \\n    51 52 53 54 55 56 57\\n\\n    5  6  7  8  9  0  1\\n    61 62 63 64 65 66 67\\n\\n    2  3  4  5  6  7  8\\n    71 72 73 74 75 76 77\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814688,
                "title": "easy-python-solution-with-o-1-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        x = rand7()\\n        y = rand7()\\n        pos = (x-1)*7 + y\\n        if pos >= 41:\\n            return self.rand10()\\n        return pos%10 +1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        x = rand7()\\n        y = rand7()\\n        pos = (x-1)*7 + y\\n        if pos >= 41:\\n            return self.rand10()\\n        return pos%10 +1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796798,
                "title": "cpp-7-ms-beats92-22-ruby-167-ms-beats100-0",
                "content": "\\n```cpp []\\n//https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000145893/\\nclass Solution {\\nprivate: \\n\\tint ans;\\npublic:\\n    int rand10() {\\n        do{\\n        \\tans = 7 * (rand7() - 1) + rand7();\\n        }\\n        while (ans > 40);\\n        return ans % 10 + 1;\\n    }\\n};\\n```\\n```ruby []\\n#https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000143249/\\n# The rand7() API is already defined for you.\\n# def rand7()\\n# @return {Integer} a random integer in the range 1 to 7\\n\\ndef rand10()\\n    r = 7 * (rand7() - 1 ) + rand7()\\n\\tuntil r < 41\\n\\t\\tr = 7 * (rand7() - 1 ) + rand7()\\n\\tend\\n\\tr % 10 + 1\\nend\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Ruby"
                ],
                "code": "```cpp []\\n//https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000145893/\\nclass Solution {\\nprivate: \\n\\tint ans;\\npublic:\\n    int rand10() {\\n        do{\\n        \\tans = 7 * (rand7() - 1) + rand7();\\n        }\\n        while (ans > 40);\\n        return ans % 10 + 1;\\n    }\\n};\\n```\n```ruby []\\n#https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000143249/\\n# The rand7() API is already defined for you.\\n# def rand7()\\n# @return {Integer} a random integer in the range 1 to 7\\n\\ndef rand10()\\n    r = 7 * (rand7() - 1 ) + rand7()\\n\\tuntil r < 41\\n\\t\\tr = 7 * (rand7() - 1 ) + rand7()\\n\\tend\\n\\tr % 10 + 1\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763177,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * def rand7(): Int = {}\\n * @return a random integer in the range 1 to 7\\n */\\nobject Solution extends SolBase {\\n      def rand10(): Int = {\\n        var row, col, idx = 0\\n        do {\\n          row = rand7()\\n          col = rand7()\\n          idx = col + (row - 1) * 7\\n        } while (idx > 40)\\n        1 + (idx - 1) % 10\\n      }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * def rand7(): Int = {}\\n * @return a random integer in the range 1 to 7\\n */\\nobject Solution extends SolBase {\\n      def rand10(): Int = {\\n        var row, col, idx = 0\\n        do {\\n          row = rand7()\\n          col = rand7()\\n          idx = col + (row - 1) * 7\\n        } while (idx > 40)\\n        1 + (idx - 1) % 10\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710270,
                "title": "",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rand10(self):\\n        return sum(rand7() for _ in range(9)) % 10 + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        return sum(rand7() for _ in range(9)) % 10 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642543,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n         double b=(49*(rand7()-1) + 7*(rand7()-1) + (rand7()-1))/343.0;\\n        return int (b*10) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n         double b=(49*(rand7()-1) + 7*(rand7()-1) + (rand7()-1))/343.0;\\n        return int (b*10) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553020,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        \\n        int ans=INT_MAX;\\n\\n        while(ans>=40){\\n            ans = 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10)+1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        \\n        int ans=INT_MAX;\\n\\n        while(ans>=40){\\n            ans = 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10)+1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548794,
                "title": "cool-solution",
                "content": "# Intuition\\nI was adding `(rand7()+rand7())%7` to the sum and modulo 10 until it worked!\\n\\n# Code\\n```\\nfunc rand10() int {\\n    \\n    return ((rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7)%10+1\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rand10() int {\\n    \\n    return ((rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7)%10+1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508426,
                "title": "java-solution-with-logic-explained",
                "content": "# Intuition\\nWe are to map the range from 1 to 7 inclusive to a bigger range from 1 to 10 inclusive\\nSo we create a map (2d array) of the size (7x7) and distrubte the element across it, starting from 1 up to 10, after reaching 10 we start again from 1 to 10, we repeat the same process, till there\\'re no enough places to take all of our range (1-10), then we start to fill cells with zeros\\nafter that we pick a number from our distribution using uniformally distributed rand7, because of that our solution will be always unifromally distributed\\n\\n# Code\\n```\\n\\n\\n    /**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 },\\n        { 8, 9, 10, 1, 2, 3, 4 },\\n        { 5, 6, 7, 8, 9, 10, 1}, \\n        { 2, 3, 4, 5, 6, 7, 8}, \\n        { 9, 10, 1, 2, 3, 4, 5}, \\n        { 6, 7, 8, 9, 10, 0, 0}, \\n        { 0, 0, 0, 0, 0, 0, 0}\\n    };\\n    \\n    public int rand10() {\\n\\n        \\n        int result = 0; \\n        while(result == 0) { \\n            result = vals[rand7()-1][rand7()-1];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n    /**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 },\\n        { 8, 9, 10, 1, 2, 3, 4 },\\n        { 5, 6, 7, 8, 9, 10, 1}, \\n        { 2, 3, 4, 5, 6, 7, 8}, \\n        { 9, 10, 1, 2, 3, 4, 5}, \\n        { 6, 7, 8, 9, 10, 0, 0}, \\n        { 0, 0, 0, 0, 0, 0, 0}\\n    };\\n    \\n    public int rand10() {\\n\\n        \\n        int result = 0; \\n        while(result == 0) { \\n            result = vals[rand7()-1][rand7()-1];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506887,
                "title": "go-arr-shuffle",
                "content": "```\\nvar a = [10]int{1,2,3,4,5,6,7,8,9,10}\\nfunc rand10() int {\\n    return a[int(int64(rand7())+time.Now().UnixNano())%10]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar a = [10]int{1,2,3,4,5,6,7,8,9,10}\\nfunc rand10() int {\\n    return a[int(int64(rand7())+time.Now().UnixNano())%10]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499373,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int g=0;\\n    int rand10() {\\n        g++;\\n        if(g%10==0)\\n            return 10;\\n        return g%10;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self):\\n        self.c = {1,2,3,4,5,6,7,8,9,10}\\n\\n    def rand10(self):\\n        x = self.c.pop()\\n        if not self.c:\\n            self.c = {1,2,3,4,5,6,7,8,9,10}\\n        return x\\n```\\n\\n```Java []\\nclass Solution extends SolBase {\\n    int count = 1;\\n    public int rand10() {\\n        count++;\\n        return count%10 +1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int g=0;\\n    int rand10() {\\n        g++;\\n        if(g%10==0)\\n            return 10;\\n        return g%10;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self):\\n        self.c = {1,2,3,4,5,6,7,8,9,10}\\n\\n    def rand10(self):\\n        x = self.c.pop()\\n        if not self.c:\\n            self.c = {1,2,3,4,5,6,7,8,9,10}\\n        return x\\n```\n```Java []\\nclass Solution extends SolBase {\\n    int count = 1;\\n    public int rand10() {\\n        count++;\\n        return count%10 +1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481216,
                "title": "c-5-line-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = ((x-1)*7) + y;\\n\\n        if(pos >= 41)\\n            return rand10();\\n        \\n        return ((pos%10) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = ((x-1)*7) + y;\\n\\n        if(pos >= 41)\\n            return rand10();\\n        \\n        return ((pos%10) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469924,
                "title": "easy-java-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x= rand7();\\n        int y= rand7();\\n        int val= (x-1)*7+y;\\n        if(val>40){\\n            return rand10();\\n        }\\n        return val % 10+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x= rand7();\\n        int y= rand7();\\n        int val= (x-1)*7+y;\\n        if(val>40){\\n            return rand10();\\n        }\\n        return val % 10+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468558,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA minimum of two rand7() is needed to get numbers between 1-10;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider a 1 based indexed 7x7 matrix. Develop a relationship between the position and the (x,y) coordinates of the matrix. For eg. 3,5 is at the 19th position, 7,7 will be at the 49th position. \\n\\nFor equal probablity of getting 1-10, some elements need to be discarded. In this case, 41-49 is discadred as it gives numbers between only 1-9.(We need 1-10,hence, unequal probability.)\\n\\nModulo operation to get the desired range of numbers(1-10).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();//x-coordinate\\n        int y = rand7();//y-coordinate\\n\\n        int val = (x-1)*7 + y;// relationsship between (x,y) and the position of the matrix.\\n\\n        if(val>40) return rand10(); // discarded numbers which gives unequal probability. Hence, we call rand10() again.\\n\\n        return val%10+1; // returning numbers ranging 1-10.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();//x-coordinate\\n        int y = rand7();//y-coordinate\\n\\n        int val = (x-1)*7 + y;// relationsship between (x,y) and the position of the matrix.\\n\\n        if(val>40) return rand10(); // discarded numbers which gives unequal probability. Hence, we call rand10() again.\\n\\n        return val%10+1; // returning numbers ranging 1-10.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440861,
                "title": "java",
                "content": "split into pairs (num1,num2) we have 49 pairs (num1,num2), for the first 40 group them into groups of 4 and return 1-10 by the group belonging of the random pair, or redraw if the pair isn\\'t belong to any of the gruop.\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while (true){\\n            int random1 = rand7(), random2=rand7();\\n            if (random1==1 && random2<=4) return 1;\\n            if (random1==1) return 2;\\n            if (random1==2 && random2<=1) return 2;\\n            if (random1==2 && random2<=5) return 3;\\n            if (random1==2) return 4;\\n            if (random1==3 && random2<=2)return 4;\\n            if (random1==3 && random2<=6)return 5;\\n            if (random1==3) return 6;\\n            if (random1==4 && random2<=3)return 6;\\n            if (random1==4) return 7;\\n            if (random1==5 && random2<=4)return 8;\\n            if (random1==5 )return 9;\\n            if (random1==6 && random2<=1)return 9;\\n            if (random1==6 && random2<=5)return 10;         \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while (true){\\n            int random1 = rand7(), random2=rand7();\\n            if (random1==1 && random2<=4) return 1;\\n            if (random1==1) return 2;\\n            if (random1==2 && random2<=1) return 2;\\n            if (random1==2 && random2<=5) return 3;\\n            if (random1==2) return 4;\\n            if (random1==3 && random2<=2)return 4;\\n            if (random1==3 && random2<=6)return 5;\\n            if (random1==3) return 6;\\n            if (random1==4 && random2<=3)return 6;\\n            if (random1==4) return 7;\\n            if (random1==5 && random2<=4)return 8;\\n            if (random1==5 )return 9;\\n            if (random1==6 && random2<=1)return 9;\\n            if (random1==6 && random2<=5)return 10;         \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432918,
                "title": "java-solution-easy",
                "content": "\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n\\n        while(true) {\\n            int row = (rand7() - 1) * 7;\\n            int col = rand7();\\n            int curr = row + col;\\n            if(curr >= 40) {\\n                return 1 + (curr - 1) % 10;\\n            }\\n        }\\n        \\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n\\n        while(true) {\\n            int row = (rand7() - 1) * 7;\\n            int col = rand7();\\n            int curr = row + col;\\n            if(curr >= 40) {\\n                return 1 + (curr - 1) % 10;\\n            }\\n        }\\n        \\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403228,
                "title": "python-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* We want to generate a random number between 1 and 10 using the rand7() function, which can only generate numbers between 1 and 7 with equal probability.\\n\\n* To do this, we generate a random number in a larger range, such as between 1 and 49, which has an equal probability of generating any number in that range.\\n\\n    - When we generate a random number using rand7(), we have seven equally likely outcomes: 1, 2, 3, 4, 5, 6, or 7.\\n    - If we generate two independent random numbers using rand7(), we have 7*7=49 possible outcomes, each of which is equally likely to occur. \\n    - That\\'s because the first number can be any of the seven values, and the second number can also be any of the seven values, resulting in 49 possible combinations.\\n    - Therefore, by generating two independent random numbers using rand7() and using them to create a number in the range [1, 49], we ensure that each number in that range has an equal probability of being generated.\\n\\n* We then reject any numbers outside the range [1, 40], which ensures that we have an equal probability of generating any number between 1 and 10.\\n* The reason we use the range [1, 40] is that it is the largest multiple of 10 that is less than or equal to 49, which means that all numbers between 1 and 10 have an equal probability of being generated if we reject any numbers outside this range.\\n* Finally, we use the modulo operator to map the remaining numbers to the range [1, 10], which gives us a uniform probability distribution for generating random numbers between 1 and 10 using the rand7() function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the rand10() function is not constant because the number of calls to rand7() is not fixed, and it depends on how many times we need to generate a number between 1 and 40. \\nHowever, the worst-case time complexity is `O(\\u221E)` because there is a possibility that we will never generate a number between 1 and 40, and the loop will run forever.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is `O(1)` because we are not storing any data structures that grow with input size. \\nWe are only using a constant amount of space to store the variables needed to generate the random numbers.\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        We want to generate a random number between 1 and 10 using the rand7() function, \\n        which can only generate numbers between 1 and 7 with equal probability.\\n\\n        To do this, we generate a random number in a larger range, \\n        such as between 1 and 49, which has an equal probability of generating any number in that range.\\n\\n        We then reject any numbers outside the range [1, 40], \\n        which ensures that we have an equal probability of generating any number between 1 and 10.\\n\\n        The reason we use the range [1, 40] is that it is the largest multiple of 10 that is less \\n        than or equal to 49, \\n\\n        which means that all numbers between 1 and 10 have an equal probability of being generated \\n        if we reject any numbers outside this range.\\n\\n        Finally, we use the modulo operator to map the remaining numbers to the range [1, 10], \\n        which gives us a uniform probability distribution for generating random numbers between 1 and 10 \\n        using the rand7() function.\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice because 7 * 7 = 49. We need 1 to 49 \\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40] because 40 % 10 = 0 and 40 / 10 = 4. We need 1 to 40 in order to get a number in the range [1, 10]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus.\\n        return num % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        We want to generate a random number between 1 and 10 using the rand7() function, \\n        which can only generate numbers between 1 and 7 with equal probability.\\n\\n        To do this, we generate a random number in a larger range, \\n        such as between 1 and 49, which has an equal probability of generating any number in that range.\\n\\n        We then reject any numbers outside the range [1, 40], \\n        which ensures that we have an equal probability of generating any number between 1 and 10.\\n\\n        The reason we use the range [1, 40] is that it is the largest multiple of 10 that is less \\n        than or equal to 49, \\n\\n        which means that all numbers between 1 and 10 have an equal probability of being generated \\n        if we reject any numbers outside this range.\\n\\n        Finally, we use the modulo operator to map the remaining numbers to the range [1, 10], \\n        which gives us a uniform probability distribution for generating random numbers between 1 and 10 \\n        using the rand7() function.\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice because 7 * 7 = 49. We need 1 to 49 \\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40] because 40 % 10 = 0 and 40 / 10 = 4. We need 1 to 40 in order to get a number in the range [1, 10]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus.\\n        return num % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382321,
                "title": "python3-made-simple-inefficient-but-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        call = None\\n\\n        while call is None:\\n            temp1 = rand7()\\n            temp2 = rand7()\\n            \\n            if temp1 == 1 and temp2 == 1:\\n                return 1\\n            elif temp1 == 1 and temp2 == 2:\\n                return 2\\n            elif temp1 == 1 and temp2 == 3:\\n                return 3\\n            elif temp1 == 1 and temp2 == 4:\\n                return 4\\n            elif temp1 == 1 and temp2 == 5:\\n                return 5\\n            elif temp1 == 1 and temp2 == 6:\\n                return 6\\n            elif temp1 == 1 and temp2 == 7:\\n                return 7\\n            elif temp1 == 2 and temp2 == 1:\\n                return 8\\n            elif temp1 == 2 and temp2 == 2:\\n                return 9\\n            elif temp1 == 2 and temp2 == 3:\\n                return 10\\n\\n        \\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        call = None\\n\\n        while call is None:\\n            temp1 = rand7()\\n            temp2 = rand7()\\n            \\n            if temp1 == 1 and temp2 == 1:\\n                return 1\\n            elif temp1 == 1 and temp2 == 2:\\n                return 2\\n            elif temp1 == 1 and temp2 == 3:\\n                return 3\\n            elif temp1 == 1 and temp2 == 4:\\n                return 4\\n            elif temp1 == 1 and temp2 == 5:\\n                return 5\\n            elif temp1 == 1 and temp2 == 6:\\n                return 6\\n            elif temp1 == 1 and temp2 == 7:\\n                return 7\\n            elif temp1 == 2 and temp2 == 1:\\n                return 8\\n            elif temp1 == 2 and temp2 == 2:\\n                return 9\\n            elif temp1 == 2 and temp2 == 3:\\n                return 10\\n\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308669,
                "title": "python-simple-2-rand7-calls-per-rand10",
                "content": "# Intuition\\nWe\\'ll pick a random value from the matrix:\\n```\\n    1  2  3  4  5  6  7  8  9 10\\n    2  3  4  5  6  7  8  9 10  1\\n    3  4  5  6  7  8  9 10  1  2\\ni-> 4  5  6  7  8  9 10  1  2  3\\n    5  6  7  8  9 10  1  2  3  4\\n    6  7  8  9 10  1  2  3  4  5\\n    7  8  9 10  1  2  3  4  5  6\\n    8  9 10  1  2  3  4  5  6  7\\n          ^\\n          |\\n          j\\n```\\nThe problem is that we can pick both `i` and `j` in the range [0, 6]. \\n\\nOne way to solve is to slide the window of possibilites by shifting the range for `j` by 1 to the right each time a number was picked. Meaning after 1st number the range for `j` will be [1, 7], after 2nd - [2, 8] and so on.\\n\\nThis way on avarage the distribution will be uniform in range [1, 10]\\n\\n# Complexity\\n- Time complexity:\\n$O(1)$\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    cnt = 0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        i = rand7()\\n        j = (rand7() + self.cnt)%10\\n        self.cnt += 1\\n        return (i + j)%10 + 1\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    1  2  3  4  5  6  7  8  9 10\\n    2  3  4  5  6  7  8  9 10  1\\n    3  4  5  6  7  8  9 10  1  2\\ni-> 4  5  6  7  8  9 10  1  2  3\\n    5  6  7  8  9 10  1  2  3  4\\n    6  7  8  9 10  1  2  3  4  5\\n    7  8  9 10  1  2  3  4  5  6\\n    8  9 10  1  2  3  4  5  6  7\\n          ^\\n          |\\n          j\\n```\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    cnt = 0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        i = rand7()\\n        j = (rand7() + self.cnt)%10\\n        self.cnt += 1\\n        return (i + j)%10 + 1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295830,
                "title": "easy-java-solution-understand-quickly-nd-easily",
                "content": "******Bold******# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x=rand7();\\n        int y=rand7();\\n        int val=(x-1)*7+y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x=rand7();\\n        int y=rand7();\\n        int val=(x-1)*7+y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284659,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        double t = rand7();\\n        double x = (double) rand()/RAND_MAX ;\\n\\n        t = (t+x)/0.7 ;\\n        int k = t;\\n        if(k > 10)\\n            return k-10;\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        double t = rand7();\\n        double x = (double) rand()/RAND_MAX ;\\n\\n        t = (t+x)/0.7 ;\\n        int k = t;\\n        if(k > 10)\\n            return k-10;\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276806,
                "title": "c-easy-method-100-pure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216620,
                "title": "slow-but-simple-and-correct",
                "content": "Just do rand7() 10 times, and then take mod 10 of the sum. Slow but correct:\\n```\\n   int rand10() {\\n        int sum = 0;\\n        for (int i=0; i < 10; i++)\\n            sum += rand7();      \\n        return ((sum - 1)% 10) + 1;\\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n   int rand10() {\\n        int sum = 0;\\n        for (int i=0; i < 10; i++)\\n            sum += rand7();      \\n        return ((sum - 1)% 10) + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189075,
                "title": "7-rand7-1-rand7",
                "content": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            x = 7 * (rand7() - 1) \\n            y = rand7()\\n            if x + y <= 10:\\n                return x+y\\n```",
                "solutionTags": [
                    "Python3",
                    "Rejection Sampling"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            x = 7 * (rand7() - 1) \\n            y = rand7()\\n            if x + y <= 10:\\n                return x+y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173005,
                "title": "sample-solution-using-only-addition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        #Table of a+b, when a < 5 or b > 3\\n        # b 1 2 3 4 5 6 7\\n        #a --------------\\n        #1| 2 3 4 5 6 7 8\\n        #2| 3 4 5 6 7 8 9\\n        #3| 4 5 6 7 8 9 0\\n        #4| 5 6 7 8 9 0 1\\n        #5| x x x 9 0 1 2\\n        #6| x x x 0 1 2 3 \\n        #7| x x x 1 2 3 4\\n        \\n        a = rand7()\\n        b = rand7()\\n\\n        return (a+b)%10+1 if a < 5 or b > 3 else self.rand10()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        #Table of a+b, when a < 5 or b > 3\\n        # b 1 2 3 4 5 6 7\\n        #a --------------\\n        #1| 2 3 4 5 6 7 8\\n        #2| 3 4 5 6 7 8 9\\n        #3| 4 5 6 7 8 9 0\\n        #4| 5 6 7 8 9 0 1\\n        #5| x x x 9 0 1 2\\n        #6| x x x 0 1 2 3 \\n        #7| x x x 1 2 3 4\\n        \\n        a = rand7()\\n        b = rand7()\\n\\n        return (a+b)%10+1 if a < 5 or b > 3 else self.rand10()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163672,
                "title": "c-easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a=rand7(),b=rand7();\\n        while(b>5)  b = rand7();//1,2,3,4,5 for 1/5\\n        while(a>2)  a = rand7();//1,2 for 1/2\\n        return a==1?b:b+5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a=rand7(),b=rand7();\\n        while(b>5)  b = rand7();//1,2,3,4,5 for 1/5\\n        while(a>2)  a = rand7();//1,2 for 1/2\\n        return a==1?b:b+5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143087,
                "title": "c-range-mapping",
                "content": "The idea is to fairly map real ranges.\\n\\nEach `rand7()` call will be a pointer to some range.\\n\\nOur ranges of interests are within `[0, 10)`\\nand there are 10 of them: `[0, 1)`, `[1, 2)`, ... `[9, 10)`. Call them **10 ranges**.\\n\\nNow problem is `rand7()` can only evenly cover range `[0, 10)` by dividing it into 7 parts: with ranges `[0, 1.42)`, ... `[8.58, 10)` and none of them match our **10 ranges**. However, once chosen some range we can keep on dividing it into 7 parts until it does fall into one of the **10 ranges**. Once it falls into any of them we return corresponding label.\\n```\\nclass Solution {\\npublic:\\n    // function to return which of 10 ranges our \\n    // real number `x` belongs to\\n    array <int, 2> f(double x) {\\n        return {(int)floor(x), (int)ceil(x)};\\n    }\\n    int rand10() {\\n        double x = 10.0, cur = 0.0;\\n        while (true) {\\n            cur += x * (rand7() / 7.0);\\n            double ll = cur - x / 7.0, rr = cur;\\n            if (f(ll) == f(rr)) // within same range ?\\n                return (int)ceil(rr);\\n            x /= 7.0;\\n            cur -= x;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n\\nTested expectation for this is close to `~ 2.262`",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to return which of 10 ranges our \\n    // real number `x` belongs to\\n    array <int, 2> f(double x) {\\n        return {(int)floor(x), (int)ceil(x)};\\n    }\\n    int rand10() {\\n        double x = 10.0, cur = 0.0;\\n        while (true) {\\n            cur += x * (rand7() / 7.0);\\n            double ll = cur - x / 7.0, rr = cur;\\n            if (f(ll) == f(rr)) // within same range ?\\n                return (int)ceil(rr);\\n            x /= 7.0;\\n            cur -= x;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136219,
                "title": "4-rand7-call-only",
                "content": "# Intuition\\nUse 2 digits and base 7 gives us 49 choices. We then sum 2 rand7() and module 7 to create a random with range [0-1]. With 50 choices we modulo by 10 to get range [0-9]. Since the question asks for [1-10], we add a single offset.\\n\\n\\n# Code\\n```\\nfunc rand10() int {\\n    return ((rand7()-1)*7+(rand7()-1)+(rand7()+rand7())%7)%10+1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rand10() int {\\n    return ((rand7()-1)*7+(rand7()-1)+(rand7()+rand7())%7)%10+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3105731,
                "title": "solution-c",
                "content": "\\n# Approach\\ncreate \"range\" of numbers from 1 to 49.\\nif the choosen number is bigger then 10 - continue. else - return it.\\n\\n# Code\\n```\\n\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int r;\\n    do {\\n        r = 7 * (rand7() - 1) + rand7();\\n    } while (r > 10);\\n    return r;    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int r;\\n    do {\\n        r = 7 * (rand7() - 1) + rand7();\\n    } while (r > 10);\\n    return r;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3041044,
                "title": "simple-solution-python3",
                "content": "# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        sm = 0\\n        for _ in range(100):\\n            sm += rand7()\\n        res = sm % 10 + 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        sm = 0\\n        for _ in range(100):\\n            sm += rand7()\\n        res = sm % 10 + 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033626,
                "title": "very-easy-solution-in-o-1-in-c",
                "content": "# Intuition\\n1. For implementing the rand10() using rand7() must have equal probability for each number.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First we have required minimum number of occurance is tow which are x and y.\\n2. Hence there total possibility will 7^2 which is 49.\\n3. Find postion where the probability of rand10() and rand7() will equal.\\n4. postion = (x-1)*7+y;\\n5. If total number of possibilities are not divisible by total number presents in rand10().\\n6. Hence we have to recall the rand10() function in the range (41 to 49).\\n7. Now we have to count total number of possibilities where probably of both api are equal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int x=0,y=0,val=0;\\n    int rand10() {\\n        x=rand7();\\n        y=rand7();\\n        val=(x-1)*7 + y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Rejection Sampling",
                    "Randomized",
                    "Probability and Statistics"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int x=0,y=0,val=0;\\n    int rand10() {\\n        x=rand7();\\n        y=rand7();\\n        val=(x-1)*7 + y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009934,
                "title": "python3-same-as-everyone-else-s-while-loop",
                "content": "# Approach\\nLooks like everyone pretty much did the same thing.\\n\\n# Code\\n```\\nclass Solution:\\n    def rand10(self):\\n        x = 50\\n        while x > 47:\\n            x = rand7() * 7 + rand7()\\n        return (x - 8) // 4 + 1\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        x = 50\\n        while x > 47:\\n            x = rand7() * 7 + rand7()\\n        return (x - 8) // 4 + 1\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970482,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- random first time to get 1-5 to get the bucket since i will split result to [1,2], [3,4] ..., [9,10]\\n- assume I get [5,6] =>\\nrandom one more time to get the first or last number [1,2,3] = left, [4,5,6] = right\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nExpected value = 7/5 + 7/6 = 2.333\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        mapping = {\\n            1: [1, 2],\\n            2: [3, 4],\\n            3: [5, 6],\\n            4: [7, 8],\\n            5: [9, 10]\\n        }\\n        while True:\\n            random_val = rand7()\\n            if 1 <= random_val <= 5:\\n                break\\n\\n        possible_vals = mapping[random_val]\\n        while True:\\n            random_val = rand7()\\n            if random_val != 7:\\n                break\\n\\n        index = (random_val-1)//3\\n        return possible_vals[index]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        mapping = {\\n            1: [1, 2],\\n            2: [3, 4],\\n            3: [5, 6],\\n            4: [7, 8],\\n            5: [9, 10]\\n        }\\n        while True:\\n            random_val = rand7()\\n            if 1 <= random_val <= 5:\\n                break\\n\\n        possible_vals = mapping[random_val]\\n        while True:\\n            random_val = rand7()\\n            if random_val != 7:\\n                break\\n\\n        index = (random_val-1)//3\\n        return possible_vals[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929998,
                "title": "java-select-from-list-simple",
                "content": "# Code\\n```\\nclass Solution extends SolBase {\\n\\n    List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\\n\\n    public int rand10() {\\n        int index = (rand7() + rand7()) % 9;\\n        int num = list.remove(index);\\n        list.add(num);\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n\\n    List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\\n\\n    public int rand10() {\\n        int index = (rand7() + rand7()) % 9;\\n        int num = list.remove(index);\\n        list.add(num);\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859486,
                "title": "c",
                "content": "```\\nint rand10() {\\n        int ans = (rand7() - 1) * 7 + rand7();\\n        return (ans <= 40) ? (ans % 10 + 1) : rand10();    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n        int ans = (rand7() - 1) * 7 + rand7();\\n        return (ans <= 40) ? (ans % 10 + 1) : rand10();    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2789669,
                "title": "python-solution-with-explaination-rejection-sampling-mathematical-explaination",
                "content": "```class Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # use rejection sampling\\n        while True:\\n            row = rand7()\\n            col = rand7()\\n            idx = col + (row - 1) * 7\\n            if idx <= 40:\\n                return (idx - 1) % 10 + 1\\n```\\n\\n\\nThe idea is to use a uniform distribution of (row, col) in a 7x7 grid, which would cover all possible integers from 1 to 49.\\n\\nThen, to map it to 1 to 10, we can just take the remainder of idx / 10.\\n\\nThe probability of having idx <= 40 is 40 / 49 ~ 82.7%.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to a specific value k is 40 / 49 / 10 ~ 8.27%.\\n\\nThat is, the desired probability is 8.27%.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to a specific value k for k = 1, 2, ..., 9 is 8.27%.\\n\\nThus, it is a uniform distribution over 1, 2, ..., 9.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to 10 is 40 / 49 - 9 * 8.27% = 1 - 9 * 8.27% ~ 0.56%.\\n\\nThus, it is not a uniform distribution over 10.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to 0 is 40 / 49 - 9 * 8.27% = 1 - 9 * 8.27% ~ 0.56%.\\n\\nThus, it is not a uniform distribution over 10.\\n\\nWe can use rejection sampling to get rid of the invalid results.\\n\\nThe probability of having a valid result is 82.7%.\\n\\nThe time complexity is O(1).\\n\\nThe space complexity is O(1).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # use rejection sampling\\n        while True:\\n            row = rand7()\\n            col = rand7()\\n            idx = col + (row - 1) * 7\\n            if idx <= 40:\\n                return (idx - 1) % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749158,
                "title": "making-a-matrix-easy-solution",
                "content": "# Approach\\nIf you make a matrix of 7x7 the numbers will go from 1-49 but for 7x6 matrix will go upto 42 (close to 40 which is a multiple of 10). So...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: theoritically infinite (when the value in each time becomes either 41 or 42 which calls the rand10() functions infinitely) but otherwise it is O(1);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n            int column = rand7(); // range is 1 - 7\\n            int row = rand7() - 1; // range is 0 - 6.\\n            int value = row * 7 + column; // range is 1 - 42.\\n            if (value <= 40){\\n                return (value - 1) % 10 + 1;\\n            }else {\\n                return rand10(); // ignoring the value 41 & 42, the probablity of getting them is 2/42 which is very less.\\n            }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n            int column = rand7(); // range is 1 - 7\\n            int row = rand7() - 1; // range is 0 - 6.\\n            int value = row * 7 + column; // range is 1 - 42.\\n            if (value <= 40){\\n                return (value - 1) % 10 + 1;\\n            }else {\\n                return rand10(); // ignoring the value 41 & 42, the probablity of getting them is 2/42 which is very less.\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634597,
                "title": "c-simple-solutions-with-two-approaches",
                "content": "Solution 1: draw two times and reject particular samples\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x;\\n        //first draw: decide if x=1,2,3,4,5 or x=6,7,8,9,10\\n        int firstDraw = rand7();\\n        while (firstDraw==7){\\n            //do again the first draw if firstDraw==7 \\n            firstDraw = rand7();\\n        }\\n        \\n        //if first draw is odd, x=1,2,3,4,5\\n        //if first draw is even, x=6,7,8,9,10\\n        if (firstDraw%2==1){\\n            x = 0;\\n        }else{\\n            x = 5;\\n        }\\n        \\n        //second draw picks a number from {1,2,3,4,5,X,X}\\n        int secondDraw = rand7();\\n        while (secondDraw>=6){\\n            secondDraw = rand7();\\n        }\\n        \\n        x += secondDraw;\\n        return x;\\n    }\\n};\\n```\\n\\nSolution 2: use rand7() for 10 times and sum the numbers up\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0; i<10; i++){\\n            sum += rand7();\\n        }\\n        return 1 + (sum%10);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x;\\n        //first draw: decide if x=1,2,3,4,5 or x=6,7,8,9,10\\n        int firstDraw = rand7();\\n        while (firstDraw==7){\\n            //do again the first draw if firstDraw==7 \\n            firstDraw = rand7();\\n        }\\n        \\n        //if first draw is odd, x=1,2,3,4,5\\n        //if first draw is even, x=6,7,8,9,10\\n        if (firstDraw%2==1){\\n            x = 0;\\n        }else{\\n            x = 5;\\n        }\\n        \\n        //second draw picks a number from {1,2,3,4,5,X,X}\\n        int secondDraw = rand7();\\n        while (secondDraw>=6){\\n            secondDraw = rand7();\\n        }\\n        \\n        x += secondDraw;\\n        return x;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0; i<10; i++){\\n            sum += rand7();\\n        }\\n        return 1 + (sum%10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569422,
                "title": "python-round-and-7-10-is-the-simplest-solution",
                "content": "class Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return round(rand7()/7*10)",
                "solutionTags": [],
                "code": "class Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return round(rand7()/7*10)",
                "codeTag": "Java"
            },
            {
                "id": 2553734,
                "title": "c-code-1-liners",
                "content": "```\\nint rand10() \\n{\\n    return (rand7()*rand7()*rand7()*rand7()*rand7())%11;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rand10() \\n{\\n    return (rand7()*rand7()*rand7()*rand7()*rand7())%11;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485364,
                "title": "golden-trick-for-rand-questions-c",
                "content": "```\\nint rand10() {\\n       \\n       //GOLDEN TRICK FOR EVERY RAND() QUESTIONS --> jitne zada rand7 se multiply krayege utne zda chances hoge 1-10 ka random nuMber ki equal probaility hone ke ...  sirf <=3 baar multiply kroge to nahi hoga equal probaibility ke sath random number generate\\n       \\n        return (rand7() * rand7() * rand7()* rand7()* rand7() *rand7()  )%11;\\n    }",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n       \\n       //GOLDEN TRICK FOR EVERY RAND() QUESTIONS --> jitne zada rand7 se multiply krayege utne zda chances hoge 1-10 ka random nuMber ki equal probaility hone ke ...  sirf <=3 baar multiply kroge to nahi hoga equal probaibility ke sath random number generate\\n       \\n        return (rand7() * rand7() * rand7()* rand7()* rand7() *rand7()  )%11;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2476777,
                "title": "c-o-1-time-space-95-faster",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        return (rand7() * rand7() * rand7() * rand7()  )%11;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rand10() {\\n        return (rand7() * rand7() * rand7() * rand7()  )%11;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2471332,
                "title": "range-mapping-rejection-sampling",
                "content": "```python\\n\\'\\'\\'\\nrange mapping\\nrejection sampling\\nO(1), O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def rand10(self):\\n        # return a random number within [0, 48]\\n        def helper():\\n            row, col = rand7() - 1, rand7() - 1\\n            return row * 7 + col\\n        \\n        # accept any number within [0, 39]\\n        # reject/regenerate any number within [40, 48]\\n        idx = 40\\n        while idx > 39:\\n            idx = helper()\\n            \\n        return idx % 10 + 1\\n```",
                "solutionTags": [],
                "code": "```python\\n\\'\\'\\'\\nrange mapping\\nrejection sampling\\nO(1), O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def rand10(self):\\n        # return a random number within [0, 48]\\n        def helper():\\n            row, col = rand7() - 1, rand7() - 1\\n            return row * 7 + col\\n        \\n        # accept any number within [0, 39]\\n        # reject/regenerate any number within [40, 48]\\n        idx = 40\\n        while idx > 39:\\n            idx = helper()\\n            \\n        return idx % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460708,
                "title": "c-solution",
                "content": "```\\nint rand10() {\\n    int res  = 41;\\n    //The highest number res can be is 49. \\n    //The range of 41-49 is not a group of 10 which would make the randomization tilted towards nums 1-9\\n    //Discard any results that are 41 - 49 and reroll\\n    while(res > 40){\\n        res = rand7() + (rand7() - 1) * 7;\\n    }\\n    // % 10 would return a 0 if res - 1 is divisible by 10. Offset by adding 1 to return range to 1 - 10 instead of 0 - 9\\n    return res = 1 + ((res - 1) % 10);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rand10() {\\n    int res  = 41;\\n    //The highest number res can be is 49. \\n    //The range of 41-49 is not a group of 10 which would make the randomization tilted towards nums 1-9\\n    //Discard any results that are 41 - 49 and reroll\\n    while(res > 40){\\n        res = rand7() + (rand7() - 1) * 7;\\n    }\\n    // % 10 would return a 0 if res - 1 is divisible by 10. Offset by adding 1 to return range to 1 - 10 instead of 0 - 9\\n    return res = 1 + ((res - 1) % 10);\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1776652,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1567070,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1570041,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 2051734,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 2020644,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1970373,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1898901,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1837622,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1804040,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            }
        ]
    }
]