[
    {
        "title": "N-Queens II",
        "question_content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the&nbsp;n-queens puzzle.\n&nbsp;\nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9",
        "solutions": [
            {
                "id": 2111583,
                "title": "cpp-explained-clean",
                "content": "**UPVOTE IF HELPFUL**\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach ,\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* **COLUMN_WISE** FILLING = Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n*  **ROW_WISE** FILLING = Only upper part of the diagonals are checked as positions below of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1); \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \\n\\t\\t}                                \\n\\treturn count;\\n}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/4a277b77-14e4-44ff-87eb-e400a3d7d41e_1654392063.0433629.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1); \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \\n\\t\\t}                                \\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111857,
                "title": "java-c-n-queens-1-2-almost-same-solution",
                "content": "**Rules For N-Queens in a chess Board :-**\\n1. Every Row should Have 1 queen\\n\\n\\n2. Every Column should have 1 quuen\\n3. No 2 queens can attack each other\\n\\n![image](https://assets.leetcode.com/users/images/a69e681e-0067-4c46-8659-f10d126eb181_1654402034.2685366.png)\\n\\n```\\nN-Quuens I\\n```\\n\\n**Problem Statement:** The n-queens is the problem of placing n queens on n \\xD7 n chessboard such that no two queens can attack each other. Given an integer n, return all distinct solutions to the n -queens puzzle. Each solution contains a distinct boards configuration of the queen\\u2019s placement, where \\u2018Q\\u2019 and \\u2018.\\u2019 indicate queen and empty space respectively.\\n\\n**Intuition:** Using the concept of Backtracking, we will place Queen at different positions of the chessboard and find the right arrangement where all the n queens can be placed on the n*n grid.\\n\\n![image](https://assets.leetcode.com/users/images/cad068d6-420e-4588-87cc-ccee4a719323_1654402478.1131492.png)\\n\\n\\n**Approach:**\\n\\n**Ist position:** This is the position where we can see no possible arrangement is found where all queens can be placed since, at the 3rd column, the Queen will be killed at all possible positions of row.\\n\\n![image](https://assets.leetcode.com/users/images/92f73459-712f-4564-a82b-a33364ea38fb_1654401381.1760585.png)\\n\\n**2nd position:** One of the correct possible arrangements is found. So we will store it as our answer.\\n\\n![image](https://assets.leetcode.com/users/images/7c6019f5-930c-4fed-bd6b-0f53440db5a9_1654401405.4075787.png)\\n\\n**3rd position:** One of the correct possible arrangements is found. So we will store it as our answer.\\n\\n![image](https://assets.leetcode.com/users/images/dd4669ff-be65-40df-88dd-ae1a04442ae5_1654401442.4140863.png)\\n\\n**4th position:** This is the position where we can see no possible arrangement is found where all queens can be placed since, at the 4th column, the Queen will be killed at all possible positions of row.\\n\\n![image](https://assets.leetcode.com/users/images/93fc6398-0119-4ba3-82a6-5162845f35fe_1654401463.9854825.png)\\n\\n<iframe src=\"https://leetcode.com/playground/MgCvV5hU/shared\" frameBorder=\"0\" width=\"1400\" height=\"1000\"></iframe>\\n\\n\\nANALYSIS :-\\n* **Time Complexity:** Exponential in nature, since we are trying out all ways. To be precise it goes as O(N! * N) nearly.\\n\\n* **Space Complexity:** O(N^2)\\n```\\nN-Quuens II\\n```\\n\\nThis Problem is Almost Similar to N-Queens what extra we have to done over here is, Instead of printing the position we have to **count** the no. of ways in which Queens can be arranged on N-By-N chess \\n\\n![image](https://assets.leetcode.com/users/images/c8f00056-d8d7-4965-a879-f3fac38d8bfc_1654399504.9641533.png)\\n\\n<iframe src=\"https://leetcode.com/playground/H7a7hggm/shared\" frameBorder=\"0\" width=\"1200\" height=\"800\"></iframe>\\n\\nANALYSIS :-\\n* **Time Complexity:** O(N! * N)\\n\\n* **Space Complexity:** O(N^2)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nN-Quuens I\\n```\n```\\nN-Quuens II\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20058,
                "title": "accepted-java-solution",
                "content": "    /**\\n     * don't need to actually place the queen,\\n     * instead, for each row, try to place without violation on\\n     * col/ diagonal1/ diagnol2.\\n     * trick: to detect whether 2 positions sit on the same diagnol:\\n     * if delta(col, row) equals, same diagnol1;\\n     * if sum(col, row) equals, same diagnal2.\\n     */\\n    private final Set<Integer> occupiedCols = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\\n    public int totalNQueens(int n) {\\n        return totalNQueensHelper(0, 0, n);\\n    }\\n    \\n    private int totalNQueensHelper(int row, int count, int n) {\\n        for (int col = 0; col < n; col++) {\\n            if (occupiedCols.contains(col))\\n                continue;\\n            int diag1 = row - col;\\n            if (occupiedDiag1s.contains(diag1))\\n                continue;\\n            int diag2 = row + col;\\n            if (occupiedDiag2s.contains(diag2))\\n                continue;\\n            // we can now place a queen here\\n            if (row == n-1)\\n                count++;\\n            else {\\n                occupiedCols.add(col);\\n                occupiedDiag1s.add(diag1);\\n                occupiedDiag2s.add(diag2);\\n                count = totalNQueensHelper(row+1, count, n);\\n                // recover\\n                occupiedCols.remove(col);\\n                occupiedDiag1s.remove(diag1);\\n                occupiedDiag2s.remove(diag2);\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * don't need to actually place the queen,\\n     * instead, for each row, try to place without violation on\\n     * col/ diagonal1/ diagnol2.\\n     * trick: to detect whether 2 positions sit on the same diagnol:\\n     * if delta(col, row) equals, same diagnol1;\\n     * if sum(col, row) equals, same diagnal2.\\n     */\\n    private final Set<Integer> occupiedCols = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\\n    public int totalNQueens(int n) {\\n        return totalNQueensHelper(0, 0, n);\\n    }\\n    \\n    private int totalNQueensHelper(int row, int count, int n) {\\n        for (int col = 0; col < n; col++) {\\n            if (occupiedCols.contains(col))\\n                continue;\\n            int diag1 = row - col;\\n            if (occupiedDiag1s.contains(diag1))\\n                continue;\\n            int diag2 = row + col;\\n            if (occupiedDiag2s.contains(diag2))\\n                continue;\\n            // we can now place a queen here\\n            if (row == n-1)\\n                count++;\\n            else {\\n                occupiedCols.add(col);\\n                occupiedDiag1s.add(diag1);\\n                occupiedDiag2s.add(diag2);\\n                count = totalNQueensHelper(row+1, count, n);\\n                // recover\\n                occupiedCols.remove(col);\\n                occupiedDiag1s.remove(diag1);\\n                occupiedDiag2s.remove(diag2);\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20048,
                "title": "easiest-java-solution-1ms-98-22",
                "content": "This is a classic backtracking problem. \\n\\nStart row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays.\\n\\nStart going back when we reach row n.\\n\\nJust FYI, if using HashSet, running time will be at least 3 times slower!\\n\\n    public class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }\\n        \\n        public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {\\n            if(row == n) count++;\\n    \\n            for(int col = 0; col < n; col++) {\\n                int id1 = col - row + n;\\n                int id2 = col + row;\\n                if(cols[col] || d1[id1] || d2[id2]) continue;\\n                \\n                cols[col] = true; d1[id1] = true; d2[id2] = true;\\n                backtracking(row + 1, cols, d1, d2, n);\\n                cols[col] = false; d1[id1] = false; d2[id2] = false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237811,
                "title": "short-easy-w-explanation-visualization-backtracking-explained",
                "content": "This is very similar to [N-Queens](https://leetcode.com/problems/n-queens/) problem, with the only difference being that we are required to return count instead of all the solution boards. But both the solutions are almost the same.\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we dont need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, **on each row only one queen** can be placed and then we can move to the next row.\\n\\nSo for each row we will to place one queen without violating the constraint and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to placed at *`(i, j)`*. If all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place the queen on the same row at some other column, i.e, we need to **backtrack**. This will give us all the possible ways to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) of how this process works -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Space Complexity :*** **`O(N*N)`**. Required for board and recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking O(N) Space)***\\n\\nWe don\\'t need to simulate the exact board since we only require number of solutions and not the exact board solutions themselves. \\n\\nHere, we only keep track of queen placements on each of *`n`* columns, *`2n-1`* diagonals and *`2n-1`* anti-diagonals. This will eliminate the need to iterative *`check`* function and reduc space usage\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack and *`col`*, *`diag`*, *`anti_diag`*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Backtracking + Bitset O(N))***\\n\\nSlight optimization using bitset in C++, although it won\\'t make much of difference in space usage since it\\'s dominated by recursive stack space usage.\\n\\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Backtracking + Bit-Manipulation)***\\n\\nDirect bit-manipulation instead of using bitset -\\n\\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/abb6caae-6ffd-4062-8244-73bd3703cfb8_1622279017.2683792.png /></td></tr></table>\\n\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126533,
                "title": "python-backtracking-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def totalNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        diag1 = set()\\n        diag2 = set()\\n        usedCols = set()\\n        \\n        return self.helper(n, diag1, diag2, usedCols, 0)\\n\\n    def helper(self, n, diag1, diag2, usedCols, row):\\n        if row == n:\\n            return 1\\n        \\n        solutions = 0\\n        \\n        for col in range(n):\\n            if row + col in diag1 or row - col in diag2 or col in usedCols:\\n                continue\\n                \\n            diag1.add(row + col)\\n            diag2.add(row - col)\\n            usedCols.add(col)\\n            \\n            solutions += self.helper(n, diag1, diag2, usedCols, row + 1)\\n        \\n            diag1.remove(row + col)\\n            diag2.remove(row - col)\\n            usedCols.remove(col)\\n        \\n        return solutions\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        diag1 = set()\\n        diag2 = set()\\n        usedCols = set()\\n        \\n        return self.helper(n, diag1, diag2, usedCols, 0)\\n\\n    def helper(self, n, diag1, diag2, usedCols, row):\\n        if row == n:\\n            return 1\\n        \\n        solutions = 0\\n        \\n        for col in range(n):\\n            if row + col in diag1 or row - col in diag2 or col in usedCols:\\n                continue\\n                \\n            diag1.add(row + col)\\n            diag2.add(row - col)\\n            usedCols.add(col)\\n            \\n            solutions += self.helper(n, diag1, diag2, usedCols, row + 1)\\n        \\n            diag1.remove(row + col)\\n            diag2.remove(row - col)\\n            usedCols.remove(col)\\n        \\n        return solutions\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20147,
                "title": "python-recursive-dfs-solution",
                "content": "The idea here is quite similar to [N-Queens ][1] while we don\\'t need to record the path, and as the return value is a number not a list, it\\'s better to use a global variable to record the result.\\n       \\n    def totalNQueens(self, n):\\n        self.res = 0\\n        self.dfs([-1]*n, 0)\\n        return self.res\\n        \\n    def dfs(self, nums, index):\\n        if index == len(nums):\\n            self.res += 1\\n            return #backtracking\\n        for i in range(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):\\n                self.dfs(nums, index+1)\\n        \\n    def valid(self, nums, n):\\n        for i in range(n):\\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\\n                return False\\n        return True\\n\\n\\n  [1]: https://leetcode.com/discuss/53764/python-recursive-dfs-solution-with-comments",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "The idea here is quite similar to [N-Queens ][1] while we don\\'t need to record the path, and as the return value is a number not a list, it\\'s better to use a global variable to record the result.\\n       \\n    def totalNQueens(self, n):\\n        self.res = 0\\n        self.dfs([-1]*n, 0)\\n        return self.res\\n        \\n    def dfs(self, nums, index):\\n        if index == len(nums):\\n            self.res += 1\\n            return #backtracking\\n        for i in range(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):\\n                self.dfs(nums, index+1)\\n        \\n    def valid(self, nums, n):\\n        for i in range(n):\\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\\n                return False\\n        return True\\n\\n\\n  [1]: https://leetcode.com/discuss/53764/python-recursive-dfs-solution-with-comments",
                "codeTag": "Python3"
            },
            {
                "id": 20077,
                "title": "c-solution-dfs-easy-understanding",
                "content": "    int totalNQueens(int n) {\\n        vector<bool> col(n, true);\\n        vector<bool> anti(2*n-1, true);\\n        vector<bool> main(2*n-1, true);\\n        vector<int> row(n, 0);\\n        int count = 0;\\n        dfs(0, row, col, main, anti, count);\\n        return count;\\n    }\\n    void dfs(int i, vector<int> &row, vector<bool> &col, vector<bool>& main, vector<bool> &anti, int &count) {\\n            if (i == row.size()) {\\n                count++;\\n                return;\\n            }\\n           for (int j = 0; j < col.size(); j++) {\\n             if (col[j] && main[i+j] && anti[i+col.size()-1-j]) {\\n                 row[i] = j; \\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = false;\\n                 dfs(i+1, row, col, main, anti, count);\\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = true;\\n          }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int totalNQueens(int n) {\\n        vector<bool> col(n, true);\\n        vector<bool> anti(2*n-1, true);\\n        vector<bool> main(2*n-1, true);\\n        vector<int> row(n, 0);\\n        int count = 0;\\n        dfs(0, row, col, main, anti, count);\\n        return count;\\n    }\\n    void dfs(int i, vector<int> &row, vector<bool> &col, vector<bool>& main, vector<bool> &anti, int &count) {\\n            if (i == row.size()) {\\n                count++;\\n                return;\\n            }\\n           for (int j = 0; j < col.size(); j++) {\\n             if (col[j] && main[i+j] && anti[i+col.size()-1-j]) {\\n                 row[i] = j; \\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = false;\\n                 dfs(i+1, row, col, main, anti, count);\\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = true;\\n          }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1238198,
                "title": "python-super-short-backtracking-explained",
                "content": "This problem is similar to problem **46** and **51**, basically we need to go over all `n!` permutations and then check if it is correct and write function to draw this solution. Let us use `dfs(board, c1, c2, c3)` function here, where:\\n\\n1. `board` are positions of queen for the first, second and so on lines. Length of `board` is how many queens we already used.\\n2. `c1` is bit mask for columns, `c2` and `c3` for diagonals. Note, that we use `i-j+n` for one of the diagonals to avoid negative numbers.  Each time we try to take all possible positions and then check if we can put queen on this position.\\n\\n#### Complexity\\nTime and space complexity is `O(n!)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def totalNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: self.ans += 1\\n            \\n           for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        self.ans = 0\\n        dfs([], 0, 0, 0, 0)\\n        return self.ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def totalNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: self.ans += 1\\n            \\n           for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        self.ans = 0\\n        dfs([], 0, 0, 0, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111695,
                "title": "c-n-queens-variation",
                "content": "**Please upvote the post if you like it :)**\\n\\nSo, basically  we have been given `n` queens and we need to place those **queens** in the `board` such that  no **two** queens **attack** each other right?\\n\\nCool, so we know that the number of ways to place `N` **queens** on a `NxN` **board** can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... which eventually leads to an overall **time** **complexity** of `O(N^2N)`, which is extremely **high** and we can\\'t afford that.\\n\\nBut, simultaneously we also know that we don\\'t actually need to traverse all the `O(N^2)` options each time. \\nSo, we can place one **queen** in each **row** and then move to the next row.\\n\\nSo for each row, we will place one queen (if possible within the contraint) and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the `isSafe` method to ensure that the queen is safe to `place` at **(i, j)**. Once, all `N` **queens** have been placed, we have got our first solution.\\n\\nFinally, to get all the other possible solutions, we will keep on removing the previously placed queen and try if its possible to place it at some other location, i.e, where we need to **backtrack**. This will give us all the possible combinations to place `N Queens` on the board as per the given constraints.\\n\\n****\\nVisualization if needed from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif)- \\n\\n\\n![image](https://assets.leetcode.com/users/images/6388c419-0494-4d56-9bc4-a710a3699862_1654316356.7472951.gif)\\n\\n\\n****\\n**Solution 1 - Backtracking Approach (C++) :** \\u2705\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t\\t// checking if any queen already placed on same column previously\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    // checking if all diagonals are safe -\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\t    board[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\t    count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\t\\t// backtrack - remove previously placed queen and try for different columns\\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```\\n\\n****\\n**Time Complexity : O(N!)**, Since we have N choices in the first row, then N-1 choices in the second row and so on so the overall complexity become **O(N!)** \\n**Space Complexity: O(N*N)**, Just the `board` and recursive `stack` space\\n\\n****\\n**Solution 2 - (Backtracking Approach O(N) Space):** \\u2705\\nHere we only need the number of `distinct` solutions and not the exact board solutions themselves, so what we can do is that we can keep a track on `queen` placements on each `n` **columns**, `2n-1` **diagonals**,` 2n-1` **Anti-daigonals**, this way we can remove the `isSafe` function and reduce **space** size.\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n**Time Complexity : O(N!)**\\n**Space Complexity : O(N), for recursive stack and col, diag, anti_diag**\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t\\t// checking if any queen already placed on same column previously\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    // checking if all diagonals are safe -\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\t    board[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\t    count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\t\\t// backtrack - remove previously placed queen and try for different columns\\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20046,
                "title": "share-my-java-code-beats-97-83-run-times",
                "content": "    /*\\n        \\u5e38\\u89c4n-queens\\u89e3\\u6cd5, \\u6570\\u7b54\\u6848\\u4e2a\\u6570.\\n        \\u7528column\\u6807\\u8bb0\\u6b64\\u884c\\u4e4b\\u524d\\u7684\\u54ea\\u4e9bcolumn\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94column\\u7684\\u7b2ccol\\u4f4d(LSB --> MSB, \\u4e0b\\u540c).\\n        \\u7528diag\\u6807\\u8bb0\\u6b64\\u4f4d\\u7f6e\\u4e4b\\u524d\\u7684\\u54ea\\u4e9b\\u4e3b\\u5bf9\\u89d2\\u7ebf\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94diag\\u7684\\u7b2c(n - 1 + row - col)\\u4f4d.\\n        \\u7528antiDiag\\u6807\\u8bb0\\u6b64\\u4f4d\\u7f6e\\u4e4b\\u524d\\u7684\\u54ea\\u4e9b\\u526f\\u5bf9\\u89d2\\u7ebf\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94antiDiag\\u7684\\u7b2c(row + col)\\u4f4d.\\n    */\\n    public class Solution {\\n        int count = 0;\\n        \\n        public int totalNQueens(int n) {\\n            dfs(0, n, 0, 0, 0);\\n            return count;\\n        }\\n        \\n        private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n            if (row == n) {\\n                ++count;\\n                return;\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                boolean isColSafe = ((1 << i) & column) == 0;\\n                boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n                boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n                if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                    dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int count = 0;\\n        \\n        public int totalNQueens(int n) {\\n            dfs(0, n, 0, 0, 0);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237780,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Note**: This problem is an easier duplicate to the previous problem, [**51: N-Queens**](https://leetcode.com/problems/n-queens), except that it doesn\\'t require us to return the actual boards, just the count.)_\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the board.\\n\\nRather than store the whole board, we can save on **space complexity** if we only keep track of the different axes of attack in which a queen might be placed. Since a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity.\\n\\nThere are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nIf we successfully reach the end of the board without failing, we should increment our answer counter (**ans**).\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.0MB** (beats 100% / 99%).\\n```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **44ms / 13.9MB** (beats 90% / 99%).\\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.2MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111513,
                "title": "python-solution-with-explanation",
                "content": "This problem is an extension on the yesterday\\'s daily challenge problem [N-Queens](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation). Please refer the link to understand how **N-Queens** is implemented. \\n\\n\\nThe below code is just a slight modification on yesterday\\'s [solution](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation) that I had posted. In this, instead of returning the list of valid solutions, I am returning the count of number of valid solutions.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        state=[[\\'.\\'] * n for _ in range(n)]\\n\\t\\t\\n\\t\\t# for tracking the columns which already have a queen\\n        visited_cols=set()\\n\\t\\t\\n\\t\\t# This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        visited_diagonals=set()\\n\\t\\t\\n\\t\\t # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:\\n                res.add(map(\\'#\\'.join, map(\\'\\'.join, state))) # add a valid solution\\n                return\\n                        \\n            for c in range(n):\\n\\t\\t\\t # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)\\n                    state[r][c]=\\'Q\\'\\n                    backtrack(r+1)\\n                    \\n\\t\\t\\t\\t\\t# reset the exploration path for backtracking\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)\\n                    state[r][c]=\\'.\\'\\n                        \\n        backtrack(0)\\n        return len(res)\\n\\n```\\n\\nBut sometimes while building a solution for a problem that is an extension or similar to another problem, we might end up with similar solution with slight change. This is what I did in my above approach. We were already tracking valid solutions in [N-Queens](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation). So instead of returning the list of valid solutions, I am returning count of the number of solutions in the list.\\n\\nIf you observe the exploration path that solution tree takes, you would notice that it starts at a different row each time. Each path it takes is unique. So instead of tracking the valid solutions. We can just track the count of valid solutions. Whenever we hit the required number of queens, we just add that path to overall tally.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:                \\n        visited_cols=set()\\n        visited_diagonals=set()\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:  # valid solution state   \\n                return 1\\n                        \\n            cnt=0\\n            for c in range(n):\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)                    \\n                    cnt+=backtrack(r+1) # count the overall tally from this current state\\n                    \\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)                    \\n            \\n            return cnt\\n        \\n        return backtrack(0)\\n\\n```\\n\\n**Time - O(N!)** - In the solution tree, number of valid exploration paths from a node reduces by 2 at each level. In first level, we have `N` columns options to place the queen i.e `N` paths from the root node. In the next level, we have max `N-2` options available because we can\\'t place the queen in same column and same diagonal as previous queen. In the next level, it will be `N-4` because of two columns and two diagonals occupied by previous two queens. This will continue and give us a `O(N!)`Time. (Let me know if you think otherwise :) )\\n\\n**Space - O(N^2)** - recursive call stack to explore all possible solutions\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        state=[[\\'.\\'] * n for _ in range(n)]\\n\\t\\t\\n\\t\\t# for tracking the columns which already have a queen\\n        visited_cols=set()\\n\\t\\t\\n\\t\\t# This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        visited_diagonals=set()\\n\\t\\t\\n\\t\\t # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:\\n                res.add(map(\\'#\\'.join, map(\\'\\'.join, state))) # add a valid solution\\n                return\\n                        \\n            for c in range(n):\\n\\t\\t\\t # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)\\n                    state[r][c]=\\'Q\\'\\n                    backtrack(r+1)\\n                    \\n\\t\\t\\t\\t\\t# reset the exploration path for backtracking\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)\\n                    state[r][c]=\\'.\\'\\n                        \\n        backtrack(0)\\n        return len(res)\\n\\n```\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:                \\n        visited_cols=set()\\n        visited_diagonals=set()\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:  # valid solution state   \\n                return 1\\n                        \\n            cnt=0\\n            for c in range(n):\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)                    \\n                    cnt+=backtrack(r+1) # count the overall tally from this current state\\n                    \\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)                    \\n            \\n            return cnt\\n        \\n        return backtrack(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20119,
                "title": "collection-of-solutions-in-java",
                "content": "This post is mainly for myself as I learnt a lot from all kinds of solutions posted under this question. The copyright goes to the original author :)\\n\\nClick on the title of each method and you can see the original author's explanations (if there is any).\\n\\n\\n#[Java accepted clean solutions, >98.73% by yunli2015][1]#\\n\\n    public class Solution {\\n        int count=0;\\n        public int totalNQueens(int n) {\\n            dfs(new int[n],0,n);\\n            return count;\\n        }\\n        public void dfs(int[] pos,int step,int n) {\\n            if(step==n) {\\n                count++;\\n                return;\\n            }\\n            for(int i=0;i<n;i++) {\\n                pos[step]=i;\\n                if(isvalid(pos,step)) dfs(pos,step+1,n);\\n            }\\n        }\\n        public boolean isvalid(int[] pos, int step) {\\n            for(int i=0;i<step;i++) {\\n                if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            }\\n            return true;\\n        } \\n    }\\n\\nessentially the same one:\\n#[Share. Java, 3ms, recurrsion, backtracing, very easy to understand. by Yuan__Yuan][2]#\\n\\n    public class Solution {\\n        public int totalNQueens(int n) {\\n            if (n == 0)\\n                return 0;\\n            int[] q = new int[n];\\n            return track(q, 0);\\n        }\\n        \\n        private int track(int[] q, int row) {\\n            if (row == q.length)\\n                return 1;\\n            int solutions = 0;\\n            for (int i = 0; i < q.length; i++) {\\n                q[row] = i;\\n                if (isValid(q, row, i)) {\\n                    solutions += track(q, row + 1);\\n                }\\n            }\\n            return solutions;\\n        }\\n        \\n        private boolean isValid(int[] q, int row, int col) {\\n            for (int i = 0; i < row; i++) {\\n                if (q[i] == col || Math.abs(row - i) == Math.abs(col - q[i]))\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }\\n\\n#[My own tedious code][3]#\\n\\n    public class Solution {\\n        private int counter = 0;\\n        public int totalNQueens(int N) {\\n            for(int i=0; i<N; i++) {\\n                char[][] board = new char[N][N];\\n                board[i][0] = 'Q';\\n                solve(board, N, 1);\\n            }\\n            return counter;\\n        }\\n        private boolean isSafe(char[][] board, int N, int row, int col) {\\n            for(int i=0; i<N; i++) {\\n                if(board[i][col]!=0) return false;\\n                if(board[row][i]!=0) return false;\\n            }\\n        \\n            int step = 1;\\n            step = 1;\\n            while(row-step>=0 && col-step>=0) {\\n                if(board[row-step][col-step]!=0) return false;\\n                ++step;\\n            }\\n            step = 1;\\n            while(row+step<N && col-step>=0) {\\n                if(board[row+step][col-step]!=0) return false;\\n                ++step;\\n            }\\n            return true;\\n        }\\n        private boolean solve(char[][] board, int N, int col) {\\n            if(col==N) {\\n                ++counter; \\n                return false;\\n            }\\n            for(int i=0; i<N; i++) {\\n                if(isSafe(board, N, i, col)) {\\n                    board[i][col] = 'Q';\\n                    if(solve(board, N, col+1)) return true;\\n                    else {\\n                        board[i][col] = 0;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n#[Pretty simple JAVA solution by EvelynGuo][4]#\\n\\n    public class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n    \\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n      }\\n      public void helper(int[] res, int n, int row){\\n        if(row==n){\\n            res[0]++;\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                if(col.contains(i) || diag1.contains(i+row) || diag2.contains(row-i)) continue;\\n                else{\\n                    col.add(i);\\n                    diag1.add(i+row);\\n                    diag2.add(row-i);\\n                    helper(res,n,row+1);\\n                    col.remove(i);\\n                    diag1.remove(i+row);\\n                    diag2.remove(row-i);\\n                }\\n             }\\n          }\\n       }\\n    }\\n\\nSimilar idea as above but better implementation:\\n\\n#[Easiest Java Solution (1ms, 98.22%) by yavinci][5]#\\n\\n    public class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }\\n    \\n        public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {\\n            if(row == n) count++;\\n    \\n            for(int col = 0; col < n; col++) {\\n                int id1 = col - row + n;\\n                int id2 = col + row;\\n                if(cols[col] || d1[id1] || d2[id2]) continue;\\n    \\n                cols[col] = true; d1[id1] = true; d2[id2] = true;\\n                backtracking(row + 1, cols, d1, d2, n);\\n                cols[col] = false; d1[id1] = false; d2[id2] = false;\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/60251/java-accepted-clean-solutions-98-73%25\\n  [2]: https://leetcode.com/discuss/72502/share-java-3ms-recurrsion-backtracing-very-easy-understand\\n  [3]: https://leetcode.com/discuss/80748/java-almost-same-as-n-queens-i\\n  [4]: https://leetcode.com/discuss/63709/pretty-simple-java-solution\\n  [5]: https://leetcode.com/discuss/69603/easiest-java-solution-1ms-98-22%25",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int count=0;\\n        public int totalNQueens(int n) {\\n            dfs(new int[n],0,n);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237813,
                "title": "n-queens-ii-easy-solution-using-backtracking-w-explanation-and-visualization",
                "content": "This is very similar to [N-Queens](https://leetcode.com/problems/n-queens/) problem, with the only difference being that we are required to return count instead of all the solution boards. But both the solutions are almost the same.\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we dont need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, **on each row only one queen** can be placed and then we can move to the next row.\\n\\nSo for each row we will to place one queen without violating the constraint and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to placed at *`(i, j)`*. If all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place the queen on the same row at some other column, i.e, we need to **backtrack**. This will give us all the possible ways to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) of how this process works -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Space Complexity :*** **`O(N*N)`**. Required for board and recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking O(N) Space)***\\n\\nWe don\\'t need to simulate the exact board since we only require number of solutions and not the exact board solutions themselves. \\n\\nHere, we only keep track of queen placements on each of *`n`* columns, *`2n-1`* diagonals and *`2n-1`* anti-diagonals. This will eliminate the need to iterative *`check`* function and reduc space usage\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack and *`col`*, *`diag`*, *`anti_diag`*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Backtracking + Bitset O(N))***\\n\\nSlight optimization using bitset in C++, although it won\\'t make much of difference in space usage since it\\'s dominated by recursive stack space usage.\\n\\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Backtracking + Bit-Manipulation)***\\n\\nDirect bit-manipulation instead of using bitset -\\n\\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/abb6caae-6ffd-4062-8244-73bd3703cfb8_1622279017.2683792.png /></td></tr></table>\\n\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111854,
                "title": "java-branch-and-bound-method-easy-optimized-solu-faster-than-98",
                "content": "**Upvote if u find this solution good**\\n```\\nclass Solution {\\n    int count = 0;\\n    public void total(int row ,int n , boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol){\\n        if(row==n){\\n            count++;\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                total(row+1,n,cols,nDiagnol,rDiagnol);\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n     boolean[] cols = new boolean[n];\\n     boolean[] nDiagnol = new boolean[2*n-1];\\n     boolean[] rDiagnol = new boolean[2*n-1];\\n        total(0,n,cols,nDiagnol,rDiagnol);\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public void total(int row ,int n , boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol){\\n        if(row==n){\\n            count++;\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                total(row+1,n,cols,nDiagnol,rDiagnol);\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n     boolean[] cols = new boolean[n];\\n     boolean[] nDiagnol = new boolean[2*n-1];\\n     boolean[] rDiagnol = new boolean[2*n-1];\\n        total(0,n,cols,nDiagnol,rDiagnol);\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237781,
                "title": "n-queens-ii-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Note**: This problem is an easier duplicate to the previous problem, [**51: N-Queens**](https://leetcode.com/problems/n-queens), except that it doesn\\'t require us to return the actual boards, just the count.)_\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the board.\\n\\nRather than store the whole board, we can save on **space complexity** if we only keep track of the different axes of attack in which a queen might be placed. Since a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity.\\n\\nThere are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nIf we successfully reach the end of the board without failing, we should increment our answer counter (**ans**).\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.0MB** (beats 100% / 99%).\\n```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **44ms / 13.9MB** (beats 90% / 99%).\\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.2MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551698,
                "title": "java-tc-o-n-n-sc-o-n-space-optimized-backtracking-using-bitset",
                "content": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n\\n        return totalNQueensHelper(new BitSet(5 * n), 0, n);\\n    }\\n\\n    private int totalNQueensHelper(BitSet occupied, int row, int n) {\\n        if (row == n) {\\n            return 1;\\n        }\\n\\n        int count = 0;\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n\\n            count += totalNQueensHelper(occupied, row + 1, n);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other N-Queens questions on LeetCode:\\n- [51. N-Queens](https://leetcode.com/problems/n-queens/discuss/1551695/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Space-Optimized-Backtracking-using-BitSet)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n\\n        return totalNQueensHelper(new BitSet(5 * n), 0, n);\\n    }\\n\\n    private int totalNQueensHelper(BitSet occupied, int row, int n) {\\n        if (row == n) {\\n            return 1;\\n        }\\n\\n        int count = 0;\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n\\n            count += totalNQueensHelper(occupied, row + 1, n);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111511,
                "title": "backtracking-and-bit-manipulation-explained",
                "content": "### Logic:\\nThis problem is essentially the original [N-Queens](https://leetcode.com/problems/n-queens/) problem but made simpler in that we don\\'t need to keep track of board state! Otherwise, the approach is identitical; attempt all valid board states through **backtracking**.\\n\\nSince the explanation still applies, I will use the same diagrammatic explanation as I did in the original N-Queens problem.\\n\\nFirst, we need to understand how a Queen moves and what constitutes a valid position. Queen\\'s can move in literally any straight-lined direction. \\n\\n![image](https://assets.leetcode.com/users/images/b51628d9-0917-45db-a2b7-823ece81a8c1_1654307228.4397633.png)\\n\\nIt\\'s possibe to place a Queen down if and only if:\\n* There exists no Queen on the current row.\\n* There exists no Queen on the current column.\\n* There exists no Queen on the current diagonal.\\n* There exists no Queen on the current anti-diagonal.\\n\\n> Backtracking: Try a promising Queen position, see how it goes. If it fails, undo that Queen and try again somewhere else.\\n\\n![image](https://assets.leetcode.com/users/images/ca380113-d402-4c1e-a21d-a632196a39fd_1654307245.1164281.png)\\n\\n\\nHopefull it\\'s now clear that we need some way to keep track of Queens on previous rows, columns and diagonals. We can take care of rows automatically by incrementing each queen placement by row. In other words, after each successful Queen placement, we move to the next row (since no two Queens can share the same row).\\nWe can keep track of previous columns just by their column indexes. What about the diagonals? Well here\\'s an interesting observation:\\n\\n![image](https://assets.leetcode.com/users/images/e88b8d70-250d-48bd-bf75-ce265e69b7d4_1654307264.8783712.png)\\n\\n\\n(the \"+N\" is to offset negative values. You will see why we do this in the next section). Now we have everything we need to keep track of previous Queens and start thinking about our algorithm! But just one more thing; let\\'s keep track of \"used\" columns and diagonals using bit masks.\\n\\n___\\n### Why Integer Bit Masks?\\nWe prefer integer bitmasks in this question for 2 main reasons:\\n1. Sets in Java are a slow datastructure. So keeping track of visited columns and diagonals using integers is much quicker through bit manipulation!\\n2. It\\'s slightly more space efficient since we\\'re only storing three integers instead of arrays or other datastructures. \\n\\n### Bit Manipulation Tricks\\n1. **Check the ith bit:** `x & (1 << i)`, where `1 << i` is shifting 1 to the left i number of times.\\n\\tFor example, if we want to check if a Queen exists at column 5, we can check if (cols & (1 << 5) != 0). Basically, if we haven\\'t seen a Queen at this column before, then the bitwise AND operation at that specific bit will be 0. Otherwise, it will be a non-zero value.\\n2. **Set the ith bit:** `x |= (1 << i)`. This performs a bitwise OR operation on the ith bit. This will always set the ith bit to 1. For example, if the ith bit in `cols` is currently 1, then 1 | 1 = 1. If it\\'s set to 0, then 0 | 0 is still = 1.\\n3. **Flip the ith bit:** `x ^= (1 << i)` To reverse the previous action, we use the inverse logic of an OR; a bitwise XOR (exclusive-OR).  The basic idea of XOR is that if two bits are the same (0,0) and (1,1), you will get 0. However if the two bits are different (1,0) or (0,1), you get 1. This is the exact opposite of OR, hence the name. \\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n```java\\nclass Solution {\\n\\tpublic int totalNQueens(int n) {\\n        return backtrack(0, 0, 0, 0, n);\\n    }\\n    \\n    private int backtrack(int row, int cols, int diags, int antiDiags, int N) {\\n\\t\\t// If we\\'re at row N, we\\'ve finished placing all N queens. Therefore, we\\'ve reached a new valid position.\\n        if (row == N) return 1;\\n        \\n        int total = 0;\\n        for (int col=0; col<N; col++) {\\n            int diag = row - col + N;\\n            int antiDiag = row + col;\\n            \\n\\t\\t\\t// Check if it\\'s possible to place a Queen at this point\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << diag)) != 0 || (antiDiags & (1 << antiDiag)) != 0) continue;\\n            \\n\\t\\t\\t// If so, apply changes to the columns and diagonals\\n            cols |= 1 << col;\\n            diags |= 1 << diag;\\n            antiDiags |= 1 << antiDiag;\\n            \\n\\t\\t\\t// Continue to the next row\\n            total += backtrack(row + 1, cols, diags, antiDiags, N);\\n            \\n\\t\\t\\t// Undo changes and try another position\\n            cols ^= 1 << col;\\n            diags ^= 1 << diag;\\n            antiDiags ^= 1 << antiDiag;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\n**Time Complexity:** `O(N!)` since we look for every valid board state.\\n**Space Complexity:** `O(N)` due to the recursive call stack.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n\\tpublic int totalNQueens(int n) {\\n        return backtrack(0, 0, 0, 0, n);\\n    }\\n    \\n    private int backtrack(int row, int cols, int diags, int antiDiags, int N) {\\n\\t\\t// If we\\'re at row N, we\\'ve finished placing all N queens. Therefore, we\\'ve reached a new valid position.\\n        if (row == N) return 1;\\n        \\n        int total = 0;\\n        for (int col=0; col<N; col++) {\\n            int diag = row - col + N;\\n            int antiDiag = row + col;\\n            \\n\\t\\t\\t// Check if it\\'s possible to place a Queen at this point\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << diag)) != 0 || (antiDiags & (1 << antiDiag)) != 0) continue;\\n            \\n\\t\\t\\t// If so, apply changes to the columns and diagonals\\n            cols |= 1 << col;\\n            diags |= 1 << diag;\\n            antiDiags |= 1 << antiDiag;\\n            \\n\\t\\t\\t// Continue to the next row\\n            total += backtrack(row + 1, cols, diags, antiDiags, N);\\n            \\n\\t\\t\\t// Undo changes and try another position\\n            cols ^= 1 << col;\\n            diags ^= 1 << diag;\\n            antiDiags ^= 1 << antiDiag;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718314,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res = 0, stack = [(Array(repeating: 0, count: n), 0)]\\n        \\n        while !stack.isEmpty {\\n            var cur = stack.removeLast(), row = cur.0, idx = cur.1\\n            if idx == row.count { res += 1; continue }\\n            for i in 0..<n {\\n                row[idx] = i\\n                if !detect(idx) { stack.append((row, idx + 1)) }\\n            }\\n            func detect(_ i: Int) -> Bool {\\n                var idx = i - 1\\n                while idx >= 0 {\\n                    let lhs = row[idx], rhs = row[i]\\n                    if lhs == rhs || abs(lhs - rhs) == (i - idx) { return true }\\n                    idx -= 1\\n                }\\n                return false\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // There are two distinct solutions to the 4-queens puzzle as shown.\\n    func test0() {\\n        let value = solution.totalNQueens(4)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.totalNQueens(1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res = 0, stack = [(Array(repeating: 0, count: n), 0)]\\n        \\n        while !stack.isEmpty {\\n            var cur = stack.removeLast(), row = cur.0, idx = cur.1\\n            if idx == row.count { res += 1; continue }\\n            for i in 0..<n {\\n                row[idx] = i\\n                if !detect(idx) { stack.append((row, idx + 1)) }\\n            }\\n            func detect(_ i: Int) -> Bool {\\n                var idx = i - 1\\n                while idx >= 0 {\\n                    let lhs = row[idx], rhs = row[i]\\n                    if lhs == rhs || abs(lhs - rhs) == (i - idx) { return true }\\n                    idx -= 1\\n                }\\n                return false\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // There are two distinct solutions to the 4-queens puzzle as shown.\\n    func test0() {\\n        let value = solution.totalNQueens(4)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.totalNQueens(1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20094,
                "title": "a-classic-c-solution-using-bitwise-operations-0ms",
                "content": "The code is very short and simple:\\n\\n    int next(int row, unsigned int vertMask, unsigned int leftMask, unsigned int rightMask, unsigned int rangeMask) {\\n        if (row == 0)\\n            return 1;\\n            \\n        unsigned int mask = rangeMask & ~(leftMask | rightMask | vertMask);\\n        int r = 0;\\n        while (mask) {\\n            unsigned int queenFlag = mask & -mask;\\n            r += next(\\n                    row-1, \\n                    (  vertMask | queenFlag ), \\n                    (  leftMask | queenFlag ) << 1, \\n                    ( rightMask | queenFlag ) >> 1, \\n                    rangeMask\\n                );\\n            mask ^= queenFlag;\\n        }\\n        return r;\\n    }\\n\\n    int totalNQueens(int n) {\\n        return next(n, 0, 0, 0, ((unsigned int)-1) >> (32-n));\\n    }\\n    \\n\\nThe main idea is each bit represent a position. If a bit is set to 1, it means this position is unavailable to put a queen into. So with 32-bit integer this way can solve no more than 32-queens problem. \\n\\nAssume current is first row, and N == 5. So rangeMask will be 0b 0001 1111. \\nThis line\\n\\nmask = rangeMask & ~(leftMask | rightMask | vertMask)\\n\\nmake available bits set to 1. So mask = 0b 0001 1111. mask & -mask is a trick to get the lowest 1-bit. Now set a queen at position queenFlag, and try next row.\\n\\nAssume row N has a queen at column 3. The arguments for next(N-1, ...) will be:\\n\\nTo shift left/right queenFlag by 1 will make the positions the queen could attack to set to 1. I set the masks' type to unsigned to avoid signed right shift could cause a bug when N = 32.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "The code is very short and simple:\\n\\n    int next(int row, unsigned int vertMask, unsigned int leftMask, unsigned int rightMask, unsigned int rangeMask) {\\n        if (row == 0)\\n            return 1;\\n            \\n        unsigned int mask = rangeMask & ~(leftMask | rightMask | vertMask);\\n        int r = 0;\\n        while (mask) {\\n            unsigned int queenFlag = mask & -mask;\\n            r += next(\\n                    row-1, \\n                    (  vertMask | queenFlag ), \\n                    (  leftMask | queenFlag ) << 1, \\n                    ( rightMask | queenFlag ) >> 1, \\n                    rangeMask\\n                );\\n            mask ^= queenFlag;\\n        }\\n        return r;\\n    }\\n\\n    int totalNQueens(int n) {\\n        return next(n, 0, 0, 0, ((unsigned int)-1) >> (32-n));\\n    }\\n    \\n\\nThe main idea is each bit represent a position. If a bit is set to 1, it means this position is unavailable to put a queen into. So with 32-bit integer this way can solve no more than 32-queens problem. \\n\\nAssume current is first row, and N == 5. So rangeMask will be 0b 0001 1111. \\nThis line\\n\\nmask = rangeMask & ~(leftMask | rightMask | vertMask)\\n\\nmake available bits set to 1. So mask = 0b 0001 1111. mask & -mask is a trick to get the lowest 1-bit. Now set a queen at position queenFlag, and try next row.\\n\\nAssume row N has a queen at column 3. The arguments for next(N-1, ...) will be:\\n\\nTo shift left/right queenFlag by 1 will make the positions the queen could attack to set to 1. I set the masks' type to unsigned to avoid signed right shift could cause a bug when N = 32.",
                "codeTag": "Unknown"
            },
            {
                "id": 2114337,
                "title": "java-two-approaches-with-detailed-explanation",
                "content": "**Approach 1:**\\n\\n**Logic:**\\nN-Queens II is just an extension of N-Queens I rather much more easier I have just made a single change in my entire code which is rather than returning the ans array i returned the ans.size as the question asked for it..\\n**Do have a look at my N-Queens I soln which is explained in detail to understand this approach**\\nhttps://leetcode.com/problems/n-queens/discuss/2109925/java-backtracking-detailed-explanation-with-pictures-easycode\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans.size();\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\\n\\n**Approach 2:(More Optimized)**\\nHere we create three Sets for every used column index ,used 45degree angle and used 135 degree angle and for every valid position we update the position in the three sets \\n**Logic:**\\n* We continue the above stated idea till we found that the current row is equal to the number of rows in the board\\n* Firstly we iterate through every column if we find the current position of row,col is a valid position we continue the process\\n* We then update the three sets \\n```\\n\\tcolIndex with the col value\\n \\tdegree135 with the row-col value\\n\\tdegree45 with the row+col value\\n```\\n* Then we call the same function recursively and then remove the values which were added in the sets\\n\\n**Helper methods used-->**\\n**validCounter -->** places the queen at valid positions and then calls the validPosition function to check for validity and then update it in the set and recursively calls itself\\n**validPosition -->** checks whether the queen can be placed at that position or not\\n\\n**Code -->**\\n**Java**\\n```\\nclass Solution {\\n    \\n    private Set<Integer> colIndex = new HashSet<Integer>();\\n    private Set<Integer> degree45 = new HashSet<Integer>();\\n    private Set<Integer> degree135 = new HashSet<Integer>();\\n    \\n    private int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        validCounter(n,0);\\n        return count;\\n    }\\n    \\n    public void validCounter(int n, int row)\\n    {\\n        if(row == n)\\n        {\\n            count++;\\n            return;\\n        }\\n        else\\n        {\\n            for(int col=0;col<n;col++)\\n            {\\n                if(validPosition(row,col))\\n                {\\n                    colIndex.add(col);\\n                    degree135.add(row-col);\\n                    degree45.add(row+col);\\n                    \\n                    validCounter(n,row+1);  //recursive calling\\n                    \\n                    colIndex.remove(col);\\n                    degree135.remove(row-col);\\n                    degree45.remove(row+col);\\n                }\\n            }\\n        }\\n    }\\n    private boolean validPosition(int row,int col)\\n    {\\n        if(colIndex.contains(col) || degree135.contains(row-col) || degree45.contains(row+col))\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```\\n\\n**Upvote if this helped**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans.size();\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\n```\\n\\tcolIndex with the col value\\n \\tdegree135 with the row-col value\\n\\tdegree45 with the row+col value\\n```\n```\\nclass Solution {\\n    \\n    private Set<Integer> colIndex = new HashSet<Integer>();\\n    private Set<Integer> degree45 = new HashSet<Integer>();\\n    private Set<Integer> degree135 = new HashSet<Integer>();\\n    \\n    private int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        validCounter(n,0);\\n        return count;\\n    }\\n    \\n    public void validCounter(int n, int row)\\n    {\\n        if(row == n)\\n        {\\n            count++;\\n            return;\\n        }\\n        else\\n        {\\n            for(int col=0;col<n;col++)\\n            {\\n                if(validPosition(row,col))\\n                {\\n                    colIndex.add(col);\\n                    degree135.add(row-col);\\n                    degree45.add(row+col);\\n                    \\n                    validCounter(n,row+1);  //recursive calling\\n                    \\n                    colIndex.remove(col);\\n                    degree135.remove(row-col);\\n                    degree45.remove(row+col);\\n                }\\n            }\\n        }\\n    }\\n    private boolean validPosition(int row,int col)\\n    {\\n        if(colIndex.contains(col) || degree135.contains(row-col) || degree45.contains(row+col))\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111563,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2411afa6-d051-4373-b850-dc589989c8bf_1654391362.3126545.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909458,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res: [[Int]] = []\\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path) }\\n            \\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                \\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.count\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res: [[Int]] = []\\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path) }\\n            \\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                \\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.count\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367756,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int cnt=0;\\n    public int totalNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }\\n        }\\n        placeQueen(n,Board,0);\\n        return cnt;\\n    }\\n    public void placeQueen(int n, char Board[][],int row)\\n    {\\n        //Base Case\\n        if(row==n)\\n        {\\n            cnt++;\\n            return;\\n        }\\n         for(int col=0;col<n;col++)\\n         {\\n             if(canPlaceQueen(n,Board,row, col))\\n             {\\n                 Board[row][col]=\\'Q\\';\\n                 placeQueen(n,Board,row+1);\\n                 Board[row][col]=\\'.\\';\\n             }\\n         }\\n        \\n    }\\n    public Boolean canPlaceQueen(int n,char Board[][],int row, int col)\\n    {\\n       // check all rows for the current column\\n        for (int i = 0; i < row; i++) \\n        {\\n            if (Board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //check for 45 degree positions\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        //check for 135 positions\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int cnt=0;\\n    public int totalNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 470018,
                "title": "c-100-speed-100-space-o-1-solution",
                "content": "\\tclass Solution {  \\n\\tprivate:\\n\\t\\tint res;\\n\\tpublic:\\n\\t\\tvoid dfs(int n,int dep,int r,int d1, int d2){\\n\\t\\t\\tif(dep==n){\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cur=1<<i;\\n\\t\\t\\t\\tif((cur&r) || (cur&d1) || (cur&d2)) continue;\\n\\t\\t\\t\\tdfs(n,dep+1, (cur|r),(cur|d1)<<1,(cur|d2)>>1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tint totalNQueens(int n) {\\n\\t\\t\\tres=0;\\n\\t\\t\\tdfs(n,0,0,0,0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {  \\n\\tprivate:\\n\\t\\tint res;\\n\\tpublic:\\n\\t\\tvoid dfs(int n,int dep,int r,int d1, int d2){\\n\\t\\t\\tif(dep==n){\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1237765,
                "title": "python-backtracking-clean-concise-o-n",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(c, rowSet, mainDiagSet, antiDiagSet):\\n            nonlocal ans\\n            if c == n:\\n                ans += 1\\n                return\\n            for r in range(n):\\n                if r not in rowSet and (r-c) not in mainDiagSet and (r+c) not in antiDiagSet:\\n                    rowSet.add(r)\\n                    mainDiagSet.add(r-c)\\n                    antiDiagSet.add(r+c)\\n                    backtrack(c + 1, rowSet, mainDiagSet, antiDiagSet)\\n                    rowSet.remove(r)\\n                    mainDiagSet.remove(r-c)\\n                    antiDiagSet.remove(r+c)\\n            \\n        ans = 0\\n        backtrack(0, set(), set(), set())\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(N!)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(c, rowSet, mainDiagSet, antiDiagSet):\\n            nonlocal ans\\n            if c == n:\\n                ans += 1\\n                return\\n            for r in range(n):\\n                if r not in rowSet and (r-c) not in mainDiagSet and (r+c) not in antiDiagSet:\\n                    rowSet.add(r)\\n                    mainDiagSet.add(r-c)\\n                    antiDiagSet.add(r+c)\\n                    backtrack(c + 1, rowSet, mainDiagSet, antiDiagSet)\\n                    rowSet.remove(r)\\n                    mainDiagSet.remove(r-c)\\n                    antiDiagSet.remove(r+c)\\n            \\n        ans = 0\\n        backtrack(0, set(), set(), set())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544297,
                "title": "javascript-48ms-backtracking",
                "content": "- Time Complexity: O(N!)\\n- Space Complexity: O(N)\\n```JavaScript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set(),\\n          hills = new Set(),\\n          dales = new Set();\\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {boolean}\\n     */\\n    const isSafe = (row, col) => !(cols.has(col) || hills.has(row - col) || dales.has(row + col));\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const placeQueen = (row, col) => {\\n        cols.add(col), hills.add(row - col), dales.add(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const removeQueen = (row, col) => {\\n        cols.delete(col), hills.delete(row - col), dales.delete(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} count\\n     * @return {number}\\n     */\\n    const backtrackQueen = (row, count) => {\\n        if (row === n) {\\n            return ++count;\\n        }\\n        for (let col = 0; col < n; col++) {\\n            if (isSafe(row, col)) {\\n                placeQueen(row, col);\\n                count = backtrackQueen(row + 1, count);\\n                removeQueen(row, col);\\n            }\\n        }\\n        return count;\\n    }\\n    return backtrackQueen(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set(),\\n          hills = new Set(),\\n          dales = new Set();\\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {boolean}\\n     */\\n    const isSafe = (row, col) => !(cols.has(col) || hills.has(row - col) || dales.has(row + col));\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const placeQueen = (row, col) => {\\n        cols.add(col), hills.add(row - col), dales.add(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const removeQueen = (row, col) => {\\n        cols.delete(col), hills.delete(row - col), dales.delete(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} count\\n     * @return {number}\\n     */\\n    const backtrackQueen = (row, count) => {\\n        if (row === n) {\\n            return ++count;\\n        }\\n        for (let col = 0; col < n; col++) {\\n            if (isSafe(row, col)) {\\n                placeQueen(row, col);\\n                count = backtrackQueen(row + 1, count);\\n                removeQueen(row, col);\\n            }\\n        }\\n        return count;\\n    }\\n    return backtrackQueen(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111576,
                "title": "java-clean-easy-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach ,\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* **COLUMN_WISE** FILLING = Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n*  **ROW_WISE** FILLING = Only upper part of the diagonals are checked as positions below of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n\\n**UPVOTE IF HELPFUL**\\n```\\npublic class Solution {\\n    int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        dfs(0, n, 0, 0, 0);\\n        return count;\\n    }\\n    \\n    private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n        if (row == n) {\\n            ++count;\\n            return;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            boolean isColSafe = ((1 << i) & column) == 0;\\n            boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n            boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n            if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n            }\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/5dec5b54-2976-4bb0-9569-fea033425a49_1654392303.9171877.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        dfs(0, n, 0, 0, 0);\\n        return count;\\n    }\\n    \\n    private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n        if (row == n) {\\n            ++count;\\n            return;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            boolean isColSafe = ((1 << i) & column) == 0;\\n            boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n            boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n            if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413249,
                "title": "my-easy-understand-n-queens-solutions-in-java",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/n-queens/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n\\n\\n## Problem\\n\\n> The n-queens puzzle is the problem of placing `n` queens on an `n\\xD7n` chessboard such that no two queens attack each other.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/rk4qd.jpg \"From LeetCode\")\\n\\n> Given an integer `n`, return all distinct solutions to the n-queens puzzle.\\n\\n> Each solution contains a distinct board configuration of the n-queens\\' placement, where `Q` and `.` both indicate a queen and an empty space respectively.\\n\\n**Note:** A queen can attack other queens that are at the same `row` or `column` or at the `diagonal` line.\\n\\n**Example:** \\n\\n```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nEnumerate all possible placements of queens on a `nxn` chessboard and check if each is valid.\\n\\n**Time:** `O(N^N)`\\n**Space:** `O(1)` if we do not consider the output list.\\n\\n\\n### Backtracking\\n\\nThe basic idea is to examine each row and use an array `attack` to restrict the possibilities in the future searching.\\n\\nCheck out the comments. Be careful about the following aspects:\\n\\n- Why will we stop? In other words, what is the base case?\\n- How do we make string generation more efficiently? `StringBuilder`\\n- Why should we initialize `attack` array with `int` type rather than `boolean`?\\n\\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\\n\\nThe graph is from LeetCode solution section.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1sasw.jpg)\\n\\nEach time we pick a queen `(i, j)` we need to update all the attacked positions below it, which include three cases as shown in the graph:\\n\\n- Left-Below positions\\n- Below positions\\n- Right-Below positions\\n\\nNotice that we cannot use `boolean` since some attacked positions might be overlapped.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/owjlb.png)\\n\\nIn the example above, when we restore attacked position for queen `B`, the orange position will be restored to no-attack state if we use `true/false`; however, it is still under attack by queen `A`.\\n\\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/a2rtf.jpg)\\n\\n**Time:** `O(N x N!)`. There is `N` possibilities to put the first queen, then no more than `N(N-2)` to put the second one, and no more than `N(N-2)(N-4)` to put the third one, and so forth. In total, there are `N` layers. The number of calls of `backtracking` at each layer is upper bounded by `N!`. (not consider string construction)\\n**Space:** `O(N^2)` since there are call stacks and `attack` array (do not consider output).\\n\\nThe space complexity can be optimized by using `N`-size array `rows`, `dale`, and `hill`. Each element of them denotes a specific vertical line or diagonal line that a queen can attack.\\n\\nFrom LeetCode solution section:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/oujkh.jpg)\\n\\n\\n\\n\\n## N-Queens II\\n\\nReturns the number of solutions. Modify based on the above solution.\\n\\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20114,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        int totalNQueens(int n) {\\n            int result=0;\\n            vector<int> solution(n);\\n            help(n, 0, solution, result);\\n            return result;\\n        }\\n        /** n:#-of-rows   row:current-#-of-row  solution:store-n-row's-col-index result:final result**/\\n        void help(int n, int row, vector<int>& solution, int& result){\\n            for(int i=0; i<n; i++){\\n                if(check(i, row, solution)){\\n                    if(row+1==n){\\n                        result++;\\n                        continue;\\n                    }\\n                    solution[row]=i;\\n                    help(n, row+1, solution, result);\\n                }\\n            }\\n        }\\n        /*** check the cur-col-choise is valid or not **/\\n        bool check(int col, int row, vector<int>& solution){\\n            for(int i=0; i<row; i++){\\n                if(col==solution[i] || abs(col-solution[i])==abs(row-i))  \\n                    return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int totalNQueens(int n) {\\n            int result=0;\\n            vector<int> solution(n);\\n            help(n, 0, solution, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20128,
                "title": "shortest-c-solution-in-0ms",
                "content": "Idea is to  use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column\\n     \\n    #include<vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        int find(int n, int left, int i, int r, vector<int>&rows,vector<int>&d1,vector<int>&d2){\\n            if (left == 0)\\n                return 1;\\n            int j,sum=0;\\n                for (j=r; j<n; j++){\\n                    if (rows[j] || d1[i+j] || d2[n-1+i-j])\\n                        continue;\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=1;\\n                    sum += find(n, left-1, i+1, 0,rows,d1,d2 );\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=0;\\n                }\\n            return sum;\\n        }\\n        int totalNQueens(int n) {\\n            vector<int>  rows(n),d1(2*n-1),d2(2*n-1);\\n            return find(n,n,0,0,rows,d1,d2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int find(int n, int left, int i, int r, vector<int>&rows,vector<int>&d1,vector<int>&d2){\\n            if (left == 0)\\n                return 1;\\n            int j,sum=0;\\n                for (j=r; j<n; j++){\\n                    if (rows[j] || d1[i+j] || d2[n-1+i-j])\\n                        continue;\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=1;\\n                    sum += find(n, left-1, i+1, 0,rows,d1,d2 );\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3315464,
                "title": "backtracking-logic-solution",
                "content": "\\n\\n# 1. BackTracking Logic Solution\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        res,col,pos,neg=0,set(),set(),set()\\n        def backtracking(r):\\n            if n==r:\\n                nonlocal res\\n                res+=1\\n            for c in range(n):\\n                if c in col or (c+r) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                backtracking(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n        backtracking(0)\\n        return res\\n    #please upvote me it would encourage me alot\\n\\n\\n```\\n\\n#   please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        res,col,pos,neg=0,set(),set(),set()\\n        def backtracking(r):\\n            if n==r:\\n                nonlocal res\\n                res+=1\\n            for c in range(n):\\n                if c in col or (c+r) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                backtracking(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n        backtracking(0)\\n        return res\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115356,
                "title": "c-backtracking-simple",
                "content": "```\\nvoid fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114396,
                "title": "easy-recursive-solution",
                "content": "```csharp\\npublic int TotalNQueens(int n)\\n{\\n\\tint count = 0;\\n\\tvar rows = new bool[n];\\n\\tvar diag1 = new bool[2 * n];\\n\\tvar diag2 = new bool[2 * n];\\n\\n\\tHelper(0); // start with the first column\\n\\n\\treturn count;\\n\\n\\tvoid Helper(int col)\\n\\t{\\n\\t\\tif (col == n) count++; // successfully placed n queens\\n\\t\\t// in case col == n, we could return right away, but it is also alright to go on\\n\\n\\t\\tfor (int row = 0; row < n; row++)\\n\\t\\t{\\n\\t\\t\\tint a = row + col;\\n\\t\\t\\tint b = row - col + n;\\n\\n\\t\\t\\tif (rows[row] || diag1[a] || diag2[b]) continue; // unable to place a queen\\n\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = true;  // place a queen\\n\\t\\t\\tHelper(col + 1);                         // go to the next column\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = false; // remove the queen\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic int TotalNQueens(int n)\\n{\\n\\tint count = 0;\\n\\tvar rows = new bool[n];\\n\\tvar diag1 = new bool[2 * n];\\n\\tvar diag2 = new bool[2 * n];\\n\\n\\tHelper(0); // start with the first column\\n\\n\\treturn count;\\n\\n\\tvoid Helper(int col)\\n\\t{\\n\\t\\tif (col == n) count++; // successfully placed n queens\\n\\t\\t// in case col == n, we could return right away, but it is also alright to go on\\n\\n\\t\\tfor (int row = 0; row < n; row++)\\n\\t\\t{\\n\\t\\t\\tint a = row + col;\\n\\t\\t\\tint b = row - col + n;\\n\\n\\t\\t\\tif (rows[row] || diag1[a] || diag2[b]) continue; // unable to place a queen\\n\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = true;  // place a queen\\n\\t\\t\\tHelper(col + 1);                         // go to the next column\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = false; // remove the queen\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113239,
                "title": "easy-c-sol-backtracking-recursion-time-o-n-n",
                "content": "```\\nclass Solution {  //Time : O(N!*N)\\npublic:\\n    \\n     void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row = 0; row<n; row++){\\n            \\n            if(leftRow[row] == 0 && lowerDiagonal[row+col] == 0 && upperDiagonal[n-1+col-row] == 0){\\n                \\n                board[row][col] = \\'Q\\';\\n                leftRow[row] = 1;\\n                lowerDiagonal[row+col] = 1;\\n                upperDiagonal[n-1 + col - row] = 1;\\n                solve(col+1,board,ans,leftRow,upperDiagonal,lowerDiagonal,n);\\n                \\n                board[row][col] = \\'.\\';\\n                leftRow[row] = 0;\\n                lowerDiagonal[row+col] = 0;\\n                upperDiagonal[n-1+col-row] = 0;\\n                \\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n         vector<vector<string>> res;\\n        vector<string> board(n);\\n        \\n        string s(n,\\'.\\');\\n        \\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        \\n        vector<int> leftRow(n,0),upperDiagonal(2*n-1,0),lowerDiagonal(2*n-1,0);\\n        solve(0,board,res,leftRow,upperDiagonal,lowerDiagonal,n);\\n        \\n        int ans = res.size();\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {  //Time : O(N!*N)\\npublic:\\n    \\n     void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111570,
                "title": "backtracking-explained",
                "content": "**UPVOTE IF HELPFUL**\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2626719c-e537-443c-90c8-afc1ae43d2e6_1654391433.2912345.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652274,
                "title": "beats-99-20-32ms-clean-recursive-solution-in-python",
                "content": "This solution is basically the same as the solution introduced in the article, but I condensed it into 10 lines of code to look more compact.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int: \\n        def rec(col, horizontal, diag, anti_diag):\\n            if col == n: return 1\\n            res = 0\\n            for row in range(n):\\n                if row not in horizontal and (row + col) not in diag and (row - col) not in anti_diag:\\n                    horizontal[row] = True; diag[row + col] = True; anti_diag[row - col] = True;\\n                    res += rec(col + 1, horizontal, diag, anti_diag)\\n                    del horizontal[row]; del diag[row + col]; del anti_diag[row - col];\\n            return res\\n        return rec(0, {}, {}, {})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int: \\n        def rec(col, horizontal, diag, anti_diag):\\n            if col == n: return 1\\n            res = 0\\n            for row in range(n):\\n                if row not in horizontal and (row + col) not in diag and (row - col) not in anti_diag:\\n                    horizontal[row] = True; diag[row + col] = True; anti_diag[row - col] = True;\\n                    res += rec(col + 1, horizontal, diag, anti_diag)\\n                    del horizontal[row]; del diag[row + col]; del anti_diag[row - col];\\n            return res\\n        return rec(0, {}, {}, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20141,
                "title": "never-write-codes-like-this-lets-do-eval",
                "content": "Following codes got AC. But you should never write some codes like this. This is post is just for joking.\\n\\n    /**\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var totalNQueens = function(n) {\\n        var p = '', s = 0, l;\\n        for (var i = 0; i < n; i++) {\\n            l = '\\\\nfor (var s# = 0; s# < ' + n + '; s#++)';\\n            for (var j = 0; j < i; j++)\\n                l += 'if (s# !== s@ && Math.abs(s# - s@) !== (# - @)) '.replace(/@/g, j);\\n            p += l.replace(/#/g, i);\\n        }\\n        p += '\\\\ns++;\\\\ns';\\n        return eval(p);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Following codes got AC. But you should never write some codes like this. This is post is just for joking.\\n\\n    /**\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var totalNQueens = function(n) {\\n        var p = '', s = 0, l;\\n        for (var i = 0; i < n; i++) {\\n            l = '\\\\nfor (var s# = 0; s# < ' + n + '; s#++)';\\n            for (var j = 0; j < i; j++)\\n                l += 'if (s# !== s@ && Math.abs(s# - s@) !== (# - @)) '.replace(/@/g, j);\\n            p += l.replace(/#/g, i);\\n        }\\n        p += '\\\\ns++;\\\\ns';\\n        return eval(p);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3764197,
                "title": "backtracking-logic-solution",
                "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587899,
                "title": "striver-type-c-most-optimized",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115617,
                "title": "javascript-efficient-solution-meme",
                "content": "There is canonic solution with backtracking for the nQueen problem. You can read more on Wikepedia, or even find a video with detailed explanation, **my role here is rather give you a meme**.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#9 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/6642a7a4-3d37-4a24-bcdd-6e3db52c05fd_1654456097.356457.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111566,
                "title": "explanation-understandable",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2626719c-e537-443c-90c8-afc1ae43d2e6_1654391433.2912345.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441898,
                "title": "c-soln-backtracking",
                "content": "Same as N-Queens I \\njust return the size of the vector used to keep possible solution of board\\n\\n```\\nclass Solution {\\npublic:\\n // this vector keeps possible board configurations\\n vector<vector<string>> res;\\n    \\n// checks whether the position is safe for queen or not\\n    bool is_Safe(vector<string>& board , int row , int column)\\n    {\\n        for(int index = row ; index >= 0 ; index--)\\n            if(board[index][column] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex >=0 ; index-- , jindex--)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex < board.size() ; index-- , jindex++)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    // checks all possible configurations by backtracking\\n    void placequeen(vector<string>& board , int row)\\n    {\\n        if(row == board.size())\\n        {\\n            res.push_back(board);\\n            return;\\n        }\\n        \\n        for(int index = 0 ; index < board.size() ; index++)\\n        {\\n            if(is_Safe(board , row , index))\\n            {\\n                \\n                board[row][index] = \\'Q\\';\\n                placequeen(board , row + 1);\\n                board[row][index] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    int totalNQueens(int n) {\\n\\n         if(n <= 0)\\n            return res.size();\\n        \\n        vector<string> board(n,string(n,\\'.\\'));\\n        placequeen(board,0);\\n        \\n        return res.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // this vector keeps possible board configurations\\n vector<vector<string>> res;\\n    \\n// checks whether the position is safe for queen or not\\n    bool is_Safe(vector<string>& board , int row , int column)\\n    {\\n        for(int index = row ; index >= 0 ; index--)\\n            if(board[index][column] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex >=0 ; index-- , jindex--)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex < board.size() ; index-- , jindex++)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    // checks all possible configurations by backtracking\\n    void placequeen(vector<string>& board , int row)\\n    {\\n        if(row == board.size())\\n        {\\n            res.push_back(board);\\n            return;\\n        }\\n        \\n        for(int index = 0 ; index < board.size() ; index++)\\n        {\\n            if(is_Safe(board , row , index))\\n            {\\n                \\n                board[row][index] = \\'Q\\';\\n                placequeen(board , row + 1);\\n                board[row][index] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    int totalNQueens(int n) {\\n\\n         if(n <= 0)\\n            return res.size();\\n        \\n        vector<string> board(n,string(n,\\'.\\'));\\n        placequeen(board,0);\\n        \\n        return res.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839035,
                "title": "clean-java-solution",
                "content": "The idea is that along the diagonals, the (row, col) tuple follows the sequence (i,j), (i+1, j+1), ..., so col - row is constant for a diagonal. Similarly, along cross diagonals, (row,col) tuple follows the sequence (i,j), (i+1, j-i), (i+2, j-2), hence row+col is constant for a cross diagonal. Using this idea, a valid position can be checked in constant time\\n```\\nclass Solution {\\n        \\n    private int numSolutions = 0;\\n    public Solution() {        \\n    }\\n    public int totalNQueens(int n) { \\n        tryQueenPlacement(0, new ChessBoard(n));\\n        return numSolutions;\\n    }\\n    \\n    private void tryQueenPlacement(int i, ChessBoard board) {\\n        if(i == board.size()) {\\n            ++numSolutions;\\n            return;\\n        }\\n        for(int j = 0; j < board.size(); j++) {\\n            if(board.isValidQueenPosition(i, j)) {\\n                board.placeQueen(i, j);\\n                tryQueenPlacement(i+1, board);                                                   \\n                board.removeQueen(i, j);\\n            }                   \\n        }\\n    }\\n    \\n    class ChessBoard{\\n        private final int boardSize;\\n        private int[] cols;\\n        private int[] diagonals;\\n        private int[] crossDiagonals;\\n        ChessBoard(int n) {\\n            this.boardSize = n;            \\n            reset(n);\\n        }\\n        \\n        int size() {\\n            return boardSize;\\n        }\\n        \\n        void reset(int boardSize) {\\n            this.cols = new int[boardSize];\\n            this.diagonals = new int[2*boardSize - 1];\\n            this.crossDiagonals = new int[2*boardSize - 1];\\n        }\\n        \\n        boolean isValidQueenPosition(int i, int j) {\\n            if(cols[j] == 1 || diagonals[j-i + (boardSize - 1)] == 1 || crossDiagonals[j+i] == 1) {\\n                return false;\\n            } \\n            return true;\\n        }\\n    \\n        void placeQueen(int i, int j) {\\n            cols[j] = 1;\\n            diagonals[j-i + (boardSize - 1)] = 1;\\n            crossDiagonals[j+i] = 1;\\n        }\\n\\n        void removeQueen(int i, int j) {\\n            cols[j] = 0;\\n            diagonals[j-i + (boardSize - 1)] = 0;\\n            crossDiagonals[j+i] = 0;\\n        }                  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    private int numSolutions = 0;\\n    public Solution() {        \\n    }\\n    public int totalNQueens(int n) { \\n        tryQueenPlacement(0, new ChessBoard(n));\\n        return numSolutions;\\n    }\\n    \\n    private void tryQueenPlacement(int i, ChessBoard board) {\\n        if(i == board.size()) {\\n            ++numSolutions;\\n            return;\\n        }\\n        for(int j = 0; j < board.size(); j++) {\\n            if(board.isValidQueenPosition(i, j)) {\\n                board.placeQueen(i, j);\\n                tryQueenPlacement(i+1, board);                                                   \\n                board.removeQueen(i, j);\\n            }                   \\n        }\\n    }\\n    \\n    class ChessBoard{\\n        private final int boardSize;\\n        private int[] cols;\\n        private int[] diagonals;\\n        private int[] crossDiagonals;\\n        ChessBoard(int n) {\\n            this.boardSize = n;            \\n            reset(n);\\n        }\\n        \\n        int size() {\\n            return boardSize;\\n        }\\n        \\n        void reset(int boardSize) {\\n            this.cols = new int[boardSize];\\n            this.diagonals = new int[2*boardSize - 1];\\n            this.crossDiagonals = new int[2*boardSize - 1];\\n        }\\n        \\n        boolean isValidQueenPosition(int i, int j) {\\n            if(cols[j] == 1 || diagonals[j-i + (boardSize - 1)] == 1 || crossDiagonals[j+i] == 1) {\\n                return false;\\n            } \\n            return true;\\n        }\\n    \\n        void placeQueen(int i, int j) {\\n            cols[j] = 1;\\n            diagonals[j-i + (boardSize - 1)] = 1;\\n            crossDiagonals[j+i] = 1;\\n        }\\n\\n        void removeQueen(int i, int j) {\\n            cols[j] = 0;\\n            diagonals[j-i + (boardSize - 1)] = 0;\\n            crossDiagonals[j+i] = 0;\\n        }                  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609947,
                "title": "not-the-fastest-in-leetcode-complier-but-the-simple-and-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int cnt = 0;\\n        vector<int> curPos;\\n\\n        totalNQueens(n, curPos, &cnt);\\n\\n        return cnt;\\n    }\\n    \\n    bool isColValid(vector<int>& curPos, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (curPos[row] == curCol) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPosValid(vector<int>& curPos, int curRow, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (abs(curPos[row] - curCol) == abs(row - curRow) ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void totalNQueens(int n, vector<int>& curPos, int* cnt) {\\n        // BASE CASE\\n        if (curPos.size() == n) {\\n            *cnt += 1;\\n            return;\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            if (!isColValid(curPos, col)) continue;\\n            if (!isPosValid(curPos, curPos.size(), col)) continue;\\n            // Positions valid\\n            // and to the correct postions\\n            curPos.push_back(col);\\n            totalNQueens(n, curPos, cnt);\\n            // delete this position\\n            curPos.pop_back();\\n             \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int cnt = 0;\\n        vector<int> curPos;\\n\\n        totalNQueens(n, curPos, &cnt);\\n\\n        return cnt;\\n    }\\n    \\n    bool isColValid(vector<int>& curPos, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (curPos[row] == curCol) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPosValid(vector<int>& curPos, int curRow, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (abs(curPos[row] - curCol) == abs(row - curRow) ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void totalNQueens(int n, vector<int>& curPos, int* cnt) {\\n        // BASE CASE\\n        if (curPos.size() == n) {\\n            *cnt += 1;\\n            return;\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            if (!isColValid(curPos, col)) continue;\\n            if (!isPosValid(curPos, curPos.size(), col)) continue;\\n            // Positions valid\\n            // and to the correct postions\\n            curPos.push_back(col);\\n            totalNQueens(n, curPos, cnt);\\n            // delete this position\\n            curPos.pop_back();\\n             \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243444,
                "title": "python-solution",
                "content": "We use the backtracking algorithm. Initialize the result `res = 0`. We use three sets `cols`, `diag` and `off_diag` to keep track of the columns, diagonals, and off-diagonals that have been occupied in the current state of the board. We define a recursive `backtrack` function which counts all valid configurations of the board, and increment `res` by `1` if a configuration is valid. More specifically, `backtrack(i)` enumerates all valid positions that the queen can be put in the `i`th row. For each valid position, we add the column, diagonal and off-diagonal occupied by the position to `cols`, `diag`, and `off_diag`, respectively, and recursively call `backtrack(i+1)`, until `i == n`, in which case we know that the current state of the board represents a valid configuration of the `n` queens, and we increment `res` by `1`. Finally, we return `res`.\\n\\nTime complexity: `O(n!)`, space complexity: `O(n)`. \\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(i):\\n            if i == n:\\n                return 1\\n            res = 0\\n            for j in range(n):\\n                if j not in cols and i-j not in diag and i+j not in off_diag:\\n                    cols.add(j)\\n                    diag.add(i-j)\\n                    off_diag.add(i+j)\\n                    res += backtrack(i+1)\\n                    off_diag.remove(i+j)\\n                    diag.remove(i-j)\\n                    cols.remove(j)\\n            return res\\n       \\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        return backtrack(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(i):\\n            if i == n:\\n                return 1\\n            res = 0\\n            for j in range(n):\\n                if j not in cols and i-j not in diag and i+j not in off_diag:\\n                    cols.add(j)\\n                    diag.add(i-j)\\n                    off_diag.add(i+j)\\n                    res += backtrack(i+1)\\n                    off_diag.remove(i+j)\\n                    diag.remove(i-j)\\n                    cols.remove(j)\\n            return res\\n       \\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807847,
                "title": "c-recursive-backtracking-bitmask-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a very classical problem; ans there is no math formula known to solve it!\\n\\n2 codes are given. One uses ordinary backtracking with boolean arrays.  The other uses bimasks insteads of boolean arrays.\\n\\nThe code solves the N-Queens problem by recursively placing queens on a chessboard. It uses backtracking and checks for valid positions to avoid conflicts. The solutions are stored in a vector and returned. The code initializes the chessboard, sets flags for occupied columns, diagonals, and anti-diagonals, and finds all valid solutions using a recursive function. \\n\\nSimilar question:\\n[51. N-Queens\\n](https://leetcode.com/problems/n-queens/solutions/3713298/c-recursive-backtracking-bool-vector-vs-bitmask-beasts-100/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)\\n\\n```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\\nvectors col, antidiag, and diag are used as boolean flags to keep track of occupied columns, anti-diagonals, and diagonals, respectively.\\n\\nHere\\'s a breakdown of each vector\\'s purpose:\\n\\ncol: This vector represents the occupied columns on the chessboard. Each element in the vector corresponds to a column on the board. If col[j] is true, it means that column j is already occupied by a queen. Otherwise, if col[j] is false, the column is available for placing a queen.\\n\\nantidiag: This vector represents the occupied anti-diagonals on the chessboard. An anti-diagonal is a diagonal line that runs from the top-right to the bottom-left of the chessboard. The length of the anti-diagonals is 2*n - 1, where n is the number of rows/columns. Each element in the vector corresponds to an anti-diagonal on the board. If antidiag[i+j] is true, it means that the anti-diagonal i+j is already occupied by a queen. If antidiag[i+j] is false, the anti-diagonal is available for placing a queen.\\n\\ndiag: This vector represents the occupied diagonals on the chessboard. A diagonal is a line that runs from the top-left to the bottom-right of the chessboard. Similar to the antidiag vector, the length of the diagonals is also 2*n - 1. Each element in the vector corresponds to a diagonal on the board. If diag[i+n-j-1] is true, it means that the diagonal i-j is already occupied by a queen (Note that i-j may be negative, shifting it to i+n-j-1 to ensure be non-negative ). If diag[i+n-j-1] is false, the diagonal is available for placing a queen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n!)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> col, diag, antidiag;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) {\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true;\\n                num+=find_sol(i+1, n);\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false;\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col.assign(n, false);\\n        diag.assign(2*n-1, false);\\n        antidiag.assign(2*n-1, false);\\n        return find_sol(0, n);\\n    }\\n};\\n\\n```\\n# Code using Bit Mask\\n```\\nclass Solution {\\npublic:\\n    int col_mask, diag_mask, anti_diag_mask;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0) \\n            {\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                num+=find_sol(i+1, n);\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        return find_sol(0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<bool> col, diag, antidiag;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) {\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true;\\n                num+=find_sol(i+1, n);\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false;\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col.assign(n, false);\\n        diag.assign(2*n-1, false);\\n        antidiag.assign(2*n-1, false);\\n        return find_sol(0, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int col_mask, diag_mask, anti_diag_mask;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0) \\n            {\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                num+=find_sol(i+1, n);\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        return find_sol(0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479663,
                "title": "fast-clean-concise-c-solution-easy-to-understand-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, res = 0;\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t\\t// count all the possible answers\\n            res++;\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    int totalNQueens(int num) {\\n        n = num;\\n\\t\\t// initializing vector with \".......n\"\\n        vector<string> ans(n);\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, res = 0;\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t\\t// count all the possible answers\\n            res++;\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    int totalNQueens(int num) {\\n        n = num;\\n\\t\\t// initializing vector with \".......n\"\\n        vector<string> ans(n);\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113635,
                "title": "c-backtracking-w-shifting-bits-and-a-cheat-version",
                "content": "For backtracking we can use 3 integers as bitmasks. We only need to shift them for the main and anti diagonal.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        return bt(n, 0, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    int bt(int n, int idx, int same, int main, int anti) {\\n        if (idx == n) return 1;\\n       \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t    const int mask = 1 << i;\\n            if (same & mask) continue;\\n            if (main & mask) continue;\\n            if (anti & mask) continue;\\n            \\n            ans += bt(n, idx + 1, same | mask, (main | mask) << 1, (anti | mask) >> 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nSince the results never change and only depend on ```n``` we could even do something like:\\n\\n```\\n    int totalNQueens(int n) {\\n        static const int ans[] = {0, 1, 0, 0, 2, 10, 4, 40, 92, 352};\\n        return ans[n];\\n    }\\n```\\n\\nWhich is likley considered cheating. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        return bt(n, 0, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    int bt(int n, int idx, int same, int main, int anti) {\\n        if (idx == n) return 1;\\n       \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t    const int mask = 1 << i;\\n            if (same & mask) continue;\\n            if (main & mask) continue;\\n            if (anti & mask) continue;\\n            \\n            ans += bt(n, idx + 1, same | mask, (main | mask) << 1, (anti | mask) >> 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```n```\n```\\n    int totalNQueens(int n) {\\n        static const int ans[] = {0, 1, 0, 0, 2, 10, 4, 40, 92, 352};\\n        return ans[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113550,
                "title": "simple-java-solution",
                "content": "```\\npublic class Solution {\\n    int s=0;\\n    public int totalNQueens(int n) {\\n        boolean[] k=new boolean[n];\\n        boolean[] p= new boolean[2*n-1];\\n        boolean[] a=new boolean[2*n-1];\\n        task(0, n,k,p,a);\\n        return s;\\n    }\\n    public void task(int x, int n, boolean[] k, boolean[] p, boolean[] a) {\\n        if (x==n) {\\n            s++;\\n            return;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            if(!k[i]&&!p[i+x]&&!a[n-1-x+i]) \\n            {\\n                k[i]=p[i+x]=a[n-1-x+i]=true;\\n                task(x+1,n,k,p,a);\\n                k[i]=p[i+x]=a[n-1-x+i]=false;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    int s=0;\\n    public int totalNQueens(int n) {\\n        boolean[] k=new boolean[n];\\n        boolean[] p= new boolean[2*n-1];\\n        boolean[] a=new boolean[2*n-1];\\n        task(0, n,k,p,a);\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2113344,
                "title": "accepted-c-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int queencount = 0;// to keep the total count\\n    bool isItSafe(vector<vector<bool> > &grid,int row,int col,int n) \\n\\t{\\n\\t\\tfor(int i=row-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][col]) return false;\\n\\t\\t}\\n\\t\\tfor(int i=row-1,j=col-1;i>=0 and j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j]) return false;\\n\\t\\t}\\n\\t\\tfor(int i=row-1,j=col+1;i>=0 and j<n;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j]) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\n   \\n\\tvoid countNQueen(vector<vector<bool> > &grid, int curr_row, int n){\\n\\t\\tif(curr_row == n){ // We found a solution so we increment our count\\n\\t\\t\\tqueencount++;\\n\\t\\t\\t// display(grid,n);\\n\\t\\t\\t// cout<<\"\\\\n\\\\n\";\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(isItSafe(grid,curr_row,i,n)){\\n\\t\\t\\t\\tgrid[curr_row][i] = true;\\n\\t\\t\\t\\tcountNQueen(grid,curr_row+1,n);\\n\\t\\t\\t\\tgrid[curr_row][i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n    int totalNQueens(int n) {\\n        vector<vector<bool> > grid(n, vector<bool>(n,false));\\n   \\n         countNQueen(grid,0,n); \\n        return queencount;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int queencount = 0;// to keep the total count\\n    bool isItSafe(vector<vector<bool> > &grid,int row,int col,int n) \\n\\t{\\n\\t\\tfor(int i=row-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][col]) return false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2113275,
                "title": "c-use-recursion-and-backtracking-explanation-through-comments-dlc-june-day-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) \\n    {\\n        int ans=0;                 //ans counts toatal no. of possible orders \\n        vector<string> board(n);   // create the board of n rows \\n        string s(n,\\'.\\');           // define column of the board size n=4 i.e. \"....\" \\n        \\n        for(int i=0;i<n;i++)       // define whole board as a empty string\\n        {\\n            board[i]=s;            //[\"....\",\"....\",\"....\",\"....\"]\\n        }\\n        \\n        // we are moving from left to right\\n        // so we need to check only left part of the current cell because all the cells after current cell (right part) will surely empty\\n        // we also can not check for upper and lower direction for current cell because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> leftrow(n,0);                      // maintaining an array left that will tell which row has already taken for placing queen\\n        vector<int> upperdiagonal(2*n-1,0);          // maintaiing an array upperdiagonal that will tell which upperdiagonal has already taken\\n        vector<int> lowerdiagonal(2*n-1,0);          // maintaiing an array lowerdiagonal that will tell which lowerdiagonal has already taken\\n        \\n        solve(0, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n        return ans;   \\n    }\\n    \\n    void solve(int col, vector<string> &board, int &ans, \\n               vector<int> &leftrow, vector<int> &lowerdiagonal, \\n               vector<int> &upperdiagonal, int n)\\n    {\\n        //when all columns are covered, we increase the count and return\\n        if(col == n) \\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++)\\n        {\\n            //condition for checking collision, if all satisfy means there is no collision\\n            if(leftrow[row]==0 && lowerdiagonal[row+col]==0 && \\n               upperdiagonal[n-1+row-col]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                leftrow[row]=1;\\n                lowerdiagonal[row+col]=1;\\n                upperdiagonal[n-1+row-col]=1;\\n                solve(col+1, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n                //backtracking\\n                board[row][col] = \\'.\\'; \\n                leftrow[row]=0;\\n                lowerdiagonal[row+col]=0;\\n                upperdiagonal[n-1+row-col]=0;\\n            }\\n        }\\n    }     \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) \\n    {\\n        int ans=0;                 //ans counts toatal no. of possible orders \\n        vector<string> board(n);   // create the board of n rows \\n        string s(n,\\'.\\');           // define column of the board size n=4 i.e. \"....\" \\n        \\n        for(int i=0;i<n;i++)       // define whole board as a empty string\\n        {\\n            board[i]=s;            //[\"....\",\"....\",\"....\",\"....\"]\\n        }\\n        \\n        // we are moving from left to right\\n        // so we need to check only left part of the current cell because all the cells after current cell (right part) will surely empty\\n        // we also can not check for upper and lower direction for current cell because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> leftrow(n,0);                      // maintaining an array left that will tell which row has already taken for placing queen\\n        vector<int> upperdiagonal(2*n-1,0);          // maintaiing an array upperdiagonal that will tell which upperdiagonal has already taken\\n        vector<int> lowerdiagonal(2*n-1,0);          // maintaiing an array lowerdiagonal that will tell which lowerdiagonal has already taken\\n        \\n        solve(0, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n        return ans;   \\n    }\\n    \\n    void solve(int col, vector<string> &board, int &ans, \\n               vector<int> &leftrow, vector<int> &lowerdiagonal, \\n               vector<int> &upperdiagonal, int n)\\n    {\\n        //when all columns are covered, we increase the count and return\\n        if(col == n) \\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++)\\n        {\\n            //condition for checking collision, if all satisfy means there is no collision\\n            if(leftrow[row]==0 && lowerdiagonal[row+col]==0 && \\n               upperdiagonal[n-1+row-col]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                leftrow[row]=1;\\n                lowerdiagonal[row+col]=1;\\n                upperdiagonal[n-1+row-col]=1;\\n                solve(col+1, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n                //backtracking\\n                board[row][col] = \\'.\\'; \\n                leftrow[row]=0;\\n                lowerdiagonal[row+col]=0;\\n                upperdiagonal[n-1+row-col]=0;\\n            }\\n        }\\n    }     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800718,
                "title": "c-backtracking-beginner-friendly-solution-w-comments",
                "content": "DO \\u2B06\\uFE0FUPVOTE IF IT WAS HELPFUL\\t\\n\\t\\n\\tclass Solution {\\n\\t\\t// vector<vector<string>> ans;\\n\\t\\tint count=0;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check\\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check left side\\n\\t\\t\\tint row=r,col=c;\\n\\t\\t\\twhile(row>=0 && col>=0){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col--;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check right side\\n\\t\\t\\trow=r,col=c;\\n\\t\\t\\twhile(row>=0 && col<n){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid helper(int r,vector<string> &v,int n){\\n\\t\\t\\t if(r==n){\\n\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t return ;\\n\\t\\t\\t }\\n\\t\\t\\tfor(int i=0;i<n;i++){ //fixing row and checking for column(each row can have only one queen)\\n\\t\\t\\t\\tif(issafe(r,i,v,n)){\\n\\t\\t\\t\\t\\tv[r][i]=\\'Q\\';\\n\\t\\t\\t\\t\\thelper(r+1,v,n);\\n\\t\\t\\t\\t\\tv[r][i]=\\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint totalNQueens(int n) {\\n\\t\\t\\tvector<string> v;\\n\\t\\t\\tstring s(n,\\'.\\');\\n\\t\\t\\tfor(int i=0;i<n;i++) v.push_back(s);\\n\\t\\t\\thelper(0,v,n);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\t// vector<vector<string>> ans;\\n\\t\\tint count=0;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check\\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1138289,
                "title": "c-easy-clean-code-explained-with-comments-backtracking",
                "content": "***Generally we see that part 2 of any variant is a modification of part 1. But, here part is relatively simple as we have to only count the valid configurations of placing N Queens on an \"n x n\" board. So, here we go through the solution.***\\n\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    bool isValid(int matrix[][9],int row,int col,int n) {\\n        \\n        // col check\\n        for(int r=0;r<row;r++) { \\n            if(matrix[r][col]==1) return false;\\n        }\\n        \\n        // left diagonal\\n        int i=row,j=col;\\n        while(i>=0 && j>=0) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j--;\\n        }\\n        // right diagonal \\n        i=row,j=col;\\n        while(i>=0 && j<n) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j++;\\n        }\\n\\n        return true;\\n    }\\n    \\n    void solve(int matrix[][9],int row,int n){\\n       // if in all the rows queens are placed, that means we have reached the end, print the board \\n        if(row==n) { \\n            count++;\\n            return;\\n        }\\n      //  bool nextQueen=false; // \"assuming that next Queen\\'s placement is not decided YET\"\\n        for(int col=0;col<n;col++) { // moving into all the columns of \"row\" \\n            if(isValid(matrix,row,col,n)) { \\n               \\n                matrix[row][col] = 1; // if yes, mark it as 1\\n // now looking for next Queen\\'s placement, moving to the next row and calling this func Recursively.\\n                solve(matrix,row+1,n);\\n                matrix[row][col]=0; \\n//THIS IS WHERE ALL THE BACKTRACKING IS HAPPENING. IF WE GOT nextQueen as false, we will BACKTRACK BY SETTING THE CURRRENT POSITION TO 0 AGAIN, WE ARE LITERALLY MOVING \"BACK\" AND WILL LOOK FOR ANY OTHER LOCATION FOR THE PLACEMENT OF THE QUEEN\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        int matrix[9][9]={0}; // creating an 2d array of 9X9 since that is the max limit\\n        solve(matrix,0,n); // solve(matrix,starting row,max rows)\\n        return count;\\n    }\\n};\\n```\\n\\n# HAPPY CODING. PLEASE UPVOTE :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    bool isValid(int matrix[][9],int row,int col,int n) {\\n        \\n        // col check\\n        for(int r=0;r<row;r++) { \\n            if(matrix[r][col]==1) return false;\\n        }\\n        \\n        // left diagonal\\n        int i=row,j=col;\\n        while(i>=0 && j>=0) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j--;\\n        }\\n        // right diagonal \\n        i=row,j=col;\\n        while(i>=0 && j<n) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j++;\\n        }\\n\\n        return true;\\n    }\\n    \\n    void solve(int matrix[][9],int row,int n){\\n       // if in all the rows queens are placed, that means we have reached the end, print the board \\n        if(row==n) { \\n            count++;\\n            return;\\n        }\\n      //  bool nextQueen=false; // \"assuming that next Queen\\'s placement is not decided YET\"\\n        for(int col=0;col<n;col++) { // moving into all the columns of \"row\" \\n            if(isValid(matrix,row,col,n)) { \\n               \\n                matrix[row][col] = 1; // if yes, mark it as 1\\n // now looking for next Queen\\'s placement, moving to the next row and calling this func Recursively.\\n                solve(matrix,row+1,n);\\n                matrix[row][col]=0; \\n//THIS IS WHERE ALL THE BACKTRACKING IS HAPPENING. IF WE GOT nextQueen as false, we will BACKTRACK BY SETTING THE CURRRENT POSITION TO 0 AGAIN, WE ARE LITERALLY MOVING \"BACK\" AND WILL LOOK FOR ANY OTHER LOCATION FOR THE PLACEMENT OF THE QUEEN\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        int matrix[9][9]={0}; // creating an 2d array of 9X9 since that is the max limit\\n        solve(matrix,0,n); // solve(matrix,starting row,max rows)\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861345,
                "title": "python3-backtracking-solution-with-detailed-comments-explanation",
                "content": "```py\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        # We only need three arrays; one for rows and two for left & right diagonals.\\n        # Since there can be only 1 queen in a row, col, & diagonals, we don\\'t need to consider\\n        # every cell/square on the board. We can just iterate over the columns.\\n        # We can use specific places in these arrays to mark off ENTIRE rows, columns, and diagonals,\\n        # since placing a queen makes the row, col, and diagonals its in invalid for placing any others.\\n        # The rows array takes care of marking off both the current row & column.\\n        # Ex. rows[2] marks off the entire third column, and the entire current row.\\n        \\n        rows = [0] * n         # There are n columns\\n        hills = [0] * (2*n-1)  # number of right diagonals (draw a board and count diagonals to verify)\\n        slopes = [0] * (2*n-1) # number of left diagonals\\n        \\n        # When placing a queen, also mark the row, column, and diagonals it attacks, since\\n        # we can\\'t place any other queens in those paths.\\n        # A queen\\'s right diagonal (hill) is: row - column.\\n        # A queen\\'s left diagonal (slope) is: row + column.\\n        def place_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 1\\n            hills[right_diag] = 1\\n            slopes[left_diag] = 1\\n            \\n        # For removing a queen, it\\'s much the same process: Unmark the row, column, and diagonals,\\n        # since removing a queen means they are no longer under attack.\\n        def remove_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 0\\n            hills[right_diag] = 0\\n            slopes[left_diag] = 0\\n        \\n        def not_under_attack(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            # In python, 0 is False and 1 is True.\\n            # So if we have rows[0] = 0, the boolean value of rows[0] is False, and not(rows[0]) returns True.\\n            # This is a simple check to see if all three of these spots contain 1\\'s or not.\\n            return not(rows[col] or hills[right_diag] or slopes[left_diag])\\n        \\n        # Start searching from the point (0,0).\\n        # (Saying row = 0, count = 0 in the function arguments is just the default value, if the function\\n        # gets called with nothing passed in. If the function DOES get called with values passed in,\\n        # the 0\\'s get overriden, and you\\'d be working with a different row & count).\\n        # Place a queen on the first open spot you find, check if the number of filled spots equals n,\\n        # and if it does, increase the total count of valid solutions.\\n        # The else clause here is what does the actual backtracking: it places a queen, calls the function again\\n        # and again with a new spot in the board, until we don\\'t hit the else clause anymore, at which point we\\n        # remove the queen at the new row, col, and resume our search by continuing the for loop.\\n        # Notice how row gets incremented each time the backtrack function gets called recursively.\\n        def backtrack(row = 0, count = 0):\\n            for col in range(n):\\n                if not_under_attack(row, col):\\n                    place_queen(row, col)\\n                    \\n                    if row+1 == n:\\n                        count += 1\\n                    else:\\n                        count = backtrack(row+1, count)\\n                        \\n                    remove_queen(row, col)\\n                    \\n            return count```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        # We only need three arrays; one for rows and two for left & right diagonals.\\n        # Since there can be only 1 queen in a row, col, & diagonals, we don\\'t need to consider\\n        # every cell/square on the board. We can just iterate over the columns.\\n        # We can use specific places in these arrays to mark off ENTIRE rows, columns, and diagonals,\\n        # since placing a queen makes the row, col, and diagonals its in invalid for placing any others.\\n        # The rows array takes care of marking off both the current row & column.\\n        # Ex. rows[2] marks off the entire third column, and the entire current row.\\n        \\n        rows = [0] * n         # There are n columns\\n        hills = [0] * (2*n-1)  # number of right diagonals (draw a board and count diagonals to verify)\\n        slopes = [0] * (2*n-1) # number of left diagonals\\n        \\n        # When placing a queen, also mark the row, column, and diagonals it attacks, since\\n        # we can\\'t place any other queens in those paths.\\n        # A queen\\'s right diagonal (hill) is: row - column.\\n        # A queen\\'s left diagonal (slope) is: row + column.\\n        def place_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 1\\n            hills[right_diag] = 1\\n            slopes[left_diag] = 1\\n            \\n        # For removing a queen, it\\'s much the same process: Unmark the row, column, and diagonals,\\n        # since removing a queen means they are no longer under attack.\\n        def remove_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 0\\n            hills[right_diag] = 0\\n            slopes[left_diag] = 0\\n        \\n        def not_under_attack(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            # In python, 0 is False and 1 is True.\\n            # So if we have rows[0] = 0, the boolean value of rows[0] is False, and not(rows[0]) returns True.\\n            # This is a simple check to see if all three of these spots contain 1\\'s or not.\\n            return not(rows[col] or hills[right_diag] or slopes[left_diag])\\n        \\n        # Start searching from the point (0,0).\\n        # (Saying row = 0, count = 0 in the function arguments is just the default value, if the function\\n        # gets called with nothing passed in. If the function DOES get called with values passed in,\\n        # the 0\\'s get overriden, and you\\'d be working with a different row & count).\\n        # Place a queen on the first open spot you find, check if the number of filled spots equals n,\\n        # and if it does, increase the total count of valid solutions.\\n        # The else clause here is what does the actual backtracking: it places a queen, calls the function again\\n        # and again with a new spot in the board, until we don\\'t hit the else clause anymore, at which point we\\n        # remove the queen at the new row, col, and resume our search by continuing the for loop.\\n        # Notice how row gets incremented each time the backtrack function gets called recursively.\\n        def backtrack(row = 0, count = 0):\\n            for col in range(n):\\n                if not_under_attack(row, col):\\n                    place_queen(row, col)\\n                    \\n                    if row+1 == n:\\n                        count += 1\\n                    else:\\n                        count = backtrack(row+1, count)\\n                        \\n                    remove_queen(row, col)\\n                    \\n            return count```",
                "codeTag": "Java"
            },
            {
                "id": 810361,
                "title": "c-4ms-heavily-commented-solution-clean-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            cnt++;\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n\\t\\t// return 0 if n <= 0\\n        if(n <= 0) return 0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            cnt++;\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n\\t\\t// return 0 if n <= 0\\n        if(n <= 0) return 0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472966,
                "title": "c-backtracking",
                "content": "For explanation: https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/\\n\\n```\\nint totalNQueens(int n) {\\n    vector<int> row(n,0);\\n    vector<vector<int>> board(n, row); // board is n x n filled with 0\\'s (safe)\\n    return backtrackNQueens(board, n, 0, 0);\\n}\\n\\nint backtrackNQueens(vector<vector<int>> &board, int n, int row, int count){\\n    for(int col = 0; col < n; col++){\\n        if(board[row][col] == 0){ // 0 is safe\\n            vector<vector<int>> prevBoard = board; // this is where we will backtrack to\\n            placeQueen(board, n, row, col);\\n            if(row == n-1){\\n                count++;\\n            } else {\\n                count = backtrackNQueens(board, n, row + 1, count);\\n            }\\n            board = prevBoard; // backtrack the last queen\\n        } \\n    }\\n    return count;\\n}\\n\\nvoid placeQueen(vector<vector<int>> &board, int n, int row, int col){\\n    for(int i = 0; i < n; i++){\\n        board[i][col] = 1; // fill vertically\\n        board[row][i] = 1; // fill horizontally \\n        int j = row + col - i; // fill the NE diagonal \\n        if(j >=0 && j < n){\\n            board[i][j] = 1;\\n        }\\n        int k = row - col + i; // fill the SE diagonal\\n        if(k >=0 && k < n){\\n            board[k][i] = 1;\\n        } \\n    }\\n}   \\n```",
                "solutionTags": [],
                "code": "```\\nint totalNQueens(int n) {\\n    vector<int> row(n,0);\\n    vector<vector<int>> board(n, row); // board is n x n filled with 0\\'s (safe)\\n    return backtrackNQueens(board, n, 0, 0);\\n}\\n\\nint backtrackNQueens(vector<vector<int>> &board, int n, int row, int count){\\n    for(int col = 0; col < n; col++){\\n        if(board[row][col] == 0){ // 0 is safe\\n            vector<vector<int>> prevBoard = board; // this is where we will backtrack to\\n            placeQueen(board, n, row, col);\\n            if(row == n-1){\\n                count++;\\n            } else {\\n                count = backtrackNQueens(board, n, row + 1, count);\\n            }\\n            board = prevBoard; // backtrack the last queen\\n        } \\n    }\\n    return count;\\n}\\n\\nvoid placeQueen(vector<vector<int>> &board, int n, int row, int col){\\n    for(int i = 0; i < n; i++){\\n        board[i][col] = 1; // fill vertically\\n        board[row][i] = 1; // fill horizontally \\n        int j = row + col - i; // fill the NE diagonal \\n        if(j >=0 && j < n){\\n            board[i][j] = 1;\\n        }\\n        int k = row - col + i; // fill the SE diagonal\\n        if(k >=0 && k < n){\\n            board[k][i] = 1;\\n        } \\n    }\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374660,
                "title": "very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        int[] queue = new int[n];\\n        backtrack(0,queue,n);\\n        return count;\\n    }\\n    \\n    private void backtrack(int row,int[] queue,int n){\\n        if(row==n){\\n            count++;\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(isOk(row,i,queue)){\\n                    queue[row]=i;\\n                    backtrack(row+1,queue,n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isOk(int row,int col,int[] queue){\\n        int leftup=col-1,rightup=col+1;\\n        int n=queue.length;\\n        for(int i=row-1;i>=0;i--){\\n            if(queue[i]==col) return false;\\n            if(leftup>=0&&queue[i]==leftup) return false;\\n            if(rightup<n&&queue[i]==rightup) return false;\\n            leftup--;rightup++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        int[] queue = new int[n];\\n        backtrack(0,queue,n);\\n        return count;\\n    }\\n    \\n    private void backtrack(int row,int[] queue,int n){\\n        if(row==n){\\n            count++;\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(isOk(row,i,queue)){\\n                    queue[row]=i;\\n                    backtrack(row+1,queue,n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isOk(int row,int col,int[] queue){\\n        int leftup=col-1,rightup=col+1;\\n        int n=queue.length;\\n        for(int i=row-1;i>=0;i--){\\n            if(queue[i]==col) return false;\\n            if(leftup>=0&&queue[i]==leftup) return false;\\n            if(rightup<n&&queue[i]==rightup) return false;\\n            leftup--;rightup++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20133,
                "title": "easy-java-python-recursive-iterative-backtracking-solutions",
                "content": "For detail explanation see n-queens [solution][1]\\n\\n**Java recursive**\\n\\n    private int bt(boolean[] c, boolean[] f, boolean[] b, int row, int n) {\\n        if (row == n) return 1;\\n        int ans = 0;\\n        for (int col = 0; col < n; ++col) {\\n            int i = col + row, j = col - row + n;\\n            if (c[col] || f[i] || b[j]) continue;\\n            c[col] = f[i] = b[j] = true;\\n            ans += bt(c, f, b, row + 1, n);\\n            c[col] = f[i] = b[j] = false;\\n        }\\n        return ans;\\n    }\\n\\n    public int totalNQueens(int n) {\\n        return bt(new boolean[n], new boolean[2 * n], new boolean[2 * n], 0, n);\\n    }\\n\\n    // Runtime: 2ms\\n\\n**Java Iterative**\\n\\n    public int totalNQueens(int n) {\\n        int ans = 0;\\n        int[] queens = new int[n];\\n        boolean[] c = new boolean[n + 1];\\n        boolean[] f = new boolean[2 * n];\\n        boolean[] b = new boolean[2 * n];\\n        c[n] = true; //dummy boundary\\n        int col = 0, row = 0;\\n        while (true) {\\n            if (c[col] || f[col + row] || b[col - row + n]) {\\n                if (row == n || col == n) {\\n                    if (row == 0) return ans;\\n                    if (row == n) ans++;\\n                    col = queens[--row];\\n                    c[col] = f[col + row] = b[col - row + n] = false;\\n                }\\n                col++;\\n            } else {\\n                c[col] = f[col + row] = b[col - row + n] = true;\\n                queens[row++] = col;\\n                col = 0;\\n            }\\n        }\\n    }\\n    // Runtime: 4ms\\n\\n**Python iterative**\\n\\n    def totalNQueens(self, n):\\n        row = col = ans = 0\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n            else:\\n                if row == n or col == n:\\n                    if row == n:\\n                        ans += 1\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n    # Runtime: 60 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/63710/ac-python-76-ms-iterative-backtracking-solution",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "For detail explanation see n-queens [solution][1]\\n\\n**Java recursive**\\n\\n    private int bt(boolean[] c, boolean[] f, boolean[] b, int row, int n) {\\n        if (row == n) return 1;\\n        int ans = 0;\\n        for (int col = 0; col < n; ++col) {\\n            int i = col + row, j = col - row + n;\\n            if (c[col] || f[i] || b[j]) continue;\\n            c[col] = f[i] = b[j] = true;\\n            ans += bt(c, f, b, row + 1, n);\\n            c[col] = f[i] = b[j] = false;\\n        }\\n        return ans;\\n    }\\n\\n    public int totalNQueens(int n) {\\n        return bt(new boolean[n], new boolean[2 * n], new boolean[2 * n], 0, n);\\n    }\\n\\n    // Runtime: 2ms\\n\\n**Java Iterative**\\n\\n    public int totalNQueens(int n) {\\n        int ans = 0;\\n        int[] queens = new int[n];\\n        boolean[] c = new boolean[n + 1];\\n        boolean[] f = new boolean[2 * n];\\n        boolean[] b = new boolean[2 * n];\\n        c[n] = true; //dummy boundary\\n        int col = 0, row = 0;\\n        while (true) {\\n            if (c[col] || f[col + row] || b[col - row + n]) {\\n                if (row == n || col == n) {\\n                    if (row == 0) return ans;\\n                    if (row == n) ans++;\\n                    col = queens[--row];\\n                    c[col] = f[col + row] = b[col - row + n] = false;\\n                }\\n                col++;\\n            } else {\\n                c[col] = f[col + row] = b[col - row + n] = true;\\n                queens[row++] = col;\\n                col = 0;\\n            }\\n        }\\n    }\\n    // Runtime: 4ms\\n\\n**Python iterative**\\n\\n    def totalNQueens(self, n):\\n        row = col = ans = 0\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n            else:\\n                if row == n or col == n:\\n                    if row == n:\\n                        ans += 1\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n    # Runtime: 60 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/63710/ac-python-76-ms-iterative-backtracking-solution",
                "codeTag": "Python3"
            },
            {
                "id": 20131,
                "title": "pretty-simple-java-solution",
                "content": " In this problem, no need to keep track of the board content, just pay attention to column, diagonal.\\n   \\n    public class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n\\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n        \\n    }\\n      public void helper(int[] res, int n, int row){\\n        if(row==n){\\n            res[0]++;\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                if(col.contains(i) || diag1.contains(i+row) || diag2.contains(row-i)) continue;\\n                else{\\n                    col.add(i);\\n                    diag1.add(i+row);\\n                    diag2.add(row-i);\\n                    helper(res,n,row+1);\\n                    col.remove(i);\\n                    diag1.remove(i+row);\\n                    diag2.remove(row-i);\\n                }\\n             }\\n          }\\n       }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n\\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20164,
                "title": "my-concise-dfs-c-solution-using-three-unordered-map-int-bool",
                "content": "    class Solution {\\n    public:\\n        unordered_map<int, bool> column, obliqueLeft, obliqueRight;\\n        int total;\\n        void NQueensHelper(int row, int n) {\\n            if (row == n+1) {\\n                total++;\\n                return;\\n            }\\n            for (int i = 1; i <= n; i++) {\\n                if (!column[i] && !obliqueLeft[i + row] && !obliqueRight[i - row]) {\\n                    column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true;\\n                    NQueensHelper(row+1, n);\\n                    column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false;\\n                }\\n            }\\n        }\\n        int totalNQueens(int n) {\\n            column.clear();\\n            obliqueLeft.clear();\\n            obliqueRight.clear();\\n            total = 0;\\n            NQueensHelper(1, n);\\n            return total;\\n        }\\n    };\\n\\nEach unordered_map represents whether column/left oblique line/right oblique line is occupied before.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        unordered_map<int, bool> column, obliqueLeft, obliqueRight;\\n        int total;\\n        void NQueensHelper(int row, int n) {\\n            if (row == n+1) {\\n                total++;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4018184,
                "title": "cpp-easy-to-understand-backtracking-solution-with-line-by-line-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x; // A counter to keep track of the total number of solutions.\\n\\n    int totalNQueens(int n) {\\n        vector<string> temp(n, string(n, \\'.\\')); // Create an empty NxN chessboard represented by a vector of strings.\\n        helper(temp, 0, 0, n); // Start the recursive process to find solutions.\\n        return x; // Return the total number of solutions.\\n    }\\n\\n    void helper(vector<string>& temp, int row, int column, int n) {\\n        if (row == n) {\\n            x++; // If a valid solution is found, increment the solution counter.\\n            return;\\n        }\\n\\n        while (column < n) {\\n            if (isvalid(temp, row, column, n)) {\\n                temp[row][column] = \\'Q\\'; // Place a queen at the current position.\\n                helper(temp, row + 1, 0, n); // Recursively try to place queens in the next row.\\n                temp[row][column] = \\'.\\'; // Backtrack by removing the queen from the current position.\\n            }\\n            column++;\\n        }\\n    }\\n\\n    bool isvalid(vector<string>& temp, int row, int col, int n) {\\n        // Check if it\\'s valid to place a queen at the current position without conflicts.\\n        for (int i = 0; i < row; i++) {\\n            if (temp[i][col] == \\'Q\\') {\\n                return false; // Check for conflicts in the same column.\\n            }\\n        }\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-left diagonal.\\n            }\\n        }\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-right diagonal.\\n            }\\n        }\\n        return true; // No conflicts found, it\\'s a valid placement.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x; // A counter to keep track of the total number of solutions.\\n\\n    int totalNQueens(int n) {\\n        vector<string> temp(n, string(n, \\'.\\')); // Create an empty NxN chessboard represented by a vector of strings.\\n        helper(temp, 0, 0, n); // Start the recursive process to find solutions.\\n        return x; // Return the total number of solutions.\\n    }\\n\\n    void helper(vector<string>& temp, int row, int column, int n) {\\n        if (row == n) {\\n            x++; // If a valid solution is found, increment the solution counter.\\n            return;\\n        }\\n\\n        while (column < n) {\\n            if (isvalid(temp, row, column, n)) {\\n                temp[row][column] = \\'Q\\'; // Place a queen at the current position.\\n                helper(temp, row + 1, 0, n); // Recursively try to place queens in the next row.\\n                temp[row][column] = \\'.\\'; // Backtrack by removing the queen from the current position.\\n            }\\n            column++;\\n        }\\n    }\\n\\n    bool isvalid(vector<string>& temp, int row, int col, int n) {\\n        // Check if it\\'s valid to place a queen at the current position without conflicts.\\n        for (int i = 0; i < row; i++) {\\n            if (temp[i][col] == \\'Q\\') {\\n                return false; // Check for conflicts in the same column.\\n            }\\n        }\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-left diagonal.\\n            }\\n        }\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-right diagonal.\\n            }\\n        }\\n        return true; // No conflicts found, it\\'s a valid placement.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839385,
                "title": "juggad-solution-beats-100-please-see-once-easiest-and-funniest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2||n==3)\\n        return 0;\\n        if(n==4)\\n        return 2;\\n        if(n==5)\\n        return 10;\\n        if(n==6)\\n        return 4;\\n        if(n==7)\\n        return 40;\\n        if(n==8)\\n        return 92;\\n        return 352;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2||n==3)\\n        return 0;\\n        if(n==4)\\n        return 2;\\n        if(n==5)\\n        return 10;\\n        if(n==6)\\n        return 4;\\n        if(n==7)\\n        return 40;\\n        if(n==8)\\n        return 92;\\n        return 352;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553872,
                "title": "swift-tc-100-sc-100-backtracking-bit-manipulation",
                "content": "\\n# Approach\\nHere we use bit manipulation technique to keep track of visited nodes instead of using **sets**. Thus, improved TC and SC. But SC is still $$O(n)$$ due to the recursion call stack.\\n\\n# Complexity\\n- Time complexity: $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        func backtrack(_ row: Int, _ cols: Int, _ diagonals: Int, _ antidiagonals: Int) -> Int {\\n            if row == n { return 1 }\\n\\n            var solution = 0\\n            for col in 0..<n {\\n                let currentDiagonal = 1 << (row - col + n)\\n                let currentAntiDiagonal = 1 << (row + col)\\n                let currCol = 1 << col\\n\\n                if  (cols & currCol) != 0 || \\n                    (diagonals & currentDiagonal) != 0 || \\n                    (antidiagonals & currentAntiDiagonal) != 0 { \\n                        continue \\n                }\\n                var cols = cols, diagonals = diagonals, antidiagonals = antidiagonals\\n                cols ^= currCol\\n                diagonals ^= currentDiagonal\\n                antidiagonals ^= currentAntiDiagonal\\n\\n                solution += backtrack(row + 1, cols, diagonals, antidiagonals)\\n            }\\n            return solution\\n        }\\n\\n        return backtrack(0, 0, 0, 0)\\n    }\\n}\\n```\\n\\n> ***Please upvote if you like it***",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        func backtrack(_ row: Int, _ cols: Int, _ diagonals: Int, _ antidiagonals: Int) -> Int {\\n            if row == n { return 1 }\\n\\n            var solution = 0\\n            for col in 0..<n {\\n                let currentDiagonal = 1 << (row - col + n)\\n                let currentAntiDiagonal = 1 << (row + col)\\n                let currCol = 1 << col\\n\\n                if  (cols & currCol) != 0 || \\n                    (diagonals & currentDiagonal) != 0 || \\n                    (antidiagonals & currentAntiDiagonal) != 0 { \\n                        continue \\n                }\\n                var cols = cols, diagonals = diagonals, antidiagonals = antidiagonals\\n                cols ^= currCol\\n                diagonals ^= currentDiagonal\\n                antidiagonals ^= currentAntiDiagonal\\n\\n                solution += backtrack(row + 1, cols, diagonals, antidiagonals)\\n            }\\n            return solution\\n        }\\n\\n        return backtrack(0, 0, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470773,
                "title": "backtracking-c-with-diagonals",
                "content": "# Intuition\\nTrack which column and diagonals are used by using 3 bool arrays.\\n\\n# Approach\\nIntroduce 3 arrays which track which columns and diagonals are occupied. Map diagonal indices using the following mapping:\\n\\n```\\n/*\\ndiagonal1:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  0   1   2   3\\n   1 | -1   0   1   2\\n   2 | -2  -1   0   1\\n   3 | -3  -2  -1   0\\n\\nD1(row, col) = col - row\\n\\ndiagonal2:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  3   2   1   0\\n   1 |  2   1   0  -1\\n   2 |  1   0  -1  -2\\n   3 |  0  -1  -2  -3\\n\\nD2(row, col) = N-1 - col - row\\n*/\\n```\\n\\nThey need to be positive, so move them up by another N-1.\\n\\n# Code\\n```\\nclass Solution {\\n  static constexpr int SIZE = 9;\\n\\n  bool column_occupied[SIZE] = {};\\n  bool diagonal1_occupied[2*SIZE] = {};\\n  bool diagonal2_occupied[2*SIZE] = {};\\n\\npublic:\\n  int totalNQueens(int n) {\\n    return solve(n, 0);\\n  }\\n\\nprivate: \\n  int solve(int n, int row) {\\n    if (row == n) return 1; // found a valid solution!\\n\\n    int sum = 0;\\n    for (int col = 0; col < n; col++) {\\n      bool &column_used = column_occupied[col];\\n      bool &diagonal1_used = diagonal1_occupied[n-1 + col - row];\\n      bool &diagonal2_used = diagonal2_occupied[2*(n-1) - col - row];\\n\\n      if (!column_used && !diagonal1_used && !diagonal2_used) {\\n        column_used = diagonal1_used = diagonal2_used = true;\\n        sum += solve(n, row+1);\\n        column_used = diagonal1_used = diagonal2_used = false;\\n      }\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n/*\\ndiagonal1:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  0   1   2   3\\n   1 | -1   0   1   2\\n   2 | -2  -1   0   1\\n   3 | -3  -2  -1   0\\n\\nD1(row, col) = col - row\\n\\ndiagonal2:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  3   2   1   0\\n   1 |  2   1   0  -1\\n   2 |  1   0  -1  -2\\n   3 |  0  -1  -2  -3\\n\\nD2(row, col) = N-1 - col - row\\n*/\\n```\n```\\nclass Solution {\\n  static constexpr int SIZE = 9;\\n\\n  bool column_occupied[SIZE] = {};\\n  bool diagonal1_occupied[2*SIZE] = {};\\n  bool diagonal2_occupied[2*SIZE] = {};\\n\\npublic:\\n  int totalNQueens(int n) {\\n    return solve(n, 0);\\n  }\\n\\nprivate: \\n  int solve(int n, int row) {\\n    if (row == n) return 1; // found a valid solution!\\n\\n    int sum = 0;\\n    for (int col = 0; col < n; col++) {\\n      bool &column_used = column_occupied[col];\\n      bool &diagonal1_used = diagonal1_occupied[n-1 + col - row];\\n      bool &diagonal2_used = diagonal2_occupied[2*(n-1) - col - row];\\n\\n      if (!column_used && !diagonal1_used && !diagonal2_used) {\\n        column_used = diagonal1_used = diagonal2_used = true;\\n        sum += solve(n, row+1);\\n        column_used = diagonal1_used = diagonal2_used = false;\\n      }\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270721,
                "title": "python3-backtracking-easy-solution-beats-98",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        ans=0\\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\\n        def solve(col,board):\\n            nonlocal ans\\n            if col==n:\\n                ans+=1\\n                return \\n            for row in range(n):\\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\\n                    board[row][col]=\"Q\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\\n                    solve(col+1,board)\\n                    board[row][col]=\".\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\\n        board=[[\".\" for i in range(n)] for _ in range(n)]\\n        solve(0,board)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        ans=0\\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\\n        def solve(col,board):\\n            nonlocal ans\\n            if col==n:\\n                ans+=1\\n                return \\n            for row in range(n):\\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\\n                    board[row][col]=\"Q\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\\n                    solve(col+1,board)\\n                    board[row][col]=\".\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\\n        board=[[\".\" for i in range(n)] for _ in range(n)]\\n        solve(0,board)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209817,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          \\n\\t\\t\\t    board[row][col] = true;          \\n\\t\\t\\t    count += solve(board, row + 1);  \\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          \\n\\t\\t\\t    board[row][col] = true;          \\n\\t\\t\\t    count += solve(board, row + 1);  \\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938038,
                "title": "very-very-easy-solution-in-0-1-time-java-100",
                "content": "```\\npublic int totalNQueens(int n) {\\n        if(n == 1)\\n            return 1;\\n        if(n < 4)\\n            return 0;\\n        if(n == 4)\\n            return 2;\\n        if(n == 5)\\n            return 10;\\n        if(n == 6)\\n            return 4;\\n        if(n == 7)\\n            return 40;\\n        if(n == 8)\\n            return 92;\\n        return 352;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int totalNQueens(int n) {\\n        if(n == 1)\\n            return 1;\\n        if(n < 4)\\n            return 0;\\n        if(n == 4)\\n            return 2;\\n        if(n == 5)\\n            return 10;\\n        if(n == 6)\\n            return 4;\\n        if(n == 7)\\n            return 40;\\n        if(n == 8)\\n            return 92;\\n        return 352;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859048,
                "title": "java-n-queens-2-using-recursion-easy-understanding",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int totalNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        helper(board,0,n);\\n        return count;\\n    }\\n    public boolean isSafe(char[][] board,int row,int col)\\n\\t{\\n\\t\\t//Vertical\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[row][i]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Horizontal\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][col]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Left\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Right\\n\\t\\tfor(int i=row,j=col;i>=0 && j<board.length;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Left\\n\\t\\tfor(int i=row,j=col;i<board.length && j>=0;i++,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Right\\n\\t\\tfor(int i=row,j=col;i<board.length && j<board.length;i++,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n    \\n    public void helper(char[][] board,int col,int row )\\n\\t{\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tif(col==row)\\t\\n\\t\\t\\t{\\n                count++;\\n                return;\\n\\t\\t\\t}\\n\\t\\t\\tif(isSafe(board,i,col))\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i][col] = \\'Q\\';\\n\\t\\t\\t\\thelper(board,col+1,row);\\t\\n\\t\\t\\t\\tboard[i][col] = \\' \\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int totalNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        helper(board,0,n);\\n        return count;\\n    }\\n    public boolean isSafe(char[][] board,int row,int col)\\n\\t{\\n\\t\\t//Vertical\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[row][i]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Horizontal\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][col]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Left\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Right\\n\\t\\tfor(int i=row,j=col;i>=0 && j<board.length;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Left\\n\\t\\tfor(int i=row,j=col;i<board.length && j>=0;i++,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Right\\n\\t\\tfor(int i=row,j=col;i<board.length && j<board.length;i++,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n    \\n    public void helper(char[][] board,int col,int row )\\n\\t{\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tif(col==row)\\t\\n\\t\\t\\t{\\n                count++;\\n                return;\\n\\t\\t\\t}\\n\\t\\t\\tif(isSafe(board,i,col))\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i][col] = \\'Q\\';\\n\\t\\t\\t\\thelper(board,col+1,row);\\t\\n\\t\\t\\t\\tboard[i][col] = \\' \\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798719,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    int totalNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    int totalNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797884,
                "title": "java-o-n-n-n-87-faster-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use the concept of **Backtracking** for this problem.\\nNow, the basic approach that one can think of would be to check each cell that is it a potential position for the queen to be placed.. !!\\n\\n*Well, we\\'ll implement the above approach itself but it in a more optimised manner using backtracking.*\\n\\nSteps to be followed ->\\n\\n - For each row of the ```chess```, we\\'ll place the queen at a specific column and will recursively check that is the remaining part of the grid able to place rest queens or not..\\n - For eg, for row or ```currLevel=0```, we first place the queen at column ```i=0``` and then will recursively call the next level or row. \\n - Now, we\\'ll check that is it safe for the queen to be placed at ```chess[currLevel][i]``` using ```isSafeForQueen(currLevel, i)```. If the position is valid, we place the queen, and similarly pass to the next level.\\n - In case, the queen doesn\\'t find any appropriate position for the ```currLevel```, we\\'ll fallback to previous level and **will *remove (backtracking)* the queen present in previous row and will try the next position.**\\n - Now, if we reach to the condition ```currLevel = n```, it means we have successfully encountered a ```way``` and hence, we return ```1``` corresponding to that way.\\n\\nFollowing above steps, we can easily frame the solution.\\n\\n# Complexity\\n- Time complexity: $$O(n^n*n)$$ - **(Beats 87%)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int[][] chess;\\n    public int totalNQueens(int n) {\\n        chess = new int[n][n];\\n        return solveNQueensHelper(n, 0);\\n    }\\n    public static int solveNQueensHelper(int n, int currLevel) {\\n        if(currLevel == n){\\n            return 1;\\n        }\\n        int ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(isSafeForQueen(currLevel, i)){\\n                chess[currLevel][i] = 1;\\n                ways += solveNQueensHelper(n, currLevel+1);\\n                chess[currLevel][i] = 0;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static boolean isSafeForQueen(int r, int c) { \\n        //col\\n        for(int i = r-1; i >= 0; i--){\\n            if(chess[i][c] == 1) return false;\\n        }\\n        //right dia\\n        for(int i = r-1, j = c+1; i >= 0 && j < chess.length; i--, j++){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        //left dia\\n        for(int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```chess```\n```currLevel=0```\n```i=0```\n```chess[currLevel][i]```\n```isSafeForQueen(currLevel, i)```\n```currLevel```\n```currLevel = n```\n```way```\n```1```\n```\\nclass Solution {\\n\\n    static int[][] chess;\\n    public int totalNQueens(int n) {\\n        chess = new int[n][n];\\n        return solveNQueensHelper(n, 0);\\n    }\\n    public static int solveNQueensHelper(int n, int currLevel) {\\n        if(currLevel == n){\\n            return 1;\\n        }\\n        int ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(isSafeForQueen(currLevel, i)){\\n                chess[currLevel][i] = 1;\\n                ways += solveNQueensHelper(n, currLevel+1);\\n                chess[currLevel][i] = 0;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static boolean isSafeForQueen(int r, int c) { \\n        //col\\n        for(int i = r-1; i >= 0; i--){\\n            if(chess[i][c] == 1) return false;\\n        }\\n        //right dia\\n        for(int i = r-1, j = c+1; i >= 0 && j < chess.length; i--, j++){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        //left dia\\n        for(int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720473,
                "title": "java-easy-code-recursion-backtracking",
                "content": "Solved using a Boolean Matrix of N size. \\nIn recusive calls it will check if putting the Queen is Safe if not Backtrack.\\n\\n\\n\\n\\n\\n\\n        \\n    class Solution {\\n    public int totalNQueens(int n) {\\n      boolean[][] board = new boolean[n][n];\\n      return queens(board,0);\\n        \\n    }\\n    int queens(boolean[][] board,int row)\\n\\t{\\n\\t\\tif(row==board.length){\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        // Placing Queens and Checking for every row and column\\n        for(int col=0;col<board.length;col++){\\n            //place queen if Safe\\n            if(isSafe(board,row,col)){\\n                board[row][col] = true;\\n                count += queens(board,row+1); //Recursive call\\n                board[row][col] = false;    // Backtrack\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    boolean isSafe(boolean[][] board, int row ,int col){\\n        \\n        // Vertical row\\n        for(int i=0;i<row;i++){\\n            if(board[i][col])\\n                return false;\\n        }\\n        \\n        // Left diagonal\\n        int maxLeft = Math.min(row,col);\\n        for(int i=1;i<=maxLeft;i++){\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        \\n        // Right diagonal\\n        int maxRight = Math.min(row,board.length-col-1);\\n        for(int i=1;i<=maxRight;i++){\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int totalNQueens(int n) {\\n      boolean[][] board = new boolean[n][n];\\n      return queens(board,0);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2559395,
                "title": "java-solution-using-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n       boolean[][] board = new boolean[n][n];\\n       return queens(board,0);\\n    }\\n\\tstatic int queens(boolean[][] board,int row){\\n        if(row == board.length){\\n            return 1;\\n        }\\n        int count = 0;\\n        //placing the queens and checking for every row and col\\n        for(int col = 0;col< board.length;col++){\\n            //place the queen if it is safe\\n            if(issafe(board,row,col)){\\n                board[row][col]=true;\\n                count += queens(board,row+1);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n    //checks all pssible safe blocks for the queens\\n    static boolean issafe(boolean[][] board,int row,int col){\\n        //check vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col]){\\n                return false;\\n            }\\n        }\\n        //check for diagonal left\\n        int maxleft = Math.min(row,col);\\n        for (int i = 1; i <= maxleft; i++) {\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        //checks for diagonal rigth\\n        int maxright = Math.min(row,board.length-col-1);\\n        for (int i = 1; i <= maxright; i++) {\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n       boolean[][] board = new boolean[n][n];\\n       return queens(board,0);\\n    }\\n\\tstatic int queens(boolean[][] board,int row){\\n        if(row == board.length){\\n            return 1;\\n        }\\n        int count = 0;\\n        //placing the queens and checking for every row and col\\n        for(int col = 0;col< board.length;col++){\\n            //place the queen if it is safe\\n            if(issafe(board,row,col)){\\n                board[row][col]=true;\\n                count += queens(board,row+1);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n    //checks all pssible safe blocks for the queens\\n    static boolean issafe(boolean[][] board,int row,int col){\\n        //check vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col]){\\n                return false;\\n            }\\n        }\\n        //check for diagonal left\\n        int maxleft = Math.min(row,col);\\n        for (int i = 1; i <= maxleft; i++) {\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        //checks for diagonal rigth\\n        int maxright = Math.min(row,board.length-col-1);\\n        for (int i = 1; i <= maxright; i++) {\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115816,
                "title": "just-1-line-solution-check-once",
                "content": "class Solution {\\npublic:\\n   int totalNQueens(int n) \\n   {\\n       return array<int, 13>{0,1,0,0,2,10,4,40,92,352,724,2680,14200}[n];\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int totalNQueens(int n) \\n   {\\n       return array<int, 13>{0,1,0,0,2,10,4,40,92,352,724,2680,14200}",
                "codeTag": "Java"
            },
            {
                "id": 2115112,
                "title": "java-backtracking-comment-added",
                "content": "```\\nclass Solution {\\n    \\n   int answer;\\n    public int totalNQueens(int n) {\\n        \\n        answer = 0;\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            answer++; // valid configuration found\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n   int answer;\\n    public int totalNQueens(int n) {\\n        \\n        answer = 0;\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            answer++; // valid configuration found\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114767,
                "title": "java-easy-understand-stack",
                "content": "\\nWe can check the board usign below \\n1. First one is to add the both row and column values (Which is stored in Positive digonal stack)\\n2. Second is to subract and store them in the Negative Digonal stack\\n3. Store each coulmn value in another stack\\n4. These stack helps in verifying the Queen\\'s position\\n\\n```\\n        0                  1       2      3 \\n0   (0+0=0) ,(0-0=0)    (0,-1)  (0,-2)  (0,-3)\\n1   (1,1)               (2,0)   (3,-1)  (4,-2)\\n2   ( 2, 2 )            (3,1)   (4,0)   (5,-1)\\n3   (3,3)               (4,2)   (5,1)   (6,0)\\n```\\n\\nFrom above diagram we can observe that all the additon value in the diagonal are same and  subracted values are same. \\nWe use this login and Push and pop the elements based on our traversal\\n\\n```\\n\\nclass Solution {\\n     int ans = 0;\\n     Stack<Integer> positiveDiagonal = new Stack<>();\\n     Stack<Integer> negativeDiagonal = new Stack<>();\\n\\n    public  int totalNQueens(int n) {\\n        int[][] board = new int[n][n];\\n        Stack<Integer> row = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            row.push(i);\\n            positiveDiagonal.push(i);\\n\\t\\t\\t// Inserting the value of diagonol\\n            negativeDiagonal.push(-i);\\n            solve(1, row, n-1,n);\\n\\t\\t\\t//Checking the board for each position in the first place then traverse the remaining  place\\n            positiveDiagonal.pop();\\n            negativeDiagonal.pop();\\n            row.pop();\\n        }\\n        return ans;\\n    }\\n\\n    public  void solve(int start, Stack<Integer> row, int size, int n) {\\n\\n        if (size==0) {\\n            ans += 1;\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// Check each element if that postion is good or not\\n            if (verifyPosition(start, i, row)) {\\n                row.push(i);\\n                positiveDiagonal.push(start + i);\\n                negativeDiagonal.push(start - i);\\n                solve(start + 1, row, size-1,n);\\n                positiveDiagonal.pop();\\n                negativeDiagonal.pop();\\n                row.pop();\\n            }\\n        }\\n    }\\n\\n    public  boolean verifyPosition(int start, int i, Stack<Integer> row) {\\n\\n        return !(row.contains(i) || positiveDiagonal.contains(start + i) || negativeDiagonal.contains(start - i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\n        0                  1       2      3 \\n0   (0+0=0) ,(0-0=0)    (0,-1)  (0,-2)  (0,-3)\\n1   (1,1)               (2,0)   (3,-1)  (4,-2)\\n2   ( 2, 2 )            (3,1)   (4,0)   (5,-1)\\n3   (3,3)               (4,2)   (5,1)   (6,0)\\n```\n```\\n\\nclass Solution {\\n     int ans = 0;\\n     Stack<Integer> positiveDiagonal = new Stack<>();\\n     Stack<Integer> negativeDiagonal = new Stack<>();\\n\\n    public  int totalNQueens(int n) {\\n        int[][] board = new int[n][n];\\n        Stack<Integer> row = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            row.push(i);\\n            positiveDiagonal.push(i);\\n\\t\\t\\t// Inserting the value of diagonol\\n            negativeDiagonal.push(-i);\\n            solve(1, row, n-1,n);\\n\\t\\t\\t//Checking the board for each position in the first place then traverse the remaining  place\\n            positiveDiagonal.pop();\\n            negativeDiagonal.pop();\\n            row.pop();\\n        }\\n        return ans;\\n    }\\n\\n    public  void solve(int start, Stack<Integer> row, int size, int n) {\\n\\n        if (size==0) {\\n            ans += 1;\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// Check each element if that postion is good or not\\n            if (verifyPosition(start, i, row)) {\\n                row.push(i);\\n                positiveDiagonal.push(start + i);\\n                negativeDiagonal.push(start - i);\\n                solve(start + 1, row, size-1,n);\\n                positiveDiagonal.pop();\\n                negativeDiagonal.pop();\\n                row.pop();\\n            }\\n        }\\n    }\\n\\n    public  boolean verifyPosition(int start, int i, Stack<Integer> row) {\\n\\n        return !(row.contains(i) || positiveDiagonal.contains(start + i) || negativeDiagonal.contains(start - i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114708,
                "title": "c-efficient-code",
                "content": "class Solution {\\npublic:\\n    \\n    int count=0;\\n    \\n    void  solve(int col,vector<int> &left,vector<int> &upperDiagnol,vector<int> &lowerDiagnol,int n)\\n    {\\n         if(col==n)\\n         {\\n             count++; \\n             return;\\n         }\\n      \\n      for(int row=0;row<n;row++)\\n      {\\n          if(left[row]==0 && lowerDiagnol[row+col]==0 && upperDiagnol[n-1+col-row]==0)\\n          {\\n              left[row]=1;\\n              lowerDiagnol[row+col]=1;\\n              upperDiagnol[n-1+col-row]=1;\\n              solve(col+1,left,upperDiagnol,lowerDiagnol,n);\\n              left[row]=0;\\n              lowerDiagnol[row+col]=0;\\n              upperDiagnol[n-1+col-row]=0;\\n              \\n              \\n          }\\n      }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<int> left(n,0);\\n        vector<int> upperDiagnol(2*n-1,0);\\n        vector<int> lowerDiagnol(2*n-1,0);\\n        \\n        solve(0,left,upperDiagnol,lowerDiagnol,n);\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int count=0;\\n    \\n    void  solve(int col,vector<int> &left,vector<int> &upperDiagnol,vector<int> &lowerDiagnol,int n)\\n    {\\n         if(col==n)\\n         {\\n             count++; \\n             return;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2113019,
                "title": "c-extension-of-n-queens-just-one-line-change",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int col, int n, vector<vector<string>>& ans , vector<string>& board, vector<int>& left, vector<int>& upperDigonal ,vector<int>& lowerDigonal)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row=0;row<n;row++)\\n        {\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[col-row+n-1]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                left[row] = 1;\\n                upperDigonal[row+col] = 1;\\n                lowerDigonal[col-row+n-1] = 1;\\n                \\n                helper(col+1,n,ans,board,left,upperDigonal,lowerDigonal);\\n                \\n                board[row][col] = \\'.\\';\\n                left[row] = 0;\\n                upperDigonal[row+col] = 0;\\n                lowerDigonal[col-row+n-1] = 0;\\n            }\\n        }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        helper(0,n,ans,board,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int col, int n, vector<vector<string>>& ans , vector<string>& board, vector<int>& left, vector<int>& upperDigonal ,vector<int>& lowerDigonal)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row=0;row<n;row++)\\n        {\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[col-row+n-1]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                left[row] = 1;\\n                upperDigonal[row+col] = 1;\\n                lowerDigonal[col-row+n-1] = 1;\\n                \\n                helper(col+1,n,ans,board,left,upperDigonal,lowerDigonal);\\n                \\n                board[row][col] = \\'.\\';\\n                left[row] = 0;\\n                upperDigonal[row+col] = 0;\\n                lowerDigonal[col-row+n-1] = 0;\\n            }\\n        }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        helper(0,n,ans,board,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112855,
                "title": "all-we-need-to-do-is-to-return-ans-size-c",
                "content": "\\u27A1 If you have solved N-queens problem: \\n ***All we need to do is to return ans.size() [2d string vector of N-Queens]. As there in N-Queens problem we have returned distinct solutions to the N-queens puzzle ,i.e., all possible solution string Vector.***\\n\\n1. **N-Queens** [https://leetcode.com/problems/n-queens/](http://)\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n\\n    vector < vector < string >> solveNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans;\\n    }\\n};\\n    \\n```\\n\\n2. **N-Queens ||** [https://leetcode.com/problems/n-queens-ii/](http://)\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n    int totalNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans.size();\\n    }\\n};\\n```\\n\\n**Upvote++ if it helped** \\u270C",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n\\n    vector < vector < string >> solveNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans;\\n    }\\n};\\n    \\n```\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n    int totalNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112815,
                "title": "java-100-loophole-solution-correct-solution",
                "content": "I used switch case instead of if-else, and since we already know the number of queens per case, I output that.\\n\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        switch ( n)\\n        {\\n            case 1: return 1;\\n            case 2: return 0;\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            default: return 352;\\n        }\\n    }\\n}\\n```\\n\\n### **Talking about the correct way of solving:**\\n**What\\'s Backtracking?**\\nBacktracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem. \\n\\nIn this problem,\\n```\\nclass Solution {\\n    public int count=0;\\n    public int totalNQueens(int n) {\\n        System.out.println(solveNQueens(n));\\n        return count;\\n    } \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        solve(0,board,ans,n);\\n        return ans;\\n    }\\n\\n    private  void solve(int col, char[][] board, List<List<String>> ans, int n) {\\n        if(col==n){\\n            // ans.add(construct(board));\\n            count++;\\n            return;\\n        }\\n        for(int row=0;row< board.length;row++){\\n            if(valid(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    private  boolean valid(int row, int col, char[][] board) {\\n        int duprow=row;\\n        int dupcol=col;\\n\\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;\\n            col--;\\n        }\\n\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0 && row< board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        switch ( n)\\n        {\\n            case 1: return 1;\\n            case 2: return 0;\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            default: return 352;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int count=0;\\n    public int totalNQueens(int n) {\\n        System.out.println(solveNQueens(n));\\n        return count;\\n    } \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        solve(0,board,ans,n);\\n        return ans;\\n    }\\n\\n    private  void solve(int col, char[][] board, List<List<String>> ans, int n) {\\n        if(col==n){\\n            // ans.add(construct(board));\\n            count++;\\n            return;\\n        }\\n        for(int row=0;row< board.length;row++){\\n            if(valid(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    private  boolean valid(int row, int col, char[][] board) {\\n        int duprow=row;\\n        int dupcol=col;\\n\\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;\\n            col--;\\n        }\\n\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0 && row< board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112338,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    //create ans vector to store all possible solutions\\n    vector<vector<string>>ans;\\n    \\n    //check whether other queen is present in column or not\\n    bool issafe(int r,int c,vector<string>&v,int n){\\n        for(int i=0;i<=r;i++){\\n            //if present return false\\n            if(v[i][c]==\\'Q\\') return false;\\n        }\\n    //check whether other queen is present in diagonally upper left position or not\\n        int row=r,col=c;\\n        while(row>=0&&col>=0){\\n         \\n            if(v[row][col]==\\'Q\\') return false;\\n            row--;col--;\\n        }\\n        //check whether other queen is present in diagonally upper right position or not\\n        row=r;col=c;\\n        while(row>=0&&c<n){\\n            if(v[row][col]==\\'Q\\') return false;\\n            row--;col++;\\n        }\\n        return true;\\n        //if no the queen is present in column and diagonally upper left and diagonally upper right positions return true(or is safe)\\n    }\\n    \\n    void solve(int r,vector<string>&v,int n){\\n        if(r==n){   \\n            ans.push_back(v);\\n            return;\\n        }\\n        //now fix the row and move over the column and check for safe position\\n        for(int i=0;i<n;i++){\\n            if(issafe(r,i,v,n)){\\n                v[r][i]=\\'Q\\';\\n                solve(r+1,v,n); \\n                v[r][i]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        //we required a board of size n*n to store n number of queens\\n        \\n        vector<string>v(n,string (n,\\'.\\'));\\n        // create a board with all non queen index\\n        solve(0,v,n); \\n        // to palce n number of queens on there safe position call solve() function with row 0 \\n        \\n        return ans.size();\\n    }\\n    \\n};\\n\\n//Up-Vote if you like\\n//Thankyou",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //create ans vector to store all possible solutions\\n    vector<vector<string>>ans;\\n    \\n    //check whether other queen is present in column or not\\n    bool issafe(int r,int c,vector<string>&v,int n){\\n        for(int i=0;i<=r;i++){\\n            //if present return false\\n            if(v[i][c]==\\'Q\\') return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111826,
                "title": "c-solution-o-1-solution-very-easy",
                "content": "May god bless you to see this O(1) solution.\\nThis is not cheating my boi. Because the constraints are very small. 1 to 9 so for only 9 solutions i first coded up the main NQueen problem and from there, i found out the possible solutions and stored them in an array. BOOM!! you got O(1) Solution.\\n\\n```\\n\\nint totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352};\\n    return ar[n-1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352};\\n    return ar[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111606,
                "title": "c-0ms-short-easy-to-understand",
                "content": "In this problem, we can go row by row, and in each position, we need to check if the column, the left diagonal and the right diagonal had a queen before.\\n```\\nclass Solution {\\nprivate:\\n    int N,ans;\\n    bool board[9][9]={0};\\n    bool isValid(int row,int col){\\n        for(int i=0;i<row;i++) if(board[i][col])return 0; //check the column\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) if(board[i][j])return 0; //check the left digonal\\n        for(int i=row-1,j=col+1;i>=0 && j<N;i--,j++) if(board[i][j])return 0;  //check the right digonal\\n        return 1;\\n    }\\n    void nQueen(int row){\\n        if(row==N){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<N;i++){\\n           if(isValid(row,i)){\\n              board[row][i]=1;\\n              nQueen(row+1);\\n              board[row][i]=0;\\n           }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        N=n;ans=0;\\n        nQueen(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N,ans;\\n    bool board[9][9]={0};\\n    bool isValid(int row,int col){\\n        for(int i=0;i<row;i++) if(board[i][col])return 0; //check the column\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) if(board[i][j])return 0; //check the left digonal\\n        for(int i=row-1,j=col+1;i>=0 && j<N;i--,j++) if(board[i][j])return 0;  //check the right digonal\\n        return 1;\\n    }\\n    void nQueen(int row){\\n        if(row==N){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<N;i++){\\n           if(isValid(row,i)){\\n              board[row][i]=1;\\n              nQueen(row+1);\\n              board[row][i]=0;\\n           }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        N=n;ans=0;\\n        nQueen(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111575,
                "title": "c-fast-solution",
                "content": "class Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n\\nprivate:\\n    int ans;\\n\\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2111495,
                "title": "python-back-tracking",
                "content": "This is similar to the problem of N-Queens (yesterday\\'s daily challange). This video (https://www.youtube.com/watch?v=Ph95IHmRp5M) helped me understand N-Queens problem.\\nFor this problem, instead of appending the answer to an array, just increase the answer by one for a valid position. \\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        col = set()\\n        negDiag = set() ## row - column is constant\\n        posDiag = set() ## row + column is constant\\n        \\n        board = [[\\'.\\']*n for _ in range(n)]\\n        ans = 0\\n        \\n        def backtrack(r):\\n            nonlocal ans\\n            if r == n:\\n                ans += 1\\n                return\\n            for c in range(n):\\n                if c not in col and (r+c) not in posDiag and (r-c) not in negDiag:\\n                    col.add(c)\\n                    negDiag.add(r-c)\\n                    posDiag.add(r+c)\\n                    board[r][c] = \\'Q\\'\\n                    \\n                    backtrack(r+1)\\n                    \\n                    col.remove(c)\\n                    negDiag.remove(r-c)\\n                    posDiag.remove(r+c)\\n                    board[r][c] = \\'.\\'\\n        \\n        backtrack(0)\\n        return ans\\n```\\nHappy coding! Thanks.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        col = set()\\n        negDiag = set() ## row - column is constant\\n        posDiag = set() ## row + column is constant\\n        \\n        board = [[\\'.\\']*n for _ in range(n)]\\n        ans = 0\\n        \\n        def backtrack(r):\\n            nonlocal ans\\n            if r == n:\\n                ans += 1\\n                return\\n            for c in range(n):\\n                if c not in col and (r+c) not in posDiag and (r-c) not in negDiag:\\n                    col.add(c)\\n                    negDiag.add(r-c)\\n                    posDiag.add(r+c)\\n                    board[r][c] = \\'Q\\'\\n                    \\n                    backtrack(r+1)\\n                    \\n                    col.remove(c)\\n                    negDiag.remove(r-c)\\n                    posDiag.remove(r+c)\\n                    board[r][c] = \\'.\\'\\n        \\n        backtrack(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111001,
                "title": "python-o-1-solution-just-kidding-this-is-cheating",
                "content": "```\\nclass Solution:\\n    \\n    def totalNQueens(self, n: int) -> int:\\n        ans = [1, 0, 0, 2, 10, 4, 40, 92, 352]\\n        return ans[n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def totalNQueens(self, n: int) -> int:\\n        ans = [1, 0, 0, 2, 10, 4, 40, 92, 352]\\n        return ans[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946703,
                "title": "c-backtracking-self-explainable-code",
                "content": "```\\nclass Solution {\\n    bool isSafe(int row,int col,vector<string>& board){\\n        //row traversal\\n        for(int i=row;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal left\\n        for(int i=row,j=col;i>=0&&j>=0;i--,j--){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal right\\n        for(int i=row,j=col;i>=0&&j<board.size();i--,j++){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    void helper(int row,int& ans,vector<string>& board){\\n        if(row==board.size()){\\n            ans++;\\n            return;\\n        }\\n        /*\\n        put the queen \\n        call for other rows\\n        backtrack i.e remove the queen\\n        */\\n        for(int j=0;j<board.size();j++){\\n            if(isSafe(row,j,board)){\\n                board[row][j]=\\'Q\\';\\n                helper(row+1,ans,board);\\n                board[row][j]=\\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        vector<string> board(n,string(n,\\'.\\'));\\n        int ans=0;\\n        helper(0,ans,board);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isSafe(int row,int col,vector<string>& board){\\n        //row traversal\\n        for(int i=row;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal left\\n        for(int i=row,j=col;i>=0&&j>=0;i--,j--){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal right\\n        for(int i=row,j=col;i>=0&&j<board.size();i--,j++){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    void helper(int row,int& ans,vector<string>& board){\\n        if(row==board.size()){\\n            ans++;\\n            return;\\n        }\\n        /*\\n        put the queen \\n        call for other rows\\n        backtrack i.e remove the queen\\n        */\\n        for(int j=0;j<board.size();j++){\\n            if(isSafe(row,j,board)){\\n                board[row][j]=\\'Q\\';\\n                helper(row+1,ans,board);\\n                board[row][j]=\\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        vector<string> board(n,string(n,\\'.\\'));\\n        int ans=0;\\n        helper(0,ans,board);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764025,
                "title": "c-backtracking-faster-than-90-percent-space-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int chessboard[9][9];\\n        memset(chessboard, -1, sizeof(chessboard));\\n        \\n        int total = 0;\\n        int row = 0;\\n        NQueens(chessboard, n, row, total);\\n        \\n        return total;\\n    }\\n    \\n    void NQueens(int chessboard[][9], int n, int row, int &total) {\\n        if(row == n) {\\n            total++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(chessboard, row, col, n) == true) {\\n                chessboard[row][col] = 0;\\n                NQueens(chessboard, n, row + 1, total);\\n                chessboard[row][col] = -1;\\n            }\\n        }\\n    }\\n    \\n    bool IsQueenSafe(int chessboard[][9], int row, int col, int n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int chessboard[9][9];\\n        memset(chessboard, -1, sizeof(chessboard));\\n        \\n        int total = 0;\\n        int row = 0;\\n        NQueens(chessboard, n, row, total);\\n        \\n        return total;\\n    }\\n    \\n    void NQueens(int chessboard[][9], int n, int row, int &total) {\\n        if(row == n) {\\n            total++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(chessboard, row, col, n) == true) {\\n                chessboard[row][col] = 0;\\n                NQueens(chessboard, n, row + 1, total);\\n                chessboard[row][col] = -1;\\n            }\\n        }\\n    }\\n    \\n    bool IsQueenSafe(int chessboard[][9], int row, int col, int n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732593,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\n\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        visitedCol = set()\\n        posDig = set() \\n        negDig = set() \\n        res = 0 \\n        def backtrack(row):\\n            if row == n: \\n                nonlocal res \\n                res += 1 \\n                return\\n            for col in range(n): \\n                if col in visitedCol or (row+col) in posDig or(row-col) in negDig: \\n                    continue \\n                visitedCol.add(col) \\n                negDig.add(row-col) \\n                posDig.add(row+col) \\n                backtrack(row+1) \\n                visitedCol.remove(col) \\n                negDig.remove(row-col) \\n                posDig.remove(row+col) \\n        backtrack(0)    \\n \\xA0 \\xA0 \\xA0 \\xA0return res",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        visitedCol = set()\\n        posDig = set() \\n        negDig = set() \\n        res = 0 \\n        def backtrack(row):\\n            if row == n: \\n                nonlocal res \\n                res += 1 \\n                return\\n            for col in range(n): \\n                if col in visitedCol or (row+col) in posDig or(row-col) in negDig: \\n                    continue \\n                visitedCol.add(col) \\n                negDig.add(row-col) \\n                posDig.add(row+col) \\n                backtrack(row+1) \\n                visitedCol.remove(col) \\n                negDig.remove(row-col) \\n                posDig.remove(row+col) \\n        backtrack(0)    \\n \\xA0 \\xA0 \\xA0 \\xA0return res",
                "codeTag": "Java"
            },
            {
                "id": 1691037,
                "title": "fastest-c-solution-0ms-100",
                "content": "```\\nint ans=0;\\n    void solve(int n, vector<bool>& cols, vector<bool>& d1, vector<bool>& d2, int i)\\n    {\\n        if(i==n) //last row: solution found\\n        {\\n            ans++;\\n        }\\n        for(int j=0; j<n; j++)\\n        {\\n            int id1=j-i+n;\\n            int id2=i+j;\\n            if(cols[j] || d1[id1] || d2[id2]) continue; //present in column, diagonal 1, diagonal 2\\n            \\n            cols[j]=true;\\n            d1[id1]=true;\\n            d2[id2]=true;\\n            solve(n, cols, d1, d2, i+1); //solve for next row\\n            cols[j]=false;\\n            d1[id1]=false;\\n            d2[id2]=false;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<bool> cols(n, false), d1(2*n, false), d2(2*n, false);\\n        solve(n, cols, d1, d2, 0);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nint ans=0;\\n    void solve(int n, vector<bool>& cols, vector<bool>& d1, vector<bool>& d2, int i)\\n    {\\n        if(i==n) //last row: solution found\\n        {\\n            ans++;\\n        }\\n        for(int j=0; j<n; j++)\\n        {\\n            int id1=j-i+n;\\n            int id2=i+j;\\n            if(cols[j] || d1[id1] || d2[id2]) continue; //present in column, diagonal 1, diagonal 2\\n            \\n            cols[j]=true;\\n            d1[id1]=true;\\n            d2[id2]=true;\\n            solve(n, cols, d1, d2, i+1); //solve for next row\\n            cols[j]=false;\\n            d1[id1]=false;\\n            d2[id2]=false;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<bool> cols(n, false), d1(2*n, false), d2(2*n, false);\\n        solve(n, cols, d1, d2, 0);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1606350,
                "title": "faster-than-96-7-python-solutions",
                "content": "Very similar to the N-Queens Hard problem. The key difference is that we don\\'t have to maintain the board here instead just increment the count value everytime we find a solution (row==n)\\n```class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        cols = set()\\n        diag = set() # signifies (r+c)\\n        anti_diag = set() #signifies (r-c)\\n        board = [[\\'.\\' for i in range(n)] for j in range(n)]\\n        self.count=0\\n    \\n        def backtrack(row):\\n            if row==n:\\n                self.count+=1\\n                return \\n            \\n            for col in range(n):\\n                if col in cols or (row+col) in diag or (row-col) in anti_diag:\\n                    continue\\n                #the queen can now be placed at this (row,col)\\n                \\n                cols.add(col)\\n                diag.add(row+col)\\n                anti_diag.add(row-col)\\n                \\n                #call backtrack function for next row\\n                backtrack(row+1)\\n                \\n                #remove the queen from this position (we backtrack from here because in the iteration part of the recursion we realized that this position is not going to return us the final answer)\\n                \\n                cols.remove(col)\\n                diag.remove(row+col)\\n                anti_diag.remove(row-col)\\n        backtrack(0)\\n        return self.count\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "Very similar to the N-Queens Hard problem. The key difference is that we don\\'t have to maintain the board here instead just increment the count value everytime we find a solution (row==n)\\n```class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        cols = set()\\n        diag = set() # signifies (r+c)\\n        anti_diag = set() #signifies (r-c)\\n        board = [[\\'.\\' for i in range(n)] for j in range(n)]\\n        self.count=0\\n    \\n        def backtrack(row):\\n            if row==n:\\n                self.count+=1\\n                return \\n            \\n            for col in range(n):\\n                if col in cols or (row+col) in diag or (row-col) in anti_diag:\\n                    continue\\n                #the queen can now be placed at this (row,col)\\n                \\n                cols.add(col)\\n                diag.add(row+col)\\n                anti_diag.add(row-col)\\n                \\n                #call backtrack function for next row\\n                backtrack(row+1)\\n                \\n                #remove the queen from this position (we backtrack from here because in the iteration part of the recursion we realized that this position is not going to return us the final answer)\\n                \\n                cols.remove(col)\\n                diag.remove(row+col)\\n                anti_diag.remove(row-col)\\n        backtrack(0)\\n        return self.count\\n",
                "codeTag": "Java"
            },
            {
                "id": 1568714,
                "title": "n-queens-ii-using-backtracking-algorithm",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint bt=0;\\nvector<vector<int> > result;\\n\\nbool isSafe(vector<vector<int> > board,int row, int col)\\n{\\n\\tint i, j;\\n\\tint N = board.size();\\n\\tfor (i = 0; i < col; i++)\\n\\t\\tif (board[row][i])\\n\\t\\t\\treturn false;\\n\\tfor (i = row, j = col; i >= 0 && j >= 0; i--, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\tfor (i = row, j = col; j >= 0 && i < N; i++, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\nbool solveNQUtil(vector<vector<int> >& board, int col)\\n{\\n\\tint N = board.size();\\n\\tif (col == N) {\\n\\t\\tvector<int> v;\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 1)\\n\\t\\t\\t\\t\\tv.push_back(j + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.push_back(v);\\n\\t\\treturn true;\\n\\t}\\n\\tbool res = false;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tif (isSafe(board, i, col)) {\\n\\t\\t\\tboard[i][col] = 1;\\n\\t\\t\\tres = solveNQUtil(board, col + 1) || res;\\n\\n\\t\\t\\tboard[i][col] = 0;\\n\\t\\t    bt++;\\n\\t\\t    \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<vector<int> > nQueen(int n)\\n{\\n\\tresult.clear();\\n\\tvector<vector<int> > board(n, vector<int>(n, 0));\\n\\n\\tif (solveNQUtil(board, 0) == false) {\\n\\t    cout << \"\\\\n\\\\nSolution for n = \" << n << \" does not exist\";\\n\\t\\treturn {};\\n\\t}\\n\\n\\tsort(result.begin(), result.end());\\n\\treturn result;\\n}\\n\\nint main()\\n{\\n\\tint n;\\n\\tcout << \"Enter the value of n = \";\\n\\tcin >> n;\\n\\t{\\n\\t int count=0;   \\n\\t vector<vector<int> > v = nQueen(n);\\n     cout << \"\\\\n\\\\nPossible solutions for n = \" << n;   \\n\\t for (auto ar : v) {\\n\\t\\tcout << \"\\\\n[\";\\n\\t\\tfor (auto it : ar)\\n\\t\\t\\tcout << it << \" \";\\n\\t\\tcout << \"]\";\\n\\t\\tcount++;\\n\\t}\\n\\tcout << \"\\\\n\\\\nThus total possible solutions of N Queen problem for N = \" << n << \" are \" << count;\\n\\tcout << \"\\\\n\\\\nTotal no. of backtracks = \" << bt;\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint bt=0;\\nvector<vector<int> > result;\\n\\nbool isSafe(vector<vector<int> > board,int row, int col)\\n{\\n\\tint i, j;\\n\\tint N = board.size();\\n\\tfor (i = 0; i < col; i++)\\n\\t\\tif (board[row][i])\\n\\t\\t\\treturn false;\\n\\tfor (i = row, j = col; i >= 0 && j >= 0; i--, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\tfor (i = row, j = col; j >= 0 && i < N; i++, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\nbool solveNQUtil(vector<vector<int> >& board, int col)\\n{\\n\\tint N = board.size();\\n\\tif (col == N) {\\n\\t\\tvector<int> v;\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 1)\\n\\t\\t\\t\\t\\tv.push_back(j + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.push_back(v);\\n\\t\\treturn true;\\n\\t}\\n\\tbool res = false;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tif (isSafe(board, i, col)) {\\n\\t\\t\\tboard[i][col] = 1;\\n\\t\\t\\tres = solveNQUtil(board, col + 1) || res;\\n\\n\\t\\t\\tboard[i][col] = 0;\\n\\t\\t    bt++;\\n\\t\\t    \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<vector<int> > nQueen(int n)\\n{\\n\\tresult.clear();\\n\\tvector<vector<int> > board(n, vector<int>(n, 0));\\n\\n\\tif (solveNQUtil(board, 0) == false) {\\n\\t    cout << \"\\\\n\\\\nSolution for n = \" << n << \" does not exist\";\\n\\t\\treturn {};\\n\\t}\\n\\n\\tsort(result.begin(), result.end());\\n\\treturn result;\\n}\\n\\nint main()\\n{\\n\\tint n;\\n\\tcout << \"Enter the value of n = \";\\n\\tcin >> n;\\n\\t{\\n\\t int count=0;   \\n\\t vector<vector<int> > v = nQueen(n);\\n     cout << \"\\\\n\\\\nPossible solutions for n = \" << n;   \\n\\t for (auto ar : v) {\\n\\t\\tcout << \"\\\\n[\";\\n\\t\\tfor (auto it : ar)\\n\\t\\t\\tcout << it << \" \";\\n\\t\\tcout << \"]\";\\n\\t\\tcount++;\\n\\t}\\n\\tcout << \"\\\\n\\\\nThus total possible solutions of N Queen problem for N = \" << n << \" are \" << count;\\n\\tcout << \"\\\\n\\\\nTotal no. of backtracks = \" << bt;\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1555851,
                "title": "python-recursive-solution-24-28ms-98",
                "content": "This was just a simplification of my solution for the preceding problem, [N-Queens](https://leetcode.com/problems/n-queens/discuss/1555836/Python-recursive-solution-28-32ms-(less~99)), so I found it interesting that the problems are presented in this order.\\n\\nIt led me to realize, however, that I don\\'t need to track the locations of queens (2D array) to generate the solutions for N-Queens (though it\\'s faster). The location of the queens can be inferred from the state of the three arrays (e.g. are the current square\\'s column and two diagonals all non-vacant?).\\n\\n```\\nclass Solution(object):\\n  def recurse(self, n, row, cols, diagsA, diagsB):\\n    if row == n:\\n      return 1\\n    r = 0\\n    for col in range(0, n):\\n      if cols[col] or diagsA[col + row] or diagsB[col - row]:\\n        continue\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = True\\n      r += self.recurse(n, row + 1, cols, diagsA, diagsB)\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = False\\n    return r\\n\\n\\n  def totalNQueens(self, n):\\n    cols = [0] * n\\n    diagsA = [0] * (n * 2 - 1)\\n    diagsB = [0] * (n * 2 - 1)\\n    return self.recurse(n, 0, cols, diagsA, diagsB)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def recurse(self, n, row, cols, diagsA, diagsB):\\n    if row == n:\\n      return 1\\n    r = 0\\n    for col in range(0, n):\\n      if cols[col] or diagsA[col + row] or diagsB[col - row]:\\n        continue\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = True\\n      r += self.recurse(n, row + 1, cols, diagsA, diagsB)\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = False\\n    return r\\n\\n\\n  def totalNQueens(self, n):\\n    cols = [0] * n\\n    diagsA = [0] * (n * 2 - 1)\\n    diagsB = [0] * (n * 2 - 1)\\n    return self.recurse(n, 0, cols, diagsA, diagsB)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524746,
                "title": "java-tc-o-n-2-sc-o-1-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\n        \\n    public int totalNQueens(int n) {\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[n];\\n        boolean[] diagonal = new boolean[n + n - 1];\\n        boolean[] antiDiagonal = new boolean[n + n - 1];\\n        \\n        return totalNQueens(n, 0, row, col, diagonal, antiDiagonal);\\n    }\\n    \\n    public static int totalNQueens(int n, int r, boolean[] row, boolean[] col, boolean[] diagonal, boolean[] antiDiagonal) {\\n        if(r == n) return 1;\\n        \\n        int count = 0;\\n        for(int c = 0; c < n; c++) {\\n            if(!row[r] && !col[c] && !diagonal[r + c] && !antiDiagonal[r - c + n - 1]) {\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = true;\\n                count += totalNQueens(n, r + 1, row, col, diagonal, antiDiagonal);\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = false;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    public int totalNQueens(int n) {\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[n];\\n        boolean[] diagonal = new boolean[n + n - 1];\\n        boolean[] antiDiagonal = new boolean[n + n - 1];\\n        \\n        return totalNQueens(n, 0, row, col, diagonal, antiDiagonal);\\n    }\\n    \\n    public static int totalNQueens(int n, int r, boolean[] row, boolean[] col, boolean[] diagonal, boolean[] antiDiagonal) {\\n        if(r == n) return 1;\\n        \\n        int count = 0;\\n        for(int c = 0; c < n; c++) {\\n            if(!row[r] && !col[c] && !diagonal[r + c] && !antiDiagonal[r - c + n - 1]) {\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = true;\\n                count += totalNQueens(n, r + 1, row, col, diagonal, antiDiagonal);\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = false;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383450,
                "title": "c-hint",
                "content": "You gotta do just a small lil\\' change in the NQueens util function.\\n```\\nint NQueensSolve(int column, vector<vector<int>> &mat, int n){\\n        if (column==n)\\n            return 1;\\n        int counter = 0;\\n        for (int row=0;row<n;row++)\\n            if (isSafe(row, column, mat, n)){\\n                mat[row][column] = 1;\\n                counter += NQueensSolve(column+1, mat, n);\\n                mat[row][column] = 0;\\n            }\\n        return counter;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint NQueensSolve(int column, vector<vector<int>> &mat, int n){\\n        if (column==n)\\n            return 1;\\n        int counter = 0;\\n        for (int row=0;row<n;row++)\\n            if (isSafe(row, column, mat, n)){\\n                mat[row][column] = 1;\\n                counter += NQueensSolve(column+1, mat, n);\\n                mat[row][column] = 0;\\n            }\\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343553,
                "title": "java-recursion-backtracking-1ms-faster-than-85",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int totalNQueens(int n) {\\n        boolean[][] queen = new boolean[n][n];\\n        count = 0;\\n        helper(0, n, queen);\\n        return count;\\n    }\\n    public void helper(int l, int n, boolean[][] queen){\\n        if(l == n){\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < queen.length; i++){\\n            if(isSafe(l, i, queen)){\\n                queen[l][i] = true;\\n                helper(l + 1, n, queen);\\n                queen[l][i] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] queen){\\n        int r = i - 1, c = j;\\n        while(r >= 0)\\n            if(queen[r--][c])\\n                return false;\\n        r = i - 1;\\n        c = j - 1;\\n        while(r >= 0 && c >= 0)\\n            if(queen[r--][c--])\\n                return false;\\n        r = i - 1;\\n        c = j + 1;\\n        while(r >= 0 && c < queen.length) \\n            if(queen[r--][c++])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int totalNQueens(int n) {\\n        boolean[][] queen = new boolean[n][n];\\n        count = 0;\\n        helper(0, n, queen);\\n        return count;\\n    }\\n    public void helper(int l, int n, boolean[][] queen){\\n        if(l == n){\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < queen.length; i++){\\n            if(isSafe(l, i, queen)){\\n                queen[l][i] = true;\\n                helper(l + 1, n, queen);\\n                queen[l][i] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] queen){\\n        int r = i - 1, c = j;\\n        while(r >= 0)\\n            if(queen[r--][c])\\n                return false;\\n        r = i - 1;\\n        c = j - 1;\\n        while(r >= 0 && c >= 0)\\n            if(queen[r--][c--])\\n                return false;\\n        r = i - 1;\\n        c = j + 1;\\n        while(r >= 0 && c < queen.length) \\n            if(queen[r--][c++])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304705,
                "title": "java-branch-and-bound-100-time",
                "content": "Here we will bound the attacking spots by the queen which is being placed currently. And will do work for only those spots which are not attacked by any queen. I am iterating on rows in recursion so i will make arrays of Column, Diagonal1, Diagonal2. \\n\\nMark the cloumn array and the diagonal array accordingly (which falls under attacking spots).\\n\\n```\\nclass Solution {\\n    \\n    public static int solve(boolean[] colArr, boolean[] d1, boolean[] d2, int i) {\\n        \\n        if(i == colArr.length) {            \\n            return 1;\\n        }\\n        int sum = 0;\\n        for(int col = 0; col < colArr.length; col++) {\\n            if(!colArr[col] && !d1[i + col] && !d2[i - col + colArr.length - 1]) {\\n                colArr[col] = true;\\n                d1[i + col] = true;\\n                d2[i - col + colArr.length - 1] = true;\\n                sum += solve( colArr, d1, d2, i + 1);\\n                colArr[col] = false;\\n                d1[i + col] = false;\\n                d2[i - col + colArr.length - 1] = false;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public int totalNQueens(int n) {\\n        return solve(new boolean[n], new boolean[2*n - 1], new boolean[2*n - 1], 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public static int solve(boolean[] colArr, boolean[] d1, boolean[] d2, int i) {\\n        \\n        if(i == colArr.length) {            \\n            return 1;\\n        }\\n        int sum = 0;\\n        for(int col = 0; col < colArr.length; col++) {\\n            if(!colArr[col] && !d1[i + col] && !d2[i - col + colArr.length - 1]) {\\n                colArr[col] = true;\\n                d1[i + col] = true;\\n                d2[i - col + colArr.length - 1] = true;\\n                sum += solve( colArr, d1, d2, i + 1);\\n                colArr[col] = false;\\n                d1[i + col] = false;\\n                d2[i - col + colArr.length - 1] = false;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public int totalNQueens(int n) {\\n        return solve(new boolean[n], new boolean[2*n - 1], new boolean[2*n - 1], 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240241,
                "title": "cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    bool isSafe(vector<vector<int> >v1,int col,int row)\\n{\\n    int n=v1.size();\\n \\n    for(int i=0;i<row;i++){\\n       if(v1[i][col]==1)\\n           return false;\\n     }\\n   \\n     for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n       if(v1[i][j])\\n       return false;\\n \\n    for(int i=row-1,j=col+1;j<n&&i>=0;i--,j++)\\n     if(v1[i][j])\\n     return false;\\n     \\nreturn true;\\n}\\nvoid NQueen(vector<vector<int> >&v1,int row)\\n{\\n   \\n    if(row==v1.size()){\\n        count++;\\n      return;}\\n      for(int i=0;i<v1.size();i++)\\n      {\\n          if(isSafe(v1,i,row))\\n          {\\n              v1[row][i]=1;\\n              NQueen(v1,row+1);\\n            v1[row][i]=0;\\n          }\\n      }\\n      return ;\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int> >v1;\\n    \\n    for(int i=0;i<n;i++){\\n        vector<int>v2(n,0);\\n    v1.push_back(v2);}\\n    \\n    NQueen(v1,0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    bool isSafe(vector<vector<int> >v1,int col,int row)\\n{\\n    int n=v1.size();\\n \\n    for(int i=0;i<row;i++){\\n       if(v1[i][col]==1)\\n           return false;\\n     }\\n   \\n     for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n       if(v1[i][j])\\n       return false;\\n \\n    for(int i=row-1,j=col+1;j<n&&i>=0;i--,j++)\\n     if(v1[i][j])\\n     return false;\\n     \\nreturn true;\\n}\\nvoid NQueen(vector<vector<int> >&v1,int row)\\n{\\n   \\n    if(row==v1.size()){\\n        count++;\\n      return;}\\n      for(int i=0;i<v1.size();i++)\\n      {\\n          if(isSafe(v1,i,row))\\n          {\\n              v1[row][i]=1;\\n              NQueen(v1,row+1);\\n            v1[row][i]=0;\\n          }\\n      }\\n      return ;\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int> >v1;\\n    \\n    for(int i=0;i<n;i++){\\n        vector<int>v2(n,0);\\n    v1.push_back(v2);}\\n    \\n    NQueen(v1,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239159,
                "title": "c-backtracking-easy-to-understand-no-need-to-form-chess-board",
                "content": "```\\n/*\\n    A simple approach will be the same as N Queens problem. Instead of returning all the configurations of board (vector<vector<string>>),\\n    here we return the count of total configurations. Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/N-Queens.cpp\\n    \\n    But, you don\\'t need to form boards and configurations to count the total configurations. See the solution below.\\n*/\\nclass Solution {\\npublic:\\n    int count = 0;\\n    unordered_set<int> cols;\\n    unordered_set<int> diags;\\n    unordered_set<int> antiDiags;\\n    void dfs(int row, int n) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int d  = row-col;\\n            int ad = row+col;\\n            \\n            if(cols.count(col) || diags.count(d) || antiDiags.count(ad))\\n                continue;\\n            \\n            cols.insert(col);\\n            diags.insert(d);\\n            antiDiags.insert(ad);\\n            \\n            dfs(row+1, n);\\n            \\n            cols.erase(col);\\n            diags.erase(d);\\n            antiDiags.erase(ad);\\n            \\n        }\\n    }\\n    vector<vector<string>> result;\\n    int totalNQueens(int n) {\\n        count = 0;\\n        if(n == 1)\\n            return 1;\\n        if(n <= 3)\\n            return count;\\n        \\n        dfs(0, n);\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    A simple approach will be the same as N Queens problem. Instead of returning all the configurations of board (vector<vector<string>>),\\n    here we return the count of total configurations. Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/N-Queens.cpp\\n    \\n    But, you don\\'t need to form boards and configurations to count the total configurations. See the solution below.\\n*/\\nclass Solution {\\npublic:\\n    int count = 0;\\n    unordered_set<int> cols;\\n    unordered_set<int> diags;\\n    unordered_set<int> antiDiags;\\n    void dfs(int row, int n) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int d  = row-col;\\n            int ad = row+col;\\n            \\n            if(cols.count(col) || diags.count(d) || antiDiags.count(ad))\\n                continue;\\n            \\n            cols.insert(col);\\n            diags.insert(d);\\n            antiDiags.insert(ad);\\n            \\n            dfs(row+1, n);\\n            \\n            cols.erase(col);\\n            diags.erase(d);\\n            antiDiags.erase(ad);\\n            \\n        }\\n    }\\n    vector<vector<string>> result;\\n    int totalNQueens(int n) {\\n        count = 0;\\n        if(n == 1)\\n            return 1;\\n        if(n <= 3)\\n            return count;\\n        \\n        dfs(0, n);\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238410,
                "title": "c-easily-understandable-solution-derived-from-n-queens-hinglish-comments",
                "content": "class Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<string>> vec;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        recurse(vec,board,0,n);\\n        return vec.size();\\n    }\\n    \\n      void recurse( vector<vector<string>> &vec ,vector<string> &board , int row , int &n)\\n    {\\n        \\n        if(row == n)\\n        {\\n            vec.push_back(board);\\n            return;\\n        }\\n        \\n        //ek particular row to already selected h and now for each cell we have to traverse through column \\n        \\n        \\n        for(int col = 0 ; col < n ; col++)\\n        {\\n             if(isValid(board,row,col,n))\\n            {\\n                 board[row][col] = \\'Q\\';\\n                 /*ek baar uss place pe Q ko rakh ke aage proceed kiya agar ispe se koi answer derive ho paega to vo apne aap end me base condition ki vajah se answer(vec) me pushback ho jaega ab backtrack karne ke baad iss postion se queen ko hatana bhi to padega taaki multiple configurations try kar sake   */\\n                 recurse(vec,board,row+1,n); // Recursing row by row\\n                 board[row][col] = \\'.\\';// yahan pe q ko hataya h \\n            }\\n        }    \\n    }\\n    \\n    \\n    bool isValid(vector<string> &board ,int &row , int &col , int &n  )\\n    {\\n        \\n        for(int i=0;i<row;++i) // If column has queen already\\n        {\\n            if(board[i][col] == \\'Q\\')\\n                return false;\\n        } \\n        \\n        // If left diagonals have queen already \\n        for(int i=1;row-i>=0&&col-i>=0;++i)\\n        {\\n            if(board[row-i][col-i] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        // If right diagonal have queen already\\n        for(int i=1;row-i>=0&&col+i<n;++i)\\n        {\\n            if(board[row-i][col+i] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<string>> vec;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        recurse(vec,board,0,n);\\n        return vec.size();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1237841,
                "title": "python-short-recursion-easy-crisp",
                "content": "# N-Queens II\\n\\n**Complexity**\\n* Time Complexity -> `O(n!)` *(Since we have to check all possible permutations)*\\n* Space Complexity -> `O(n)` *(only set size of diagonals and columns)*\\n\\n\\n**[Note]**  *tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))*\\n\\nIn the above line I have incremented **row** by 1 and used **set\\'s union method(Operator |)**  to include diagonals and columns . For eg let\\'s take n=2, *[[00, 01], [10, 11]]*, then for diagonal 1 (col-row) -> *[[0, 1], [-1, 0]]* so it gives **diag1** set `{0, 1, -1}` and for diagonal 2 (col+row) -> *[[0, 1], [1, 2]]* it gives **diag2** `set {0, 1, 2}` , and for columns **cols** `set {0, 1}`\\n\\n\\n*Please upvote if you like the solution and comment if have any queries* .\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        def soln(row, diag1, diag2, cols):\\n            #if passing all the rows and columns of the grid then return 1 i.e. possible answer\\n            if row==n:\\n                return 1\\n            \\n            tot = 0\\n            for col in range(n):\\n                #checking for the grid of queen not in same diagonals and same columns \\n                if ((col-row) in diag1) or ((col+row) in diag2) or (col in cols):\\n                    continue\\n                 \\n                #if passed above condition then including this grid in diagonals and columns for next row\\n                tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))\\n            \\n            #Finally returning total no. of soluntions\\n            return tot\\n         \\n        #taking starting from row 0 sets of diagonal1 , diagonal2, columns\\n        return soln(0, set(), set(), set())\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        def soln(row, diag1, diag2, cols):\\n            #if passing all the rows and columns of the grid then return 1 i.e. possible answer\\n            if row==n:\\n                return 1\\n            \\n            tot = 0\\n            for col in range(n):\\n                #checking for the grid of queen not in same diagonals and same columns \\n                if ((col-row) in diag1) or ((col+row) in diag2) or (col in cols):\\n                    continue\\n                 \\n                #if passed above condition then including this grid in diagonals and columns for next row\\n                tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))\\n            \\n            #Finally returning total no. of soluntions\\n            return tot\\n         \\n        #taking starting from row 0 sets of diagonal1 , diagonal2, columns\\n        return soln(0, set(), set(), set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237750,
                "title": "n-queens-ii-c",
                "content": "The code written here is similar to the code, I gave before to the 1st part of it.\\nOnly the difference is here we want to count the number, so whenever we find a possible arrangement of queens we do ``ans++`` and finally return ans\\nMy previous post to the 1st part : https://leetcode.com/discuss/explore/may-leetcoding-challenge-2021/1223128/n-queens-c-backtracking\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n\\t\\t\\t\\t\\n        // we do not need to check column clashes as we place queens in different columns only\\n\\t\\t\\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)\\n        {\\n            ans++;   \\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);\\n                board[i][col]=\".\";\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n\\t\\t\\t\\t\\n        // we do not need to check column clashes as we place queens in different columns only\\n\\t\\t\\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)\\n        {\\n            ans++;   \\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);\\n                board[i][col]=\".\";\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224223,
                "title": "easy-to-understand-n-queens2-soln",
                "content": "```\\nclass Solution {\\n    \\n      char[][] board;\\n    List<List<String>> res;\\n    public int totalNQueens(int n) {\\n        solveNQueens(n);\\n      return res.size(); \\n    }\\n   List<List<String>> solveNQueens(int n) {\\n         board = new char[n][n];\\n         res = new ArrayList<List<String>>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        solveRec(0);\\n        return res;\\n    }\\n    List<String> construct() {\\n        List<String> res = new LinkedList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n\\tvoid solveRec(int col) {\\n\\t\\tint N = board.length;\\n\\t\\tif(col==N) {\\n          res.add(construct());\\n            return;\\n        }\\n\\t\\tfor(int i=0;i<N;i++) {\\n\\t\\t\\tif(isSafe(i,col)) {\\n\\t\\t\\t\\tboard[i][col]=\\'Q\\';\\n\\t\\t\\t\\tsolveRec(col+1);\\n\\t\\t\\t\\tboard[i][col]=\\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tboolean isSafe(int row,int col) {\\n\\t\\tfor(int i=0;i<col;i++) {\\n\\t\\t\\tif(board[row][i]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i< board.length&& j>=0;i++,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n      char[][] board;\\n    List<List<String>> res;\\n    public int totalNQueens(int n) {\\n        solveNQueens(n);\\n      return res.size(); \\n    }\\n   List<List<String>> solveNQueens(int n) {\\n         board = new char[n][n];\\n         res = new ArrayList<List<String>>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        solveRec(0);\\n        return res;\\n    }\\n    List<String> construct() {\\n        List<String> res = new LinkedList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n\\tvoid solveRec(int col) {\\n\\t\\tint N = board.length;\\n\\t\\tif(col==N) {\\n          res.add(construct());\\n            return;\\n        }\\n\\t\\tfor(int i=0;i<N;i++) {\\n\\t\\t\\tif(isSafe(i,col)) {\\n\\t\\t\\t\\tboard[i][col]=\\'Q\\';\\n\\t\\t\\t\\tsolveRec(col+1);\\n\\t\\t\\t\\tboard[i][col]=\\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tboolean isSafe(int row,int col) {\\n\\t\\tfor(int i=0;i<col;i++) {\\n\\t\\t\\tif(board[row][i]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i< board.length&& j>=0;i++,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223291,
                "title": "plain-backtracking-simple-c-code",
                "content": "Same as N-queen solution : \\nhttps://leetcode.com/problems/n-queens/discuss/1223282/Plain-Backtracking-Simple-C%2B%2B-code-with-comments\\n```\\nclass Solution {\\n    bool isRowFree(vector<string> &board, int row){\\n        int n = board.size();\\n        for(int col = 0; col < n; col++)\\n            if(board[row][col] == \\'Q\\') return false;\\n        return true;\\n    }\\n    bool isDiagonalFree(vector<string> &board, int row, int col){\\n        int n = board.size();\\n        int i = row, j = col;\\n        \\n        //Only need to check left side diagonals\\n        while(i >= 0 && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i--, j--;\\n        }\\n        i = row, j = col;\\n        while(i < n && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    void solve(vector<string> &board, int curr_col,int &ans){\\n        int n = board.size();\\n        \\n        if(curr_col == n){\\n            ans++;\\n            return;\\n        } \\n        \\n        //Check for valid row for curr_col where queen can be placed\\n        for(int curr_row = 0; curr_row < n; curr_row++){\\n            if(isRowFree(board, curr_row)  &&                \\n               isDiagonalFree(board, curr_row, curr_col))\\n            {\\n                board[curr_row][curr_col] = \\'Q\\';\\n                solve(board,curr_col+1,ans);\\n                board[curr_row][curr_col] = \\'.\\';   //backtrack step\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        vector<string> board (n ,string(n,\\'.\\'));\\n        int ans=0;\\n        \\n        solve(board, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isRowFree(vector<string> &board, int row){\\n        int n = board.size();\\n        for(int col = 0; col < n; col++)\\n            if(board[row][col] == \\'Q\\') return false;\\n        return true;\\n    }\\n    bool isDiagonalFree(vector<string> &board, int row, int col){\\n        int n = board.size();\\n        int i = row, j = col;\\n        \\n        //Only need to check left side diagonals\\n        while(i >= 0 && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i--, j--;\\n        }\\n        i = row, j = col;\\n        while(i < n && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    void solve(vector<string> &board, int curr_col,int &ans){\\n        int n = board.size();\\n        \\n        if(curr_col == n){\\n            ans++;\\n            return;\\n        } \\n        \\n        //Check for valid row for curr_col where queen can be placed\\n        for(int curr_row = 0; curr_row < n; curr_row++){\\n            if(isRowFree(board, curr_row)  &&                \\n               isDiagonalFree(board, curr_row, curr_col))\\n            {\\n                board[curr_row][curr_col] = \\'Q\\';\\n                solve(board,curr_col+1,ans);\\n                board[curr_row][curr_col] = \\'.\\';   //backtrack step\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        vector<string> board (n ,string(n,\\'.\\'));\\n        int ans=0;\\n        \\n        solve(board, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147551,
                "title": "c-backtracking-4ms-memory-99-9",
                "content": "class Solution {\\npublic:\\n\\n    int vis[9][9] ={0};\\n    int cnt=0;\\n    bool isvalid( int i, int j, int n){\\n        int x = i -1;\\n        while(x>=0){\\n            if(vis[x][j]){\\n                return false;\\n            }\\n            x--;\\n        }\\n        x = i -1;\\n        int y= j -1;\\n        while(x>=0 && y>=0){\\n            if(vis[x][y]){\\n                return false;\\n            }\\n            x--;y--;\\n        }\\n        x = i-1;\\n        y = j+1;\\n        while(x>=0 && y<n){\\n            if(vis[x][y]){\\n                return false;\\n            }\\n            x--;y++;\\n        }\\n        return true;\\n    }\\n    \\n    void countNQ(int r, int n){\\n        if(r == n){\\n            cnt++;\\n            return;\\n        }\\n\\n        for(int c= 0; c<n; c++){\\n            if(isvalid(r, c,n)){\\n                vis[r][c] = 1;\\n                countNQ(r+1, n);\\n                vis[r][c] = 0;\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        // vector<vector<int>>vis(n, vector<int>(n));\\n        countNQ(0,n);\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int vis[9][9] ={0}",
                "codeTag": "Java"
            },
            {
                "id": 916375,
                "title": "python-easy-solution-with-comments-95-7-faster",
                "content": "class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        \\n        #initializing the variables column, left digonal, right digonal, result\\n        col=[0]*(n+1); left_diag=[0]*(50); right_diag=[0]*(50);self.result=0\\n        \\n        #here is the main function\\n        def nqueen(c,n,ans):\\n            \\n            #if all columns are filled return True\\n            if c>=n: return True\\n            \\n            #traversing through every row\\n            for r in range(n):\\n                \\n                #if it is safe\\n                if col[r]!=1 and left_diag[r-c+n-1]!=1 and right_diag[r+c]!=1:\\n                    \\n                    #then we will update corresponding values to 1\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=1\\n                    \\n                    #if the the total board is filled then we will make result+1\\n                    if nqueen(c+1,n,ans): self.result+=1\\n                        \\n                    #if there was no way to fill backtrack and set all values to 0\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=0\\n        \\n        #here we are creating the empty grid\\n        grid=[[0]*n for i in range(n)]\\n        #calling main function\\n        nqueen(0,n,grid)\\n        \\n        return self.result",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        \\n        #initializing the variables column, left digonal, right digonal, result\\n        col=[0]*(n+1); left_diag=[0]*(50); right_diag=[0]*(50);self.result=0\\n        \\n        #here is the main function\\n        def nqueen(c,n,ans):\\n            \\n            #if all columns are filled return True\\n            if c>=n: return True\\n            \\n            #traversing through every row\\n            for r in range(n):\\n                \\n                #if it is safe\\n                if col[r]!=1 and left_diag[r-c+n-1]!=1 and right_diag[r+c]!=1:\\n                    \\n                    #then we will update corresponding values to 1\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=1\\n                    \\n                    #if the the total board is filled then we will make result+1\\n                    if nqueen(c+1,n,ans): self.result+=1\\n                        \\n                    #if there was no way to fill backtrack and set all values to 0\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=0\\n        \\n        #here we are creating the empty grid\\n        grid=[[0]*n for i in range(n)]\\n        #calling main function\\n        nqueen(0,n,grid)\\n        \\n        return self.result",
                "codeTag": "Java"
            },
            {
                "id": 827234,
                "title": "go-backtracking-solution",
                "content": "This is an easier version of #51.\\n\\nMore Go LC solutions:\\nhttps://github.com/phea/leetcode-go\\n\\n```go\\nfunc totalNQueens(n int) int {\\n\\tcol := make([]int, n)\\n\\tdiag := make([]int, n*2)\\n\\tdiag2 := make([]int, n*2)\\n\\tvar count int\\n\\tvar search func(y int)\\n\\tsearch = func(y int) {\\n\\t\\tif y == n {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor x := 0; x < n; x++ {\\n\\t\\t\\tif col[x] != 0 || diag[x+y] != 0 || diag2[x-y+n-1] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 1, 1, 1\\n\\t\\t\\tsearch(y + 1)\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 0, 0, 0\\n\\t\\t}\\n\\t}\\n\\n\\tsearch(0)\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc totalNQueens(n int) int {\\n\\tcol := make([]int, n)\\n\\tdiag := make([]int, n*2)\\n\\tdiag2 := make([]int, n*2)\\n\\tvar count int\\n\\tvar search func(y int)\\n\\tsearch = func(y int) {\\n\\t\\tif y == n {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor x := 0; x < n; x++ {\\n\\t\\t\\tif col[x] != 0 || diag[x+y] != 0 || diag2[x-y+n-1] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 1, 1, 1\\n\\t\\t\\tsearch(y + 1)\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 0, 0, 0\\n\\t\\t}\\n\\t}\\n\\n\\tsearch(0)\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760728,
                "title": "java-backtracking-solution",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n           \\tList<List<Integer>> result= new ArrayList<List<Integer>>();\\n    \\tsolveNQueens(result, n, 0, new ArrayList<Integer>());\\n    \\treturn result.size();\\n    }\\n\\n\\tprivate static void solveNQueens(List<List<Integer>> result, int n, int row, ArrayList<Integer> colPlacement)\\n\\t{\\n\\t\\tif(row==n)\\n\\t\\t\\tresult.add(new ArrayList<Integer>(colPlacement));\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int col=0; col<n; col++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolPlacement.add(col);\\n\\t\\t\\t\\tif(placementIsValid(colPlacement))\\n\\t\\t\\t\\t\\tsolveNQueens(result, n, row+1, colPlacement);\\n\\t\\t\\t\\tcolPlacement.remove(colPlacement.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static boolean placementIsValid(ArrayList<Integer> colPlacement) \\n\\t{\\n\\t\\tint row= colPlacement.size()-1;\\n\\t\\tfor(int i=0; i<row; i++)\\n\\t\\t{\\n\\t\\t\\tint diff= Math.abs(colPlacement.get(i)-colPlacement.get(row));\\n\\t\\t\\tif(diff==0 || diff==(row-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n           \\tList<List<Integer>> result= new ArrayList<List<Integer>>();\\n    \\tsolveNQueens(result, n, 0, new ArrayList<Integer>());\\n    \\treturn result.size();\\n    }\\n\\n\\tprivate static void solveNQueens(List<List<Integer>> result, int n, int row, ArrayList<Integer> colPlacement)\\n\\t{\\n\\t\\tif(row==n)\\n\\t\\t\\tresult.add(new ArrayList<Integer>(colPlacement));\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int col=0; col<n; col++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolPlacement.add(col);\\n\\t\\t\\t\\tif(placementIsValid(colPlacement))\\n\\t\\t\\t\\t\\tsolveNQueens(result, n, row+1, colPlacement);\\n\\t\\t\\t\\tcolPlacement.remove(colPlacement.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static boolean placementIsValid(ArrayList<Integer> colPlacement) \\n\\t{\\n\\t\\tint row= colPlacement.size()-1;\\n\\t\\tfor(int i=0; i<row; i++)\\n\\t\\t{\\n\\t\\t\\tint diff= Math.abs(colPlacement.get(i)-colPlacement.get(row));\\n\\t\\t\\tif(diff==0 || diff==(row-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503671,
                "title": "swift-dsf-solution-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    var total:Int = 0\\n    \\n    func totalNQueens(_ n: Int) -> Int{\\n        var arr:[Int] = Array(repeating: 0, count: n)\\n        helper(&arr, 0)\\n        return total\\n    }\\n    \\n    func helper(_ arr: inout [Int],_ current: Int) {\\n        if current == arr.count{\\n            total += 1\\n            return\\n        }\\n        for i in 0..<arr.count{\\n            if !hasConflict(&arr, current, i){\\n                arr[current] = i\\n                helper(&arr, current+1)\\n            }\\n        }\\n    }\\n    \\n    func hasConflict(_ arr:inout[Int],_ row:Int,_ col:Int)->Bool{\\n        for i in 0..<row {\\n            if arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row {\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var total:Int = 0\\n    \\n    func totalNQueens(_ n: Int) -> Int{\\n        var arr:[Int] = Array(repeating: 0, count: n)\\n        helper(&arr, 0)\\n        return total\\n    }\\n    \\n    func helper(_ arr: inout [Int],_ current: Int) {\\n        if current == arr.count{\\n            total += 1\\n            return\\n        }\\n        for i in 0..<arr.count{\\n            if !hasConflict(&arr, current, i){\\n                arr[current] = i\\n                helper(&arr, current+1)\\n            }\\n        }\\n    }\\n    \\n    func hasConflict(_ arr:inout[Int],_ row:Int,_ col:Int)->Bool{\\n        for i in 0..<row {\\n            if arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row {\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480337,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nSame as [51. N-Queens](https://leetcode.com/problems/n-queens/discuss/480335/Javascript-and-C%2B%2B-solutions) except for the return value.  Instead of returning string reprenstations of the solutions, return the count of solutions.\\n\\n*Javascript*\\n```\\nvar totalNQueens = (N, cnt = 0) => {\\n    let A = Array(N).fill(-1); // index is the row and value is the column of each queen\\n    let ok = (i, j) => {\\n        if (A[i] > -1 || A.some(col => col == j) || A.some((col, row, A) => col > -1 && Math.abs(row - i) == Math.abs(col - j)))\\n            return false; // invalid row, col, or diag\\n        return true;\\n    };\\n    let dfs = (i = 0) => {\\n        if (i == N) {\\n            ++cnt;\\n            return;\\n        }\\n        for (let j = 0; j < N; ++j) {\\n            if (!ok(i, j))\\n                continue;\\n            A[i] = j,\\n            dfs(i + 1),\\n            A[i] = -1;            \\n        }\\n    };\\n    dfs();\\n    return cnt;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int totalNQueens(int N, VVI ans = {}, int cnt = 0) {\\n        VI A(N, -1); // row is index and col is value of each queen\\n        return dfs(A, ans);\\n    }\\nprivate:\\n    bool ok(VI& A, int i, int j) {\\n        if (A[i] > -1 || find(A.begin(), A.end(), j) != A.end())\\n            return false;\\n        for (auto row = 0; row < A.size(); ++row) {\\n            auto col = A[row];\\n            if (col > -1 && abs(row - i) == abs(col - j))\\n                return false;\\n        }\\n        return true;\\n    };\\n    int dfs(VI& A, VVI& ans, int i = 0, int cnt = 0) {\\n        auto N = A.size();\\n        if (i == N) {\\n            ans.push_back(A);\\n            return 1;\\n        }\\n        for (auto j = 0; j < N; ++j) {\\n            if (!ok(A, i, j))\\n                continue;\\n            A[i] = j;\\n            cnt += dfs(A, ans, i + 1);\\n            A[i] = -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar totalNQueens = (N, cnt = 0) => {\\n    let A = Array(N).fill(-1); // index is the row and value is the column of each queen\\n    let ok = (i, j) => {\\n        if (A[i] > -1 || A.some(col => col == j) || A.some((col, row, A) => col > -1 && Math.abs(row - i) == Math.abs(col - j)))\\n            return false; // invalid row, col, or diag\\n        return true;\\n    };\\n    let dfs = (i = 0) => {\\n        if (i == N) {\\n            ++cnt;\\n            return;\\n        }\\n        for (let j = 0; j < N; ++j) {\\n            if (!ok(i, j))\\n                continue;\\n            A[i] = j,\\n            dfs(i + 1),\\n            A[i] = -1;            \\n        }\\n    };\\n    dfs();\\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int totalNQueens(int N, VVI ans = {}, int cnt = 0) {\\n        VI A(N, -1); // row is index and col is value of each queen\\n        return dfs(A, ans);\\n    }\\nprivate:\\n    bool ok(VI& A, int i, int j) {\\n        if (A[i] > -1 || find(A.begin(), A.end(), j) != A.end())\\n            return false;\\n        for (auto row = 0; row < A.size(); ++row) {\\n            auto col = A[row];\\n            if (col > -1 && abs(row - i) == abs(col - j))\\n                return false;\\n        }\\n        return true;\\n    };\\n    int dfs(VI& A, VVI& ans, int i = 0, int cnt = 0) {\\n        auto N = A.size();\\n        if (i == N) {\\n            ans.push_back(A);\\n            return 1;\\n        }\\n        for (auto j = 0; j < N; ++j) {\\n            if (!ok(A, i, j))\\n                continue;\\n            A[i] = j;\\n            cnt += dfs(A, ans, i + 1);\\n            A[i] = -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386070,
                "title": "javascript",
                "content": "```\\nvar totalNQueens = function(n) {\\n    let res = 0;\\n    let board = [];\\n    function backtrack(r) {\\n        if(r === n) {\\n            res++;\\n            return;\\n        }\\n        for(let c = 0 ; c < n ; c++) {\\n            if(!board.some((bc, br) => \\n                          bc === c || bc - br === c - r || bc + br === c + r)) {\\n                board.push(c);\\n                backtrack(r + 1);\\n                board.pop();\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return res;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar totalNQueens = function(n) {\\n    let res = 0;\\n    let board = [];\\n    function backtrack(r) {\\n        if(r === n) {\\n            res++;\\n            return;\\n        }\\n        for(let c = 0 ; c < n ; c++) {\\n            if(!board.some((bc, br) => \\n                          bc === c || bc - br === c - r || bc + br === c + r)) {\\n                board.push(c);\\n                backtrack(r + 1);\\n                board.pop();\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368847,
                "title": "java-backtracking-solution-traditional-and-clean",
                "content": "```\\nclass Solution {\\n    /*\\n    \\u5BF9\\u4E8E\\u8FD9\\u7C7B\\u95EE\\u9898\\uFF0C\\u6CA1\\u6709\\u592A\\u7B80\\u4FBF\\u7684\\u65B9\\u6CD5\\uFF0C\\u53EA\\u80FD\\u4F7F\\u7528\\u7A77\\u4E3E\\u6CD5\\uFF0C\\u5C31\\u662F\\u5C1D\\u8BD5\\u6240\\u6709\\u7684\\u7EC4\\u5408\\uFF0C\\u6BCF\\u653E\\u7F6E\\u4E00\\u4E2A\\u65B0\\u7684\\u7687\\u540E\\u7684\\u65F6\\u5019\\uFF0C\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u8DDF\\u4E4B\\u524D\\u7684\\u6240\\u6709\\u7687\\u540E\\u4E0D\\u80FD\\u51B2\\u7A81\\uFF0C\\u82E5\\u53D1\\u751F\\u4E86\\u51B2\\u7A81\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u653E\\uFF0C\\u8981\\u91CD\\u65B0\\u627E\\u5730\\u65B9\\uFF0C\\u8FD9\\u4E2A\\u903B\\u8F91\\u975E\\u5E38\\u9002\\u5408\\u7528\\u9012\\u5F52\\u6765\\u505A\\u3002\\n    \\u6240\\u8C13\\u9012\\u5F52\\u56DE\\u6EAF\\uFF0C\\u672C\\u8D28\\u4E0A\\u662F\\u4E00\\u79CD\\u679A\\u4E3E\\u6CD5\\u3002\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4ECE\\u68CB\\u76D8\\u7684\\u7B2C\\u4E00\\u884C\\u5F00\\u59CB\\u5C1D\\u8BD5\\u6446\\u653E\\u7B2C\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u6446\\u653E\\u6210\\u529F\\u540E\\uFF0C\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u518D\\u9075\\u5FAA\\u89C4\\u5219\\u5728\\u68CB\\u76D8\\u7B2C\\u4E8C\\u884C\\u6765\\u6446\\u653E\\u7B2C\\u4E8C\\u4E2A\\u7687\\u540E\\u3002\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u65E0\\u6CD5\\u6446\\u653E\\uFF0C\\u5219\\u5411\\u53F3\\u79FB\\u52A8\\u4E00\\u683C\\u518D\\u6B21\\u5C1D\\u8BD5\\uFF0C\\u5982\\u679C\\u6446\\u653E\\u6210\\u529F\\uFF0C\\u5219\\u7EE7\\u7EED\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u6446\\u653E\\u7B2C\\u4E09\\u4E2A\\u7687\\u540E......\\n    \\u5982\\u679C\\u67D0\\u4E00\\u5C42\\u770B\\u904D\\u4E86\\u6240\\u6709\\u683C\\u5B50\\uFF0C\\u90FD\\u65E0\\u6CD5\\u6210\\u529F\\u6446\\u653E\\uFF0C\\u5219\\u56DE\\u6EAF\\u5230\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u8BA9\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\u53F3\\u79FB\\u4E00\\u683C\\uFF0C\\u518D\\u8FDB\\u884C\\u9012\\u5F52\\u3002\\u5982\\u679C\\u516B\\u4E2A\\u7687\\u540E\\u90FD\\u6446\\u653E\\u5B8C\\u6BD5\\u4E14\\u7B26\\u5408\\u89C4\\u5219\\uFF0C\\u90A3\\u4E48\\u5C31\\u5F97\\u5230\\u4E86\\u5176\\u4E2D\\u4E00\\u79CD\\u6B63\\u786E\\u7684\\u89E3\\u6CD5\\u3002\\n    */\\n    int results = 0;\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        \\n        List<Integer> queenPos = new ArrayList<>();\\n        search(queenPos, n);\\n        return results;\\n    }\\n    \\n    /*\\n     * results store all of the chessboards\\n     * queenPos store the column indices or the position of queens for each row\\n     */\\n    private void search(List<Integer> queenPos,\\n                        int n) {\\n        \\n        // there are already n queens in the list, \\n        // which means every row has been assigned a queen\\n        if (queenPos.size() == n) {\\n            results++;\\n            return;\\n        }\\n        \\n        for (int colIndex = 0; colIndex < n; colIndex++) {\\n            if (!isValid(queenPos, colIndex)) {\\n                continue;\\n            }\\n            queenPos.add(colIndex);\\n            search(queenPos, n);\\n            // backtracking, and explore if the queen can be placed into the next column\\n            queenPos.remove(queenPos.size() - 1);\\n        }\\n    }\\n    \\n    private boolean isValid(List<Integer> queenPos, int column) {\\n        int row = queenPos.size();\\n        for (int rowIndex = 0; rowIndex < row; rowIndex++) {\\n            int preQueenPos = queenPos.get(rowIndex);\\n            // same column, fail\\n            if (preQueenPos == column) {\\n                return false;\\n            }\\n            // left diagonal or right diagonal, fail\\n            if (rowIndex + preQueenPos == row + column \\n                || rowIndex - preQueenPos == row - column) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    \\u5BF9\\u4E8E\\u8FD9\\u7C7B\\u95EE\\u9898\\uFF0C\\u6CA1\\u6709\\u592A\\u7B80\\u4FBF\\u7684\\u65B9\\u6CD5\\uFF0C\\u53EA\\u80FD\\u4F7F\\u7528\\u7A77\\u4E3E\\u6CD5\\uFF0C\\u5C31\\u662F\\u5C1D\\u8BD5\\u6240\\u6709\\u7684\\u7EC4\\u5408\\uFF0C\\u6BCF\\u653E\\u7F6E\\u4E00\\u4E2A\\u65B0\\u7684\\u7687\\u540E\\u7684\\u65F6\\u5019\\uFF0C\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u8DDF\\u4E4B\\u524D\\u7684\\u6240\\u6709\\u7687\\u540E\\u4E0D\\u80FD\\u51B2\\u7A81\\uFF0C\\u82E5\\u53D1\\u751F\\u4E86\\u51B2\\u7A81\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u653E\\uFF0C\\u8981\\u91CD\\u65B0\\u627E\\u5730\\u65B9\\uFF0C\\u8FD9\\u4E2A\\u903B\\u8F91\\u975E\\u5E38\\u9002\\u5408\\u7528\\u9012\\u5F52\\u6765\\u505A\\u3002\\n    \\u6240\\u8C13\\u9012\\u5F52\\u56DE\\u6EAF\\uFF0C\\u672C\\u8D28\\u4E0A\\u662F\\u4E00\\u79CD\\u679A\\u4E3E\\u6CD5\\u3002\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4ECE\\u68CB\\u76D8\\u7684\\u7B2C\\u4E00\\u884C\\u5F00\\u59CB\\u5C1D\\u8BD5\\u6446\\u653E\\u7B2C\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u6446\\u653E\\u6210\\u529F\\u540E\\uFF0C\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u518D\\u9075\\u5FAA\\u89C4\\u5219\\u5728\\u68CB\\u76D8\\u7B2C\\u4E8C\\u884C\\u6765\\u6446\\u653E\\u7B2C\\u4E8C\\u4E2A\\u7687\\u540E\\u3002\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u65E0\\u6CD5\\u6446\\u653E\\uFF0C\\u5219\\u5411\\u53F3\\u79FB\\u52A8\\u4E00\\u683C\\u518D\\u6B21\\u5C1D\\u8BD5\\uFF0C\\u5982\\u679C\\u6446\\u653E\\u6210\\u529F\\uFF0C\\u5219\\u7EE7\\u7EED\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u6446\\u653E\\u7B2C\\u4E09\\u4E2A\\u7687\\u540E......\\n    \\u5982\\u679C\\u67D0\\u4E00\\u5C42\\u770B\\u904D\\u4E86\\u6240\\u6709\\u683C\\u5B50\\uFF0C\\u90FD\\u65E0\\u6CD5\\u6210\\u529F\\u6446\\u653E\\uFF0C\\u5219\\u56DE\\u6EAF\\u5230\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u8BA9\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\u53F3\\u79FB\\u4E00\\u683C\\uFF0C\\u518D\\u8FDB\\u884C\\u9012\\u5F52\\u3002\\u5982\\u679C\\u516B\\u4E2A\\u7687\\u540E\\u90FD\\u6446\\u653E\\u5B8C\\u6BD5\\u4E14\\u7B26\\u5408\\u89C4\\u5219\\uFF0C\\u90A3\\u4E48\\u5C31\\u5F97\\u5230\\u4E86\\u5176\\u4E2D\\u4E00\\u79CD\\u6B63\\u786E\\u7684\\u89E3\\u6CD5\\u3002\\n    */\\n    int results = 0;\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        \\n        List<Integer> queenPos = new ArrayList<>();\\n        search(queenPos, n);\\n        return results;\\n    }\\n    \\n    /*\\n     * results store all of the chessboards\\n     * queenPos store the column indices or the position of queens for each row\\n     */\\n    private void search(List<Integer> queenPos,\\n                        int n) {\\n        \\n        // there are already n queens in the list, \\n        // which means every row has been assigned a queen\\n        if (queenPos.size() == n) {\\n            results++;\\n            return;\\n        }\\n        \\n        for (int colIndex = 0; colIndex < n; colIndex++) {\\n            if (!isValid(queenPos, colIndex)) {\\n                continue;\\n            }\\n            queenPos.add(colIndex);\\n            search(queenPos, n);\\n            // backtracking, and explore if the queen can be placed into the next column\\n            queenPos.remove(queenPos.size() - 1);\\n        }\\n    }\\n    \\n    private boolean isValid(List<Integer> queenPos, int column) {\\n        int row = queenPos.size();\\n        for (int rowIndex = 0; rowIndex < row; rowIndex++) {\\n            int preQueenPos = queenPos.get(rowIndex);\\n            // same column, fail\\n            if (preQueenPos == column) {\\n                return false;\\n            }\\n            // left diagonal or right diagonal, fail\\n            if (rowIndex + preQueenPos == row + column \\n                || rowIndex - preQueenPos == row - column) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305056,
                "title": "c-99-beaten-using-backtracking-basic-hacking-code-the-road-coderz-codez",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        \\n        int aCol[n + 1];\\n        \\n        return countQueens(n, aCol, 0); \\n    }\\n    \\n    int countQueens(int n, int *pCol, int pIndex) {\\n        \\n        if (pIndex >= n) { return 1; }\\n        \\n        int aCount = 0;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            bool aBlocked = false;\\n            \\n            for (int aBack=pIndex-1;aBack>=0;aBack--) {\\n                \\n                if (pCol[aBack] == i) { aBlocked = true; }\\n                \\n                int aDiff = pCol[aBack] - i;\\n                if (aDiff < 0) { aDiff = -aDiff; }\\n                \\n                if ((pIndex - aBack) == aDiff) {\\n                    aBlocked = true;\\n                }\\n            }\\n            if (aBlocked) { continue; }\\n            \\n            pCol[pIndex] = i;\\n            \\n            aCount += countQueens(n, pCol, pIndex + 1);   \\n        }\\n        return aCount;\\n    }\\n    \\n};\\n```\\n\\nGG",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        \\n        int aCol[n + 1];\\n        \\n        return countQueens(n, aCol, 0); \\n    }\\n    \\n    int countQueens(int n, int *pCol, int pIndex) {\\n        \\n        if (pIndex >= n) { return 1; }\\n        \\n        int aCount = 0;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            bool aBlocked = false;\\n            \\n            for (int aBack=pIndex-1;aBack>=0;aBack--) {\\n                \\n                if (pCol[aBack] == i) { aBlocked = true; }\\n                \\n                int aDiff = pCol[aBack] - i;\\n                if (aDiff < 0) { aDiff = -aDiff; }\\n                \\n                if ((pIndex - aBack) == aDiff) {\\n                    aBlocked = true;\\n                }\\n            }\\n            if (aBlocked) { continue; }\\n            \\n            pCol[pIndex] = i;\\n            \\n            aCount += countQueens(n, pCol, pIndex + 1);   \\n        }\\n        return aCount;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299715,
                "title": "java-clean-bitwise-implementation-beats-100-0ms",
                "content": "```\\nclass Solution {\\n  \\n  private int size;\\n  private int count;\\n\\n  private void solve(int row, int ld, int rd) {\\n    if (row == size) {\\n      count++;\\n      return;\\n    }\\n    int pos = size & (~(row | ld | rd));\\n    while (pos != 0) {\\n      int p = pos & (-pos);\\n      pos -= p;\\n      solve(row + p, (ld + p) << 1, (rd + p) >> 1);\\n    }\\n  }\\n  \\n  public int totalNQueens(int n) {\\n    count = 0;\\n    size = (1 << n) - 1;\\n    solve(0, 0, 0);\\n    return count;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n  \\n  private int size;\\n  private int count;\\n\\n  private void solve(int row, int ld, int rd) {\\n    if (row == size) {\\n      count++;\\n      return;\\n    }\\n    int pos = size & (~(row | ld | rd));\\n    while (pos != 0) {\\n      int p = pos & (-pos);\\n      pos -= p;\\n      solve(row + p, (ld + p) << 1, (rd + p) >> 1);\\n    }\\n  }\\n  \\n  public int totalNQueens(int n) {\\n    count = 0;\\n    size = (1 << n) - 1;\\n    solve(0, 0, 0);\\n    return count;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196627,
                "title": "c-using-bit-manipulation",
                "content": "Need to consider the bit size.  \\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row, int cols, int pie, int na, int &n, int &count) {\\n        if (row >= n) {\\n            count++;\\n            return;\\n        }\\n\\n        int bits = ~(cols | pie | na) & (1 << n - 1);\\n        while (bits) {\\n            int x = bits & -bits;\\n            dfs(row + 1, cols | x, (pie | x) << 1, (na | x) >> 1, n, count);\\n            bits ^= x;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if (n < 1) {\\n            return 0;\\n        }\\n\\n        int ret = 0;\\n        dfs(0, 0, 0, 0, n, ret);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row, int cols, int pie, int na, int &n, int &count) {\\n        if (row >= n) {\\n            count++;\\n            return;\\n        }\\n\\n        int bits = ~(cols | pie | na) & (1 << n - 1);\\n        while (bits) {\\n            int x = bits & -bits;\\n            dfs(row + 1, cols | x, (pie | x) << 1, (na | x) >> 1, n, count);\\n            bits ^= x;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if (n < 1) {\\n            return 0;\\n        }\\n\\n        int ret = 0;\\n        dfs(0, 0, 0, 0, n, ret);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152108,
                "title": "a-nice-hack-might-be-very-informative-specially-for-new-users",
                "content": "For those who don\\'t know, this site can be of very much use.\\nThere\\'s this site: https://oeis.org/ (The online encyclopedia of integer sequence) which has all popular integer sequences. Number of solutions of NQueens is one among them.\\n\\nJust search for nQueen, you can see it here: https://oeis.org/search?q=nqueen&language=english&go=Search\\n\\nNow coming to the code\\n```cpp\\nint totalNQueens(int n) {\\n    int ans[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624};\\n    return ans[n - 1];\\n}\\n```\\n:P\\n",
                "solutionTags": [],
                "code": "```cpp\\nint totalNQueens(int n) {\\n    int ans[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624};\\n    return ans[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123480,
                "title": "java-beats-100-love-u-all",
                "content": "```\\nclass Solution {\\n    private static final int res[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104};\\n\\n    public int totalNQueens(int n) {\\n        if (n >= 1) {\\n            return res[n - 1];\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int res[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104};\\n\\n    public int totalNQueens(int n) {\\n        if (n >= 1) {\\n            return res[n - 1];\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20064,
                "title": "beat-me-fastest-c-15-queens-1000ms",
                "content": "15 queens ~ 1000ms\\n```\\nint N, NF;\\nint put(int n, int nw, int ne){\\n        if(n==NF)return 1;\\n        int res=0;\\n        nw>>=1;ne<<=1;\\n        int mask=( ~(n|nw|ne) ) & ( (1<<N) -1 );\\n        while(mask){\\n                int i=(mask&-mask);\\n                res+=put(n^i,nw^i,ne^i);\\n                mask-=i;\\n        }\\n        return res;\\n}\\nint totalNQueens(int n) {\\n        N=n;\\n        NF=(1<<N)-1;\\n        int i=1<<((N-1)/2);\\n        int mid=put(i,i,i);\\n        int res=mid;\\n        for(i>>=1;i;i>>=1){\\n                res+=put(i,i,i);\\n        }\\n        res+=res;\\n        if(N&1)res-=mid;\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint N, NF;\\nint put(int n, int nw, int ne){\\n        if(n==NF)return 1;\\n        int res=0;\\n        nw>>=1;ne<<=1;\\n        int mask=( ~(n|nw|ne) ) & ( (1<<N) -1 );\\n        while(mask){\\n                int i=(mask&-mask);\\n                res+=put(n^i,nw^i,ne^i);\\n                mask-=i;\\n        }\\n        return res;\\n}\\nint totalNQueens(int n) {\\n        N=n;\\n        NF=(1<<N)-1;\\n        int i=1<<((N-1)/2);\\n        int mid=put(i,i,i);\\n        int res=mid;\\n        for(i>>=1;i;i>>=1){\\n                res+=put(i,i,i);\\n        }\\n        res+=res;\\n        if(N&1)res-=mid;\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20096,
                "title": "java-ac-bit-m-over-98-low-space",
                "content": "public class Solution {\\n    \\n    int sum = 0, upperlim = 1;\\n    \\n    public int totalNQueens(int n) {\\n        upperlim = (upperlim << n) - 1; \\n        helper(0,0,0);\\n        return sum;\\n    }\\n    \\n    void helper(int row, int ld, int rd){  \\n        if (row != upperlim)  \\n        {  \\n            int pos = upperlim & ~(row | ld | rd);   \\n            while (pos>0)\\n            {  \\n                int p = pos & -pos;                                                \\n      \\n                pos -= p;                             \\n                \\n                helper(row + p, (ld + p) << 1, (rd + p) >> 1);                                \\n            }  \\n        }else{\\n            sum++;\\n        }  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    \\n    int sum = 0, upperlim = 1;\\n    \\n    public int totalNQueens(int n) {\\n        upperlim = (upperlim << n) - 1; \\n        helper(0,0,0);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20090,
                "title": "11-line-python-solution-easy-to-understand",
                "content": "    def totalNQueens(self, n):\\n        def dfs(board, row):\\n            if row == n: return 1\\n            count = 0\\n            for x in set_n - set(board):\\n                # check diagonal conflict\\n                if all(row - i != abs(x - y) for i, y in enumerate(board[:row])):\\n                    board[row] = x\\n                    count += dfs(board, row + 1)\\n                    board[row] = '.'\\n            return count\\n\\n        set_n = {i for i in xrange(n)}\\n        return dfs(['.'] * n, 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def totalNQueens(self, n):\\n        def dfs(board, row):\\n            if row == n: return 1\\n            count = 0\\n            for x in set_n - set(board):\\n                # check diagonal conflict\\n                if all(row - i != abs(x - y) for i, y in enumerate(board[:row])):\\n                    board[row] = x\\n                    count += dfs(board, row + 1)\\n                    board[row] = '.'\\n            return count\\n\\n        set_n = {i for i in xrange(n)}\\n        return dfs(['.'] * n, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 20086,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static boolean checkOk(int[] columnNumber, int row) {\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif (columnNumber[row] == columnNumber[i]\\n\\t\\t\\t\\t\\t|| Math.abs(i - row) == Math.abs(columnNumber[i] - columnNumber[row]))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void DFS(int n, int row, int[] columnNumber, int[] count) {\\n\\t\\tif (row == n)\\n\\t\\t\\tcount[0]++;\\n\\t\\telse {\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tcolumnNumber[row] = i;\\n\\t\\t\\t\\tif (checkOk(columnNumber, row))\\n\\t\\t\\t\\t\\tDFS(n, row + 1, columnNumber, count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int totalNQueens(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint[] columnNumber = new int[n];\\n\\t\\tint[] count = { 0 };\\n\\t\\tDFS(n, 0, columnNumber, count);\\n\\t\\treturn count[0];\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static boolean checkOk(int[] columnNumber, int row) {\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif (columnNumber[row] == columnNumber[i]\\n\\t\\t\\t\\t\\t|| Math.abs(i - row) == Math.abs(columnNumber[i] - columnNumber[row]))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void DFS(int n, int row, int[] columnNumber, int[] count) {\\n\\t\\tif (row == n)\\n\\t\\t\\tcount[0]++;\\n\\t\\telse {\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tcolumnNumber[row] = i;\\n\\t\\t\\t\\tif (checkOk(columnNumber, row))\\n\\t\\t\\t\\t\\tDFS(n, row + 1, columnNumber, count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int totalNQueens(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint[] columnNumber = new int[n];\\n\\t\\tint[] count = { 0 };\\n\\t\\tDFS(n, 0, columnNumber, count);\\n\\t\\treturn count[0];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 20137,
                "title": "java-accepted-clean-solutions-98-73",
                "content": "    public class Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        \\n        \\n        dfs(new int[n],0,n);\\n        return count;\\n    }\\n    public void dfs(int[] pos,int step,int n) {\\n        if(step==n) {\\n            \\n            count++;\\n            return;\\n        }\\n        for(int i=0;i<n;i++) {\\n            pos[step]=i;\\n            if(isvalid(pos,step)) {\\n                dfs(pos,step+1,n);\\n            }\\n        }\\n    }\\n    public boolean isvalid(int[] pos, int step) {\\n        for(int i=0;i<step;i++) {\\n            if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            \\n        }\\n        return true;\\n    }\\n   \\n   \\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        \\n        \\n        dfs(new int[n],0,n);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20139,
                "title": "short-c-solution-representing-board-as-vector-int",
                "content": "The basic idea is to represent the board as a vector of int, where each index is a column of the board, and each value is the row the queen is on. We can do this because all solutions have exactly one queen on every column. Then, for each column, we place a queen on each row and check if the board is valid. If it is, we recurse on the next column. Checking if the board is valid is straightforward - we just check the row and diagonals of the newest queen against the existing queens:\\n\\n    class Solution {\\n    public:\\n        bool isValid(const vector<int>& columns, int col) {\\n            for (int c = 0; c < col; ++c) {\\n                if ((columns[c] == columns[col])\\n                    || (col - c == columns[col] - columns[c])\\n                    || (col - c == columns[c] - columns[col])) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    \\n        int totalNQueens(vector<int>& columns, int col) {\\n            if (col == columns.size()) {\\n                return 1;\\n            }\\n            int total = 0;\\n            for (int row = 0; row < columns.size(); ++row) {\\n                columns[col] = row;\\n                if (isValid(columns, col)) {\\n                    total += totalNQueens(columns, col + 1);\\n                }\\n            }\\n            return total;\\n        }\\n    \\n        int totalNQueens(int n) {\\n            vector<int> columns(n, 0);\\n            return totalNQueens(columns, 0);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        bool isValid(const vector<int>& columns, int col) {\\n            for (int c = 0; c < col; ++c) {\\n                if ((columns[c] == columns[col])\\n                    || (col - c == columns[col] - columns[c])\\n                    || (col - c == columns[c] - columns[col])) {\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 20169,
                "title": "accepted-backtracking-python-solution-very-similar-to-the-solution-to-n-queens-i",
                "content": "    class Solution:\\n        # @return an integer\\n        def totalNQueens(self, n):\\n            self.num = 0\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.num\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                self.num += 1\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True\\n\\nJust changed from appending all possible boards to self.result to incrementing self.num by 1 every time when a possible board is found.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return an integer\\n        def totalNQueens(self, n):\\n            self.num = 0\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.num\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                self.num += 1\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True\\n\\nJust changed from appending all possible boards to self.result to incrementing self.num by 1 every time when a possible board is found.",
                "codeTag": "Java"
            },
            {
                "id": 4076593,
                "title": "easy-fast-solution-using-backtracking-and-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }\\n    static int queens(boolean [][] board,int row) {\\n\\t\\tif(row == board.length) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint count=0;\\n        for (int col = 0; col < board.length; col++) {\\n\\t\\t    if(isSafe(board,row,col)) {\\n\\t\\t\\t    board[row][col] = true;\\n\\t\\t\\t    count += queens(board, row+1);\\n\\t\\t\\t    board[row][col] = false;\\n\\t\\t    }\\n\\t    }\\n\\t\\treturn count;\\n\\t}\\n\\tstatic boolean isSafe(boolean[][] board, int row, int col) {\\n\\t\\t\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif(board[i][col]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLeft = Math.min(row, col);\\n\\t\\tfor(int i= 1 ;i<=maxLeft;i++) {\\n\\t\\t\\tif (board[row-i][col-i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxRight = Math.min(row, board.length-col-1);\\n\\t\\tfor (int i = 1; i <= maxRight; i++) {\\n\\t\\t\\tif(board[row-i][col+i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }\\n    static int queens(boolean [][] board,int row) {\\n\\t\\tif(row == board.length) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint count=0;\\n        for (int col = 0; col < board.length; col++) {\\n\\t\\t    if(isSafe(board,row,col)) {\\n\\t\\t\\t    board[row][col] = true;\\n\\t\\t\\t    count += queens(board, row+1);\\n\\t\\t\\t    board[row][col] = false;\\n\\t\\t    }\\n\\t    }\\n\\t\\treturn count;\\n\\t}\\n\\tstatic boolean isSafe(boolean[][] board, int row, int col) {\\n\\t\\t\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif(board[i][col]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLeft = Math.min(row, col);\\n\\t\\tfor(int i= 1 ;i<=maxLeft;i++) {\\n\\t\\t\\tif (board[row-i][col-i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxRight = Math.min(row, board.length-col-1);\\n\\t\\tfor (int i = 1; i <= maxRight; i++) {\\n\\t\\t\\tif(board[row-i][col+i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018517,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n       return solve(board, 0, solutions);\\n       \\n        \\n    }\\n     static int solve(boolean[][] board, int row, List<List<String>> solutions) {\\n        if (row == board.length) {\\n            solutions.add(display(board));\\n            return 1;\\n        }\\n            int count = 0;\\n        for (int col = 0; col < board.length; col++) {\\n            if (isSafe(board, row, col)) {\\n                board[row][col] = true;\\n               count+=solve(board, row + 1, solutions);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isSafe(boolean[][] board, int row, int col) {\\n        for (int i = 0; i < row; i++) {\\n            if (board[i][col]) {\\n                return false;\\n            }\\n        }\\n        int maxLeft = Math.min(row, col);\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if (board[row - i][col - i]) {\\n                return false;\\n            }\\n        }\\n        int maxRight = Math.min(row, board.length - col - 1);\\n        for (int i = 1; i <= maxRight; i++) {\\n            if (board[row - i][col + i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static ArrayList<String> display(boolean[][] board) {\\n        ArrayList<String> list = new ArrayList<>();\\n        for (boolean[] arr : board) {\\n            StringBuilder row = new StringBuilder();\\n            for (boolean num : arr) {\\n                if (num) {\\n                    row.append(\"Q\");\\n                } else {\\n                    row.append(\".\");\\n                }\\n            }\\n            list.add(row.toString());\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n       return solve(board, 0, solutions);\\n       \\n        \\n    }\\n     static int solve(boolean[][] board, int row, List<List<String>> solutions) {\\n        if (row == board.length) {\\n            solutions.add(display(board));\\n            return 1;\\n        }\\n            int count = 0;\\n        for (int col = 0; col < board.length; col++) {\\n            if (isSafe(board, row, col)) {\\n                board[row][col] = true;\\n               count+=solve(board, row + 1, solutions);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isSafe(boolean[][] board, int row, int col) {\\n        for (int i = 0; i < row; i++) {\\n            if (board[i][col]) {\\n                return false;\\n            }\\n        }\\n        int maxLeft = Math.min(row, col);\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if (board[row - i][col - i]) {\\n                return false;\\n            }\\n        }\\n        int maxRight = Math.min(row, board.length - col - 1);\\n        for (int i = 1; i <= maxRight; i++) {\\n            if (board[row - i][col + i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static ArrayList<String> display(boolean[][] board) {\\n        ArrayList<String> list = new ArrayList<>();\\n        for (boolean[] arr : board) {\\n            StringBuilder row = new StringBuilder();\\n            for (boolean num : arr) {\\n                if (num) {\\n                    row.append(\"Q\");\\n                } else {\\n                    row.append(\".\");\\n                }\\n            }\\n            list.add(row.toString());\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929358,
                "title": "2-approaches-100-faster-o-1-lookup-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    // bool isSafe(int r, int c, vector<vector<int>> &board){\\n    //     //Upper\\n    //     for(int i = r-1; i >= 0; --i){\\n    //         if(board[i][c]) return false;\\n    //     }\\n\\n    //     //UL\\n    //     for(int i = r-1, j = c-1; i >= 0 && j >= 0; --i, --j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     //UR\\n    //     for(int i = r-1, j = c+1; i >= 0 && j < n; --i, ++j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     return true;\\n    // }\\n    // int f(int row, vector<vector<int>> &board){\\n    //     if(row == n) return 1;\\n\\n    //     int count = 0;\\n    //     for(int i = 0; i < n; ++i){\\n    //         if(isSafe(row, i, board)){\\n    //             board[row][i] = 1;\\n    //             count += f(row+1, board);\\n    //             board[row][i] = 0;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }\\n    int f(int row, vector<bool> &u, vector<bool> &ul, vector<bool> &ur){\\n        if(row == n) return 1;\\n        int count = 0;\\n        for(int col = 0; col < n; ++col){\\n            if(u[col] && ul[n-1+row-col] && ur[row+col]){\\n                u[col] = false;\\n                ul[n-1+row-col] = false;\\n                ur[row+col] = false;\\n                count += f(row+1, u, ul, ur);\\n                u[col] = true;\\n                ul[n-1+row-col] = true;\\n                ur[row+col] = true;\\n            }\\n        }\\n        return count;\\n    }\\n    int totalNQueens(int N) {\\n        n = N;\\n        // vector<vector<int>> board(n, vector<int>(n, 0));\\n        vector<bool> u(n, true), ul(2*n-1, true), ur(2*n-1, true);\\n        return f(0, u, ul, ur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    // bool isSafe(int r, int c, vector<vector<int>> &board){\\n    //     //Upper\\n    //     for(int i = r-1; i >= 0; --i){\\n    //         if(board[i][c]) return false;\\n    //     }\\n\\n    //     //UL\\n    //     for(int i = r-1, j = c-1; i >= 0 && j >= 0; --i, --j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     //UR\\n    //     for(int i = r-1, j = c+1; i >= 0 && j < n; --i, ++j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     return true;\\n    // }\\n    // int f(int row, vector<vector<int>> &board){\\n    //     if(row == n) return 1;\\n\\n    //     int count = 0;\\n    //     for(int i = 0; i < n; ++i){\\n    //         if(isSafe(row, i, board)){\\n    //             board[row][i] = 1;\\n    //             count += f(row+1, board);\\n    //             board[row][i] = 0;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }\\n    int f(int row, vector<bool> &u, vector<bool> &ul, vector<bool> &ur){\\n        if(row == n) return 1;\\n        int count = 0;\\n        for(int col = 0; col < n; ++col){\\n            if(u[col] && ul[n-1+row-col] && ur[row+col]){\\n                u[col] = false;\\n                ul[n-1+row-col] = false;\\n                ur[row+col] = false;\\n                count += f(row+1, u, ul, ur);\\n                u[col] = true;\\n                ul[n-1+row-col] = true;\\n                ur[row+col] = true;\\n            }\\n        }\\n        return count;\\n    }\\n    int totalNQueens(int N) {\\n        n = N;\\n        // vector<vector<int>> board(n, vector<int>(n, 0));\\n        vector<bool> u(n, true), ul(2*n-1, true), ur(2*n-1, true);\\n        return f(0, u, ul, ur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876811,
                "title": "beats-100-commented-bet-easiest-to-understand-used-safe-state-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool safe(int *place,int row,int col){\\n               for(int i=0;i<row;i++){\\n                   if(place[i]==col) return false;\\n                   if(abs(row-i)==abs(col-place[i])) return false;\\n               }\\n               return true;\\n    }\\n    void nqueen(int n,int row,int *place,int *sum){\\n                  for(int i=0;i<n;i++){\\n                if(safe(place,row,i)){\\n                   place[row]=i;\\n                   if(row==n-1) (*sum)+=1;\\n                   else nqueen(n,row+1,place,sum);\\n                }     \\n                \\n                \\n           }\\n    }\\n    int totalNQueens(int n) {\\n        int place[n];\\n        int sum=0;\\nnqueen(n,0,place,&sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool safe(int *place,int row,int col){\\n               for(int i=0;i<row;i++){\\n                   if(place[i]==col) return false;\\n                   if(abs(row-i)==abs(col-place[i])) return false;\\n               }\\n               return true;\\n    }\\n    void nqueen(int n,int row,int *place,int *sum){\\n                  for(int i=0;i<n;i++){\\n                if(safe(place,row,i)){\\n                   place[row]=i;\\n                   if(row==n-1) (*sum)+=1;\\n                   else nqueen(n,row+1,place,sum);\\n                }     \\n                \\n                \\n           }\\n    }\\n    int totalNQueens(int n) {\\n        int place[n];\\n        int sum=0;\\nnqueen(n,0,place,&sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862732,
                "title": "simplest-solution-100-sc-tc-using-recursion-backtracking",
                "content": "# Intuition\\nWe improve this from the N Quuens 1 by taking the advantage that we do not need the whole board, we just need to know the location of queens. We use a vector of pairs to store the location of our queens. We simply follow the recursive approach.\\n\\n# Approach\\nWe store the queens in a vector of pairs & increase the value of the counter whenever we get the size of the queens vector = n. To check the validity of placing queens we simply check if they\\'re in the same row or same column. Or check the mod of the difference between the row and previous rows & col and previous columns.\\n\\n# Complexity\\n- Time complexity:\\nO( N * 2^N ) - Because recursion is 2^N & our check function is N.\\n\\n# Space complexity:\\nO(N) - Because we just use a 1 dimensional vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int count = 0;\\n        vector<pair<int , int>> queens;\\n        int col = 0;\\n        compute( col, queens, count, n);\\n\\n        return count;\\n    }\\n\\n    void compute( int col, vector<pair<int , int>>& queens, int& count, int n){\\n\\n        if( queens.size() == n){\\n            count++;\\n            return;\\n        }\\n\\n        for( int row = 0; row<n; row++ ){\\n            if( check( row, col, queens, n) ){\\n                queens.push_back({row, col});\\n                compute( col+ 1, queens, count, n);\\n                queens.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    bool check( int row, int col, vector<pair<int , int>>& queens, int n){\\n\\n        for( int i = 0; i< queens.size(); i++){\\n            int prow = queens[i].first;\\n            int pcol = queens[i].second;\\n\\n            if( pcol == col || abs(pcol - col) == abs(prow - row) || prow == row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int count = 0;\\n        vector<pair<int , int>> queens;\\n        int col = 0;\\n        compute( col, queens, count, n);\\n\\n        return count;\\n    }\\n\\n    void compute( int col, vector<pair<int , int>>& queens, int& count, int n){\\n\\n        if( queens.size() == n){\\n            count++;\\n            return;\\n        }\\n\\n        for( int row = 0; row<n; row++ ){\\n            if( check( row, col, queens, n) ){\\n                queens.push_back({row, col});\\n                compute( col+ 1, queens, count, n);\\n                queens.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    bool check( int row, int col, vector<pair<int , int>>& queens, int n){\\n\\n        for( int i = 0; i< queens.size(); i++){\\n            int prow = queens[i].first;\\n            int pcol = queens[i].second;\\n\\n            if( pcol == col || abs(pcol - col) == abs(prow - row) || prow == row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862026,
                "title": "python-96-52-faster-two-approaches",
                "content": "**Brute Force Approch:**\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,board):\\n            i,j=row,col\\n            while i>=0 and j>=0: # for diagonaly upwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i-=1\\n                j-=1\\n            i,j=row,col\\n            while i<n and j>=0: # for diagonaly downwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i+=1\\n                j-=1\\n            while col>=0: # for checking the same column\\n                if board[row][col]==\\'Q\\':\\n                    return False\\n                col-=1\\n            return True\\n        \\n        def solve(c,board):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,board):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    solve(c+1,board)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        ans=[]\\n        solve(0,board)\\n        return len(ans)       \\n```\\n**Optimized Approach:**\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,same_row,left_up,left_down):\\n            if row in same_row:\\n                return False\\n            if (n-1+col-row) in left_up:\\n                return False\\n            if (row+col) in left_down:\\n                return False\\n            return True\\n        \\n        def solve(c,board,same_row,left_up,left_down):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,same_row,left_up,left_down):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    same_row.add(i)\\n                    left_up.add(n-1+c-i)\\n                    left_down.add(i+c)\\n                    solve(c+1,board,same_row,left_up,left_down)\\n                    same_row.remove(i)\\n                    left_up.remove(n-1+c-i)\\n                    left_down.remove(i+c)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        same_row=set()\\n        left_up=set()\\n        left_down=set()\\n        ans=[]\\n        solve(0,board,same_row,left_up,left_down)\\n        return len(ans)\\n```\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,board):\\n            i,j=row,col\\n            while i>=0 and j>=0: # for diagonaly upwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i-=1\\n                j-=1\\n            i,j=row,col\\n            while i<n and j>=0: # for diagonaly downwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i+=1\\n                j-=1\\n            while col>=0: # for checking the same column\\n                if board[row][col]==\\'Q\\':\\n                    return False\\n                col-=1\\n            return True\\n        \\n        def solve(c,board):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,board):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    solve(c+1,board)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        ans=[]\\n        solve(0,board)\\n        return len(ans)       \\n```\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,same_row,left_up,left_down):\\n            if row in same_row:\\n                return False\\n            if (n-1+col-row) in left_up:\\n                return False\\n            if (row+col) in left_down:\\n                return False\\n            return True\\n        \\n        def solve(c,board,same_row,left_up,left_down):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,same_row,left_up,left_down):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    same_row.add(i)\\n                    left_up.add(n-1+c-i)\\n                    left_down.add(i+c)\\n                    solve(c+1,board,same_row,left_up,left_down)\\n                    same_row.remove(i)\\n                    left_up.remove(n-1+c-i)\\n                    left_down.remove(i+c)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        same_row=set()\\n        left_up=set()\\n        left_down=set()\\n        ans=[]\\n        solve(0,board,same_row,left_up,left_down)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847808,
                "title": "similar-n-queens-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public boolean issafe(int row,int col,char board[][]){\\n           //horizantal\\n           for(int j=0;j<board.length;j++){\\n               if(board[row][j]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //vertical\\n           for(int i=0;i<board[0].length;i++){\\n               if(board[i][col]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperleft\\n           int r=row;\\n           for(int c=col;c>=0&&r>=0;c--,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperright\\n            r=row;\\n           for(int c=col;c<board.length&&r>=0;c++,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerleft\\n            r=row;\\n           for(int c=col;c>=0&&r<board[0].length;c--,r++){\\n                if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerright\\n           return true;\\n       }\\n    public void combine(List<List<String>> list,char board[][]){\\n        List<String> currboard=new ArrayList<>();\\n        for(int row=0;row<board.length;row++){\\n            String curr=\"\";\\n            for(int col=0;col<board[0].length;col++){\\n                if(board[row][col]==\\'Q\\'){\\n                    curr+=\\'Q\\';\\n                }\\n                else{\\n                    curr+=\\'.\\';\\n                }\\n            }\\n            currboard.add(curr);\\n        }\\n        list.add(currboard);\\n    }\\n    public void solve(List<List<String>> list,char board[][],int col){\\n        if(col==board.length){\\n            combine(list,board);\\n            return ;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(issafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(list,board,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n        List<List<String>> list=new ArrayList<>();\\n        char board[][]=new char[n][n];\\n        solve(list,board,0);\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public boolean issafe(int row,int col,char board[][]){\\n           //horizantal\\n           for(int j=0;j<board.length;j++){\\n               if(board[row][j]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //vertical\\n           for(int i=0;i<board[0].length;i++){\\n               if(board[i][col]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperleft\\n           int r=row;\\n           for(int c=col;c>=0&&r>=0;c--,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperright\\n            r=row;\\n           for(int c=col;c<board.length&&r>=0;c++,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerleft\\n            r=row;\\n           for(int c=col;c>=0&&r<board[0].length;c--,r++){\\n                if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerright\\n           return true;\\n       }\\n    public void combine(List<List<String>> list,char board[][]){\\n        List<String> currboard=new ArrayList<>();\\n        for(int row=0;row<board.length;row++){\\n            String curr=\"\";\\n            for(int col=0;col<board[0].length;col++){\\n                if(board[row][col]==\\'Q\\'){\\n                    curr+=\\'Q\\';\\n                }\\n                else{\\n                    curr+=\\'.\\';\\n                }\\n            }\\n            currboard.add(curr);\\n        }\\n        list.add(currboard);\\n    }\\n    public void solve(List<List<String>> list,char board[][],int col){\\n        if(col==board.length){\\n            combine(list,board);\\n            return ;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(issafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(list,board,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n        List<List<String>> list=new ArrayList<>();\\n        char board[][]=new char[n][n];\\n        solve(list,board,0);\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764769,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n// IF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!\\n\\n![download.png](https://assets.leetcode.com/users/images/1e5393d0-c496-46d8-a339-1d7e7241754f_1689346738.066668.png)\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        boolean board[][]=new boolean[n][n];\\n        return queens(board,0);    }\\n      int queens(boolean[][]board,int row)\\n    {   if(row == board.length)  return 1;\\n        int count=0;\\n        // place the queen and check row and colum\\n        for(int col=0;col<board.length;col++)\\n         // place the queen if it is safe\\n        if(isSafe(board,row,col))\\n        { board[row][col]=true;\\n          count+=queens(board,row + 1);\\n          board[row][col]=false;\\n         }\\n          return count;\\n    }   \\n  boolean isSafe(boolean [][] board,int row,int col)\\n  { // checking verticle \\n    for(int i=0;i<row;i++)\\n    if(board[i][col]) return false;\\n     // checking left digonal\\n    int maxLeft=Math.min(row,col);\\n    for(int i=1;i<=maxLeft;i++)\\n    if(board[row -i][col -i]) return false;\\n    // checking right digonal\\n    int maxRight=Math.min(row,board.length - col -1);\\n    for( int i=1;i<=maxRight;i++)\\n    if(board[row - i][col + i]) return false;\\n     // if none of the check is false, means ans is true\\n     return true;\\n   }\\n }\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int totalNQueens(int n) {\\n        boolean board[][]=new boolean[n][n];\\n        return queens(board,0);    }",
                "codeTag": "Java"
            },
            {
                "id": 3700252,
                "title": "c-follows-from-n-queens-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<string>& temp,int i,int j){\\n        for(int k=0;k<temp.size();k++){\\n            if(temp[k][j]==\\'Q\\' || temp[i][k]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int a=i,b=j;\\n        while(a>=0 && b<temp.size()){\\n            if(temp[a][b]==\\'Q\\'){\\n                return false;\\n            }\\n            a--;b++;\\n        }\\n        int c=i,d=j;\\n        while(c>=0 && d>=0){\\n            if(temp[c][d]==\\'Q\\'){\\n                return false;\\n            }\\n            c--;\\n            d--;\\n        }\\n        return true;\\n    }\\n    bool helper(int i, vector<string>& temp, vector<vector<string>>& store){\\n        //base case\\n        if(i==temp.size()){\\n            store.push_back(temp);\\n            return false;\\n        }\\n        //recursive case\\n        for(int j=0;j<temp.size();j++){\\n            if(isValid(temp,i,j)){\\n                temp[i][j]=\\'Q\\';\\n                bool remaining= helper(i+1,temp,store);\\n                if(remaining==true){\\n                    return true;\\n                }\\n                temp[i][j]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    int totalNQueens(int n) {\\n        int ans1;\\n        vector<vector<string>> store;\\n        vector<string> temp;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            ans += \".\";\\n        }\\n        for(int i=0;i<n;i++){\\n            temp.push_back(ans);\\n        }\\n        int i=0;\\n        helper(i,temp,store);\\n        ans1=store.size();\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<string>& temp,int i,int j){\\n        for(int k=0;k<temp.size();k++){\\n            if(temp[k][j]==\\'Q\\' || temp[i][k]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int a=i,b=j;\\n        while(a>=0 && b<temp.size()){\\n            if(temp[a][b]==\\'Q\\'){\\n                return false;\\n            }\\n            a--;b++;\\n        }\\n        int c=i,d=j;\\n        while(c>=0 && d>=0){\\n            if(temp[c][d]==\\'Q\\'){\\n                return false;\\n            }\\n            c--;\\n            d--;\\n        }\\n        return true;\\n    }\\n    bool helper(int i, vector<string>& temp, vector<vector<string>>& store){\\n        //base case\\n        if(i==temp.size()){\\n            store.push_back(temp);\\n            return false;\\n        }\\n        //recursive case\\n        for(int j=0;j<temp.size();j++){\\n            if(isValid(temp,i,j)){\\n                temp[i][j]=\\'Q\\';\\n                bool remaining= helper(i+1,temp,store);\\n                if(remaining==true){\\n                    return true;\\n                }\\n                temp[i][j]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    int totalNQueens(int n) {\\n        int ans1;\\n        vector<vector<string>> store;\\n        vector<string> temp;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            ans += \".\";\\n        }\\n        for(int i=0;i<n;i++){\\n            temp.push_back(ans);\\n        }\\n        int i=0;\\n        helper(i,temp,store);\\n        ans1=store.size();\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629401,
                "title": "c-backtracking-solution-explained",
                "content": "# Intuition\\nWe need to place the queens such that they cannot cross eachother.\\n# Approach\\nWe keep check each row for a position where we can place a queen, then place it there and call recursion to place the queens in the other rows and then backtrack to find the other possibilities. \\nIf we get to the last row and are able to place a queen in that row, that means we have a possible combination, so we increment the total number of possible combinations by 1\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count;\\n    bool checkValid(vector<string> &board, int row, int col, int size){\\n\\n        // check top up\\n        for(int i = row-1;i>=0; i--){\\n            if(board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n\\n        // check diagonal\\n        for(int i = 1; i<=row; i++){\\n            if(col-i>=0){\\n                // left diagonal\\n                if(board[row-i][col-i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n            if(col+i <size){\\n                // right diagonal\\n                if(board[row-i][col+i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void helper(vector<string> &board, int row, int size){\\n        if(row == size){\\n            count++;\\n            return;\\n        }\\n\\n        for(int i = 0; i<size; i++){\\n            if(checkValid(board, row, i, size)){\\n                board[row][i] = \\'Q\\';\\n                helper(board, row+1, size);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        string str;\\n        str.append(n, \\'.\\');\\n        vector<string> board(n, str);\\n        count = 0;\\n        helper(board, 0, n);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count;\\n    bool checkValid(vector<string> &board, int row, int col, int size){\\n\\n        // check top up\\n        for(int i = row-1;i>=0; i--){\\n            if(board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n\\n        // check diagonal\\n        for(int i = 1; i<=row; i++){\\n            if(col-i>=0){\\n                // left diagonal\\n                if(board[row-i][col-i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n            if(col+i <size){\\n                // right diagonal\\n                if(board[row-i][col+i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void helper(vector<string> &board, int row, int size){\\n        if(row == size){\\n            count++;\\n            return;\\n        }\\n\\n        for(int i = 0; i<size; i++){\\n            if(checkValid(board, row, i, size)){\\n                board[row][i] = \\'Q\\';\\n                helper(board, row+1, size);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        string str;\\n        str.append(n, \\'.\\');\\n        vector<string> board(n, str);\\n        count = 0;\\n        helper(board, 0, n);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624735,
                "title": "n-queens-bitmasking-0-ms-beats-100",
                "content": "x means safe position\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, int row, int colMask, int leftDiagMask, int rightDiagMask) {\\n        if (row == n) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        int rowState = (colMask | leftDiagMask | rightDiagMask) & ((1 << n) - 1);\\n        int x = rowState ^ ((1 << n) - 1);\\n        while (x) {\\n            int queenPos = x & (-x);\\n            x -= queenPos;\\n            if (!(queenPos & rowState)) {\\n                ans += solve(n, row + 1, colMask | queenPos, (leftDiagMask | queenPos) << 1, (rightDiagMask | queenPos) >> 1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solve(n, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, int row, int colMask, int leftDiagMask, int rightDiagMask) {\\n        if (row == n) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        int rowState = (colMask | leftDiagMask | rightDiagMask) & ((1 << n) - 1);\\n        int x = rowState ^ ((1 << n) - 1);\\n        while (x) {\\n            int queenPos = x & (-x);\\n            x -= queenPos;\\n            if (!(queenPos & rowState)) {\\n                ans += solve(n, row + 1, colMask | queenPos, (leftDiagMask | queenPos) << 1, (rightDiagMask | queenPos) >> 1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solve(n, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481133,
                "title": "c-using-recursion-backtracking-t-c-o-n-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n!)\\n        Space Complexity : O(n^2) + O(2*n) + O(n)\\n    */\\n    \\nprivate:\\n    vector<int> upperLeftDiagnal;\\n    vector<int> upperRightDiagnal;\\n    vector<int> upperCol;\\n    \\n    int res = 0;\\n    vector<string> board;\\n    \\n    void helper(int row, int size){\\n        if(row == size){\\n            res++;\\n            return;\\n        }\\n        \\n        for(int col=0; col<size; col++){\\n            if(upperCol[col]==0 and\\n               upperLeftDiagnal[row+col]==0 and\\n               upperRightDiagnal[(size-1)+col-row]==0\\n              ){\\n                board[row][col] = \\'Q\\';\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 1;\\n                helper(row+1, size);\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 0;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int totalNQueens(int n) {\\n        upperLeftDiagnal.resize(2*n-1, 0);\\n        upperRightDiagnal.resize(2*n-1, 0);\\n        upperCol.resize(n, 0);\\n        \\n        board.resize(n);\\n        string s(n, \\'.\\');\\n        \\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        \\n        //row, size\\n        helper(0, n);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n!)\\n        Space Complexity : O(n^2) + O(2*n) + O(n)\\n    */\\n    \\nprivate:\\n    vector<int> upperLeftDiagnal;\\n    vector<int> upperRightDiagnal;\\n    vector<int> upperCol;\\n    \\n    int res = 0;\\n    vector<string> board;\\n    \\n    void helper(int row, int size){\\n        if(row == size){\\n            res++;\\n            return;\\n        }\\n        \\n        for(int col=0; col<size; col++){\\n            if(upperCol[col]==0 and\\n               upperLeftDiagnal[row+col]==0 and\\n               upperRightDiagnal[(size-1)+col-row]==0\\n              ){\\n                board[row][col] = \\'Q\\';\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 1;\\n                helper(row+1, size);\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 0;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int totalNQueens(int n) {\\n        upperLeftDiagnal.resize(2*n-1, 0);\\n        upperRightDiagnal.resize(2*n-1, 0);\\n        upperCol.resize(n, 0);\\n        \\n        board.resize(n);\\n        string s(n, \\'.\\');\\n        \\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        \\n        //row, size\\n        helper(0, n);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447118,
                "title": "o-1-c-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        switch(n) {\\n            case 1: return 1;\\n            case 2:\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            case 9: return 352;\\n            default: return 0;                \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        switch(n) {\\n            case 1: return 1;\\n            case 2:\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            case 9: return 352;\\n            default: return 0;                \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384665,
                "title": "easy-solution-using-bitset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bitset<30> col, d1, d2;\\n\\n    int solve(int i, int n) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int cunt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !d1[i - j + n - 1] && !d2[i + j]) {\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 1;\\n                cunt += solve(i + 1, n);\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 0;  \\n            }\\n        }\\n        return cunt;\\n    }\\n\\n    int totalNQueens(int n) {\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bitset<30> col, d1, d2;\\n\\n    int solve(int i, int n) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int cunt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !d1[i - j + n - 1] && !d2[i + j]) {\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 1;\\n                cunt += solve(i + 1, n);\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 0;  \\n            }\\n        }\\n        return cunt;\\n    }\\n\\n    int totalNQueens(int n) {\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346300,
                "title": "easiest-python-solution-beating-81-66",
                "content": "![image.png](https://assets.leetcode.com/users/images/a11c8897-726f-4336-9fa6-f93d594eed71_1679893956.642597.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def search(queens, dif, sum):\\n            l = len(queens)\\n            if l == n:\\n                self.ans += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and l-q not in dif and l+q not in sum:\\n                    search(queens+[q], dif+[l-q], sum+[l+q])\\n        \\n        self.ans = 0\\n        search([],[],[])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def search(queens, dif, sum):\\n            l = len(queens)\\n            if l == n:\\n                self.ans += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and l-q not in dif and l+q not in sum:\\n                    search(queens+[q], dif+[l-q], sum+[l+q])\\n        \\n        self.ans = 0\\n        search([],[],[])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309809,
                "title": "space-o-n-easy-understand-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solveNQueens(n).size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solveNQueens(n).size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283759,
                "title": "cpp-backtracking-o-1-diagnol-check-beats-100",
                "content": "The N-Queen problem is one of the classic Backtracking problem out there.\\n\\nSince we have N queens, we place a queen in **each row of the board** and then move to the next row.\\n\\nIn each row, we have a queen placed in a column. To keep a track of the columns used, **We can use an array, where each index denotes a row and queens[i] is the coloumn used**.\\n\\nFor no queen to attack each other : \\n- No 2 queens should we on the same row\\n*Since we are placing one queen in each row this doesn\\'t require a check*\\n\\n- No 2 queens should be on the same column\\n*We can check this simply by queens array if any previous element of the array has the same value as our current candidate column for placing the queen.*\\n\\n- No 2 queens must be present on the same diagnol\\n*A diagnol on a chesboard is either 45 degrees or 135 degrees, i.e the sloped is 1 or -1. We can also say the slope is abs(1)*\\n**Calculating slope:** \\n**abs(previous_col - curr_col) / abs(previous_row - curr_row)**\\n*Thus a O(1) check*\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int row, int col, vector<int> &queens, int &n){\\n        for(int i = 0; i < row; i++){\\n            int prev_row = i;\\n            int prev_col = queens[i];\\n\\n            if(prev_col == col || abs(row-prev_row) == abs(col - prev_col)){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int solve(int level, int &n, vector<int> &queens){\\n\\n        if(level == n){\\n            return 1;\\n        }\\n       int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            if(check(level, col, queens, n)){\\n                queens[level] = col;\\n                ans += solve(level + 1, n, queens);\\n                queens[level] = -1;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    int totalNQueens(int n) {\\n        vector<int> queens(n,-1);\\n        int res = solve(0, n, queens);\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int row, int col, vector<int> &queens, int &n){\\n        for(int i = 0; i < row; i++){\\n            int prev_row = i;\\n            int prev_col = queens[i];\\n\\n            if(prev_col == col || abs(row-prev_row) == abs(col - prev_col)){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int solve(int level, int &n, vector<int> &queens){\\n\\n        if(level == n){\\n            return 1;\\n        }\\n       int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            if(check(level, col, queens, n)){\\n                queens[level] = col;\\n                ans += solve(level + 1, n, queens);\\n                queens[level] = -1;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    int totalNQueens(int n) {\\n        vector<int> queens(n,-1);\\n        int res = solve(0, n, queens);\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207915,
                "title": "python-fast-backtracking-horizontal-symmetry-97-39",
                "content": "# Intuition\\nTry to check all possible combinations with backtracking.\\nE.g.\\nFind a row where you can put a queen in the first column. \\nFind a row where you can put a queen in the second column.\\n...\\nIf it\\'s not last column, but you can\\'t put queen. Then go back to the previous column and find the next row where you can put queen.\\n... \\nIf it\\'s a last column and you found a row where you can put queen - you have plus one possible solution.\\n\\n# Approach\\n\\nNaive aproach would be to store state of a board in an array of arrays, where `False` empty cell and `True` is a cell with a queen. However, in this case you would need to check all placed queens, to verify position of the next queen.\\n\\nIt easier and more effective to store ocupied rows and diagonals separatly. Columns are not stored as backtracking goes from 1st to n-th one by one.\\n\\nThe easiest logical optimization would be to find solutions with a queen in the first column and first half or rows. For the second half of rows solutions are horizontaly symetric. And don\\'t forget about midde row. It would make any solution almost 2 times faster.\\nYou can go further and think of vertical symetry, and rotation symetry.\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        rows = [0 for _ in range(n)]\\n        ldiags = [0 for _ in range(2 * n + 1)]\\n        rdiags = [0 for _ in range(2 * n + 1)]\\n        total = 0\\n\\n        def backtrack(i, j_range=None):\\n            nonlocal rows\\n            nonlocal ldiags\\n            nonlocal rdiags\\n            nonlocal total\\n\\n            for j in range(*j_range) if j_range else range(n):\\n                if not (\\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\\n                ):\\n                    if i + 1 == n:\\n                        total += 1\\n                    else:\\n                        rows[j] = 1\\n                        ldiags[l] = 1\\n                        rdiags[r] = 1\\n                        backtrack(i + 1)\\n                        rows[j] = 0\\n                        ldiags[l] = 0\\n                        rdiags[r] = 0\\n\\n        backtrack(0, (0, n // 2))\\n        total *= 2\\n        if n % 2:\\n            backtrack(0, (n // 2, n // 2 + 1))\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        rows = [0 for _ in range(n)]\\n        ldiags = [0 for _ in range(2 * n + 1)]\\n        rdiags = [0 for _ in range(2 * n + 1)]\\n        total = 0\\n\\n        def backtrack(i, j_range=None):\\n            nonlocal rows\\n            nonlocal ldiags\\n            nonlocal rdiags\\n            nonlocal total\\n\\n            for j in range(*j_range) if j_range else range(n):\\n                if not (\\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\\n                ):\\n                    if i + 1 == n:\\n                        total += 1\\n                    else:\\n                        rows[j] = 1\\n                        ldiags[l] = 1\\n                        rdiags[r] = 1\\n                        backtrack(i + 1)\\n                        rows[j] = 0\\n                        ldiags[l] = 0\\n                        rdiags[r] = 0\\n\\n        backtrack(0, (0, n // 2))\\n        total *= 2\\n        if n % 2:\\n            backtrack(0, (n // 2, n // 2 + 1))\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199663,
                "title": "python-recursive-backtracking-just-print-the-length",
                "content": "# Code\\n```\\nclass Solution:\\n    def IsSafe(self,row,column,n,board):\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    def solveQueens(self,column,n,board,result):\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            return\\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n        return\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return len(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def IsSafe(self,row,column,n,board):\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    def solveQueens(self,column,n,board,result):\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            return\\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n        return\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176316,
                "title": "52-n-queens-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- In this solution, we use depth first search (dfs) to find all solutions to the N-Queens problem\\n- The queens list keeps track of the row number for each column, where queens[i] represents the row number for the ith column.\\n- The dif list keeps track of the difference between the row number and the column number, where dif[i] = p - q and p is the row number and q is the column number.\\n- The sum list keeps track of the sum of the row number and the column number, where sum[i] = p + q and p is the row number and q is the column number.\\n- For each iteration, we check if the column q has not been used in the current solution and if the diagonal represented by dif[i] and the diagonal represented by sum[i] have not been used. If both conditions are met, we add q to the current solution and continue the search.\\n- If the length of the queens list is equal to n, it means we have found a solution and we increment the result by 1.\\n- Finally, we return the result which represents the number of solutions to the N-Queens problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                self.result += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        \\n        self.result = 0\\n        dfs([],[],[])\\n        return self.result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                self.result += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        \\n        self.result = 0\\n        dfs([],[],[])\\n        return self.result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158572,
                "title": "backtracking-and-bitmasking-better-than-backtracking-c",
                "content": "# Backtracking O(N! * N)\\n```\\nclass Solution {\\npublic:\\nint ans;\\nbool is_valid(vector<string> &board, int row, int col){\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                board[row][i] = \\'Q\\';\\n                dfs(board,row+1);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if(n <= 0) return 0;\\n        ans=0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Bitmasking O(N!)\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int res = 0;\\n        vector<int> col(n, 0), dg(2 * n, 0), udg(2 * n, 0);\\n        // Start the backtracking function from the first row\\n        solveNQueens(res, col, dg, udg, 0, n);\\n        return res;\\n    }\\n    void solveNQueens(int& res, vector<int>& col, vector<int>& dg,\\n                      vector<int>& udg, int row, int& n) {\\n        // If we have reached the last row, it means a valid solution is found\\n        if (row == n) {\\n            ++res; // Increment the number of solutions\\n            return;\\n        }\\n        for (int c = 0; c < n; ++c) {\\n            // Check if the current column, current diagonal (row + column) \\n            // and current anti-diagonal (n + row - column) are all empty\\n            if (!col[c] && !dg[row + c] && !udg[n + row - c]) {\\n                col[c] = dg[row + c] = udg[n + row - c] = 1;\\n                // Move to the next row and repeat the process\\n                solveNQueens(res, col, dg, udg, row + 1, n);\\n                col[c] = dg[row + c] = udg[n + row - c] = 0;\\n                // Backtrack to try other columns in the current row\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\nThe algorithm works as follows:\\n\\nIf row is equal to n, it means all n rows have been filled, and a possible solution has been found, so res is incremented.\\n\\nFor each column c from 0 to n-1:\\n\\nIf the column, diagonal, and anti-diagonal corresponding to the current row and column are not occupied (represented by the values in col, dg, and udg being 0), the current position is marked as occupied and the algorithm continues to the next row by calling solveNQueens recursively.\\n\\nAfter the recursive call returns, the current position is marked as unoccupied to backtrack to previous positions.\\n\\nThis algorithm has a time complexity of O(n!).\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans;\\nbool is_valid(vector<string> &board, int row, int col){\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                board[row][i] = \\'Q\\';\\n                dfs(board,row+1);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if(n <= 0) return 0;\\n        ans=0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int res = 0;\\n        vector<int> col(n, 0), dg(2 * n, 0), udg(2 * n, 0);\\n        // Start the backtracking function from the first row\\n        solveNQueens(res, col, dg, udg, 0, n);\\n        return res;\\n    }\\n    void solveNQueens(int& res, vector<int>& col, vector<int>& dg,\\n                      vector<int>& udg, int row, int& n) {\\n        // If we have reached the last row, it means a valid solution is found\\n        if (row == n) {\\n            ++res; // Increment the number of solutions\\n            return;\\n        }\\n        for (int c = 0; c < n; ++c) {\\n            // Check if the current column, current diagonal (row + column) \\n            // and current anti-diagonal (n + row - column) are all empty\\n            if (!col[c] && !dg[row + c] && !udg[n + row - c]) {\\n                col[c] = dg[row + c] = udg[n + row - c] = 1;\\n                // Move to the next row and repeat the process\\n                solveNQueens(res, col, dg, udg, row + 1, n);\\n                col[c] = dg[row + c] = udg[n + row - c] = 0;\\n                // Backtrack to try other columns in the current row\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131987,
                "title": "0ms-100-faster-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isSafe(vector<string> &board, int row, int col, vector<int> &lowerDiagonal, vector<int> &upperDiagonal, vector<int>&leftSideRow, int n) {\\n        if(upperDiagonal[n-1+col-row]!=1 && leftSideRow[row]!=1 && lowerDiagonal[row+col]!=1) return true;\\n        return false;\\n    }\\n\\n    void backtrack(int col, vector<string>&board, int&ans, int n, vector<int>&lowerDiagonal, vector<int>&upperDiagonal, vector<int>& leftSideRow) {\\n        if(col==n) {\\n            ans++;\\n            return;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(isSafe(board, i, col, lowerDiagonal, upperDiagonal, leftSideRow, n)) {\\n                board[i][col] = \\'Q\\';\\n                lowerDiagonal[i+col] = 1;\\n                upperDiagonal[n-1+col-i] = 1;\\n                leftSideRow[i] = 1;\\n                backtrack(col+1, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n                board[i][col] = \\'.\\';\\n                lowerDiagonal[i+col] = 0;\\n                upperDiagonal[n-1+col-i] = 0;\\n                leftSideRow[i] = 0;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        int ans = 0;\\n        vector<string> board(n);\\n        vector<int> lowerDiagonal(2*n-1, 0);\\n        vector<int> upperDiagonal(2*n-1,0);\\n        vector<int> leftSideRow(n,0);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++) {\\n            board[i] = s;\\n        }\\n        backtrack(0, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isSafe(vector<string> &board, int row, int col, vector<int> &lowerDiagonal, vector<int> &upperDiagonal, vector<int>&leftSideRow, int n) {\\n        if(upperDiagonal[n-1+col-row]!=1 && leftSideRow[row]!=1 && lowerDiagonal[row+col]!=1) return true;\\n        return false;\\n    }\\n\\n    void backtrack(int col, vector<string>&board, int&ans, int n, vector<int>&lowerDiagonal, vector<int>&upperDiagonal, vector<int>& leftSideRow) {\\n        if(col==n) {\\n            ans++;\\n            return;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(isSafe(board, i, col, lowerDiagonal, upperDiagonal, leftSideRow, n)) {\\n                board[i][col] = \\'Q\\';\\n                lowerDiagonal[i+col] = 1;\\n                upperDiagonal[n-1+col-i] = 1;\\n                leftSideRow[i] = 1;\\n                backtrack(col+1, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n                board[i][col] = \\'.\\';\\n                lowerDiagonal[i+col] = 0;\\n                upperDiagonal[n-1+col-i] = 0;\\n                leftSideRow[i] = 0;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        int ans = 0;\\n        vector<string> board(n);\\n        vector<int> lowerDiagonal(2*n-1, 0);\\n        vector<int> upperDiagonal(2*n-1,0);\\n        vector<int> leftSideRow(n,0);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++) {\\n            board[i] = s;\\n        }\\n        backtrack(0, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085407,
                "title": "100-fastest-solution-using-the-back-tracking-and-recursion",
                "content": "# Intuition\\nTake a intution that the queen attacks only when either they are present in the same row,col or diagonally.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe try to make diagonal rl and lr and  lrow which ensures that the queen must be placed in different diagonal; and row respectively.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint c=0;\\n    void rec( vector<string>&board, vector<int>&lrow, vector<int>&lr, vector<int>&rl,int col,int n){\\n         if(col==n){\\n             c++;\\n              return;\\n         }\\n         for(int row=0;row<n;row++)\\n       {  \\n           if(lrow[row]==0 && lr[row+col]==0 && rl[n-1+col-row]==0){\\n             board[row][col]=\\'Q\\';\\n             lrow[row]=1;\\n             lr[row+col]=1;\\n             rl[n-1+col-row]=1;\\n            rec(board,lrow,lr,rl,col+1,n);\\n              board[row][col]=\\'.\\';\\n             lrow[row]=0;\\n             lr[row+col]=0;\\n             rl[n-1+col-row]=0;\\n          }\\n       }\\n    }\\n    int totalNQueens(int n) {\\n          vector<int>lrow(n,0),lr(2*n-1,0),rl(2*n-1,0);\\n       string s(n,\\'.\\');\\n       vector<string>board;\\n       for(int i=0;i<n;i++){\\n           board.push_back(s);\\n       }\\n        rec(board,lrow,lr,rl,0,n);\\n        return c;\\n    }\\n};\\n```\\nPls \\uD83D\\uDE4F\\uD83D\\uDE4FUpvote if u find this helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint c=0;\\n    void rec( vector<string>&board, vector<int>&lrow, vector<int>&lr, vector<int>&rl,int col,int n){\\n         if(col==n){\\n             c++;\\n              return;\\n         }\\n         for(int row=0;row<n;row++)\\n       {  \\n           if(lrow[row]==0 && lr[row+col]==0 && rl[n-1+col-row]==0){\\n             board[row][col]=\\'Q\\';\\n             lrow[row]=1;\\n             lr[row+col]=1;\\n             rl[n-1+col-row]=1;\\n            rec(board,lrow,lr,rl,col+1,n);\\n              board[row][col]=\\'.\\';\\n             lrow[row]=0;\\n             lr[row+col]=0;\\n             rl[n-1+col-row]=0;\\n          }\\n       }\\n    }\\n    int totalNQueens(int n) {\\n          vector<int>lrow(n,0),lr(2*n-1,0),rl(2*n-1,0);\\n       string s(n,\\'.\\');\\n       vector<string>board;\\n       for(int i=0;i<n;i++){\\n           board.push_back(s);\\n       }\\n        rec(board,lrow,lr,rl,0,n);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049726,
                "title": "begineer-friendly-code-to-understand-backtracking-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\\'\\' for i in range(n)] for j in range(n)]\\n        self.queens = n\\n        # self.placed = 0\\n        self.ans = 0\\n        # self.queen_pos = []\\n        self.place(0,board)\\n        return self.ans\\n    \\n    def place(self,i,board,queens=None,placed=0):\\n        if placed == self.queens:\\n            self.ans += 1\\n            return\\n        if i>= self.queens:\\n            return\\n        if not queens:\\n            queens = []\\n        for j in range(self.queens):\\n            if not self.intersect(queens+[[i,j]],placed,board):\\n                board[i][j] = \\'Q\\'\\n                self.place(i+1,board,queens+[[i,j]],placed+1)\\n                board[i][j] = \\'\\'\\n    \\n    def intersect(self,queens,placed,board):\\n        if placed < 1:\\n            return False\\n        for queen in queens:\\n            q_x,q_y = queen[0],queen[1]\\n            for i in range(self.queens):\\n                if board[i][q_y] == \\'Q\\' and i!=q_x:\\n                    return True\\n                if board[q_x][i] == \\'Q\\' and i!=q_y:\\n                    return True\\n                \\n            # right down diagonal check\\n            while q_x+1<self.queens and q_y+1<self.queens:\\n                q_x,q_y = q_x+1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left down diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y+1<self.queens:\\n                q_x,q_y = q_x-1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # right up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x+1<self.queens and q_y-1>=0:\\n                q_x,q_y = q_x+1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y-1>=0:\\n                q_x,q_y = q_x-1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n        return False\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\\'\\' for i in range(n)] for j in range(n)]\\n        self.queens = n\\n        # self.placed = 0\\n        self.ans = 0\\n        # self.queen_pos = []\\n        self.place(0,board)\\n        return self.ans\\n    \\n    def place(self,i,board,queens=None,placed=0):\\n        if placed == self.queens:\\n            self.ans += 1\\n            return\\n        if i>= self.queens:\\n            return\\n        if not queens:\\n            queens = []\\n        for j in range(self.queens):\\n            if not self.intersect(queens+[[i,j]],placed,board):\\n                board[i][j] = \\'Q\\'\\n                self.place(i+1,board,queens+[[i,j]],placed+1)\\n                board[i][j] = \\'\\'\\n    \\n    def intersect(self,queens,placed,board):\\n        if placed < 1:\\n            return False\\n        for queen in queens:\\n            q_x,q_y = queen[0],queen[1]\\n            for i in range(self.queens):\\n                if board[i][q_y] == \\'Q\\' and i!=q_x:\\n                    return True\\n                if board[q_x][i] == \\'Q\\' and i!=q_y:\\n                    return True\\n                \\n            # right down diagonal check\\n            while q_x+1<self.queens and q_y+1<self.queens:\\n                q_x,q_y = q_x+1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left down diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y+1<self.queens:\\n                q_x,q_y = q_x-1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # right up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x+1<self.queens and q_y-1>=0:\\n                q_x,q_y = q_x+1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y-1>=0:\\n                q_x,q_y = q_x-1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n        return False\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010025,
                "title": "n-queens-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\\n    //check for same row\\n    int x = row;\\n    int y = col;\\n    \\n    while(y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n    }\\n    \\n    //no need to check for columns as we are adding one queen in one column\\n    \\n    //check for diagonals\\n    //check for North West(NW) diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x>=0 && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x--;\\n    }\\n    \\n    //check for SW diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x<n && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x++;\\n    }\\n    //no need to check for NE and SE diagonals as queen hasn\\'t been added to the right.\\n    return true;\\n}\\n\\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\\n    //base case\\n    if(col == n){\\n        count++;\\n        return ;\\n    }\\n    \\n    //solve for 1 column, rest recursion will take care\\n    for(int row = 0 ; row < n ; row++){\\n        if(isSafe(row,col,board,n)){\\n            board[row][col] = 1;\\n            solve(col+1 , ans , board , n , count);\\n            //backtrack\\n            board[row][col] = 0;\\n        }\\n    }\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int>> board(n , vector<int>(n,0));\\n        vector<vector<int>> ans;\\n        int count = 0;\\n        \\n        solve(0 , ans , board , n , count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\\n    //check for same row\\n    int x = row;\\n    int y = col;\\n    \\n    while(y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n    }\\n    \\n    //no need to check for columns as we are adding one queen in one column\\n    \\n    //check for diagonals\\n    //check for North West(NW) diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x>=0 && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x--;\\n    }\\n    \\n    //check for SW diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x<n && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x++;\\n    }\\n    //no need to check for NE and SE diagonals as queen hasn\\'t been added to the right.\\n    return true;\\n}\\n\\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\\n    //base case\\n    if(col == n){\\n        count++;\\n        return ;\\n    }\\n    \\n    //solve for 1 column, rest recursion will take care\\n    for(int row = 0 ; row < n ; row++){\\n        if(isSafe(row,col,board,n)){\\n            board[row][col] = 1;\\n            solve(col+1 , ans , board , n , count);\\n            //backtrack\\n            board[row][col] = 0;\\n        }\\n    }\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int>> board(n , vector<int>(n,0));\\n        vector<vector<int>> ans;\\n        int count = 0;\\n        \\n        solve(0 , ans , board , n , count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565873,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1569403,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1567140,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565828,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1997219,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571127,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571126,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1983949,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1792088,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1576678,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565873,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1569403,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1567140,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565828,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1997219,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571127,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571126,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1983949,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1792088,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1576678,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 2064843,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2029585,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2016375,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2000586,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1991597,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1981878,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1883948,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1841509,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1823866,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1808779,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            }
        ]
    }
]