[
    {
        "title": "Remove Invalid Parentheses",
        "question_content": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\n\nExample 2:\n\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\n\nExample 3:\n\nInput: s = \")(\"\nOutput: [\"\"]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 25\n\ts consists of lowercase English letters and parentheses '(' and ')'.\n\tThere will be at most 20 parentheses in s.",
        "solutions": [
            {
                "id": 75027,
                "title": "easy-short-concise-and-fast-java-dfs-3-ms-solution",
                "content": "For a better view [see here](http://algobox.org/remove-invalid-parentheses/)\\n\\nKey Points:\\n\\n1. Generate unique answer once and only once, do not rely on Set.\\n2. Do not need preprocess.\\n3. Runtime 3 ms.\\n\\nExplanation:\\nWe all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter.\\nThe counter will increase when it is \\u2018(\\u2018 and decrease when it is \\u2018)\\u2019. Whenever the counter is negative, we have more \\u2018)\\u2019 than \\u2018(\\u2018 in the prefix.\\n\\nTo make the prefix valid, we need to remove a \\u2018)\\u2019. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.\\n\\nAfter the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two \\u2018)\\u2019 in two steps only with a different order.\\nFor this, we keep tracking the last removal position and only remove \\u2018)\\u2019 after that.\\n\\nNow one may ask. What about \\u2018(\\u2018? What if s = \\u2018(()(()\\u2019 in which we need remove \\u2018(\\u2018?\\nThe answer is: do the same from right to left.\\nHowever a cleverer idea is: reverse the string and reuse the code!\\nHere is the final implement in Java.\\n\\n\\n\\n**Java**\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        remove(s, ans, 0, 0, new char[]{'(', ')'});\\n        return ans;\\n    }\\n\\n    public void remove(String s, List<String> ans, int last_i, int last_j,  char[] par) {\\n        for (int stack = 0, i = last_i; i < s.length(); ++i) {\\n            if (s.charAt(i) == par[0]) stack++;\\n            if (s.charAt(i) == par[1]) stack--;\\n            if (stack >= 0) continue;\\n            for (int j = last_j; j <= i; ++j)\\n                if (s.charAt(j) == par[1] && (j == last_j || s.charAt(j - 1) != par[1]))\\n                    remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);\\n            return;\\n        }\\n        String reversed = new StringBuilder(s).reverse().toString();\\n        if (par[0] == '(') // finished left to right\\n            remove(reversed, ans, 0, 0, new char[]{')', '('});\\n        else // finished right to left\\n            ans.add(reversed);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "For a better view [see here](http://algobox.org/remove-invalid-parentheses/)\\n\\nKey Points:\\n\\n1. Generate unique answer once and only once, do not rely on Set.\\n2. Do not need preprocess.\\n3. Runtime 3 ms.\\n\\nExplanation:\\nWe all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter.\\nThe counter will increase when it is \\u2018(\\u2018 and decrease when it is \\u2018)\\u2019. Whenever the counter is negative, we have more \\u2018)\\u2019 than \\u2018(\\u2018 in the prefix.\\n\\nTo make the prefix valid, we need to remove a \\u2018)\\u2019. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.\\n\\nAfter the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two \\u2018)\\u2019 in two steps only with a different order.\\nFor this, we keep tracking the last removal position and only remove \\u2018)\\u2019 after that.\\n\\nNow one may ask. What about \\u2018(\\u2018? What if s = \\u2018(()(()\\u2019 in which we need remove \\u2018(\\u2018?\\nThe answer is: do the same from right to left.\\nHowever a cleverer idea is: reverse the string and reuse the code!\\nHere is the final implement in Java.\\n\\n\\n\\n**Java**\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        remove(s, ans, 0, 0, new char[]{'(', ')'});\\n        return ans;\\n    }\\n\\n    public void remove(String s, List<String> ans, int last_i, int last_j,  char[] par) {\\n        for (int stack = 0, i = last_i; i < s.length(); ++i) {\\n            if (s.charAt(i) == par[0]) stack++;\\n            if (s.charAt(i) == par[1]) stack--;\\n            if (stack >= 0) continue;\\n            for (int j = last_j; j <= i; ++j)\\n                if (s.charAt(j) == par[1] && (j == last_j || s.charAt(j - 1) != par[1]))\\n                    remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);\\n            return;\\n        }\\n        String reversed = new StringBuilder(s).reverse().toString();\\n        if (par[0] == '(') // finished left to right\\n            remove(reversed, ans, 0, 0, new char[]{')', '('});\\n        else // finished right to left\\n            ans.add(reversed);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 75032,
                "title": "share-my-java-bfs-solution",
                "content": "The idea is straightforward, with the input string `s`, we generate all possible states by removing one `(` or `)`, check if they are valid, if found valid ones on the current level, put them to the final result list and we are done, otherwise, add them to a queue and carry on to the next level. \\n\\nThe good thing of using BFS is that we can guarantee the number of parentheses that need to be removed is minimal, also no recursion call is needed in BFS.\\n\\nThanks to [@peisi][1], we don't need stack to check valid parentheses.\\n\\nTime complexity: \\n\\nIn BFS we handle the states level by level, in the worst case, we need to handle all the levels, we can analyze the time complexity level by level and add them up to get the final complexity. \\n\\nOn the first level, there's only one string which is the input string `s`, let's say the length of it is `n`, to check whether it's valid, we need `O(n)` time. On the second level, we remove one `(` or `)` from the first level, so there are `C(n, n-1)` new strings, each of them has `n-1` characters, and for each string, we need to check whether it's valid or not, thus the total time complexity on this level is `(n-1)` x `C(n, n-1)`. Come to the third level, total time complexity is `(n-2)` x `C(n, n-2)`, so on and so forth...\\n\\nFinally we have this formula: \\n\\n`T(n)` = `n` x `C(n, n)` + `(n-1)` x `C(n, n-1)` + ... + `1` x `C(n, 1)` = `n` x `2^(n-1)`.\\n\\nFollowing is the Java solution:\\n\\n    public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n          List<String> res = new ArrayList<>();\\n          \\n          // sanity check\\n          if (s == null) return res;\\n          \\n          Set<String> visited = new HashSet<>();\\n          Queue<String> queue = new LinkedList<>();\\n          \\n          // initialize\\n          queue.add(s);\\n          visited.add(s);\\n          \\n          boolean found = false;\\n          \\n          while (!queue.isEmpty()) {\\n            s = queue.poll();\\n            \\n            if (isValid(s)) {\\n              // found an answer, add to the result\\n              res.add(s);\\n              found = true;\\n            }\\n          \\n            if (found) continue;\\n          \\n            // generate all possible states\\n            for (int i = 0; i < s.length(); i++) {\\n              // we only try to remove left or right paren\\n              if (s.charAt(i) != '(' && s.charAt(i) != ')') continue;\\n            \\n              String t = s.substring(0, i) + s.substring(i + 1);\\n            \\n              if (!visited.contains(t)) {\\n                // for each state, if it's not visited, add it to the queue\\n                queue.add(t);\\n                visited.add(t);\\n              }\\n            }\\n          }\\n          \\n          return res;\\n        }\\n        \\n        // helper function checks if string s contains valid parantheses\\n        boolean isValid(String s) {\\n          int count = 0;\\n        \\n          for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '(') count++;\\n            if (c == ')' && count-- == 0) return false;\\n          }\\n        \\n          return count == 0;\\n        }\\n    }\\n\\n  [1]: https://leetcode.com/discuss/user/peisi",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n          List<String> res = new ArrayList<>();\\n          \\n          // sanity check\\n          if (s == null) return res;\\n          \\n          Set<String> visited = new HashSet<>();\\n          Queue<String> queue = new LinkedList<>();\\n          \\n          // initialize\\n          queue.add(s);\\n          visited.add(s);\\n          \\n          boolean found = false;\\n          \\n          while (!queue.isEmpty()) {\\n            s = queue.poll();\\n            \\n            if (isValid(s)) {\\n              // found an answer, add to the result\\n              res.add(s);\\n              found = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 75034,
                "title": "easiest-9ms-java-solution",
                "content": "Here I share my `DFS` or `backtracking` solution. It's `10X` faster than optimized `BFS`.\\n\\n 1. Limit max removal  `rmL` and  `rmR` for backtracking boundary. Otherwise it will exhaust all possible valid substrings, not shortest ones.\\n 2. Scan from left to right, avoiding invalid strs (on the fly) by checking num of `open` parens.\\n 3. If it's `'('`, either use it, or remove it.\\n 4. If it's `'('`, either use it, or remove it.\\n 5. Otherwise just append it.\\n 6. Lastly set `StringBuilder` to the last decision point.\\n\\nIn each step, make sure:\\n\\n 1. `i` does not exceed `s.length()`.\\n 2. Max removal `rmL` `rmR` and num of `open` parens are non negative.\\n 3. De-duplicate by adding to a `HashSet`.\\n\\nCompared to `106 ms` `BFS (Queue & Set)`, it's faster and easier. Hope it helps! Thanks.\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        int rmL = 0, rmR = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '(') {\\n                rmL++;\\n            } else if (s.charAt(i) == ')') {\\n                if (rmL != 0) {\\n                    rmL--;\\n                } else {\\n                    rmR++;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(s, 0, res, new StringBuilder(), rmL, rmR, 0);\\n        return new ArrayList<String>(res);\\n    }\\n    \\n    public void dfs(String s, int i, Set<String> res, StringBuilder sb, int rmL, int rmR, int open) {\\n        if (rmL < 0 || rmR < 0 || open < 0) {\\n            return;\\n        }\\n        if (i == s.length()) {\\n            if (rmL == 0 && rmR == 0 && open == 0) {\\n                res.add(sb.toString());\\n            }        \\n            return;\\n        }\\n    \\n        char c = s.charAt(i); \\n        int len = sb.length();\\n    \\n        if (c == '(') {\\n            dfs(s, i + 1, res, sb, rmL - 1, rmR, open);\\t\\t    // not use (\\n        \\tdfs(s, i + 1, res, sb.append(c), rmL, rmR, open + 1);       // use (\\n    \\n        } else if (c == ')') {\\n            dfs(s, i + 1, res, sb, rmL, rmR - 1, open);\\t            // not use  )\\n        \\tdfs(s, i + 1, res, sb.append(c), rmL, rmR, open - 1);  \\t    // use )\\n    \\n        } else {\\n            dfs(s, i + 1, res, sb.append(c), rmL, rmR, open);\\t\\n        }\\n    \\n        sb.setLength(len);        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here I share my `DFS` or `backtracking` solution. It's `10X` faster than optimized `BFS`.\\n\\n 1. Limit max removal  `rmL` and  `rmR` for backtracking boundary. Otherwise it will exhaust all possible valid substrings, not shortest ones.\\n 2. Scan from left to right, avoiding invalid strs (on the fly) by checking num of `open` parens.\\n 3. If it's `'('`, either use it, or remove it.\\n 4. If it's `'('`, either use it, or remove it.\\n 5. Otherwise just append it.\\n 6. Lastly set `StringBuilder` to the last decision point.\\n\\nIn each step, make sure:\\n\\n 1. `i` does not exceed `s.length()`.\\n 2. Max removal `rmL` `rmR` and num of `open` parens are non negative.\\n 3. De-duplicate by adding to a `HashSet`.\\n\\nCompared to `106 ms` `BFS (Queue & Set)`, it's faster and easier. Hope it helps! Thanks.\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        int rmL = 0, rmR = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '(') {\\n                rmL++;\\n            } else if (s.charAt(i) == ')') {\\n                if (rmL != 0) {\\n                    rmL--;\\n                } else {\\n                    rmR++;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(s, 0, res, new StringBuilder(), rmL, rmR, 0);\\n        return new ArrayList<String>(res);\\n    }\\n    \\n    public void dfs(String s, int i, Set<String> res, StringBuilder sb, int rmL, int rmR, int open) {\\n        if (rmL < 0 || rmR < 0 || open < 0) {\\n            return;\\n        }\\n        if (i == s.length()) {\\n            if (rmL == 0 && rmR == 0 && open == 0) {\\n                res.add(sb.toString());\\n            }        \\n            return;\\n        }\\n    \\n        char c = s.charAt(i); \\n        int len = sb.length();\\n    \\n        if (c == '(') {\\n            dfs(s, i + 1, res, sb, rmL - 1, rmR, open);\\t\\t    // not use (\\n        \\tdfs(s, i + 1, res, sb.append(c), rmL, rmR, open + 1);       // use (\\n    \\n        } else if (c == ')') {\\n            dfs(s, i + 1, res, sb, rmL, rmR - 1, open);\\t            // not use  )\\n        \\tdfs(s, i + 1, res, sb.append(c), rmL, rmR, open - 1);  \\t    // use )\\n    \\n        } else {\\n            dfs(s, i + 1, res, sb.append(c), rmL, rmR, open);\\t\\n        }\\n    \\n        sb.setLength(len);        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 75038,
                "title": "evolve-from-intuitive-solution-to-optimal-a-review-of-all-solutions",
                "content": "There are three challenges. Remove minimum parenthesis, the result is valid and without duplicates.  All BFS and DFS solutions look like O(n2^n), but the performance is different depending on how they solve the challenges. \\n\\nBFS Solutions\\n1. BFS guarantees shortest path. Since the problem asks to remove minimum parenthesis, it is natural think of BFS. A straightforward approach is to remove a parenthesis from the current string until we get a valid string. It generates both duplicate and invalid strings. We can use a hash table to remove duplicates and check each string for validity. [The idea is from @jeantimex.](https://discuss.leetcode.com/topic/28827/share-my-java-bfs-solution) \\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<string> q;\\n        unordered_set<string> ht;\\n        q.push(s);\\n        vector<string> res;\\n        while(!q.empty()) {\\n            string ss = q.front();\\n            q.pop();\\n            if(ht.count(ss)) continue;\\n            ht.insert(ss);\\n            if(isValid(ss)) res.push_back(ss);\\n            else if (res.empty()) \\n                for(int i=0;i<ss.size();i++) \\n                    if(ss[i]==\\')\\'|| ss[i]==\\'(\\') q.push(ss.substr(0,i)+ss.substr(i+1));\\n        }\\n        return res;\\n    }\\n    bool isValid(string &s) {\\n        int count=0;\\n        for(auto c:s) {\\n            if(c==\\'(\\') count++;\\n            if(c==\\')\\')\\n                if(count>0) count--;\\n                else return false;\\n        }\\n        return !count;\\n    }\\n```\\n2. We can speed up and get rid of the hash table by generating unique strings only. There are two types of duplicates. First is due to removing the same set of characters in different order. For example, \"**(**()**(**()\", remove 0th then 3rd or remove 3rd then 0th both generates \"()()\". So we can enforce an order by keeping the last removal index and remove after it only. The other is handling consecutive same chars, say, \"(()\". We get the same string by removing either the 0th or 1st \\'(\\'. We can just remove the 0th.  [The idea is from @dietpepsi.](https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution)\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<pair<string,int>> q;\\n        q.push(make_pair(s,0));\\n        vector<string> res;\\n        while(!q.empty()) {\\n            auto p=q.front();\\n            q.pop();\\n            string ss=p.first;\\n            if(isValid(ss)) res.push_back(ss);\\n            else if (res.empty()) \\n                for(int i=p.second;i<ss.size();i++) \\n                    if((ss[i]==\\')\\'|| ss[i]==\\'(\\') && (i==p.second || ss[i]!=ss[i-1])) \\n                        q.push(make_pair(ss.substr(0,i)+ss.substr(i+1),i));\\n        }\\n        return res;\\n    }\\n```\\n3. The optimal BFS should not generate invalid strings either. Again, [the idea is from @dietpepsi.](https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution)\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<tuple<string,int,int,char>> q;\\n        q.push(make_tuple(s,0,0,\\'(\\'));\\n        vector<string> res;\\n        while(!q.empty()) {\\n            auto t=q.front();\\n            q.pop();\\n            string str=get<0>(t);\\n            int start =get<1>(t), lastRm=get<2>(t), count = 0;\\n            char l = get<3>(t), r = l==\\'(\\'?\\')\\':\\'(\\';\\n            for(int i=start; i<str.size();i++) {\\n                if(str[i] == l) count++;\\n                else if(str[i]==r) count--;\\n                if(count>=0) continue;\\n                for(int j=lastRm;j<=i;j++)\\n                    if(str[j]==r && (j==lastRm || str[j-1]!=r))\\n                        q.push(make_tuple(str.substr(0,j)+str.substr(j+1),i,j,l));\\n                break;\\n            }\\n            if(count < 0) continue;\\n            reverse(str.begin(),str.end());\\n            if(l==\\'(\\') q.push(make_tuple(str,0,0,\\')\\'));\\n            else res.push_back(str);\\n        }\\n        return res;\\n    }\\n```\\nDFS solutions\\n1. A naive DFS is to generate all the 2^n substr. We use hash table to remove duplicates. and then return the longest ones. It is less efficient than BFS because DFS does not guarantee shortest path. So we cannot stop after the first valid strings as in BFS.\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string> ht;\\n        string cur;\\n        dfs(0,cur,s,ht);\\n        size_t ml = 0;\\n        for(auto& str:ht) ml = max(ml,str.size());\\n        vector<string> res;\\n        for(auto& str:ht) if(str.size()==ml) res.push_back(str);\\n        return res;\\n    }\\n    void dfs(int p, string& cur, string& s, unordered_set<string>& res) {\\n        if(p==s.size()) {\\n            if(isValid(cur)) res.insert(cur);\\n            return;\\n        }\\n        cur+=s[p];\\n        dfs(p+1,cur,s,res);\\n        cur.pop_back();\\n        if(s[p]==\\'(\\'||s[p]==\\')\\') dfs(p+1,cur,s,res); \\n    }\\n```\\n2. The naive DFS searches from a lot of duplicate states. We can use a hash table to avoid it.\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_map<string,int> vstd;\\n        string cur;\\n        unordered_set<string> ht;\\n        dfs(0,cur,s, ht, vstd);\\n        size_t ml = 0;\\n        for(auto& str:ht) ml = max(ml,str.size());\\n        vector<string> res;\\n        for(auto& str:ht) if(str.size()==ml) res.push_back(str);\\n        return res;\\n    }\\n    void dfs(int p, string& cur, string& s, unordered_set<string>& res, unordered_map<string,int>& vstd) {\\n        auto it = vstd.find(cur);\\n        if(it!=vstd.end() && it->second <= p) return;\\n        if(p==s.size()) {\\n            if(isValid(cur)) res.insert(cur);\\n            return;\\n        }\\n        cur+=s[p];\\n        dfs(p+1,cur,s,res,vstd);\\n        cur.pop_back();\\n        if(s[p]==\\'(\\'||s[p]==\\')\\') dfs(p+1,cur,s,res,vstd);\\n        if(it == vstd.end()) vstd[cur] = p;\\n        else it->second = min(it->second,p);\\n    }\\n```\\n3. The above DFS approaches are not efficient at all since they generate strings of all lengths. BFS only removes the minimum number of strings so we should be able to do the same thing in DFS. Since the problem asks to remove minimum number of parenthesis, it is natural to compute the min number first and then use it to guide the DFS. This guarantees we only generate valid strings. The other challenge is to handle duplicate strings. We still use hash table to remove duplicates. The disadvantage is that duplicates are generated so the search space is not minimal. [The idea is from @yavinci](https://discuss.leetcode.com/topic/30743/easiest-9ms-java-solution).\\n* java\\n```\\n\\tpublic List<String> removeInvalidParentheses(String s) {\\n        int left=0, right=0;\\n        for(int i=0;i<s.length();i++) {\\n            char c = s.charAt(i);\\n            if(c==\\'(\\') {\\n                left++;\\n            } else if(c==\\')\\') {\\n                if(left==0) {\\n                    right++;\\n                } else {\\n                    left--;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(0, 0, left, right, s, new StringBuilder(), res);\\n        return new ArrayList(res);\\n    }\\n    private void dfs(int i, int open, int left, int right, String s, StringBuilder sb, Set<String> res) {\\n        if(i==s.length() ||open<0 ||left<0||right<0) {\\n            if(open==0 && left==0 && right==0) {\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n        char c = s.charAt(i++);\\n        if(c==\\'(\\') {\\n            dfs(i, open, left-1, right, s, sb, res);\\n            dfs(i, open+1, left, right, s, sb.append(c), res);\\n        } else if(c==\\')\\') {\\n            dfs(i, open, left, right-1, s, sb, res);\\n            dfs(i, open-1, left, right, s, sb.append(c), res);\\n        } else {\\n            dfs(i, open, left, right, s, sb.append(c), res);\\n        }\\n        sb.setLength(sb.length()-1);\\n    }\\n}\\n```\\n* c++\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        int rmL=0,rmR=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]==\\'(\\') rmL++;\\n            if(s[i]==\\')\\') {\\n                if(rmL>0) rmL--;\\n                else rmR++;\\n            } \\n        }\\n        unordered_set<string> res; \\n        string one;\\n        dfs(s, 0, rmL, rmR, 0, one, res);\\n        return vector<string> (res.begin(),res.end());\\n    }\\n    void dfs(string &s, int i, int rmL, int rmR, int pl, string &one, unordered_set<string> &res) {\\n        if(i == s.size() || rmL<0 || rmR<0 ||pl<0) {\\n            if(rmL==0 && rmR==0 && pl==0) res.insert(one);\\n            return;\\n        }\\n        if(s[i]==\\'(\\') {\\n            dfs(s,i+1,rmL-1,rmR,pl,one,res);\\n            one+=\\'(\\';\\n            dfs(s,i+1,rmL,rmR,pl+1,one,res);\\n        } else if(s[i]==\\')\\') {\\n            dfs(s,i+1,rmL,rmR-1,pl,one,res);\\n            one+=\\')\\';\\n            dfs(s,i+1,rmL,rmR,pl-1,one,res);\\n        } else {\\n            one+=s[i];\\n            dfs(s,i+1,rmL,rmR,pl,one,res);\\n        }\\n        one.pop_back();\\n    } \\n```\\n4. [DFS of unique strings from @cqnkxy ](https://discuss.leetcode.com/topic/28819/c-depth-limited-dfs-3ms-eliminate-duplicates-without-hashmap). Search space is not optimal because it expands from invalid strings.\\n5. [DFS of unique and valid strings from @dietpepsi ](https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution) This is the optimal solution and source of all the ideas.\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> res;\\n        dfs(0,0,\"()\",s,res);\\n        return res;\\n    }\\n    void dfs(int p, int lastRm, char dir[], string s, vector<string>& res) {\\n        for(int i=p, count=0;i<s.size();i++) {\\n            if(s[i]==dir[0]) count++;\\n            else if(s[i]==dir[1]) count--;\\n            if(count>=0) continue;\\n            for(int j=lastRm;j<=i;j++)\\n                if(s[j]==dir[1] && (j==lastRm || s[j-1]!=dir[1]))\\n                    dfs(i,j,dir,s.substr(0,j)+s.substr(j+1),res);\\n            return;        \\n        }\\n        reverse(s.begin(),s.end());\\n        if(dir[0]==\\'(\\') dfs(0,0,\")(\",s,res);\\n        else res.push_back(s);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<string> q;\\n        unordered_set<string> ht;\\n        q.push(s);\\n        vector<string> res;\\n        while(!q.empty()) {\\n            string ss = q.front();\\n            q.pop();\\n            if(ht.count(ss)) continue;\\n            ht.insert(ss);\\n            if(isValid(ss)) res.push_back(ss);\\n            else if (res.empty()) \\n                for(int i=0;i<ss.size();i++) \\n                    if(ss[i]==\\')\\'|| ss[i]==\\'(\\') q.push(ss.substr(0,i)+ss.substr(i+1));\\n        }\\n        return res;\\n    }\\n    bool isValid(string &s) {\\n        int count=0;\\n        for(auto c:s) {\\n            if(c==\\'(\\') count++;\\n            if(c==\\')\\')\\n                if(count>0) count--;\\n                else return false;\\n        }\\n        return !count;\\n    }\\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<pair<string,int>> q;\\n        q.push(make_pair(s,0));\\n        vector<string> res;\\n        while(!q.empty()) {\\n            auto p=q.front();\\n            q.pop();\\n            string ss=p.first;\\n            if(isValid(ss)) res.push_back(ss);\\n            else if (res.empty()) \\n                for(int i=p.second;i<ss.size();i++) \\n                    if((ss[i]==\\')\\'|| ss[i]==\\'(\\') && (i==p.second || ss[i]!=ss[i-1])) \\n                        q.push(make_pair(ss.substr(0,i)+ss.substr(i+1),i));\\n        }\\n        return res;\\n    }\\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<tuple<string,int,int,char>> q;\\n        q.push(make_tuple(s,0,0,\\'(\\'));\\n        vector<string> res;\\n        while(!q.empty()) {\\n            auto t=q.front();\\n            q.pop();\\n            string str=get<0>(t);\\n            int start =get<1>(t), lastRm=get<2>(t), count = 0;\\n            char l = get<3>(t), r = l==\\'(\\'?\\')\\':\\'(\\';\\n            for(int i=start; i<str.size();i++) {\\n                if(str[i] == l) count++;\\n                else if(str[i]==r) count--;\\n                if(count>=0) continue;\\n                for(int j=lastRm;j<=i;j++)\\n                    if(str[j]==r && (j==lastRm || str[j-1]!=r))\\n                        q.push(make_tuple(str.substr(0,j)+str.substr(j+1),i,j,l));\\n                break;\\n            }\\n            if(count < 0) continue;\\n            reverse(str.begin(),str.end());\\n            if(l==\\'(\\') q.push(make_tuple(str,0,0,\\')\\'));\\n            else res.push_back(str);\\n        }\\n        return res;\\n    }\\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string> ht;\\n        string cur;\\n        dfs(0,cur,s,ht);\\n        size_t ml = 0;\\n        for(auto& str:ht) ml = max(ml,str.size());\\n        vector<string> res;\\n        for(auto& str:ht) if(str.size()==ml) res.push_back(str);\\n        return res;\\n    }\\n    void dfs(int p, string& cur, string& s, unordered_set<string>& res) {\\n        if(p==s.size()) {\\n            if(isValid(cur)) res.insert(cur);\\n            return;\\n        }\\n        cur+=s[p];\\n        dfs(p+1,cur,s,res);\\n        cur.pop_back();\\n        if(s[p]==\\'(\\'||s[p]==\\')\\') dfs(p+1,cur,s,res); \\n    }\\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_map<string,int> vstd;\\n        string cur;\\n        unordered_set<string> ht;\\n        dfs(0,cur,s, ht, vstd);\\n        size_t ml = 0;\\n        for(auto& str:ht) ml = max(ml,str.size());\\n        vector<string> res;\\n        for(auto& str:ht) if(str.size()==ml) res.push_back(str);\\n        return res;\\n    }\\n    void dfs(int p, string& cur, string& s, unordered_set<string>& res, unordered_map<string,int>& vstd) {\\n        auto it = vstd.find(cur);\\n        if(it!=vstd.end() && it->second <= p) return;\\n        if(p==s.size()) {\\n            if(isValid(cur)) res.insert(cur);\\n            return;\\n        }\\n        cur+=s[p];\\n        dfs(p+1,cur,s,res,vstd);\\n        cur.pop_back();\\n        if(s[p]==\\'(\\'||s[p]==\\')\\') dfs(p+1,cur,s,res,vstd);\\n        if(it == vstd.end()) vstd[cur] = p;\\n        else it->second = min(it->second,p);\\n    }\\n```\n```\\n\\tpublic List<String> removeInvalidParentheses(String s) {\\n        int left=0, right=0;\\n        for(int i=0;i<s.length();i++) {\\n            char c = s.charAt(i);\\n            if(c==\\'(\\') {\\n                left++;\\n            } else if(c==\\')\\') {\\n                if(left==0) {\\n                    right++;\\n                } else {\\n                    left--;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(0, 0, left, right, s, new StringBuilder(), res);\\n        return new ArrayList(res);\\n    }\\n    private void dfs(int i, int open, int left, int right, String s, StringBuilder sb, Set<String> res) {\\n        if(i==s.length() ||open<0 ||left<0||right<0) {\\n            if(open==0 && left==0 && right==0) {\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n        char c = s.charAt(i++);\\n        if(c==\\'(\\') {\\n            dfs(i, open, left-1, right, s, sb, res);\\n            dfs(i, open+1, left, right, s, sb.append(c), res);\\n        } else if(c==\\')\\') {\\n            dfs(i, open, left, right-1, s, sb, res);\\n            dfs(i, open-1, left, right, s, sb.append(c), res);\\n        } else {\\n            dfs(i, open, left, right, s, sb.append(c), res);\\n        }\\n        sb.setLength(sb.length()-1);\\n    }\\n}\\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        int rmL=0,rmR=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]==\\'(\\') rmL++;\\n            if(s[i]==\\')\\') {\\n                if(rmL>0) rmL--;\\n                else rmR++;\\n            } \\n        }\\n        unordered_set<string> res; \\n        string one;\\n        dfs(s, 0, rmL, rmR, 0, one, res);\\n        return vector<string> (res.begin(),res.end());\\n    }\\n    void dfs(string &s, int i, int rmL, int rmR, int pl, string &one, unordered_set<string> &res) {\\n        if(i == s.size() || rmL<0 || rmR<0 ||pl<0) {\\n            if(rmL==0 && rmR==0 && pl==0) res.insert(one);\\n            return;\\n        }\\n        if(s[i]==\\'(\\') {\\n            dfs(s,i+1,rmL-1,rmR,pl,one,res);\\n            one+=\\'(\\';\\n            dfs(s,i+1,rmL,rmR,pl+1,one,res);\\n        } else if(s[i]==\\')\\') {\\n            dfs(s,i+1,rmL,rmR-1,pl,one,res);\\n            one+=\\')\\';\\n            dfs(s,i+1,rmL,rmR,pl-1,one,res);\\n        } else {\\n            one+=s[i];\\n            dfs(s,i+1,rmL,rmR,pl,one,res);\\n        }\\n        one.pop_back();\\n    } \\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> res;\\n        dfs(0,0,\"()\",s,res);\\n        return res;\\n    }\\n    void dfs(int p, int lastRm, char dir[], string s, vector<string>& res) {\\n        for(int i=p, count=0;i<s.size();i++) {\\n            if(s[i]==dir[0]) count++;\\n            else if(s[i]==dir[1]) count--;\\n            if(count>=0) continue;\\n            for(int j=lastRm;j<=i;j++)\\n                if(s[j]==dir[1] && (j==lastRm || s[j-1]!=dir[1]))\\n                    dfs(i,j,dir,s.substr(0,j)+s.substr(j+1),res);\\n            return;        \\n        }\\n        reverse(s.begin(),s.end());\\n        if(dir[0]==\\'(\\') dfs(0,0,\")(\",s,res);\\n        else res.push_back(s);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165420,
                "title": "thinking-process-bfs",
                "content": "We are required to return the minimum number of invalid parentheses to remove.\\n\\nLet\\'s model the problem as a graph, \\n```\\nnode: all possible string by removing parenthesis (The start node is `s`)\\nedge (from u to v): by removing a parentheses of u\\n```\\n\\nAs a result, the problem becomes to get the shortest distance from `s` to a valid node (assuming at level `l`) in the first place; then get all valid nodes within level `l`.\\n\\nShortest-path problem is natural to **BFS**.\\n\\n****\\n```\\n    public List<String> removeInvalidParentheses(String s) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.offer(s);\\n        \\n        List<String> validStrInCurLevel = new ArrayList<>(); // Indicate whether a valid node has been met as well\\n        \\n        // Level-BFS\\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            for (int j = 0; j < sz; j++) {\\n                String cur = q.poll();\\n                \\n                if (valid(cur)) {\\n                    validStrInCurLevel.add(cur);\\n                }\\n                \\n                if (validStrInCurLevel.isEmpty()) { // If no valid node has been met\\n                    // Add adjacent nodes to queue\\n                    for (int i = 0; i < cur.length(); i++) {\\n                        if (cur.charAt(i) == \\'(\\' || cur.charAt(i) == \\')\\') {\\n                            String adj = cur.substring(0, i) + cur.substring(i + 1);\\n                            if (!visited.contains(adj)) {\\n                                visited.add(adj);\\n                                q.offer(adj);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (!validStrInCurLevel.isEmpty()) { // If a valid node has been met, return valid nodes in the same level\\n                return validStrInCurLevel;\\n            }\\n        }\\n        throw null;\\n    }\\n    \\n    private boolean valid(String s) {\\n        int score = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' )\\n                score++;\\n            else if (s.charAt(i) == \\')\\')\\n                score--;\\n            if (score < 0)\\n                return false;\\n        }\\n        return score == 0;\\n    }\\n```\\n(\\u0E51\\u2022 . \\u2022\\u0E51)",
                "solutionTags": [],
                "code": "```\\nnode: all possible string by removing parenthesis (The start node is `s`)\\nedge (from u to v): by removing a parentheses of u\\n```\n```\\n    public List<String> removeInvalidParentheses(String s) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.offer(s);\\n        \\n        List<String> validStrInCurLevel = new ArrayList<>(); // Indicate whether a valid node has been met as well\\n        \\n        // Level-BFS\\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            for (int j = 0; j < sz; j++) {\\n                String cur = q.poll();\\n                \\n                if (valid(cur)) {\\n                    validStrInCurLevel.add(cur);\\n                }\\n                \\n                if (validStrInCurLevel.isEmpty()) { // If no valid node has been met\\n                    // Add adjacent nodes to queue\\n                    for (int i = 0; i < cur.length(); i++) {\\n                        if (cur.charAt(i) == \\'(\\' || cur.charAt(i) == \\')\\') {\\n                            String adj = cur.substring(0, i) + cur.substring(i + 1);\\n                            if (!visited.contains(adj)) {\\n                                visited.add(adj);\\n                                q.offer(adj);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (!validStrInCurLevel.isEmpty()) { // If a valid node has been met, return valid nodes in the same level\\n                return validStrInCurLevel;\\n            }\\n        }\\n        throw null;\\n    }\\n    \\n    private boolean valid(String s) {\\n        int score = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\' )\\n                score++;\\n            else if (s.charAt(i) == \\')\\')\\n                score--;\\n            if (score < 0)\\n                return false;\\n        }\\n        return score == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75028,
                "title": "short-python-bfs",
                "content": "**Solution 1**\\n\\nBeing lazy and using `eval` for checking:\\n\\n    def removeInvalidParentheses(self, s):\\n        level = {s}\\n        while True:\\n            valid = []\\n            for s in level:\\n                try:\\n                    eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                    valid.append(s)\\n                except:\\n                    pass\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\nUpdate: Meh, ok, checking it myself isn't that much longer, and it's three times as fast:\\n\\n**Solution 2**\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            ctr = 0\\n            for c in s:\\n                if c == '(':\\n                    ctr += 1\\n                elif c == ')':\\n                    ctr -= 1\\n                    if ctr < 0:\\n                        return False\\n            return ctr == 0\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\n**Solution 3**\\n\\nJust a mix of the above two.\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            try:\\n                eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                return True\\n            except:\\n                pass\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\n**Solution 4**\\n\\nYet another way to do `isvalid`.\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            s = filter('()'.count, s)\\n            while '()' in s:\\n                s = s.replace('()', '')\\n            return not s\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1**\\n\\nBeing lazy and using `eval` for checking:\\n\\n    def removeInvalidParentheses(self, s):\\n        level = {s}\\n        while True:\\n            valid = []\\n            for s in level:\\n                try:\\n                    eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                    valid.append(s)\\n                except:\\n                    pass\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\nUpdate: Meh, ok, checking it myself isn't that much longer, and it's three times as fast:\\n\\n**Solution 2**\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            ctr = 0\\n            for c in s:\\n                if c == '(':\\n                    ctr += 1\\n                elif c == ')':\\n                    ctr -= 1\\n                    if ctr < 0:\\n                        return False\\n            return ctr == 0\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\n**Solution 3**\\n\\nJust a mix of the above two.\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            try:\\n                eval('0,' + filter('()'.count, s).replace(')', '),'))\\n                return True\\n            except:\\n                pass\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}\\n\\n---\\n\\n**Solution 4**\\n\\nYet another way to do `isvalid`.\\n\\n    def removeInvalidParentheses(self, s):\\n        def isvalid(s):\\n            s = filter('()'.count, s)\\n            while '()' in s:\\n                s = s.replace('()', '')\\n            return not s\\n        level = {s}\\n        while True:\\n            valid = filter(isvalid, level)\\n            if valid:\\n                return valid\\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}",
                "codeTag": "Python3"
            },
            {
                "id": 75050,
                "title": "my-c-dfs-solution-16ms",
                "content": "    class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            unordered_set<string> result;\\n            int left_removed = 0;\\n            int right_removed = 0;\\n            for(auto c : s) {\\n                if(c == '(') {\\n                    ++left_removed;\\n                }\\n                if(c == ')') {\\n                    if(left_removed != 0) {\\n                        --left_removed;\\n                    }\\n                    else {\\n                        ++right_removed;\\n                    }\\n                }\\n            }\\n            helper(s, 0, left_removed, right_removed, 0, \"\", result);\\n            return vector<string>(result.begin(), result.end());\\n        }\\n    private:\\n        void helper(string s, int index, int left_removed, int right_removed, int pair, string path, unordered_set<string>& result) {\\n            if(index == s.size()) {\\n                if(left_removed == 0 && right_removed == 0 && pair == 0) {\\n                    result.insert(path);\\n                }\\n                return;\\n            }\\n            if(s[index] != '(' && s[index] != ')') {\\n                helper(s, index + 1, left_removed, right_removed, pair, path + s[index], result);\\n            }\\n            else {\\n                if(s[index] == '(') {\\n                    if(left_removed > 0) {\\n                        helper(s, index + 1, left_removed - 1, right_removed, pair, path, result);\\n                    }\\n                    helper(s, index + 1, left_removed, right_removed, pair + 1, path + s[index], result);\\n                }\\n                if(s[index] == ')') {\\n                    if(right_removed > 0) {\\n                        helper(s, index + 1, left_removed, right_removed - 1, pair, path, result);\\n                    }\\n                    if(pair > 0) {\\n                        helper(s, index + 1, left_removed, right_removed, pair - 1, path + s[index], result);\\n                    }\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            unordered_set<string> result;\\n            int left_removed = 0;\\n            int right_removed = 0;\\n            for(auto c : s) {\\n                if(c == '(') {\\n                    ++left_removed;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 606847,
                "title": "java-python-dfs-with-memoization-fastest-clean-concise",
                "content": "**Idea**\\n- Generate all valid parentheses from string `s`, we can memoize them to avoid re-compute sub-problem again. It\\'s the same idea with **[140. Word Break II](https://leetcode.com/problems/word-break-ii/)**.\\n- Then get the maximum length among those valid parentheses.\\n- Filter the result by choosing parentheses which has the length equals to the maximum length.\\n\\n<iframe src=\"https://leetcode.com/playground/6hRb2XX6/shared\" frameBorder=\"0\" width=\"100%\" height=\"660\"></iframe>",
                "solutionTags": [],
                "code": "**Idea**\\n- Generate all valid parentheses from string `s`, we can memoize them to avoid re-compute sub-problem again. It\\'s the same idea with **[140. Word Break II](https://leetcode.com/problems/word-break-ii/)**.\\n- Then get the maximum length among those valid parentheses.\\n- Filter the result by choosing parentheses which has the length equals to the maximum length.\\n\\n<iframe src=\"https://leetcode.com/playground/6hRb2XX6/shared\" frameBorder=\"0\" width=\"100%\" height=\"660\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 75048,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "    class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            int remove_left=0, remove_right=0, pair=0;\\n            /*** use the unordered_set to deal with the duplicate cases ***/\\n            unordered_set<string> result;\\n            /***  calculate the remained # of left and right parentheses  ***/\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]=='(')   remove_left++;\\n                else if(s[i]==')'){\\n                    if(remove_left > 0) remove_left--;\\n                    else    remove_right++;\\n                }\\n            }\\n            help(0, 0, remove_left, remove_right, s, \"\", result);\\n            /*** change the unordered_set to vector ***/\\n            return vector<string>(result.begin(), result.end());\\n        }\\n        \\n        /***\\n        pair : record the () pair count in the solution\\n        index : record the cur-position int the string s\\n        remove_left : the number of left parentheses needed to delete\\n        remove_right : the number of right parentheses needed to delete\\n        s : origninal input string    solution : the current produced string\\n        result : stores all the satisfied solution string\\n        ***/\\n        void help(int pair, int index, int remove_left, int remove_right, const string& s, string solution, unordered_set<string>& result){\\n            /***   end condition       ***/\\n            if(index==s.size()){\\n                /*** check whether the remained string solution is right  ***/\\n                if(pair==0 && remove_left==0 && remove_right==0)    result.insert(solution);\\n                return;\\n            }\\n            /***    left-half-parentheses     ***/\\n            if(s[index]=='('){\\n                /***    remove the left-half-parentheses     ***/\\n                if(remove_left > 0)     help(pair, index+1, remove_left-1, remove_right, s, solution, result);\\n                /***    keep  the  left-half-parentheses     ***/\\n                help(pair+1, index+1, remove_left, remove_right, s, solution+s[index], result);\\n            }\\n            /***    right-half-parentheses     ***/\\n            else if(s[index]==')'){\\n                /***    remove the right-half-parentheses     ***/\\n                if(remove_right > 0)     help(pair, index+1, remove_left, remove_right-1, s, solution, result);\\n                /***    keep  the  right-half-parentheses     ***/\\n                if(pair > 0) help(pair-1, index+1, remove_left, remove_right, s, solution+s[index], result);\\n            }\\n            /***    other-characters     ***/\\n            else{\\n                help(pair, index+1, remove_left, remove_right, s, solution+s[index], result);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            int remove_left=0, remove_right=0, pair=0;\\n            /*** use the unordered_set to deal with the duplicate cases ***/\\n            unordered_set<string> result;\\n            /***  calculate the remained # of left and right parentheses  ***/\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]=='(')   remove_left++;\\n                else if(s[i]==')'){\\n                    if(remove_left > 0) remove_left--;\\n                    else    remove_right++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 75041,
                "title": "java-bfs-solution-16ms-avoid-generating-duplicate-strings",
                "content": "The naive BFS solution is quite simple to implement. To speed up we can use a Set to record all the strings generated and avoid revisit. But a better and faster solution is to avoid generate duplicate strings all together.\\n\\n\\nThe first observation is when we want to remove a ')' or '(' from several consecutive ones we only remove the first one, because remove any one the result will be the same. For example\\n\\n    \"())\" ---> \"()\"\\n    only remove the first one of '))'\\n\\nThe second observation is when we remove a character it must behind it's parent removal position. For example\\n\\n    we need remove 2 from \"(())((\"\\n    we want to remove positions combination i,j with no duplicate\\n    so we let i < j then it will not generate duplicate combinations\\n    in practice, we record the position i and put it in to queue\\n    which is then polled out and used as the starting point of the next removal\\n\\nA third observation is if the previous step we removed a \"(\", we should never remove a \")\" in the following steps. This is obvious since otherwise we could just save these two removals and still be valid with less removals. With this observation all the possible removals will be something like this\\n\\n    \")))))))))(((((((((\"\\n\\nAll the removed characters forming a string with consecutive left bracket followed by consecutive right bracket.\\n\\nBy applying these restrictions, we can avoid generate duplicate strings and the need of a set which saves a lot of space.\\n\\n\\nUltimately we can further improve the algorithm to eliminate isValid calls. To do this we need to remove and only remove those characters that would lead us to valid strings. This needs some preprocess and can reduce the time to around 3ms.\\n\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        if (isValid(s))\\n            return Collections.singletonList(s);\\n        List<String> ans = new ArrayList<>();\\n        //The queue only contains invalid middle steps\\n        Queue<Tuple> queue = new LinkedList<>();\\n        //The 3-Tuple is (string, startIndex, lastRemovedChar)\\n        queue.add(new Tuple(s, 0, ')'));\\n        while (!queue.isEmpty()) {\\n            Tuple x = queue.poll();\\n            //Observation 2, start from last removal position\\n            for (int i = x.start; i < x.string.length(); ++i) {\\n                char ch = x.string.charAt(i);\\n                //Not parentheses\\n                if (ch != '(' && ch != ')') continue;\\n                //Observation 1, do not repeatedly remove from consecutive ones\\n                if (i != x.start && x.string.charAt(i - 1) == ch) continue;\\n                //Observation 3, do not remove a pair of valid parentheses\\n                if (x.removed == '(' && ch == ')') continue;\\n                String t = x.string.substring(0, i) + x.string.substring(i + 1);\\n                //Check isValid before add\\n                if (isValid(t))\\n                    ans.add(t);\\n                //Avoid adding leaf level strings\\n                else if (ans.isEmpty())\\n                    queue.add(new Tuple(t, i, ch));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == '(') ++count;\\n            if (c == ')' && count-- == 0) return false;\\n        }\\n        return count == 0;\\n    }\\n\\n    private class Tuple {\\n        public final String string;\\n        public final int start;\\n        public final char removed;\\n\\n        public Tuple(String string, int start, char removed) {\\n            this.string = string;\\n            this.start = start;\\n            this.removed = removed;\\n        }\\n    }\\n    //  125 / 125 test cases passed.\\n    //  Status: Accepted\\n    //  Runtime: 16 ms",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "The naive BFS solution is quite simple to implement. To speed up we can use a Set to record all the strings generated and avoid revisit. But a better and faster solution is to avoid generate duplicate strings all together.\\n\\n\\nThe first observation is when we want to remove a ')' or '(' from several consecutive ones we only remove the first one, because remove any one the result will be the same. For example\\n\\n    \"())\" ---> \"()\"\\n    only remove the first one of '))'\\n\\nThe second observation is when we remove a character it must behind it's parent removal position. For example\\n\\n    we need remove 2 from \"(())((\"\\n    we want to remove positions combination i,j with no duplicate\\n    so we let i < j then it will not generate duplicate combinations\\n    in practice, we record the position i and put it in to queue\\n    which is then polled out and used as the starting point of the next removal\\n\\nA third observation is if the previous step we removed a \"(\", we should never remove a \")\" in the following steps. This is obvious since otherwise we could just save these two removals and still be valid with less removals. With this observation all the possible removals will be something like this\\n\\n    \")))))))))(((((((((\"\\n\\nAll the removed characters forming a string with consecutive left bracket followed by consecutive right bracket.\\n\\nBy applying these restrictions, we can avoid generate duplicate strings and the need of a set which saves a lot of space.\\n\\n\\nUltimately we can further improve the algorithm to eliminate isValid calls. To do this we need to remove and only remove those characters that would lead us to valid strings. This needs some preprocess and can reduce the time to around 3ms.\\n\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        if (isValid(s))\\n            return Collections.singletonList(s);\\n        List<String> ans = new ArrayList<>();\\n        //The queue only contains invalid middle steps\\n        Queue<Tuple> queue = new LinkedList<>();\\n        //The 3-Tuple is (string, startIndex, lastRemovedChar)\\n        queue.add(new Tuple(s, 0, ')'));\\n        while (!queue.isEmpty()) {\\n            Tuple x = queue.poll();\\n            //Observation 2, start from last removal position\\n            for (int i = x.start; i < x.string.length(); ++i) {\\n                char ch = x.string.charAt(i);\\n                //Not parentheses\\n                if (ch != '(' && ch != ')') continue;\\n                //Observation 1, do not repeatedly remove from consecutive ones\\n                if (i != x.start && x.string.charAt(i - 1) == ch) continue;\\n                //Observation 3, do not remove a pair of valid parentheses\\n                if (x.removed == '(' && ch == ')') continue;\\n                String t = x.string.substring(0, i) + x.string.substring(i + 1);\\n                //Check isValid before add\\n                if (isValid(t))\\n                    ans.add(t);\\n                //Avoid adding leaf level strings\\n                else if (ans.isEmpty())\\n                    queue.add(new Tuple(t, i, ch));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static boolean isValid(String s) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == '(') ++count;\\n            if (c == ')' && count-- == 0) return false;\\n        }\\n        return count == 0;\\n    }\\n\\n    private class Tuple {\\n        public final String string;\\n        public final int start;\\n        public final char removed;\\n\\n        public Tuple(String string, int start, char removed) {\\n            this.string = string;\\n            this.start = start;\\n            this.removed = removed;\\n        }\\n    }\\n    //  125 / 125 test cases passed.\\n    //  Status: Accepted\\n    //  Runtime: 16 ms",
                "codeTag": "Java"
            },
            {
                "id": 75057,
                "title": "44ms-python-solution",
                "content": " - Scan from left to right, make sure count[\"(\"]>=count[\")\"].  \\n - Then scan from right to left, make sure count[\"(\"]<=count[\")\"].\\n\\n----------\\n\\n\\n    class Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        removed = 0\\n        results = {s}\\n        count = {\"(\": 0, \")\": 0}\\n        for i, c in enumerate(s):\\n            if c == \")\" and count[\"(\"] == count[\")\"]:\\n                new_results = set()\\n                while results:\\n                    result = results.pop()\\n                    for j in range(i - removed + 1):\\n                        if result[j] == \")\":\\n                            new_results.add(result[:j] + result[j + 1:])\\n                results = new_results\\n                removed += 1\\n            else:\\n                if c in count:\\n                    count[c] += 1\\n        count = {\"(\": 0, \")\": 0}\\n        i = len(s)\\n        ll = len(s) - removed\\n        for ii in range(ll - 1, -1, -1):\\n            i-=1\\n            c = s[i]\\n            if c == \"(\" and count[\"(\"] == count[\")\"]:\\n                new_results = set()\\n                while results:\\n                    result = results.pop()\\n                    for j in range(ii, ll):\\n                        if result[j] == \"(\":\\n                            new_results.add(result[:j] + result[j + 1:])\\n                results = new_results\\n                ll -= 1\\n            else:\\n                if c in count:\\n                    count[c] += 1\\n        return list(results)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        removed = 0\\n        results = {s}",
                "codeTag": "Java"
            },
            {
                "id": 75095,
                "title": "java-optimized-dfs-solution-3-ms",
                "content": "DFS solution with optimizations:\\n\\n1. Before starting DFS, calculate the total numbers of opening and closing parentheses that need to be removed in the final solution, then these two numbers could be used to speed up the DFS process.\\n2. Use while loop to avoid duplicate result in DFS, instead of using HashSet.\\n3. Use count variable to validate the parentheses dynamically.\\n\\n----------\\n     public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            int count = 0, openN = 0, closeN = 0;\\n\\n            // calculate the total numbers of opening and closing parentheses\\n            // that need to be removed in the final solution\\n            for (char c : s.toCharArray()) {\\n                if (c == '(') {\\n                    count++;\\n                } else if (c == ')') {\\n                    if (count == 0) closeN++;\\n                    else count--;\\n                }\\n            }\\n            openN = count;\\n            count = 0;\\n    \\n            if (openN == 0 && closeN == 0) return Arrays.asList(s);\\n    \\n            List<String> result = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n    \\n            dfs(s.toCharArray(), 0, count, openN, closeN, result, sb);\\n    \\n            return result;\\n        }\\n    \\n        private void dfs(char[] s, int p, int count, int openN, int closeN, List<String> result, StringBuilder sb) {\\n            if (count < 0) return; // the parentheses is invalid\\n\\n            if (p == s.length) {\\n                if (openN == 0 && closeN == 0) { // the minimum number of invalid parentheses have been removed\\n                    result.add(sb.toString());\\n                }\\n                return;\\n            }\\n    \\n            if (s[p] != '(' && s[p] != ')') {\\n                sb.append(s[p]);\\n                dfs(s, p + 1, count, openN, closeN, result, sb);\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else if (s[p] == '(') {\\n                int i = 1;\\n                while (p + i < s.length && s[p + i] == '(') i++; // use while loop to avoid duplicate result in DFS, instead of using HashSet\\n                sb.append(s, p, i);\\n                dfs(s, p + i, count + i, openN, closeN, result, sb);\\n                sb.delete(sb.length() - i, sb.length());\\n    \\n                if (openN > 0) {\\n                    // remove the current opening parenthesis\\n                    dfs(s, p + 1, count, openN - 1, closeN, result, sb);\\n                }\\n            } else {\\n                int i = 1;\\n                while (p + i < s.length && s[p + i] == ')') i++; // use while loop to avoid duplicate result in DFS, instead of using HashSet\\n                sb.append(s, p, i);\\n                dfs(s, p + i, count - i, openN, closeN, result, sb);\\n                sb.delete(sb.length() - i, sb.length());\\n    \\n                if (closeN > 0) {\\n                    // remove the current closing parenthesis\\n                    dfs(s, p + 1, count, openN, closeN - 1, result, sb);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            int count = 0, openN = 0, closeN = 0;\\n\\n            // calculate the total numbers of opening and closing parentheses\\n            // that need to be removed in the final solution\\n            for (char c : s.toCharArray()) {\\n                if (c == '(') {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 75117,
                "title": "python-dfs-solution",
                "content": "The basic idea is recursive DFS with pruning function. \\n\\nGenerate new strings by removing parenthesis, and calculate the total number of mismatched parentheses inside the string by *function* **calc(s)**. \\n\\nIf the mismatched parentheses increased, then discard the string.\\n\\n    class Solution(object):\\n        def removeInvalidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            def dfs(s):\\n                mi = calc(s)\\n                if mi == 0:\\n                    return [s]\\n                ans = []\\n                for x in range(len(s)):\\n                    if s[x] in ('(', ')'):\\n                        ns = s[:x] + s[x+1:]\\n                        if ns not in visited and calc(ns) < mi:\\n                            visited.add(ns)\\n                            ans.extend(dfs(ns))\\n                return ans    \\n            def calc(s):\\n                a = b = 0\\n                for c in s:\\n                    a += {'(' : 1, ')' : -1}.get(c, 0)\\n                    b += a < 0\\n                    a = max(a, 0)\\n                return a + b\\n    \\n            visited = set([s])    \\n            return dfs(s)\\n\\nref: [http://bookshadow.com/weblog/2015/11/05/leetcode-remove-invalid-parentheses/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/11/05/leetcode-remove-invalid-parentheses/",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution(object):\\n        def removeInvalidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            def dfs(s):\\n                mi = calc(s)\\n                if mi == 0:\\n                    return [s]\\n                ans = []\\n                for x in range(len(s)):\\n                    if s[x] in ('(', ')'):\\n                        ns = s[:x] + s[x+1:]\\n                        if ns not in visited and calc(ns) < mi:\\n                            visited.add(ns)\\n                            ans.extend(dfs(ns))\\n                return ans    \\n            def calc(s):\\n                a = b = 0\\n                for c in s:\\n                    a += {'(' : 1, ')' : -1}",
                "codeTag": "Java"
            },
            {
                "id": 75046,
                "title": "c-depth-limited-dfs-3ms-eliminate-duplicates-without-hashmap",
                "content": "num1 and num2 stand for the number of '(' and ')' to remove respectively. Duplicates arise from consecutive '(' or ')'. We only get rid of the first one before going a level further.\\n\\n    class Solution {\\n    private:\\n        bool isValid(string s) {\\n            int sum = 0;\\n            for(char &c : s) {\\n                if(c == '(') ++sum;\\n                else if(c == ')') --sum;\\n                if(sum < 0) return false;\\n            }\\n            return sum == 0;\\n        }\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            int num1 = 0, num2 = 0;\\n            for(char &c : s) {\\n                num1 += c == '(';\\n                if (num1 == 0) {\\n                    num2 += c == ')';\\n                } else {\\n                    num1 -= c == ')';\\n                }\\n            }\\n            vector<string> ret;\\n            dfs(s, 0, num1, num2, ret);\\n            return ret;\\n        }\\n        void dfs(string s, int beg, int num1, int num2, vector<string> &ret) {\\n            if(num1 == 0 && num2 == 0) {\\n                if(isValid(s))\\n                    ret.push_back(s);\\n            } else {\\n                for(int i = beg; i < s.size(); ++i) {\\n                    string tmp = s;\\n                    if(num2 == 0 && num1 > 0 && tmp[i] == '(') {\\n                        if(i == beg || tmp[i] != tmp[i - 1]) {\\n                            tmp.erase(i, 1);\\n                            dfs(tmp, i, num1 - 1, num2, ret);\\n                        }\\n                    }\\n                    if(num2 > 0 && tmp[i] == ')') {\\n                        if(i == beg || tmp[i] != tmp[i - 1]) {\\n                            tmp.erase(i, 1);\\n                            dfs(tmp, i, num1, num2 - 1, ret);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool isValid(string s) {\\n            int sum = 0;\\n            for(char &c : s) {\\n                if(c == '(') ++sum;\\n                else if(c == ')') --sum;\\n                if(sum < 0) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1132245,
                "title": "bactracking-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_set<string> uset; \\n    int countRemoval(string s){\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(st.size()==0){\\n                    st.push(\\')\\');\\n                }\\n                else if(st.top()==\\')\\'){\\n                    st.push(\\')\\');\\n                }\\n                else if(st.top()==\\'(\\'){\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        int invalid=st.size(); //minimum removals\\n        \\n        return invalid;\\n    }\\n   \\n    void helper(int invalid,string s){\\n        if(invalid<0) return;\\n        if(invalid==0){ \\n            int invalidNow=countRemoval(s);\\n            if(invalidNow==0){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n      for(int i=0;i<s.size();i++){\\n          if (s[i] != \\')\\' && s[i] != \\'(\\')\\n                {\\n                continue;\\n                }\\n          \\n          string left=s.substr(0,i);\\n          string right=s.substr(i+1);\\n          string temp=left+right;\\n          if(uset.find(temp)==uset.end()){\\n              uset.insert(temp);\\n            helper(invalid-1,temp);       \\n          }\\n               \\n      }  \\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        int invalid=countRemoval(s);\\n        helper(invalid,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_set<string> uset; \\n    int countRemoval(string s){\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(st.size()==0){\\n                    st.push(\\')\\');\\n                }\\n                else if(st.top()==\\')\\'){\\n                    st.push(\\')\\');\\n                }\\n                else if(st.top()==\\'(\\'){\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        int invalid=st.size(); //minimum removals\\n        \\n        return invalid;\\n    }\\n   \\n    void helper(int invalid,string s){\\n        if(invalid<0) return;\\n        if(invalid==0){ \\n            int invalidNow=countRemoval(s);\\n            if(invalidNow==0){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n      for(int i=0;i<s.size();i++){\\n          if (s[i] != \\')\\' && s[i] != \\'(\\')\\n                {\\n                continue;\\n                }\\n          \\n          string left=s.substr(0,i);\\n          string right=s.substr(i+1);\\n          string temp=left+right;\\n          if(uset.find(temp)==uset.end()){\\n              uset.insert(temp);\\n            helper(invalid-1,temp);       \\n          }\\n               \\n      }  \\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        int invalid=countRemoval(s);\\n        helper(invalid,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906780,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar isValid = string => {\\n    let open = 0;\\n    for (const c of string) {\\n        if (c === \\'(\\') open++;// Increment open brackets\\n        else if (c === \\')\\') {\\n            if (open === 0) return false;// If closing bracket, but no open bracket, this is invalid\\n            open--;\\n        }\\n    }\\n    \\n    return open === 0;// Open brackets should be zero for valid string\\n};\\n\\nvar removeInvalidParentheses = function(s) {\\n    /**\\n        Concept:\\n            -- Since we have to remove minimum number of invalid parentheses, the problem can be looked at as considering every invalid string and trying to remove a parentheses at each\\n               position and trying to see if all those strings are valid. This can be thought as similar to BFS.\\n            -- Every time an invalid string is present, we repeat the above process.\\n            -- If a valid string is found, that\\'s the string with minimum removes. We should be looking\\n               for more such valid strings in our queue, but not creating substrings anymore.\\n        \\n        Approach:\\n            -- Push input string on a queue and also mark it as seen, so we don\\'t look at it again.\\n            -- For each string removed from queue front, check if it is a valid string.\\n               -- If valid, keep looking for other valid strings in the queue.\\n               -- If invalid and a valid string is already found, don\\'t do anything.\\n               -- If invalid and no valid string is found, do the following:\\n                  -- For each character of the string, create a substring with all characters but that.\\n                  -- If the substring is not seen before, add it to seen and push to queue\\n    */\\n    \\n    // Time Complexity: O(2^N) since each one of N characters can be included in string or not.\\n    // Space Complexity: O(N^2) since there is worst case N recursion depth, with O(N) space to store string at each level\\n    \\n    if (!s || s.length === 0) return [\\'\\'];\\n    \\n    const queue = [s], seen = new Set(), result = [];\\n    seen.add(s);\\n    \\n    let validFound = false;\\n    \\n    while (queue.length > 0) {\\n        let expression = queue.shift();\\n        \\n        // If expression is valid\\n        if (isValid(expression)) {\\n            result.push(expression);// Push to result\\n            validFound = true;\\n        }\\n        \\n        if (validFound) continue;// If atleast one valid string found, don\\'t do anything\\n        \\n        for (let i = 0; i < expression.length; i++) {\\n            if (expression[i] !== \\'(\\' && expression[i] !== \\')\\') {\\n                continue;// If expression\\'s i-th character is anything but one of ( or ), continue\\n            }\\n            \\n            // Calculate next string for consideration\\n            // Characters 0 to i-th (not including) + Characters (i + 1)th (including) to end\\n            let next = expression.substring(0, i) + expression.substring(i + 1);\\n            if (!seen.has(next)) {\\n                seen.add(next);\\n                queue.push(next);\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar isValid = string => {\\n    let open = 0;\\n    for (const c of string) {\\n        if (c === \\'(\\') open++;// Increment open brackets\\n        else if (c === \\')\\') {\\n            if (open === 0) return false;// If closing bracket, but no open bracket, this is invalid\\n            open--;\\n        }\\n    }\\n    \\n    return open === 0;// Open brackets should be zero for valid string\\n};\\n\\nvar removeInvalidParentheses = function(s) {\\n    /**\\n        Concept:\\n            -- Since we have to remove minimum number of invalid parentheses, the problem can be looked at as considering every invalid string and trying to remove a parentheses at each\\n               position and trying to see if all those strings are valid. This can be thought as similar to BFS.\\n            -- Every time an invalid string is present, we repeat the above process.\\n            -- If a valid string is found, that\\'s the string with minimum removes. We should be looking\\n               for more such valid strings in our queue, but not creating substrings anymore.\\n        \\n        Approach:\\n            -- Push input string on a queue and also mark it as seen, so we don\\'t look at it again.\\n            -- For each string removed from queue front, check if it is a valid string.\\n               -- If valid, keep looking for other valid strings in the queue.\\n               -- If invalid and a valid string is already found, don\\'t do anything.\\n               -- If invalid and no valid string is found, do the following:\\n                  -- For each character of the string, create a substring with all characters but that.\\n                  -- If the substring is not seen before, add it to seen and push to queue\\n    */\\n    \\n    // Time Complexity: O(2^N) since each one of N characters can be included in string or not.\\n    // Space Complexity: O(N^2) since there is worst case N recursion depth, with O(N) space to store string at each level\\n    \\n    if (!s || s.length === 0) return [\\'\\'];\\n    \\n    const queue = [s], seen = new Set(), result = [];\\n    seen.add(s);\\n    \\n    let validFound = false;\\n    \\n    while (queue.length > 0) {\\n        let expression = queue.shift();\\n        \\n        // If expression is valid\\n        if (isValid(expression)) {\\n            result.push(expression);// Push to result\\n            validFound = true;\\n        }\\n        \\n        if (validFound) continue;// If atleast one valid string found, don\\'t do anything\\n        \\n        for (let i = 0; i < expression.length; i++) {\\n            if (expression[i] !== \\'(\\' && expression[i] !== \\')\\') {\\n                continue;// If expression\\'s i-th character is anything but one of ( or ), continue\\n            }\\n            \\n            // Calculate next string for consideration\\n            // Characters 0 to i-th (not including) + Characters (i + 1)th (including) to end\\n            let next = expression.substring(0, i) + expression.substring(i + 1);\\n            if (!seen.has(next)) {\\n                seen.add(next);\\n                queue.push(next);\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696750,
                "title": "python-backtracking-solution-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ## RC ##\\n        ## APPROACH : BACK-TRACKING ##\\n        ## Similar to Leetcode 32. Longest Valid Parentheses ##\\n        ## LOGIC ##\\n        #   1. use stack to find invalid left and right braces.\\n        #   2. if its close brace at index i , you can remove it directly to make it valid and also you can also remove any of the close braces before that i.e in the range [0,i-1]\\n        #   3. similarly for open brace, left over at index i, you can remove it or any other open brace after that i.e [i+1, end]\\n        #   4. if left over braces are more than 1 say 2 close braces here, you need to make combinations of all 2 braces before that index and find valid parentheses.\\n        #   5. so, we count left and right invalid braces and do backtracking removing them\\n        \\n\\t\\t## TIME COMPLEXITY : O(2^N) ## (each brace has 2 options: exits or to be removed)\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        def isValid(s):\\n            stack = []\\n            for i in range(len(s)):\\n                if( s[i] == \\'(\\' ):\\n                    stack.append( (i,\\'(\\') )\\n                elif( s[i] == \\')\\' ):\\n                    if(stack and stack[-1][1] == \\'(\\'):\\n                        stack.pop()\\n                    else:\\n                        stack.append( (i,\\')\\') )         # pushing invalid close braces also\\n            return len(stack) == 0, stack\\n        \\n        \\n        def dfs( s, left, right):\\n            visited.add(s)\\n            if left == 0 and right == 0 and isValid(s)[0]:  res.append(s)\\n            for i, ch in enumerate(s):\\n                if ch != \\'(\\' and ch != \\')\\': continue                                    # if it is any other char ignore.\\n                if (ch == \\'(\\' and left == 0) or (ch == \\')\\' and right == 0): continue    # if left == 0 then removing \\'(\\' will only cause imbalance. Hence, skip.\\n                if s[:i] + s[i+1:] not in visited:\\n                    dfs( s[:i] + s[i+1:], left - (ch == \\'(\\'), right - (ch == \\')\\') )\\n        \\n        stack = isValid(s)[1]\\n        lc = sum([1 for val in stack if val[1] == \"(\"]) # num of left braces\\n        rc = len(stack) - lc\\n        \\n        res, visited = [], set()\\n        dfs(s, lc, rc)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ## RC ##\\n        ## APPROACH : BACK-TRACKING ##\\n        ## Similar to Leetcode 32. Longest Valid Parentheses ##\\n        ## LOGIC ##\\n        #   1. use stack to find invalid left and right braces.\\n        #   2. if its close brace at index i , you can remove it directly to make it valid and also you can also remove any of the close braces before that i.e in the range [0,i-1]\\n        #   3. similarly for open brace, left over at index i, you can remove it or any other open brace after that i.e [i+1, end]\\n        #   4. if left over braces are more than 1 say 2 close braces here, you need to make combinations of all 2 braces before that index and find valid parentheses.\\n        #   5. so, we count left and right invalid braces and do backtracking removing them\\n        \\n\\t\\t## TIME COMPLEXITY : O(2^N) ## (each brace has 2 options: exits or to be removed)\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        def isValid(s):\\n            stack = []\\n            for i in range(len(s)):\\n                if( s[i] == \\'(\\' ):\\n                    stack.append( (i,\\'(\\') )\\n                elif( s[i] == \\')\\' ):\\n                    if(stack and stack[-1][1] == \\'(\\'):\\n                        stack.pop()\\n                    else:\\n                        stack.append( (i,\\')\\') )         # pushing invalid close braces also\\n            return len(stack) == 0, stack\\n        \\n        \\n        def dfs( s, left, right):\\n            visited.add(s)\\n            if left == 0 and right == 0 and isValid(s)[0]:  res.append(s)\\n            for i, ch in enumerate(s):\\n                if ch != \\'(\\' and ch != \\')\\': continue                                    # if it is any other char ignore.\\n                if (ch == \\'(\\' and left == 0) or (ch == \\')\\' and right == 0): continue    # if left == 0 then removing \\'(\\' will only cause imbalance. Hence, skip.\\n                if s[:i] + s[i+1:] not in visited:\\n                    dfs( s[:i] + s[i+1:], left - (ch == \\'(\\'), right - (ch == \\')\\') )\\n        \\n        stack = isValid(s)[1]\\n        lc = sum([1 for val in stack if val[1] == \"(\"]) # num of left braces\\n        rc = len(stack) - lc\\n        \\n        res, visited = [], set()\\n        dfs(s, lc, rc)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75079,
                "title": "python-dp-solution",
                "content": "We can perceive the task as minimization the number of  removed parenthesis  and represent the solution as recursive with parameters si - 'Start Index' and oc - 'Open Count'. \\n\\nDropCount = min(DropCount[si + 1][oc], DropCount[si + 1][oc + {1 if s[si] == '(' else -1}]\\n\\n    def minDrop(s, si, oc, cache, pseq):\\n        N = len(s)\\n    \\n        if oc < 0:\\n            return N - si + 1\\n    \\n        if si == N :\\n            if oc == 0:\\n                pseq[si][oc] = {''}\\n            return oc\\n    \\n        if cache[si][oc] != -1:\\n            return cache[si][oc]\\n    \\n        \\n        if s[si] in '()':\\n            dc0 = 1 + minDrop(s, si + 1, oc, cache, pseq)\\n            pseq0 = pseq[si + 1][oc]\\n    \\n            if s[si] == '(':\\n                dc1 = minDrop(s, si + 1, oc + 1, cache, pseq)\\n                pseq1 = ['(' + x for x in pseq[si + 1][oc + 1]]\\n            else:\\n                dc1 = minDrop(s, si + 1, oc - 1, cache, pseq)\\n                pseq1 = [')' + x for x in pseq[si + 1][oc - 1]]\\n    \\n            cache[si][oc] = min(dc0, dc1)\\n    \\n            # note '=' - in case of eqaulity we keep both combination sets\\n            if dc0 >= dc1 :\\n                pseq[si][oc] = pseq[si][oc].union(pseq1)\\n    \\n            if dc0 <= dc1 :\\n                pseq[si][oc] = pseq[si][oc].union(pseq0) \\n    \\n        else:\\n            cache[si][oc] = minDrop(s, si + 1, oc, cache, pseq)\\n            pseq[si][oc] = [s[si] + x for x in pseq[si + 1][oc]]\\n    \\n        return cache[si][oc]\\n    \\n    class Solution(object):\\n        def removeInvalidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            N = len(s)\\n            cache = [[-1 for x in range(N)] for x in range(N)]\\n            pseq = [[set() for x in range(N + 1)] for x in range(N + 1)]\\n    \\n            c = minDrop(s, 0, 0, cache, pseq)\\n    \\n            return list(pseq[0][0])",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "We can perceive the task as minimization the number of  removed parenthesis  and represent the solution as recursive with parameters si - 'Start Index' and oc - 'Open Count'. \\n\\nDropCount = min(DropCount[si + 1][oc], DropCount[si + 1][oc + {1 if s[si] == '(' else -1}]\\n\\n    def minDrop(s, si, oc, cache, pseq):\\n        N = len(s)\\n    \\n        if oc < 0:\\n            return N - si + 1\\n    \\n        if si == N :\\n            if oc == 0:\\n                pseq[si][oc] = {''}\\n            return oc\\n    \\n        if cache[si][oc] != -1:\\n            return cache[si][oc]\\n    \\n        \\n        if s[si] in '()':\\n            dc0 = 1 + minDrop(s, si + 1, oc, cache, pseq)\\n            pseq0 = pseq[si + 1][oc]\\n    \\n            if s[si] == '(':\\n                dc1 = minDrop(s, si + 1, oc + 1, cache, pseq)\\n                pseq1 = ['(' + x for x in pseq[si + 1][oc + 1]]\\n            else:\\n                dc1 = minDrop(s, si + 1, oc - 1, cache, pseq)\\n                pseq1 = [')' + x for x in pseq[si + 1][oc - 1]]\\n    \\n            cache[si][oc] = min(dc0, dc1)\\n    \\n            # note '=' - in case of eqaulity we keep both combination sets\\n            if dc0 >= dc1 :\\n                pseq[si][oc] = pseq[si][oc].union(pseq1)\\n    \\n            if dc0 <= dc1 :\\n                pseq[si][oc] = pseq[si][oc].union(pseq0) \\n    \\n        else:\\n            cache[si][oc] = minDrop(s, si + 1, oc, cache, pseq)\\n            pseq[si][oc] = [s[si] + x for x in pseq[si + 1][oc]]\\n    \\n        return cache[si][oc]\\n    \\n    class Solution(object):\\n        def removeInvalidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: List[str]\\n            \"\"\"\\n            N = len(s)\\n            cache = [[-1 for x in range(N)] for x in range(N)]\\n            pseq = [[set() for x in range(N + 1)] for x in range(N + 1)]\\n    \\n            c = minDrop(s, 0, 0, cache, pseq)\\n    \\n            return list(pseq[0][0])",
                "codeTag": "Java"
            },
            {
                "id": 1620475,
                "title": "java-optimized-backtracking-solution-easy-read-stack",
                "content": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans=new ArrayList<>();\\n        HashSet<String> set=new HashSet<String>();\\n        \\n        int minBracket=removeBracket(s);\\n        getAns(s, minBracket,set,ans);\\n        \\n        return ans;\\n    }\\n    \\n    public void getAns(String s, int minBracket, HashSet<String> set, List<String> ans){\\n        if(set.contains(s)) return;\\n        \\n        set.add(s);\\n        \\n        if(minBracket==0){\\n            int remove=removeBracket(s);   \\n            if(remove==0) ans.add(s);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\'(\\' && s.charAt(i)!=\\')\\') continue;\\n            String L=s.substring(0,i);\\n            String R=s.substring(i+1);\\n            \\n            if(!set.contains(L+R)) getAns(L+R,minBracket-1,set,ans);\\n        }\\n    }\\n    \\n    public int removeBracket(String s){\\n        Stack<Character> stack=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char x=s.charAt(i);\\n            \\n            if(x==\\'(\\') stack.push(x);\\n            else if(x==\\')\\'){\\n                if(!stack.isEmpty() && stack.peek()==\\'(\\') stack.pop();\\n                else stack.push(x);\\n            } \\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans=new ArrayList<>();\\n        HashSet<String> set=new HashSet<String>();\\n        \\n        int minBracket=removeBracket(s);\\n        getAns(s, minBracket,set,ans);\\n        \\n        return ans;\\n    }\\n    \\n    public void getAns(String s, int minBracket, HashSet<String> set, List<String> ans){\\n        if(set.contains(s)) return;\\n        \\n        set.add(s);\\n        \\n        if(minBracket==0){\\n            int remove=removeBracket(s);   \\n            if(remove==0) ans.add(s);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\'(\\' && s.charAt(i)!=\\')\\') continue;\\n            String L=s.substring(0,i);\\n            String R=s.substring(i+1);\\n            \\n            if(!set.contains(L+R)) getAns(L+R,minBracket-1,set,ans);\\n        }\\n    }\\n    \\n    public int removeBracket(String s){\\n        Stack<Character> stack=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char x=s.charAt(i);\\n            \\n            if(x==\\'(\\') stack.push(x);\\n            else if(x==\\')\\'){\\n                if(!stack.isEmpty() && stack.peek()==\\'(\\') stack.pop();\\n                else stack.push(x);\\n            } \\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472074,
                "title": "c-using-stack-and-dfs",
                "content": "**Please Upvote if you like the solution and comment down below for any query!**\\n\\n    class Solution {\\n    public:\\n    vector<string> ans;\\n    unordered_map<string,int> map;//Just to prevent by taking duplicate string in ans\\n    void solve(string s,int minimum_removal_allowed)\\n    {\\n        if(map[s]!=0)//for checking that string is already exist in map or not\\n            return;\\n        else\\n            map[s]++;//when current string is not present than insert that on map\\n        \\n        if(minimum_removal_allowed==0)//when minimum removal removal that is required in given string is 0\\n        {\\n            int minimum_removal_now=getminimuminvalid(s);//here we are checking that the current string even after removal of required number of brackets is valid or not\\n            if(minimum_removal_now==0)//it means that the string after removal is valid, then insert that in ans\\n            {   \\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string left=s.substr(0,i);//taken as it runs till (i-1) and we are skipping ith bracket\\n            string right=s.substr(i+1);//from i+1 to end or s.size()\\n            \\n            solve(left+right,minimum_removal_allowed-1);//calling again by combining left and right\\n        }\\n        return;\\n    }\\n    int getminimuminvalid(string s)\\n    {\\n        stack<char>stack;\\n        int i=0;\\n        \\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'(\\')//when \"(\" simply insert that on stack\\n                stack.push(\\'(\\');\\n            else if(s[i]==\\')\\')//2 cases when bracket is \")\"\\n            {\\n                if(stack.empty()==false && stack.top()==\\'(\\')//if top of stack is \"(\" then pop\\n                {\\n                    stack.pop();\\n                }\\n                else\\n                     stack.push(\\')\\');//otherwise push on stack\\n            }\\n            i++;\\n        }\\n        return stack.size();\\n    }\\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        int minimum_removals=getminimuminvalid(s);\\n        \\n        solve(s,minimum_removals);\\n        return ans;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n    vector<string> ans;\\n    unordered_map<string,int> map;//Just to prevent by taking duplicate string in ans\\n    void solve(string s,int minimum_removal_allowed)\\n    {\\n        if(map[s]!=0)//for checking that string is already exist in map or not\\n            return;\\n        else\\n            map[s]++;//when current string is not present than insert that on map\\n        \\n        if(minimum_removal_allowed==0)//when minimum removal removal that is required in given string is 0\\n        {\\n            int minimum_removal_now=getminimuminvalid(s);//here we are checking that the current string even after removal of required number of brackets is valid or not\\n            if(minimum_removal_now==0)//it means that the string after removal is valid, then insert that in ans\\n            {   \\n                ans.push_back(s);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 520944,
                "title": "c-simple-bfs-solution-20-ms",
                "content": "Not the fastest of all solutions, but very easy to comprehend. (20 ms is not bad for BFS).\\nNote: searching/removing only one of the parenthesis (as returned by ```isValid```) makes this more the 3x faster, compared to searching for both.\\n```\\nclass Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) \\n        {\\n            vector<string> res;\\n            unordered_set<string> visited;\\n            queue<string> q;\\n            q.push(s);\\n            visited.insert(s);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i = 0; i < size; ++i)\\n                {\\n                    string str = q.front(); q.pop();\\n                    char ch_remove = isValid(str);\\n                    if(ch_remove == 1) res.push_back(str);\\n\\n                    if(res.size()) continue; // all our results are on this level - no need to populate queue\\n\\n                    for(int j = 0; j < str.length(); ++j)\\n                    {\\n                        if(str[j] == ch_remove)\\n                        {\\n                            string snew = str.substr(0, j) + str.substr(j+1);\\n                            if(!visited.count(snew)) \\n                            {\\n                                q.push(snew);\\n                                visited.insert(snew);\\n                            }\\n                        }\\n                    }\\n                }\\n                if(res.size()) break;\\n            }\\n            return res;\\n        }\\n\\n    protected:\\n        // returns 1 if valid; char to be removed otherwise\\n        char isValid(string& s)\\n        {\\n            int count = 0;\\n            for(char c : s)\\n            {\\n                if(c == \\'(\\') ++count;\\n                else if(c == \\')\\') \\n                    if(count > 0) --count;\\n                    else return \\')\\';\\n            }\\n            return count == 0 ? 1 : \\'(\\';\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```isValid```\n```\\nclass Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) \\n        {\\n            vector<string> res;\\n            unordered_set<string> visited;\\n            queue<string> q;\\n            q.push(s);\\n            visited.insert(s);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i = 0; i < size; ++i)\\n                {\\n                    string str = q.front(); q.pop();\\n                    char ch_remove = isValid(str);\\n                    if(ch_remove == 1) res.push_back(str);\\n\\n                    if(res.size()) continue; // all our results are on this level - no need to populate queue\\n\\n                    for(int j = 0; j < str.length(); ++j)\\n                    {\\n                        if(str[j] == ch_remove)\\n                        {\\n                            string snew = str.substr(0, j) + str.substr(j+1);\\n                            if(!visited.count(snew)) \\n                            {\\n                                q.push(snew);\\n                                visited.insert(snew);\\n                            }\\n                        }\\n                    }\\n                }\\n                if(res.size()) break;\\n            }\\n            return res;\\n        }\\n\\n    protected:\\n        // returns 1 if valid; char to be removed otherwise\\n        char isValid(string& s)\\n        {\\n            int count = 0;\\n            for(char c : s)\\n            {\\n                if(c == \\'(\\') ++count;\\n                else if(c == \\')\\') \\n                    if(count > 0) --count;\\n                    else return \\')\\';\\n            }\\n            return count == 0 ? 1 : \\'(\\';\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273674,
                "title": "swift-bfs-solution",
                "content": "Since we just need to find **\"minimum\"** number of invalid parentheses, we do BFS for the string (use string length to represent the level here). When the level becomes smaller than length of our previous results, we can stop.\\n\\nTo prevent a large amount of duplicate searching, we need to skip those we have visited to prevent them from going deeper.\\n\\n```swift\\nclass Solution {\\n    func removeInvalidParentheses(_ s: String) -> [String] {\\n        var result = Set<String>()\\n        var queue = [s], visited = Set<String>()\\n        while queue.count > 0 {\\n            let curr = queue.removeFirst()\\n            if let first = result.first, first.count > curr.count {\\n                break\\n            }\\n                        \\n            if isValid(curr) {\\n                result.insert(curr)\\n\\n            } else {\\n                let toRemove = charToRemove(curr)\\n                for i in curr.indices where curr[i] == toRemove {\\n                    let next = String(curr[curr.startIndex..<i] + curr[curr.index(after: i)...])\\n                    if !visited.contains(next) {\\n                        queue.append(next)\\n                        visited.insert(next)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return Array(result)\\n    }\\n\\n\\n    func isValid(_ s: String) -> Bool {\\n        var l = 0\\n        for char in s {\\n            if char == \"(\" {\\n                l += 1\\n            } else if char == \")\" {\\n                l -= 1\\n            }\\n            if l < 0 {\\n                return false\\n            }\\n        }\\n        return l == 0\\n    }\\n    \\n    func charToRemove(_ s: String) -> Character {\\n        var l = 0, r = 0\\n        for char in s {\\n            if char == \"(\" {\\n                l += 1\\n            } else if char == \")\" {\\n                r += 1\\n            }\\n        }\\n        return l > r ? \"(\" : \")\"\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func removeInvalidParentheses(_ s: String) -> [String] {\\n        var result = Set<String>()\\n        var queue = [s], visited = Set<String>()\\n        while queue.count > 0 {\\n            let curr = queue.removeFirst()\\n            if let first = result.first, first.count > curr.count {\\n                break\\n            }\\n                        \\n            if isValid(curr) {\\n                result.insert(curr)\\n\\n            } else {\\n                let toRemove = charToRemove(curr)\\n                for i in curr.indices where curr[i] == toRemove {\\n                    let next = String(curr[curr.startIndex..<i] + curr[curr.index(after: i)...])\\n                    if !visited.contains(next) {\\n                        queue.append(next)\\n                        visited.insert(next)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return Array(result)\\n    }\\n\\n\\n    func isValid(_ s: String) -> Bool {\\n        var l = 0\\n        for char in s {\\n            if char == \"(\" {\\n                l += 1\\n            } else if char == \")\" {\\n                l -= 1\\n            }\\n            if l < 0 {\\n                return false\\n            }\\n        }\\n        return l == 0\\n    }\\n    \\n    func charToRemove(_ s: String) -> Character {\\n        var l = 0, r = 0\\n        for char in s {\\n            if char == \"(\" {\\n                l += 1\\n            } else if char == \")\" {\\n                r += 1\\n            }\\n        }\\n        return l > r ? \"(\" : \")\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173070,
                "title": "12-lines-c-with-dfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    map<int, unordered_set<string> > ans;\\n    void dfs(const string &s, int cur, int leftCount, int rightCount, string path) {\\n        if (rightCount > leftCount) return;\\n        if (cur == s.length()) {\\n            if (leftCount == rightCount) ans[path.length()].insert(path);\\n            return;\\n        }\\n        if (s[cur] != \\'(\\' && s[cur] != \\')\\') { path += s[cur]; }\\n        dfs(s, cur+1, leftCount, rightCount, path);\\n        if (s[cur] == \\'(\\') { dfs(s, cur+1, leftCount+1, rightCount, path+\\'(\\'); }\\n        if (s[cur] == \\')\\') { dfs(s, cur+1, leftCount, rightCount+1, path+\\')\\'); }\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        dfs(s, 0, 0, 0, \"\");\\n        return vector<string>(ans.rbegin()->second.begin(), ans.rbegin()->second.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    map<int, unordered_set<string> > ans;\\n    void dfs(const string &s, int cur, int leftCount, int rightCount, string path) {\\n        if (rightCount > leftCount) return;\\n        if (cur == s.length()) {\\n            if (leftCount == rightCount) ans[path.length()].insert(path);\\n            return;\\n        }\\n        if (s[cur] != \\'(\\' && s[cur] != \\')\\') { path += s[cur]; }\\n        dfs(s, cur+1, leftCount, rightCount, path);\\n        if (s[cur] == \\'(\\') { dfs(s, cur+1, leftCount+1, rightCount, path+\\'(\\'); }\\n        if (s[cur] == \\')\\') { dfs(s, cur+1, leftCount, rightCount+1, path+\\')\\'); }\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        dfs(s, 0, 0, 0, \"\");\\n        return vector<string>(ans.rbegin()->second.begin(), ans.rbegin()->second.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327481,
                "title": "python-dfs-solution-with-pruning-28-ms-beat-99-56-bfs-solution",
                "content": "DFS solution with pruning:\\n\\n1. Find the numbers of total \\'(\\', \\')\\', and the numbers of \\'(\\', \\')\\' that are needed to delete in order to get longest valid strings.\\n2. Use DFS to delete some parentheses that are needed to delete.  Prune the recursion tree when deletion is a must to improve the efficiency.\\n\\nTime complexity: O(n * C(left_p, left_del) * C(right_p, right_del)), where C(n,k) is n choose k.\\n```\\nclass Solution:\\n    def find_delete(self, s):\\n        x = 0\\n        left_p, right_p = 0, 0\\n        left_del, right_del = 0, 0\\n        for c in s:\\n            if c == \\'(\\':\\n                x += 1\\n                left_p += 1\\n            elif c == \\')\\':\\n                right_p += 1\\n                if x > 0:\\n                    x -= 1\\n                else:\\n                    right_del += 1\\n        left_del = x\\n        return (left_p, right_p, left_del, right_del)\\n        \\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def dfs(i, x, curr_s, l_p, r_p, l_del, r_del):\\n            # i: the index such that s[i] will be considered at this step\\n            # x = # left brakets - # right brakets in curr_s\\n            # l_p, r_p: left/right brakets remaining in s[i:]\\n            # l_del, r_del: left/right brakets needed to delete in s[i:]\\n            if i == len(s):\\n                if l_del == 0 and r_del == 0:\\n                    res.add(curr_s)\\n                return\\n            if s[i] == \\'(\\':\\n                if l_p == l_del: # must delete it\\n                    dfs(i + 1, x, curr_s, l_p - 1, r_p, l_del - 1, r_del)\\n                else:\\n                    # allowed to keep it\\n                    dfs(i + 1, x + 1, curr_s + \\'(\\', l_p - 1, r_p, l_del, r_del)\\n                    if l_del > 0: # allowed to delete it\\n                         dfs(i + 1, x, curr_s, l_p - 1, r_p, l_del - 1, r_del)\\n            elif s[i] == \\')\\':\\n                if r_p == r_del: # must delete it\\n                    dfs(i + 1, x, curr_s, l_p, r_p - 1, l_del, r_del - 1)\\n                else:\\n                    if x > 0: # allowed to keep it\\n                        dfs(i + 1, x - 1, curr_s + \\')\\', l_p, r_p - 1, l_del, r_del)\\n                    if r_del > 0: # allowed to delete it\\n                        dfs(i + 1, x, curr_s, l_p, r_p - 1, l_del, r_del - 1)\\n            else:\\n                dfs(i + 1, x, curr_s + s[i], l_p, r_p, l_del, r_del)\\n        \\n        l_p, r_p, l_del, r_del = self.find_delete(s)\\n        res = set()\\n        dfs(0, 0, \\'\\', l_p, r_p, l_del, r_del)\\n        return list(res)\\n```\\n\\nBFS solution: time complexity: O(n * 2 ^ m), where n = len(s), and m = # parenthesis in s.\\n\\nLevel-by-level BFS visit can be used to solve a lot of problems of finding discrete shortest distance.\\nPlease see and vote for my solutions for these similar problems\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1651394/Python-level-by-level-BFS-Solution)\\n[127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/352659/Simple-Python-BFS-solution)\\n[126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/discuss/352661/Simple-Python-BFS-solution)\\n[301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/discuss/327481/Python-DFS-solution-with-pruning-(28-ms-beat-99.56)-%2B-BFS-solution)\\n[317. Shortest Distance from All Buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/331983/Python-BFS-solution-(52-ms-beat-98.27))\\n[529. Minesweeper](https://leetcode.com/problems/minesweeper/discuss/1651414/python-level-by-level-bfs-solution)\\n[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/discuss/412586/Standard-Python-BFS-solution-(level-by-level-traversal))\\n[815. Bus Routes](https://leetcode.com/problems/bus-routes/discuss/1651399/Python-Level-by-level-BFS-solution)\\n[854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/discuss/420506/Python-BFS-solution)\\n[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/364604/Simple-Python-BFS-Solution-(292-ms-beat-97.78))\\n[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313229/Python-BFS-solution)\\n[1210. Minimum Moves to Reach Target with Rotations](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/392940/Standard-Python-BFS-solution)\\n[1263. Minimum Moves to Move a Box to Their Target Location](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution)\\n[1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/1651383/Python-level-by-level-BFS-Solution)\\n\\n```\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def check_valid(candidate):\\n            bal = 0\\n            for char in candidate:\\n                if char == \"(\": bal += 1\\n                elif char == \")\": bal -= 1\\n                if bal < 0: return False\\n            return bal == 0\\n        \\n        res = set()\\n        queue = deque([s])\\n        visited = {s}\\n        # BFS to delete parethesis level-by-level\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size): # visit all strings at this level\\n                candidate = queue.popleft()\\n                if check_valid(candidate): \\n                    res.add(candidate)\\n                    continue\\n                for i, char in enumerate(candidate):\\n                    if char in \"()\":\\n                        new_candidate = candidate[:i]+candidate[i+1:]  \\n                        # append strings to the next level\\n                        if new_candidate not in visited:\\n                            queue.append(new_candidate)\\n                            visited.add(new_candidate)\\n            if len(res) != 0:\\n                return list(res)\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find_delete(self, s):\\n        x = 0\\n        left_p, right_p = 0, 0\\n        left_del, right_del = 0, 0\\n        for c in s:\\n            if c == \\'(\\':\\n                x += 1\\n                left_p += 1\\n            elif c == \\')\\':\\n                right_p += 1\\n                if x > 0:\\n                    x -= 1\\n                else:\\n                    right_del += 1\\n        left_del = x\\n        return (left_p, right_p, left_del, right_del)\\n        \\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def dfs(i, x, curr_s, l_p, r_p, l_del, r_del):\\n            # i: the index such that s[i] will be considered at this step\\n            # x = # left brakets - # right brakets in curr_s\\n            # l_p, r_p: left/right brakets remaining in s[i:]\\n            # l_del, r_del: left/right brakets needed to delete in s[i:]\\n            if i == len(s):\\n                if l_del == 0 and r_del == 0:\\n                    res.add(curr_s)\\n                return\\n            if s[i] == \\'(\\':\\n                if l_p == l_del: # must delete it\\n                    dfs(i + 1, x, curr_s, l_p - 1, r_p, l_del - 1, r_del)\\n                else:\\n                    # allowed to keep it\\n                    dfs(i + 1, x + 1, curr_s + \\'(\\', l_p - 1, r_p, l_del, r_del)\\n                    if l_del > 0: # allowed to delete it\\n                         dfs(i + 1, x, curr_s, l_p - 1, r_p, l_del - 1, r_del)\\n            elif s[i] == \\')\\':\\n                if r_p == r_del: # must delete it\\n                    dfs(i + 1, x, curr_s, l_p, r_p - 1, l_del, r_del - 1)\\n                else:\\n                    if x > 0: # allowed to keep it\\n                        dfs(i + 1, x - 1, curr_s + \\')\\', l_p, r_p - 1, l_del, r_del)\\n                    if r_del > 0: # allowed to delete it\\n                        dfs(i + 1, x, curr_s, l_p, r_p - 1, l_del, r_del - 1)\\n            else:\\n                dfs(i + 1, x, curr_s + s[i], l_p, r_p, l_del, r_del)\\n        \\n        l_p, r_p, l_del, r_del = self.find_delete(s)\\n        res = set()\\n        dfs(0, 0, \\'\\', l_p, r_p, l_del, r_del)\\n        return list(res)\\n```\n```\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def check_valid(candidate):\\n            bal = 0\\n            for char in candidate:\\n                if char == \"(\": bal += 1\\n                elif char == \")\": bal -= 1\\n                if bal < 0: return False\\n            return bal == 0\\n        \\n        res = set()\\n        queue = deque([s])\\n        visited = {s}\\n        # BFS to delete parethesis level-by-level\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size): # visit all strings at this level\\n                candidate = queue.popleft()\\n                if check_valid(candidate): \\n                    res.add(candidate)\\n                    continue\\n                for i, char in enumerate(candidate):\\n                    if char in \"()\":\\n                        new_candidate = candidate[:i]+candidate[i+1:]  \\n                        # append strings to the next level\\n                        if new_candidate not in visited:\\n                            queue.append(new_candidate)\\n                            visited.add(new_candidate)\\n            if len(res) != 0:\\n                return list(res)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459218,
                "title": "python-solution-using-smart-backtracking-with-a-simple-trick-beats-82-in-time-and-100-in-space",
                "content": "This solution uses backtracking but in order to prevent repeatitive calls of the backtracking function, I first calculate how many left and right parenthesis needs to be removed. If a right parenthesis doesn\\'t have a matching left one, it needs to be removed, also if there are more left parenthesis compared to the right ones, the extra left prenthesis needs to be removed.\\nAfter calculating number of lefts and rights that needs to be removed, inside the backtracking function, I remove the left or right parenthesis, only if I am not exceeding the number of the parentheis that should be removed.\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ans = []\\n        lefts_to_remove, rights_to_remove = 0, 0\\n        lefts, rights = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                lefts += 1\\n            elif s[i] == \\')\\':\\n                if lefts > 0:\\n                    lefts -= 1\\n                else:\\n                    rights_to_remove += 1 #if right doesn\\'t have a matching left, it should be removed\\n        lefts_to_remove = lefts #if we have more lefts than rights, extra lefts should be removed\\n        \\n        self.backtracking(0, 0, s, 0, \\'\\', ans, lefts_to_remove, rights_to_remove)\\n        if not ans:\\n            ans.append(\\'\\')\\n        \\n        return ans\\n                    \\n    \\n    def backtracking(self, lefts, rights, s, ind, cur_str, ans, lefts_to_remove, rights_to_remove):\\n        if ind == len(s):\\n            if lefts == rights and lefts_to_remove==0 and rights_to_remove==0 and cur_str not in ans:\\n                ans.append(cur_str)\\n            return\\n        \\n        if s[ind] == \\'(\\':\\n            if lefts_to_remove > 0:\\n                self.backtracking(lefts, rights, s, ind+1, cur_str, ans, lefts_to_remove-1, rights_to_remove)\\n            self.backtracking(lefts+1, rights, s, ind+1, cur_str+\\'(\\', ans, lefts_to_remove, rights_to_remove)\\n            \\n        elif s[ind] == \\')\\':\\n            if (lefts==0 or lefts>=rights) and rights_to_remove > 0:\\n                self.backtracking(lefts, rights, s, ind+1, cur_str, ans, lefts_to_remove, rights_to_remove-1)\\n            if lefts > rights:\\n                self.backtracking(lefts, rights+1, s, ind+1, cur_str+\\')\\', ans, lefts_to_remove, rights_to_remove)\\n            \\n        else:\\n            self.backtracking(lefts, rights, s, ind+1, cur_str+s[ind], ans, lefts_to_remove, rights_to_remove)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "This solution uses backtracking but in order to prevent repeatitive calls of the backtracking function, I first calculate how many left and right parenthesis needs to be removed. If a right parenthesis doesn\\'t have a matching left one, it needs to be removed, also if there are more left parenthesis compared to the right ones, the extra left prenthesis needs to be removed.\\nAfter calculating number of lefts and rights that needs to be removed, inside the backtracking function, I remove the left or right parenthesis, only if I am not exceeding the number of the parentheis that should be removed.\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ans = []\\n        lefts_to_remove, rights_to_remove = 0, 0\\n        lefts, rights = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                lefts += 1\\n            elif s[i] == \\')\\':\\n                if lefts > 0:\\n                    lefts -= 1\\n                else:\\n                    rights_to_remove += 1 #if right doesn\\'t have a matching left, it should be removed\\n        lefts_to_remove = lefts #if we have more lefts than rights, extra lefts should be removed\\n        \\n        self.backtracking(0, 0, s, 0, \\'\\', ans, lefts_to_remove, rights_to_remove)\\n        if not ans:\\n            ans.append(\\'\\')\\n        \\n        return ans\\n                    \\n    \\n    def backtracking(self, lefts, rights, s, ind, cur_str, ans, lefts_to_remove, rights_to_remove):\\n        if ind == len(s):\\n            if lefts == rights and lefts_to_remove==0 and rights_to_remove==0 and cur_str not in ans:\\n                ans.append(cur_str)\\n            return\\n        \\n        if s[ind] == \\'(\\':\\n            if lefts_to_remove > 0:\\n                self.backtracking(lefts, rights, s, ind+1, cur_str, ans, lefts_to_remove-1, rights_to_remove)\\n            self.backtracking(lefts+1, rights, s, ind+1, cur_str+\\'(\\', ans, lefts_to_remove, rights_to_remove)\\n            \\n        elif s[ind] == \\')\\':\\n            if (lefts==0 or lefts>=rights) and rights_to_remove > 0:\\n                self.backtracking(lefts, rights, s, ind+1, cur_str, ans, lefts_to_remove, rights_to_remove-1)\\n            if lefts > rights:\\n                self.backtracking(lefts, rights+1, s, ind+1, cur_str+\\')\\', ans, lefts_to_remove, rights_to_remove)\\n            \\n        else:\\n            self.backtracking(lefts, rights, s, ind+1, cur_str+s[ind], ans, lefts_to_remove, rights_to_remove)",
                "codeTag": "Java"
            },
            {
                "id": 304220,
                "title": "python-60ms-clean-and-commented",
                "content": "My cleaner take of the Editorial Solution 2.\\n```python\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        # First, find how many misplaced parens\\n        left, right = 0, 0\\n        for ch in s:\\n            if ch == \\'(\\':\\n                left += 1\\n            elif ch == \\')\\':\\n                if left > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n            \\n        res = {}\\n        def recurse(s, i, left, right, curr, leftExtra):\\n            # Prune\\n            if \\'\\'.join(curr) in res:\\n                return\\n            if left+right > len(s)-i:\\n                return\\n            \\n            # Done, add valid string to res\\n            if i == len(s):\\n                if left == 0 and right == 0:\\n                    res[\\'\\'.join(curr)] = True\\n                return\\n            \\n            # Discard case\\n            if (s[i] == \\'(\\' and left > 0):\\n                recurse(s, i+1, left-1, right, curr, leftExtra)\\n            elif (s[i] == \\')\\' and right > 0):\\n                recurse(s, i+1, left, right-1, curr, leftExtra)\\n            \\n            # Keep case\\n            curr.append(s[i])\\n            if s[i] != \\'(\\' and s[i] != \\')\\':\\n                recurse(s, i+1, left, right, curr, leftExtra)\\n            # Keep parentheses only if balance maintained\\n            elif s[i] == \\'(\\':\\n                recurse(s, i+1, left, right, curr, leftExtra+1)\\n            elif s[i] == \\')\\' and leftExtra > 0:\\n                recurse(s, i+1, left, right, curr, leftExtra-1)\\n            \\n            # Backtrack\\n            curr.pop()\\n                    \\n        recurse(s, 0, left, right, [], 0)\\n        return list(r for r in res if res[r])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        # First, find how many misplaced parens\\n        left, right = 0, 0\\n        for ch in s:\\n            if ch == \\'(\\':\\n                left += 1\\n            elif ch == \\')\\':\\n                if left > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n            \\n        res = {}\\n        def recurse(s, i, left, right, curr, leftExtra):\\n            # Prune\\n            if \\'\\'.join(curr) in res:\\n                return\\n            if left+right > len(s)-i:\\n                return\\n            \\n            # Done, add valid string to res\\n            if i == len(s):\\n                if left == 0 and right == 0:\\n                    res[\\'\\'.join(curr)] = True\\n                return\\n            \\n            # Discard case\\n            if (s[i] == \\'(\\' and left > 0):\\n                recurse(s, i+1, left-1, right, curr, leftExtra)\\n            elif (s[i] == \\')\\' and right > 0):\\n                recurse(s, i+1, left, right-1, curr, leftExtra)\\n            \\n            # Keep case\\n            curr.append(s[i])\\n            if s[i] != \\'(\\' and s[i] != \\')\\':\\n                recurse(s, i+1, left, right, curr, leftExtra)\\n            # Keep parentheses only if balance maintained\\n            elif s[i] == \\'(\\':\\n                recurse(s, i+1, left, right, curr, leftExtra+1)\\n            elif s[i] == \\')\\' and leftExtra > 0:\\n                recurse(s, i+1, left, right, curr, leftExtra-1)\\n            \\n            # Backtrack\\n            curr.pop()\\n                    \\n        recurse(s, 0, left, right, [], 0)\\n        return list(r for r in res if res[r])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154272,
                "title": "javascript-bfs-solution",
                "content": "```js\\nfunction removeInvalidParentheses(s) {\\n  let queue = new Set([s]);\\n  while (queue.size) {\\n    const next = new Set();\\n    for (let v of queue) {\\n      if (isValid(v)) {\\n        return [...queue].filter(isValid);\\n      }\\n      \\n      for (let i = 0; i < v.length; i++) {\\n        next.add(v.slice(0, i) + v.slice(i+1));\\n      }\\n    }\\n    queue = next;\\n  }\\n  return [\\'\\'];\\n}\\n\\nfunction isValid(str) {\\n  let bal = 0;\\n  for (let ch of str) {\\n    if (ch === \\'(\\') {\\n      bal++;\\n    } else if (ch === \\')\\') {\\n      bal--;\\n    }\\n    if (bal < 0) {\\n      return false;\\n    }\\n  }\\n  return bal === 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction removeInvalidParentheses(s) {\\n  let queue = new Set([s]);\\n  while (queue.size) {\\n    const next = new Set();\\n    for (let v of queue) {\\n      if (isValid(v)) {\\n        return [...queue].filter(isValid);\\n      }\\n      \\n      for (let i = 0; i < v.length; i++) {\\n        next.add(v.slice(0, i) + v.slice(i+1));\\n      }\\n    }\\n    queue = next;\\n  }\\n  return [\\'\\'];\\n}\\n\\nfunction isValid(str) {\\n  let bal = 0;\\n  for (let ch of str) {\\n    if (ch === \\'(\\') {\\n      bal++;\\n    } else if (ch === \\')\\') {\\n      bal--;\\n    }\\n    if (bal < 0) {\\n      return false;\\n    }\\n  }\\n  return bal === 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75059,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Remove Invalid Parentheses** https://leetcode.com/problems/remove-invalid-parentheses/\\n\\n**Breadth First Search**\\n* is_valid - Tests if the brackets are balanced or not. Keep a counter. Increment it when you have \"(\" and decrement it when you see \")\". If counter is ever negative, then return False\\n* Keep a queue and hash-set. Now add s to queue.\\n* Now run a standard BFS. \\n* Dequeue one by one at a level and test if it is valid. \\n* If yes, add to result. Otherwise remove each element and add to queue.\\n* Why do we use a hash-set? Assume we have \"())\" -> you can remove 1st or 2nd and it will yield (), ().\\n* This can be duplication and cause issues later\\n* Complexity will be n* (2^n)\\n*  https://discuss.leetcode.com/topic/28827/share-my-java-bfs-solution\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def is_valid(self, s):\\n        count = 0\\n        for ch in s:\\n            if ch == \"(\":\\n                count = count + 1\\n            elif ch == \")\":\\n                count = count - 1\\n            if count < 0:\\n                return False\\n        return count == 0\\n    \\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        q, result = deque(), []\\n        q.append(s)\\n        while len(q) and len(result) == 0:\\n            next_level = set([])\\n            for _ in range(len(q)):\\n                x = q.popleft()\\n                if self.is_valid(x):\\n                    result.append(x)\\n                elif len(result) == 0:\\n                    for i in range(len(x)):\\n                        if x[i] in (\"(\", \")\"):\\n                            next_level.add(x[0:i] + x[i+1:])\\n            for nl in next_level:\\n                q.append(nl)\\n        return result if result else [\"\"]\\n```\\n\\n**Implement BFS using a set.**\\n*  Since a set is used to implement the queue, there is no need for a hash-set to remove duplicates\\n```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def is_valid(s):\\n            count = 0\\n            for ch in s:\\n                if ch == \"(\":\\n                    count = count + 1\\n                elif ch == \")\":\\n                    count = count - 1\\n                if count < 0:\\n                    return False\\n            return count == 0\\n        q = {s}\\n        while q:\\n            result = filter(is_valid, q)\\n            if result:\\n                return result\\n            else:\\n                q = {x[:i] + x[i+1:] for x in q for i in range(len(x))}\\n        return [\"\"]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def is_valid(self, s):\\n        count = 0\\n        for ch in s:\\n            if ch == \"(\":\\n                count = count + 1\\n            elif ch == \")\":\\n                count = count - 1\\n            if count < 0:\\n                return False\\n        return count == 0\\n    \\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        q, result = deque(), []\\n        q.append(s)\\n        while len(q) and len(result) == 0:\\n            next_level = set([])\\n            for _ in range(len(q)):\\n                x = q.popleft()\\n                if self.is_valid(x):\\n                    result.append(x)\\n                elif len(result) == 0:\\n                    for i in range(len(x)):\\n                        if x[i] in (\"(\", \")\"):\\n                            next_level.add(x[0:i] + x[i+1:])\\n            for nl in next_level:\\n                q.append(nl)\\n        return result if result else [\"\"]\\n```\n```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def is_valid(s):\\n            count = 0\\n            for ch in s:\\n                if ch == \"(\":\\n                    count = count + 1\\n                elif ch == \")\":\\n                    count = count - 1\\n                if count < 0:\\n                    return False\\n            return count == 0\\n        q = {s}\\n        while q:\\n            result = filter(is_valid, q)\\n            if result:\\n                return result\\n            else:\\n                q = {x[:i] + x[i+1:] for x in q for i in range(len(x))}\\n        return [\"\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75083,
                "title": "recursive-dfs-solution-accepted-as-best-0ms-in-c-well-explanation",
                "content": "We are going to take three steps to make this problem easy enough to solve and in the end we will have the <font color=\"#00bb00\">best solution</font>:\\n\\nStep 1 -> very intuitive solution\\n---\\nTraverse the string from the very beginning till the end and try each character -> <font color=\"#bb0000\">remove it or not remove it</font>, to determine whether the rest is solvable using DFS.\\n\\n- but there is a definitely problem, it's a brute-force method and in this case it will absolutely tumble into TLE since its time cost is O(n*2^n).\\n\\nStep2 -> using extra variable to reduce the complexity dramatically\\n--\\nWhy should we have to try each character since most of them can be ignored? But how to actually and simply reduce the complexity? \\n\\n- brackets come in pair, so there are quite limited left and right brackets should be removed while all others remain; huh? this will dramatically save us lots of time when the searching depth are constrained to the difference between the amount of left and right brackets -> time cost now is O(n^k) -> k is the difference between the amount of left and right brackets. \\n\\n> Bang! Good choice! Love this!\\n\\nStep3 -> why there should be step3?\\n--\\nOkay, now since the problem might already be solved, but there is also a little more we can do to make it better. While we are searching and trying each path encountering left and right bracket in step 2 we have to check the validity of the string at the end of the search (what is the end of the search? it's when the difference between left and right brackets are zero -> which specifically means the amount of left and right brackets are exactly the same). This checking validity process is quite tedious and time-consuming using a stack maybe, so that's why we need step 3 to remove this tricky little sub-problem.\\n\\n- we are to use another variable pair to record the state between left and right brackets (not remove a left bracket will increase pair while not remove a right will decrease it but -> before not-remove a right bracket we have to first check the pair -> is it decrease-able? -> that's the key we can make sure the final result will be a valid left-right-parentheses string -> needless for further checking -> awesome, isn't it?) when traversing further -> we have to check whether the removing process should be done or not.\\n\\n>At last the complexity is dramatically shrunk -> real O(n^k)\\n\\nOne more thing should also be aware that the result string should be unique in the return sets so when we are collecting the string we have to check whether it's been collected or not -> since we are using C instead of C++ or Java or some other high-level ones whose set objects might easily handle this issue -> since we are C fighters, that's a little stuff we need to do here ^^\\n\\nBang! End of Story!\\n\\n- space complexity O(n^2), since the amount of the sets will be around O(n) -> it's a guess without further accurate calculation;\\n- time complexity O(n^k), after the pruning operations the complexity will be determined by the difference between the amount of left and right brackets.\\n\\n\\n\\n----------\\n\\n    void traverse(char* s, int len, int start, int left, int right, int pair, char* stack, int top, char*** arr, int *returnSize)\\n    {\\n        if(start == len)\\n        {\\n            if(!left && !right && !pair)\\n            {\\n                int size = top+1;\\n                char *t = (char*)malloc(sizeof(char)*(size+1));\\n                for(int i = 0; i < size; i++)\\n                    t[i] = stack[i];\\n                t[size] = '\\\\0';\\n                int i = 0;\\n                while(i < *returnSize) //remove duplicates;\\n                {\\n                    if(!strcmp(t, (*arr)[i]))\\n                        break;\\n                    i++;\\n                }\\n                if(i == *returnSize) //add a bran-new string;\\n                {\\n                    *returnSize += 1;\\n                    *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                    (*arr)[*returnSize-1] = t;\\n                }\\n            }\\n            return ;\\n        }\\n        char c = s[start];\\n        if(c == '(')\\n        {\\n            if(left) //try to remove it;\\n                traverse(s, len, start+1, left-1, right, pair, stack, top, arr, returnSize);\\n            stack[top+1] = c; //try to add it as a pair;\\n            traverse(s, len, start+1, left, right, pair+1, stack, top+1, arr, returnSize);\\n        }\\n        else if(c == ')')\\n        {\\n            if(right) //try to remove it;\\n                traverse(s, len, start+1, left, right-1, pair, stack, top, arr, returnSize);\\n            if(pair) //try to use it as the other half of a pair;\\n            {\\n                stack[top+1] = c;\\n                traverse(s, len, start+1, left, right, pair-1, stack, top+1, arr, returnSize);\\n            }\\n        }\\n        else //just collect since it's not brackets;\\n        {\\n            stack[top+1] = c;\\n            traverse(s, len, start+1, left, right, pair, stack, top+1, arr, returnSize);\\n        }\\n    }\\n    \\n    //AC - 0ms;\\n    char** removeInvalidParentheses(char* s, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int left=0, right=0;\\n        for(int i = 0; s[i]; i++) //find out how many opening and closing brackets should be removed;\\n        {\\n            if(s[i] == '(') left++;\\n            else if(s[i] == ')')\\n            {\\n                if(left) left--;\\n                else right++;\\n            }\\n        }\\n        int len = strlen(s);\\n        char *stack = (char*)malloc(sizeof(char)*len);\\n        int top = -1;\\n        traverse(s, len, 0, left, right, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "We are going to take three steps to make this problem easy enough to solve and in the end we will have the <font color=\"#00bb00\">best solution</font>:\\n\\nStep 1 -> very intuitive solution\\n---\\nTraverse the string from the very beginning till the end and try each character -> <font color=\"#bb0000\">remove it or not remove it</font>, to determine whether the rest is solvable using DFS.\\n\\n- but there is a definitely problem, it's a brute-force method and in this case it will absolutely tumble into TLE since its time cost is O(n*2^n).\\n\\nStep2 -> using extra variable to reduce the complexity dramatically\\n--\\nWhy should we have to try each character since most of them can be ignored? But how to actually and simply reduce the complexity? \\n\\n- brackets come in pair, so there are quite limited left and right brackets should be removed while all others remain; huh? this will dramatically save us lots of time when the searching depth are constrained to the difference between the amount of left and right brackets -> time cost now is O(n^k) -> k is the difference between the amount of left and right brackets. \\n\\n> Bang! Good choice! Love this!\\n\\nStep3 -> why there should be step3?\\n--\\nOkay, now since the problem might already be solved, but there is also a little more we can do to make it better. While we are searching and trying each path encountering left and right bracket in step 2 we have to check the validity of the string at the end of the search (what is the end of the search? it's when the difference between left and right brackets are zero -> which specifically means the amount of left and right brackets are exactly the same). This checking validity process is quite tedious and time-consuming using a stack maybe, so that's why we need step 3 to remove this tricky little sub-problem.\\n\\n- we are to use another variable pair to record the state between left and right brackets (not remove a left bracket will increase pair while not remove a right will decrease it but -> before not-remove a right bracket we have to first check the pair -> is it decrease-able? -> that's the key we can make sure the final result will be a valid left-right-parentheses string -> needless for further checking -> awesome, isn't it?) when traversing further -> we have to check whether the removing process should be done or not.\\n\\n>At last the complexity is dramatically shrunk -> real O(n^k)\\n\\nOne more thing should also be aware that the result string should be unique in the return sets so when we are collecting the string we have to check whether it's been collected or not -> since we are using C instead of C++ or Java or some other high-level ones whose set objects might easily handle this issue -> since we are C fighters, that's a little stuff we need to do here ^^\\n\\nBang! End of Story!\\n\\n- space complexity O(n^2), since the amount of the sets will be around O(n) -> it's a guess without further accurate calculation;\\n- time complexity O(n^k), after the pruning operations the complexity will be determined by the difference between the amount of left and right brackets.\\n\\n\\n\\n----------\\n\\n    void traverse(char* s, int len, int start, int left, int right, int pair, char* stack, int top, char*** arr, int *returnSize)\\n    {\\n        if(start == len)\\n        {\\n            if(!left && !right && !pair)\\n            {\\n                int size = top+1;\\n                char *t = (char*)malloc(sizeof(char)*(size+1));\\n                for(int i = 0; i < size; i++)\\n                    t[i] = stack[i];\\n                t[size] = '\\\\0';\\n                int i = 0;\\n                while(i < *returnSize) //remove duplicates;\\n                {\\n                    if(!strcmp(t, (*arr)[i]))\\n                        break;\\n                    i++;\\n                }\\n                if(i == *returnSize) //add a bran-new string;\\n                {\\n                    *returnSize += 1;\\n                    *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                    (*arr)[*returnSize-1] = t;\\n                }\\n            }\\n            return ;\\n        }\\n        char c = s[start];\\n        if(c == '(')\\n        {\\n            if(left) //try to remove it;\\n                traverse(s, len, start+1, left-1, right, pair, stack, top, arr, returnSize);\\n            stack[top+1] = c; //try to add it as a pair;\\n            traverse(s, len, start+1, left, right, pair+1, stack, top+1, arr, returnSize);\\n        }\\n        else if(c == ')')\\n        {\\n            if(right) //try to remove it;\\n                traverse(s, len, start+1, left, right-1, pair, stack, top, arr, returnSize);\\n            if(pair) //try to use it as the other half of a pair;\\n            {\\n                stack[top+1] = c;\\n                traverse(s, len, start+1, left, right, pair-1, stack, top+1, arr, returnSize);\\n            }\\n        }\\n        else //just collect since it's not brackets;\\n        {\\n            stack[top+1] = c;\\n            traverse(s, len, start+1, left, right, pair, stack, top+1, arr, returnSize);\\n        }\\n    }\\n    \\n    //AC - 0ms;\\n    char** removeInvalidParentheses(char* s, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int left=0, right=0;\\n        for(int i = 0; s[i]; i++) //find out how many opening and closing brackets should be removed;\\n        {\\n            if(s[i] == '(') left++;\\n            else if(s[i] == ')')\\n            {\\n                if(left) left--;\\n                else right++;\\n            }\\n        }\\n        int len = strlen(s);\\n        char *stack = (char*)malloc(sizeof(char)*len);\\n        int top = -1;\\n        traverse(s, len, 0, left, right, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 75090,
                "title": "python-dfs-solution",
                "content": "Inspired from [here][1]. The idea is basically DFS and pruning when the parentheses is already visited or number of invalid parentheses is less than current invalid\\n\\n        \\n        def removeInvalidParentheses(self, s):\\n            res = []\\n            self.visited = set([s])\\n            self.dfs(s, self.invalid(s), res)\\n            return res\\n        \\n        def dfs(self, s, n, res):\\n            if n == 0:\\n                res.append(s)\\n                return\\n            for i in range(len(s)):\\n                if s[i] in ('(',')'):\\n                    new_s = s[:i]+s[i+1:]\\n                    if new_s not in self.visited and self.invalid(new_s) < n:\\n                        self.visited.add(new_s)\\n                        self.dfs(new_s, self.invalid(new_s), res)\\n            \\n        def invalid(self, s):\\n            plus = minus = 0\\n            memo = {\"(\":1, \")\":-1}\\n            for c in s:\\n                plus += memo.get(c,0)\\n                minus += 1 if plus < 0 else 0\\n                plus = max(0, plus)\\n            return plus + minus\\n\\n  [1]: http://bookshadow.com/weblog/2015/11/05/leetcode-remove-invalid-parentheses/",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Inspired from [here][1]. The idea is basically DFS and pruning when the parentheses is already visited or number of invalid parentheses is less than current invalid\\n\\n        \\n        def removeInvalidParentheses(self, s):\\n            res = []\\n            self.visited = set([s])\\n            self.dfs(s, self.invalid(s), res)\\n            return res\\n        \\n        def dfs(self, s, n, res):\\n            if n == 0:\\n                res.append(s)\\n                return\\n            for i in range(len(s)):\\n                if s[i] in ('(',')'):\\n                    new_s = s[:i]+s[i+1:]\\n                    if new_s not in self.visited and self.invalid(new_s) < n:\\n                        self.visited.add(new_s)\\n                        self.dfs(new_s, self.invalid(new_s), res)\\n            \\n        def invalid(self, s):\\n            plus = minus = 0\\n            memo = {\"(\":1, \")\":-1}\\n            for c in s:\\n                plus += memo.get(c,0)\\n                minus += 1 if plus < 0 else 0\\n                plus = max(0, plus)\\n            return plus + minus\\n\\n  [1]: http://bookshadow.com/weblog/2015/11/05/leetcode-remove-invalid-parentheses/",
                "codeTag": "Python3"
            },
            {
                "id": 1732399,
                "title": "self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string, bool> mp;     // to avoid duplicates\\n    int getInvalid(string s){\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\') \\n                st.push(\\'(\\');\\n            else if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top()==\\'(\\') \\n                    st.pop();\\n                else st.push(\\')\\');\\n            }\\n        }\\n        return st.size();       // no of invalid parentheses\\n    }\\n    void removeInvalidParentheses(string s, int invalid){\\n        \\n        if(mp[s]==1) return;        // if already go back\\n        else mp[s] = 1;\\n        if(invalid<0) return;\\n        if(invalid==0) {\\n            if(!getInvalid(s))\\n            ans.push_back(s);\\n            return;\\n        }\\n        ////////////////////////////////\\n        for(int i=0; i<s.size(); i++){\\n            string left = s.substr(0, i);   // 0 -> i-1\\n            string right = s.substr(i+1);   // i -> till last\\n            removeInvalidParentheses( left + right, invalid-1);  // decrement invalid cnt\\n//  -->     remove and call (check now it is valid or not)\\n//  -->     if more invalid were there we had done helper call that many times\\n        }\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        removeInvalidParentheses(s, getInvalid(s));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string, bool> mp;     // to avoid duplicates\\n    int getInvalid(string s){\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\') \\n                st.push(\\'(\\');\\n            else if(s[i]==\\')\\'){\\n                if(!st.empty() && st.top()==\\'(\\') \\n                    st.pop();\\n                else st.push(\\')\\');\\n            }\\n        }\\n        return st.size();       // no of invalid parentheses\\n    }\\n    void removeInvalidParentheses(string s, int invalid){\\n        \\n        if(mp[s]==1) return;        // if already go back\\n        else mp[s] = 1;\\n        if(invalid<0) return;\\n        if(invalid==0) {\\n            if(!getInvalid(s))\\n            ans.push_back(s);\\n            return;\\n        }\\n        ////////////////////////////////\\n        for(int i=0; i<s.size(); i++){\\n            string left = s.substr(0, i);   // 0 -> i-1\\n            string right = s.substr(i+1);   // i -> till last\\n            removeInvalidParentheses( left + right, invalid-1);  // decrement invalid cnt\\n//  -->     remove and call (check now it is valid or not)\\n//  -->     if more invalid were there we had done helper call that many times\\n        }\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        removeInvalidParentheses(s, getInvalid(s));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166497,
                "title": "easy-c-solution-using-dfs",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    // Function to calculate how many invalid parenthesis are there in a string\\n    int getmin(string s)\\n    {\\n        int n=s.length();\\n        stack<char>stk;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(stk.empty())\\n                {\\n                    stk.push(s[i]);\\n                }\\n                else\\n                {\\n                    if(stk.top()==\\'(\\')\\n                    {\\n                        stk.pop();\\n                    }\\n                    else\\n                    {\\n                        stk.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return stk.size();\\n    }\\n    void helper(unordered_set<string>&h,unordered_set<string>&dict,vector<string>&v,string s,int mra)\\n    {\\n        // If minimum removals allowed is 0 that means we can\\'t remove anymore charcter\\n        if(mra==0)\\n        {\\n            //If no. of invalid parenthesis is 0 and it is not included in the\\n            // result then add it to the result cause it is a valid string\\n            if(getmin(s)==0 && h.find(s)==h.end())\\n            {\\n                h.insert(s);\\n                v.push_back(s);\\n            }\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string tmp=s.substr(0,i)+s.substr(i+1); // Removing the ith character\\n            if(dict.find(tmp)==dict.end()) // Check whether we have already computed this string or not\\n            {\\n                dict.insert(tmp);\\n                helper(h,dict,v,tmp,mra-1);\\n            }\\n        }\\n    }\\n    vector<string> removeInvalidParentheses(string s)\\n    {\\n        int mra=getmin(s); // mra is the minimum no. of parentheis to be removed to make the string valid\\n        unordered_set<string>h,dict;\\n        // h is for removing duplicate results and dict is for storing computed strings\\n        vector<string>v;\\n        helper(h,dict,v,s,mra);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // Function to calculate how many invalid parenthesis are there in a string\\n    int getmin(string s)\\n    {\\n        int n=s.length();\\n        stack<char>stk;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(stk.empty())\\n                {\\n                    stk.push(s[i]);\\n                }\\n                else\\n                {\\n                    if(stk.top()==\\'(\\')\\n                    {\\n                        stk.pop();\\n                    }\\n                    else\\n                    {\\n                        stk.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return stk.size();\\n    }\\n    void helper(unordered_set<string>&h,unordered_set<string>&dict,vector<string>&v,string s,int mra)\\n    {\\n        // If minimum removals allowed is 0 that means we can\\'t remove anymore charcter\\n        if(mra==0)\\n        {\\n            //If no. of invalid parenthesis is 0 and it is not included in the\\n            // result then add it to the result cause it is a valid string\\n            if(getmin(s)==0 && h.find(s)==h.end())\\n            {\\n                h.insert(s);\\n                v.push_back(s);\\n            }\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string tmp=s.substr(0,i)+s.substr(i+1); // Removing the ith character\\n            if(dict.find(tmp)==dict.end()) // Check whether we have already computed this string or not\\n            {\\n                dict.insert(tmp);\\n                helper(h,dict,v,tmp,mra-1);\\n            }\\n        }\\n    }\\n    vector<string> removeInvalidParentheses(string s)\\n    {\\n        int mra=getmin(s); // mra is the minimum no. of parentheis to be removed to make the string valid\\n        unordered_set<string>h,dict;\\n        // h is for removing duplicate results and dict is for storing computed strings\\n        vector<string>v;\\n        helper(h,dict,v,s,mra);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856905,
                "title": "python-3-commented-bfs",
                "content": "*Runtime: 196 ms, faster than 45.23% of Python3 online submissions for Remove Invalid Parentheses.\\nMemory Usage: 14.3 MB, less than 26.77% of Python3 online submissions for Remove Invalid Parentheses.*\\n\\n```python\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        # define when a combination of parenthesis is still valid\\n        def valid(candidate):\\n            counter = 0\\n            for char in candidate:\\n                if char == \"(\": counter += 1\\n                elif char == \")\": counter -= 1\\n                if counter < 0: return False\\n            # balanced?\\n            return counter == 0\\n        # the actual BFS, we return the minimum of removals, so we stop as soon as we have something\\n        res, frontier = set() , set([s])\\n        while not res:\\n            _next = set()\\n            for candidate in frontier:\\n                if valid(candidate): res.add(candidate); continue\\n                # generate more candidates based on this candidate\\n                for i, letter in enumerate(candidate):\\n                    # skip trash\\n                    if letter not in \"()\": continue\\n                    _next.add(candidate[:i] + candidate[i+1:])\\n            frontier = _next\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        # define when a combination of parenthesis is still valid\\n        def valid(candidate):\\n            counter = 0\\n            for char in candidate:\\n                if char == \"(\": counter += 1\\n                elif char == \")\": counter -= 1\\n                if counter < 0: return False\\n            # balanced?\\n            return counter == 0\\n        # the actual BFS, we return the minimum of removals, so we stop as soon as we have something\\n        res, frontier = set() , set([s])\\n        while not res:\\n            _next = set()\\n            for candidate in frontier:\\n                if valid(candidate): res.add(candidate); continue\\n                # generate more candidates based on this candidate\\n                for i, letter in enumerate(candidate):\\n                    # skip trash\\n                    if letter not in \"()\": continue\\n                    _next.add(candidate[:i] + candidate[i+1:])\\n            frontier = _next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75036,
                "title": "very-easy-self-explanatory-fast-c-solution-0-ms",
                "content": "- If there are repeated open/close parentheses only remove one of them\\n- If the current state will not yield a solution (number of open parentheses so far < 0) stop iterating\\n- Remember open parentheses count so we don't have to calculate it again\\n\\n```\\nclass Solution {\\n    void remove(int open, int left, int right, int iStart, string s, vector<string> &out) {\\n        // Iterate through all the remaining characters and see if we can remove them\\n        // In the meantime we can also keep track of how many open parantheses we have \\n        // so far to avoid calculating it separately.\\n        for (int i = iStart; i < s.size() && open >= 0; ++i) {\\n            if (s[i] == '(') {\\n                // If we should remove this open parantheses, make sure last element wasn't an\\n                // open parantheses since removing this would result in the same output\\n                // as removing the previous one so it's redundant.\\n                if (left > 0 && (i == 0 || s[i - 1] != '('))\\n                    remove(open, left - 1, right, i, s.substr(0, i) + s.substr(i + 1), out);\\n\\n                ++open;\\n            } else if (s[i] == ')') {\\n                // Same as open parantheses, don't remove if same as previous character\\n                if (right > 0 && (i == 0 || s[i - 1] != ')'))\\n                    remove(open, left, right - 1, i, s.substr(0, i) + s.substr(i + 1), out);\\n\\n                --open;\\n            }\\n        }\\n        \\n        if (left == 0 && right == 0 && open == 0)\\n            out.emplace_back(move(s));\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> out;\\n        \\n        // How many left and right parantheses should we remove?\\n        int left = 0, right = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == '(') {\\n                ++left;\\n            } else if (s[i] == ')') {\\n                if (left > 0)\\n                    --left;\\n                else\\n                    ++right;\\n            }                \\n        }\\n        \\n        remove(0, left, right, 0, s, out);\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void remove(int open, int left, int right, int iStart, string s, vector<string> &out) {\\n        // Iterate through all the remaining characters and see if we can remove them\\n        // In the meantime we can also keep track of how many open parantheses we have \\n        // so far to avoid calculating it separately.\\n        for (int i = iStart; i < s.size() && open >= 0; ++i) {\\n            if (s[i] == '(') {\\n                // If we should remove this open parantheses, make sure last element wasn't an\\n                // open parantheses since removing this would result in the same output\\n                // as removing the previous one so it's redundant.\\n                if (left > 0 && (i == 0 || s[i - 1] != '('))\\n                    remove(open, left - 1, right, i, s.substr(0, i) + s.substr(i + 1), out);\\n\\n                ++open;\\n            } else if (s[i] == ')') {\\n                // Same as open parantheses, don't remove if same as previous character\\n                if (right > 0 && (i == 0 || s[i - 1] != ')'))\\n                    remove(open, left, right - 1, i, s.substr(0, i) + s.substr(i + 1), out);\\n\\n                --open;\\n            }\\n        }\\n        \\n        if (left == 0 && right == 0 && open == 0)\\n            out.emplace_back(move(s));\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> out;\\n        \\n        // How many left and right parantheses should we remove?\\n        int left = 0, right = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == '(') {\\n                ++left;\\n            } else if (s[i] == ')') {\\n                if (left > 0)\\n                    --left;\\n                else\\n                    ++right;\\n            }                \\n        }\\n        \\n        remove(0, left, right, 0, s, out);\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75110,
                "title": "straight-forward-solution-with-explanation",
                "content": ") is always follow (, so we just need to count the unmatched (.\\n\\nThree situations in each turn: \\n\\n1. (, pick and not pick it. \\n2. ), if we have unmatched (, 2 choices, else drop it.\\n3. pick other chars.\\n\\nSince it need to remove the minimum brackets, we should figure out the maximum matched ().\\nNotice the order of below two lines:\\n\\n    dfs(str.substring(1), subRes + '(', countLeft + 1, maxLeft + 1);\\n    dfs(str.substring(1), subRes, countLeft, maxLeft);\\n\\nIt ensures the maximum result appear before the shorter ones.\\n\\n    /**\\n     * @param {string} s\\n     * @return {string[]}\\n     */\\n    var removeInvalidParentheses = function(s) {\\n    \\tvar res = [], max = 0;\\n    \\tdfs(s, \"\", 0, 0);\\n    \\treturn res.length !== 0 ? res : [\"\"];\\n    \\n    \\tfunction dfs(str, subRes, countLeft, maxLeft){\\n    \\t\\tif(str === \"\"){\\n    \\t\\t\\tif(countLeft === 0 && subRes !== \"\"){\\n    \\t\\t\\t\\tif(maxLeft > max)\\n    \\t\\t\\t\\t\\tmax = maxLeft;\\n    \\t\\t\\t\\tif(max === maxLeft && res.indexOf(subRes) === -1)\\n    \\t\\t\\t\\t\\tres.push(subRes);\\n    \\t\\t\\t}\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif(str[0] === '('){\\n    \\t\\t\\tdfs(str.substring(1), subRes + '(', countLeft + 1, maxLeft + 1);\\n    \\t\\t\\tdfs(str.substring(1), subRes, countLeft, maxLeft);\\n    \\t\\t}else if(str[0] === ')'){\\n    \\t\\t\\tif(countLeft > 0)\\n    \\t\\t\\t\\tdfs(str.substring(1), subRes + ')', countLeft - 1, maxLeft);\\n    \\t\\t\\tdfs(str.substring(1), subRes, countLeft, maxLeft);\\n    \\t\\t}else{\\n    \\t\\t\\tdfs(str.substring(1), subRes + str[0], countLeft, maxLeft);\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": ") is always follow (, so we just need to count the unmatched (.\\n\\nThree situations in each turn: \\n\\n1. (, pick and not pick it. \\n2. ), if we have unmatched (, 2 choices, else drop it.\\n3. pick other chars.\\n\\nSince it need to remove the minimum brackets, we should figure out the maximum matched ().\\nNotice the order of below two lines:\\n\\n    dfs(str.substring(1), subRes + '(', countLeft + 1, maxLeft + 1);\\n    dfs(str.substring(1), subRes, countLeft, maxLeft);\\n\\nIt ensures the maximum result appear before the shorter ones.\\n\\n    /**\\n     * @param {string} s\\n     * @return {string[]}\\n     */\\n    var removeInvalidParentheses = function(s) {\\n    \\tvar res = [], max = 0;\\n    \\tdfs(s, \"\", 0, 0);\\n    \\treturn res.length !== 0 ? res : [\"\"];\\n    \\n    \\tfunction dfs(str, subRes, countLeft, maxLeft){\\n    \\t\\tif(str === \"\"){\\n    \\t\\t\\tif(countLeft === 0 && subRes !== \"\"){\\n    \\t\\t\\t\\tif(maxLeft > max)\\n    \\t\\t\\t\\t\\tmax = maxLeft;\\n    \\t\\t\\t\\tif(max === maxLeft && res.indexOf(subRes) === -1)\\n    \\t\\t\\t\\t\\tres.push(subRes);\\n    \\t\\t\\t}\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif(str[0] === '('){\\n    \\t\\t\\tdfs(str.substring(1), subRes + '(', countLeft + 1, maxLeft + 1);\\n    \\t\\t\\tdfs(str.substring(1), subRes, countLeft, maxLeft);\\n    \\t\\t}else if(str[0] === ')'){\\n    \\t\\t\\tif(countLeft > 0)\\n    \\t\\t\\t\\tdfs(str.substring(1), subRes + ')', countLeft - 1, maxLeft);\\n    \\t\\t\\tdfs(str.substring(1), subRes, countLeft, maxLeft);\\n    \\t\\t}else{\\n    \\t\\t\\tdfs(str.substring(1), subRes + str[0], countLeft, maxLeft);\\n    \\t\\t}\\n    \\t}\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 75099,
                "title": "c-8ms-dfs-solution-with-comments",
                "content": "    void DFS(int ind, int l, int r, const string &s, vector<string> &ret, string &path) {\\n        // l is the number of '('s and r is the number of ')'s in path\\n    \\tif(r>l) return;\\n    \\t\\n    \\tif(ind==s.size()) {\\n    \\t    // if !ret.empty(), we find one longest valid string\\n    \\t\\tif(l==r && (ret.empty() || path.size()==ret[0].size())) \\n    \\t\\t    ret.push_back(path);\\n    \\t\\treturn;\\n    \\t}\\n    \\t\\n    \\tif(!ret.empty())\\n    \\t    if(path.size() + s.size() - ind < ret[0].size()) return;\\n    \\t\\n    \\tchar c = s[ind++];\\n    \\tpath.push_back(c);\\n    \\tif(c!='(' && c!=')')\\n    \\t\\tDFS(ind,l,r,s,ret,path);\\n    \\telse if(c=='(')\\n    \\t\\tDFS(ind,l+1,r,s,ret,path);\\n    \\telse \\n    \\t\\tDFS(ind,l,r+1,s,ret,path);\\n    \\t\\n    \\tpath.pop_back();\\n    \\tif(c!='(' && c!=')')\\n    \\t    DFS(ind,l,r,s,ret,path);\\n    \\telse {\\n    \\t    //once decide to give up current '(' or ')', we do not need to try the continuous '('s or ')'s\\n    \\t    while(c==s[ind]) ++ind;\\n    \\t    DFS(ind,l,r,s,ret,path);\\n    \\t}\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n    \\tvector<string> ret;\\n    \\tstring path;\\n    \\tDFS(0,0,0,s,ret,path);\\n    \\tif(ret.empty()) return {\"\"};\\n    \\treturn ret;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    void DFS(int ind, int l, int r, const string &s, vector<string> &ret, string &path) {\\n        // l is the number of '('s and r is the number of ')'s in path\\n    \\tif(r>l) return;\\n    \\t\\n    \\tif(ind==s.size()) {\\n    \\t    // if !ret.empty(), we find one longest valid string\\n    \\t\\tif(l==r && (ret.empty() || path.size()==ret[0].size())) \\n    \\t\\t    ret.push_back(path);\\n    \\t\\treturn;\\n    \\t}\\n    \\t\\n    \\tif(!ret.empty())\\n    \\t    if(path.size() + s.size() - ind < ret[0].size()) return;\\n    \\t\\n    \\tchar c = s[ind++];\\n    \\tpath.push_back(c);\\n    \\tif(c!='(' && c!=')')\\n    \\t\\tDFS(ind,l,r,s,ret,path);\\n    \\telse if(c=='(')\\n    \\t\\tDFS(ind,l+1,r,s,ret,path);\\n    \\telse \\n    \\t\\tDFS(ind,l,r+1,s,ret,path);\\n    \\t\\n    \\tpath.pop_back();\\n    \\tif(c!='(' && c!=')')\\n    \\t    DFS(ind,l,r,s,ret,path);\\n    \\telse {\\n    \\t    //once decide to give up current '(' or ')', we do not need to try the continuous '('s or ')'s\\n    \\t    while(c==s[ind]) ++ind;\\n    \\t    DFS(ind,l,r,s,ret,path);\\n    \\t}\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n    \\tvector<string> ret;\\n    \\tstring path;\\n    \\tDFS(0,0,0,s,ret,path);\\n    \\tif(ret.empty()) return {\"\"};\\n    \\treturn ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1852712,
                "title": "c-remove-invalid-parentheses",
                "content": "**Logic : If therer exists \\'n\\' mismatched brackets. Then we can remove atmost \\'n\\' braces to make it valid**\\n\\nIn the this approach, we simply one by one remove our parentheses now as we can the bracket we also keep track of the previous sequences so that we won\\u2019t check the same sequence twice now if we find a valid sequence out of these all possibilities, we print all the valid possibilities and that\\u2019s how our program proceeds.\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\n\\t\\t/*Functtion to calculate miismatched bracket*/\\n\\t\\tint minvalid(string s){\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tfor(auto it: s){\\n\\t\\t\\t\\tif(it == \\'(\\')   st.push(it);\\n\\t\\t\\t\\telse if(it == \\')\\'){\\n\\t\\t\\t\\t\\tif(!st.empty() && st.top() == \\'(\\')\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\telse    st.push(it);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn st.size();\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tvoid solve(string s, vector<string>& ans, map<string, bool>& mpp, int removal){\\n\\t\\t\\t/*If the string is already present in the map return back*/\\n\\t\\t\\tif(mpp[s])  return;\\n\\t\\t\\t\\n\\t\\t\\t/*If the string is not prensent in the map add it, and give the value of the string TRUE*/\\n\\t\\t\\telse    mpp[s] = true;\\n\\n\\t\\t\\tif(removal==0){\\n\\t\\t\\t\\t/*Even though removal becomes zero we still have to cjeck for its validity*/\\n\\t\\t\\t\\tint n = minvalid(s);\\n\\t\\t\\t\\tif(n == 0)\\n\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\tstring left = s.substr(0,i);\\n\\t\\t\\t\\tstring right = s.substr(i+1);\\n\\t\\t\\t\\t/*Excluding the ith element*/\\n\\t\\t\\t\\tsolve(left+right, ans, mpp, removal-1); \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<string> removeInvalidParentheses(string s) {\\n\\t\\t\\tint removal = minvalid(s);\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tmap<string, bool> mpp;\\n\\t\\t\\tsolve(s, ans, mpp, removal);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n**Also Check :**\\n**1. Valid Parentheses :** https://leetcode.com/problems/valid-parentheses/discuss/1852395/c-valid-parentheses\\n**2. Minimum Number of Swaps to Make the String Balanced :** https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/discuss/1851792/c-minimum-number-of-swaps-to-make-the-string-balanced\\n**3. Minimum Add to Make Parentheses Valid :** https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/1852480/C%2B%2B-or-Minimum-Add-to-Make-Parentheses-Valid",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\t/*Functtion to calculate miismatched bracket*/\\n\\t\\tint minvalid(string s){\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tfor(auto it: s){\\n\\t\\t\\t\\tif(it == \\'(\\')   st.push(it);\\n\\t\\t\\t\\telse if(it == \\')\\'){\\n\\t\\t\\t\\t\\tif(!st.empty() && st.top() == \\'(\\')\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\telse    st.push(it);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 75075,
                "title": "simple-dfs-yet-quite-efficient-in-cpp",
                "content": "There must be some extra `(` or `)` that cannot be matched, so the first step is to count them - there are either extra `(` or extra `)` (there is no way that both of them are redundant). \\n\\nThen we can start to traverse and try different options (for example: if there are extra `(` then we can either remove it or keep it when we encounter it, but if we keep it then it has to be matched by another `)`, so we are to use another value `openCount` to count the unmatched `(` and when we reach the end of the string, all we need to do is check whether all the `unmatched (` are matched, if they are then we can collect them)\\n\\n> **Note** Using `unordered_set` to avoid duplicates.\\n\\n-----\\n```\\nclass Solution {\\npublic:\\n    void removeInvalid(string& s, int pos, string t, unordered_set<string>& v, int lCount, int rCount, int openCount){\\n        if(s[pos] == '\\\\0') { if(!openCount) v.insert(t); return ; }\\n        if(s[pos] == '('){\\n            if(lCount) removeInvalid(s, pos+1, t, v, lCount-1, rCount, openCount);\\n            removeInvalid(s, pos+1, t+\"(\", v, lCount, rCount, openCount+1);\\n        }\\n        else if(s[pos] == ')'){\\n            if(rCount) removeInvalid(s, pos+1, t, v, lCount, rCount-1, openCount);\\n            if(openCount) removeInvalid(s, pos+1, t+\")\", v, lCount, rCount, openCount-1);\\n        }\\n        else removeInvalid(s, pos+1, t+s[pos], v, lCount, rCount, openCount);\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        int lCount = 0, rCount = 0;\\n        unordered_set<string> v;\\n        for(int i = 0; s[i]; ++i)\\n            if(s[i] == '(') lCount++;\\n            else if(s[i] == ')') lCount>0? lCount-- : rCount++;\\n        removeInvalid(s, 0, \"\", v, lCount, rCount, 0);\\n        return vector<string>(v.begin(), v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void removeInvalid(string& s, int pos, string t, unordered_set<string>& v, int lCount, int rCount, int openCount){\\n        if(s[pos] == '\\\\0') { if(!openCount) v.insert(t); return ; }\\n        if(s[pos] == '('){\\n            if(lCount) removeInvalid(s, pos+1, t, v, lCount-1, rCount, openCount);\\n            removeInvalid(s, pos+1, t+\"(\", v, lCount, rCount, openCount+1);\\n        }\\n        else if(s[pos] == ')'){\\n            if(rCount) removeInvalid(s, pos+1, t, v, lCount, rCount-1, openCount);\\n            if(openCount) removeInvalid(s, pos+1, t+\")\", v, lCount, rCount, openCount-1);\\n        }\\n        else removeInvalid(s, pos+1, t+s[pos], v, lCount, rCount, openCount);\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        int lCount = 0, rCount = 0;\\n        unordered_set<string> v;\\n        for(int i = 0; s[i]; ++i)\\n            if(s[i] == '(') lCount++;\\n            else if(s[i] == ')') lCount>0? lCount-- : rCount++;\\n        removeInvalid(s, 0, \"\", v, lCount, rCount, 0);\\n        return vector<string>(v.begin(), v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75097,
                "title": "share-my-c-bfs-solution-4ms",
                "content": "    class Solution {\\n    public:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> ans;\\n        if (s.size() == 0) {\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        deque<string> queue;\\n        unordered_set<string> exists;\\n        queue.push_back(s);\\n        while (!queue.empty()) {\\n            string target_str = queue.front();\\n            queue.pop_front();\\n            // cut from 172ms to 92ms\\n            if (exists.find(target_str) != exists.end()) {\\n                continue;\\n            }\\n            // cut from 16 to 4ms\\n            exists.insert(target_str);\\n            int invalid_point = findInvalidPoint(target_str);\\n            if (invalid_point == -1) {\\n                ans.push_back(target_str);\\n                continue;\\n            }\\n            int start = 0;\\n            int limit = target_str.size();\\n            if (target_str[invalid_point] == LC) {\\n                start = invalid_point;\\n            } else {\\n                limit = invalid_point + 1;\\n            }\\n            for (int i = start; i < limit; ++i) {\\n                if (target_str[i] != target_str[invalid_point]) {\\n                    continue;\\n                }\\n                // cut from 92ms to 16ms, no need to search \\n                if (i != start && target_str[i-1] == target_str[i]) {\\n                    continue;\\n                }\\n                string tmp_s = target_str.substr(0, i);\\n                if (i != target_str.size() - 1) {\\n                    tmp_s.append(target_str.substr(i+1, target_str.size()));\\n                }\\n                queue.push_back(tmp_s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    private:\\n    const char LC = '(';\\n    const char RC = ')';\\n    int findInvalidPoint(string& s) {\\n        stack<pair<char, int> > st;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == LC) {\\n                st.push(pair<char, int>(s[i], i));\\n            } else if (s[i] == RC) {\\n                if (st.size() == 0) {\\n                    return i;\\n                } \\n                st.pop();\\n            }\\n        }\\n        int top = -1;\\n        if (!st.empty()) {\\n            top = st.top().second;\\n            st.pop();\\n        }\\n        return top;\\n    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> ans;\\n        if (s.size() == 0) {\\n            ans.push_back(\"\");\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 75098,
                "title": "java-bfs-40ms-and-dfs-17ms-without-hashset",
                "content": "The critical step is to recognize that this question can be reformulated as below\\n\\nGiven Array[], find all possible combinations which can form a valid parenthesis. And among all of them, find the longest. So first I'd recommend to work on question https://leetcode.com/problems/subsets-ii/\\n\\nSo what we'll try to do is to generate unique combinations using either Iterative(BFS) or recursive(DFS). Two observations can help\\n\\n 1. continuous (((+ or )))+ are guaranteed to be duplicate\\n 2.  if if we define an extra element to identify the position of last removed index, then next BFS, we'll only need to start from there, instead of loop from 0 to str.length. According to combination C(n,k) = C(n-1,k-1) + C(n-1,k)\\n\\n\\nBFS\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        Queue<String> queue = new LinkedList<>();\\n        Queue<Integer> ends = new LinkedList<>(); //here consider ends is index of last removed element!\\n    \\n        List<String> res = new ArrayList<>();\\n        int size = 1;\\n        queue.offer(s);\\n        ends.add(s.length());\\n    \\n        while (!queue.isEmpty()) {\\n            String str = queue.poll();\\n            int end = ends.poll();\\n    \\n            if (isValid(str)) res.add(str);\\n    \\n            //only when not found, we need to consider next level\\n            if (res.size() > 0) continue;\\n            for (int i = end - 1; i >= 0; i--) {\\n                if (str.charAt(i) != '(' && str.charAt(i) != ')') continue;\\n                String next = (new StringBuilder()).append(str.substring(0, i)).append(str.substring(i + 1)).toString();\\n                queue.offer(next);\\n                ends.add(i);\\n                \\n                //skip continuous ')' and '('\\n                while (i > 0 && str.charAt(i) == str.charAt(i - 1)) i--;\\n            }\\n    \\n            //check level finish, if not found, go on to next level\\n            if (--size == 0) {\\n                if (res.size() > 0) break;\\n                size = queue.size();\\n            }\\n        }\\n    \\n        return res;\\n    }\\n    \\n    \\n    private boolean isValid(String s) {\\n        int open = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == '(') open++;\\n            else if (c == ')') open--;\\n            if (open < 0) return false;\\n        }\\n        return open == 0;\\n    }\\n\\nDFS\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, s, 0, new StringBuilder(), 0);\\n\\n        return res;\\n    }\\n\\n\\n    private void dfs(List<String> res, String s, int start, StringBuilder path, int open) {\\n        if (open < 0) return;\\n        if (!res.isEmpty() && path.length() + s.length() - start < res.get(0).length()) return;\\n        if (start == s.length()) {\\n            if (open == 0 && (res.size() == 0 || path.length() == res.get(0).length())) res.add(path.toString());\\n            return;\\n        }\\n\\n        path.append(s.charAt(start));\\n        if (s.charAt(start) != '(' && s.charAt(start) != ')') dfs(res, s, start + 1, path, open);\\n        else {\\n            dfs(res, s, start + 1, path, open + (s.charAt(start) == '(' ? 1 : -1));\\n            while (start < s.length() - 1 && s.charAt(start) == s.charAt(start + 1)) start++;\\n        }\\n\\n        path.deleteCharAt(path.length() - 1);\\n        dfs(res, s, start + 1, path, open);\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "The critical step is to recognize that this question can be reformulated as below\\n\\nGiven Array[], find all possible combinations which can form a valid parenthesis. And among all of them, find the longest. So first I'd recommend to work on question https://leetcode.com/problems/subsets-ii/\\n\\nSo what we'll try to do is to generate unique combinations using either Iterative(BFS) or recursive(DFS). Two observations can help\\n\\n 1. continuous (((+ or )))+ are guaranteed to be duplicate\\n 2.  if if we define an extra element to identify the position of last removed index, then next BFS, we'll only need to start from there, instead of loop from 0 to str.length. According to combination C(n,k) = C(n-1,k-1) + C(n-1,k)\\n\\n\\nBFS\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        Queue<String> queue = new LinkedList<>();\\n        Queue<Integer> ends = new LinkedList<>(); //here consider ends is index of last removed element!\\n    \\n        List<String> res = new ArrayList<>();\\n        int size = 1;\\n        queue.offer(s);\\n        ends.add(s.length());\\n    \\n        while (!queue.isEmpty()) {\\n            String str = queue.poll();\\n            int end = ends.poll();\\n    \\n            if (isValid(str)) res.add(str);\\n    \\n            //only when not found, we need to consider next level\\n            if (res.size() > 0) continue;\\n            for (int i = end - 1; i >= 0; i--) {\\n                if (str.charAt(i) != '(' && str.charAt(i) != ')') continue;\\n                String next = (new StringBuilder()).append(str.substring(0, i)).append(str.substring(i + 1)).toString();\\n                queue.offer(next);\\n                ends.add(i);\\n                \\n                //skip continuous ')' and '('\\n                while (i > 0 && str.charAt(i) == str.charAt(i - 1)) i--;\\n            }\\n    \\n            //check level finish, if not found, go on to next level\\n            if (--size == 0) {\\n                if (res.size() > 0) break;\\n                size = queue.size();\\n            }\\n        }\\n    \\n        return res;\\n    }\\n    \\n    \\n    private boolean isValid(String s) {\\n        int open = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == '(') open++;\\n            else if (c == ')') open--;\\n            if (open < 0) return false;\\n        }\\n        return open == 0;\\n    }\\n\\nDFS\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, s, 0, new StringBuilder(), 0);\\n\\n        return res;\\n    }\\n\\n\\n    private void dfs(List<String> res, String s, int start, StringBuilder path, int open) {\\n        if (open < 0) return;\\n        if (!res.isEmpty() && path.length() + s.length() - start < res.get(0).length()) return;\\n        if (start == s.length()) {\\n            if (open == 0 && (res.size() == 0 || path.length() == res.get(0).length())) res.add(path.toString());\\n            return;\\n        }\\n\\n        path.append(s.charAt(start));\\n        if (s.charAt(start) != '(' && s.charAt(start) != ')') dfs(res, s, start + 1, path, open);\\n        else {\\n            dfs(res, s, start + 1, path, open + (s.charAt(start) == '(' ? 1 : -1));\\n            while (start < s.length() - 1 && s.charAt(start) == s.charAt(start + 1)) start++;\\n        }\\n\\n        path.deleteCharAt(path.length() - 1);\\n        dfs(res, s, start + 1, path, open);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 439831,
                "title": "javascript-solution-w-explanation-bfs-dfs",
                "content": "Im sure lots of optimizations can be made here, but I think these simpler versions give the best ideas toward this problem. :)\\n### The idea - BFS\\n1. Build a tree where the `root` node is the given string, and each level(child nodes), we are trying to remove 1 parentheses from the previous nodes. \\n2. At some level, we will remove enough parentheses to generage a valid string, and we stop going to deeper levels at that point.\\n``` javascript\\nvar removeInvalidParenthesesBFS = function(s) {\\n\\t// sanity check\\n    if (s.length == 0 || s == null) return [\"\"];\\n\\n    var isValid = function(str) {\\n        let count = 0;\\n        for (let i=0;i<str.length;i++) {\\n            if (str[i] == \\')\\' && count-- == 0) return false;\\n            else if (str[i] == \\'(\\') count++;\\n        }\\n        return count==0;\\n    }\\n\\n    let queue = [s], result = [], done = false;\\n    while(queue.length!=0) {\\n        let node = queue.shift();\\n        if (isValid(node)) {\\n            result.push(node);\\n            done = true;\\n        }\\n\\n        // generate child nodes for next level\\n        if (!done) { \\n            for (let i=0;i<node.length;i++) {\\n                if (node[i]==\\'(\\'||node[i]==\\')\\') {\\n\\t\\t\\t\\t\\t// prep the child node by removing the current parenthese \\n                    let temp = node.substring(0,i) + node.substring(i+1);\\n                    if (!queue.includes(temp)) queue.push(temp);\\n                    if (node[i]==\\'(\\') while(node[i+1]==\\'(\\') i++;\\n                    else while(node[i+1]==\\')\\') i++;\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```\\n### The idea - DFS\\n1. The methodology of DFS is to use recursion to expore all the possibilities (nodes)\\n``` javascript\\nvar removeInvalidParentheses = function(s) {\\n    // sanity check\\n    if (!s.length) return [\"\"];\\n\\n    /**\\n     * @param {Number} l - invalid \\'(\\' needs to be removed\\n     * @param {Number} r - invalid \\')\\' needs to be removed\\n     * @param {Number} i - current position\\n     * @param {Number} a - current result assembly\\n     * @param {Number} c - bracket counter (check validness) \\n     * when c < 0, it means we have an extra \\')\\' up to the current point, \\n     * which means the string will never be valid\\n     */\\n    var dfs = function(l, r, i, a, c) {\\n        if (l < 0 || r < 0 || c < 0) return;\\n        if (i == s.length) {\\n            if (l==0 && r==0 && c==0) result.add(a);\\n            return;\\n        }\\n\\n        if (s[i] == \\'(\\' || s[i] == \\')\\') {\\n            let f = s[i]==\\'(\\'; // flag\\n            dfs(l, r, i+1, a+s[i], c+(f?1:-1)); // keep\\n            dfs(l-(f?1:0),r-(f?0:1), i+1, a, c) // remove\\n        } else {\\n            dfs(l, r, i+1, a+s[i], c);\\n        }\\n    }\\n\\n    // count invalid parentheses\\n    let lc = 0, rc = 0;\\n    for (let i=0;i<s.length;i++) {\\n        if (s[i] == \\'(\\') lc++;\\n        else if (s[i] == \\')\\') {\\n            if (lc > 0) lc--;\\n            else rc++;\\n        }\\n    }\\n\\n    let result = new Set();\\n    dfs(lc, rc, 0, \"\", 0);\\n    return [...result.values()];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar removeInvalidParenthesesBFS = function(s) {\\n\\t// sanity check\\n    if (s.length == 0 || s == null) return [\"\"];\\n\\n    var isValid = function(str) {\\n        let count = 0;\\n        for (let i=0;i<str.length;i++) {\\n            if (str[i] == \\')\\' && count-- == 0) return false;\\n            else if (str[i] == \\'(\\') count++;\\n        }\\n        return count==0;\\n    }\\n\\n    let queue = [s], result = [], done = false;\\n    while(queue.length!=0) {\\n        let node = queue.shift();\\n        if (isValid(node)) {\\n            result.push(node);\\n            done = true;\\n        }\\n\\n        // generate child nodes for next level\\n        if (!done) { \\n            for (let i=0;i<node.length;i++) {\\n                if (node[i]==\\'(\\'||node[i]==\\')\\') {\\n\\t\\t\\t\\t\\t// prep the child node by removing the current parenthese \\n                    let temp = node.substring(0,i) + node.substring(i+1);\\n                    if (!queue.includes(temp)) queue.push(temp);\\n                    if (node[i]==\\'(\\') while(node[i+1]==\\'(\\') i++;\\n                    else while(node[i+1]==\\')\\') i++;\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```\n``` javascript\\nvar removeInvalidParentheses = function(s) {\\n    // sanity check\\n    if (!s.length) return [\"\"];\\n\\n    /**\\n     * @param {Number} l - invalid \\'(\\' needs to be removed\\n     * @param {Number} r - invalid \\')\\' needs to be removed\\n     * @param {Number} i - current position\\n     * @param {Number} a - current result assembly\\n     * @param {Number} c - bracket counter (check validness) \\n     * when c < 0, it means we have an extra \\')\\' up to the current point, \\n     * which means the string will never be valid\\n     */\\n    var dfs = function(l, r, i, a, c) {\\n        if (l < 0 || r < 0 || c < 0) return;\\n        if (i == s.length) {\\n            if (l==0 && r==0 && c==0) result.add(a);\\n            return;\\n        }\\n\\n        if (s[i] == \\'(\\' || s[i] == \\')\\') {\\n            let f = s[i]==\\'(\\'; // flag\\n            dfs(l, r, i+1, a+s[i], c+(f?1:-1)); // keep\\n            dfs(l-(f?1:0),r-(f?0:1), i+1, a, c) // remove\\n        } else {\\n            dfs(l, r, i+1, a+s[i], c);\\n        }\\n    }\\n\\n    // count invalid parentheses\\n    let lc = 0, rc = 0;\\n    for (let i=0;i<s.length;i++) {\\n        if (s[i] == \\'(\\') lc++;\\n        else if (s[i] == \\')\\') {\\n            if (lc > 0) lc--;\\n            else rc++;\\n        }\\n    }\\n\\n    let result = new Set();\\n    dfs(lc, rc, 0, \"\", 0);\\n    return [...result.values()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415004,
                "title": "python-dfs",
                "content": "First we read `s` from left to right and remove all the invalid `)`. Then we will get multiple candidate solutions and save them in `cands`. Then we read each candidate from right to left (reversely) and remove all the invalid `(` and we will get the final solutions.\\n\\nSo it takes two round dfs. The first dfs takes in credit map: `{\"(\":1, \")\":-1}` and produce candidates and the second dfs takes in `{\")\":1, \"(\":-1}` and produce solutions.\\n\\nIn dfs, we use a `bal` to track current balance. Once `bal < 0` when we read at index `j`, current `s` is not balance and we need to remove a parenthese, which is `)` in the first dfs and `(` in the second dfs. In either case, its credit is `-1`. We can remove any negative parenthese at index `i` as long as `i < j` and produce a new dfs branch.\\n\\nAnd be careful we can only remove one negative parenthese when there is a consecutive array of negative parentheses. e.g. In the first dfs, when we reach `())(`, we can only remove one `)` otherwise we will produce two identical solutions of `)()`. So I add `i == l or p.get(s[i-1], 0) != -1` to avoid that.\\n\\nAnd due to we need to read each candidate reversely, we can save each candidate reversely in the first place. In the second dfs, it will reverse them back and produce the correct solution.\\n\\n```\\ndef removeInvalidParentheses(s):\\n\\tdef dfs(s, l, r, p, sols):\\n\\t\\tbal = 0\\n\\t\\tfor j in range(r, len(s)):\\n\\t\\t\\tbal += p.get(s[j], 0)\\n\\t\\t\\tif bal < 0:\\n\\t\\t\\t\\tfor i in range(l, j+1):\\n\\t\\t\\t\\t\\tif p.get(s[i], 0) == -1 and (i == l or p.get(s[i-1], 0) != -1):\\n\\t\\t\\t\\t\\t\\tdfs(s[:i]+s[i+1:], i, j, p, sols)\\n\\t\\t\\t\\treturn\\n\\t\\tsols.append(s[::-1])\\n\\n\\tcands, sols = [], []\\n\\tdfs(s, 0, 0, {\"(\":1, \")\":-1}, cands)\\n\\tfor cand in cands:\\n\\t\\tdfs(cand, 0, 0, {\")\":1, \"(\":-1}, sols)\\n\\treturn sols\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeInvalidParentheses(s):\\n\\tdef dfs(s, l, r, p, sols):\\n\\t\\tbal = 0\\n\\t\\tfor j in range(r, len(s)):\\n\\t\\t\\tbal += p.get(s[j], 0)\\n\\t\\t\\tif bal < 0:\\n\\t\\t\\t\\tfor i in range(l, j+1):\\n\\t\\t\\t\\t\\tif p.get(s[i], 0) == -1 and (i == l or p.get(s[i-1], 0) != -1):\\n\\t\\t\\t\\t\\t\\tdfs(s[:i]+s[i+1:], i, j, p, sols)\\n\\t\\t\\t\\treturn\\n\\t\\tsols.append(s[::-1])\\n\\n\\tcands, sols = [], []\\n\\tdfs(s, 0, 0, {\"(\":1, \")\":-1}, cands)\\n\\tfor cand in cands:\\n\\t\\tdfs(cand, 0, 0, {\")\":1, \"(\":-1}, sols)\\n\\treturn sols\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 397950,
                "title": "remove-invalid-parenthesis-using-bfs-clear-explanation",
                "content": "```\\n# Objective is to find valid string with least number of changes.\\n# If we use BFS and traverse levels, where levels represent number of changes/removals in the string then we will be able to find the valid strings corresponding to each level.\\n#Eg.\\n# starting = \"()())()\"\\n# Level 0 -> no valid string\\n# Level 1 -> \"()()()\", \"(())()\"\\n# Level 2 -> no valid string\\n# Level 3 -> \"()()\", \"(())\"\\n# In our case we want to minimize the change, so we will stop traversing into additional levels whenever we encounter a valid string in a level. In the above example we encounter valid string in Level 1, so we can stop traversing any further and just explore that same level to find out more valid strings.\\n\\nclass Solution:\\n    # To identify if the char is a parenthesis\\n    def isParenthesis(self, c):\\n        if c in set([\"(\", \")\"]):\\n            return True\\n        return False\\n    \\n    # To check if the string is valid or not. Matching parenthesis\\n    def isValid(self, S):\\n        stack = []\\n        for s in S:\\n            if s == \"(\":\\n                stack.append(s)\\n            elif s == \")\" and (not stack or stack[-1] != \"(\"):\\n                return False\\n            elif s == \")\":\\n                stack.pop()\\n            else:\\n                continue\\n        if stack: return False\\n        return True\\n                \\n    \\n    \\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        queue = [s]\\n        seen = set()\\n        \\n        result = []\\n        dont_traverse = False\\n        while(queue):\\n            str = queue.pop(0)\\n            if str not in seen:\\n                seen.add(str)\\n            else:\\n                continue\\n            # Find if it is a valid string\\n            if self.isValid(str):\\n                # Add this to result and set the flag to stop traversing any further vertically.\\n                result.append(str)\\n                dont_traverse = True\\n            \\n            \\n            if not dont_traverse: \\n                for i,p in enumerate(str):\\n                    if self.isParenthesis(p):\\n                        temp_str = str[0:i] + str[i+1:]\\n                        queue.append(temp_str)\\n        \\n            \\n        return result        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Objective is to find valid string with least number of changes.\\n# If we use BFS and traverse levels, where levels represent number of changes/removals in the string then we will be able to find the valid strings corresponding to each level.\\n#Eg.\\n# starting = \"()())()\"\\n# Level 0 -> no valid string\\n# Level 1 -> \"()()()\", \"(())()\"\\n# Level 2 -> no valid string\\n# Level 3 -> \"()()\", \"(())\"\\n# In our case we want to minimize the change, so we will stop traversing into additional levels whenever we encounter a valid string in a level. In the above example we encounter valid string in Level 1, so we can stop traversing any further and just explore that same level to find out more valid strings.\\n\\nclass Solution:\\n    # To identify if the char is a parenthesis\\n    def isParenthesis(self, c):\\n        if c in set([\"(\", \")\"]):\\n            return True\\n        return False\\n    \\n    # To check if the string is valid or not. Matching parenthesis\\n    def isValid(self, S):\\n        stack = []\\n        for s in S:\\n            if s == \"(\":\\n                stack.append(s)\\n            elif s == \")\" and (not stack or stack[-1] != \"(\"):\\n                return False\\n            elif s == \")\":\\n                stack.pop()\\n            else:\\n                continue\\n        if stack: return False\\n        return True\\n                \\n    \\n    \\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        queue = [s]\\n        seen = set()\\n        \\n        result = []\\n        dont_traverse = False\\n        while(queue):\\n            str = queue.pop(0)\\n            if str not in seen:\\n                seen.add(str)\\n            else:\\n                continue\\n            # Find if it is a valid string\\n            if self.isValid(str):\\n                # Add this to result and set the flag to stop traversing any further vertically.\\n                result.append(str)\\n                dont_traverse = True\\n            \\n            \\n            if not dont_traverse: \\n                for i,p in enumerate(str):\\n                    if self.isParenthesis(p):\\n                        temp_str = str[0:i] + str[i+1:]\\n                        queue.append(temp_str)\\n        \\n            \\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 397200,
                "title": "python-good-programmer-will-always-know-multiple-ways",
                "content": "(BFS & DFS With explanation)\\n\\n```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        if s == \"\":\\n            return [\"\"]\\n        \\n        # check the initial state of \\'s\\'. If either \\'(\\' or \\')\\' is in excess.\\n        left = right = 0\\n        for paren in s:\\n            if paren == \\'(\\':\\n                left += 1\\n            elif paren == \\')\\' and left > 0:\\n                left -= 1\\n            elif paren == \\')\\' and left == 0:\\n                right += 1\\n        \\n        #Method 1: BFS\\n        self.result = []\\n        self.visited = set()\\n        self._BFS(s, left, right)\\n        \\n        #Method 2: DFS\\n        self.result = []\\n        self.visited = set()\\n        self._DFS(s, 0, left, right)\\n        \\n        if self.result == []:\\n            return [\"\"]\\n        \\n        return self.result\\n\\n    def _DFS(self, s, index, left, right):\\n        self.visited.add(s)\\n        # only if the s is balanced check if it is also valid.\\n        if left == 0 and right == 0:\\n            if self._isValid(s):\\n                self.result.append(s)\\n        \\n        for i in range(index, len(s)):\\n            # if it is any other char ignore.\\n            if s[i] != \\'(\\' and s[i] != \\')\\':\\n                continue\\n            \\n            # if left == 0 then removing \\'(\\' will only cause imbalance. Hence, skip.\\n            if s[i] == \\'(\\' and left == 0:\\n                continue\\n            \\n            # if right == 0 then removing \\')\\' will only cause imbalance. Hence, skip.\\n            if s[i] == \\')\\' and right == 0:\\n                continue\\n            \\n            nxt = s[:i] + s[i+1:]\\n            if nxt not in self.visited:\\n                self._DFS(nxt, i, left - (s[i]==\\'(\\'), right - (s[i]==\\')\\'))\\n        \\n        \\n    def _BFS(self, s, left, right):\\n        BFSQueue, result = [(s, left, right)], []        \\n        minFound = False \\n        \\n        while BFSQueue:\\n            s, l, r = BFSQueue.pop(0) \\n            \\n            # only if the s is balanced check if it is also valid.\\n            if l == 0 and r == 0:\\n                if self._isValid(s):\\n                    result.append(s)\\n                    minFound = True\\n            \\n            #Once a valid expression is found, no need to do any further removals. \\n\\t\\t\\t#Just check for whatever is remaining in the queue\\n            if minFound:\\n                continue\\n            \\n            for i in range(len(s)):\\n                # if it is any other char ignore.\\n                if s[i] != \\'(\\' and s[i] != \\')\\':\\n                    continue\\n                \\n                # if l == 0 then removing \\'(\\' will only cause imbalance. Hence, skip.\\n                if s[i] == \\'(\\' and l == 0:\\n                    continue\\n                    \\n                # if r == 0 then removing \\')\\' will only cause imbalance. Hence, skip.\\n                if s[i] == \\')\\' and r == 0:\\n                    continue\\n                    \\n                nxt = s[:i] + s[i+1:]\\n                if nxt not in self.visited:\\n                    self.visited.add(nxt)\\n                    BFSQueue.append( (nxt, l - (s[i]==\\'(\\'), r - (s[i]==\\')\\')) )\\n        \\n        self.result = result\\n\\n        \\n    def _isValid(self, paren):\\n        parenCount = 0\\n        for p in paren:\\n            if p == \\'(\\':\\n                parenCount += 1\\n            elif p == \\')\\':\\n                parenCount -= 1\\n            if parenCount < 0:\\n                return False\\n        return parenCount == 0\\n    \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        if s == \"\":\\n            return [\"\"]\\n        \\n        # check the initial state of \\'s\\'. If either \\'(\\' or \\')\\' is in excess.\\n        left = right = 0\\n        for paren in s:\\n            if paren == \\'(\\':\\n                left += 1\\n            elif paren == \\')\\' and left > 0:\\n                left -= 1\\n            elif paren == \\')\\' and left == 0:\\n                right += 1\\n        \\n        #Method 1: BFS\\n        self.result = []\\n        self.visited = set()\\n        self._BFS(s, left, right)\\n        \\n        #Method 2: DFS\\n        self.result = []\\n        self.visited = set()\\n        self._DFS(s, 0, left, right)\\n        \\n        if self.result == []:\\n            return [\"\"]\\n        \\n        return self.result\\n\\n    def _DFS(self, s, index, left, right):\\n        self.visited.add(s)\\n        # only if the s is balanced check if it is also valid.\\n        if left == 0 and right == 0:\\n            if self._isValid(s):\\n                self.result.append(s)\\n        \\n        for i in range(index, len(s)):\\n            # if it is any other char ignore.\\n            if s[i] != \\'(\\' and s[i] != \\')\\':\\n                continue\\n            \\n            # if left == 0 then removing \\'(\\' will only cause imbalance. Hence, skip.\\n            if s[i] == \\'(\\' and left == 0:\\n                continue\\n            \\n            # if right == 0 then removing \\')\\' will only cause imbalance. Hence, skip.\\n            if s[i] == \\')\\' and right == 0:\\n                continue\\n            \\n            nxt = s[:i] + s[i+1:]\\n            if nxt not in self.visited:\\n                self._DFS(nxt, i, left - (s[i]==\\'(\\'), right - (s[i]==\\')\\'))\\n        \\n        \\n    def _BFS(self, s, left, right):\\n        BFSQueue, result = [(s, left, right)], []        \\n        minFound = False \\n        \\n        while BFSQueue:\\n            s, l, r = BFSQueue.pop(0) \\n            \\n            # only if the s is balanced check if it is also valid.\\n            if l == 0 and r == 0:\\n                if self._isValid(s):\\n                    result.append(s)\\n                    minFound = True\\n            \\n            #Once a valid expression is found, no need to do any further removals. \\n\\t\\t\\t#Just check for whatever is remaining in the queue\\n            if minFound:\\n                continue\\n            \\n            for i in range(len(s)):\\n                # if it is any other char ignore.\\n                if s[i] != \\'(\\' and s[i] != \\')\\':\\n                    continue\\n                \\n                # if l == 0 then removing \\'(\\' will only cause imbalance. Hence, skip.\\n                if s[i] == \\'(\\' and l == 0:\\n                    continue\\n                    \\n                # if r == 0 then removing \\')\\' will only cause imbalance. Hence, skip.\\n                if s[i] == \\')\\' and r == 0:\\n                    continue\\n                    \\n                nxt = s[:i] + s[i+1:]\\n                if nxt not in self.visited:\\n                    self.visited.add(nxt)\\n                    BFSQueue.append( (nxt, l - (s[i]==\\'(\\'), r - (s[i]==\\')\\')) )\\n        \\n        self.result = result\\n\\n        \\n    def _isValid(self, paren):\\n        parenCount = 0\\n        for p in paren:\\n            if p == \\'(\\':\\n                parenCount += 1\\n            elif p == \\')\\':\\n                parenCount -= 1\\n            if parenCount < 0:\\n                return False\\n        return parenCount == 0\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 391415,
                "title": "java-solution-with-detailed-comments-easy-understand-readable",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/remove-invalid-parentheses/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n## Problem\\n\\n> Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Note:** The input string may contain letters other than the parentheses `(` and `)`.\\n\\n**Example:** \\n\\n```java\\nInput: \"()())()\"\\nOutput: [\"()()()\", \"(())()\"]\\n\\nInput: \"(a)())()\"\\nOutput: [\"(a)()()\", \"(a())()\"]\\n\\nInput: \")\"\\nOutput: [\"\"]\\n\\nInput: \")a\"\\nOutput: [\"a\"]\\n\\nInput: \")(\"\\nOutput: [\"\"]\\n\\nInput: \"v)k)()\"\\nOutput: [\"vk()\"]\\n\\nInput: \"())))()v(k\"\\nOutput: [\"()()vk\"]\\n\\n// There are many test cases... If you write a good function of delete count calculation, you don\\'t have to worry about those corner and special cases!\\n```\\n\\n**Follow up:** Pruning\\n\\n\\n## Analysis\\n\\n### Backtracking\\n\\nMain function:\\n\\n```java\\npublic List<String> removeInvalidParentheses(String s) {\\n  List<String> result = new ArrayList<>();\\n  \\n  // calculate the number of \"(\" and \")\" we should delete\\n  int[] count = getDeleteCount(s);\\n  int leftCount = count[0];\\n  int rightCount = count[1];\\n  \\n  StringBuilder sb = new StringBuilder();\\n  backtrack(leftCount, rightCount, 0, 0, 0, sb, s, result, false, false);\\n  \\n  return result;\\n}\\n```\\n\\nThe `getDeleteCount` function helps determine how many `(` and `)` we will delete.\\n\\n**Note:**\\n\\n- **This function is very important.** `(` should be calculated starting from the right side of the array, which is opposed to the way we did for `(`.\\n- If this function does not provide correct number of `(` we should delete, you have to handle a lot of corner and special cases.\\n\\n```java\\n// Return how many \"(\" and \")\" should we delete.\\nprivate int[] getDeleteCount(String s) {\\n  int L1 = 0, R1 = 0;\\n  int L2 = 0, R2 = 0;\\n  int leftCount = 0, rightCount = 0;\\n  for (int i = 0; i < s.length(); ++i) {\\n    char ch1 = s.charAt(i); // from left\\n    char ch2 = s.charAt(s.length() - i - 1); // from right\\n    if (ch1 == \\'(\\') L1 += 1; // remember to skip other letters\\n    if (ch1 == \\')\\') R1 += 1;\\n    if (ch2 == \\'(\\') L2 += 1;\\n    if (ch2 == \\')\\') R2 += 1;\\n    rightCount = Math.max(rightCount, R1 - L1);\\n    leftCount = Math.max(leftCount, L2 - R2);\\n  }\\n  return new int[] { leftCount, rightCount };\\n}\\n```\\n\\nBacktracking function:\\n\\n```java\\n/**\\n * leftCount:    # of \"(\" we should delete\\n * rightCount:   # of \")\" we should delete\\n * L:            # of \"(\" we have selected\\n * R:            # of \")\" we have selected\\n * pos:          current index in the string\\n * deletedLeft:  indicate whether we deleted \"(\" in the previous level\\n * deletedRight: indicate whether we deleted \")\" in the previous level\\n * (deletedLeft and deletedRight are for duplicate checking)\\n * \\n * It means that if you have deleted \"(\" at the previous level, \\n * you should not choose \"(\" at the current level because it incurs duplicate results.\\n */\\nprivate void backtrack(int leftCount, int rightCount, int L, int R, int pos, \\n                       StringBuilder sb, String s, List<String> result, \\n                       boolean deletedLeft, boolean deletedRight) {\\n  // base case\\n  if (L < R) { // L < R (not balanced)\\n    return;\\n  }\\n  if (pos == s.length()) { // time to add the result\\n    if (leftCount == 0 && rightCount == 0 && L == R) { // check if it is a valid string\\n      result.add(sb.toString());\\n    }\\n    return;\\n  }\\n  \\n  char ch = s.charAt(pos);\\n  if (ch == \\'(\\') {\\n    // select\\n    if (deletedLeft == false || s.charAt(pos - 1) != \\'(\\') { // check for duplicates\\n      sb.append(ch);\\n      backtrack(leftCount, rightCount, L + 1, R, pos + 1, sb, s, result, false, false);\\n      sb.deleteCharAt(sb.length() - 1);\\n    }\\n    // do not select it (delete)\\n    if (leftCount > 0) {\\n      backtrack(leftCount - 1, rightCount, L, R, pos + 1, sb, s, result, true, false);\\n    }\\n  }\\n  else if (ch == \\')\\') {\\n    // select\\n    if (deletedRight == false || s.charAt(pos - 1) != \\')\\') { // check for duplicates\\n      sb.append(ch);\\n      backtrack(leftCount, rightCount, L, R + 1, pos + 1, sb, s, result, false, false);\\n      sb.deleteCharAt(sb.length() - 1);\\n    }\\n    // do not select it (delete)\\n    if (rightCount > 0) {\\n      backtrack(leftCount, rightCount - 1, L, R, pos + 1, sb, s, result, false, true);\\n    }\\n  }\\n  else { // other letter\\n    sb.append(ch);\\n    backtrack(leftCount, rightCount, L, R, pos + 1, sb, s, result, false, false);\\n    sb.deleteCharAt(sb.length() - 1);\\n    return;\\n  }\\n}\\n```\\n\\n**Time:** `O(2^N)` is the upper bound, but we have pruning.\\n**Space:** `O(N)` because of call stacks.\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nInput: \"()())()\"\\nOutput: [\"()()()\", \"(())()\"]\\n\\nInput: \"(a)())()\"\\nOutput: [\"(a)()()\", \"(a())()\"]\\n\\nInput: \")\"\\nOutput: [\"\"]\\n\\nInput: \")a\"\\nOutput: [\"a\"]\\n\\nInput: \")(\"\\nOutput: [\"\"]\\n\\nInput: \"v)k)()\"\\nOutput: [\"vk()\"]\\n\\nInput: \"())))()v(k\"\\nOutput: [\"()()vk\"]\\n\\n// There are many test cases... If you write a good function of delete count calculation, you don\\'t have to worry about those corner and special cases!\\n```\n```java\\npublic List<String> removeInvalidParentheses(String s) {\\n  List<String> result = new ArrayList<>();\\n  \\n  // calculate the number of \"(\" and \")\" we should delete\\n  int[] count = getDeleteCount(s);\\n  int leftCount = count[0];\\n  int rightCount = count[1];\\n  \\n  StringBuilder sb = new StringBuilder();\\n  backtrack(leftCount, rightCount, 0, 0, 0, sb, s, result, false, false);\\n  \\n  return result;\\n}\\n```\n```java\\n// Return how many \"(\" and \")\" should we delete.\\nprivate int[] getDeleteCount(String s) {\\n  int L1 = 0, R1 = 0;\\n  int L2 = 0, R2 = 0;\\n  int leftCount = 0, rightCount = 0;\\n  for (int i = 0; i < s.length(); ++i) {\\n    char ch1 = s.charAt(i); // from left\\n    char ch2 = s.charAt(s.length() - i - 1); // from right\\n    if (ch1 == \\'(\\') L1 += 1; // remember to skip other letters\\n    if (ch1 == \\')\\') R1 += 1;\\n    if (ch2 == \\'(\\') L2 += 1;\\n    if (ch2 == \\')\\') R2 += 1;\\n    rightCount = Math.max(rightCount, R1 - L1);\\n    leftCount = Math.max(leftCount, L2 - R2);\\n  }\\n  return new int[] { leftCount, rightCount };\\n}\\n```\n```java\\n/**\\n * leftCount:    # of \"(\" we should delete\\n * rightCount:   # of \")\" we should delete\\n * L:            # of \"(\" we have selected\\n * R:            # of \")\" we have selected\\n * pos:          current index in the string\\n * deletedLeft:  indicate whether we deleted \"(\" in the previous level\\n * deletedRight: indicate whether we deleted \")\" in the previous level\\n * (deletedLeft and deletedRight are for duplicate checking)\\n * \\n * It means that if you have deleted \"(\" at the previous level, \\n * you should not choose \"(\" at the current level because it incurs duplicate results.\\n */\\nprivate void backtrack(int leftCount, int rightCount, int L, int R, int pos, \\n                       StringBuilder sb, String s, List<String> result, \\n                       boolean deletedLeft, boolean deletedRight) {\\n  // base case\\n  if (L < R) { // L < R (not balanced)\\n    return;\\n  }\\n  if (pos == s.length()) { // time to add the result\\n    if (leftCount == 0 && rightCount == 0 && L == R) { // check if it is a valid string\\n      result.add(sb.toString());\\n    }\\n    return;\\n  }\\n  \\n  char ch = s.charAt(pos);\\n  if (ch == \\'(\\') {\\n    // select\\n    if (deletedLeft == false || s.charAt(pos - 1) != \\'(\\') { // check for duplicates\\n      sb.append(ch);\\n      backtrack(leftCount, rightCount, L + 1, R, pos + 1, sb, s, result, false, false);\\n      sb.deleteCharAt(sb.length() - 1);\\n    }\\n    // do not select it (delete)\\n    if (leftCount > 0) {\\n      backtrack(leftCount - 1, rightCount, L, R, pos + 1, sb, s, result, true, false);\\n    }\\n  }\\n  else if (ch == \\')\\') {\\n    // select\\n    if (deletedRight == false || s.charAt(pos - 1) != \\')\\') { // check for duplicates\\n      sb.append(ch);\\n      backtrack(leftCount, rightCount, L, R + 1, pos + 1, sb, s, result, false, false);\\n      sb.deleteCharAt(sb.length() - 1);\\n    }\\n    // do not select it (delete)\\n    if (rightCount > 0) {\\n      backtrack(leftCount, rightCount - 1, L, R, pos + 1, sb, s, result, false, true);\\n    }\\n  }\\n  else { // other letter\\n    sb.append(ch);\\n    backtrack(leftCount, rightCount, L, R, pos + 1, sb, s, result, false, false);\\n    sb.deleteCharAt(sb.length() - 1);\\n    return;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287813,
                "title": "javascript-bfs-and-dfs",
                "content": "BFS\\n```\\nvar removeInvalidParentheses = function(s) {\\n  if(!s.length) return [\\'\\'];\\n  let res = [];\\n  let queue = [s];\\n  let visited = [s];\\n  let found = false;\\n  \\n  while(queue.length) {\\n    const s = queue.shift();\\n    if(isValid(s)) {\\n      res.push(s);\\n      found = true;\\n    }\\n    if(found) continue;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n      const c = s[i];\\n      if(c != \\'(\\' && c != \\')\\') continue;\\n      const t = s.slice(0, i) + s.slice(i + 1);\\n      if(!visited.includes(t)) {\\n        queue.push(t);\\n        visited.push(t);\\n      }\\n    }\\n  }\\n  \\n  return res;\\n};\\n\\nfunction isValid(s) {\\n  let counter = 0;\\n  for(let i = 0; i < s.length; i++) {\\n    const c = s[i];\\n    if(c == \\'(\\') counter++;\\n    if(c == \\')\\' && counter-- == 0) return false;\\n  }\\n  return counter == 0;\\n}\\n```\\nDFS\\n```\\nvar removeInvalidParentheses = function(s) {\\n  if(!s.length) return [\\'\\'];\\n  let res = [];\\n  // pre-process, how many invalid brackets\\n  let l = 0;\\n  let r = 0;\\n  for(let i = 0; i < s.length; i++) {\\n    if(s[i] == \\'(\\') {\\n      l++;\\n    } else if(s[i] == \\')\\') {\\n      if(l > 0) {\\n        l--;\\n      } else {\\n        r++;\\n      }\\n    }\\n  }\\n  \\n  recurse(s, res, \\'\\', 0, l, r, 0);\\n  \\n  return res;\\n};\\n\\nfunction recurse(s, res, temp, pos, l, r, open) {\\n  if(l < 0 || r < 0 || open < 0) return;\\n  \\n  if(pos == s.length) {\\n    if(l == 0 && r == 0 && open == 0) {\\n      if(!res.includes(temp)) res.push(temp);\\n    }\\n    return;\\n  }\\n  \\n  if(s[pos] == \\'(\\') {\\n    recurse(s, res, temp + \\'(\\', pos + 1, l, r, open + 1);//use\\n    recurse(s, res, temp, pos + 1, l - 1, r, open);//not use\\n  } else if(s[pos] == \\')\\') {\\n    recurse(s, res, temp + \\')\\', pos + 1, l, r, open - 1);//use\\n    recurse(s, res, temp, pos + 1, l, r - 1, open);\\n  } else {\\n    recurse(s, res, temp + s[pos], pos + 1, l, r, open);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeInvalidParentheses = function(s) {\\n  if(!s.length) return [\\'\\'];\\n  let res = [];\\n  let queue = [s];\\n  let visited = [s];\\n  let found = false;\\n  \\n  while(queue.length) {\\n    const s = queue.shift();\\n    if(isValid(s)) {\\n      res.push(s);\\n      found = true;\\n    }\\n    if(found) continue;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n      const c = s[i];\\n      if(c != \\'(\\' && c != \\')\\') continue;\\n      const t = s.slice(0, i) + s.slice(i + 1);\\n      if(!visited.includes(t)) {\\n        queue.push(t);\\n        visited.push(t);\\n      }\\n    }\\n  }\\n  \\n  return res;\\n};\\n\\nfunction isValid(s) {\\n  let counter = 0;\\n  for(let i = 0; i < s.length; i++) {\\n    const c = s[i];\\n    if(c == \\'(\\') counter++;\\n    if(c == \\')\\' && counter-- == 0) return false;\\n  }\\n  return counter == 0;\\n}\\n```\n```\\nvar removeInvalidParentheses = function(s) {\\n  if(!s.length) return [\\'\\'];\\n  let res = [];\\n  // pre-process, how many invalid brackets\\n  let l = 0;\\n  let r = 0;\\n  for(let i = 0; i < s.length; i++) {\\n    if(s[i] == \\'(\\') {\\n      l++;\\n    } else if(s[i] == \\')\\') {\\n      if(l > 0) {\\n        l--;\\n      } else {\\n        r++;\\n      }\\n    }\\n  }\\n  \\n  recurse(s, res, \\'\\', 0, l, r, 0);\\n  \\n  return res;\\n};\\n\\nfunction recurse(s, res, temp, pos, l, r, open) {\\n  if(l < 0 || r < 0 || open < 0) return;\\n  \\n  if(pos == s.length) {\\n    if(l == 0 && r == 0 && open == 0) {\\n      if(!res.includes(temp)) res.push(temp);\\n    }\\n    return;\\n  }\\n  \\n  if(s[pos] == \\'(\\') {\\n    recurse(s, res, temp + \\'(\\', pos + 1, l, r, open + 1);//use\\n    recurse(s, res, temp, pos + 1, l - 1, r, open);//not use\\n  } else if(s[pos] == \\')\\') {\\n    recurse(s, res, temp + \\')\\', pos + 1, l, r, open - 1);//use\\n    recurse(s, res, temp, pos + 1, l, r - 1, open);\\n  } else {\\n    recurse(s, res, temp + s[pos], pos + 1, l, r, open);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75084,
                "title": "clean-java-solution-bfs-optimization-40ms",
                "content": "Solution based earlier posts on this forum.\\n\\n     public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s == null || s.length() == 0) {\\n        \\tans.add(\"\");\\n        \\treturn ans;\\n        }\\n        \\n        //Remove proceeding \")\".\\n        int i = 0;\\n        while (i < s.length() && s.charAt(i) != '(') i++;\\n        s = s.substring(0, i).replace(\")\", \"\") + ((i == s.length())?\"\" : s.substring(i));\\n        \\n        //Remove trailing \"(\"\\n        int j = s.length() - 1;\\n        while (j >= 0 && s.charAt(j) != ')') j--;\\n        s = s.substring(0, j+1) + ((j == s.length()-1)? \"\" : s.substring(j+1).replace(\"(\", \"\"));\\n        \\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.offer(s);\\n        visited.add(s);\\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n        \\ts = q.poll();\\n        \\tif (isValid(s)) {\\n        \\t\\tans.add(s);\\n        \\t\\tfound = true;\\n        \\t}\\n        \\tif (found) continue;\\n        \\tfor (int k = 0; k < s.length(); k++) {\\n        \\t\\tif (s.charAt(k) != '(' && s.charAt(k) != ')') \\n        \\t\\t\\tcontinue;\\n        \\t\\t//Avoid dup.\\n        \\t\\tif (k > 0 && s.charAt(k) == s.charAt(k-1)) \\n        \\t\\t\\tcontinue;\\n        \\t\\tString t = s.substring(0,k) + s.substring(k+1);\\n        \\t\\tif (!visited.contains(t)) {\\n        \\t\\t\\tq.offer(t);\\n        \\t\\t\\tvisited.add(t);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n\\n\\tprivate boolean isValid(String s) {\\n\\t\\tint count = 0;\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\tif (c == '(') \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse if (c == ')') {\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\tif (count < 0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count == 0;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "Solution based earlier posts on this forum.\\n\\n     public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s == null || s.length() == 0) {\\n        \\tans.add(\"\");\\n        \\treturn ans;\\n        }\\n        \\n        //Remove proceeding \")\".\\n        int i = 0;\\n        while (i < s.length() && s.charAt(i) != '(') i++;\\n        s = s.substring(0, i).replace(\")\", \"\") + ((i == s.length())?\"\" : s.substring(i));\\n        \\n        //Remove trailing \"(\"\\n        int j = s.length() - 1;\\n        while (j >= 0 && s.charAt(j) != ')') j--;\\n        s = s.substring(0, j+1) + ((j == s.length()-1)? \"\" : s.substring(j+1).replace(\"(\", \"\"));\\n        \\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.offer(s);\\n        visited.add(s);\\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n        \\ts = q.poll();\\n        \\tif (isValid(s)) {\\n        \\t\\tans.add(s);\\n        \\t\\tfound = true;\\n        \\t}\\n        \\tif (found) continue;\\n        \\tfor (int k = 0; k < s.length(); k++) {\\n        \\t\\tif (s.charAt(k) != '(' && s.charAt(k) != ')') \\n        \\t\\t\\tcontinue;\\n        \\t\\t//Avoid dup.\\n        \\t\\tif (k > 0 && s.charAt(k) == s.charAt(k-1)) \\n        \\t\\t\\tcontinue;\\n        \\t\\tString t = s.substring(0,k) + s.substring(k+1);\\n        \\t\\tif (!visited.contains(t)) {\\n        \\t\\t\\tq.offer(t);\\n        \\t\\t\\tvisited.add(t);\\n        \\t\\t}\\n        \\t}\\n        }\\n        return ans;\\n    }\\n\\n\\tprivate boolean isValid(String s) {\\n\\t\\tint count = 0;\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\tif (c == '(') \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse if (c == ')') {\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\tif (count < 0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count == 0;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 75096,
                "title": "0ms-c-solution-generating-only-longest-valid-strings-not-using-hash-map",
                "content": "A counter is use the indicate the difference between the number of \\u2018(\\u2019 and \\u2018)\\u2019. There are several observations to decrease the running time:\\n\\nIf we remove \\u2018(\\u2019 at index \\u201ci\\u201d, then we should also remove the following consecutive \\u2018(\\u2019 to avoid duplicate solution.\\n\\nThe same principle works for \\u2018)\\u2019.\\n\\nTo get the longest valid string, we should try not delete a certain character first.\\n\\nDuring the DFS, if we observe that the string to be obtained without removing any more characters is shorter than the max length of the solution, we should stop searching.\\n\\nWe can use \\u2018)\\u2019 only when the counter is larger than 0.\\n\\nWe can use \\u2018(\\u2019 only when the remaining \\u2018)\\u2019 is more than the counter.\\n\\nWe can ignore \\u2018)\\u2019 only when the the remaining \\u2018)\\u2019 is not less than the counter.\\n\\n    class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            maxAnsLen = 0;\\n            strLen = s.size();\\n            cnt = 0;\\n            str = s;\\n            tmp = \"\";\\n            \\n            numAntiP = new int [strLen + 1];\\n            jump = new int [strLen + 1];\\n            numAntiP[strLen] = 0;\\n            jump[strLen] = strLen;\\n            str.push_back('@');\\n            for (int i = strLen - 1; i >= 0; i--) {\\n                numAntiP[i] = numAntiP[i + 1] + (str[i] == ')');\\n                if (str[i] == ')')\\n                    jump[i] = (str[i + 1] == ')') ? jump[i + 1] : (i + 1);\\n                if (str[i] == '(')\\n                    jump[i] = (str[i + 1] == '(') ? jump[i + 1] : (i + 1);\\n            }\\n    \\n            dfs(0);\\n            return ans;\\n        }\\n    private:\\n        int cnt, *numAntiP, *jump, strLen, maxAnsLen;\\n        vector<string> ans;\\n        string str, tmp;\\n        void dfs(int i) {\\n            if (strLen - i + tmp.size() < maxAnsLen)\\n                return;\\n            else if (i == strLen) {\\n                maxAnsLen = tmp.size();\\n                ans.push_back(tmp);\\n            }\\n            else if (str[i] == ')') {\\n                if (cnt > 0) {\\n                    cnt--;\\n                    tmp.push_back(str[i]);\\n                    dfs(i + 1);\\n                    tmp.pop_back();\\n                    cnt++;\\n                }\\n                if (numAntiP[i + 1] >= cnt)\\n                    dfs(jump[i]); \\n            }\\n            else if (str[i] == '(') {\\n                if (numAntiP[i + 1] > cnt) {\\n                    cnt++;\\n                    tmp.push_back(str[i]);\\n                    dfs(i + 1);\\n                    tmp.pop_back();\\n                    cnt--;\\n                }\\n                dfs(jump[i]); \\n            }\\n            else {\\n                tmp.push_back(str[i]);\\n                dfs(i + 1);\\n                tmp.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> removeInvalidParentheses(string s) {\\n            maxAnsLen = 0;\\n            strLen = s.size();\\n            cnt = 0;\\n            str = s;\\n            tmp = \"\";\\n            \\n            numAntiP = new int [strLen + 1];\\n            jump = new int [strLen + 1];\\n            numAntiP[strLen] = 0;\\n            jump[strLen] = strLen;\\n            str.push_back('@');\\n            for (int i = strLen - 1; i >= 0; i--) {\\n                numAntiP[i] = numAntiP[i + 1] + (str[i] == ')');\\n                if (str[i] == ')')\\n                    jump[i] = (str[i + 1] == ')') ? jump[i + 1] : (i + 1);\\n                if (str[i] == '(')\\n                    jump[i] = (str[i + 1] == '(') ? jump[i + 1] : (i + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3238714,
                "title": "301-time-90-95-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. getLeftAndRightCounts(s: str) -> tuple: This function takes a string as input and returns a tuple containing two integers. The two integers are the counts of the left and right parentheses that need to be removed to make the given string valid. The function scans the string from left to right and counts the number of left and right parentheses that need to be removed. If a right parenthesis is encountered before a left parenthesis, it is counted as a redundant right parenthesis that needs to be removed.\\n\\n2. isValid(s: str) -> bool: This function takes a string as input and returns True if the string is a valid string, i.e., it has balanced parentheses. The function scans the string from left to right and maintains a count of the number of left and right parentheses encountered. If the count of right parentheses becomes greater than the count of left parentheses at any point, the string is invalid and the function returns False.\\n\\n3. dfs(s: str, start: int, l: int, r: int) -> None: This function takes a string, a start index, and two integer counts as input. The start index is used to avoid generating duplicate combinations. The two integer counts are the counts of the left and right parentheses that need to be removed to make the given string valid. The function generates all the possible combinations of valid strings by removing invalid parentheses. It starts by checking if the given string is valid. If it is, the string is added to the answer list. If not, it loops through the string from the start index and removes a left or right parenthesis if it is invalid. If a right parenthesis is removed, the count of right parentheses is decremented, and if a left parenthesis is removed, the count of left parentheses is decremented. The function then calls itself recursively with the updated string, start index, and counts. The loop continues until all the possible combinations have been generated.\\n\\nThe main function removeInvalidParentheses(self, s: str) -> List[str] uses the above functions to solve the problem. It first calls getLeftAndRightCounts(s) to get the counts of the left and right parentheses that need to be removed. It then calls dfs(s, 0, l, r) to generate all the possible combinations of valid strings by removing invalid parentheses. The valid strings are added to a list, which is returned at the end.\\n\\n# Complexity\\n- Time complexity:\\n90.95%\\n\\n- Space complexity:\\n81.81%\\n\\n# Code\\n```\\nclass Solution:\\n  def removeInvalidParentheses(self, s: str) -> List[str]:\\n    def getLeftAndRightCounts(s: str) -> tuple:\\n      l = 0\\n      r = 0\\n\\n      for c in s:\\n        if c == \\'(\\':\\n          l += 1\\n        elif c == \\')\\':\\n          if l == 0:\\n            r += 1\\n          else:\\n            l -= 1\\n\\n      return l, r\\n\\n    def isValid(s: str):\\n      count = 0  # Number of \\'(\\' - # Of \\')\\'\\n      for c in s:\\n        if c == \\'(\\':\\n          count += 1\\n        elif c == \\')\\':\\n          count -= 1\\n        if count < 0:\\n          return False\\n      return True  # Count == 0\\n\\n    ans = []\\n\\n    def dfs(s: str, start: int, l: int, r: int) -> None:\\n      if l == 0 and r == 0 and isValid(s):\\n        ans.append(s)\\n        return\\n\\n      for i in range(start, len(s)):\\n        if i > start and s[i] == s[i - 1]:\\n          continue\\n        if r > 0 and s[i] == \\')\\':  # Delete s[i]\\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\\n        elif l > 0 and s[i] == \\'(\\':  # Delete s[i]\\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\\n\\n    l, r = getLeftAndRightCounts(s)\\n    dfs(s, 0, l, r)\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def removeInvalidParentheses(self, s: str) -> List[str]:\\n    def getLeftAndRightCounts(s: str) -> tuple:\\n      l = 0\\n      r = 0\\n\\n      for c in s:\\n        if c == \\'(\\':\\n          l += 1\\n        elif c == \\')\\':\\n          if l == 0:\\n            r += 1\\n          else:\\n            l -= 1\\n\\n      return l, r\\n\\n    def isValid(s: str):\\n      count = 0  # Number of \\'(\\' - # Of \\')\\'\\n      for c in s:\\n        if c == \\'(\\':\\n          count += 1\\n        elif c == \\')\\':\\n          count -= 1\\n        if count < 0:\\n          return False\\n      return True  # Count == 0\\n\\n    ans = []\\n\\n    def dfs(s: str, start: int, l: int, r: int) -> None:\\n      if l == 0 and r == 0 and isValid(s):\\n        ans.append(s)\\n        return\\n\\n      for i in range(start, len(s)):\\n        if i > start and s[i] == s[i - 1]:\\n          continue\\n        if r > 0 and s[i] == \\')\\':  # Delete s[i]\\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\\n        elif l > 0 and s[i] == \\'(\\':  # Delete s[i]\\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\\n\\n    l, r = getLeftAndRightCounts(s)\\n    dfs(s, 0, l, r)\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816221,
                "title": "c-2-optimized-versions-simple-and-clean-solution-backtracking-stack",
                "content": "**1.  Version 1**\\n\\n```\\nunordered_set<string> st,vis;\\n    \\n    int countmin(string &s)\\n    {\\n        stack<int> st;\\n        \\n        for(char ch:s)\\n        {\\n            if(ch==\\'(\\')\\n                st.push(ch);\\n            else if(ch==\\')\\')\\n            {\\n                if(!st.empty() && st.top()==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(ch);\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n    \\n    void removemin(string s,int c)\\n    {\\n        if(vis.find(s)!=vis.end())\\n            return;\\n            \\n        vis.insert(s);\\n        \\n        if(c==0)\\n        {\\n            st.insert(s);\\n            return;\\n        }\\n                \\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\')\\')\\n                removemin(s.substr(0,i)+s.substr(i+1),c-1);\\n        }       \\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        vector<string> ans;\\n        int c=countmin(s);\\n        \\n        removemin(s,c);\\n        \\n        for(string str:st)\\n        {\\n            if(!countmin(str))\\n                ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**2. Version 2**\\n \\n ```\\n int l,r;\\n    unordered_set<string> st,vis;\\n    \\n    void countmin(string &s)\\n    {\\n        stack<int> st;\\n        \\n        for(char ch:s)\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                l++;\\n                st.push(ch);\\n            }\\n            else if(ch==\\')\\')\\n            {\\n                if(!st.empty() && st.top()==\\'(\\')\\n                {\\n                    st.pop();\\n                    l--;\\n                }\\n                else\\n                {\\n                    st.push(ch);\\n                    r++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void removemin(string s,int l,int r)\\n    {\\n        if(vis.find(s)==vis.end())\\n            vis.insert(s);\\n        else \\n            return;\\n        \\n        if(l==0 && r==0)\\n        {\\n            st.insert(s);\\n            return;\\n        }\\n        \\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                removemin(s.substr(0,i)+s.substr(i+1),l-1,r);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                removemin(s.substr(0,i)+s.substr(i+1),l,r-1);\\n            }\\n        }     \\n    }\\n    \\n    bool isValid(string s)\\n    {\\n        int c=0;\\n        \\n        for(char ch:s)\\n        {\\n            if(ch==\\'(\\')\\n                c++;\\n            else if(ch==\\')\\')\\n            {\\n                if(c>0)\\n                    c--;\\n                else return 0;\\n            }\\n        }\\n        return c==0;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        l=0;\\n        r=0;\\n        vector<string> ans;\\n        countmin(s);\\n        \\n        removemin(s,l,r);\\n        \\n        for(string str:st)\\n        {\\n            if(isValid(str))\\n                ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nDo share suggestions & upvote if you like !! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nunordered_set<string> st,vis;\\n    \\n    int countmin(string &s)\\n    {\\n        stack<int> st;\\n        \\n        for(char ch:s)\\n        {\\n            if(ch==\\'(\\')\\n                st.push(ch);\\n            else if(ch==\\')\\')\\n            {\\n                if(!st.empty() && st.top()==\\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(ch);\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n    \\n    void removemin(string s,int c)\\n    {\\n        if(vis.find(s)!=vis.end())\\n            return;\\n            \\n        vis.insert(s);\\n        \\n        if(c==0)\\n        {\\n            st.insert(s);\\n            return;\\n        }\\n                \\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\')\\')\\n                removemin(s.substr(0,i)+s.substr(i+1),c-1);\\n        }       \\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        vector<string> ans;\\n        int c=countmin(s);\\n        \\n        removemin(s,c);\\n        \\n        for(string str:st)\\n        {\\n            if(!countmin(str))\\n                ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n int l,r;\\n    unordered_set<string> st,vis;\\n    \\n    void countmin(string &s)\\n    {\\n        stack<int> st;\\n        \\n        for(char ch:s)\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                l++;\\n                st.push(ch);\\n            }\\n            else if(ch==\\')\\')\\n            {\\n                if(!st.empty() && st.top()==\\'(\\')\\n                {\\n                    st.pop();\\n                    l--;\\n                }\\n                else\\n                {\\n                    st.push(ch);\\n                    r++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void removemin(string s,int l,int r)\\n    {\\n        if(vis.find(s)==vis.end())\\n            vis.insert(s);\\n        else \\n            return;\\n        \\n        if(l==0 && r==0)\\n        {\\n            st.insert(s);\\n            return;\\n        }\\n        \\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                removemin(s.substr(0,i)+s.substr(i+1),l-1,r);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                removemin(s.substr(0,i)+s.substr(i+1),l,r-1);\\n            }\\n        }     \\n    }\\n    \\n    bool isValid(string s)\\n    {\\n        int c=0;\\n        \\n        for(char ch:s)\\n        {\\n            if(ch==\\'(\\')\\n                c++;\\n            else if(ch==\\')\\')\\n            {\\n                if(c>0)\\n                    c--;\\n                else return 0;\\n            }\\n        }\\n        return c==0;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        l=0;\\n        r=0;\\n        vector<string> ans;\\n        countmin(s);\\n        \\n        removemin(s,l,r);\\n        \\n        for(string str:st)\\n        {\\n            if(isValid(str))\\n                ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524742,
                "title": "easy-to-understand-recursive-java-solution-with-line-by-line-explanation",
                "content": "**Optional but Recommended:** Go through the following link and try to understand the approach used in backtracking for subsets and permutation problem\\nhttps://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning) \\n\\n**Key Idea:**\\n* For each character in string, it will either be present in validString or not present in valid String and since there is no way of knowing if we should add it to the validString or not, we will use recursion to check for each state and will check in the end if it passes or not.\\n* So basically, the most easy and obvious solution is to form all the strings by either choosing a character at a time or not choosing it. \\n\\t* This will result in Set of answers many of which might not be valid or might not be using minimum number of removal to form valid strings.\\n\\t* Nevertheless, we can post process the set of answers to filter the validStrings and we can then select the strings with largest size as part of our final answer.\\n\\nThe code for that would look like as follows:\\n```\\nclass Solution {\\n    Set<String> list = new HashSet<>();\\n    int remCount = Integer.MAX_VALUE;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        removeInvalidParentheses(s,0,new StringBuilder());\\n        \\n       HashMap<Integer, Set<String>> map = new HashMap<>();\\n        int maxSize = 0;\\n        for(String candidate: list) {\\n            if(isValid(candidate) && candidate.length() >= maxSize) {\\n                maxSize = candidate.length();\\n                map.putIfAbsent(maxSize, new HashSet<>());\\n                map.get(maxSize).add(candidate);\\n            }\\n        }\\n        \\n        return new ArrayList<>(map.get(maxSize));\\n    }\\n    \\n    void removeInvalidParentheses(String s, int index, StringBuilder sb) {\\n        if(index == s.length()) {\\n\\t\\t    // if index reached the end of string, add the valid string candidate formed.\\n            list.add(sb.toString());\\n        } else {\\n            \\n            // Choice 1: Add this character in valid string candidate\\n            sb.append(s.charAt(index));\\n            removeInvalidParentheses(s,index+1,sb);\\n            sb.setLength(sb.length()-1);\\n            \\n            //Choice 2: Dont Add this character in valid string candidate\\n             removeInvalidParentheses(s,index+1,sb);\\n        }\\n    }\\n    \\n    boolean isValid(String s) {\\n        int open = 0, close = 0;\\n        \\n        for(char c: s.toCharArray()) {\\n            if(c == \\'(\\') open++;\\n            \\n            if(c == \\')\\') {\\n                if(open > close) close++;\\n                else return false;\\n            }\\n        }\\n        \\n        return open == close;\\n    }\\n}\\n```\\n\\nThough this solution will pass most of the test cases, at the time of writing (123/127) you also know that we can optimize this solution further.\\n\\n* First thing we can do is dont recurse for solution which we know would fail such as string beginning with close parantheses - `)`.\\n* For this, we can use the idea from` isValid` method that we wrote and check the count of open and close bracket for checking the presence of valid string. Logic is simple as described below:\\n  * We keep track of number of `open` and `close` parantheses in a variable. \\n  * If we found a `)` parantheses then it will be part of the valid string if and only if `open > close` else it will be invalid and we dont add it.\\n  * Further in our previous solution we have used Map to find the strings with least number of removal, we can handle it on the go by having a `count` variable which contains the count of invalidIndexes and we add a validStringCandidate to the list if and only if its removal count for that string is less than the global minima.\\n\\nThe solution would look like as follows:\\n\\n```\\nclass Solution {\\n    Set<String> list = new HashSet<>();\\n    int remCount = Integer.MAX_VALUE;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        removeInvalidParentheses(s,0,new StringBuilder(), 0, 0, 0);\\n        return new ArrayList<>(list);\\n    }\\n    \\n    void removeInvalidParentheses(String s, int index, StringBuilder sb, int open, int close, int count) {\\n        \\n        if(index == s.length() && open == close) {\\n            if(count <= remCount) {\\n                if(count<remCount) list = new HashSet<>();\\n                list.add(new String(sb.toString()));\\n                remCount = count;\\n            } \\n        } else {\\n            if(index >= s.length()) return;\\n            char c = s.charAt(index);\\n            if(c != \\'(\\' && c != \\')\\') {\\n                // Char. This will always be part of valid string. Add it.\\n                sb.append(c);\\n                removeInvalidParentheses(s,index+1,sb, open, close, count);\\n                sb.setLength(sb.length()-1);\\n            } else {\\n                // Choice1: Dont choose this char\\n                removeInvalidParentheses(s,index+1,sb, open, close, count+1);\\n                \\n                //Choice2: Choose this char (this is without optimization):\\n                if(c == \\'(\\') {\\n                    sb.append(c);\\n                    removeInvalidParentheses(s,index+1,sb, open+1, close, count);\\n                    sb.setLength(sb.length()-1);\\n                } else if(c == \\')\\') {\\n                    if(open > close) {\\n                        sb.append(c);\\n                        removeInvalidParentheses(s,index+1,sb, open, close+1, count);\\n                        sb.setLength(sb.length()-1);\\n                    } \\n                }\\n            }\\n        }\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Set<String> list = new HashSet<>();\\n    int remCount = Integer.MAX_VALUE;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        removeInvalidParentheses(s,0,new StringBuilder());\\n        \\n       HashMap<Integer, Set<String>> map = new HashMap<>();\\n        int maxSize = 0;\\n        for(String candidate: list) {\\n            if(isValid(candidate) && candidate.length() >= maxSize) {\\n                maxSize = candidate.length();\\n                map.putIfAbsent(maxSize, new HashSet<>());\\n                map.get(maxSize).add(candidate);\\n            }\\n        }\\n        \\n        return new ArrayList<>(map.get(maxSize));\\n    }\\n    \\n    void removeInvalidParentheses(String s, int index, StringBuilder sb) {\\n        if(index == s.length()) {\\n\\t\\t    // if index reached the end of string, add the valid string candidate formed.\\n            list.add(sb.toString());\\n        } else {\\n            \\n            // Choice 1: Add this character in valid string candidate\\n            sb.append(s.charAt(index));\\n            removeInvalidParentheses(s,index+1,sb);\\n            sb.setLength(sb.length()-1);\\n            \\n            //Choice 2: Dont Add this character in valid string candidate\\n             removeInvalidParentheses(s,index+1,sb);\\n        }\\n    }\\n    \\n    boolean isValid(String s) {\\n        int open = 0, close = 0;\\n        \\n        for(char c: s.toCharArray()) {\\n            if(c == \\'(\\') open++;\\n            \\n            if(c == \\')\\') {\\n                if(open > close) close++;\\n                else return false;\\n            }\\n        }\\n        \\n        return open == close;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Set<String> list = new HashSet<>();\\n    int remCount = Integer.MAX_VALUE;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        removeInvalidParentheses(s,0,new StringBuilder(), 0, 0, 0);\\n        return new ArrayList<>(list);\\n    }\\n    \\n    void removeInvalidParentheses(String s, int index, StringBuilder sb, int open, int close, int count) {\\n        \\n        if(index == s.length() && open == close) {\\n            if(count <= remCount) {\\n                if(count<remCount) list = new HashSet<>();\\n                list.add(new String(sb.toString()));\\n                remCount = count;\\n            } \\n        } else {\\n            if(index >= s.length()) return;\\n            char c = s.charAt(index);\\n            if(c != \\'(\\' && c != \\')\\') {\\n                // Char. This will always be part of valid string. Add it.\\n                sb.append(c);\\n                removeInvalidParentheses(s,index+1,sb, open, close, count);\\n                sb.setLength(sb.length()-1);\\n            } else {\\n                // Choice1: Dont choose this char\\n                removeInvalidParentheses(s,index+1,sb, open, close, count+1);\\n                \\n                //Choice2: Choose this char (this is without optimization):\\n                if(c == \\'(\\') {\\n                    sb.append(c);\\n                    removeInvalidParentheses(s,index+1,sb, open+1, close, count);\\n                    sb.setLength(sb.length()-1);\\n                } else if(c == \\')\\') {\\n                    if(open > close) {\\n                        sb.append(c);\\n                        removeInvalidParentheses(s,index+1,sb, open, close+1, count);\\n                        sb.setLength(sb.length()-1);\\n                    } \\n                }\\n            }\\n        }\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397395,
                "title": "java-confused-still-line-by-line-explanations-this-might-help",
                "content": "```\\nclass Solution {\\n    \\n\\t// need to find unique results hence hashset of strings\\n    Set<String> result = new HashSet<>();\\n\\t\\n    char open = \\'(\\';\\n    char close = \\')\\';\\n\\t\\n    public List<String> removeInvalidParentheses(String s) {\\n        \\n\\t\\t// initial open/close braces to remove for empty string\\n        int openRem = 0;\\n        int closeRem = 0;\\n        \\n        for(char ch:s.toCharArray())\\n        {\\n\\t\\t// if open always increment openRem - there is always a possibility of finding a close bracket down the line\\n            if(ch == open)\\n            {\\n                openRem++;\\n            } else if(ch == close)\\n            {\\n\\t\\t\\t// if close (2 possibilies) \\n                if(openRem == 0)\\n                {\\n\\t\\t\\t\\t// 1 -> no open bracket was encountered - increment close count (since openRem = 0)\\n                    closeRem++;\\n                } \\n                if(openRem > 0)\\n                {\\n\\t\\t\\t\\t// 2 -> if there was a matching open bracket i.e openRem > 0 use up that open bracket by decrementing open count\\n                    openRem--;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// recursion start - read the method signature to know the params\\n        findValidExpr(s,0,0,0,openRem,closeRem,new StringBuilder());\\n        return new ArrayList<>(result);\\n    }\\n    \\n\\t// open/close count is the no of open close brackets in the stringBuilder answer at any point in time.\\n    public void findValidExpr(String s,int index, int openCount, int closeCount, int openRem,int closeRem,StringBuilder sb)\\n    {\\n\\t// if reached the end of s\\n        if(index == s.length())\\n        {\\n\\t\\t\\n\\t\\t// if both remaining brackets are used up, (normally there exists a unmatched (unused) brackets for invalid expressions - fact)\\n            if(openRem == 0 && closeRem == 0)\\n            {\\n                result.add(sb.toString());\\n            }\\n        } else{\\n            char ch = s.charAt(index);\\n            int len = sb.length();\\n\\t\\t\\t\\n\\t\\t\\t// two ways to proceed forward \\n\\t\\t\\t\\n\\t\\t\\t// 1 -> you can elimiate the character and proceed recursion( where in the character we remove is the extra unmatched invalid bracket) we ensure that by verifiying with the openRem & closeRem i.e target unmatched brackets to remove\\n            if((ch == open && openRem >0) || (ch == close && closeRem >0))\\n            {\\n\\t\\t\\t// no change in open/close count since we are eliminating this character, only openRem/closeRem count changes (1 elimination done)\\n                this.findValidExpr(s,index+1,openCount,closeCount,ch == open?openRem-1:openRem,ch == close?closeRem-1:closeRem,sb);\\n            }\\n            \\n\\t\\t\\t// 2 -> you can either consider the character in our final answer\\n            sb.append(ch);\\n            \\n\\t\\t\\t// if its an alphabet no effect on balancing hence recurse again\\n            if(ch != open && ch != close)\\n            {\\n                this.findValidExpr(s,index+1,openCount,closeCount,openRem,closeRem,sb);\\n            } \\n\\t\\t\\t// if open bracket always consider\\n\\t\\t\\telse if(ch == open)\\n            {\\n                this.findValidExpr(s,index+1,openCount+1,closeCount,openRem,closeRem,sb);\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// different scenario for close bracket consider only if count of close bracket < open bracket since {}} this second close bracket makes the whole thing invalid, no point in considering it and recursing further, only extra left bracket makes sense eg {{}**processed this here** } <- we have the possibility to find this to finally match that extra { we found earlier\\n\\t\\t\\telse if(closeCount < openCount)\\n            {\\n                this.findValidExpr(s,index+1,openCount,closeCount+1,openRem,closeRem,sb);\\n            }\\n            // important for backtracking delete the consideration of this character while we go down the stack call for new possibility considerations\\n            sb.deleteCharAt(len);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\t// need to find unique results hence hashset of strings\\n    Set<String> result = new HashSet<>();\\n\\t\\n    char open = \\'(\\';\\n    char close = \\')\\';\\n\\t\\n    public List<String> removeInvalidParentheses(String s) {\\n        \\n\\t\\t// initial open/close braces to remove for empty string\\n        int openRem = 0;\\n        int closeRem = 0;\\n        \\n        for(char ch:s.toCharArray())\\n        {\\n\\t\\t// if open always increment openRem - there is always a possibility of finding a close bracket down the line\\n            if(ch == open)\\n            {\\n                openRem++;\\n            } else if(ch == close)\\n            {\\n\\t\\t\\t// if close (2 possibilies) \\n                if(openRem == 0)\\n                {\\n\\t\\t\\t\\t// 1 -> no open bracket was encountered - increment close count (since openRem = 0)\\n                    closeRem++;\\n                } \\n                if(openRem > 0)\\n                {\\n\\t\\t\\t\\t// 2 -> if there was a matching open bracket i.e openRem > 0 use up that open bracket by decrementing open count\\n                    openRem--;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// recursion start - read the method signature to know the params\\n        findValidExpr(s,0,0,0,openRem,closeRem,new StringBuilder());\\n        return new ArrayList<>(result);\\n    }\\n    \\n\\t// open/close count is the no of open close brackets in the stringBuilder answer at any point in time.\\n    public void findValidExpr(String s,int index, int openCount, int closeCount, int openRem,int closeRem,StringBuilder sb)\\n    {\\n\\t// if reached the end of s\\n        if(index == s.length())\\n        {\\n\\t\\t\\n\\t\\t// if both remaining brackets are used up, (normally there exists a unmatched (unused) brackets for invalid expressions - fact)\\n            if(openRem == 0 && closeRem == 0)\\n            {\\n                result.add(sb.toString());\\n            }\\n        } else{\\n            char ch = s.charAt(index);\\n            int len = sb.length();\\n\\t\\t\\t\\n\\t\\t\\t// two ways to proceed forward \\n\\t\\t\\t\\n\\t\\t\\t// 1 -> you can elimiate the character and proceed recursion( where in the character we remove is the extra unmatched invalid bracket) we ensure that by verifiying with the openRem & closeRem i.e target unmatched brackets to remove\\n            if((ch == open && openRem >0) || (ch == close && closeRem >0))\\n            {\\n\\t\\t\\t// no change in open/close count since we are eliminating this character, only openRem/closeRem count changes (1 elimination done)\\n                this.findValidExpr(s,index+1,openCount,closeCount,ch == open?openRem-1:openRem,ch == close?closeRem-1:closeRem,sb);\\n            }\\n            \\n\\t\\t\\t// 2 -> you can either consider the character in our final answer\\n            sb.append(ch);\\n            \\n\\t\\t\\t// if its an alphabet no effect on balancing hence recurse again\\n            if(ch != open && ch != close)\\n            {\\n                this.findValidExpr(s,index+1,openCount,closeCount,openRem,closeRem,sb);\\n            } \\n\\t\\t\\t// if open bracket always consider\\n\\t\\t\\telse if(ch == open)\\n            {\\n                this.findValidExpr(s,index+1,openCount+1,closeCount,openRem,closeRem,sb);\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// different scenario for close bracket consider only if count of close bracket < open bracket since {}} this second close bracket makes the whole thing invalid, no point in considering it and recursing further, only extra left bracket makes sense eg {{}**processed this here** } <- we have the possibility to find this to finally match that extra { we found earlier\\n\\t\\t\\telse if(closeCount < openCount)\\n            {\\n                this.findValidExpr(s,index+1,openCount,closeCount+1,openRem,closeRem,sb);\\n            }\\n            // important for backtracking delete the consideration of this character while we go down the stack call for new possibility considerations\\n            sb.deleteCharAt(len);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930177,
                "title": "java-short-and-crisp-beats-99-9-with-detailed-explanation",
                "content": "There are only two cases for Invalid Parentheses.\\n**Case-1:** if total number of \\')\\' is greater than total number of \\'(\\'\\n1.At any instant,  number of \\'(\\' should be >= number of \\')\\'.\\n2. So keep a counter variable and  while parsing if \\'(\\' counter++, else if \\')\\' counter--.\\n3. Once counter is <0, then we will get to know there is an imbalance and we need to remove a \\')\\'\\n4. We can remove any of the \\')\\' from left to current index to make expression balance. But if there are consecutive \\')\\' [ like \\')))\\' ], then remove only one \\')\\' beacuse we dont want to have duplicate expressions.\\n5. Thats all, now continue recursion til end of the string.\\n**Case-2:** If total number of \\'(\\' is greater than total number of  \\')\\'.\\nReplace \\'(\\' with \\')\\' and \\')\\' with \\'(\\' and apply same procedure as Case-1  and reverse the string.\\n\\n**Example.1:**\\nInput: \"()())()\"\\nOutput: [\"()()()\", \"(())()\"]\\n\\nString s=\"()())()\",left=0,right=0. \\n1.parse till right<s.length() and   if \\'(\\' counter++, else if \\')\\' counter--\\nright=0, \\'(\\'  counter=1\\nright=1, \\')\\'  couter=0\\nright=2, \\'(\\' counter=1\\nright=3, \\')\\' counter=0\\nright=4, \\')\\' counter=-1. Here counter<0, so there is an imbalance . \\nWe can remove any of the \\')\\' to make it balance expression.\\n\\n2.left=0, right=4, now parse till left<=right\\nleft=0, \\'(\\' so continue\\nleft=1, \\')\\' after removing \\')\\' at left=1, \\n...........s=\"(())()\" now again apply recursion and check for imbalance for rest of the string. \\nleft=2, \\'(\\' so continue\\nleft=3 \\')\\' after removing \\')\\' at left=3\\n.........s=\"()()()\" so now again apply recursion and check for imbalance for rest of the string. \\nleft=4, \\')\\'  if we remove  \\')\\' at left=4 we will get duplicate string  s=\"()()()\". So to prevent this make sure if there are consecutive \\')\\', removing any one of the \\')\\' [or the first \\')\\' ] is enough.\\n\\nNow s.substring(left,1+right) is balanced, repest this process for rest of the string .\\n\\n**Example 2:** \\nif s=\"(()\", here as total number of \\'(\\' is greater than total number of  \\')\\'. \\nReplace \\'(\\' with \\')\\' and \\')\\' with \\'(\\' and apply same procedure as example-1 and reverse the string .\\nstring will become s=\"))(\" ,res=\")(\" apply reverse of s =\"()\"**\\n\\n```\\nclass Solution {\\n    private  List<String> res;\\n    public List<String> removeInvalidParentheses(String s) {\\n        res=new ArrayList();\\n        recur(s,0,0,new char[]{\\'(\\',\\')\\'});\\n            return res;\\n    }\\n    private void recur(String s,int left,int right,char[] paranthesis){\\n        int len=s.length();int val=0;\\n        for(;right<len;right++){\\n            char ch=s.charAt(right);\\n            if(ch==paranthesis[0]) val++;\\n            else if(ch==paranthesis[1]) val--;\\n            if(val<0) break;\\n        }\\n        if(val<0){\\n            for(;left<=right;left++){\\n                char ch=s.charAt(left);\\n                if(ch!=paranthesis[1]) continue;\\n                if(left>1 && s.charAt(left)==s.charAt(left-1)) continue;\\n                String temp=s.substring(0,left)+s.substring(left+1);\\n                recur(temp,left,right,paranthesis);\\n            }\\n        }\\n        else if(val>0){\\n            recur(new StringBuilder(s).reverse().toString(),0,0,new char[]{\\')\\',\\'(\\'});\\n        }\\n        else res.add(paranthesis[0]==\\'(\\'?s:new StringBuilder(s).reverse().toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private  List<String> res;\\n    public List<String> removeInvalidParentheses(String s) {\\n        res=new ArrayList();\\n        recur(s,0,0,new char[]{\\'(\\',\\')\\'});\\n            return res;\\n    }\\n    private void recur(String s,int left,int right,char[] paranthesis){\\n        int len=s.length();int val=0;\\n        for(;right<len;right++){\\n            char ch=s.charAt(right);\\n            if(ch==paranthesis[0]) val++;\\n            else if(ch==paranthesis[1]) val--;\\n            if(val<0) break;\\n        }\\n        if(val<0){\\n            for(;left<=right;left++){\\n                char ch=s.charAt(left);\\n                if(ch!=paranthesis[1]) continue;\\n                if(left>1 && s.charAt(left)==s.charAt(left-1)) continue;\\n                String temp=s.substring(0,left)+s.substring(left+1);\\n                recur(temp,left,right,paranthesis);\\n            }\\n        }\\n        else if(val>0){\\n            recur(new StringBuilder(s).reverse().toString(),0,0,new char[]{\\')\\',\\'(\\'});\\n        }\\n        else res.add(paranthesis[0]==\\'(\\'?s:new StringBuilder(s).reverse().toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545408,
                "title": "python-56ms-dfs-easy-to-understand",
                "content": "The basic idea is to count number of redundant \\'(\\' and \\')\\' in the given string first.\\nThen run dfs, terminate when any of the validness requirement is not met.\\nTime complexity is O(2^N).\\n\\n```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\"\"\"\\n        # count the number of \\'(\\' and \\')\\' needs to be removed\\n        if not s:\\n            return [\\'\\']\\n        stack = []\\n        del_l = del_r = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(c)\\n            elif c == \\')\\':\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                else:\\n                    del_r += 1\\n        del_l += len(stack)\\n        \\n\\t\\t# apply dfs\\n        def dfs(i, curr, half, l, r):  # half: number of excess half parenthesis \\'(\\' in curr\\n            if l < 0 or r < 0 or half < 0:\\n                return\\n            if i == len(s):\\n                if l == r == half == 0: # push valid result\\n                    res.add(curr)\\n                return\\n            if s[i] == \\'(\\':\\n                dfs(i + 1, curr, half, l - 1, r) # del l\\n                dfs(i + 1, curr + s[i], half + 1, l, r) # keep l\\n            elif s[i] == \\')\\':\\n                dfs(i + 1, curr, half, l, r - 1) # del r\\n                dfs(i + 1, curr + s[i], half - 1, l, r) # keep r\\n            else:\\n                dfs(i + 1, curr + s[i], half, l, r) # add letters\\n        \\n        res = set()\\n        dfs(0, \\'\\', 0, del_l, del_r)\\n        return list(res)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\"\"\"\\n        # count the number of \\'(\\' and \\')\\' needs to be removed\\n        if not s:\\n            return [\\'\\']\\n        stack = []\\n        del_l = del_r = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(c)\\n            elif c == \\')\\':\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                else:\\n                    del_r += 1\\n        del_l += len(stack)\\n        \\n\\t\\t# apply dfs\\n        def dfs(i, curr, half, l, r):  # half: number of excess half parenthesis \\'(\\' in curr\\n            if l < 0 or r < 0 or half < 0:\\n                return\\n            if i == len(s):\\n                if l == r == half == 0: # push valid result\\n                    res.add(curr)\\n                return\\n            if s[i] == \\'(\\':\\n                dfs(i + 1, curr, half, l - 1, r) # del l\\n                dfs(i + 1, curr + s[i], half + 1, l, r) # keep l\\n            elif s[i] == \\')\\':\\n                dfs(i + 1, curr, half, l, r - 1) # del r\\n                dfs(i + 1, curr + s[i], half - 1, l, r) # keep r\\n            else:\\n                dfs(i + 1, curr + s[i], half, l, r) # add letters\\n        \\n        res = set()\\n        dfs(0, \\'\\', 0, del_l, del_r)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539667,
                "title": "python-3-bfs",
                "content": "```\\nimport collections\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        q = collections.deque([s])\\n        res = []\\n        visited = set()\\n        visited.add(s)\\n        found = False\\n        while q:\\n            strr = q.popleft()\\n            if self.isValid(strr):\\n                res.append(strr)\\n                found = True\\n            if found: continue\\n            for i in range(len(strr)):\\n                if strr[i]==\\'(\\' or strr[i]==\\')\\':\\n                    ss = strr[:i] + strr[i+1:]\\n                    if ss not in visited:\\n                        q.append(ss)\\n                        visited.add(ss)\\n        return res\\n       \\n    def isValid(self, s):\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                count+=1\\n            elif c == \\')\\':\\n                count-=1\\n            if count<0:\\n                return False\\n        return count == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        q = collections.deque([s])\\n        res = []\\n        visited = set()\\n        visited.add(s)\\n        found = False\\n        while q:\\n            strr = q.popleft()\\n            if self.isValid(strr):\\n                res.append(strr)\\n                found = True\\n            if found: continue\\n            for i in range(len(strr)):\\n                if strr[i]==\\'(\\' or strr[i]==\\')\\':\\n                    ss = strr[:i] + strr[i+1:]\\n                    if ss not in visited:\\n                        q.append(ss)\\n                        visited.add(ss)\\n        return res\\n       \\n    def isValid(self, s):\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                count+=1\\n            elif c == \\')\\':\\n                count-=1\\n            if count<0:\\n                return False\\n        return count == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417962,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public IList<string> RemoveInvalidParentheses(string s) \\n    {\\n        var result = new List<string>();\\n        if (s == null) return result;\\n        var visited = new HashSet<string>();\\n        visited.Add(s);\\n        var queue = new Queue<string>();\\n        queue.Enqueue(s);\\n        while(queue.Any())\\n        {\\n            if(result.Count > 0) \\n                break;\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var current = queue.Dequeue();\\n                if(IsValidParentheses(current))\\n                    result.Add(current);\\n                for(int i = 0; i < current.Length; i++)\\n                {\\n                    if(current[i] == \\'(\\'|| current[i] == \\')\\')\\n                    {\\n                        var newString = current.Substring(0, i) +  current.Substring(i + 1);\\n                        if(!visited.Contains(newString))\\n                        {\\n                            queue.Enqueue(newString);\\n                            visited.Add(newString);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    private bool IsValidParentheses(string s)\\n    {\\n        int open = 0, close = 0;\\n        foreach(var ch in s)\\n        {\\n            if(ch == \\'(\\')\\n                open++;\\n            else if(ch ==\\')\\')\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        \\n        return open == close;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> RemoveInvalidParentheses(string s) \\n    {\\n        var result = new List<string>();\\n        if (s == null) return result;\\n        var visited = new HashSet<string>();\\n        visited.Add(s);\\n        var queue = new Queue<string>();\\n        queue.Enqueue(s);\\n        while(queue.Any())\\n        {\\n            if(result.Count > 0) \\n                break;\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var current = queue.Dequeue();\\n                if(IsValidParentheses(current))\\n                    result.Add(current);\\n                for(int i = 0; i < current.Length; i++)\\n                {\\n                    if(current[i] == \\'(\\'|| current[i] == \\')\\')\\n                    {\\n                        var newString = current.Substring(0, i) +  current.Substring(i + 1);\\n                        if(!visited.Contains(newString))\\n                        {\\n                            queue.Enqueue(newString);\\n                            visited.Add(newString);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    \\n    private bool IsValidParentheses(string s)\\n    {\\n        int open = 0, close = 0;\\n        foreach(var ch in s)\\n        {\\n            if(ch == \\'(\\')\\n                open++;\\n            else if(ch ==\\')\\')\\n                close++;\\n            if(close>open)\\n                return false;\\n        }\\n        \\n        return open == close;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124206,
                "title": "three-different-methods-top-down-dfs-bottom-up-dfs-and-bfs",
                "content": "**Top-down DFS**\\n\\n- When we have a string, we can scan through it character by each character, keeping track of the index that we are currently looking at. Why do we need to keep track of the current index? Since we use it to indicate whether we\\'ve reached the final state or not. The final state is when our scanning pointer has reached the end of the string.\\n- For each character, it can be one of \\'(\\', \\')\\' and \\'[a-z]\\'.\\n- For each character, we consider whether we want to keep it in the final string or not.\\n\\t\\t- What\\'s the final string? It\\'s just the remaining string when we\\'ve reached the final state\\n\\t\\t- The final string might or might not be valid in terms of matching opening and closing parentheses. We simply have to check to decide whether we can add it to the final result set.\\n- If the current character is a letter: simple enough, keep it in the string and move on to the next index.\\n- If the current character is a paren:\\n\\t\\t- Choice 1: Keep it. Recurse to the next level without removing the current character, and just move the \"current index\" forward by 1.\\n\\t\\t- Choice 2: Discard it. Recurse to the next level with a string that has the current character removed, by constructing a substring out of the current string that intentionally leaves out the current character. At the next recursion level, since we\\'ve taken out one character, the current index remains the same, and we automatically move on to the \"next\" character in the string that hasn\\'t had the current character removed.\\n\\n```\\n    bool isValid(const string& s) {\\n        int left = 0, right = 0;\\n        \\n        for (char c : s) {\\n            if (\\'(\\' == c) {\\n                left++;\\n            } else if (\\')\\' == c) {\\n                (left > 0) ? left-- : right++;\\n            } else {\\n                // no op\\n            }\\n        }\\n        \\n        return (0 == left) && (0 == right);\\n    }\\n    \\n    \\n    // DFS (top-down)\\n    void dfs(unordered_set<string>& results, const string& s, int pos) {\\n        // Base case -> reached the end of the string\\n        if (pos == s.size()) {\\n            // Factor out validity checking code\\n            if (isValid(s)) {\\n                // Keep the current valid one if none has been recorded, or if the recorded one has the same size as the current one\\n                if (results.empty() || s.size() == results.begin()->size()) {\\n                    results.insert(s);\\n                } else {\\n                    // We want the min number of parens removed\\n                    // which, in other words, is to keep the longest remaining string\\n                    // Discard previously accumulated strings if they are shorter than the current valid one\\n                    if (s.size() > results.begin()->size()) {\\n                        results.clear();\\n                        results.insert(s);\\n                    }\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (s[pos] == \\'(\\' || s[pos] == \\')\\') {\\n            // Take it\\n            dfs(results, s, pos + 1);\\n            \\n            // Not take it, construct a substring without the current character\\n            dfs(results, s.substr(0, pos) + s.substr(pos + 1, s.size() - pos - 1), pos);\\n        } else {\\n            // Letter, take it\\n            dfs(results, s, pos + 1);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        // Use a set to de-duplicates\\n        unordered_set<string> results;\\n        \\n        // DFS starts from the 0th index\\n        dfs(results, s, 0);\\n        \\n        // Return a vector instead of a set\\n        return vector<string>(results.begin(), results.end());\\n    }\\n```\\n\\n\\n**Bottom-up DFS**\\n* Similar thought process as the top down approach. Also consider each character until we\\'ve reached the end of the string, that whether we should keep or discard the current character.\\n* \\tThe only difference is that we start with an empty string and append to it when we take a character from the input string, and passing it as-it-is when we discard a character.\\n```\\n    // The same valid() function\\n\\t\\t\\n    // DFS (bottom-up)\\n    void dfs(unordered_set<string>& validStrings, string curStr, const string& s, int pos) {\\n        if (pos == s.size()) {\\n            if (isValid(curStr)) {\\n                if (validStrings.empty() || curStr.size() == validStrings.begin()->size()) {\\n                    validStrings.insert(curStr);\\n                } else {\\n                    if (curStr.size() > validStrings.begin()->size()) {\\n                        validStrings.clear();\\n                        validStrings.insert(curStr);\\n                    }\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (s[pos] == \\'(\\') {\\n            // Take it\\n            dfs(validStrings, curStr + \\'(\\', s, pos + 1);\\n            \\n            // Not take it\\n            dfs(validStrings, curStr, s, pos + 1);\\n        } else if (s[pos] == \\')\\') {\\n            // Take it\\n            dfs(validStrings, curStr + \\')\\', s, pos + 1);\\n            \\n            // Not take it\\n            dfs(validStrings, curStr, s, pos + 1);\\n        } else {\\n            // Letter\\n            dfs(validStrings, curStr + s[pos], s, pos + 1);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string> validStrings;\\n        dfs(validStrings, \"\", s, 0);\\n        return vector<string>(validStrings.begin(), validStrings.end());\\n    }\\n```\\n\\n**BFS**\\n\\n* The mindset is a little different with BFS. With BFS, we look at the current string and think that we can generate ~N different states, each by removing a paren from the current string. (Why ~N? Some of them are letters which we don\\'t remove, and also removing paren at a different index might result in the same string. And exactly because of this, at each layer we will need to keep a set of the currently generated states to refrain from adding duplicate states to the queue that contains states waiting to be visited.)\\n* Since we are using BFS, the first layer at which we encounter a valid solution (same valid() function as before) would contain the states that represent the longest remaining string. So at a particular layer, we keep a flag that gets turned on when we see a valid result, and then we stop searching at that layer since we don\\'t care about shorter valid strings being generated in future layers.\\n\\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<string> toVisit;\\n        unordered_set<string> seen;\\n        int layer = 0;\\n        bool foundValid = false;\\n        vector<string> results;\\n        \\n        toVisit.push(s);\\n        \\n        while (!toVisit.empty()) {\\n            int size = toVisit.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                string str = toVisit.front();\\n                toVisit.pop();\\n                \\n                if (isValid(str)) {\\n                    if (!foundValid) {\\n                        foundValid = true;\\n                    }\\n                    \\n                    results.push_back(str);\\n                } else {\\n                    // Generate a new string by removing a paren in the current string\\n                    for (int i = 0; i < str.size(); ++i) {\\n                        if (str[i] == \\'(\\' || str[i] == \\')\\') {\\n                            string newStr = str.substr(0, i) + str.substr(i + 1, str.size() - i - 1);\\n                            if (seen.find(newStr) == seen.end()) {\\n                                seen.insert(newStr);\\n                                toVisit.push(newStr);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            layer++;\\n            \\n            if (foundValid) {\\n                break;\\n            }\\n        }\\n        \\n        return results;\\n    }\\n```\\n\\n**[UPSHOTS]**\\n1. With search problems, we will need to define what consists of a **state** (in this case it is a string transformed from the input string), and what consists of a **state transfer**/**an edge in the graph connecting two states**(in the DFS case at each state we have two outgoing edges if the current character is a paren, to either keep it, or to discard it. With the current character as a letter, there\\'s only one outgoing edge, which means keeping the letter.)\\n\\n2. Search problems often involves generating all the valid states -> they will have exponential time complexity. The space complexity for DFS will be the level of recursions (how many recursions do we need to get down to the base case, where there\\'s no outgoing edges any more), and the space complexity for BFS will be the number of states generated at the outermost layer of the search. (if k possible states per layer and the search spans d layers, then *k^d* states will be generated at the *d*th layer.)\\n\\n3. Simple algorithms such as validating parentheses balance should be factored out when we are writing the main algorithm, so as to let the main algorithm have a cleaner structure, be easier to understand/debug/reason about, be easier to test etc.",
                "solutionTags": [],
                "code": "```\\n    bool isValid(const string& s) {\\n        int left = 0, right = 0;\\n        \\n        for (char c : s) {\\n            if (\\'(\\' == c) {\\n                left++;\\n            } else if (\\')\\' == c) {\\n                (left > 0) ? left-- : right++;\\n            } else {\\n                // no op\\n            }\\n        }\\n        \\n        return (0 == left) && (0 == right);\\n    }\\n    \\n    \\n    // DFS (top-down)\\n    void dfs(unordered_set<string>& results, const string& s, int pos) {\\n        // Base case -> reached the end of the string\\n        if (pos == s.size()) {\\n            // Factor out validity checking code\\n            if (isValid(s)) {\\n                // Keep the current valid one if none has been recorded, or if the recorded one has the same size as the current one\\n                if (results.empty() || s.size() == results.begin()->size()) {\\n                    results.insert(s);\\n                } else {\\n                    // We want the min number of parens removed\\n                    // which, in other words, is to keep the longest remaining string\\n                    // Discard previously accumulated strings if they are shorter than the current valid one\\n                    if (s.size() > results.begin()->size()) {\\n                        results.clear();\\n                        results.insert(s);\\n                    }\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (s[pos] == \\'(\\' || s[pos] == \\')\\') {\\n            // Take it\\n            dfs(results, s, pos + 1);\\n            \\n            // Not take it, construct a substring without the current character\\n            dfs(results, s.substr(0, pos) + s.substr(pos + 1, s.size() - pos - 1), pos);\\n        } else {\\n            // Letter, take it\\n            dfs(results, s, pos + 1);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        // Use a set to de-duplicates\\n        unordered_set<string> results;\\n        \\n        // DFS starts from the 0th index\\n        dfs(results, s, 0);\\n        \\n        // Return a vector instead of a set\\n        return vector<string>(results.begin(), results.end());\\n    }\\n```\n```\\n    // The same valid() function\\n\\t\\t\\n    // DFS (bottom-up)\\n    void dfs(unordered_set<string>& validStrings, string curStr, const string& s, int pos) {\\n        if (pos == s.size()) {\\n            if (isValid(curStr)) {\\n                if (validStrings.empty() || curStr.size() == validStrings.begin()->size()) {\\n                    validStrings.insert(curStr);\\n                } else {\\n                    if (curStr.size() > validStrings.begin()->size()) {\\n                        validStrings.clear();\\n                        validStrings.insert(curStr);\\n                    }\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        if (s[pos] == \\'(\\') {\\n            // Take it\\n            dfs(validStrings, curStr + \\'(\\', s, pos + 1);\\n            \\n            // Not take it\\n            dfs(validStrings, curStr, s, pos + 1);\\n        } else if (s[pos] == \\')\\') {\\n            // Take it\\n            dfs(validStrings, curStr + \\')\\', s, pos + 1);\\n            \\n            // Not take it\\n            dfs(validStrings, curStr, s, pos + 1);\\n        } else {\\n            // Letter\\n            dfs(validStrings, curStr + s[pos], s, pos + 1);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string> validStrings;\\n        dfs(validStrings, \"\", s, 0);\\n        return vector<string>(validStrings.begin(), validStrings.end());\\n    }\\n```\n```\\n    vector<string> removeInvalidParentheses(string s) {\\n        queue<string> toVisit;\\n        unordered_set<string> seen;\\n        int layer = 0;\\n        bool foundValid = false;\\n        vector<string> results;\\n        \\n        toVisit.push(s);\\n        \\n        while (!toVisit.empty()) {\\n            int size = toVisit.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                string str = toVisit.front();\\n                toVisit.pop();\\n                \\n                if (isValid(str)) {\\n                    if (!foundValid) {\\n                        foundValid = true;\\n                    }\\n                    \\n                    results.push_back(str);\\n                } else {\\n                    // Generate a new string by removing a paren in the current string\\n                    for (int i = 0; i < str.size(); ++i) {\\n                        if (str[i] == \\'(\\' || str[i] == \\')\\') {\\n                            string newStr = str.substr(0, i) + str.substr(i + 1, str.size() - i - 1);\\n                            if (seen.find(newStr) == seen.end()) {\\n                                seen.insert(newStr);\\n                                toVisit.push(newStr);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            layer++;\\n            \\n            if (foundValid) {\\n                break;\\n            }\\n        }\\n        \\n        return results;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75074,
                "title": "clean-c-0ms-solution-with-comments",
                "content": "Idea is to search twice the string (left to right, and right to left), and get rid of all necessary chars.\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<string> ans;\\n    \\n    void gen(string s, int start, int lbound, char inc, char dec) { // search from start, delete until lbound\\n        int cnt = 0;\\n        for (int i = start; i < s.length(); i++) {\\n            cnt += s[i] == inc ? 1 : s[i] == dec ? -1 : 0;\\n            \\n            if (cnt == -1) {                                    // if got extra dec, delete all possible positions\\n                int j = i;\\n                while (lbound <= j) {\\n                    if ((j == lbound || s[j - 1] != s[j]) && s[j] == dec) { // skip duplicates, delete until lbound\\n                        gen(s.substr(0, j) + s.substr(j + 1), i, j, inc, dec);\\n                    }\\n                    j--;\\n                }\\n                return;\\n            }\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        if (inc == '(') {                           // if it's first round, search the reverse string again\\n            gen(s, 0, 0, dec, inc);\\n        } else {\\n            ans.push_back(s);                       // if it's second round, it's a valid path, add to ans\\n        }\\n    }\\n    \\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        gen(s, 0, 0, '(', ')');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> ans;\\n    \\n    void gen(string s, int start, int lbound, char inc, char dec) { // search from start, delete until lbound\\n        int cnt = 0;\\n        for (int i = start; i < s.length(); i++) {\\n            cnt += s[i] == inc ? 1 : s[i] == dec ? -1 : 0;\\n            \\n            if (cnt == -1) {                                    // if got extra dec, delete all possible positions\\n                int j = i;\\n                while (lbound <= j) {\\n                    if ((j == lbound || s[j - 1] != s[j]) && s[j] == dec) { // skip duplicates, delete until lbound\\n                        gen(s.substr(0, j) + s.substr(j + 1), i, j, inc, dec);\\n                    }\\n                    j--;\\n                }\\n                return;\\n            }\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        if (inc == '(') {                           // if it's first round, search the reverse string again\\n            gen(s, 0, 0, dec, inc);\\n        } else {\\n            ans.push_back(s);                       // if it's second round, it's a valid path, add to ans\\n        }\\n    }\\n    \\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        gen(s, 0, 0, '(', ')');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75104,
                "title": "dfs-and-bfs-java-solutions-add-one-more-optimized-fast-dfs-solution",
                "content": "    // Optimized DFS Solution\\n    public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            if (s.length() == 0) return new ArrayList<String>(Arrays.asList(\"\"));\\n            Map<Integer, List<String>> dics = new HashMap<Integer, List<String>>();\\n            Set<String> visited = new HashSet<String>();\\n            int[] min = new int[]{Integer.MAX_VALUE};\\n            char[] str = s.toCharArray();\\n            helper(dics, str, 0, \"\", 0, 0, min, 0, visited);\\n            return dics.get(min[0]);\\n        }\\n        private void helper(Map<Integer, List<String>> dics, char[] str, int start, String cur, \\n                            int left, int right, int[] min, int delete, Set<String> visited) {\\n            // Base Cases\\n            if (visited.contains(cur + delete)) return;\\n            visited.add(cur + delete);\\n            if (start == str.length) {\\n                if (left != right) return;\\n                if (!dics.containsKey(delete)) dics.put(delete, new ArrayList<String>());\\n                dics.get(delete).add(cur);\\n                min[0] = Math.min(min[0], delete);\\n                return;\\n            }\\n            if (left < right) return;\\n            if (str[start] == '(') {\\n                helper(dics, str, start + 1, cur + \"(\", left + 1, right, min, delete, visited);\\n                helper(dics, str, start + 1, cur, left, right, min, delete + 1, visited);\\n            } else if (str[start] == ')') {\\n                helper(dics, str, start + 1, cur + \")\", left, right + 1, min, delete, visited);\\n                helper(dics, str, start + 1, cur, left, right, min, delete + 1, visited);\\n            } else {\\n                helper(dics, str, start + 1, cur + str[start], left, right, min, delete, visited);\\n            }\\n        }\\n    }\\n\\n    // DFS \\n    public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            if (s.length() == 0) return new ArrayList<String>(Arrays.asList(\"\"));\\n            Map<Integer, Set<String>> dics = new HashMap<Integer, Set<String>>();\\n            int[] min = new int[]{Integer.MAX_VALUE};\\n            char[] str = s.toCharArray();\\n            helper(dics, str, 0, \"\", 0, 0, min, 0);\\n            return new ArrayList<String>(dics.get(min[0]));\\n        }\\n        private void helper(Map<Integer, Set<String>> dics, char[] str, int start, String cur, \\n                            int left, int right, int[] min, int delete) {\\n            // Base Cases\\n            if (start == str.length) {\\n                if (left != right) return;\\n                if (!dics.containsKey(delete)) dics.put(delete, new HashSet<String>());\\n                dics.get(delete).add(cur);\\n                min[0] = Math.min(min[0], delete);\\n                return;\\n            }\\n            if (left < right) return;\\n            if (str[start] == '(') {\\n                helper(dics, str, start + 1, cur + \"(\", left + 1, right, min, delete);\\n                helper(dics, str, start + 1, cur, left, right, min, delete + 1);\\n            } else if (str[start] == ')') {\\n                helper(dics, str, start + 1, cur + \")\", left, right + 1, min, delete);\\n                helper(dics, str, start + 1, cur, left, right, min, delete + 1);\\n            } else {\\n                helper(dics, str, start + 1, cur + str[start], left, right, min, delete);\\n            }\\n        }\\n    }\\n\\n    // BFS\\n    //idea from @jeantimex, modified and rewrite\\n    public class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            List<String> res = new ArrayList<String>();\\n            if (s == null) return res;\\n            Queue<String> queue = new LinkedList<String>();\\n            Set<String> visited = new HashSet<String>();\\n            queue.add(s);\\n            boolean reached = false;\\n            while (!queue.isEmpty()) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    String cur = queue.remove();\\n                    // Valid\\n                    if (isValid(cur)) {\\n                        reached = true;\\n                        res.add(cur);\\n                    }\\n                    // Not Valid Then Delete \\n                    if (!reached) {\\n                        for (int j = 0; j < cur.length(); j++) {\\n                            if (cur.charAt(j) != '(' && cur.charAt(j) != ')') continue;\\n                            String newStr = cur.substring(0, j) + cur.substring(j + 1);\\n                            if (!visited.contains(newStr)) {\\n                                queue.add(newStr);\\n                                visited.add(newStr);\\n                            }\\n                        }\\n                    }\\n                }\\n                if (reached) break;\\n            }\\n            return res;\\n        }\\n        private boolean isValid(String str) {\\n            char[] s = str.toCharArray();\\n            int left = 0;\\n            for (int i = 0; i < s.length; i++) {\\n                if (s[i] == '(') left++;\\n                else if (s[i] == ')') {\\n                    if (left == 0) return false;\\n                    left--;\\n                }\\n            }\\n            return left == 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> removeInvalidParentheses(String s) {\\n            if (s.length() == 0) return new ArrayList<String>(Arrays.asList(\"\"));\\n            Map<Integer, List<String>> dics = new HashMap<Integer, List<String>>();\\n            Set<String> visited = new HashSet<String>();\\n            int[] min = new int[]{Integer.MAX_VALUE}",
                "codeTag": "Java"
            },
            {
                "id": 2869720,
                "title": "remove-invalid-parantheses-optimized-bfs-approach-c-solution",
                "content": "# Intuition\\nJust delete every character and check each possibility level by level.\\n\\n# Approach\\nUsing BFS , each level indicates how many characters are deleted.\\n\\n# Complexity\\n- Time complexity:\\nExponential\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string s)\\n    {\\n        int x = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\') x++;\\n            if(s[i] == \\')\\') x--;\\n\\n            if(x < 0) return false;\\n        }\\n        return x == 0;\\n    }\\n\\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        int n = s.size();\\n        vector<string>ans;\\n        unordered_map<string, int>mp, mp1;\\n        deque<string>q;\\n\\n        bool flag = false;\\n        q.push_back(s);\\n        while(!q.empty())\\n        {\\n            int nn = q.size();\\n            while(nn--)\\n            {\\n                string curr = q.front();\\n                q.pop_front();\\n\\n\\n                if(solve(curr) && !mp[curr]) \\n                {\\n                    ans.push_back(curr);\\n                    mp[curr]++;\\n                    flag = true;\\n                    continue;\\n                }\\n              \\n                for(int i=0; i<curr.size(); i++)\\n                {\\n                    if(curr[i] != \\')\\' && curr[i] != \\'(\\') continue;\\n                    string temp = curr.substr(0, i) + curr.substr(i + 1);\\n                    if(!mp1[temp]) q.push_back(temp), mp1[temp]++;\\n                }\\n            }\\n\\n            if(flag) break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(string s)\\n    {\\n        int x = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\') x++;\\n            if(s[i] == \\')\\') x--;\\n\\n            if(x < 0) return false;\\n        }\\n        return x == 0;\\n    }\\n\\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        int n = s.size();\\n        vector<string>ans;\\n        unordered_map<string, int>mp, mp1;\\n        deque<string>q;\\n\\n        bool flag = false;\\n        q.push_back(s);\\n        while(!q.empty())\\n        {\\n            int nn = q.size();\\n            while(nn--)\\n            {\\n                string curr = q.front();\\n                q.pop_front();\\n\\n\\n                if(solve(curr) && !mp[curr]) \\n                {\\n                    ans.push_back(curr);\\n                    mp[curr]++;\\n                    flag = true;\\n                    continue;\\n                }\\n              \\n                for(int i=0; i<curr.size(); i++)\\n                {\\n                    if(curr[i] != \\')\\' && curr[i] != \\'(\\') continue;\\n                    string temp = curr.substr(0, i) + curr.substr(i + 1);\\n                    if(!mp1[temp]) q.push_back(temp), mp1[temp]++;\\n                }\\n            }\\n\\n            if(flag) break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518455,
                "title": "c-backtracking-memoization",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1. We need to count minimum number of invalid parenthesis present in string.\\n2. Check for each index we if can remove current parenthesis to make string balanced.\\n3. To optimize solution, we can keep track of all the strings we have already processed using map to avoid extra function calls.\\n   eg: \"( ( ) ) ( )\" // removing character at index 2 and 3 yields the same result\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minRemovals(string s){\\n        int i, n=s.length();\\n        stack<char> st;\\n        for(i=0;i<n;i++){\\n            char ch=s[i];\\n            if(isalpha(ch)){\\n                continue;\\n            }\\n            if(ch==\\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(st.size()==0 || st.top()==\\')\\'){\\n                    st.push(ch);\\n                }else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n    \\n    void solve(string s, vector<string> &ans, int removal, unordered_map<string,bool> &mp){\\n        if(removal==0 && minRemovals(s)==0){\\n            mp[s]=true;\\n            ans.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])) continue;\\n            string pre=s.substr(0,i);\\n            string suf=s.substr(i+1);\\n            \\n            string sub=pre+suf;\\n            if(mp.find(sub)!=mp.end()) continue;\\n            mp[sub]=true;\\n            solve(sub,ans,removal-1,mp);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        int removals=minRemovals(s);\\n        \\n        vector<string> ans;\\n        unordered_map<string,bool> mp;\\n        solve(s,ans,removals,mp);\\n        if(ans.size()==0) ans.push_back(\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minRemovals(string s){\\n        int i, n=s.length();\\n        stack<char> st;\\n        for(i=0;i<n;i++){\\n            char ch=s[i];\\n            if(isalpha(ch)){\\n                continue;\\n            }\\n            if(ch==\\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(st.size()==0 || st.top()==\\')\\'){\\n                    st.push(ch);\\n                }else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n    \\n    void solve(string s, vector<string> &ans, int removal, unordered_map<string,bool> &mp){\\n        if(removal==0 && minRemovals(s)==0){\\n            mp[s]=true;\\n            ans.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(isalpha(s[i])) continue;\\n            string pre=s.substr(0,i);\\n            string suf=s.substr(i+1);\\n            \\n            string sub=pre+suf;\\n            if(mp.find(sub)!=mp.end()) continue;\\n            mp[sub]=true;\\n            solve(sub,ans,removal-1,mp);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        int removals=minRemovals(s);\\n        \\n        vector<string> ans;\\n        unordered_map<string,bool> mp;\\n        solve(s,ans,removals,mp);\\n        if(ans.size()==0) ans.push_back(\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898000,
                "title": "o-n-2-to-find-count-answer-o-ans-to-write-it-many-insights-discussed",
                "content": "Let us call a string of brackets left-balanced if each prefix has number of \"(\" >= number of \")\".\\nSimilarly, it is right-balanced if each suffix has number of \")\" >= number of \"(\".\\n\\n**Insight** : A bracket string is balanced (or \"valid\") if it is both left-balanced and right-balanced. \\nBut there\\'s a much easier condition: it is balanced if it is left-balanced and the total number of \"(\" and \")\" match at the end (or equivalently, if \"(\" and \")\" match and it\\'s right balanced).\\n\\nSo before we solve the full problem, let\\'s pretend instead of needing the string to be balanced, it only needs to be left-balanced. We will only need to remove closing brackets \")\". We sweep from left to right, keeping track of the difference in # of \"(\" and # of \")\".  Whenever there is more \")\", we have to remove some \")\", and this could be any that we have seen so far. Let us keep a list of the strings we have so far. At first this will be the normal string, but we will then grow the list as we have choices of which previous \")\" to delete.\\n\\n**Insight:** Even after we make new strings with deleted \")\", we can simply continue scanning the original string, as our new strings only have \")\" deleted before our current spot in the scan.\\n\\nWhen this is done, we will have all possible left-balanced strings. How do we make them fully-balanced? For each resulting left-balanced string, we can do the same thing from the right, scanning right-to-left and deleting \"(\" when the string is not right-balanced. Code-wise, we can save time by reversing each left-balanced answer, call our previous code, and reverse the results. Note we are doing the left-balance procedure on the original string, then for **each** result we are calling the right-balance procedure, creating a results-of-results that we put flatten together.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        auto frontans = solveFront(s);\\n        unordered_set<string> fullans;\\n        for (auto ans: frontans){\\n            for (auto backans: solveFront(reverse(ans))){\\n                fullans.insert(reverse(backans));\\n            }\\n        }\\n        return {fullans.begin(), fullans.end()};\\n    }\\n    \\n    string reverse(string s){\\n        for (int i=0;i*2+1 < s.length();i++){\\n            swap(s[i], s[s.length()-1-i]);\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if (s[i] ==\\'(\\') s[i] = \\')\\';\\n            else if (s[i]==\\')\\') s[i] = \\'(\\';\\n        }\\n        return s;\\n    }\\n    \\n    unordered_set<string> solveFront(string s) {\\n        unordered_set<string> prevans;\\n        unordered_set<string> nextans;\\n        prevans.insert(s);\\n        int lbal=0;\\n        int n_removes=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            else if (s[i] ==\\')\\'){\\n                if (lbal > 0){\\n                    lbal--;\\n                }\\n                else {\\n                    for (auto pans: prevans){\\n                        for (int j=i-n_removes;j>=0;j--){\\n                            if (pans[j]==\\')\\'){\\n                                string pans_copy = pans;\\n                                pans_copy.erase(pans_copy.begin()+j);\\n                                nextans.insert(pans_copy);\\n                            }\\n                        }\\n                    }\\n                    swap(prevans, nextans);\\n                    nextans = {};\\n                    n_removes++;\\n                }\\n            }\\n        }\\n        return prevans;\\n    }\\n};\\n```\\n\\nThis is nice, and happens to run in 0ms on the test cases, but we can do better. Let\\'s see if we can avoid calling the entire procedure again from the right-side on each of the left-balanced sub-answers (which can be exponential in number). At first it seems like it\\'s unavoidable, as it matters in the right-balancing procedure where the \")\" are, and in each sub-answer we have them in different places as we deleted in different places.\\n\\n**Big Insight**: The left-balancing and right-balancing procedure actually never overlap. At the end of the left-balancing procedure, each prefix of a subanswer has \"(\" >= \")\". Consider the last spot in which the prefix has \"(\" == \")\". Since each sub-prefix of this prefix is left-balanced, and the number of \"(\" =\")\", the prefix is balanced (and so everything inside will be right balanced too)!\\nSo actually, we only need to run the right-balancing procedure up to the last spot in which the left-balancing procedure created an equal number of \"(\" and \")\", and this spot is the same for each sub-answer, no matter which early \"(\" were deleted. And the suffix after this spot was not touched in any sub-answer and will equal to the original string. \\nIn fact, we can just precompute how far we need to do the left-balancing procedure and how far we need to do the right-balancing procedure, and stich together every pair of left subanswer and every right subanswer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int last_lbal_index=-1;\\n        int last_l_bad_index=-1;\\n        int lbal=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            if (s[i]==\\')\\') {\\n                lbal--;\\n                if (lbal < 0){\\n                    lbal = 0;\\n                    last_l_bad_index=i;\\n                }\\n                if (lbal==0){\\n                    last_lbal_index = i;\\n                }\\n            }\\n        }\\n        \\n        int last_r_bad_index=s.length();\\n        int rbal=0;\\n        for (int i=s.length()-1;i>last_lbal_index;i--){\\n            if (s[i]==\\')\\') rbal++;\\n            if (s[i]==\\'(\\') {\\n                rbal--;\\n                if (rbal<0){\\n                    rbal = 0;\\n                    last_r_bad_index = i;\\n                }\\n            }\\n        }\\n        \\n        string balanced_middle = s.substr(last_l_bad_index+1, last_r_bad_index - last_l_bad_index-1); // i.e. from last_l_bad_index+1 to last_r_bad_index-1\\n        \\n        vector<string> ans;\\n        \\n        for (const string& front_ans:solveFront(s.substr(0,last_l_bad_index+1))) {\\n            for (const string& rev_back_ans:solveFront(reverse(s.substr(last_r_bad_index)))){\\n                ans.push_back(front_ans + balanced_middle + reverse(rev_back_ans));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    string reverse(string s){\\n        for (int i=0;i*2+1 < s.length();i++){\\n            swap(s[i], s[s.length()-1-i]);\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if (s[i] ==\\'(\\') s[i] = \\')\\';\\n            else if (s[i]==\\')\\') s[i] = \\'(\\';\\n        }\\n        return s;\\n    }\\n\\n    \\n    unordered_set<string> solveFront(string s) {\\n        \\n        unordered_set<string> prevans;\\n        unordered_set<string> nextans;\\n        prevans.insert(s);\\n        int lbal=0;\\n        int n_removes=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            else if (s[i] ==\\')\\'){\\n                if (lbal > 0){\\n                    lbal--;\\n                }\\n                else {\\n                    for (auto pans: prevans){\\n                        for (int j=i-n_removes;j>=0;j--){\\n                            if (pans[j]==\\')\\'){\\n                                string pans_copy = pans;\\n                                pans_copy.erase(pans_copy.begin()+j);\\n                                nextans.insert(pans_copy);\\n                            }\\n                        }\\n                    }\\n                    swap(prevans, nextans);\\n                    nextans = {};\\n                    n_removes++;\\n                }\\n            }\\n        }\\n        \\n        return prevans;\\n    }\\n};\\n```\\nMuch better! But the runtime here is O(N*|ANS|), because for each position, for each subanswer we both do a O(N) string search for \")\", an O(N) copy and an O(N) string::erase. We can actually get around all three of these and improve the answer to O(|ANS|). Instead of keeping track of strings as we go left-to-right, we will instead keep track of current lists of right-bracket positions we want to delete. Only at the end we will go back and create the actual strings. Instead of searching for \")\" each time, we compute the positions at the beginning and at each delete round we can just use every delete that is after our last delete in the current subanswer. To get around the O(N) copy, we will only copy when one subanswer branches into multiple, and otherwise just modify in-place. This way the runtime is dominated by O(|ANS|). You\\'ll notice that if the question asked \"how many ways\" are there to delete characters rather than writing down each way, we could modify to keep track of counts rather than delete positions, and then the runtime will be O(N^2)!\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int last_lbal_index=-1;\\n        int last_l_bad_index=-1;\\n        int lbal=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            if (s[i]==\\')\\') {\\n                lbal--;\\n                if (lbal < 0){\\n                    lbal = 0;\\n                    last_l_bad_index=i;\\n                }\\n                if (lbal==0){\\n                    last_lbal_index = i;\\n                }\\n            }\\n        }\\n        \\n        int last_r_bad_index=s.length();\\n        int rbal=0;\\n        for (int i=s.length()-1;i>last_lbal_index;i--){\\n            if (s[i]==\\')\\') rbal++;\\n            if (s[i]==\\'(\\') {\\n                rbal--;\\n                if (rbal<0){\\n                    rbal = 0;\\n                    last_r_bad_index = i;\\n                }\\n            }\\n        }\\n        \\n        string balanced_middle = s.substr(last_l_bad_index+1, last_r_bad_index - last_l_bad_index-1); // i.e. from last_l_bad_index+1 to last_r_bad_index-1\\n        \\n        vector<string> ans;\\n        \\n        for (const string& front_ans:solveFront(s.substr(0,last_l_bad_index+1))) {\\n            for (const string& rev_back_ans:solveFront(reverse(s.substr(last_r_bad_index)))){\\n                ans.push_back(front_ans + balanced_middle + reverse(rev_back_ans));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    string reverse(string s){\\n        for (int i=0;i*2+1 < s.length();i++){\\n            swap(s[i], s[s.length()-1-i]);\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if (s[i] ==\\'(\\') s[i] = \\')\\';\\n            else if (s[i]==\\')\\') s[i] = \\'(\\';\\n        }\\n        return s;\\n    }\\n\\n    \\n    unordered_set<string> solveFront(string s) {\\n        vector<int> rparen_loc; // locations of \\')\\'\\n        vector<int> must_delete_before_loc; // an rparen must be deleted before these locations to keep the string left-balanced.\\n        \\n        int lbal=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            else if (s[i]==\\')\\'){\\n                rparen_loc.push_back(i);\\n                if (lbal > 0){\\n                    lbal--;\\n                } else {\\n                    must_delete_before_loc.push_back(rparen_loc.size());\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        // now each of these will be a vector of rparen indexes chosen to remove, converted to a proper string later. This is to avoid using the expensive string::erase.\\n        vector<vector<int> > prevans;\\n        \\n        prevans.push_back({});\\n        \\n        for (int n_delete=0;n_delete<must_delete_before_loc.size();n_delete++){\\n            int num_prev = prevans.size();\\n            for (int i=0;i<num_prev;i++){\\n                int start = 0;\\n                if (prevans[i].size() > 0){\\n                    start = prevans[i][n_delete-1]+1; // new delete must be after old deletes of the answer we are building on.\\n                }\\n                for (int i_rparen = start; i_rparen<must_delete_before_loc[n_delete]; i_rparen++){\\n                    if (prevans[i].size()>n_delete){\\n                        // this answer was already modified, so a new vector must be copied.\\n                        vector<int> nans = prevans[i];\\n                        nans[n_delete] = i_rparen;\\n                        prevans.push_back(nans);\\n                    } else {\\n                        // don\\'t copy the first time, just modify the answer.\\n                        prevans[i].push_back(i_rparen);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // we have the answer in a weird form, now we need to get the actual strings\\n        unordered_set<string> all_str_ans;\\n        for (auto ans: prevans){\\n            string str_ans;\\n            int j=0;\\n            for (int i=0;i<s.length();i++){\\n                if (j<ans.size() && rparen_loc[ans[j]] == i){\\n                    // skip this character\\n                    j++;\\n                    continue;\\n                }\\n                \\n                str_ans += s[i];\\n            }\\n            \\n            all_str_ans.insert(str_ans);\\n        }\\n        \\n        return all_str_ans;\\n        \\n    }\\n};\\n```\\n\\nFor getting O(N^2) for the counting version of the problem,\\nlet dp[n][k] be the number of valid ways to delete k of the first n \")\". \\ndp[n][k] = 0 if more than k \")\" must be deleted by that point, and otherwise dp[n][k] = dp[n-1][k-1] + dp[n-1][k] (delete the nth \")\" or don\\'t). Visually this is pascals triangle with columns getting zero\\'d out after certain points, so it\\'s possible that there is a mathematical way to improve this to something even better via combinatorics.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        auto frontans = solveFront(s);\\n        unordered_set<string> fullans;\\n        for (auto ans: frontans){\\n            for (auto backans: solveFront(reverse(ans))){\\n                fullans.insert(reverse(backans));\\n            }\\n        }\\n        return {fullans.begin(), fullans.end()};\\n    }\\n    \\n    string reverse(string s){\\n        for (int i=0;i*2+1 < s.length();i++){\\n            swap(s[i], s[s.length()-1-i]);\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if (s[i] ==\\'(\\') s[i] = \\')\\';\\n            else if (s[i]==\\')\\') s[i] = \\'(\\';\\n        }\\n        return s;\\n    }\\n    \\n    unordered_set<string> solveFront(string s) {\\n        unordered_set<string> prevans;\\n        unordered_set<string> nextans;\\n        prevans.insert(s);\\n        int lbal=0;\\n        int n_removes=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            else if (s[i] ==\\')\\'){\\n                if (lbal > 0){\\n                    lbal--;\\n                }\\n                else {\\n                    for (auto pans: prevans){\\n                        for (int j=i-n_removes;j>=0;j--){\\n                            if (pans[j]==\\')\\'){\\n                                string pans_copy = pans;\\n                                pans_copy.erase(pans_copy.begin()+j);\\n                                nextans.insert(pans_copy);\\n                            }\\n                        }\\n                    }\\n                    swap(prevans, nextans);\\n                    nextans = {};\\n                    n_removes++;\\n                }\\n            }\\n        }\\n        return prevans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int last_lbal_index=-1;\\n        int last_l_bad_index=-1;\\n        int lbal=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            if (s[i]==\\')\\') {\\n                lbal--;\\n                if (lbal < 0){\\n                    lbal = 0;\\n                    last_l_bad_index=i;\\n                }\\n                if (lbal==0){\\n                    last_lbal_index = i;\\n                }\\n            }\\n        }\\n        \\n        int last_r_bad_index=s.length();\\n        int rbal=0;\\n        for (int i=s.length()-1;i>last_lbal_index;i--){\\n            if (s[i]==\\')\\') rbal++;\\n            if (s[i]==\\'(\\') {\\n                rbal--;\\n                if (rbal<0){\\n                    rbal = 0;\\n                    last_r_bad_index = i;\\n                }\\n            }\\n        }\\n        \\n        string balanced_middle = s.substr(last_l_bad_index+1, last_r_bad_index - last_l_bad_index-1); // i.e. from last_l_bad_index+1 to last_r_bad_index-1\\n        \\n        vector<string> ans;\\n        \\n        for (const string& front_ans:solveFront(s.substr(0,last_l_bad_index+1))) {\\n            for (const string& rev_back_ans:solveFront(reverse(s.substr(last_r_bad_index)))){\\n                ans.push_back(front_ans + balanced_middle + reverse(rev_back_ans));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    string reverse(string s){\\n        for (int i=0;i*2+1 < s.length();i++){\\n            swap(s[i], s[s.length()-1-i]);\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if (s[i] ==\\'(\\') s[i] = \\')\\';\\n            else if (s[i]==\\')\\') s[i] = \\'(\\';\\n        }\\n        return s;\\n    }\\n\\n    \\n    unordered_set<string> solveFront(string s) {\\n        \\n        unordered_set<string> prevans;\\n        unordered_set<string> nextans;\\n        prevans.insert(s);\\n        int lbal=0;\\n        int n_removes=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            else if (s[i] ==\\')\\'){\\n                if (lbal > 0){\\n                    lbal--;\\n                }\\n                else {\\n                    for (auto pans: prevans){\\n                        for (int j=i-n_removes;j>=0;j--){\\n                            if (pans[j]==\\')\\'){\\n                                string pans_copy = pans;\\n                                pans_copy.erase(pans_copy.begin()+j);\\n                                nextans.insert(pans_copy);\\n                            }\\n                        }\\n                    }\\n                    swap(prevans, nextans);\\n                    nextans = {};\\n                    n_removes++;\\n                }\\n            }\\n        }\\n        \\n        return prevans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int last_lbal_index=-1;\\n        int last_l_bad_index=-1;\\n        int lbal=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            if (s[i]==\\')\\') {\\n                lbal--;\\n                if (lbal < 0){\\n                    lbal = 0;\\n                    last_l_bad_index=i;\\n                }\\n                if (lbal==0){\\n                    last_lbal_index = i;\\n                }\\n            }\\n        }\\n        \\n        int last_r_bad_index=s.length();\\n        int rbal=0;\\n        for (int i=s.length()-1;i>last_lbal_index;i--){\\n            if (s[i]==\\')\\') rbal++;\\n            if (s[i]==\\'(\\') {\\n                rbal--;\\n                if (rbal<0){\\n                    rbal = 0;\\n                    last_r_bad_index = i;\\n                }\\n            }\\n        }\\n        \\n        string balanced_middle = s.substr(last_l_bad_index+1, last_r_bad_index - last_l_bad_index-1); // i.e. from last_l_bad_index+1 to last_r_bad_index-1\\n        \\n        vector<string> ans;\\n        \\n        for (const string& front_ans:solveFront(s.substr(0,last_l_bad_index+1))) {\\n            for (const string& rev_back_ans:solveFront(reverse(s.substr(last_r_bad_index)))){\\n                ans.push_back(front_ans + balanced_middle + reverse(rev_back_ans));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    string reverse(string s){\\n        for (int i=0;i*2+1 < s.length();i++){\\n            swap(s[i], s[s.length()-1-i]);\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if (s[i] ==\\'(\\') s[i] = \\')\\';\\n            else if (s[i]==\\')\\') s[i] = \\'(\\';\\n        }\\n        return s;\\n    }\\n\\n    \\n    unordered_set<string> solveFront(string s) {\\n        vector<int> rparen_loc; // locations of \\')\\'\\n        vector<int> must_delete_before_loc; // an rparen must be deleted before these locations to keep the string left-balanced.\\n        \\n        int lbal=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\'(\\') lbal++;\\n            else if (s[i]==\\')\\'){\\n                rparen_loc.push_back(i);\\n                if (lbal > 0){\\n                    lbal--;\\n                } else {\\n                    must_delete_before_loc.push_back(rparen_loc.size());\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        // now each of these will be a vector of rparen indexes chosen to remove, converted to a proper string later. This is to avoid using the expensive string::erase.\\n        vector<vector<int> > prevans;\\n        \\n        prevans.push_back({});\\n        \\n        for (int n_delete=0;n_delete<must_delete_before_loc.size();n_delete++){\\n            int num_prev = prevans.size();\\n            for (int i=0;i<num_prev;i++){\\n                int start = 0;\\n                if (prevans[i].size() > 0){\\n                    start = prevans[i][n_delete-1]+1; // new delete must be after old deletes of the answer we are building on.\\n                }\\n                for (int i_rparen = start; i_rparen<must_delete_before_loc[n_delete]; i_rparen++){\\n                    if (prevans[i].size()>n_delete){\\n                        // this answer was already modified, so a new vector must be copied.\\n                        vector<int> nans = prevans[i];\\n                        nans[n_delete] = i_rparen;\\n                        prevans.push_back(nans);\\n                    } else {\\n                        // don\\'t copy the first time, just modify the answer.\\n                        prevans[i].push_back(i_rparen);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // we have the answer in a weird form, now we need to get the actual strings\\n        unordered_set<string> all_str_ans;\\n        for (auto ans: prevans){\\n            string str_ans;\\n            int j=0;\\n            for (int i=0;i<s.length();i++){\\n                if (j<ans.size() && rparen_loc[ans[j]] == i){\\n                    // skip this character\\n                    j++;\\n                    continue;\\n                }\\n                \\n                str_ans += s[i];\\n            }\\n            \\n            all_str_ans.insert(str_ans);\\n        }\\n        \\n        return all_str_ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816368,
                "title": "java-dfs-2ms",
                "content": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        int bL,bR;\\n        bL=bR=0; \\n        //bL -> amount of remaining open brackets to be removed\\n        //bR -> amount of remaining closed brackets to be removed\\n        \\n        //PreCalculate  bL and bR to get the \"minimum removed valid string\"\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\') bL++;\\n            else if(s.charAt(i)==\\')\\'){\\n                if(bL>0) bL--;\\n                else bR++;\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        solve(s,res,new StringBuilder(),bL,bR,0,0);\\n        return new ArrayList<>(res);\\n    }\\n    \\n    void solve(String s, Set<String> res, StringBuilder sb, int bL, int bR,int pL, int idx){\\n        \\n        if(idx == s.length() || bL<0 || bR<0 || pL<0){\\n            if(bL==0 && bR==0 && pL==0) res.add(sb.toString());\\n            return;\\n        }\\n        \\n        if(s.charAt(idx) == \\'(\\'){\\n            solve(s,res,sb,bL-1,bR,pL,idx+1); //consider \\'(\\' removing it\\n            sb.append(s.charAt(idx));\\n            solve(s,res,sb,bL,bR,pL+1,idx+1); //dont consider \\'(\\' removing it\\n        }\\n        else if(s.charAt(idx) == \\')\\'){\\n            solve(s,res,sb,bL,bR-1,pL,idx+1); //consider \\')\\' removing it\\n            sb.append(s.charAt(idx));\\n            solve(s,res,sb,bL,bR,pL-1,idx+1);  // don\\'t consider \\')\\' removing it\\n        }\\n        else{\\n            sb.append(s.charAt(idx));\\n            solve(s,res,sb,bL,bR,pL,idx+1);\\n        }\\n        sb.setLength(sb.length()-1); //backtrack\\n    }\\n    //pL -> amount of open paranthesis that need to be closed\\n}\\n```\\n\\nInspired by the following article \\nhttps://leetcode.com/problems/remove-invalid-parentheses/discuss/75038/Evolve-from-intuitive-solution-to-optimal-a-review-of-all-solutions",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        int bL,bR;\\n        bL=bR=0; \\n        //bL -> amount of remaining open brackets to be removed\\n        //bR -> amount of remaining closed brackets to be removed\\n        \\n        //PreCalculate  bL and bR to get the \"minimum removed valid string\"\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\') bL++;\\n            else if(s.charAt(i)==\\')\\'){\\n                if(bL>0) bL--;\\n                else bR++;\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        solve(s,res,new StringBuilder(),bL,bR,0,0);\\n        return new ArrayList<>(res);\\n    }\\n    \\n    void solve(String s, Set<String> res, StringBuilder sb, int bL, int bR,int pL, int idx){\\n        \\n        if(idx == s.length() || bL<0 || bR<0 || pL<0){\\n            if(bL==0 && bR==0 && pL==0) res.add(sb.toString());\\n            return;\\n        }\\n        \\n        if(s.charAt(idx) == \\'(\\'){\\n            solve(s,res,sb,bL-1,bR,pL,idx+1); //consider \\'(\\' removing it\\n            sb.append(s.charAt(idx));\\n            solve(s,res,sb,bL,bR,pL+1,idx+1); //dont consider \\'(\\' removing it\\n        }\\n        else if(s.charAt(idx) == \\')\\'){\\n            solve(s,res,sb,bL,bR-1,pL,idx+1); //consider \\')\\' removing it\\n            sb.append(s.charAt(idx));\\n            solve(s,res,sb,bL,bR,pL-1,idx+1);  // don\\'t consider \\')\\' removing it\\n        }\\n        else{\\n            sb.append(s.charAt(idx));\\n            solve(s,res,sb,bL,bR,pL,idx+1);\\n        }\\n        sb.setLength(sb.length()-1); //backtrack\\n    }\\n    //pL -> amount of open paranthesis that need to be closed\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762947,
                "title": "python-backtracking-solution-faster-than-89-59",
                "content": "I felt like other solutions were not clear so wanted to share my approach in case it helps anyone.\\n\\nThis problem requires an exhaustive search of all possible variations of the input. We need to try every potential combination of the input, verify if it\\'s valid, and append to list of results if it is correct. \\nSince trying every possible variation can be time consuming, we want to try and reduce the \"search space\" as much as possible. We can do this by looking at the original input, and see how many invalid parentheses it has to start with. For example, if the input is already valid, there is no point in exhaustively trying all possibilities. Similarly, if the input has 2 invalid parentheses (for example \"))()\"), there is no point in trying to remove more than 2 parentheses in our exhaustive search. \\n\\nAll possible combinations of the input can be enumerated using BFS or DFS. However, BFS in general will use much more space so DFS is recommended. In practice, I noticed that BFS approach took more than 1000 ms to complete whereas DFS approach can run in under 100 ms. Part of this is because DFS allows you to immediately discard or append a solution and continue processing, whereas for BFS you would have to generate all enumerated combinations and then process them at a later stage. Another way to think about it is that for DFS, the state of search at any given point in time is proportional to the height of the traversal tree from root to the current level. For BFS, the state of the search is the size of the queue, which is proportional to the _width_ of the tree at a given level. In this specific problem, we are essentially checking whether a character is going to be a part of the final correct solution or not. Each character would either be included or not included. We then iterate through the remainder of the string with a given character either included or not included. So the total runtime complexity is O(2^n). This means that the width of a tree at a given level can be on the order of 2^n whereas the height of the tree can be on the order of O(n). Though the Big O runtime would be comparable, such implementation details can be important to consider in practice, especially the amount of memory used. \\n\\nThe code below can be summarized as follows:\\n* Perform an initial traversal of the input string to determine how many invalid left and right parentheses exist. \\n* If there are no invalid parentheses, return early\\n* Traverse through input a second time, given a start position, the number of invalid left parentheses, the number of invalid right parentheses, and the size of the string\\n* For every character in the string, check if it\\'s a left or right parentheses. If it\\'s left or right, and there is still a nonzero number of invalid parentheses that exist in the string, attempt to remove the current character and perform a recursive function call to determine if the result of removing the character would yield a valid result. Do this until there are no more invalid parentheses left. \\n* Once there are no more invalid parentheses left, check if the result is actually balanced. This is necessary because even though there may be no more invalid parentheses, the solution must also be balanced. For example, let\\'s say we have two extra left parenthesis, like in the string \"()()((\". One of the possible combinations may try to remove two left parentheses that were actually valid, yielding a potential result such as \"))((\". Though this answer would not have any remaining parentheses to be removed, it would not be balanced and therefore should not be included as part of the result. \\n```\\n\\t\\tdef num_invalid(s):\\n            num_left = num_right = 0\\n            for char in s:\\n                if char == \"(\":\\n                    num_left += 1\\n                elif char == \")\":\\n                    if num_left > 0:\\n                        num_left -= 1\\n                    else:\\n                        num_right += 1\\n            return [num_left, num_right]\\n        \\n        valid = [0, 0]\\n        # rem_left and rem_right represent the number of left and right parentheses we are allowed to remove \\n        # to meet the requirement of only removing the minimum amount of invalid parentheses\\n        def backtrack(s, ind, size, rem_left, rem_right, result):\\n            if rem_left == 0 and rem_right == 0:\\n                if num_invalid(s) == valid:\\n                    result.append(s)\\n                return\\n            \\n            for i in range(ind, size):\\n                current = s[i]\\n                if i > ind and current == s[i - 1]:\\n                    continue\\n                \\n                if current == \\')\\' and rem_right > 0:\\n                    backtrack(s[:i] + s[i + 1:], i, size - 1, rem_left, rem_right - 1, result)\\n                elif current == \\'(\\' and rem_left > 0:\\n                    backtrack(s[:i] + s[i + 1:], i, size - 1, rem_left - 1, rem_right, result)\\n\\n        l, r = num_invalid(s)\\n        if l == 0 and r == 0:\\n            return [s]\\n        \\n        result = []\\n        backtrack(s, 0, len(s), l, r, result)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tdef num_invalid(s):\\n            num_left = num_right = 0\\n            for char in s:\\n                if char == \"(\":\\n                    num_left += 1\\n                elif char == \")\":\\n                    if num_left > 0:\\n                        num_left -= 1\\n                    else:\\n                        num_right += 1\\n            return [num_left, num_right]\\n        \\n        valid = [0, 0]\\n        # rem_left and rem_right represent the number of left and right parentheses we are allowed to remove \\n        # to meet the requirement of only removing the minimum amount of invalid parentheses\\n        def backtrack(s, ind, size, rem_left, rem_right, result):\\n            if rem_left == 0 and rem_right == 0:\\n                if num_invalid(s) == valid:\\n                    result.append(s)\\n                return\\n            \\n            for i in range(ind, size):\\n                current = s[i]\\n                if i > ind and current == s[i - 1]:\\n                    continue\\n                \\n                if current == \\')\\' and rem_right > 0:\\n                    backtrack(s[:i] + s[i + 1:], i, size - 1, rem_left, rem_right - 1, result)\\n                elif current == \\'(\\' and rem_left > 0:\\n                    backtrack(s[:i] + s[i + 1:], i, size - 1, rem_left - 1, rem_right, result)\\n\\n        l, r = num_invalid(s)\\n        if l == 0 and r == 0:\\n            return [s]\\n        \\n        result = []\\n        backtrack(s, 0, len(s), l, r, result)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 376616,
                "title": "easy-js-solution-speed-97-memory-100",
                "content": "```\\nvar removeInvalidParentheses = function(s) {\\n  const helper = new RemoveInvalid(s);\\n  return helper.options;\\n};\\n\\nclass RemoveInvalid {\\n  constructor(string) {\\n    this.options = [];\\n    this.remove(string, 0, 0, \\'(\\', \\')\\');\\n  }\\n  \\n  remove(string, startI, startJ, open, close) {\\n    let count = 0;\\n    for (let i = startI; i < string.length; i++) {\\n      const char = string[i];\\n      if (char === open) count++;\\n      if (char === close) count--;\\n      \\n      if (count >= 0) continue; // we haven\\'t found a missing parentheses\\n      \\n      // we found an invalid parentheses...\\n      // let\\'s loop over from the startJ and find all the possible substrings\\n      // we can come up with by removing the first possible closing parentheses\\n      for (let j = startJ; j <= i; j++) {\\n        // avoid duplicates by skipping if the prev char was a closing parentheses (since we would have already added it)\\n        if (string[j] === close && (j === startJ || string[j-1] !== close)) { \\n          // i = the index where we found the extra closing parentheses\\n          // j = the index where we removed a closing parenthese to make our substring valid\\n          this.remove(string.substring(0, j) + string.substring(j+1), i, j, open, close);\\n        }\\n      }\\n      // our recursion above will handle all other possible substrings, we can terminate now.\\n      // If we didn\\'t, we would be adding an invalid string to our list of valid options below.\\n      return;\\n    }\\n    \\n    // we need to reverse our string to account for other possible solutions (right to left)\\n    // if we just went right to left, we need to reverse again to get our original string\\n    const reverse = string.split(\\'\\').reverse().join(\\'\\');\\n    if (open === \\'(\\') {\\n      this.remove(reverse, 0, 0, \\')\\', \\'(\\');\\n    } else {\\n      // we\\'ve went left to right, and right to left\\n      // if we got to this point, our string contains no missing parentheses\\n      this.options.push(reverse);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeInvalidParentheses = function(s) {\\n  const helper = new RemoveInvalid(s);\\n  return helper.options;\\n};\\n\\nclass RemoveInvalid {\\n  constructor(string) {\\n    this.options = [];\\n    this.remove(string, 0, 0, \\'(\\', \\')\\');\\n  }\\n  \\n  remove(string, startI, startJ, open, close) {\\n    let count = 0;\\n    for (let i = startI; i < string.length; i++) {\\n      const char = string[i];\\n      if (char === open) count++;\\n      if (char === close) count--;\\n      \\n      if (count >= 0) continue; // we haven\\'t found a missing parentheses\\n      \\n      // we found an invalid parentheses...\\n      // let\\'s loop over from the startJ and find all the possible substrings\\n      // we can come up with by removing the first possible closing parentheses\\n      for (let j = startJ; j <= i; j++) {\\n        // avoid duplicates by skipping if the prev char was a closing parentheses (since we would have already added it)\\n        if (string[j] === close && (j === startJ || string[j-1] !== close)) { \\n          // i = the index where we found the extra closing parentheses\\n          // j = the index where we removed a closing parenthese to make our substring valid\\n          this.remove(string.substring(0, j) + string.substring(j+1), i, j, open, close);\\n        }\\n      }\\n      // our recursion above will handle all other possible substrings, we can terminate now.\\n      // If we didn\\'t, we would be adding an invalid string to our list of valid options below.\\n      return;\\n    }\\n    \\n    // we need to reverse our string to account for other possible solutions (right to left)\\n    // if we just went right to left, we need to reverse again to get our original string\\n    const reverse = string.split(\\'\\').reverse().join(\\'\\');\\n    if (open === \\'(\\') {\\n      this.remove(reverse, 0, 0, \\')\\', \\'(\\');\\n    } else {\\n      // we\\'ve went left to right, and right to left\\n      // if we got to this point, our string contains no missing parentheses\\n      this.options.push(reverse);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996595,
                "title": "remove-invalid-parentheses",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSTEPS : \\n$$1$$ : count min. no. of unwanted brackets are there.\\n$$2$$ : maintain a set so that ans doesn\\'t repeat.\\n$$3$$ : call  Remove_Invalid_Parentheses() function\\n$$4$$ : In function base case is if min. no. of unwanted bracket are 0 then check if my current string is valid or not by simply using same function as we use for finding min. no. of unwanted bracket, $$if(cnt==0)$$ means no  unwanted bracket are there.\\n$$5$$ : maintain a dp unordered map so to reduce recursive calls(btw if u not use this map, it will get TLE ) \\n$$6$$ : break our main string with every \\'(\\' && \\')\\'\\n$$7$$ : call on left + right part of string with cnt-1, also store in dp.\\n$$8$$ : return dp[s] (currstr)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking , dp, stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n!^k)$$ -> n = s.size(), k = min. no. of unwanted brackets\\ncorrect me if i am wrong.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment if you know \\uD83D\\uDE42\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nunordered_map<string,int> dp;\\nint Remove_Invalid_Parentheses(string s,int cnt,set<string>& st){\\n    if(cnt==0){\\n        int minr = solve(s);\\n        if(minr==0){\\n            st.insert(s);\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp.find(s)!=dp.end())return dp[s];\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\')\\'||s[i]==\\'(\\'){\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            dp[left+right] = Remove_Invalid_Parentheses(left+right,cnt-1,st);\\n        }\\n    }\\n    return dp[s];\\n}\\nint solve(string s){\\n    int cnt = 0,n=s.size();\\n    stack<char> st;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }else if(s[i]==\\')\\') {\\n            if(!st.empty()&&st.top()==\\'(\\')st.pop();\\n            else st.push(s[i]);\\n        }\\n    }\\n    return st.size();\\n}\\n\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> v;\\n        int cnt = solve(s);\\n        set<string> st;\\n        Remove_Invalid_Parentheses(s,cnt,st);\\n        while(!st.empty()){\\n            v.push_back(*st.begin());\\n            st.erase(st.begin());\\n        }\\n        cout<<cnt<<endl;\\n        return v;\\n    }\\n};\\n```\\nUpvote If You like it :) \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nunordered_map<string,int> dp;\\nint Remove_Invalid_Parentheses(string s,int cnt,set<string>& st){\\n    if(cnt==0){\\n        int minr = solve(s);\\n        if(minr==0){\\n            st.insert(s);\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp.find(s)!=dp.end())return dp[s];\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\')\\'||s[i]==\\'(\\'){\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            dp[left+right] = Remove_Invalid_Parentheses(left+right,cnt-1,st);\\n        }\\n    }\\n    return dp[s];\\n}\\nint solve(string s){\\n    int cnt = 0,n=s.size();\\n    stack<char> st;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }else if(s[i]==\\')\\') {\\n            if(!st.empty()&&st.top()==\\'(\\')st.pop();\\n            else st.push(s[i]);\\n        }\\n    }\\n    return st.size();\\n}\\n\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> v;\\n        int cnt = solve(s);\\n        set<string> st;\\n        Remove_Invalid_Parentheses(s,cnt,st);\\n        while(!st.empty()){\\n            v.push_back(*st.begin());\\n            st.erase(st.begin());\\n        }\\n        cout<<cnt<<endl;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1949187,
                "title": "explanation-about-dfs-vs-bfs-tradeoffs-outperforming-dfs-solution",
                "content": "Although it may seem obvious BFS is better solution to find the min change, in the interview you may still be better to suggest BFS and DFS and pros and cons.\\n\\nBFS can be good if the required min deletion is small. However if the amount of deletion gets larger and larger the required space increses exponentially very quickly. This may become an issue for some software e.g. embedded device with restricted memory.\\n\\nDFS may look no-go at glance because of the fact that we need to **traverse to the depest variation of the string** (removing all paranthesis) and also **tracking the answers for the level**. However with a very simple optimisation you can drastically improve the performance. The key idea here is to calculate the minimum number of deletion to make the parenthesis in advance, and limit the DFS by that which completely eliminates the two concerns mentioned above. Also `isValid` needs to be invoked only for the candidate cases not for all variants which is another good thing.\\n\\nThe time complexity is same to BFS, but the space complexity becomes O(n) instead of O(2^n). Obviously better solution.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int count = 0;\\n        for(char &c : s) {\\n            if(c == \\'(\\') ++count;\\n            else if(c == \\')\\') --count;\\n            if(count < 0) return false;\\n        }\\n        return count == 0;\\n    }\\n    \\n    string stringWithout(string& s, int idx) {\\n        return s.substr(0, idx) + s.substr(idx+1);\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        // calculate minimum deletion to make correct parentheses\\n        int leftCount = 0;\\n        int rightCount = 0;\\n        for(int i = 0 ; i < s.size() ; ++i) {\\n            if (s[i] == \\'(\\') {\\n                leftCount++;\\n            } else if (s[i] == \\')\\') {\\n                if (leftCount) {\\n                    leftCount--;\\n                } else {\\n                    rightCount++;\\n                }\\n            }\\n        }\\n        \\n        vector<string> answer;\\n        dfsTraverse(s, 0, leftCount, rightCount, answer);\\n        return answer;\\n    }\\n   \\n    void dfsTraverse(string s, int startIdx, int leftCount, int rightCount, vector<string>& answer) {\\n        if (leftCount == 0  && rightCount == 0) {\\n            if (isValid(s)) {\\n                answer.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = startIdx; i < s.size(); ++i) {\\n            // skip visiting duplicated case\\n            if (i != startIdx && s[i] == s[i-1]) continue;\\n            \\n\\t\\t\\t// visit variances where possible\\n            if (s[i] == \\'(\\' && leftCount && !rightCount) {\\n                dfsTraverse(stringWithout(s, i), i, leftCount - 1, rightCount, answer);\\n            } else if (s[i] == \\')\\' && rightCount) {\\n                dfsTraverse(stringWithout(s, i), i, leftCount, rightCount-1, answer);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int count = 0;\\n        for(char &c : s) {\\n            if(c == \\'(\\') ++count;\\n            else if(c == \\')\\') --count;\\n            if(count < 0) return false;\\n        }\\n        return count == 0;\\n    }\\n    \\n    string stringWithout(string& s, int idx) {\\n        return s.substr(0, idx) + s.substr(idx+1);\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        // calculate minimum deletion to make correct parentheses\\n        int leftCount = 0;\\n        int rightCount = 0;\\n        for(int i = 0 ; i < s.size() ; ++i) {\\n            if (s[i] == \\'(\\') {\\n                leftCount++;\\n            } else if (s[i] == \\')\\') {\\n                if (leftCount) {\\n                    leftCount--;\\n                } else {\\n                    rightCount++;\\n                }\\n            }\\n        }\\n        \\n        vector<string> answer;\\n        dfsTraverse(s, 0, leftCount, rightCount, answer);\\n        return answer;\\n    }\\n   \\n    void dfsTraverse(string s, int startIdx, int leftCount, int rightCount, vector<string>& answer) {\\n        if (leftCount == 0  && rightCount == 0) {\\n            if (isValid(s)) {\\n                answer.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = startIdx; i < s.size(); ++i) {\\n            // skip visiting duplicated case\\n            if (i != startIdx && s[i] == s[i-1]) continue;\\n            \\n\\t\\t\\t// visit variances where possible\\n            if (s[i] == \\'(\\' && leftCount && !rightCount) {\\n                dfsTraverse(stringWithout(s, i), i, leftCount - 1, rightCount, answer);\\n            } else if (s[i] == \\')\\' && rightCount) {\\n                dfsTraverse(stringWithout(s, i), i, leftCount, rightCount-1, answer);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555755,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        \\n        def valid(s):\\n            l,r=0,0\\n            for c in s:\\n                if c==\\'(\\':\\n                    l+=1\\n                elif c==\\')\\':\\n                    if  l<=0:\\n                        r+=1\\n                    else:\\n                        l-=1\\n            return not l and not r\\n        \\n        res=[]\\n        seen=set()\\n        level={s}\\n        while True:\\n            newLevel=set()\\n            for word in level:\\n                if valid(word):\\n                    res.append(word)\\n            if res: return res\\n            \\n            for word in level:\\n                for i in range(len(word)):\\n                    if word[i] in \\'()\\':\\n                        newWord=word[:i]+word[i+1:]\\n                        if newWord not in seen:\\n                            seen.add(newWord)\\n                            newLevel.add(newWord)\\n                  \\n            level=newLevel\\n                \\n        return [\"\"]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        \\n        def valid(s):\\n            l,r=0,0\\n            for c in s:\\n                if c==\\'(\\':\\n                    l+=1\\n                elif c==\\')\\':\\n                    if  l<=0:\\n                        r+=1\\n                    else:\\n                        l-=1\\n            return not l and not r\\n        \\n        res=[]\\n        seen=set()\\n        level={s}\\n        while True:\\n            newLevel=set()\\n            for word in level:\\n                if valid(word):\\n                    res.append(word)\\n            if res: return res\\n            \\n            for word in level:\\n                for i in range(len(word)):\\n                    if word[i] in \\'()\\':\\n                        newWord=word[:i]+word[i+1:]\\n                        if newWord not in seen:\\n                            seen.add(newWord)\\n                            newLevel.add(newWord)\\n                  \\n            level=newLevel\\n                \\n        return [\"\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552581,
                "title": "c-simple-explained-solution",
                "content": "/*\\nusing recursion and backtracking: \\nleft: extra \\'(\\'  \\nright : extra \\')\\'\\nFirst count extra left and right, then recursively remove all extra left and extra right and store all possible valid strings we can formed after this:-\\nNOTE:- for each bracket, we have following choices:-\\nfor \\'(\\' :- we not include this only if(left>0) or we include this\\nfor \\')\\' :- we not include this only if(right>0) or we include this\\n\\nfinally if we traversed the whole string and left==0 && right==0 and all perfect pairs formed(p=0) consider it as valid ans\\n\\nTo avoid duplicate answers use unordered_set to store answers, In last ,store unordered_set to ans vector and return\\n*/\\n\\n```\\nclass Solution {\\n  unordered_set<string>st;\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int left=0,right=0;\\n      for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'(\\')\\n          left++;\\n        else if(s[i]==\\')\\'){\\n          if(left>0)\\n            left--;\\n          else\\n            right++;\\n        }\\n      }\\n      \\n      find(0/*index*/, 0/*incomplete pair*/,s,left,right,\"\"/*temp valid ans*/);\\n      \\n      return vector<string>(st.begin(),st.end());\\n    }\\n  \\n    void find(int i,int p,string& s,int left,int right,string temp){\\n      if(i==s.length()){\\n        if(p==0 && left==0 && right==0)\\n        st.insert(temp);\\n        return;\\n      }\\n      \\n      if(s[i]==\\'(\\'){\\n        if(left>0) // so not include this \\n          find(i+1,p,s,left-1,right,temp);\\n        \\n           // include this(after including this , we get one incomplete pair, so increase p)\\n          find(i+1,p+1,s,left,right,temp+s[i]);\\n      }\\n      else if(s[i]==\\')\\'){\\n        if(right>0)  //not include this\\n          find(i+1,p,s,left,right-1,temp);\\n        // include this only if there is any incomplete pair(one pair complete so reduce p)\\n         if(p>0)\\n        find(i+1,p-1,s,left,right,temp+s[i]);\\n      }\\n      else{\\n        // if any alphabat, include this without any tension\\n        find(i+1,p,s,left,right,temp+s[i]);\\n      }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  unordered_set<string>st;\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int left=0,right=0;\\n      for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'(\\')\\n          left++;\\n        else if(s[i]==\\')\\'){\\n          if(left>0)\\n            left--;\\n          else\\n            right++;\\n        }\\n      }\\n      \\n      find(0/*index*/, 0/*incomplete pair*/,s,left,right,\"\"/*temp valid ans*/);\\n      \\n      return vector<string>(st.begin(),st.end());\\n    }\\n  \\n    void find(int i,int p,string& s,int left,int right,string temp){\\n      if(i==s.length()){\\n        if(p==0 && left==0 && right==0)\\n        st.insert(temp);\\n        return;\\n      }\\n      \\n      if(s[i]==\\'(\\'){\\n        if(left>0) // so not include this \\n          find(i+1,p,s,left-1,right,temp);\\n        \\n           // include this(after including this , we get one incomplete pair, so increase p)\\n          find(i+1,p+1,s,left,right,temp+s[i]);\\n      }\\n      else if(s[i]==\\')\\'){\\n        if(right>0)  //not include this\\n          find(i+1,p,s,left,right-1,temp);\\n        // include this only if there is any incomplete pair(one pair complete so reduce p)\\n         if(p>0)\\n        find(i+1,p-1,s,left,right,temp+s[i]);\\n      }\\n      else{\\n        // if any alphabat, include this without any tension\\n        find(i+1,p,s,left,right,temp+s[i]);\\n      }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454039,
                "title": "easy-to-understand-bfs-python-solution",
                "content": "I think BFS suits this problem the best, this is my explaination that helped me understand this problem. \\n\\nThe intuition is simple:\\n1- We want to explore every level using BFS, in every level we want to remove one ( or ); we do that by populating a queue data structure with all possible candidates at one level. \\n2- we evaluate all candidates at that level\\n3- If we find a candidate that returns a vaild expression, then we freeze that level by setting the `variable stay_at_this_level` to True. \\n4- if variable `stay_at_this_level`  is `True`, then we evaluate the rest of the candidates at that level.\\n5- f variable `stay_at_this_level`  is `False`, then we continue to the next level i.e. one less char, and we populate `queue` with all the possible candidates. \\n--> the reason we use stay_at_this_level is we want to find the **minimum number of invalid parentheses to make the input string valid.**\\n\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        \\n        def is_valid(expr):\\n            count = 0\\n            for ch in expr:\\n                if ch in \\'()\\':\\n                    if ch == \\'(\\':\\n                        count += 1\\n                    elif ch == \\')\\':\\n                        count -= 1\\n                    if count < 0:\\n                        return False\\n            return count == 0\\n        \\n        queue = collections.deque()\\n        queue.append(s)\\n        \\n        seen = set()\\n        seen.add(s)\\n        \\n        stay_at_this_level = False\\n        output = []\\n        \\n        while queue:\\n            \\n            expression = queue.popleft()\\n            \\n            if is_valid(expression):\\n                output.append(expression)\\n                stay_at_this_level = True\\n                \\n            elif not stay_at_this_level:\\n                # populate queue with candidiates at the next level i.e. one less ( or )\\n                for i in range(len(expression)):\\n                    \\n                    if expression[i] in \\'()\\':\\n                        candidate = expression[:i] + expression[i+1:]\\n                        \\n                        if candidate not in seen:\\n                            queue.append(candidate)\\n                            seen.add(candidate)\\n                            \\n        return output if output else [\\'\\']\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        \\n        def is_valid(expr):\\n            count = 0\\n            for ch in expr:\\n                if ch in \\'()\\':\\n                    if ch == \\'(\\':\\n                        count += 1\\n                    elif ch == \\')\\':\\n                        count -= 1\\n                    if count < 0:\\n                        return False\\n            return count == 0\\n        \\n        queue = collections.deque()\\n        queue.append(s)\\n        \\n        seen = set()\\n        seen.add(s)\\n        \\n        stay_at_this_level = False\\n        output = []\\n        \\n        while queue:\\n            \\n            expression = queue.popleft()\\n            \\n            if is_valid(expression):\\n                output.append(expression)\\n                stay_at_this_level = True\\n                \\n            elif not stay_at_this_level:\\n                # populate queue with candidiates at the next level i.e. one less ( or )\\n                for i in range(len(expression)):\\n                    \\n                    if expression[i] in \\'()\\':\\n                        candidate = expression[:i] + expression[i+1:]\\n                        \\n                        if candidate not in seen:\\n                            queue.append(candidate)\\n                            seen.add(candidate)\\n                            \\n        return output if output else [\\'\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449422,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    unordered_map<string,int> mp;\\n    \\n    int getMinInValid(string s)\\n    {\\n        stack<char> stck;\\n        int i = 0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                stck.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(stck.size() > 0 && stck.top() == \\'(\\')\\n                    stck.pop();\\n                else\\n                    stck.push(\\')\\');\\n            }\\n            i++;\\n        }\\n        return stck.size();\\n    }\\n    \\n    void solve(string s,int minInv)\\n    {\\n        if(mp[s] != 0)\\n            return;\\n        else\\n            mp[s]++;\\n        \\n        if(minInv == 0)\\n        {\\n            if(!getMinInValid(s))\\n                res.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            solve(left+right, minInv-1);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        solve(s, getMinInValid(s));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    unordered_map<string,int> mp;\\n    \\n    int getMinInValid(string s)\\n    {\\n        stack<char> stck;\\n        int i = 0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                stck.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(stck.size() > 0 && stck.top() == \\'(\\')\\n                    stck.pop();\\n                else\\n                    stck.push(\\')\\');\\n            }\\n            i++;\\n        }\\n        return stck.size();\\n    }\\n    \\n    void solve(string s,int minInv)\\n    {\\n        if(mp[s] != 0)\\n            return;\\n        else\\n            mp[s]++;\\n        \\n        if(minInv == 0)\\n        {\\n            if(!getMinInValid(s))\\n                res.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            solve(left+right, minInv-1);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        solve(s, getMinInValid(s));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429639,
                "title": "getting-tle-can-some-one-please-help",
                "content": "I\\'m not able to understand what is wrong with this code. Individual Test cases are passing but if I submit same tc fails.\\nTC failing - \")x(()())()(\"\\ncause - TLE\\n```\\nclass Solution {\\n    Set<String> res = new HashSet<>();\\n    void backTrack(String str,int minRemoval)\\n    {\\n        if(minRemoval == 0)\\n        {\\n            int minRemovalNow = getMin(str);\\n            if(minRemovalNow == 0)\\n            {\\n                if(!res.contains(str))\\n                {\\n                    res.add(str);\\n                }\\n            }\\n        }\\n        Set <String>test = new HashSet<>();\\n        for(int i = 0;i<str.length();i++)\\n        {\\n            \\n            String right = str.substring(0,i);\\n            String left = str.substring(i+1);\\n            if(test.contains(right+left)) continue;\\n            backTrack(right+left,minRemoval-1);\\n             test.add(right+left);\\n            \\n        }\\n    }\\n    public static int getMin(String str)\\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0;i<str.length();i++)\\n        {\\n            Character ch = str.charAt(i);\\n            if(ch ==\\'(\\')\\n                st.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(st.size()==0)\\n                    st.push(ch);\\n                else if(st.peek()==\\')\\')\\n                    st.push(ch);\\n                else if(st.peek()==\\'(\\')\\n                    st.pop();\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n    public List<String> removeInvalidParentheses(String s) {\\n        \\n        int minRemoval = getMin(s);\\n        backTrack(s,minRemoval);\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> res = new HashSet<>();\\n    void backTrack(String str,int minRemoval)\\n    {\\n        if(minRemoval == 0)\\n        {\\n            int minRemovalNow = getMin(str);\\n            if(minRemovalNow == 0)\\n            {\\n                if(!res.contains(str))\\n                {\\n                    res.add(str);\\n                }\\n            }\\n        }\\n        Set <String>test = new HashSet<>();\\n        for(int i = 0;i<str.length();i++)\\n        {\\n            \\n            String right = str.substring(0,i);\\n            String left = str.substring(i+1);\\n            if(test.contains(right+left)) continue;\\n            backTrack(right+left,minRemoval-1);\\n             test.add(right+left);\\n            \\n        }\\n    }\\n    public static int getMin(String str)\\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0;i<str.length();i++)\\n        {\\n            Character ch = str.charAt(i);\\n            if(ch ==\\'(\\')\\n                st.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(st.size()==0)\\n                    st.push(ch);\\n                else if(st.peek()==\\')\\')\\n                    st.push(ch);\\n                else if(st.peek()==\\'(\\')\\n                    st.pop();\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n    public List<String> removeInvalidParentheses(String s) {\\n        \\n        int minRemoval = getMin(s);\\n        backTrack(s,minRemoval);\\n        return new ArrayList(res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405462,
                "title": "c-faster-than-100",
                "content": "class Solution {\\nprivate:\\n    bool isValid(string s) {\\n        int sum = 0;\\n        for (char& c : s) {\\n            if (c == \\'(\\') ++sum;\\n            else if (c == \\')\\') --sum;\\n            if (sum < 0) return false;\\n        }\\n        return sum == 0;\\n    }\\npublic:\\n    std::vector<string> results;\\n    vector<string> removeInvalidParentheses(string s) {\\n        int left = 0, right = 0;\\n        for (char& c : s) {\\n            if (c == \\'(\\')\\n                ++left;\\n            else if(c == \\')\\'){\\n                if (left == 0)\\n                    ++right;\\n                else if (left > 0) {\\n                    --left;\\n                }\\n            }\\n        }\\n        dfs(s, 0, left, right);\\n        return results;\\n    }\\n    void dfs(string s, int beg, int left, int right) {\\n        if (left == 0 && right == 0) {\\n            if (isValid(s))\\n                results.push_back(s);\\n        }\\n        else {\\n            for (int i = beg; i < s.size(); ++i) {\\n                string tmp = s;\\n                if (right == 0 && left > 0 && tmp[i] == \\'(\\') {\\n                    if (i == beg || tmp[i] != tmp[i - 1]) {\\n                        tmp.erase(i, 1);\\n                        dfs(tmp, i, left - 1, right);\\n                    }\\n                }\\n                if (right > 0 && tmp[i] == \\')\\') {\\n                    if (i == beg || tmp[i] != tmp[i - 1]) {\\n                        tmp.erase(i, 1);\\n                        dfs(tmp, i, left, right - 1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    bool isValid(string s) {\\n        int sum = 0;\\n        for (char& c : s) {\\n            if (c == \\'(\\') ++sum;\\n            else if (c == \\')\\') --sum;\\n            if (sum < 0) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1262942,
                "title": "c-with-explanation-optimised-backtracking-0-ms",
                "content": "**Approach-1**(Backtracking or recursion)\\nFor each opening or closing bracket, we try both combinations of  including it and not including it. We also keep a count variable where if at any stage, we find the number of closing brackets more than the opening brackets, then we return from the search and backtrack to the last valid partial solution or recursion step. We store the solutions in a hashset and also keep a track of the smallest number of deletions till then. We only add the formed string to the result if the number of deletions is same or less. If the number of deletions is less, then we update the global least deletions variable and clear the result and add the newly formed string.\\nTime Complexity->O(2^n)\\nThis is beacuse for each character, we will have to check to include it or not.\\nSpace Complexity->O(n) for the recursion stack.\\n\\n**Approach-2**(Better Backtracking)\\nSince all the parenthesis are of the same type ,we can determine from the string how may opening and closing parenthesis are to be deleted respectively. i.e we can directly find what will the the size of our final string and exactly how may of each type of parenthesis we would want to remove. Once we find this, for each part of the recursion, we only delete a parenthesis if a parenthesis  of such type is still remaining to be deleted. This way, in each string, we save a lot of calcullation as we dont delete unnecessary parenthesis and also once all the required parenthesis are deleted, we dont not  do any further operations than adding the remaining characters. \\n```\\nclass Solution {\\npublic:\\n    unordered_set<string>valid;\\n    \\n    void helper(string curr,int pos,int count,int opening_left,int closing_left,string &s)\\n    {\\n        if(pos==s.length())\\n        {   \\n            if(closing_left==0 and opening_left==0)\\n            {\\n                valid.insert(curr);\\n            }\\n            return;\\n        }\\n        if(count<0)\\n        {\\n            return;\\n        }\\n        \\n        if(s[pos]==\\'(\\')\\n        {   \\n            helper(curr+s[pos],pos+1,count+1,opening_left,closing_left,s);\\n\\n        }\\n        else if(s[pos]==\\')\\')\\n        {\\n            helper(curr+s[pos],pos+1,count-1,opening_left,closing_left,s);\\n        }\\n        else\\n        {\\n            helper(curr+s[pos],pos+1,count,opening_left,closing_left,s);\\n        }\\n        \\n        if(s[pos]==\\'(\\' and opening_left)\\n        {\\n            helper(curr,pos+1,count,opening_left-1,closing_left,s);\\n        }\\n        else if(s[pos]==\\')\\' and closing_left)\\n        {\\n            helper(curr,pos+1,count,opening_left,closing_left-1,s);\\n        }\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        int extra_opening=0,extra_closing=0,count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                count++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                count--;\\n            }\\n            if(count<0)\\n            {   \\n                extra_closing++;\\n                count=0;\\n            }\\n        }\\n        extra_opening+=count;\\n        helper(\"\",0,0,extra_opening,extra_closing,s);\\n        vector<string>res;\\n        for(auto str: valid)\\n        {\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>valid;\\n    \\n    void helper(string curr,int pos,int count,int opening_left,int closing_left,string &s)\\n    {\\n        if(pos==s.length())\\n        {   \\n            if(closing_left==0 and opening_left==0)\\n            {\\n                valid.insert(curr);\\n            }\\n            return;\\n        }\\n        if(count<0)\\n        {\\n            return;\\n        }\\n        \\n        if(s[pos]==\\'(\\')\\n        {   \\n            helper(curr+s[pos],pos+1,count+1,opening_left,closing_left,s);\\n\\n        }\\n        else if(s[pos]==\\')\\')\\n        {\\n            helper(curr+s[pos],pos+1,count-1,opening_left,closing_left,s);\\n        }\\n        else\\n        {\\n            helper(curr+s[pos],pos+1,count,opening_left,closing_left,s);\\n        }\\n        \\n        if(s[pos]==\\'(\\' and opening_left)\\n        {\\n            helper(curr,pos+1,count,opening_left-1,closing_left,s);\\n        }\\n        else if(s[pos]==\\')\\' and closing_left)\\n        {\\n            helper(curr,pos+1,count,opening_left,closing_left-1,s);\\n        }\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        int extra_opening=0,extra_closing=0,count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                count++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                count--;\\n            }\\n            if(count<0)\\n            {   \\n                extra_closing++;\\n                count=0;\\n            }\\n        }\\n        extra_opening+=count;\\n        helper(\"\",0,0,extra_opening,extra_closing,s);\\n        vector<string>res;\\n        for(auto str: valid)\\n        {\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859681,
                "title": "java-94ms-generate-all-valid-sequence-and-keep-only-maxed-length-onces",
                "content": "The backtracking function generates all the valid subsets of parentheses and later it is fillered out.\\n\\nBacktracking logic:\\n```\\ncase 1: neither \\'(\\' nor \\')\\' => We include current character and keep processing\\ncase 2: either \\'(\\' or \\')\\'\\n\\t\\tcase 2.1: run w/o current character\\n\\t\\tcase 2.2: run with current character\\n\\t\\t// keep track of open and close. terminate is close > open\\n```\\n\\nImprovement pending : \\n1. avoid String concatenation in code.\\n2. use cache to improve runtime\\n```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        Set<String> result = new HashSet();\\n        helper(result, \"\", s, 0, 0, 0);\\n        // find max len from result set and eliminate the rest of sequence.\\n        int maxLen = result.stream().map(r->r.length()).max(Integer::compare).get();\\n        return result.stream().filter(r->r.length() == maxLen).collect(Collectors.toList());\\n    }\\n    \\n    public void helper(Set<String> result, String stack, String str, int cur, int open, int close){\\n        if ( close > open ) return;\\n        \\n        if ( cur == str.length() ){\\n            if( close == open )\\n                result.add(stack);\\n            return;\\n        }\\n        \\n        char current = str.charAt(cur);\\n        if ( current == \\')\\' || current == \\'(\\'){\\n            helper(result, stack, str, cur+1, open, close); // w/o\\n            \\n            if ( current == \\'(\\') open++; else close++;\\n            helper(result, stack + String.valueOf(current), str, cur+1, open, close);\\n        }else{\\n            helper(result, stack + String.valueOf(current), str, cur+1, open, close);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ncase 1: neither \\'(\\' nor \\')\\' => We include current character and keep processing\\ncase 2: either \\'(\\' or \\')\\'\\n\\t\\tcase 2.1: run w/o current character\\n\\t\\tcase 2.2: run with current character\\n\\t\\t// keep track of open and close. terminate is close > open\\n```\n```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        Set<String> result = new HashSet();\\n        helper(result, \"\", s, 0, 0, 0);\\n        // find max len from result set and eliminate the rest of sequence.\\n        int maxLen = result.stream().map(r->r.length()).max(Integer::compare).get();\\n        return result.stream().filter(r->r.length() == maxLen).collect(Collectors.toList());\\n    }\\n    \\n    public void helper(Set<String> result, String stack, String str, int cur, int open, int close){\\n        if ( close > open ) return;\\n        \\n        if ( cur == str.length() ){\\n            if( close == open )\\n                result.add(stack);\\n            return;\\n        }\\n        \\n        char current = str.charAt(cur);\\n        if ( current == \\')\\' || current == \\'(\\'){\\n            helper(result, stack, str, cur+1, open, close); // w/o\\n            \\n            if ( current == \\'(\\') open++; else close++;\\n            helper(result, stack + String.valueOf(current), str, cur+1, open, close);\\n        }else{\\n            helper(result, stack + String.valueOf(current), str, cur+1, open, close);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703436,
                "title": "intuitive-recursion-with-concise-analysis",
                "content": "### Recursion\\nHaving analysized examples, it\\'s easy to find out that when the number of *)* is more than *(*, it means the expression is invalid, and we need remove one *)* from the substring we just saw. Once we found a place to remove *)*, we can repeat the same procedure for the remaining substring, which makes us think of using recursion. We split up the string into pieces, each of which is invalid and removed with *)* so that we can have the valid expression at the end. But how to find out which *)* we need to remove?  Taking a look at below examples\\n```\\n// marked the ) to remove\\n()) -> (*)*) -> ()\\n()()) ->  ((*)*)) -> (()),   ()(*)*) ->  ()() \\n) -> *)* ->  \\'\\'\\n```\\nIt\\'s easy to see we can just remove the *)* that is matched with one *(*. or the starting *)*. So we can iterate each position of *)* and just remove one that is just following *(*. We use the variable `lastRemoved` to indicate the starting position for next remove as the remove position might be not limited to current invalid substring. Ex. if we have 2 invalid pieces and need remove 2 *)*, it\\'s possbile to find 2 *)* to remove in one single piece so that both become valid.\\n```\\n()()) ()) -> (*)*(*)*) ()) -> (()())\\n```\\n\\nNote, this procedure only works for cases when *)* is more than *(*, what about `(()`? Naive solution is to call the same procedure with slight difference of treating *(* as *)*, and *)* as *(*. So, we can go through the procedure first for *()* pair, if no parenthesis is removed, then go through it again with *)(*. Last, we put the string to result set which is valid.\\n\\n```python\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ans = []\\n        \\n        def helper(s, index, last_removed, pair):\\n            count = 0\\n            for i in range(index, len(s)):\\n                if s[i] == pair[0]:\\n                    count += 1\\n                if s[i] == pair[1]:\\n                    count -= 1\\n                if count < 0:\\n                    for j in range(last_removed, i + 1):\\n                        if s[j] == pair[1] and (j == last_removed or s[j] != s[j - 1]):\\n                            helper(s[:j] + s[j + 1:], i, j, pair)\\n                    return\\n            if pair[0] == \\'(\\':\\n                helper(s[::-1], 0, 0, pair[::-1])\\n            else:\\n                ans.append(\\'\\'.join(s[::-1]))\\n        helper(s, 0, 0, \\'()\\') \\n        return ans\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n// marked the ) to remove\\n()) -> (*)*) -> ()\\n()()) ->  ((*)*)) -> (()),   ()(*)*) ->  ()() \\n) -> *)* ->  \\'\\'\\n```\n```\\n()()) ()) -> (*)*(*)*) ()) -> (()())\\n```\n```python\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ans = []\\n        \\n        def helper(s, index, last_removed, pair):\\n            count = 0\\n            for i in range(index, len(s)):\\n                if s[i] == pair[0]:\\n                    count += 1\\n                if s[i] == pair[1]:\\n                    count -= 1\\n                if count < 0:\\n                    for j in range(last_removed, i + 1):\\n                        if s[j] == pair[1] and (j == last_removed or s[j] != s[j - 1]):\\n                            helper(s[:j] + s[j + 1:], i, j, pair)\\n                    return\\n            if pair[0] == \\'(\\':\\n                helper(s[::-1], 0, 0, pair[::-1])\\n            else:\\n                ans.append(\\'\\'.join(s[::-1]))\\n        helper(s, 0, 0, \\'()\\') \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 658165,
                "title": "c-bfs-solution",
                "content": "I couldn\\'t solve the question using BFS, this solution is C++ version of this [one](https://leetcode.com/problems/remove-invalid-parentheses/discuss/75032/Share-my-Java-BFS-solution). The idea is to classify the solution into levels, like\\nlevel 0 - no character removed\\nlevel 1 - 1 character removed\\nlevel 2 - 2 characters removed\\n.\\n.\\nAlso each level is traversed completely in one go so that, if solution is obtained there, we need not go to further levels, because we want minimum number of removals.\\n```\\nbool check(string s)\\n{\\n\\tint count = 0;\\n        for (const char ch : s) {\\n            if (ch == \\'(\\') count++;\\n            if (ch == \\')\\') count--;\\n            if (count < 0) return false;\\n        }\\n        return count == 0;\\n}\\nvector<string> removeInvalidParentheses(string s)\\n{\\n\\tqueue<string> q;\\n\\tq.push(s);\\n\\tvector<string> ret;\\n    unordered_set<string> v;\\n\\tint flag=0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint n=q.size();\\n\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t{\\n\\t\\t\\tstring a=q.front();\\n            //cout<<a<<endl;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(check(a))\\n\\t\\t\\t{\\n\\t\\t\\t\\tret.push_back(a);\\n\\t\\t\\t\\tflag=1;// marks the flag whether the solution is found or not\\n\\t\\t\\t}\\n\\t\\t\\telse if(!flag)\\n\\t\\t\\t\\tfor(int j=0;j<a.length();++j)\\n\\t\\t\\t\\t{\\n                    string t=a;\\n\\t\\t\\t\\t\\tif(a[j]==\\'(\\'||a[j]==\\')\\')\\n                    {\\n                        t.erase(j,1);\\n                    }\\n                    else continue;\\n                    if(v.find(t)==v.end())\\n                    {\\n\\t\\t\\t\\t\\t    q.push(t);\\n                        v.insert(t);\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(flag)// if we found solution in this level, no need to go further down.\\n\\t\\t\\tbreak;\\n\\t}\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nbool check(string s)\\n{\\n\\tint count = 0;\\n        for (const char ch : s) {\\n            if (ch == \\'(\\') count++;\\n            if (ch == \\')\\') count--;\\n            if (count < 0) return false;\\n        }\\n        return count == 0;\\n}\\nvector<string> removeInvalidParentheses(string s)\\n{\\n\\tqueue<string> q;\\n\\tq.push(s);\\n\\tvector<string> ret;\\n    unordered_set<string> v;\\n\\tint flag=0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint n=q.size();\\n\\t\\tfor(int i=0;i<n;++i)\\n\\t\\t{\\n\\t\\t\\tstring a=q.front();\\n            //cout<<a<<endl;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(check(a))\\n\\t\\t\\t{\\n\\t\\t\\t\\tret.push_back(a);\\n\\t\\t\\t\\tflag=1;// marks the flag whether the solution is found or not\\n\\t\\t\\t}\\n\\t\\t\\telse if(!flag)\\n\\t\\t\\t\\tfor(int j=0;j<a.length();++j)\\n\\t\\t\\t\\t{\\n                    string t=a;\\n\\t\\t\\t\\t\\tif(a[j]==\\'(\\'||a[j]==\\')\\')\\n                    {\\n                        t.erase(j,1);\\n                    }\\n                    else continue;\\n                    if(v.find(t)==v.end())\\n                    {\\n\\t\\t\\t\\t\\t    q.push(t);\\n                        v.insert(t);\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(flag)// if we found solution in this level, no need to go further down.\\n\\t\\t\\tbreak;\\n\\t}\\n    return ret;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 637749,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        cnt = 0\\n        for c in s:\\n            if c ==\\'(\\':\\n                cnt+=1\\n            elif c==\\')\\':\\n                cnt-=1\\n            if cnt<0:\\n                return False\\n        return cnt==0\\n\\n    def backtrack(self, s, idx, left, right):\\n        if left==0 and right==0:\\n            if self.isValid(s) and (s not in self.res):\\n                self.res.append(s)\\n            return\\n            \\n        for i in range(idx, len(s)):\\n            if s[i]==\\'(\\' and left>0:\\n                self.backtrack(s[:i]+s[i+1:], i, left-1, right)\\n            elif s[i]==\\')\\' and right>0:\\n                self.backtrack(s[:i]+s[i+1:], i, left, right-1)\\n    \\n    \\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        left = right = 0\\n        for c in s:\\n            if c==\\'(\\':\\n                left+=1\\n            elif c==\\')\\':\\n                if left==0:\\n                    right+=1\\n                else:\\n                    left-=1\\n                    \\n        self.res = []\\n        self.backtrack(s, 0, left, right)\\n        return self.res\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, s):\\n        cnt = 0\\n        for c in s:\\n            if c ==\\'(\\':\\n                cnt+=1\\n            elif c==\\')\\':\\n                cnt-=1\\n            if cnt<0:\\n                return False\\n        return cnt==0\\n\\n    def backtrack(self, s, idx, left, right):\\n        if left==0 and right==0:\\n            if self.isValid(s) and (s not in self.res):\\n                self.res.append(s)\\n            return\\n            \\n        for i in range(idx, len(s)):\\n            if s[i]==\\'(\\' and left>0:\\n                self.backtrack(s[:i]+s[i+1:], i, left-1, right)\\n            elif s[i]==\\')\\' and right>0:\\n                self.backtrack(s[:i]+s[i+1:], i, left, right-1)\\n    \\n    \\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        left = right = 0\\n        for c in s:\\n            if c==\\'(\\':\\n                left+=1\\n            elif c==\\')\\':\\n                if left==0:\\n                    right+=1\\n                else:\\n                    left-=1\\n                    \\n        self.res = []\\n        self.backtrack(s, 0, left, right)\\n        return self.res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 567948,
                "title": "super-simple-bfs-python-solution",
                "content": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        \\n        # check if a given string is valid\\n        def isValid (str):\\n            \\n            # if str is empty\\n            if not str:\\n                return True\\n            \\n            count = 0\\n            for char in str:\\n                # if char ( is encountered, increment\\n                if char == \\'(\\':\\n                    count += 1\\n                # if char \\')\\' is encountered, decrement\\n                elif char == \\')\\':\\n                    count -= 1\\n                    # if more closing braces encountered than open, \\n                    # return \\n                    if count < 0:\\n                        return False\\n                    \\n            return count == 0\\n        \\n        # the given string is valid already, return that\\n        if isValid(s):\\n            return [s]\\n\\n        \\n        # given string is not valid, use a set to keep track of elements\\n        bfs_set = {s}\\n        while bfs_set:\\n            \\n            # list to store all valids\\n            valid_list = []\\n            \\n            # if any valid set is encountered in the set, return them\\n            for string in bfs_set:\\n                if isValid(string):\\n                    valid_list.append (string)\\n            \\n            # this is the minimum number of invalid parenthesis required, \\n            # so return this list\\n            if valid_list:\\n                return valid_list\\n            \\n            # next iteration bfs set\\n            next_iter_bfs = set()\\n            \\n            # still invalid huh? do bfs on all possible strings, \\n            # with each character removed\\n            for string in bfs_set:\\n                # iterate over chars and append all possible strings\\n                # after one removal of char\\n                for it in range (len (string)):\\n                    # remove that it, if it\\'s considered a paran\\n                    if string[it] == \\')\\' or string[it] == \\'(\\':\\n                        next_iter_bfs.add (string [0:it] + string [it+1:])\\n                        \\n                        \\n            # make next iter bfs set the current one\\n            bfs_set = next_iter_bfs\\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        \\n        # check if a given string is valid\\n        def isValid (str):\\n            \\n            # if str is empty\\n            if not str:\\n                return True\\n            \\n            count = 0\\n            for char in str:\\n                # if char ( is encountered, increment\\n                if char == \\'(\\':\\n                    count += 1\\n                # if char \\')\\' is encountered, decrement\\n                elif char == \\')\\':\\n                    count -= 1\\n                    # if more closing braces encountered than open, \\n                    # return \\n                    if count < 0:\\n                        return False\\n                    \\n            return count == 0\\n        \\n        # the given string is valid already, return that\\n        if isValid(s):\\n            return [s]\\n\\n        \\n        # given string is not valid, use a set to keep track of elements\\n        bfs_set = {s}\\n        while bfs_set:\\n            \\n            # list to store all valids\\n            valid_list = []\\n            \\n            # if any valid set is encountered in the set, return them\\n            for string in bfs_set:\\n                if isValid(string):\\n                    valid_list.append (string)\\n            \\n            # this is the minimum number of invalid parenthesis required, \\n            # so return this list\\n            if valid_list:\\n                return valid_list\\n            \\n            # next iteration bfs set\\n            next_iter_bfs = set()\\n            \\n            # still invalid huh? do bfs on all possible strings, \\n            # with each character removed\\n            for string in bfs_set:\\n                # iterate over chars and append all possible strings\\n                # after one removal of char\\n                for it in range (len (string)):\\n                    # remove that it, if it\\'s considered a paran\\n                    if string[it] == \\')\\' or string[it] == \\'(\\':\\n                        next_iter_bfs.add (string [0:it] + string [it+1:])\\n                        \\n                        \\n            # make next iter bfs set the current one\\n            bfs_set = next_iter_bfs\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 537217,
                "title": "easy-to-follow-backtracking-more-transparent-than-solutions",
                "content": "The reciepe: \\n1) we need to know how much brackets we have at all, this is how we will limit the combinations\\n2) we do each step following the pattern of the string, by `for-loop`ing on it\\'s characters\\n3) on each step we have two options: include current character or not include. At this point we need only to define restructions for the choises and we are all set.\\n4) when to exit: we reached the end of the string, and succesfull combination only if we have used all the capacity of number of parentheses\\n```\\nvar removeInvalidParentheses = function(s) {\\n    const output = new Set()\\n    \\n    let requiredOpenedNumber = 0\\n    let requiredClosedNumber = 0\\n    let otherCharsNumber = 0\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            requiredOpenedNumber++\\n        } else if (s[i] === \\')\\') {\\n            if (requiredOpenedNumber > requiredClosedNumber) {\\n                requiredClosedNumber++\\n            }\\n        } else {\\n            otherCharsNumber++\\n        }\\n    }\\n    \\n    backtracking(0,s,[],output, requiredClosedNumber, requiredClosedNumber, otherCharsNumber)\\n    \\n    return Array.from(output)\\n};\\n```\\n```\\nconst backtracking = (startIndex, s, current, output, countOpened, countClosed, countChars) => {\\n    \\n    if (countOpened === 0 && countClosed === 0 && countChars === 0) {\\n        output.add(current.join(\\'\\'))\\n        return\\n    }\\n    \\n    for (let i = startIndex; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            if (countOpened > 0) {\\n                current.push(\\'(\\')\\n                backtracking(i+1,s,current,output,countOpened - 1,countClosed,countChars)\\n                current.pop()\\n            }\\n        } else if (s[i] === \\')\\') {            \\n            if (countOpened < countClosed) {\\n                current.push(\\')\\')\\n                backtracking(i+1,s,current,output,countOpened,countClosed - 1,countChars)\\n                current.pop()\\n            }\\n        } else {\\n            current.push(s[i])\\n            backtracking(i+1,s,current,output,countOpened,countClosed,countChars - 1)\\n            current.pop()\\n        }\\n        \\n    }\\n}\\n```\\nHope it helps.",
                "solutionTags": [],
                "code": "```\\nvar removeInvalidParentheses = function(s) {\\n    const output = new Set()\\n    \\n    let requiredOpenedNumber = 0\\n    let requiredClosedNumber = 0\\n    let otherCharsNumber = 0\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            requiredOpenedNumber++\\n        } else if (s[i] === \\')\\') {\\n            if (requiredOpenedNumber > requiredClosedNumber) {\\n                requiredClosedNumber++\\n            }\\n        } else {\\n            otherCharsNumber++\\n        }\\n    }\\n    \\n    backtracking(0,s,[],output, requiredClosedNumber, requiredClosedNumber, otherCharsNumber)\\n    \\n    return Array.from(output)\\n};\\n```\n```\\nconst backtracking = (startIndex, s, current, output, countOpened, countClosed, countChars) => {\\n    \\n    if (countOpened === 0 && countClosed === 0 && countChars === 0) {\\n        output.add(current.join(\\'\\'))\\n        return\\n    }\\n    \\n    for (let i = startIndex; i < s.length; i++) {\\n        if (s[i] === \\'(\\') {\\n            if (countOpened > 0) {\\n                current.push(\\'(\\')\\n                backtracking(i+1,s,current,output,countOpened - 1,countClosed,countChars)\\n                current.pop()\\n            }\\n        } else if (s[i] === \\')\\') {            \\n            if (countOpened < countClosed) {\\n                current.push(\\')\\')\\n                backtracking(i+1,s,current,output,countOpened,countClosed - 1,countChars)\\n                current.pop()\\n            }\\n        } else {\\n            current.push(s[i])\\n            backtracking(i+1,s,current,output,countOpened,countClosed,countChars - 1)\\n            current.pop()\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386768,
                "title": "java-2-solutions-backtrack-with-pruning-and-bfs",
                "content": "**Backtrack solution** \\nInspired by the hints\\n\\n```\\nclass Solution {\\n\\n    Set<String> res = new HashSet<>();\\n    Deque<Character> stack = new LinkedList();\\n    int wrongLeft = 0, wrongRight = 0;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        preprocess(s);\\n        helper(\"\", s, wrongLeft, wrongRight);\\n        return res.stream().collect(Collectors.toList());\\n    }\\n    \\n    // find number of misplaced lefts and rights\\n    void preprocess(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    wrongRight++;\\n                } else {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        while (!stack.isEmpty()) {\\n            stack.pop();\\n            wrongLeft++;\\n        }\\n    }\\n    \\n    void helper(String prefix, String remaining, int leftQuota, int rightQuota) {\\n        if (leftQuota + rightQuota == 0) {\\n            String candidate = prefix + remaining;\\n            if (isValid(candidate) ) {\\n                res.add(candidate);\\n            }\\n            return;\\n        }\\n        if (\"\".equals(remaining)) {\\n            return;\\n        }\\n        char charEvaluated = remaining.charAt(0);\\n        String newRemaining = remaining.substring(1);\\n        // other chars\\n        if (charEvaluated != \\'(\\' &&charEvaluated != \\')\\') {\\n            helper(prefix + charEvaluated, newRemaining, leftQuota, rightQuota);\\n            return;\\n        }\\n\\n        // retain this parenthesis\\n        helper(prefix + charEvaluated, newRemaining, leftQuota, rightQuota);\\n        \\n        // discard this parenthesis\\n        if (charEvaluated == \\'(\\') {\\n            leftQuota--;\\n        } else {\\n            rightQuota--;\\n        }\\n        helper(prefix, newRemaining, leftQuota, rightQuota);\\n    }\\n    \\n    boolean isValid(String str) {\\n        stack.clear();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty() || stack.peek() != \\'(\\') {\\n                    return false;\\n                }\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```\\n\\n\\n**BFS solution**\\nOne of the comments reminded me that shortest path in search problems normally should be approached with BFS. So here\\'s one.\\n\\n```\\nclass Solution {\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        Set<String> res = new HashSet<>();\\n        boolean found = false;\\n        Deque<String> q = new LinkedList<>();\\n        q.offer(s);\\n        while (!q.isEmpty()) {\\n            int len = q.size();\\n            Set<String> nextLevel = new HashSet<>();\\n            while (len-- > 0) {\\n                String str = q.poll();\\n                if (isValid(str)) {\\n                    found = true;\\n                    res.add(str);\\n                }\\n                if (!found) {\\n                    for (int i = 0; i < str.length(); i++) {\\n                        nextLevel.add(new StringBuilder(str).deleteCharAt(i).toString());\\n                    }\\n                }\\n            }\\n            if (found) {\\n                break;\\n            } else {\\n                q.addAll(nextLevel);\\n            }\\n        }\\n        return res.stream().collect(Collectors.toList());\\n    }\\n    \\n    static Deque<Character> stack = new LinkedList<>();\\n    static boolean isValid(String str) {\\n        stack.clear();\\n        for (char c : str.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty() || stack.peek() != \\'(\\') {\\n                    return false;\\n                } else {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    Set<String> res = new HashSet<>();\\n    Deque<Character> stack = new LinkedList();\\n    int wrongLeft = 0, wrongRight = 0;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        preprocess(s);\\n        helper(\"\", s, wrongLeft, wrongRight);\\n        return res.stream().collect(Collectors.toList());\\n    }\\n    \\n    // find number of misplaced lefts and rights\\n    void preprocess(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    wrongRight++;\\n                } else {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        while (!stack.isEmpty()) {\\n            stack.pop();\\n            wrongLeft++;\\n        }\\n    }\\n    \\n    void helper(String prefix, String remaining, int leftQuota, int rightQuota) {\\n        if (leftQuota + rightQuota == 0) {\\n            String candidate = prefix + remaining;\\n            if (isValid(candidate) ) {\\n                res.add(candidate);\\n            }\\n            return;\\n        }\\n        if (\"\".equals(remaining)) {\\n            return;\\n        }\\n        char charEvaluated = remaining.charAt(0);\\n        String newRemaining = remaining.substring(1);\\n        // other chars\\n        if (charEvaluated != \\'(\\' &&charEvaluated != \\')\\') {\\n            helper(prefix + charEvaluated, newRemaining, leftQuota, rightQuota);\\n            return;\\n        }\\n\\n        // retain this parenthesis\\n        helper(prefix + charEvaluated, newRemaining, leftQuota, rightQuota);\\n        \\n        // discard this parenthesis\\n        if (charEvaluated == \\'(\\') {\\n            leftQuota--;\\n        } else {\\n            rightQuota--;\\n        }\\n        helper(prefix, newRemaining, leftQuota, rightQuota);\\n    }\\n    \\n    boolean isValid(String str) {\\n        stack.clear();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty() || stack.peek() != \\'(\\') {\\n                    return false;\\n                }\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n        Set<String> res = new HashSet<>();\\n        boolean found = false;\\n        Deque<String> q = new LinkedList<>();\\n        q.offer(s);\\n        while (!q.isEmpty()) {\\n            int len = q.size();\\n            Set<String> nextLevel = new HashSet<>();\\n            while (len-- > 0) {\\n                String str = q.poll();\\n                if (isValid(str)) {\\n                    found = true;\\n                    res.add(str);\\n                }\\n                if (!found) {\\n                    for (int i = 0; i < str.length(); i++) {\\n                        nextLevel.add(new StringBuilder(str).deleteCharAt(i).toString());\\n                    }\\n                }\\n            }\\n            if (found) {\\n                break;\\n            } else {\\n                q.addAll(nextLevel);\\n            }\\n        }\\n        return res.stream().collect(Collectors.toList());\\n    }\\n    \\n    static Deque<Character> stack = new LinkedList<>();\\n    static boolean isValid(String str) {\\n        stack.clear();\\n        for (char c : str.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty() || stack.peek() != \\'(\\') {\\n                    return false;\\n                } else {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352370,
                "title": "dfs-w-pre-processing-backtrack-w-stringbuilder-1ms-java-solution-beating-100",
                "content": "I believe that the code with comments should be self-explanatory enough. Let me know if you have any doubt or suggestion on possible optimization.\\n```java\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> rst = new ArrayList<>();\\n        // record the number of excessive ( and excessive )\\n        int l = 0, r = 0;\\n        int len = s.length();\\n\\n        // pre-processing: find out the number of excessive ( and ) that needs to be\\n        // removed to make parentheses become valid\\n        for (int i = 0; i < len; ++i) {\\n            char curr = s.charAt(i);\\n\\n            // in case current char is \"(\"\\n            if (curr == \\'(\\') ++l;\\n            // in case current char is \")\"\\n            else if (curr == \\')\\') {\\n                // subcase 1: there is a \"(\" on the left to pair with this \")\"\\n                if (l > 0) --l;\\n\\n                // subcase 2: currently all \"(\" have been used to pair with previous \")\"\\n                // then this is an excessive \")\" as not \"(\" can be used to pair with it\\n                else if (l == 0) ++r;\\n            }\\n        }\\n\\n        // based on tempate for combination, slightly changed\\n        dfs(s, 0, len, l, r, 0, new StringBuilder(), rst);\\n        return rst;\\n    }\\n\\n    private void dfs(String s, int startIdx, int len, int l, int r, int balance, StringBuilder sb, List<String> rst) {\\n        for (int i = startIdx; i < len; ++i) {\\n\\n            // in case current string is unbalanced, prune it\\n            if (balance < 0) return;\\n\\n            char curr = s.charAt(i);\\n\\n            // in case this is the first of duplicates \\'(\\', then we probably need\\n            // need to remove it to get rid of excessive \"(\" and \")\"\\n            if (i == startIdx || curr != s.charAt(i - 1)) {\\n                // NOTE: remove \")\" first before removing \"(\"\\n                if (r > 0 && curr == \\')\\') {\\n                    int size = sb.length();\\n                    dfs(s, i + 1, len, l, r - 1, balance, sb, rst);\\n                    // backtrack\\n                    sb.setLength(size);\\n                }\\n                // similarly, remove \"(\"\\n                else if (l > 0 && curr == \\'(\\') {\\n                    int size = sb.length();\\n                    dfs(s, i + 1, len, l - 1, r, balance, sb, rst);\\n                    // backtrack\\n                    sb.setLength(size);\\n                }\\n            }\\n            // add current character to string builder\\n            sb.append(curr);\\n\\n            // update the balance\\n            if (curr == \\'(\\') ++balance;\\n            if (curr == \\')\\') --balance;\\n        }\\n\\n        // add string to final result list\\n        if (l == 0 && r == 0 && balance == 0) rst.add(sb.toString());\\n    }\\n}\\n```\\nHappy Coding",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> rst = new ArrayList<>();\\n        // record the number of excessive ( and excessive )\\n        int l = 0, r = 0;\\n        int len = s.length();\\n\\n        // pre-processing: find out the number of excessive ( and ) that needs to be\\n        // removed to make parentheses become valid\\n        for (int i = 0; i < len; ++i) {\\n            char curr = s.charAt(i);\\n\\n            // in case current char is \"(\"\\n            if (curr == \\'(\\') ++l;\\n            // in case current char is \")\"\\n            else if (curr == \\')\\') {\\n                // subcase 1: there is a \"(\" on the left to pair with this \")\"\\n                if (l > 0) --l;\\n\\n                // subcase 2: currently all \"(\" have been used to pair with previous \")\"\\n                // then this is an excessive \")\" as not \"(\" can be used to pair with it\\n                else if (l == 0) ++r;\\n            }\\n        }\\n\\n        // based on tempate for combination, slightly changed\\n        dfs(s, 0, len, l, r, 0, new StringBuilder(), rst);\\n        return rst;\\n    }\\n\\n    private void dfs(String s, int startIdx, int len, int l, int r, int balance, StringBuilder sb, List<String> rst) {\\n        for (int i = startIdx; i < len; ++i) {\\n\\n            // in case current string is unbalanced, prune it\\n            if (balance < 0) return;\\n\\n            char curr = s.charAt(i);\\n\\n            // in case this is the first of duplicates \\'(\\', then we probably need\\n            // need to remove it to get rid of excessive \"(\" and \")\"\\n            if (i == startIdx || curr != s.charAt(i - 1)) {\\n                // NOTE: remove \")\" first before removing \"(\"\\n                if (r > 0 && curr == \\')\\') {\\n                    int size = sb.length();\\n                    dfs(s, i + 1, len, l, r - 1, balance, sb, rst);\\n                    // backtrack\\n                    sb.setLength(size);\\n                }\\n                // similarly, remove \"(\"\\n                else if (l > 0 && curr == \\'(\\') {\\n                    int size = sb.length();\\n                    dfs(s, i + 1, len, l - 1, r, balance, sb, rst);\\n                    // backtrack\\n                    sb.setLength(size);\\n                }\\n            }\\n            // add current character to string builder\\n            sb.append(curr);\\n\\n            // update the balance\\n            if (curr == \\'(\\') ++balance;\\n            if (curr == \\')\\') --balance;\\n        }\\n\\n        // add string to final result list\\n        if (l == 0 && r == 0 && balance == 0) rst.add(sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308256,
                "title": "java-solution-using-bfs",
                "content": "The idea is quite simple. \\n* We use BFS to find the neighbors of string s which are strings with less one character. We only remove \\'(\\' or \\')\\' characters when we search for neighbors.\\n* Once we find a string that has matching parenthesis, we know the correct length for the solution strings since BFS will give us all strings of that length.\\n* We can use a boolean flag to tell us when to stop searching (stoping search means that we stop adding strings to our queue). We stop search when we find a valid solution. \\n* It\\'s easy to check if a string is valid using a stack as shown below.\\n\\nProblem Nuances:\\n* Use a set to store solutions found since there could be duplicate solutions\\n* Use a set to store which strings have been visisted to avoid checking the same strings again and again (very simple caching- this would be called memoization if done using DFS)\\n\\n```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if(s == null || s.length() == 0) {\\n            ans.add(\"\");\\n            return ans;\\n        }\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(s);\\n        boolean flag = false;\\n        Set<String> set = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        while(!queue.isEmpty()) {\\n            int level = queue.size();\\n            for(int i = 0; i <= level - 1; i++) {\\n                String top = queue.poll();\\n                if(visited.contains(top)) continue;\\n                if(checkValid(top)) {\\n                    flag = true;\\n                    set.add(top);\\n                }\\n                if(!flag) {\\n                    visited.add(top);\\n                    for(int j = 0; j <= top.length() - 1; j++) {\\n                       char curr = top.charAt(j);\\n                       if(curr != \\'(\\' && curr != \\')\\') continue;\\n                       String add = top.substring(0, j) + top.substring(j+1, top.length());\\n                       queue.add(add);\\n                   } \\n                }\\n            }\\n            if(flag) break;\\n        }\\n        ans.addAll(set);\\n        return ans;\\n    }\\n    \\n    public boolean checkValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(\\'(\\');\\n            } else if(ch == \\')\\') {\\n                if(stack.size() == 0) return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if(s == null || s.length() == 0) {\\n            ans.add(\"\");\\n            return ans;\\n        }\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(s);\\n        boolean flag = false;\\n        Set<String> set = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        while(!queue.isEmpty()) {\\n            int level = queue.size();\\n            for(int i = 0; i <= level - 1; i++) {\\n                String top = queue.poll();\\n                if(visited.contains(top)) continue;\\n                if(checkValid(top)) {\\n                    flag = true;\\n                    set.add(top);\\n                }\\n                if(!flag) {\\n                    visited.add(top);\\n                    for(int j = 0; j <= top.length() - 1; j++) {\\n                       char curr = top.charAt(j);\\n                       if(curr != \\'(\\' && curr != \\')\\') continue;\\n                       String add = top.substring(0, j) + top.substring(j+1, top.length());\\n                       queue.add(add);\\n                   } \\n                }\\n            }\\n            if(flag) break;\\n        }\\n        ans.addAll(set);\\n        return ans;\\n    }\\n    \\n    public boolean checkValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(\\'(\\');\\n            } else if(ch == \\')\\') {\\n                if(stack.size() == 0) return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280177,
                "title": "2ms-java-intuitive-dfs-no-set-no-reverse",
                "content": "During the DFS, if the result we are building is still valid, for the current char we have two options: \\n1. take it\\n2. skip it\\n\\nWe can brainlessly take any element, because we have validation at each recursion step.\\nThe key question is when to skip an element.\\nTo meet the requirement of getting valid ones with minimum removal, we should:\\n* Only remove when neccessary. That means, only skip when there is still a misplaced bracket.\\n* So we should count the number of misplaced brackets in advance.\\n\\nTo speed up:\\n*  Don\\'t get a potential result first, then throw it into a Set. This is slow.\\n*  Avoid duplicate processing in advance.\\n\\nThe duplicate results could only be caused by skipping identical elememts.\\n* For xxAAxx, the result is the same if you skip the first or the second A.\\n\\nSo, to avoid duplicate in advance:\\n* For xxAAxx, we could only skip the second A if the first A is not skipped.\\n* This is to check` s.charAt(i) == sb.charAt(sb.length() - 1)`\\n\\n```\\nclass Solution { // DFS\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList();\\n        if (s == null) return res;\\n        \\n        // count misplaced parentheses\\n        int left = 0, right = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') left += 1;\\n            else if (c == \\')\\' && left > 0) left -= 1;\\n            else if (c == \\')\\') right += 1;\\n        }\\n        \\n        dfs(0, new StringBuilder(), 0, left + right, s, res);\\n        return res;\\n    }\\n    \\n    private void dfs(int i, StringBuilder sb, int left, int mis, String s, List<String> res) { // take when possible\\n        if (i == s.length() && left == 0) { // complete\\n            res.add(sb.toString());\\n        } else if (i <s.length() && left >= 0) { // process while valid\\n            char c = s.charAt(i);\\n            int  leftChange = c == \\'(\\' ? 1 : c == \\')\\' ? -1 : 0;\\n            sb.append(c);\\n            dfs(i + 1, sb, left + leftChange, mis, s, res); // take\\n            sb.deleteCharAt(sb.length() - 1);\\n            if (mis > 0 && !(sb.length() > 0 && s.charAt(i) == sb.charAt(sb.length() - 1)) && (c == \\')\\' || c == \\'(\\')) {\\n                dfs(i + 1, sb, left, mis - 1, s, res); // skip\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution { // DFS\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList();\\n        if (s == null) return res;\\n        \\n        // count misplaced parentheses\\n        int left = 0, right = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') left += 1;\\n            else if (c == \\')\\' && left > 0) left -= 1;\\n            else if (c == \\')\\') right += 1;\\n        }\\n        \\n        dfs(0, new StringBuilder(), 0, left + right, s, res);\\n        return res;\\n    }\\n    \\n    private void dfs(int i, StringBuilder sb, int left, int mis, String s, List<String> res) { // take when possible\\n        if (i == s.length() && left == 0) { // complete\\n            res.add(sb.toString());\\n        } else if (i <s.length() && left >= 0) { // process while valid\\n            char c = s.charAt(i);\\n            int  leftChange = c == \\'(\\' ? 1 : c == \\')\\' ? -1 : 0;\\n            sb.append(c);\\n            dfs(i + 1, sb, left + leftChange, mis, s, res); // take\\n            sb.deleteCharAt(sb.length() - 1);\\n            if (mis > 0 && !(sb.length() > 0 && s.charAt(i) == sb.charAt(sb.length() - 1)) && (c == \\')\\' || c == \\'(\\')) {\\n                dfs(i + 1, sb, left, mis - 1, s, res); // skip\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269162,
                "title": "bfs-and-dfs-solutions-in-python",
                "content": "```\\n    # DFS\\n    def removeInvalidParentheses(self, s):\\n        res = []\\n        self.DFS(s, set([s]), res)\\n        return res\\n    \\n    def DFS(self, s, visited, res):\\n        num_mismatched = self.calc(s)\\n        if num_mismatched==0:\\n            res.append(s)\\n        else:\\n            for i, c in enumerate(s):\\n                if c in \\'()\\':\\n                    new_s = s[:i] + s[i+1:]\\n                    if new_s not in visited and self.calc(new_s) < num_mismatched:\\n                        visited.add(new_s)\\n                        self.DFS(new_s, visited, res)\\n\\n    # BFS\\n   def removeInvalidParentheses(self, s):\\n        res = []\\n        visited = set([s])\\n        queue = collections.deque([s])\\n        while queue:\\n            cur = queue.popleft()\\n            num_mismatched = self.calc(cur)\\n            if num_mismatched == 0:\\n                res.append(cur)    \\n            else:   \\n                for i, c in enumerate(cur):\\n                    if c in \\'()\\':\\n                        new_s = cur[:i] + cur[i+1:]\\n                        if new_s not in visited and self.calc(new_s) < num_mismatched:\\n                            visited.add(new_s)\\n                            queue.append(new_s)\\n        return res\\n\\t\\t\\n   def calc(self, s):\\n        a = b = 0\\n        for c in s:\\n            a += {\\'(\\': 1, \\')\\': -1}.get(c, 0)\\n            b += (a < 0)  # b counts for mismatched right bracket\\n            a = max(a, 0) # a counts for mismatched left bracket\\n        return a+b\\n```",
                "solutionTags": [],
                "code": "```\\n    # DFS\\n    def removeInvalidParentheses(self, s):\\n        res = []\\n        self.DFS(s, set([s]), res)\\n        return res\\n    \\n    def DFS(self, s, visited, res):\\n        num_mismatched = self.calc(s)\\n        if num_mismatched==0:\\n            res.append(s)\\n        else:\\n            for i, c in enumerate(s):\\n                if c in \\'()\\':\\n                    new_s = s[:i] + s[i+1:]\\n                    if new_s not in visited and self.calc(new_s) < num_mismatched:\\n                        visited.add(new_s)\\n                        self.DFS(new_s, visited, res)\\n\\n    # BFS\\n   def removeInvalidParentheses(self, s):\\n        res = []\\n        visited = set([s])\\n        queue = collections.deque([s])\\n        while queue:\\n            cur = queue.popleft()\\n            num_mismatched = self.calc(cur)\\n            if num_mismatched == 0:\\n                res.append(cur)    \\n            else:   \\n                for i, c in enumerate(cur):\\n                    if c in \\'()\\':\\n                        new_s = cur[:i] + cur[i+1:]\\n                        if new_s not in visited and self.calc(new_s) < num_mismatched:\\n                            visited.add(new_s)\\n                            queue.append(new_s)\\n        return res\\n\\t\\t\\n   def calc(self, s):\\n        a = b = 0\\n        for c in s:\\n            a += {\\'(\\': 1, \\')\\': -1}.get(c, 0)\\n            b += (a < 0)  # b counts for mismatched right bracket\\n            a = max(a, 0) # a counts for mismatched left bracket\\n        return a+b\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 248938,
                "title": "java-easy-to-understand-backtrack-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> list = new ArrayList<String>();\\n\\t\\thelper(list, s, 0, 0, 0, \\'(\\', \\')\\',false);\\n\\t\\treturn list;\\n    }\\n    \\n    public void helper(List<String> list, String s, int balance, int index, int last, char first, char second, boolean reversed) {\\n        if (index >= s.length()) {\\n            if (!reversed) {\\n                helper(list, new StringBuilder(s).reverse().toString(), 0, 0, 0,\\')\\', \\'(\\', true);\\n            }\\n            else {\\n                list.add(new StringBuilder(s).reverse().toString());\\n            }\\n            return;                         \\n        }\\n        // check the balance to maintain valid \\n        if (s.charAt(index) == first) {\\n\\t\\t\\tbalance++;\\n\\t\\t} \\n\\t\\tif (s.charAt(index) == second) {\\n\\t\\t\\tbalance--;\\n        }\\n        if (balance >= 0){\\n            helper(list, s, balance, index + 1, last, first, second, reversed);\\n        }\\n        else {\\n            for (int i = last; i <= index; i++){\\n                if (s.charAt(i) == second && (i == 0 || s.charAt(i - 1) != second)) {\\n                    helper(list, s.substring(0, i) + s.substring(i + 1, s.length()), balance + 1, index, i, first, second, reversed);\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> list = new ArrayList<String>();\\n\\t\\thelper(list, s, 0, 0, 0, \\'(\\', \\')\\',false);\\n\\t\\treturn list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 227076,
                "title": "n-3-dp-solution-8ms",
                "content": "I have to say DP should be the right approach to this problem\\n\\nThe idea is: f[i][j] means the longest valid sub string in index range [i,j]\\n1. f[i][j] = max(f[i][j], f[i][k] + f[k+1][j]) // k should be in range [i,j-1]\\n2. f[i][j] = max(f[i][j], \"(\" + f[i+1][j-1] + \")\")  // When s[i] = \\'(\\' and s[j] = \\')\\'\\n\\nThe time complexity should be n^3 then. To avoid duplicate solution, I used set to store answers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.length();\\n        if (n==0) return vector<string>(1, \"\");\\n        \\n        vector<vector<set<string>>> f(n,vector<set<string>>(n));\\n        \\n        for (int i = 0; i<n; ++i) {\\n            if (s[i] == \\'(\\' || s[i] == \\')\\') f[i][i].insert(\"\");\\n            else {\\n                string t = \"\";\\n                t += s[i];\\n                f[i][i].insert(t);\\n            }\\n        }\\n        \\n        for (int i = 2; i<=n; ++i) {\\n            for (int j = 0; j<=n-i; ++j) {\\n                int l = j;\\n                int r = j+i-1;\\n                f[l][r].clear();\\n                f[l][r].insert(\"\");\\n                if (s[l] == \\'(\\' && s[r] == \\')\\') {\\n                    if (l+1==r) {\\n                        f[l][r].clear();\\n                        f[l][r].insert(\"()\");\\n                    } else {\\n                        for (string t : f[l+1][r-1]) {\\n                            string tt = \"(\" + t + \")\";\\n                            if (tt.length() > f[l][r].begin()->length()) {\\n                                f[l][r].clear();\\n                                f[l][r].insert(tt);\\n                            } else if (tt.length() == f[l][r].begin()->length()) {\\n                                f[l][r].insert(tt);\\n                            }\\n                        }    \\n                    }\\n                }\\n                for (int k = l; k<r; ++k) {\\n                    for (string t1 : f[l][k]) {\\n                        for (string t2 : f[k+1][r]) {\\n                            string tt = t1+t2;\\n                            if (tt.length() > f[l][r].begin()->length()) {\\n                                f[l][r].clear();\\n                                f[l][r].insert(tt);\\n                            } else if (tt.length() == f[l][r].begin()->length()) {\\n                                f[l][r].insert(tt);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> res(f[0][n-1].begin(), f[0][n-1].end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.length();\\n        if (n==0) return vector<string>(1, \"\");\\n        \\n        vector<vector<set<string>>> f(n,vector<set<string>>(n));\\n        \\n        for (int i = 0; i<n; ++i) {\\n            if (s[i] == \\'(\\' || s[i] == \\')\\') f[i][i].insert(\"\");\\n            else {\\n                string t = \"\";\\n                t += s[i];\\n                f[i][i].insert(t);\\n            }\\n        }\\n        \\n        for (int i = 2; i<=n; ++i) {\\n            for (int j = 0; j<=n-i; ++j) {\\n                int l = j;\\n                int r = j+i-1;\\n                f[l][r].clear();\\n                f[l][r].insert(\"\");\\n                if (s[l] == \\'(\\' && s[r] == \\')\\') {\\n                    if (l+1==r) {\\n                        f[l][r].clear();\\n                        f[l][r].insert(\"()\");\\n                    } else {\\n                        for (string t : f[l+1][r-1]) {\\n                            string tt = \"(\" + t + \")\";\\n                            if (tt.length() > f[l][r].begin()->length()) {\\n                                f[l][r].clear();\\n                                f[l][r].insert(tt);\\n                            } else if (tt.length() == f[l][r].begin()->length()) {\\n                                f[l][r].insert(tt);\\n                            }\\n                        }    \\n                    }\\n                }\\n                for (int k = l; k<r; ++k) {\\n                    for (string t1 : f[l][k]) {\\n                        for (string t2 : f[k+1][r]) {\\n                            string tt = t1+t2;\\n                            if (tt.length() > f[l][r].begin()->length()) {\\n                                f[l][r].clear();\\n                                f[l][r].insert(tt);\\n                            } else if (tt.length() == f[l][r].begin()->length()) {\\n                                f[l][r].insert(tt);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> res(f[0][n-1].begin(), f[0][n-1].end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75040,
                "title": "c-backtrack-bfs-easy-to-understand",
                "content": "**Solution 1**\\n\\nBrute force, 196ms.\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string>res;\\n        int minMove = INT_MAX;\\n        backtrack(res, s, 0, 0, minMove);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string s, int pos, int move, int& minMove){\\n        if(pos > s.size() || move > minMove) return;\\n        if(isValid(s)){\\n            if(move < minMove) res.clear(), res.push_back(s), minMove = move;\\n            else if(move == minMove && find(res.begin(), res.end(), s) == res.end()) res.push_back(s);\\n            return;\\n        }\\n        while(pos < s.size() && s[pos] != '(' && s[pos] != ')') pos++;\\n        if(pos >= s.size()) return;\\n        backtrack(res, s.substr(0, pos) + s.substr(pos + 1), pos, move + 1, minMove);\\n        backtrack(res, s, pos + 1, move, minMove);\\n    }\\n    \\n    bool isValid(string& s){\\n        int sum = 0;\\n        for(auto c: s){\\n            if(c == '(') sum++;\\n            else if(c == ')') sum--;\\n            if(sum < 0) return false;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nBFS, 63ms.\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string>visited;\\n        vector<string>res;\\n        deque<string>cur;\\n        deque<string>next;\\n        cur.push_back(s);\\n        while(!cur.empty()){\\n            s = cur.front();\\n            cur.pop_front();\\n            if(isValid(s)){\\n                res.push_back(s);\\n                continue;\\n            }\\n            for(int i = 0; i < s.size(); i++){\\n                if(s[i] != '(' && s[i] != ')') continue;\\n                string tmp = s.substr(0, i) + s.substr(i + 1);\\n                if(visited.count(tmp) == 0){\\n                    next.push_back(tmp);\\n                    visited.insert(tmp);\\n                }\\n            }\\n            if(cur.empty() && res.size() == 0) swap(cur, next);\\n        }\\n        return res;\\n    }\\n    \\n    bool isValid(string& s){\\n        int sum = 0;\\n        for(auto c: s){\\n            if(c == '(') sum++;\\n            else if(c == ')') sum--;\\n            if(sum < 0) return false;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string>res;\\n        int minMove = INT_MAX;\\n        backtrack(res, s, 0, 0, minMove);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string s, int pos, int move, int& minMove){\\n        if(pos > s.size() || move > minMove) return;\\n        if(isValid(s)){\\n            if(move < minMove) res.clear(), res.push_back(s), minMove = move;\\n            else if(move == minMove && find(res.begin(), res.end(), s) == res.end()) res.push_back(s);\\n            return;\\n        }\\n        while(pos < s.size() && s[pos] != '(' && s[pos] != ')') pos++;\\n        if(pos >= s.size()) return;\\n        backtrack(res, s.substr(0, pos) + s.substr(pos + 1), pos, move + 1, minMove);\\n        backtrack(res, s, pos + 1, move, minMove);\\n    }\\n    \\n    bool isValid(string& s){\\n        int sum = 0;\\n        for(auto c: s){\\n            if(c == '(') sum++;\\n            else if(c == ')') sum--;\\n            if(sum < 0) return false;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        unordered_set<string>visited;\\n        vector<string>res;\\n        deque<string>cur;\\n        deque<string>next;\\n        cur.push_back(s);\\n        while(!cur.empty()){\\n            s = cur.front();\\n            cur.pop_front();\\n            if(isValid(s)){\\n                res.push_back(s);\\n                continue;\\n            }\\n            for(int i = 0; i < s.size(); i++){\\n                if(s[i] != '(' && s[i] != ')') continue;\\n                string tmp = s.substr(0, i) + s.substr(i + 1);\\n                if(visited.count(tmp) == 0){\\n                    next.push_back(tmp);\\n                    visited.insert(tmp);\\n                }\\n            }\\n            if(cur.empty() && res.size() == 0) swap(cur, next);\\n        }\\n        return res;\\n    }\\n    \\n    bool isValid(string& s){\\n        int sum = 0;\\n        for(auto c: s){\\n            if(c == '(') sum++;\\n            else if(c == ')') sum--;\\n            if(sum < 0) return false;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75049,
                "title": "understandable-python-solution",
                "content": "```py\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        # this checks if a string is invalid\\n        def isvalid(s):\\n            s = ''.join(list(filter('()'.count, s))) # eliminate all non-brackets\\n            while '()' in s:\\n                s = s.replace('()', '')\\n            return not s\\n        \\n        store = {s}\\n        while True:\\n            valid = filter(isvalid, store)\\n            if valid:\\n                return valid\\n            store = {s[:i] + s[i+1:] for s in store for i in range(len(s))} # add all possible brackets into store\\n        \\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        # this checks if a string is invalid\\n        def isvalid(s):\\n            s = ''.join(list(filter('()'.count, s))) # eliminate all non-brackets\\n            while '()' in s:\\n                s = s.replace('()', '')\\n            return not s\\n        \\n        store = {s}\\n        while True:\\n            valid = filter(isvalid, store)\\n            if valid:\\n                return valid\\n            store = {s[:i] + s[i+1:] for s in store for i in range(len(s))} # add all possible brackets into store\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 75078,
                "title": "c-implement-version-of-dietpepsi-s-dfs-solution-easy-understanding-in-the-recursion-part",
                "content": "this is a c++ implement version of  dietpepsi.\\nhttps://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution/7\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n       vector<string> res;\\n       helper(s,0,0,res,{'(',')'});\\n       return res;\\n    }\\nprivate:\\n    void helper(string& s, int last_i, int last_j, vector<string>& res, pair<char,char> flag) {\\n        int cnt = 0;\\n        for(int i=last_i;i<s.size();i++) {\\n            if(s[i]==flag.first) cnt++;\\n            if(s[i]==flag.second) cnt--;\\n            if(cnt>=0) continue;\\n            for(int j=last_j;j<=i;j++) {\\n                if(s[j]==flag.second && (j== last_j || s[j-1]!=flag.second)){\\n                    string t = s.substr(0,j)+s.substr(j+1);\\n                    helper(t,i,j,res, flag);\\n                }\\n                    \\n            }\\n            return;\\n        }\\n      // i think this kind of implement is more easy to understand compared with dietpepsi's concise code\\n        if(cnt>0){\\n            string rs = s;\\n            reverse(rs.begin(),rs.end());\\n            helper(rs,0,0,res,{')','('});\\n        }\\n        if(cnt==0){\\n            if(flag.first =='(')\\n                res.push_back(s);\\n            else{\\n                string rs = s;\\n                reverse(rs.begin(),rs.end());\\n                res.push_back(rs);\\n            }\\n        }  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n       vector<string> res;\\n       helper(s,0,0,res,{'(',')'});\\n       return res;\\n    }\\nprivate:\\n    void helper(string& s, int last_i, int last_j, vector<string>& res, pair<char,char> flag) {\\n        int cnt = 0;\\n        for(int i=last_i;i<s.size();i++) {\\n            if(s[i]==flag.first) cnt++;\\n            if(s[i]==flag.second) cnt--;\\n            if(cnt>=0) continue;\\n            for(int j=last_j;j<=i;j++) {\\n                if(s[j]==flag.second && (j== last_j || s[j-1]!=flag.second)){\\n                    string t = s.substr(0,j)+s.substr(j+1);\\n                    helper(t,i,j,res, flag);\\n                }\\n                    \\n            }\\n            return;\\n        }\\n      // i think this kind of implement is more easy to understand compared with dietpepsi's concise code\\n        if(cnt>0){\\n            string rs = s;\\n            reverse(rs.begin(),rs.end());\\n            helper(rs,0,0,res,{')','('});\\n        }\\n        if(cnt==0){\\n            if(flag.first =='(')\\n                res.push_back(s);\\n            else{\\n                string rs = s;\\n                reverse(rs.begin(),rs.end());\\n                res.push_back(rs);\\n            }\\n        }  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282424,
                "title": "cleancodegolang-runtime-0-ms-beats-100-memory-2-7-mb-beats-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc removeInvalidParentheses(s string) []string {\\n    left := 0\\n    right := 0\\n    result := []string{}\\n\\n    visited := make(map[string]empty)\\n\\n    for _,v := range s{\\n        if v == \\'(\\'{\\n            left++\\n        } else if v == \\')\\' {\\n            if left==0 {\\n                right++\\n            } else {\\n                left--\\n            }\\n        }\\n    }\\n\\n    dfs(s, 0, left, right, &result, visited)\\n    return result\\n}\\n\\ntype empty struct{}\\n\\nfunc dfs(s string, start int, left int, right int, res *[]string, visited map[string]empty){\\n\\n    // if _, found := visited[s]; found {\\n    //     return\\n    // } else {\\n    //     visited[s] = empty{}\\n    // }\\n\\n    if left == 0 && right == 0 && isValid(s){\\n        *res = append(*res, s)\\n        return\\n    }\\n\\n    for i := start; i<len(s); i++ {\\n\\n        if i!=start && s[i] == s[i-1] {\\n            continue\\n        }\\n\\n        cur := s[:i]+s[i+1:]\\n        if s[i] == \\'(\\' && left > 0{\\n            dfs(cur, i, left-1, right, res, visited)\\n        } else if s[i] == \\')\\' && right > 0{\\n            dfs(cur, i, left, right-1, res, visited)\\n        }\\n    }\\n}\\n\\nfunc isValid(s string) bool{\\n    count := 0\\n\\n    for _,v := range s{\\n        if v == \\'(\\' {\\n            count++\\n        } else if v == \\')\\' {\\n            count--\\n        }\\n\\n        if count < 0 {\\n            return false\\n        }\\n    }\\n    return count==0\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeInvalidParentheses(s string) []string {\\n    left := 0\\n    right := 0\\n    result := []string{}\\n\\n    visited := make(map[string]empty)\\n\\n    for _,v := range s{\\n        if v == \\'(\\'{\\n            left++\\n        } else if v == \\')\\' {\\n            if left==0 {\\n                right++\\n            } else {\\n                left--\\n            }\\n        }\\n    }\\n\\n    dfs(s, 0, left, right, &result, visited)\\n    return result\\n}\\n\\ntype empty struct{}\\n\\nfunc dfs(s string, start int, left int, right int, res *[]string, visited map[string]empty){\\n\\n    // if _, found := visited[s]; found {\\n    //     return\\n    // } else {\\n    //     visited[s] = empty{}\\n    // }\\n\\n    if left == 0 && right == 0 && isValid(s){\\n        *res = append(*res, s)\\n        return\\n    }\\n\\n    for i := start; i<len(s); i++ {\\n\\n        if i!=start && s[i] == s[i-1] {\\n            continue\\n        }\\n\\n        cur := s[:i]+s[i+1:]\\n        if s[i] == \\'(\\' && left > 0{\\n            dfs(cur, i, left-1, right, res, visited)\\n        } else if s[i] == \\')\\' && right > 0{\\n            dfs(cur, i, left, right-1, res, visited)\\n        }\\n    }\\n}\\n\\nfunc isValid(s string) bool{\\n    count := 0\\n\\n    for _,v := range s{\\n        if v == \\'(\\' {\\n            count++\\n        } else if v == \\')\\' {\\n            count--\\n        }\\n\\n        if count < 0 {\\n            return false\\n        }\\n    }\\n    return count==0\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807979,
                "title": "backtracking-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        # (((((((((((\\n        # O(2^n), O(n)\\n        # backtracking approach\\n\\n        self.longest_string = -1\\n        self.res = set()\\n\\n        self.dfs(s, 0, [], 0, 0)\\n\\n        return self.res\\n\\n    def dfs(self, string, cur_idx, cur_res, l_count, r_count):\\n        if cur_idx >= len(string):\\n            if l_count == r_count:\\n                if len(cur_res) > self.longest_string:\\n                    self.longest_string = len(cur_res)\\n\\n                    self.res = set()\\n                    self.res.add(\"\".join(cur_res))\\n                elif len(cur_res) == self.longest_string:\\n                    self.res.add(\"\".join(cur_res))\\n        \\n        else:\\n            cur_char = string[cur_idx]\\n\\n            if cur_char == \"(\":\\n                cur_res.append(cur_char)\\n                # taking cur_char\\n                self.dfs(string, cur_idx + 1, cur_res, l_count + 1, r_count)\\n\\n                # not taking cur_char\\n                cur_res.pop()\\n                self.dfs(string, cur_idx + 1, cur_res, l_count, r_count)\\n\\n            elif cur_char == \")\":\\n                self.dfs(string, cur_idx + 1, cur_res, l_count, r_count)\\n\\n                # checking of l_count should be greater than r_count\\n                if l_count > r_count:\\n                    cur_res.append(cur_char)\\n                    # taking )\\n                    self.dfs(string, cur_idx + 1, cur_res, l_count, r_count + 1)\\n\\n                    # not taking )\\n                    cur_res.pop()\\n            \\n            else: # this is for any character except \"(\" and \")\"\\n                cur_res.append(cur_char)\\n                self.dfs(string, cur_idx + 1, cur_res, l_count, r_count)\\n                cur_res.pop()\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        # (((((((((((\\n        # O(2^n), O(n)\\n        # backtracking approach\\n\\n        self.longest_string = -1\\n        self.res = set()\\n\\n        self.dfs(s, 0, [], 0, 0)\\n\\n        return self.res\\n\\n    def dfs(self, string, cur_idx, cur_res, l_count, r_count):\\n        if cur_idx >= len(string):\\n            if l_count == r_count:\\n                if len(cur_res) > self.longest_string:\\n                    self.longest_string = len(cur_res)\\n\\n                    self.res = set()\\n                    self.res.add(\"\".join(cur_res))\\n                elif len(cur_res) == self.longest_string:\\n                    self.res.add(\"\".join(cur_res))\\n        \\n        else:\\n            cur_char = string[cur_idx]\\n\\n            if cur_char == \"(\":\\n                cur_res.append(cur_char)\\n                # taking cur_char\\n                self.dfs(string, cur_idx + 1, cur_res, l_count + 1, r_count)\\n\\n                # not taking cur_char\\n                cur_res.pop()\\n                self.dfs(string, cur_idx + 1, cur_res, l_count, r_count)\\n\\n            elif cur_char == \")\":\\n                self.dfs(string, cur_idx + 1, cur_res, l_count, r_count)\\n\\n                # checking of l_count should be greater than r_count\\n                if l_count > r_count:\\n                    cur_res.append(cur_char)\\n                    # taking )\\n                    self.dfs(string, cur_idx + 1, cur_res, l_count, r_count + 1)\\n\\n                    # not taking )\\n                    cur_res.pop()\\n            \\n            else: # this is for any character except \"(\" and \")\"\\n                cur_res.append(cur_char)\\n                self.dfs(string, cur_idx + 1, cur_res, l_count, r_count)\\n                cur_res.pop()\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508883,
                "title": "using-stack-and-recursion-easy-to-understand-fully-explained",
                "content": "```\\nclass Solution {\\n    List<String> res=new ArrayList<>();\\n    HashSet<String> visited=new HashSet<>();\\n    \\n    //so firstly checking that which of parenthesis is invalid\\n    //so pushing the ( bracket into stack and and then checking if ) bracket is there and checking that top of stack is (then pop ( bracket from stack and whatever bracket is extra put into hashset and getting size of that stack\\n    public int getMinInvalid(String s){\\n        Stack<Character> st=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                st.push(\\'(\\');\\n            }else if(s.charAt(i)==\\')\\'){\\n                if(st.size()>0 && st.peek()==\\'(\\')\\n                    st.pop();\\n                else{\\n                    st.push(\\')\\');\\n                }\\n            }else{\\n                continue;\\n            }\\n        }\\n        return st.size();\\n    }\\n    //so we will be checking if duplicate set is not present of same and set is not containing that \\n    //brackets then it is put in set otherwise if it is present is it not again put\\n    void solve(String s,int minInv,HashSet<String> duplicate){\\n        if(minInv==0){\\n            int now=getMinInvalid(s);\\n            if(now==0){\\n                if(duplicate.contains(s)==false){\\n                    duplicate.add(s);\\n                    res.add(s);\\n                }\\n            }\\n            return;\\n        }\\n        //here we will be spliting string into left and right part as we see if any invalid parenthesis is present then ten from where we split the string into two part so valid parenthesis is formed\\n        //like \"()())()\" so here we see if we remove 1 bracket \")())() then it is not valid parenthesis\" and if we remove 2 bracket \"(())()\" then it is valid parenthesis\\n        //now removing 3 bracket \"()))()\" now it is not valid parentesis then removing 4 breakcet \"()()()\" so it a valid parenthesisand so on \\n        for(int i=0;i<s.length();i++){\\n            // like ()())() here 4th no bracket ) if removed then it is formed left =()( and right= )()\\n            //by combining them they are valid bracket\\n            String left=s.substring(0,i);\\n            String right=s.substring(i+1);\\n            \\n            if(visited.contains(left+right)==false){\\n                visited.add(left+right);\\n                solve(left+right,minInv-1,duplicate);\\n            }\\n        }\\n    }\\n    public List<String> removeInvalidParentheses(String s) {\\n        int rem=getMinInvalid(s);\\n        solve(s,rem,new HashSet<>());\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res=new ArrayList<>();\\n    HashSet<String> visited=new HashSet<>();\\n    \\n    //so firstly checking that which of parenthesis is invalid\\n    //so pushing the ( bracket into stack and and then checking if ) bracket is there and checking that top of stack is (then pop ( bracket from stack and whatever bracket is extra put into hashset and getting size of that stack\\n    public int getMinInvalid(String s){\\n        Stack<Character> st=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                st.push(\\'(\\');\\n            }else if(s.charAt(i)==\\')\\'){\\n                if(st.size()>0 && st.peek()==\\'(\\')\\n                    st.pop();\\n                else{\\n                    st.push(\\')\\');\\n                }\\n            }else{\\n                continue;\\n            }\\n        }\\n        return st.size();\\n    }\\n    //so we will be checking if duplicate set is not present of same and set is not containing that \\n    //brackets then it is put in set otherwise if it is present is it not again put\\n    void solve(String s,int minInv,HashSet<String> duplicate){\\n        if(minInv==0){\\n            int now=getMinInvalid(s);\\n            if(now==0){\\n                if(duplicate.contains(s)==false){\\n                    duplicate.add(s);\\n                    res.add(s);\\n                }\\n            }\\n            return;\\n        }\\n        //here we will be spliting string into left and right part as we see if any invalid parenthesis is present then ten from where we split the string into two part so valid parenthesis is formed\\n        //like \"()())()\" so here we see if we remove 1 bracket \")())() then it is not valid parenthesis\" and if we remove 2 bracket \"(())()\" then it is valid parenthesis\\n        //now removing 3 bracket \"()))()\" now it is not valid parentesis then removing 4 breakcet \"()()()\" so it a valid parenthesisand so on \\n        for(int i=0;i<s.length();i++){\\n            // like ()())() here 4th no bracket ) if removed then it is formed left =()( and right= )()\\n            //by combining them they are valid bracket\\n            String left=s.substring(0,i);\\n            String right=s.substring(i+1);\\n            \\n            if(visited.contains(left+right)==false){\\n                visited.add(left+right);\\n                solve(left+right,minInv-1,duplicate);\\n            }\\n        }\\n    }\\n    public List<String> removeInvalidParentheses(String s) {\\n        int rem=getMinInvalid(s);\\n        solve(s,rem,new HashSet<>());\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335254,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool CheckValid(string &str)\\n    {\\n        stack<char> st;\\n        int i = 0, n = str.size();\\n        while(i < n)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                st.push(str[i]);\\n            }\\n            else if(str[i] == \\')\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                st.pop();\\n            }\\n            i++;\\n        }\\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.size();\\n        queue<string> q;\\n        q.push(s);\\n        vector<string> um;\\n        unordered_map<string, int> visited;\\n        bool bk = false;\\n        if(CheckValid(s))\\n        {\\n            um.push_back(s);\\n            return um;\\n        }\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string tmp = q.front();\\n                q.pop();\\n                for(int i = 0; i < tmp.size(); i++)\\n                {\\n                    if(s[i] >= \\'a\\' && s[i] <= \\'z\\') continue;\\n                    string z = tmp;\\n                    z.erase(i, 1);\\n                    if(visited.count(z)) continue;\\n                    if(CheckValid(z))\\n                    {\\n                        um.push_back(z);\\n                        bk = true;\\n                    }\\n                    visited[z]++;\\n                    q.push(z);\\n                }\\n            }\\n            if(bk) break;\\n        }\\n        return um;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool CheckValid(string &str)\\n    {\\n        stack<char> st;\\n        int i = 0, n = str.size();\\n        while(i < n)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                st.push(str[i]);\\n            }\\n            else if(str[i] == \\')\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                st.pop();\\n            }\\n            i++;\\n        }\\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.size();\\n        queue<string> q;\\n        q.push(s);\\n        vector<string> um;\\n        unordered_map<string, int> visited;\\n        bool bk = false;\\n        if(CheckValid(s))\\n        {\\n            um.push_back(s);\\n            return um;\\n        }\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string tmp = q.front();\\n                q.pop();\\n                for(int i = 0; i < tmp.size(); i++)\\n                {\\n                    if(s[i] >= \\'a\\' && s[i] <= \\'z\\') continue;\\n                    string z = tmp;\\n                    z.erase(i, 1);\\n                    if(visited.count(z)) continue;\\n                    if(CheckValid(z))\\n                    {\\n                        um.push_back(z);\\n                        bk = true;\\n                    }\\n                    visited[z]++;\\n                    q.push(z);\\n                }\\n            }\\n            if(bk) break;\\n        }\\n        return um;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309656,
                "title": "my-c-solution-beats-100-0-ms-easy-to-understand",
                "content": "Here, I share my backtracking solution for <a href=\"https://leetcode.com/problems/remove-invalid-parentheses/\"> Remove Invalid Parentheses</a>.\\n\\nSteps :\\n\\n1.  &nbsp; Count  number of \\'(\\'  and \\')\\' due to which string is invalid\\n2.  &nbsp; Using helper function try to remove extra parentheses & update the count \\n3.  &nbsp; If we get a valid string after removing parentheses, store it\\n\\n   \\n   <br>\\n   \\n    // For storing output\\n    vector <string> output; \\n\\n\\t// To check if string is valid\\n    bool isValid(string &s){ \\n\\t\\n        int pair = 0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            \\n            if(s[i] == \\'(\\'){\\n                \\n                pair++;\\n            }\\n            else if(s[i] == \\')\\'){\\n                \\n                pair--;\\n                \\n                if(pair < 0)\\n                    return false;\\n            } \\n        }\\n        \\n\\t\\t// Check if string is valid\\n        return pair == 0;\\n    }\\n\\n    void removeHelper(string input, int index, int left, int right){\\n        \\n\\t\\t// When removal of extra brackets is done\\n        if(left == 0 && right == 0){\\n            \\n\\t\\t\\t// Pushing the valid string only\\n            if(isValid(input)){\\n                \\n                output.push_back(input);\\n            }\\n            \\n            return;\\n        }\\n    \\n        for(int i=index; i<input.size(); i++){\\n            \\n\\t\\t\\t// For avoiding same valid string \\n            if(i > index && input[i] == input[i-1]) continue;\\n            \\n            string tmp = input;\\n           \\n\\t\\t   // Remove brackets based on left and right count\\n            if(right == 0 && left > 0 && input[i] == \\'(\\') {\\n \\n                 tmp.erase(i, 1);\\n                 removeHelper(tmp, i, left-1, right);\\n            }\\n            else if(right > 0 && input[i] == \\')\\') {\\n                \\n                tmp.erase(i, 1);\\n                removeHelper(tmp, i, left, right-1);\\n            }\\n        }\\n    }\\n    \\n\\t// Driver Function \\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        if(s.size() == 0) return output;\\n\\t\\t\\n\\t\\t// Count \\'(\\'  &  \\')\\' due to which string is invalid \\n        int left = 0;\\n        int right = 0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            \\n            if(s[i] == \\'(\\'){\\n                \\n                left++;\\n            }\\n            else if(s[i] == \\')\\'){\\n                \\n                if(left > 0){\\n                    \\n                    left--;\\n                }\\n                else{\\n                    \\n                    right++;\\n                }\\n            }   \\n        }\\n        \\n\\t\\t// Helper to remove those extra brackets\\n        removeHelper(s, 0, left, right);\\n        \\n        return output;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "Here, I share my backtracking solution for <a href=\"https://leetcode.com/problems/remove-invalid-parentheses/\"> Remove Invalid Parentheses</a>.\\n\\nSteps :\\n\\n1.  &nbsp; Count  number of \\'(\\'  and \\')\\' due to which string is invalid\\n2.  &nbsp; Using helper function try to remove extra parentheses & update the count \\n3.  &nbsp; If we get a valid string after removing parentheses, store it\\n\\n   \\n   <br>\\n   \\n    // For storing output\\n    vector <string> output; \\n\\n\\t// To check if string is valid\\n    bool isValid(string &s){ \\n\\t\\n        int pair = 0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            \\n            if(s[i] == \\'(\\'){\\n                \\n                pair++;\\n            }\\n            else if(s[i] == \\')\\'){\\n                \\n                pair--;\\n                \\n                if(pair < 0)\\n                    return false;\\n            } \\n        }\\n        \\n\\t\\t// Check if string is valid\\n        return pair == 0;\\n    }\\n\\n    void removeHelper(string input, int index, int left, int right){\\n        \\n\\t\\t// When removal of extra brackets is done\\n        if(left == 0 && right == 0){\\n            \\n\\t\\t\\t// Pushing the valid string only\\n            if(isValid(input)){\\n                \\n                output.push_back(input);\\n            }\\n            \\n            return;\\n        }\\n    \\n        for(int i=index; i<input.size(); i++){\\n            \\n\\t\\t\\t// For avoiding same valid string \\n            if(i > index && input[i] == input[i-1]) continue;\\n            \\n            string tmp = input;\\n           \\n\\t\\t   // Remove brackets based on left and right count\\n            if(right == 0 && left > 0 && input[i] == \\'(\\') {\\n \\n                 tmp.erase(i, 1);\\n                 removeHelper(tmp, i, left-1, right);\\n            }\\n            else if(right > 0 && input[i] == \\')\\') {\\n                \\n                tmp.erase(i, 1);\\n                removeHelper(tmp, i, left, right-1);\\n            }\\n        }\\n    }\\n    \\n\\t// Driver Function \\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        if(s.size() == 0) return output;\\n\\t\\t\\n\\t\\t// Count \\'(\\'  &  \\')\\' due to which string is invalid \\n        int left = 0;\\n        int right = 0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            \\n            if(s[i] == \\'(\\'){\\n                \\n                left++;\\n            }\\n            else if(s[i] == \\')\\'){\\n                \\n                if(left > 0){\\n                    \\n                    left--;\\n                }\\n                else{\\n                    \\n                    right++;\\n                }\\n            }   \\n        }\\n        \\n\\t\\t// Helper to remove those extra brackets\\n        removeHelper(s, 0, left, right);\\n        \\n        return output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2285580,
                "title": "simple-clean-c-recursion-optimization",
                "content": "```\\n// Extension of This problem : https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nclass Solution {\\npublic:\\n    \\n    int getMin(string str) // gives how much Minimum removals allowed\\n    {\\n        stack<char>st;\\n        for(int i = 0;i < str.length(); i++){\\n            \\n            char ch = str[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\'){\\n                if(st.size() == 0){\\n                    st.push(ch);\\n                }\\n                else if(st.top() == \\')\\'){\\n                    st.push(ch);\\n                }\\n                else if(st.top() == \\'(\\'){\\n                    st.pop();\\n                }\\n            }\\n        }    \\n        \\n        return st.size(); // count of Invalid parenthesis \\n    }\\n    \\n    void solve(string s, int mra, unordered_set<string>&set, unordered_set<string>&vis)\\n    {\\n        if(vis.find(s) != vis.end())// optimization code\\n            return; // agar same string pahle bhi aa chuki hai toh uske liye doobara nahi karenge\\n                    // uska track rakhenge\\n        \\n        vis.insert(s);\\n        if(mra == 0) \\n        {\\n            // jo string lekar aaye ho voh balanced hai ya nahi , i.e mrnow = 0 (Balanced)\\n            int mrnow = getMin(s);\\n            if(mrnow == 0){\\n                // answer\\n                set.insert(s);// agar ek se jyada baar same bane toh\\n            }\\n            return;\\n        }\\n        \\n        for(int j = 0; j< s.length();j++)\\n        {\\n            string left = s.substr(0,j);\\n            string right = s.substr(j+1);\\n            solve(left + right, mra-1, set, vis);\\n        }\\n        \\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        int minimumRemovalsAllowed = getMin(s);\\n        vector<string>ans;\\n        unordered_set<string>st; // for unique strings\\n        unordered_set<string>vis;\\n        solve(s, minimumRemovalsAllowed, st, vis);\\n        \\n        for(auto x : st) ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// Extension of This problem : https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nclass Solution {\\npublic:\\n    \\n    int getMin(string str) // gives how much Minimum removals allowed\\n    {\\n        stack<char>st;\\n        for(int i = 0;i < str.length(); i++){\\n            \\n            char ch = str[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\')\\'){\\n                if(st.size() == 0){\\n                    st.push(ch);\\n                }\\n                else if(st.top() == \\')\\'){\\n                    st.push(ch);\\n                }\\n                else if(st.top() == \\'(\\'){\\n                    st.pop();\\n                }\\n            }\\n        }    \\n        \\n        return st.size(); // count of Invalid parenthesis \\n    }\\n    \\n    void solve(string s, int mra, unordered_set<string>&set, unordered_set<string>&vis)\\n    {\\n        if(vis.find(s) != vis.end())// optimization code\\n            return; // agar same string pahle bhi aa chuki hai toh uske liye doobara nahi karenge\\n                    // uska track rakhenge\\n        \\n        vis.insert(s);\\n        if(mra == 0) \\n        {\\n            // jo string lekar aaye ho voh balanced hai ya nahi , i.e mrnow = 0 (Balanced)\\n            int mrnow = getMin(s);\\n            if(mrnow == 0){\\n                // answer\\n                set.insert(s);// agar ek se jyada baar same bane toh\\n            }\\n            return;\\n        }\\n        \\n        for(int j = 0; j< s.length();j++)\\n        {\\n            string left = s.substr(0,j);\\n            string right = s.substr(j+1);\\n            solve(left + right, mra-1, set, vis);\\n        }\\n        \\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        int minimumRemovalsAllowed = getMin(s);\\n        vector<string>ans;\\n        unordered_set<string>st; // for unique strings\\n        unordered_set<string>vis;\\n        solve(s, minimumRemovalsAllowed, st, vis);\\n        \\n        for(auto x : st) ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174279,
                "title": "c-tle-in-submission-but-accept-in-console-please-tell-me-the-reason-and-problem-in-my-code",
                "content": "class Solution {\\npublic:\\n    int check(string s)\\n    {\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n           \\n            \\n            if(st.size()==0&&s[i]==\\')\\')\\n                return 0;\\n            \\n          else  if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n          else  if(s[i]==\\')\\')\\n              st.pop();\\n            \\n            \\n            \\n            \\n        }\\n        if(st.size()==0)\\n            return 1;\\n        else\\n            return 0;\\n        \\n    }\\n    //int as=-5;\\n    unordered_map<string,int>vis;\\n    void fun(string s,int i,string &temp,vector<string>&ans,int &as)\\n    {\\n        if(vis[temp]==1)\\n            return;\\n        if(i==s.size())\\n        {\\n           // for(int i=0;i<temp.size();i++)\\n            //    cout<<temp[i];\\n           // cout<<endl;\\n            if(check(temp)==1)\\n            {\\n            //    cout<<\"andar\"<<endl;\\n              //  cout<<temp.size()<<endl;\\n               // cout<<as<<endl;\\n              if(temp.size()>=as)\\n              {\\n                   \\n                  ans.push_back(temp);\\n                  as=temp.size();\\n                  vis[temp]=1;\\n               //  cout<<\"as andar\"<<as<<endl;\\n              }\\n            }\\n            return;\\n        }\\n        \\n        \\n        temp.push_back(s[i]);\\n        fun(s,i+1,temp,ans,as);\\n        temp.pop_back();\\n        fun(s,i+1,temp,ans,as);\\n            \\n        \\n    }\\n    \\n    \\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        string temp=\"\";\\n        vector<string>ans;\\n        vector<string>sol;\\n        int as=1;\\n        fun(s,0,temp,ans,as);\\n   //     cout<<\"sss  \"<<as<<endl;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i].size()==as)\\n            {\\n                sol.push_back(ans[i]);\\n            }\\n        }\\n        if(sol.size()==0)\\n        {\\n            return {\"\"};\\n        }\\n        return sol;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int check(string s)\\n    {\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n           \\n            \\n            if(st.size()==0&&s[i]==\\')\\')\\n                return 0;\\n            \\n          else  if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n          else  if(s[i]==\\')\\')\\n              st.pop();\\n            \\n            \\n            \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1921842,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n```\\n    int get_min(string &str)\\n    {\\n        int n = str.size();\\n        \\n        stack<char> st;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                st.push(str[i]);\\n            }\\n            \\n            else if(str[i] == \\')\\')\\n            {\\n                if(st.empty())\\n                {\\n                    count++;\\n                }\\n                \\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        count += st.size();\\n        \\n        return count;\\n    }\\n    \\n    unordered_set<string> res, vis;\\n    \\n    void helper(string str, int min_removal)\\n    {\\n        if(vis.find(str) != vis.end())\\n            return;\\n        \\n        vis.insert(str);\\n        \\n        if(min_removal == 0)\\n        {\\n            res.insert(str);\\n            \\n            return;\\n        }\\n        \\n        for(int i = 0; i < str.size(); i++)\\n        {\\n            if(str[i] == \\'(\\' || str[i] == \\')\\')\\n            {\\n                string left = str.substr(0, i);\\n                \\n                string right = str.substr(i + 1);\\n                \\n                helper(left + right, min_removal - 1);\\n            }\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string str) {\\n        \\n        int n = str.size();\\n        \\n        int min_removal = get_min(str);\\n        \\n        helper(str, min_removal);\\n        \\n        vector<string> ans;\\n        \\n        for(auto x : res)\\n        {\\n            if(get_min(x) == 0)\\n            {\\n                ans.push_back(x);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n    int get_min(string &str)\\n    {\\n        int n = str.size();\\n        \\n        stack<char> st;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'(\\')\\n            {\\n                st.push(str[i]);\\n            }\\n            \\n            else if(str[i] == \\')\\')\\n            {\\n                if(st.empty())\\n                {\\n                    count++;\\n                }\\n                \\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        count += st.size();\\n        \\n        return count;\\n    }\\n    \\n    unordered_set<string> res, vis;\\n    \\n    void helper(string str, int min_removal)\\n    {\\n        if(vis.find(str) != vis.end())\\n            return;\\n        \\n        vis.insert(str);\\n        \\n        if(min_removal == 0)\\n        {\\n            res.insert(str);\\n            \\n            return;\\n        }\\n        \\n        for(int i = 0; i < str.size(); i++)\\n        {\\n            if(str[i] == \\'(\\' || str[i] == \\')\\')\\n            {\\n                string left = str.substr(0, i);\\n                \\n                string right = str.substr(i + 1);\\n                \\n                helper(left + right, min_removal - 1);\\n            }\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string str) {\\n        \\n        int n = str.size();\\n        \\n        int min_removal = get_min(str);\\n        \\n        helper(str, min_removal);\\n        \\n        vector<string> ans;\\n        \\n        for(auto x : res)\\n        {\\n            if(get_min(x) == 0)\\n            {\\n                ans.push_back(x);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915593,
                "title": "simple-solution-in-java-elegant-and-concise",
                "content": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        Queue<String> queue = new LinkedList<>();\\n        \\n        /*\\n           In the queue, after each level, the length of strings will be the length of string in the current level - 1,\\n           so if in the current level, there is some valid string, then all the substrings of the current valid string will not be \\n           considered that is why no need to do any more insertions in the queue \\n        */\\n        \\n        queue.offer(s);\\n        visited.add(s);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean found = false;\\n            \\n            for(int l=0; l<size; l++){\\n                String str = queue.poll();\\n                if(isValid(str)){\\n                    ans.add(str);\\n                    found = true;\\n                }\\n            \\n                if(found) continue; // No need to go to the next level \\n                \\n                for(int i=0; i<str.length(); i++){\\n                    if(str.charAt(i) != \\'(\\' && str.charAt(i) != \\')\\') continue;\\n                \\n                    String newStr = str.substring(0, i) + str.substring(i+1);\\n                    if(!visited.contains(newStr)){\\n                        visited.add(newStr);\\n                        queue.offer(newStr);\\n                    }\\n                }\\n            }\\n            \\n            if(found) break;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isValid(String s){\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) != \\'(\\' && s.charAt(i) != \\')\\') continue;\\n            \\n            if(s.charAt(i) == \\'(\\') count++;\\n            else count--;\\n            \\n            if(count < 0) return false;\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        Queue<String> queue = new LinkedList<>();\\n        \\n        /*\\n           In the queue, after each level, the length of strings will be the length of string in the current level - 1,\\n           so if in the current level, there is some valid string, then all the substrings of the current valid string will not be \\n           considered that is why no need to do any more insertions in the queue \\n        */\\n        \\n        queue.offer(s);\\n        visited.add(s);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean found = false;\\n            \\n            for(int l=0; l<size; l++){\\n                String str = queue.poll();\\n                if(isValid(str)){\\n                    ans.add(str);\\n                    found = true;\\n                }\\n            \\n                if(found) continue; // No need to go to the next level \\n                \\n                for(int i=0; i<str.length(); i++){\\n                    if(str.charAt(i) != \\'(\\' && str.charAt(i) != \\')\\') continue;\\n                \\n                    String newStr = str.substring(0, i) + str.substring(i+1);\\n                    if(!visited.contains(newStr)){\\n                        visited.add(newStr);\\n                        queue.offer(newStr);\\n                    }\\n                }\\n            }\\n            \\n            if(found) break;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isValid(String s){\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) != \\'(\\' && s.charAt(i) != \\')\\') continue;\\n            \\n            if(s.charAt(i) == \\'(\\') count++;\\n            else count--;\\n            \\n            if(count < 0) return false;\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704877,
                "title": "backtracking-solution",
                "content": "```\\nclass Solution {\\n    int get_cor_len(string s,int &a){ // Function to get the correct required valid length of string \\n        \\n        int l = 0,ml = 0; // l->left, ml->misplaced left\\n        int r = 0,mr = 0; // r->right, mr->misplaced right\\n        \\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(isalpha(s[i])){\\n                a++;\\n                flag = 1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                l++;\\n                ml++;\\n            }\\n            else{\\n                r++;\\n                if(ml>0){\\n                    ml--;\\n                }\\n                else{\\n                    mr++;\\n                }\\n            }\\n        }\\n        return (l-ml+r-mr+a);\\n    }\\n    \\n    string get_alpha(string s,int count){ // Function to get the alphabets from the given string\\n        int n = s.size();\\n        string alpha = \"\";\\n        int a = 0;\\n        for(char c:s){\\n            if(isalpha(c)){\\n                alpha.push_back(c);\\n                c++;\\n            }\\n            if(c==count)\\n                break;\\n        }\\n        return alpha;\\n    }\\n    \\n    void solve(vector<string> &result,string out,string s,\\n               int index,int left,int right,int cor_len,int n){ // Main backtracking function to get our result\\n        \\n        if(out.size()>cor_len){ //If output size is greater than the correct required length, then end the\\n            return;                    // currect function\\n        }\\n\\t\\t/* If index comes to the end of the string, then validate the output size,\\n\\t\\topen brackets and close brackets, and then check whether current output is\\n\\t\\tpresent in the result vector or not, then store the output, if all the\\n\\t\\trequirements met.. */\\n        if(index==n){\\n            if(out.size()==cor_len && left==right){ \\n                if(find(result.begin(),result.end(),out)==result.end()){ \\n                    result.push_back(out);  \\n                }\\n            }\\n            return;\\n        }\\n\\t\\t/* If index is not at the end of the string, but output size matches the\\n\\t\\tcorrect length, then check whether the current output is present in the \\n\\t\\tresult vector or not, and if it is not present, then store it in the result\\n\\t\\tand return...*/\\n        if(out.size()==cor_len && left==right){  \\n            if(find(result.begin(),result.end(),out)==result.end()){\\n                    result.push_back(out);\\n            }\\n            return;\\n        }\\n        if(out.size()+n-index>=cor_len){ //If output size plus the given string left to be checked is greater than or equal to the correct length\\n            if(left==right){  // If current output is balanced\\n                if(s[index]==\\'(\\'){\\n                    solve(result,out+s[index],s,index+1,left+1,right,cor_len,n);\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n                else if(isalpha(s[index])){\\n                    solve(result,out+s[index],s,index+1,left,right,cor_len,n);\\n                }\\n                else{\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n            }\\n            else{  // If current output is not balanced\\n                if(s[index]==\\'(\\'){\\n                    solve(result,out+s[index],s,index+1,left+1,right,cor_len,n);\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n                else if(isalpha(s[index])){\\n                    solve(result,out+s[index],s,index+1,left,right,cor_len,n);\\n                }\\n                else{\\n                    solve(result,out+s[index],s,index+1,left,right+1,cor_len,n);\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> result;\\n        string out;\\n        int alpha = 0;\\n        int cor_len = get_cor_len(s,alpha); //To get the correct required length\\n        \\n        if(cor_len==0) //If correct length is zero, then simply return the vector of empty string\\n            return {\"\"};\\n        else if(cor_len==alpha){   // If all the parentheses is misplaced and alphabets are present in the \\n            return {get_alpha(s,alpha)};  // given string, then return the string of alphabets\\n        }\\n        solve(result,out,s,0,0,0,cor_len,s.size()); // Backtracking starts here...\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int get_cor_len(string s,int &a){ // Function to get the correct required valid length of string \\n        \\n        int l = 0,ml = 0; // l->left, ml->misplaced left\\n        int r = 0,mr = 0; // r->right, mr->misplaced right\\n        \\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(isalpha(s[i])){\\n                a++;\\n                flag = 1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                l++;\\n                ml++;\\n            }\\n            else{\\n                r++;\\n                if(ml>0){\\n                    ml--;\\n                }\\n                else{\\n                    mr++;\\n                }\\n            }\\n        }\\n        return (l-ml+r-mr+a);\\n    }\\n    \\n    string get_alpha(string s,int count){ // Function to get the alphabets from the given string\\n        int n = s.size();\\n        string alpha = \"\";\\n        int a = 0;\\n        for(char c:s){\\n            if(isalpha(c)){\\n                alpha.push_back(c);\\n                c++;\\n            }\\n            if(c==count)\\n                break;\\n        }\\n        return alpha;\\n    }\\n    \\n    void solve(vector<string> &result,string out,string s,\\n               int index,int left,int right,int cor_len,int n){ // Main backtracking function to get our result\\n        \\n        if(out.size()>cor_len){ //If output size is greater than the correct required length, then end the\\n            return;                    // currect function\\n        }\\n\\t\\t/* If index comes to the end of the string, then validate the output size,\\n\\t\\topen brackets and close brackets, and then check whether current output is\\n\\t\\tpresent in the result vector or not, then store the output, if all the\\n\\t\\trequirements met.. */\\n        if(index==n){\\n            if(out.size()==cor_len && left==right){ \\n                if(find(result.begin(),result.end(),out)==result.end()){ \\n                    result.push_back(out);  \\n                }\\n            }\\n            return;\\n        }\\n\\t\\t/* If index is not at the end of the string, but output size matches the\\n\\t\\tcorrect length, then check whether the current output is present in the \\n\\t\\tresult vector or not, and if it is not present, then store it in the result\\n\\t\\tand return...*/\\n        if(out.size()==cor_len && left==right){  \\n            if(find(result.begin(),result.end(),out)==result.end()){\\n                    result.push_back(out);\\n            }\\n            return;\\n        }\\n        if(out.size()+n-index>=cor_len){ //If output size plus the given string left to be checked is greater than or equal to the correct length\\n            if(left==right){  // If current output is balanced\\n                if(s[index]==\\'(\\'){\\n                    solve(result,out+s[index],s,index+1,left+1,right,cor_len,n);\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n                else if(isalpha(s[index])){\\n                    solve(result,out+s[index],s,index+1,left,right,cor_len,n);\\n                }\\n                else{\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n            }\\n            else{  // If current output is not balanced\\n                if(s[index]==\\'(\\'){\\n                    solve(result,out+s[index],s,index+1,left+1,right,cor_len,n);\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n                else if(isalpha(s[index])){\\n                    solve(result,out+s[index],s,index+1,left,right,cor_len,n);\\n                }\\n                else{\\n                    solve(result,out+s[index],s,index+1,left,right+1,cor_len,n);\\n                    solve(result,out,s,index+1,left,right,cor_len,n);\\n                }\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> result;\\n        string out;\\n        int alpha = 0;\\n        int cor_len = get_cor_len(s,alpha); //To get the correct required length\\n        \\n        if(cor_len==0) //If correct length is zero, then simply return the vector of empty string\\n            return {\"\"};\\n        else if(cor_len==alpha){   // If all the parentheses is misplaced and alphabets are present in the \\n            return {get_alpha(s,alpha)};  // given string, then return the string of alphabets\\n        }\\n        solve(result,out,s,0,0,0,cor_len,s.size()); // Backtracking starts here...\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639879,
                "title": "python-backtracking-easily-derived-from-combination-backtracking-template",
                "content": "Components:\\n1) Calculate how many invalid left(i.e. \\'(\\') and right (i.e. \\')\\') to remove\\n2) A function to check if a string is a valid form\\n3) DFS bactracking to remove invalid paretheses:\\n         tips:\\n         a) get one solution and return: when left and right both are zero and the remaining str is valid\\n\\t\\t b) check if not parentheses, continue\\n\\t\\t c) check if same with previous parethesis to avoid duplicates, continue\\n\\t\\t d) always remove invalid \")\" before \"(\" to reach validity\\n\\t\\t e) use combination concept and comb[i] == \\'\\' to indicate a removal and comb[i] = s[i] to backtrack\\n\\t\\t \\n\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        #calculate total invalid r and l to remove\\n        l, r = 0, 0\\n        for char in s:  \\n            l += (char == \\'(\\')\\n            if (l == 0):\\n                r += (char == \\')\\')\\n            else:\\n                l -= (char == \\')\\')\\n        \\n        #function to check if the string is valid form\\n        def isvalid(s):\\n            count = 0\\n            for char in s:\\n                if char == \\'(\\': count += 1\\n                if char == \\')\\': count -= 1\\n                if count < 0: return False\\n            \\n            return count == 0\\n        \\n        #backtracking dfs \\n        def dfs(comb, start, left, right):\\n            curr_str = \\'\\'.join(comb)\\n            \\n            if left == 0 and right == 0 and isvalid(curr_str): #stop condition\\n                result.append(curr_str)\\n                return\\n            \\n            for i in range(start, len(s)):\\n                if s[i] != \\'(\\' and  s[i] != \\')\\': #if not parentheses\\n                    continue\\n                if i != start and s[i] == s[i-1]: #if same as previous one, continue to avoid duplicates\\n                    continue\\n                \\n                #always remove invalid \")\" before \"(\" \\n                if (right > 0 and s[i] == \\')\\'):\\n                    comb[i] = \\'\\' #remove this parenthesis\\n                    dfs(comb, i+1, left, right - 1)\\n                    comb[i] = s[i]  #backtracking\\n                elif (left > 0 and s[i] == \\'(\\'): \\n                    comb[i] = \\'\\' #remove this parenthesis\\n                    dfs(comb, i+1, left-1, right)\\n                    comb[i] = s[i] #backtracking\\n        \\n        result = []\\n        dfs(list(s), 0, l, r)\\n        \\n        return result\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        #calculate total invalid r and l to remove\\n        l, r = 0, 0\\n        for char in s:  \\n            l += (char == \\'(\\')\\n            if (l == 0):\\n                r += (char == \\')\\')\\n            else:\\n                l -= (char == \\')\\')\\n        \\n        #function to check if the string is valid form\\n        def isvalid(s):\\n            count = 0\\n            for char in s:\\n                if char == \\'(\\': count += 1\\n                if char == \\')\\': count -= 1\\n                if count < 0: return False\\n            \\n            return count == 0\\n        \\n        #backtracking dfs \\n        def dfs(comb, start, left, right):\\n            curr_str = \\'\\'.join(comb)\\n            \\n            if left == 0 and right == 0 and isvalid(curr_str): #stop condition\\n                result.append(curr_str)\\n                return\\n            \\n            for i in range(start, len(s)):\\n                if s[i] != \\'(\\' and  s[i] != \\')\\': #if not parentheses\\n                    continue\\n                if i != start and s[i] == s[i-1]: #if same as previous one, continue to avoid duplicates\\n                    continue\\n                \\n                #always remove invalid \")\" before \"(\" \\n                if (right > 0 and s[i] == \\')\\'):\\n                    comb[i] = \\'\\' #remove this parenthesis\\n                    dfs(comb, i+1, left, right - 1)\\n                    comb[i] = s[i]  #backtracking\\n                elif (left > 0 and s[i] == \\'(\\'): \\n                    comb[i] = \\'\\' #remove this parenthesis\\n                    dfs(comb, i+1, left-1, right)\\n                    comb[i] = s[i] #backtracking\\n        \\n        result = []\\n        dfs(list(s), 0, l, r)\\n        \\n        return result\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1634866,
                "title": "python-dfs-using-cache-50-ms-and-beat-90",
                "content": "using @cache  to handle the duplication computing issue. It made the code easier to write.\\n\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ans = set()\\n        \\n        def isValid(s):\\n            ct = 0\\n            for c in s:\\n                if c==\\'(\\': ct+=1\\n                elif c==\\')\\':\\n                    if ct<1:return False\\n                    ct-=1\\n            return ct==0\\n\\n        @cache\\n        def dfs(s, start, l, r):\\n            #print(s,start, l,r)\\n            if l==r==0 and isValid(s):\\n                ans.add(s)   \\n\\n            i=start\\n            if r>0:\\n                while i<len(s):\\n                    if s[i]==\")\":\\n                        dfs(s[:i]+ s[i+1:], i, l, r-1)\\n                    i+=1\\n            \\n            while i<len(s):\\n                if s[i]==\"(\": \\n                    dfs(s[:i]+ s[i+1:], i, l-1, r)\\n                i+=1\\n\\n        l,r=0,0\\n        ct=0\\n        for c in s:\\n            if c==\\'(\\': ct+=1\\n            elif c==\\')\\':\\n                if ct>0: ct-=1\\n                else: r+=1\\n        l=ct\\n        dfs(s, 0, l, r)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        ans = set()\\n        \\n        def isValid(s):\\n            ct = 0\\n            for c in s:\\n                if c==\\'(\\': ct+=1\\n                elif c==\\')\\':\\n                    if ct<1:return False\\n                    ct-=1\\n            return ct==0\\n\\n        @cache\\n        def dfs(s, start, l, r):\\n            #print(s,start, l,r)\\n            if l==r==0 and isValid(s):\\n                ans.add(s)   \\n\\n            i=start\\n            if r>0:\\n                while i<len(s):\\n                    if s[i]==\")\":\\n                        dfs(s[:i]+ s[i+1:], i, l, r-1)\\n                    i+=1\\n            \\n            while i<len(s):\\n                if s[i]==\"(\": \\n                    dfs(s[:i]+ s[i+1:], i, l-1, r)\\n                i+=1\\n\\n        l,r=0,0\\n        ct=0\\n        for c in s:\\n            if c==\\'(\\': ct+=1\\n            elif c==\\')\\':\\n                if ct>0: ct-=1\\n                else: r+=1\\n        l=ct\\n        dfs(s, 0, l, r)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517136,
                "title": "c-bfs-short-code-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\n    vector<string> removeInvalidParentheses(string s)\\n    {\\n        if (s == \"\")\\n            return { {} };\\n\\n        vector<string> results;\\n\\n        // bfs - Let\\'s do level-by-level\\n        queue<string> q;\\n        unordered_set<string> set;\\n        bool found = false;\\n\\n        // push the original string to queue. \\n\\t\\t// This is 0th level in BFS i.e., 0 characters removed from the original string\\n        q.push(s);\\n        set.insert(s);\\n\\n        while (!q.empty())\\n        {\\n            string current = q.front(); q.pop();\\n\\n            if (isValidParenthesis(current))\\n            {\\n                found = true;\\n                results.push_back(current);\\n            }\\n\\n            // If we find at least one valid parenthesis at current level, \\n            // let skip looking for valid parenthesis at next levels.\\n            // In other words, just process the current queue\\n            \\n            // Because, at next levels, the valid parenthesis will be shorter than the current level. \\n            // Problem statement did not ask for valid parenthesis of all sizes,\\n            // it only asked for valid parenthesis of biggest size (one size)\\n            if (found == true)\\n                continue;\\n\\n            for (int i = 0; i < current.size(); i++)\\n            {\\n                if (current[i] != \\'(\\' && current[i] != \\')\\')\\n                    continue; \\n\\n                string temp = current.substr(0, i) + current.substr(i + 1);\\n\\n                if (set.find(temp) == set.end())\\n                {\\n                    q.push(temp);\\n                    set.insert(temp);\\n                }\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    bool isValidParenthesis(string input)\\n    {\\n        stack<char> s;\\n        for (int i = 0; i < input.size(); i++)\\n        {\\n            if (!s.empty() && input[i] == \\')\\' && s.top() == \\'(\\')\\n                s.pop();\\n            else if (input[i] == \\'(\\' || input[i] == \\')\\')\\n                s.push(input[i]);\\n        }\\n\\n        if (s.empty())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n    vector<string> removeInvalidParentheses(string s)\\n    {\\n        if (s == \"\")\\n            return { {} };\\n\\n        vector<string> results;\\n\\n        // bfs - Let\\'s do level-by-level\\n        queue<string> q;\\n        unordered_set<string> set;\\n        bool found = false;\\n\\n        // push the original string to queue. \\n\\t\\t// This is 0th level in BFS i.e., 0 characters removed from the original string\\n        q.push(s);\\n        set.insert(s);\\n\\n        while (!q.empty())\\n        {\\n            string current = q.front(); q.pop();\\n\\n            if (isValidParenthesis(current))\\n            {\\n                found = true;\\n                results.push_back(current);\\n            }\\n\\n            // If we find at least one valid parenthesis at current level, \\n            // let skip looking for valid parenthesis at next levels.\\n            // In other words, just process the current queue\\n            \\n            // Because, at next levels, the valid parenthesis will be shorter than the current level. \\n            // Problem statement did not ask for valid parenthesis of all sizes,\\n            // it only asked for valid parenthesis of biggest size (one size)\\n            if (found == true)\\n                continue;\\n\\n            for (int i = 0; i < current.size(); i++)\\n            {\\n                if (current[i] != \\'(\\' && current[i] != \\')\\')\\n                    continue; \\n\\n                string temp = current.substr(0, i) + current.substr(i + 1);\\n\\n                if (set.find(temp) == set.end())\\n                {\\n                    q.push(temp);\\n                    set.insert(temp);\\n                }\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    bool isValidParenthesis(string input)\\n    {\\n        stack<char> s;\\n        for (int i = 0; i < input.size(); i++)\\n        {\\n            if (!s.empty() && input[i] == \\')\\' && s.top() == \\'(\\')\\n                s.pop();\\n            else if (input[i] == \\'(\\' || input[i] == \\')\\')\\n                s.push(input[i]);\\n        }\\n\\n        if (s.empty())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494485,
                "title": "easy-c-solution-using-map-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find_min_removal(string s){\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(st.size()==0){\\n                    st.push(s[i]);\\n                }\\n                else{\\n                    if(st.top()==\\'(\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        st.push(s[i]);\\n                    } \\n                }\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        \\n        return st.size();\\n        \\n    }\\n\\n    void solve(int min_removal, string s, vector<string> &ans,unordered_map<string,int> &mpp){\\n        \\n        if(mpp[s]==1){ // Avoid duplicacy\\n            return;\\n        }\\n        \\n        mpp[s] = 1; //Add to the map\\n        if(min_removal==0){\\n            if(find_min_removal(s)==0){ //check for valid paranthesis\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=\\'(\\' and s[i]!=\\')\\'){    //if s[i] is a letter\\n                continue;\\n            }\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            string temp = left + right;\\n            solve(min_removal-1,temp,ans,mpp);\\n        }\\n    }\\n    \\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> ans;\\n        unordered_map<string,int> mpp;\\n        \\n        int min_removal = find_min_removal(s);\\n\\n        solve(min_removal,s,ans,mpp);\\n     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find_min_removal(string s){\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\')\\'){\\n                if(st.size()==0){\\n                    st.push(s[i]);\\n                }\\n                else{\\n                    if(st.top()==\\'(\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        st.push(s[i]);\\n                    } \\n                }\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        \\n        return st.size();\\n        \\n    }\\n\\n    void solve(int min_removal, string s, vector<string> &ans,unordered_map<string,int> &mpp){\\n        \\n        if(mpp[s]==1){ // Avoid duplicacy\\n            return;\\n        }\\n        \\n        mpp[s] = 1; //Add to the map\\n        if(min_removal==0){\\n            if(find_min_removal(s)==0){ //check for valid paranthesis\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=\\'(\\' and s[i]!=\\')\\'){    //if s[i] is a letter\\n                continue;\\n            }\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            string temp = left + right;\\n            solve(min_removal-1,temp,ans,mpp);\\n        }\\n    }\\n    \\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> ans;\\n        unordered_map<string,int> mpp;\\n        \\n        int min_removal = find_min_removal(s);\\n\\n        solve(min_removal,s,ans,mpp);\\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469426,
                "title": "python-3-bfs-solution-100ms-70",
                "content": "```python3\\nclass Solution:\\n    def __init__(self):\\n        self.max_length = -math.inf\\n    \\n    def check(self, s):\\n        x, y = 0, 0\\n        for i in s:\\n            if i == \"(\":\\n                x += 1\\n            elif i == \")\":\\n                if x == 0:\\n                    y += 1\\n                else:\\n                    x -= 1\\n        return x, y, x == y == 0\\n    \\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        q = [self.check(s)[:2] + (s,)]\\n        results = []\\n        used = set()\\n        valid_length = -math.inf\\n        \\n        while len(q) > 0:\\n            x, y, s = q.pop(0)\\n            if s in used:\\n                continue\\n            used.add(s)\\n            \\n            if len(s) < valid_length:\\n                break\\n            \\n            if x == y == 0 and self.check(s)[2]:\\n                valid_length = len(s)\\n                results.append(s)\\n                continue\\n\\n            last = None\\n            for index, i in enumerate(s):\\n                if i == last:\\n                    continue\\n                last = i\\n                \\n                if i != \"(\" and i != \")\":\\n                    continue\\n                if i == \"(\" and x - 1 < 0:\\n                    continue\\n                if i == \")\" and y - 1 < 0:\\n                    continue\\n                \\n                q.append((\\n                    x - 1 if i == \"(\" else x, \\n                    y - 1 if i == \")\" else y, \\n                    s[:index] + s[index+1:]\\n                ))\\n        \\n        return results\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python3\\nclass Solution:\\n    def __init__(self):\\n        self.max_length = -math.inf\\n    \\n    def check(self, s):\\n        x, y = 0, 0\\n        for i in s:\\n            if i == \"(\":\\n                x += 1\\n            elif i == \")\":\\n                if x == 0:\\n                    y += 1\\n                else:\\n                    x -= 1\\n        return x, y, x == y == 0\\n    \\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        q = [self.check(s)[:2] + (s,)]\\n        results = []\\n        used = set()\\n        valid_length = -math.inf\\n        \\n        while len(q) > 0:\\n            x, y, s = q.pop(0)\\n            if s in used:\\n                continue\\n            used.add(s)\\n            \\n            if len(s) < valid_length:\\n                break\\n            \\n            if x == y == 0 and self.check(s)[2]:\\n                valid_length = len(s)\\n                results.append(s)\\n                continue\\n\\n            last = None\\n            for index, i in enumerate(s):\\n                if i == last:\\n                    continue\\n                last = i\\n                \\n                if i != \"(\" and i != \")\":\\n                    continue\\n                if i == \"(\" and x - 1 < 0:\\n                    continue\\n                if i == \")\" and y - 1 < 0:\\n                    continue\\n                \\n                q.append((\\n                    x - 1 if i == \"(\" else x, \\n                    y - 1 if i == \")\" else y, \\n                    s[:index] + s[index+1:]\\n                ))\\n        \\n        return results\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461270,
                "title": "java-backtracking-no-comments",
                "content": "```\\nclass Solution {\\n    public int size = 0;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        HashSet<String> result = new HashSet<>();\\n        int left = 0, right = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                left++;\\n            } else if (s.charAt(i) == \\')\\' ) {\\n                if (left <= 0) right++;\\n                else left--;\\n            }\\n        }\\n        if (left + right == 0) result.add(s);\\n        else helper(s, left, right, 0, result);\\n        \\n        List<String> answer = new LinkedList<>(result);\\n        if (answer.isEmpty()) answer.add(\"\");\\n        \\n        return answer;\\n    }\\n    \\n    public void helper(String s, int left, int right, int i, HashSet<String> result) {\\n        if (left + right == 0 && isValid(s)) {\\n            result.add(s);\\n            return ;\\n        }\\n        if (i >= s.length()) return ;\\n        \\n        String tmp = s.substring(0, i) + s.substring(i+1, s.length());\\n        if (s.charAt(i) == \\')\\' && right > 0) {\\n            helper(tmp, left, right-1, i, result);\\n        } else if (s.charAt(i) == \\'(\\' && left > 0) {\\n            helper(tmp, left-1, right, i, result);\\n        }\\n        helper(s, left, right, i+1, result);\\n    }\\n    \\n    public boolean isValid(String s) {\\n        if (s.length() == 0) return true;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\\'(\\');\\n            } else if (s.charAt(i) == \\')\\') {\\n                if (stack.isEmpty()) return false;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int size = 0;\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        HashSet<String> result = new HashSet<>();\\n        int left = 0, right = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                left++;\\n            } else if (s.charAt(i) == \\')\\' ) {\\n                if (left <= 0) right++;\\n                else left--;\\n            }\\n        }\\n        if (left + right == 0) result.add(s);\\n        else helper(s, left, right, 0, result);\\n        \\n        List<String> answer = new LinkedList<>(result);\\n        if (answer.isEmpty()) answer.add(\"\");\\n        \\n        return answer;\\n    }\\n    \\n    public void helper(String s, int left, int right, int i, HashSet<String> result) {\\n        if (left + right == 0 && isValid(s)) {\\n            result.add(s);\\n            return ;\\n        }\\n        if (i >= s.length()) return ;\\n        \\n        String tmp = s.substring(0, i) + s.substring(i+1, s.length());\\n        if (s.charAt(i) == \\')\\' && right > 0) {\\n            helper(tmp, left, right-1, i, result);\\n        } else if (s.charAt(i) == \\'(\\' && left > 0) {\\n            helper(tmp, left-1, right, i, result);\\n        }\\n        helper(s, left, right, i+1, result);\\n    }\\n    \\n    public boolean isValid(String s) {\\n        if (s.length() == 0) return true;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\\'(\\');\\n            } else if (s.charAt(i) == \\')\\') {\\n                if (stack.isEmpty()) return false;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371129,
                "title": "c-concise-but-slow-bfs-solution-1800-ms",
                "content": "The idea is:\\n1) to find all valid substrings with removing some parentheses;\\n2) to pick valid substrings with maximum length.\\n\\nNote: Using an unordered_set<string> to filter out deplucated entries in each BFS iteration improves performance by 99% with reaching 16 ms.    \\n~~~\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        // {balance, left characters}\\n        // counting: \\'(\\': ++; \\')\\': --.\\n        queue<pair<int, string>> q;\\n        q.push({0, \"\"});\\n        \\n        // use bfs to find all substrings, \\n        for (auto c: s) {\\n            int size = q.size();\\n            for (int j = 0; j < size; ++j) {\\n                int b = q.front().first;\\n                string  v(q.front().second);\\n                q.pop();\\n                \\n                // removing current character\\n                if (c == \\'(\\' || c == \\')\\') q.push({b, v});\\n                // not valid\\n                if (c == \\')\\' && b == 0) continue; \\n                // keeping current character\\n                v.push_back(c);\\n                if (c == \\'(\\') q.push({b + 1, v});\\n                else if (c == \\')\\') q.push({b - 1, v});\\n                else q.push({b, v});\\n            }\\n        }\\n        \\n        // process results to  collect valid substrings with max length \\n        unordered_set<string> st;\\n        int len = 0;\\n        while (q.empty() == false) {\\n            string s = q.front().second;\\n            int a = q.front().first;\\n            q.pop();\\n            if (a > 0) continue;\\n            if (s.size() > len) len = s.size();\\n            st.insert(s);\\n        }\\n        vector<string> ret;\\n        for (auto it = st.begin(); it != st.end(); ++it) {\\n            if (it->size() == len) ret.push_back(*it);\\n        }\\n        return ret;\\n    }\\n};\\n~~!\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        // {balance, left characters}",
                "codeTag": "Java"
            },
            {
                "id": 1347372,
                "title": "simple-cpp-solution-using-recursion-and-backtrack-with-explanation-o-2-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    //Check if current string has balanced paranthesis\\n    bool isValid(string &str)\\n    {\\n        int count = 0;\\n        \\n        //Count open and close brackets in given string.\\n        for(auto ch : str)\\n        {\\n            if(ch == \\'(\\')\\n                count++;\\n            else if(ch == \\')\\')\\n                count--;\\n            \\n            //If at any time, we have more closing brackets than opening brackets, return false\\n            if(count < 0)\\n                return false;\\n        }\\n        \\n        if(count != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    void helper(string &s, int i, string &curr, vector<string> &res)\\n    {\\n        //If we have reached end of string, add to res\\n        if(i == s.size())\\n        {\\n            if(isValid(curr))\\n                res.push_back(curr);\\n            return;\\n        }\\n        \\n        //If we have an open or close bracket, don\\'t consider current character and recurse ahead\\n        if(s[i] == \\'(\\' || s[i] == \\')\\')\\n            helper(s, i+1, curr, res);\\n        \\n        //Consider current character and recurse\\n        curr += s[i];\\n        helper(s, i+1, curr, res);\\n        curr.pop_back();\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        vector<string> currRes, res;\\n        string curr = \"\";\\n        unordered_set<string> st;\\n        int maxLen = 0;\\n        \\n        //Find all valid balanced strings after removal of brackets.\\n        helper(s, 0, curr, currRes);\\n        \\n        //Find max length of all strings\\n        for(auto str : currRes)\\n            maxLen = max(maxLen, (int)str.size());\\n        \\n        //Find all the maxLen strings and take only the unique occurances of each\\n        for(auto str : currRes)\\n        {\\n            //If we have a maxLen string, check if it is unique, then push to res and mark is as seen in set\\n            if(str.size() == maxLen && st.find(str) == st.end())\\n            {\\n                res.push_back(str);\\n                st.insert(str);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //Check if current string has balanced paranthesis\\n    bool isValid(string &str)\\n    {\\n        int count = 0;\\n        \\n        //Count open and close brackets in given string.\\n        for(auto ch : str)\\n        {\\n            if(ch == \\'(\\')\\n                count++;\\n            else if(ch == \\')\\')\\n                count--;\\n            \\n            //If at any time, we have more closing brackets than opening brackets, return false\\n            if(count < 0)\\n                return false;\\n        }\\n        \\n        if(count != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    void helper(string &s, int i, string &curr, vector<string> &res)\\n    {\\n        //If we have reached end of string, add to res\\n        if(i == s.size())\\n        {\\n            if(isValid(curr))\\n                res.push_back(curr);\\n            return;\\n        }\\n        \\n        //If we have an open or close bracket, don\\'t consider current character and recurse ahead\\n        if(s[i] == \\'(\\' || s[i] == \\')\\')\\n            helper(s, i+1, curr, res);\\n        \\n        //Consider current character and recurse\\n        curr += s[i];\\n        helper(s, i+1, curr, res);\\n        curr.pop_back();\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        vector<string> currRes, res;\\n        string curr = \"\";\\n        unordered_set<string> st;\\n        int maxLen = 0;\\n        \\n        //Find all valid balanced strings after removal of brackets.\\n        helper(s, 0, curr, currRes);\\n        \\n        //Find max length of all strings\\n        for(auto str : currRes)\\n            maxLen = max(maxLen, (int)str.size());\\n        \\n        //Find all the maxLen strings and take only the unique occurances of each\\n        for(auto str : currRes)\\n        {\\n            //If we have a maxLen string, check if it is unique, then push to res and mark is as seen in set\\n            if(str.size() == maxLen && st.find(str) == st.end())\\n            {\\n                res.push_back(str);\\n                st.insert(str);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327924,
                "title": "java-clean-concise-bfs-solution",
                "content": "I think this problem should use BFS instead of DFS. Here is my code:\\n```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList<>();\\n        bfs(s, res);\\n        return res;\\n    }\\n    \\n    private void bfs(String s, List<String> res) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        q.add(s);\\n        seen.add(s);\\n        \\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n            s = q.poll();\\n            \\n            if (isValid(s)) {\\n                res.add(s);\\n                found = true;\\n            }\\n            if (found) { continue; }\\n            \\n            for (int i = 0; i < s.length(); i++) {\\n                char ch = s.charAt(i);\\n                if (ch == \\'(\\' || ch == \\')\\') {\\n                    String next = s.substring(0, i) + s.substring(i+1);\\n                    if (!seen.contains(next)) {\\n                        q.add(next);\\n                        seen.add(next);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'(\\') { count += 1; }\\n            if (ch == \\')\\') { count -= 1; }\\n            if (count < 0) { return false; }\\n        }\\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList<>();\\n        bfs(s, res);\\n        return res;\\n    }\\n    \\n    private void bfs(String s, List<String> res) {\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        q.add(s);\\n        seen.add(s);\\n        \\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n            s = q.poll();\\n            \\n            if (isValid(s)) {\\n                res.add(s);\\n                found = true;\\n            }\\n            if (found) { continue; }\\n            \\n            for (int i = 0; i < s.length(); i++) {\\n                char ch = s.charAt(i);\\n                if (ch == \\'(\\' || ch == \\')\\') {\\n                    String next = s.substring(0, i) + s.substring(i+1);\\n                    if (!seen.contains(next)) {\\n                        q.add(next);\\n                        seen.add(next);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isValid(String s) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'(\\') { count += 1; }\\n            if (ch == \\')\\') { count -= 1; }\\n            if (count < 0) { return false; }\\n        }\\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309295,
                "title": "c-solution-using-backtracking-and-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getMinInValid(string s)\\n    {\\n        stack<char> stck;\\n        int i=0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                stck.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(stck.size() > 0 && stck.top() == \\'(\\')\\n                    stck.pop();\\n                else\\n                    stck.push(\\')\\');\\n            }\\n            i++;\\n        }\\n        return stck.size();\\n    }\\n    \\n    bool isValid(string s)\\n    {\\n        stack<char> stck;\\n        int i=0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                stck.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(stck.size() > 0 && stck.top() == \\'(\\')\\n                    stck.pop();\\n                else\\n                    return false;\\n            }\\n            i++;\\n        }\\n        if(stck.size() != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<string> res;\\n    unordered_map<string,int> mp;\\n    void solve(string s,int minInv)\\n    {\\n        if(mp[s] != 0)\\n            return;\\n        else\\n            mp[s]++;\\n        if(minInv == 0)\\n        {\\n            if(isValid(s) == true)\\n                res.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            solve(left+right,minInv-1);\\n        }\\n            \\n        return;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        solve(s,getMinInValid(s));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getMinInValid(string s)\\n    {\\n        stack<char> stck;\\n        int i=0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                stck.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(stck.size() > 0 && stck.top() == \\'(\\')\\n                    stck.pop();\\n                else\\n                    stck.push(\\')\\');\\n            }\\n            i++;\\n        }\\n        return stck.size();\\n    }\\n    \\n    bool isValid(string s)\\n    {\\n        stack<char> stck;\\n        int i=0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                stck.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(stck.size() > 0 && stck.top() == \\'(\\')\\n                    stck.pop();\\n                else\\n                    return false;\\n            }\\n            i++;\\n        }\\n        if(stck.size() != 0)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<string> res;\\n    unordered_map<string,int> mp;\\n    void solve(string s,int minInv)\\n    {\\n        if(mp[s] != 0)\\n            return;\\n        else\\n            mp[s]++;\\n        if(minInv == 0)\\n        {\\n            if(isValid(s) == true)\\n                res.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            solve(left+right,minInv-1);\\n        }\\n            \\n        return;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        solve(s,getMinInValid(s));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292961,
                "title": "simple-java-1-ms-solution",
                "content": "/*\\n\\nWorkbook:\\n\\n\"()())()\"\\n\\nValid: - > \"()()()\", \"(())()\"\\n\\nInvalid: --> \"()())()\"\\n\\n( --> stack++ \\n) --> stack--\\n\\nif(stack < 0)  then invalid paranthesis\\n\\n\\nBruteForce Approach:\\nRemove each character and check if it valid or not and add to the result.\\n\\nNaive improvement: \\nFind extra num of right and left paranthesis and remove that many from given string and check if it is valid or not.\\n\\nOptimal Improvement:\\nFind extra right paranthesis and remove non consecutive character, check if it is valid or not and add it to the result.\\nreverse the string and check for the extra left paranthesis or not.\\n\\n*/\\n\\n\\nclass Solution {\\n    \\n    List<String> result= new ArrayList<>();\\n    \\n    public List<String> removeInvalidParentheses(String s) { \\n        \\n        removeParenthesesHelper(s,result,0,0,new char[]{\\'(\\',\\')\\'});        \\n        return result;\\n        \\n    }\\n    \\n    public void removeParenthesesHelper(String s, List<String> res, int left, int right,char[] param)\\n    {\\n        \\n        int stack=0;\\n        for(int i=left;i<s.length();i++)\\n        {\\n            if(s.charAt(i) == param[0])\\n                stack++;\\n            if(s.charAt(i) == param[1])\\n                stack--;\\n            \\n            if(stack >= 0) continue;\\n            \\n            \\n            StringBuilder sb1= new StringBuilder(s); \\n            \\n            for(int j= right; j <=i ;j++)\\n            {\\n                if(s.charAt(j) == param[1] && (j==right || s.charAt(j-1) != param[1]))\\n                {\\n                    char temp= sb1.charAt(j);\\n                    sb1.deleteCharAt(j);\\n                    removeParenthesesHelper(sb1.toString(),res,i,j,param);\\n                    sb1.insert(j,temp);\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        \\n        StringBuilder sb= new StringBuilder();        \\n        sb.append(s).reverse();\\n        \\n        if(param[0] == \\'(\\')\\n        {\\n              removeParenthesesHelper(sb.toString(),result,0,0,new char[]{\\')\\',\\'(\\'});\\n        }\\n        else\\n        {\\n            result.add(sb.toString());\\n        }\\n        \\n        \\n        \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    List<String> result= new ArrayList<>();\\n    \\n    public List<String> removeInvalidParentheses(String s) { \\n        \\n        removeParenthesesHelper(s,result,0,0,new char[]{\\'(\\',\\')\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1249118,
                "title": "python-dfs-solution-with-comments",
                "content": "\\n```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        #Calculate the number of unmatched left and right \\n\\n        redundant_open=0\\n        redundat_close=0\\n        \\n        for i in s:\\n            if i==\"(\":\\n                redundant_open+=1\\n            elif i==\")\":\\n                if redundant_open>0:\\n                    redundant_open-=1\\n                else:\\n\\t\\t\\t\\t        # If we don\\'t have a matching left, then this is a misplaced right, record it.\\n\\n                    redundat_close+=1\\n        \\n        ans=set()\\n        \\n        def dfs(index,left,right,ope,close,valid):\\n\\t\\t    # If we reached the end of the string, just check if the resulting expression is\\n            # valid or not and also if we have removed the total number of left and right\\n            # parentheses that we should have removed.\\n            if index==len(s):\\n                if left==right and ope==0 and close==0:\\n                    ans.add(valid)\\n                return \\n            \\n            if s[index]==\\'(\\':\\n                if ope>0:\\n                    dfs(index+1,left,right,ope-1,close,valid)\\n                    \\n                dfs(index+1,left+1,right,ope,close,valid+\"(\")\\n                \\n            elif s[index]==\\')\\':\\n                if close>0:\\n                    dfs(index+1,left,right,ope,close-1,valid)\\n                if  right<left:  \\n                    dfs(index+1,left,right+1,ope,close,valid+\")\")\\n            else:\\n                dfs(index+1,left,right,ope,close,valid+s[index])\\n                \\n                    \\n                \\n        dfs(0,0,0,redundant_open,redundat_close,\"\")\\n        return list(ans)\\n     \\n```\\n\\nTC= O(2**N)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        #Calculate the number of unmatched left and right \\n\\n        redundant_open=0\\n        redundat_close=0\\n        \\n        for i in s:\\n            if i==\"(\":\\n                redundant_open+=1\\n            elif i==\")\":\\n                if redundant_open>0:\\n                    redundant_open-=1\\n                else:\\n\\t\\t\\t\\t        # If we don\\'t have a matching left, then this is a misplaced right, record it.\\n\\n                    redundat_close+=1\\n        \\n        ans=set()\\n        \\n        def dfs(index,left,right,ope,close,valid):\\n\\t\\t    # If we reached the end of the string, just check if the resulting expression is\\n            # valid or not and also if we have removed the total number of left and right\\n            # parentheses that we should have removed.\\n            if index==len(s):\\n                if left==right and ope==0 and close==0:\\n                    ans.add(valid)\\n                return \\n            \\n            if s[index]==\\'(\\':\\n                if ope>0:\\n                    dfs(index+1,left,right,ope-1,close,valid)\\n                    \\n                dfs(index+1,left+1,right,ope,close,valid+\"(\")\\n                \\n            elif s[index]==\\')\\':\\n                if close>0:\\n                    dfs(index+1,left,right,ope,close-1,valid)\\n                if  right<left:  \\n                    dfs(index+1,left,right+1,ope,close,valid+\")\")\\n            else:\\n                dfs(index+1,left,right,ope,close,valid+s[index])\\n                \\n                    \\n                \\n        dfs(0,0,0,redundant_open,redundat_close,\"\")\\n        return list(ans)\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207868,
                "title": "python-solution-56ms-with-detailed-explanation",
                "content": "* if we want to get all valid parentheses from the given string, we have to figure out how many invalid parentheses are included in the string\\n* a common way to do this is recording the number of \"(\" before current index, if we meet \")\" deduct one from it. if no more \"(\" exits, then the current \")\" is invalid.\\n* After calculation, we are able to do DFS\\n* During the DFS, 3 cases need to be considered:\\n    * s[index] == \"(\":\\n        * we can skip current \"(\" if there are redundant \"(\" left\\n        * or we can put current \"(\" into the path\\n    * s[index] == \")\":\\n        * we can skip current \")\" if there are redundant \")\" left\\n        * or we can put current \")\" into the path, but only if we have more \"(\" than \")\" before. otherwise adding one more \")\" would result in invalid answer\\n    * s[index] == others:\\n        * other element in the string doesn\\'t matter, just put it into the path\\n\\nclass Solution:\\n\\n    def removeInvalidParentheses(self, s):\\n        redundant_left = 0\\n        redundant_right = 0\\n        # calculate the number of invalid parentheses\\n        for x in s:\\n            if x == \"(\":\\n                redundant_left+=1\\n            elif x==\")\":\\n                if redundant_left>0:\\n                    redundant_left-=1\\n                else:\\n                    redundant_right+=1\\n\\n        ans = set()\\n        def dfs(index, left_included, right_included, redundant_left, redundant_right, valid):\\n            if index == len(s):\\n                if right_included == left_included and redundant_left == redundant_right == 0:\\n                    ans.add(valid)\\n                return \\n            if s[index] == \"(\":\\n                if redundant_left>0:\\n                    dfs(index+1, left_included, right_included, redundant_left-1, redundant_right, valid)\\n                dfs(index+1, left_included+1, right_included, redundant_left, redundant_right, valid+\"(\")\\n            elif s[index] == \")\":\\n                if redundant_right>0:\\n                    dfs(index+1, left_included, right_included, redundant_left, redundant_right-1, valid)\\n                if right_included<left_included:\\n                    dfs(index+1, left_included, right_included+1, redundant_left, redundant_right, valid+\")\")\\n            else:\\n                dfs(index+1, left_included, right_included, redundant_left, redundant_right, valid+s[index])\\n        dfs(0, 0, 0, redundant_left, redundant_right, \"\")\\n        return list(ans)",
                "solutionTags": [
                    "Python"
                ],
                "code": "* if we want to get all valid parentheses from the given string, we have to figure out how many invalid parentheses are included in the string\\n* a common way to do this is recording the number of \"(\" before current index, if we meet \")\" deduct one from it. if no more \"(\" exits, then the current \")\" is invalid.\\n* After calculation, we are able to do DFS\\n* During the DFS, 3 cases need to be considered:\\n    * s[index] == \"(\":\\n        * we can skip current \"(\" if there are redundant \"(\" left\\n        * or we can put current \"(\" into the path\\n    * s[index] == \")\":\\n        * we can skip current \")\" if there are redundant \")\" left\\n        * or we can put current \")\" into the path, but only if we have more \"(\" than \")\" before. otherwise adding one more \")\" would result in invalid answer\\n    * s[index] == others:\\n        * other element in the string doesn\\'t matter, just put it into the path\\n\\nclass Solution:\\n\\n    def removeInvalidParentheses(self, s):\\n        redundant_left = 0\\n        redundant_right = 0\\n        # calculate the number of invalid parentheses\\n        for x in s:\\n            if x == \"(\":\\n                redundant_left+=1\\n            elif x==\")\":\\n                if redundant_left>0:\\n                    redundant_left-=1\\n                else:\\n                    redundant_right+=1\\n\\n        ans = set()\\n        def dfs(index, left_included, right_included, redundant_left, redundant_right, valid):\\n            if index == len(s):\\n                if right_included == left_included and redundant_left == redundant_right == 0:\\n                    ans.add(valid)\\n                return \\n            if s[index] == \"(\":\\n                if redundant_left>0:\\n                    dfs(index+1, left_included, right_included, redundant_left-1, redundant_right, valid)\\n                dfs(index+1, left_included+1, right_included, redundant_left, redundant_right, valid+\"(\")\\n            elif s[index] == \")\":\\n                if redundant_right>0:\\n                    dfs(index+1, left_included, right_included, redundant_left, redundant_right-1, valid)\\n                if right_included<left_included:\\n                    dfs(index+1, left_included, right_included+1, redundant_left, redundant_right, valid+\")\")\\n            else:\\n                dfs(index+1, left_included, right_included, redundant_left, redundant_right, valid+s[index])\\n        dfs(0, 0, 0, redundant_left, redundant_right, \"\")\\n        return list(ans)",
                "codeTag": "Java"
            },
            {
                "id": 1205760,
                "title": "c-recursion-backtracking-easy-to-understand-solution",
                "content": "Would really appreciate if anyone can help me with placing the backtracking at a better postion for improved performance!\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> checkMap;\\n    void solve(vector<string> &ans,string s,int count,string curr,int i,int n,int open,int closing){\\n        if(checkMap[curr]){\\n            return;\\n        }\\n        // cout<<curr<<\" \"<<i<<\" \"<<open<<\" \"<<closing<<\" \"<<count<<\" \"<<curr.length()<<\"\\\\n\";\\n        \\n        if(i==count && curr.length()==n && open==closing){\\n        \\n            if(!checkMap[curr]){\\n                ans.push_back(curr);\\n                checkMap[curr]=true;\\n            }\\n            return;\\n        }\\n        if(closing>open){\\n            return;\\n        }\\n        \\n        else{\\n            if(s[i]==\\'(\\'){\\n                    solve(ans,s,count,curr+\\'(\\',i+1,n,open+1,closing);\\n                    checkMap[curr+\\'(\\']=true;\\n                    solve(ans,s,count,curr,i+1,n,open,closing);\\n                    checkMap[curr]=true;\\n\\n            }else if(s[i]==\\')\\'){\\n                    solve(ans,s,count,curr+\\')\\',i+1,n,open,closing+1);\\n                    checkMap[curr+\\')\\']=true;\\n                    solve(ans,s,count,curr,i+1,n,open,closing);        \\n                    checkMap[curr]=true;\\n            }else if(isalpha(s[i])){\\n                solve(ans,s,count,curr+s[i],i+1,n,open,closing);\\n                checkMap[curr+s[i]]=true;\\n\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n       \\n        vector<string> ans;\\n        int count=0;\\n        int lCount=0,rCount=0;\\n        for(auto p:s){\\n            if(p==\\'(\\'){\\n                lCount++;\\n            }else if(p==\\')\\'){\\n                if(lCount>0){\\n                    lCount--;\\n                }else{\\n                    rCount++;\\n                }\\n            }\\n        }\\n        count+=lCount+rCount;\\n        cout<<count;\\n\\n        solve(ans,s,s.length(),\"\",0,s.length()-count,0,0);\\n        // cout<<count;\\n        if(ans.size()<1){\\n            return {\"\"};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> checkMap;\\n    void solve(vector<string> &ans,string s,int count,string curr,int i,int n,int open,int closing){\\n        if(checkMap[curr]){\\n            return;\\n        }\\n        // cout<<curr<<\" \"<<i<<\" \"<<open<<\" \"<<closing<<\" \"<<count<<\" \"<<curr.length()<<\"\\\\n\";\\n        \\n        if(i==count && curr.length()==n && open==closing){\\n        \\n            if(!checkMap[curr]){\\n                ans.push_back(curr);\\n                checkMap[curr]=true;\\n            }\\n            return;\\n        }\\n        if(closing>open){\\n            return;\\n        }\\n        \\n        else{\\n            if(s[i]==\\'(\\'){\\n                    solve(ans,s,count,curr+\\'(\\',i+1,n,open+1,closing);\\n                    checkMap[curr+\\'(\\']=true;\\n                    solve(ans,s,count,curr,i+1,n,open,closing);\\n                    checkMap[curr]=true;\\n\\n            }else if(s[i]==\\')\\'){\\n                    solve(ans,s,count,curr+\\')\\',i+1,n,open,closing+1);\\n                    checkMap[curr+\\')\\']=true;\\n                    solve(ans,s,count,curr,i+1,n,open,closing);        \\n                    checkMap[curr]=true;\\n            }else if(isalpha(s[i])){\\n                solve(ans,s,count,curr+s[i],i+1,n,open,closing);\\n                checkMap[curr+s[i]]=true;\\n\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n       \\n        vector<string> ans;\\n        int count=0;\\n        int lCount=0,rCount=0;\\n        for(auto p:s){\\n            if(p==\\'(\\'){\\n                lCount++;\\n            }else if(p==\\')\\'){\\n                if(lCount>0){\\n                    lCount--;\\n                }else{\\n                    rCount++;\\n                }\\n            }\\n        }\\n        count+=lCount+rCount;\\n        cout<<count;\\n\\n        solve(ans,s,s.length(),\"\",0,s.length()-count,0,0);\\n        // cout<<count;\\n        if(ans.size()<1){\\n            return {\"\"};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 997987,
                "title": "c-dfs-time-o-n-2-n-space-o-n",
                "content": "Time Complexity: \\n```\\nT(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)\\n```\\nwhich is O (n * 2^N)\\nSpace Complexity: O (N) (Depth of Recursion Calls)\\n\\nFor more analysis on Time and Space, I referred [this](https://leetcode.com/problems/remove-invalid-parentheses/discuss/167659/Time-Complexity-Analysis-O(n*2n)) by @code-junkie and [this ](https://leetcode.com/problems/remove-invalid-parentheses/discuss/75032/Share-my-Java-BFS-solution) by @jeantimex\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string str) {\\n        unordered_set <string> res;\\n        int left=0, right=0; //these count the invalid brackets\\n        for (char c: str) {\\n            if (c==\\'(\\') left++;\\n            else if (c==\\')\\') {\\n                if (left!=0) left--;\\n                else right++;\\n            }\\n        }\\n        dfs (str, 0, left, right, 0, \"\", res);\\n        return vector<string>(res.begin(), res.end());\\n    }\\n    void dfs (string s, int index, int left, int right, int pair, string tempRes, unordered_set <string>&res) {\\n        if (index==s.size()) {\\n            if (left==0 && right==0 && pair==0) res.insert (tempRes);\\n            return;\\n        }\\n        if (isalpha(s[index])) dfs (s, index+1, left, right, pair, tempRes+s[index], res);\\n        else {\\n            if (s[index]==\\'(\\') {\\n                if (left>0) dfs (s, index+1, left-1, right, pair, tempRes, res);\\n                dfs (s, index+1, left, right, pair+1, tempRes+s[index], res);\\n            }\\n            if (s[index]==\\')\\') {\\n                if (right>0) dfs (s, index+1, left, right-1, pair, tempRes, res);\\n                if (pair>0)dfs (s, index+1, left, right, pair-1, tempRes+s[index], res);\\n            }\\n        }\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nT(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeInvalidParentheses(string str) {\\n        unordered_set <string> res;\\n        int left=0, right=0; //these count the invalid brackets\\n        for (char c: str) {\\n            if (c==\\'(\\') left++;\\n            else if (c==\\')\\') {\\n                if (left!=0) left--;\\n                else right++;\\n            }\\n        }\\n        dfs (str, 0, left, right, 0, \"\", res);\\n        return vector<string>(res.begin(), res.end());\\n    }\\n    void dfs (string s, int index, int left, int right, int pair, string tempRes, unordered_set <string>&res) {\\n        if (index==s.size()) {\\n            if (left==0 && right==0 && pair==0) res.insert (tempRes);\\n            return;\\n        }\\n        if (isalpha(s[index])) dfs (s, index+1, left, right, pair, tempRes+s[index], res);\\n        else {\\n            if (s[index]==\\'(\\') {\\n                if (left>0) dfs (s, index+1, left-1, right, pair, tempRes, res);\\n                dfs (s, index+1, left, right, pair+1, tempRes+s[index], res);\\n            }\\n            if (s[index]==\\')\\') {\\n                if (right>0) dfs (s, index+1, left, right-1, pair, tempRes, res);\\n                if (pair>0)dfs (s, index+1, left, right, pair-1, tempRes+s[index], res);\\n            }\\n        }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956399,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s):\\n        self.ans = set()\\n        self.min_removed = float(\"inf\")\\n\\n        def dfs(depth, left, right, removed, cur):\\n            if depth == len(s):\\n                if left == right:\\n                    if removed < self.min_removed:\\n                        self.min_removed = removed\\n                        self.ans = {cur}\\n                    elif removed == self.min_removed:\\n                        self.ans.add(cur)\\n                \\n                return\\n\\n            if s[depth] == \"(\":\\n                # delete it\\n                dfs(depth + 1, left, right, removed + 1, cur)\\n                \\n                # keep it\\n                dfs(depth + 1, left + 1, right, removed, cur + s[depth])\\n                \\n            elif s[depth] == \")\":\\n                # delete it\\n                dfs(depth + 1, left, right, removed + 1, cur)\\n                \\n                # keep it\\n                if left > right:\\n                    dfs(depth + 1, left, right + 1, removed, cur + s[depth])\\n            else:\\n                dfs(depth + 1, left, right, removed, cur + s[depth])\\n\\n        dfs(0, 0, 0, 0, \"\")\\n        return list(self.ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeInvalidParentheses(self, s):\\n        self.ans = set()\\n        self.min_removed = float(\"inf\")\\n\\n        def dfs(depth, left, right, removed, cur):\\n            if depth == len(s):\\n                if left == right:\\n                    if removed < self.min_removed:\\n                        self.min_removed = removed\\n                        self.ans = {cur}\\n                    elif removed == self.min_removed:\\n                        self.ans.add(cur)\\n                \\n                return\\n\\n            if s[depth] == \"(\":\\n                # delete it\\n                dfs(depth + 1, left, right, removed + 1, cur)\\n                \\n                # keep it\\n                dfs(depth + 1, left + 1, right, removed, cur + s[depth])\\n                \\n            elif s[depth] == \")\":\\n                # delete it\\n                dfs(depth + 1, left, right, removed + 1, cur)\\n                \\n                # keep it\\n                if left > right:\\n                    dfs(depth + 1, left, right + 1, removed, cur + s[depth])\\n            else:\\n                dfs(depth + 1, left, right, removed, cur + s[depth])\\n\\n        dfs(0, 0, 0, 0, \"\")\\n        return list(self.ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899135,
                "title": "java-easy-solution-with-comments-faster-then-99-98-stack-and-2-pointers",
                "content": "we can use stack or a counter to iterate the sting\\n\\n( -> stack ++\\n) -> stack --\\n\\nif stack < 0 exit --> we have to remove \\')\\'\\n\\nif stack < 0\\nwe need a pointer that should point to the location where we\\'ve seen the invalid parenthesis\\npointer starts from 0 to that place, and remove a close parenthesis and call the helper function again\\nwe need to recursively check the rest part we also need handle the duplicates results\\n\\nelse if stack > 0\\nneed to remove \\'(\\'\\nreverse string to reuse the code\\n\\nelse add string to result list\\n(ordered or reversed ordered)\\nif left is \\')\\' and right is \\'(\\' we\\'ve to reverse them\\n\\nclass Solution\\n{\\n    public List<String> removeInvalidParentheses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        int left_pointer = 0;\\n        int right_pointer = 0;\\n        char[] paren_type =  new char[] {\\'(\\', \\')\\'};\\n        helper(s, left_pointer, right_pointer, result, paren_type);\\n        return result;\\n    }\\n\\n    private void helper(String s, int left, int right, List<String> result, char[] parenthesis)\\n    {\\n        int stack = 0;\\n\\n        // first we need to move the right pointer to check whether \\'closed parenthesis\\' > \\'no. of open parenthesis\\'\\n\\n        int n = s.length();\\n        for (; right < n; right ++)\\n        {\\n            char c = s.charAt(right);\\n            if (c == parenthesis[0])    // open parenthesis\\n                stack ++;\\n            else if (c == parenthesis[1])\\n                stack --;\\n            if (stack < 0)\\n                break;\\n        }\\n\\n        if (stack < 0)    // we need to remove one closed parenthesis\\n        {\\n\\n            // move the left pointer and keep the right pointer stay at his place\\n\\n            for(; left <= right; left++)\\n            {\\n                char c = s.charAt(left);\\n\\n                // we need to remove the close parenthesis, so if this char is not a closed parenthesis just continue\\n\\n                if (c != parenthesis[1])\\n                    continue;\\n\\n                // we also need to avoid duplicates; we can remove either the first seen closed parenthesis or the next\\n                // but not the last\\n\\n                if (left > 1 && s.charAt(left) == s.charAt(left - 1))  // continue if current elem. == next elem.\\n                    continue;\\n\\n                helper(s.substring(0, left) + s.substring(left + 1), left, right, result, parenthesis);\\n\\n            }\\n        }\\n        else if (stack > 0)\\n\\n            // we just need to reverse the order\\n\\n            helper(new StringBuilder(s).reverse().toString(), 0, 0, result, new char[] {\\')\\', \\'(\\'});\\n\\n        else\\n            result.add(parenthesis[0] == \\'(\\' ? s : new StringBuilder(s).reverse().toString());\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public List<String> removeInvalidParentheses(String s)\\n    {\\n        List<String> result = new ArrayList<>();\\n        int left_pointer = 0;\\n        int right_pointer = 0;\\n        char[] paren_type =  new char[] {\\'(\\', \\')\\'}",
                "codeTag": "Java"
            },
            {
                "id": 834665,
                "title": "js-dfs",
                "content": "For each char you can decide to leave it or remove it. This forms a tree-like structure with a time complexity of 2^N, being N the length of the string.\\nLuckily do some optimizations.\\nThe first one is to use memoization for the previously seen strings. Imagine we have the following string \"( ) ) ( )\". If we remove the first or second \")\" the resulting string would be the same.\\nThe second one is to stop removing chars if we have already reached the minimum amount of chars to form a valid string. For example with \"( ) ) ( )\" as soon as we remove the first \")\" we reach a valid string, so we don\\'t need remove any more chars. Of course that removing \") ( )\" would also result on a valid string, but the problem asks to remove the minimum amount of parenthesis.\\nThe last optimization is to keep track of the count of  opened and closed parenthesis. If we see a \"(\" we increase opens by 1 and if its a \")\" we decrease it. So if reach a point where opens is less than 0, we know we should stop checking because it won\\'t be valid.\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar removeInvalidParentheses = function(s) {\\n    let minRemoved = [Infinity];\\n    let answer = [[]];\\n    helper(\"\", s, 0, minRemoved,answer,{}, 0);\\n    return answer[0];\\n};\\nfunction helper(prefix, current, removedCount, min,answer, cache, opens){\\n\\t//memoization\\n    if(cache[prefix])\\n        return;    \\n    if(!current.length){\\n        const valid = opens === 0;\\n        cache[prefix] = true;\\n        if(valid){\\n            if(min[0] !== removedCount){\\n                answer[0] = [prefix];\\n            }else{\\n                answer[0].push(prefix);\\n            }\\n            min[0] = removedCount;\\n        }\\n        return;\\n    }\\n\\t//opens count\\n    const valid = opens >= 0;\\n    if(!valid)return;\\n    const char = current[0];\\n    const next = current.substr(1);\\n    //don\\'t remove\\n    helper(prefix+char, next, removedCount, min, answer, cache, char===\"(\"?opens+1:char===\")\"?opens-1:opens);\\n    //remove only the char is a \"(\" or \")\" and if by removing one we wouldn\\'t be exceding the current minumum of removed chars.\\n    if((char === \"(\"  || char === \")\") && removedCount < min[0])\\n        helper(prefix, next, removedCount+1, min, answer, cache, opens);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar removeInvalidParentheses = function(s) {\\n    let minRemoved = [Infinity];\\n    let answer = [[]];\\n    helper(\"\", s, 0, minRemoved,answer,{}, 0);\\n    return answer[0];\\n};\\nfunction helper(prefix, current, removedCount, min,answer, cache, opens){\\n\\t//memoization\\n    if(cache[prefix])\\n        return;    \\n    if(!current.length){\\n        const valid = opens === 0;\\n        cache[prefix] = true;\\n        if(valid){\\n            if(min[0] !== removedCount){\\n                answer[0] = [prefix];\\n            }else{\\n                answer[0].push(prefix);\\n            }\\n            min[0] = removedCount;\\n        }\\n        return;\\n    }\\n\\t//opens count\\n    const valid = opens >= 0;\\n    if(!valid)return;\\n    const char = current[0];\\n    const next = current.substr(1);\\n    //don\\'t remove\\n    helper(prefix+char, next, removedCount, min, answer, cache, char===\"(\"?opens+1:char===\")\"?opens-1:opens);\\n    //remove only the char is a \"(\" or \")\" and if by removing one we wouldn\\'t be exceding the current minumum of removed chars.\\n    if((char === \"(\"  || char === \")\") && removedCount < min[0])\\n        helper(prefix, next, removedCount+1, min, answer, cache, opens);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 828545,
                "title": "simple-java-bfs-solution",
                "content": "```\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if(s == null) return res;\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.offer(s);\\n        visited.add(s);\\n        boolean found = false;\\n        while(q.size() > 0) {\\n            String curr = q.poll();\\n            if(isValid(curr)) {\\n                res.add(curr);\\n                found = true;\\n            }\\n            if(found) continue;\\n            for(int i=0; i<curr.length();i++) {\\n                if(curr.charAt(i) != \\'(\\' && curr.charAt(i) != \\')\\') continue;\\n                String newStr = curr.substring(0, i) + curr.substring(i+1);\\n                if(visited.contains(newStr)) continue;\\n                q.offer(newStr);\\n                visited.add(newStr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isValid(String s) {\\n        int count = 0;\\n        for(char c: s.toCharArray()) {\\n            if(c == \\'(\\') count++;\\n            if(c == \\')\\') {\\n                if(count <= 0) return false;\\n                count--;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> removeInvalidParentheses(String s) {\\n        List<String> res = new ArrayList<>();\\n        if(s == null) return res;\\n        Queue<String> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.offer(s);\\n        visited.add(s);\\n        boolean found = false;\\n        while(q.size() > 0) {\\n            String curr = q.poll();\\n            if(isValid(curr)) {\\n                res.add(curr);\\n                found = true;\\n            }\\n            if(found) continue;\\n            for(int i=0; i<curr.length();i++) {\\n                if(curr.charAt(i) != \\'(\\' && curr.charAt(i) != \\')\\') continue;\\n                String newStr = curr.substring(0, i) + curr.substring(i+1);\\n                if(visited.contains(newStr)) continue;\\n                q.offer(newStr);\\n                visited.add(newStr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isValid(String s) {\\n        int count = 0;\\n        for(char c: s.toCharArray()) {\\n            if(c == \\'(\\') count++;\\n            if(c == \\')\\') {\\n                if(count <= 0) return false;\\n                count--;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826480,
                "title": "brain-teaser-i-did-a-stupid-thing-in-my-coding-round",
                "content": "Code never lies!!! Yes..!! No room for silly mistake\\n\\nJust one \\'&\\' can change lives !!\\nIn my coding round, I spent 45 minutes on this question but couldn\\'t pass all the test cases.\\nAll because I had missed a \\'&\\'....\\n\\nSo, giving you guys a max 5 minute time task to find out which one/ones of the following will give a correct answer !!\\n\\nSolution 1:\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    set<string> res;\\n    int mincnt;\\n    vector<string> removeInvalidParentheses(string s) {\\n        n=s.length();\\n        mincnt=INT_MAX; string tmp;\\n        dfs(s, 0, 0, tmp, 0, 0); \\n        vector<string> ans(res.begin(), res.end());\\n        return ans;\\n    }\\n    \\n    void dfs(string& s, int lc, int rc, string sb, int removecnt, int indx ){\\n        // cout<<indx<<\" \"<<sb<<\" \"<<endl;\\n        int i=indx;\\n        if(indx==n){\\n            // cout<<\"end---: \"<<sb<<endl;\\n            if(removecnt==mincnt && lc==rc){   \\n                res.insert(sb);  return;\\n            }\\n            else{\\n                if(mincnt>removecnt && lc==rc){\\n                    mincnt = removecnt;\\n                    res.clear();\\n                    res.insert(sb); return ;\\n                }\\n            }\\n            return;\\n        }\\n        else{\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\'){   // if none of the parantheses\\n                sb.push_back(s[i]) ;\\n                dfs(s, lc, rc, sb , removecnt, indx+1);    // append the character and iterate further\\n                // sb.pop_back();      //< even if I comment this line, I am getting Correct answer. Can anyone explain why\\n            }\\n            else\\n            {\\n                dfs(s, lc, rc, sb, removecnt+1, indx+1);\\n                sb.push_back(s[i]);\\n                if(s[indx]==\\'(\\'){\\n                    dfs(s, lc+1, rc, sb, removecnt, indx+1);\\n                }\\n                else if(lc>rc){\\n                    dfs(s, lc, rc+1, sb, removecnt, indx+1);\\n                }\\n               sb.pop_back(); \\n            }\\n        }\\n        // cout<<sb<<endl;\\n        return ;\\n    }\\n};\\n```\\n\\n\\nsolution2:\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    set<string> res;\\n    int mincnt;\\n    vector<string> removeInvalidParentheses(string s) {\\n        n=s.length();\\n        mincnt=INT_MAX; string tmp;\\n        dfs(s, 0, 0, tmp, 0, 0); \\n        vector<string> ans(res.begin(), res.end());\\n        return ans;\\n    }\\n    \\n    void dfs(string& s, int lc, int rc, string& sb, int removecnt, int indx ){\\n        // cout<<indx<<\" \"<<sb<<\" \"<<endl;\\n        int i=indx;\\n        if(indx==n){\\n            // cout<<\"end---: \"<<sb<<endl;\\n            if(removecnt==mincnt && lc==rc){   \\n                res.insert(sb);  return;\\n            }\\n            else{\\n                if(mincnt>removecnt && lc==rc){\\n                    mincnt = removecnt;\\n                    res.clear();\\n                    res.insert(sb); return ;\\n                }\\n            }\\n            return;\\n        }\\n        else{\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\'){   // if none of the parantheses\\n                sb.push_back(s[i]) ;\\n                dfs(s, lc, rc, sb , removecnt, indx+1);    // append the character and iterate further\\n                sb.pop_back();\\n            }\\n            else\\n            {\\n                dfs(s, lc, rc, sb, removecnt+1, indx+1);\\n                sb.push_back(s[i]);\\n                if(s[indx]==\\'(\\'){\\n                    dfs(s, lc+1, rc, sb, removecnt, indx+1);\\n                }\\n                else if(lc>rc){\\n                    dfs(s, lc, rc+1, sb, removecnt, indx+1);\\n                }\\n               sb.pop_back(); \\n            }\\n        }\\n        // cout<<sb<<endl;\\n        return ;\\n    }\\n};\\n```\\nSolution 3:\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    set<string> res;\\n    int mincnt;\\n    vector<string> removeInvalidParentheses(string s) {\\n        n=s.length();\\n        mincnt=INT_MAX; string tmp;\\n        dfs(s, 0, 0, tmp, 0, 0); \\n        vector<string> ans(res.begin(), res.end());\\n        return ans;\\n    }\\n    \\n    void dfs(string& s, int lc, int rc, string sb, int removecnt, int indx ){\\n        // cout<<indx<<\" \"<<sb<<\" \"<<endl;\\n        int i=indx;\\n        if(indx==n){\\n            // cout<<\"end---: \"<<sb<<endl;\\n            if(removecnt==mincnt && lc==rc){   \\n                res.insert(sb);  return;\\n            }\\n            else{\\n                if(mincnt>removecnt && lc==rc){\\n                    mincnt = removecnt;\\n                    res.clear();\\n                    res.insert(sb); return ;\\n                }\\n            }\\n            return;\\n        }\\n        else{\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\'){   // if none of the parantheses\\n                sb.push_back(s[i]) ;\\n                dfs(s, lc, rc, sb , removecnt, indx+1);    // append the character and iterate further\\n                sb.pop_back();\\n            }\\n            else\\n            {\\n                dfs(s, lc, rc, sb, removecnt+1, indx+1);\\n                sb.push_back(s[i]);\\n                if(s[indx]==\\'(\\'){\\n                    dfs(s, lc+1, rc, sb, removecnt, indx+1);\\n                }\\n                else if(lc>rc){\\n                    dfs(s, lc, rc+1, sb, removecnt, indx+1);\\n                }\\n               sb.pop_back(); \\n            }\\n        }\\n        // cout<<sb<<endl;\\n        return ;\\n    }\\n};\\n```\\n\\nCan you tell without running which one will yield WA ????",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    set<string> res;\\n    int mincnt;\\n    vector<string> removeInvalidParentheses(string s) {\\n        n=s.length();\\n        mincnt=INT_MAX; string tmp;\\n        dfs(s, 0, 0, tmp, 0, 0); \\n        vector<string> ans(res.begin(), res.end());\\n        return ans;\\n    }\\n    \\n    void dfs(string& s, int lc, int rc, string sb, int removecnt, int indx ){\\n        // cout<<indx<<\" \"<<sb<<\" \"<<endl;\\n        int i=indx;\\n        if(indx==n){\\n            // cout<<\"end---: \"<<sb<<endl;\\n            if(removecnt==mincnt && lc==rc){   \\n                res.insert(sb);  return;\\n            }\\n            else{\\n                if(mincnt>removecnt && lc==rc){\\n                    mincnt = removecnt;\\n                    res.clear();\\n                    res.insert(sb); return ;\\n                }\\n            }\\n            return;\\n        }\\n        else{\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\'){   // if none of the parantheses\\n                sb.push_back(s[i]) ;\\n                dfs(s, lc, rc, sb , removecnt, indx+1);    // append the character and iterate further\\n                // sb.pop_back();      //< even if I comment this line, I am getting Correct answer. Can anyone explain why\\n            }\\n            else\\n            {\\n                dfs(s, lc, rc, sb, removecnt+1, indx+1);\\n                sb.push_back(s[i]);\\n                if(s[indx]==\\'(\\'){\\n                    dfs(s, lc+1, rc, sb, removecnt, indx+1);\\n                }\\n                else if(lc>rc){\\n                    dfs(s, lc, rc+1, sb, removecnt, indx+1);\\n                }\\n               sb.pop_back(); \\n            }\\n        }\\n        // cout<<sb<<endl;\\n        return ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    set<string> res;\\n    int mincnt;\\n    vector<string> removeInvalidParentheses(string s) {\\n        n=s.length();\\n        mincnt=INT_MAX; string tmp;\\n        dfs(s, 0, 0, tmp, 0, 0); \\n        vector<string> ans(res.begin(), res.end());\\n        return ans;\\n    }\\n    \\n    void dfs(string& s, int lc, int rc, string& sb, int removecnt, int indx ){\\n        // cout<<indx<<\" \"<<sb<<\" \"<<endl;\\n        int i=indx;\\n        if(indx==n){\\n            // cout<<\"end---: \"<<sb<<endl;\\n            if(removecnt==mincnt && lc==rc){   \\n                res.insert(sb);  return;\\n            }\\n            else{\\n                if(mincnt>removecnt && lc==rc){\\n                    mincnt = removecnt;\\n                    res.clear();\\n                    res.insert(sb); return ;\\n                }\\n            }\\n            return;\\n        }\\n        else{\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\'){   // if none of the parantheses\\n                sb.push_back(s[i]) ;\\n                dfs(s, lc, rc, sb , removecnt, indx+1);    // append the character and iterate further\\n                sb.pop_back();\\n            }\\n            else\\n            {\\n                dfs(s, lc, rc, sb, removecnt+1, indx+1);\\n                sb.push_back(s[i]);\\n                if(s[indx]==\\'(\\'){\\n                    dfs(s, lc+1, rc, sb, removecnt, indx+1);\\n                }\\n                else if(lc>rc){\\n                    dfs(s, lc, rc+1, sb, removecnt, indx+1);\\n                }\\n               sb.pop_back(); \\n            }\\n        }\\n        // cout<<sb<<endl;\\n        return ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    set<string> res;\\n    int mincnt;\\n    vector<string> removeInvalidParentheses(string s) {\\n        n=s.length();\\n        mincnt=INT_MAX; string tmp;\\n        dfs(s, 0, 0, tmp, 0, 0); \\n        vector<string> ans(res.begin(), res.end());\\n        return ans;\\n    }\\n    \\n    void dfs(string& s, int lc, int rc, string sb, int removecnt, int indx ){\\n        // cout<<indx<<\" \"<<sb<<\" \"<<endl;\\n        int i=indx;\\n        if(indx==n){\\n            // cout<<\"end---: \"<<sb<<endl;\\n            if(removecnt==mincnt && lc==rc){   \\n                res.insert(sb);  return;\\n            }\\n            else{\\n                if(mincnt>removecnt && lc==rc){\\n                    mincnt = removecnt;\\n                    res.clear();\\n                    res.insert(sb); return ;\\n                }\\n            }\\n            return;\\n        }\\n        else{\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\'){   // if none of the parantheses\\n                sb.push_back(s[i]) ;\\n                dfs(s, lc, rc, sb , removecnt, indx+1);    // append the character and iterate further\\n                sb.pop_back();\\n            }\\n            else\\n            {\\n                dfs(s, lc, rc, sb, removecnt+1, indx+1);\\n                sb.push_back(s[i]);\\n                if(s[indx]==\\'(\\'){\\n                    dfs(s, lc+1, rc, sb, removecnt, indx+1);\\n                }\\n                else if(lc>rc){\\n                    dfs(s, lc, rc+1, sb, removecnt, indx+1);\\n                }\\n               sb.pop_back(); \\n            }\\n        }\\n        // cout<<sb<<endl;\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 780115,
                "title": "c-dfs-solution-12-ms-8-2mb-faster-than-80-4",
                "content": "```\\nclass Solution {\\n    //check if the string str has matched parenthesis\\n    bool isValid(const string& str)\\n    {\\n        int cnt = 0;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(str[i] == \\'(\\')  cnt++;\\n            if(str[i] == \\')\\') cnt--;\\n            if(cnt<0) return 0;\\n        }\\n        return cnt == 0;\\n    }\\n    void dfs(const string s, int start, int l, int r, vector<string>& ans ){\\n        if(l==0 && r==0){\\n            if(isValid(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=start; i<s.length();i++){\\n            if(i!=start && s[i]==s[i-1])//skip duplicate patenthesis, only remove the first encountered one\\n\\t\\t\\t//e.g. consider this case \"(()\" , removing the first encountered \"(\" result in the same solution as removing the second \"(\", same applies to case \"())\" for removing \")\"\\n                continue;\\n            \\n            \\n            //first remove all the right parenthesis: \\n            //consider this case: \")()(()\" if we remove the first (  then we have \"))(()\",  we make the second ) invalid\\n            if(s[i]==\\')\\' && r>0){\\n                string curr = s;\\n                curr.erase(i,1);//erase current \")\"\\n                dfs(curr,i, l, r-1, ans);\\n            }else if(s[i]==\\'(\\' && l>0){\\n                string curr = s;\\n                curr.erase(i,1);//erase current \"(\"\\n                dfs(curr,i, l-1, r, ans);\\n            }\\n\\n        }\\n        \\n    }\\n    \\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> res;\\n        int l = 0, r = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')  l++;\\n            if(s[i] == \\')\\'){\\n                if(l!=0) l--;\\n                else r++;\\n            }   \\n        }\\n\\t\\t//l: how many \"(\" to remove in s, r: how many \")\" to remove in s\\n        dfs(s,0,l, r, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //check if the string str has matched parenthesis\\n    bool isValid(const string& str)\\n    {\\n        int cnt = 0;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(str[i] == \\'(\\')  cnt++;\\n            if(str[i] == \\')\\') cnt--;\\n            if(cnt<0) return 0;\\n        }\\n        return cnt == 0;\\n    }\\n    void dfs(const string s, int start, int l, int r, vector<string>& ans ){\\n        if(l==0 && r==0){\\n            if(isValid(s))\\n                ans.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=start; i<s.length();i++){\\n            if(i!=start && s[i]==s[i-1])//skip duplicate patenthesis, only remove the first encountered one\\n\\t\\t\\t//e.g. consider this case \"(()\" , removing the first encountered \"(\" result in the same solution as removing the second \"(\", same applies to case \"())\" for removing \")\"\\n                continue;\\n            \\n            \\n            //first remove all the right parenthesis: \\n            //consider this case: \")()(()\" if we remove the first (  then we have \"))(()\",  we make the second ) invalid\\n            if(s[i]==\\')\\' && r>0){\\n                string curr = s;\\n                curr.erase(i,1);//erase current \")\"\\n                dfs(curr,i, l, r-1, ans);\\n            }else if(s[i]==\\'(\\' && l>0){\\n                string curr = s;\\n                curr.erase(i,1);//erase current \"(\"\\n                dfs(curr,i, l-1, r, ans);\\n            }\\n\\n        }\\n        \\n    }\\n    \\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> res;\\n        int l = 0, r = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')  l++;\\n            if(s[i] == \\')\\'){\\n                if(l!=0) l--;\\n                else r++;\\n            }   \\n        }\\n\\t\\t//l: how many \"(\" to remove in s, r: how many \")\" to remove in s\\n        dfs(s,0,l, r, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651314,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidString(string str) { \\n        int cnt = 0; \\n        for (int i = 0; i < str.length(); i++) { \\n            if (str[i] == \\'(\\') cnt++; \\n            else if (str[i] == \\')\\') cnt--; \\n            if (cnt < 0) return false; \\n        } \\n        return (cnt == 0); \\n    } \\n\\n    vector<string> removeInvalidParentheses(string str) { \\n        if (str.empty()){ \\n            return {\"\"}; \\n        }\\n        \\n        set<string> visit; \\n        vector<string> res;\\n\\n        queue<string> q; \\n        string temp; \\n        bool level = false; \\n\\n        q.push(str); \\n        visit.insert(str); \\n        while (!q.empty()) { \\n            str = q.front();  q.pop();\\n            if (isValidString(str)) { \\n                res.push_back(str);\\n                level = true; \\n            } \\n            if (level) continue; \\n            for (int i = 0; i < str.length(); i++) { \\n                if (str[i]!=\\'(\\' && str[i]!=\\')\\') continue; \\n\\n                temp = str.substr(0, i) + str.substr(i + 1); \\n                if (visit.find(temp) == visit.end()) { \\n                    q.push(temp); \\n                    visit.insert(temp); \\n                } \\n            } \\n        }\\n        return res;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidString(string str) { \\n        int cnt = 0; \\n        for (int i = 0; i < str.length(); i++) { \\n            if (str[i] == \\'(\\') cnt++; \\n            else if (str[i] == \\')\\') cnt--; \\n            if (cnt < 0) return false; \\n        } \\n        return (cnt == 0); \\n    } \\n\\n    vector<string> removeInvalidParentheses(string str) { \\n        if (str.empty()){ \\n            return {\"\"}; \\n        }\\n        \\n        set<string> visit; \\n        vector<string> res;\\n\\n        queue<string> q; \\n        string temp; \\n        bool level = false; \\n\\n        q.push(str); \\n        visit.insert(str); \\n        while (!q.empty()) { \\n            str = q.front();  q.pop();\\n            if (isValidString(str)) { \\n                res.push_back(str);\\n                level = true; \\n            } \\n            if (level) continue; \\n            for (int i = 0; i < str.length(); i++) { \\n                if (str[i]!=\\'(\\' && str[i]!=\\')\\') continue; \\n\\n                temp = str.substr(0, i) + str.substr(i + 1); \\n                if (visit.find(temp) == visit.end()) { \\n                    q.push(temp); \\n                    visit.insert(temp); \\n                } \\n            } \\n        }\\n        return res;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558173,
                "title": "java-easy-to-read",
                "content": "```\\nclass Solution {\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n \\n        if(s == null) return Arrays.asList(\"\");\\n\\n        List<String> rList = new ArrayList<>();\\n        List<String> sCand = new LinkedList<>();\\n\\n        sCand.add(s);\\n\\n        Set<String> visited = new HashSet<>();\\n\\n        while (!sCand.isEmpty()) {\\n            for (String sC : sCand) {\\n                if(isValid(sC)) {\\n                    rList.add(sC);\\n                }\\n            }\\n\\n            if(rList.size() > 0) return rList;\\n            List<String> nextItr = new LinkedList<>();\\n            for (String cd : sCand) {\\n                for(int i = 0; i < cd.length(); i ++) {\\n                    char c = cd.charAt(i);\\n                    if(c != \\'(\\' && c != \\')\\') continue;\\n                    StringBuffer sb = new StringBuffer(cd);\\n                    String next = sb.deleteCharAt(i).toString();\\n                    if(visited.contains(next)) continue;\\n                    visited.add(next);\\n                    nextItr.add(next);\\n                }\\n                sCand = nextItr;\\n            }\\n        }\\n        \\n        return rList;\\n    }\\n\\n\\n    private boolean isValid(String sVal) {\\n        int count = 0;\\n\\n        for (char c : sVal.toCharArray()) {\\n            if(c == \\'(\\') count++;\\n            if(c == \\')\\' && count-- == 0) return false;\\n        }\\n\\n        return count == 0;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> removeInvalidParentheses(String s) {\\n \\n        if(s == null) return Arrays.asList(\"\");\\n\\n        List<String> rList = new ArrayList<>();\\n        List<String> sCand = new LinkedList<>();\\n\\n        sCand.add(s);\\n\\n        Set<String> visited = new HashSet<>();\\n\\n        while (!sCand.isEmpty()) {\\n            for (String sC : sCand) {\\n                if(isValid(sC)) {\\n                    rList.add(sC);\\n                }\\n            }\\n\\n            if(rList.size() > 0) return rList;\\n            List<String> nextItr = new LinkedList<>();\\n            for (String cd : sCand) {\\n                for(int i = 0; i < cd.length(); i ++) {\\n                    char c = cd.charAt(i);\\n                    if(c != \\'(\\' && c != \\')\\') continue;\\n                    StringBuffer sb = new StringBuffer(cd);\\n                    String next = sb.deleteCharAt(i).toString();\\n                    if(visited.contains(next)) continue;\\n                    visited.add(next);\\n                    nextItr.add(next);\\n                }\\n                sCand = nextItr;\\n            }\\n        }\\n        \\n        return rList;\\n    }\\n\\n\\n    private boolean isValid(String sVal) {\\n        int count = 0;\\n\\n        for (char c : sVal.toCharArray()) {\\n            if(c == \\'(\\') count++;\\n            if(c == \\')\\' && count-- == 0) return false;\\n        }\\n\\n        return count == 0;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483699,
                "title": "easy-understood-scala-solution",
                "content": "For every left parenthesis, we should have a corresponding right parenthesis. We can make use of two counters which keep track of misplaced left and right parenthesis and in one iteration we can find out these two values.\\n0 1 2 3 4 5 6 7\\n( ) ) ) ( ( ( )  \\ni = 0, left = 1, right = 0\\ni = 1, left = 0, right = 0\\ni = 2, left = 0, right = 1\\ni = 3, left = 0, right = 2\\ni = 4, left = 1, right = 2\\ni = 5, left = 2, right = 2\\ni = 6, left = 3, right = 2\\ni = 7, left = 2, right = 2\\nWe have 2 misplaced left and 2 misplaced right parentheses.\\n```\\ndef removeInvalidParentheses(s: String): List[String] = {\\n    var misLeft, misRight = 0\\n    s.foreach {\\n      case \\'(\\' =>\\n        misLeft += 1\\n      case \\')\\' =>\\n        if (misLeft > 0) misLeft -= 1 else misRight += 1\\n      case _ =>\\n    }\\n    var ans: List[String] = Nil\\n    val N = s.length\\n    \\n    def dfs(idx: Int, input: String, l0: Int, r0: Int, l: Int, r: Int): Unit = {\\n      if (idx >= N) {\\n        if (l0 == 0 && r0 == 0) ans ::= input\\n        return\\n      }\\n      s(idx) match {\\n        case c@\\'(\\' =>\\n          if (l > 0) dfs(idx + 1, input, l0, r0, l - 1, r)\\n          dfs(idx + 1, input + c, l0 + 1, r0, l, r)\\n        case c@\\')\\' =>\\n          if (r > 0) dfs(idx + 1, input, l0, r0, l, r - 1)\\n          val newLeft = if (l0 > 0) l0 - 1 else l0\\n          val newRight = if (l0 > 0) r0 else r0 + 1\\n          dfs(idx + 1, input + c, newLeft, newRight, l, r)\\n        case c@_ =>\\n          dfs(idx + 1, input + c, l0, r0, l, r)\\n      }\\n    }\\n    \\n    dfs(0, \"\", 0, 0, misLeft, misRight)\\n    ans.distinct\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeInvalidParentheses(s: String): List[String] = {\\n    var misLeft, misRight = 0\\n    s.foreach {\\n      case \\'(\\' =>\\n        misLeft += 1\\n      case \\')\\' =>\\n        if (misLeft > 0) misLeft -= 1 else misRight += 1\\n      case _ =>\\n    }\\n    var ans: List[String] = Nil\\n    val N = s.length\\n    \\n    def dfs(idx: Int, input: String, l0: Int, r0: Int, l: Int, r: Int): Unit = {\\n      if (idx >= N) {\\n        if (l0 == 0 && r0 == 0) ans ::= input\\n        return\\n      }\\n      s(idx) match {\\n        case c@\\'(\\' =>\\n          if (l > 0) dfs(idx + 1, input, l0, r0, l - 1, r)\\n          dfs(idx + 1, input + c, l0 + 1, r0, l, r)\\n        case c@\\')\\' =>\\n          if (r > 0) dfs(idx + 1, input, l0, r0, l, r - 1)\\n          val newLeft = if (l0 > 0) l0 - 1 else l0\\n          val newRight = if (l0 > 0) r0 else r0 + 1\\n          dfs(idx + 1, input + c, newLeft, newRight, l, r)\\n        case c@_ =>\\n          dfs(idx + 1, input + c, l0, r0, l, r)\\n      }\\n    }\\n    \\n    dfs(0, \"\", 0, 0, misLeft, misRight)\\n    ans.distinct\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 418188,
                "title": "c-dfs-solution-w-comments",
                "content": "```\\nclass Solution {\\n    int maxLen = 0;\\n    unordered_set<string> res;\\n    void helper(int idx, string& curr, int open, int close, const string& s){\\n        \\n        if (idx == s.size()){\\n            //If the number of open and close parens are not equal, there\\'s no valid solution\\n            if (open != close) return;\\n            \\n            //See if the curr string is a longer solution than what we\\'ve seen before,\\n            //if so, then clear all the previous solutions\\n            if (curr.size() > maxLen){\\n                maxLen = curr.size();\\n                res.clear();\\n            }\\n            //Insert the curr solution if it\\'s as long as what we\\'ve seen so far.\\n            if (curr.size() == maxLen){\\n                res.insert(curr);    \\n            }\\n            \\n            return;\\n        }\\n        \\n        int currChar = s[idx];\\n        \\n        //If the current character is not a parens, just insert and recurse\\n        if (currChar != \\'(\\' && currChar != \\')\\'){\\n            curr.push_back(currChar);\\n            helper(idx+1, curr, open, close, s);\\n            curr.pop_back();\\n        } else {\\n            if (currChar == \\')\\'){\\n                //If current solution already contains the same number of open and close parens, \\n                //adding a closing paren will cause the solution to be invalid, because it will be impossible\\n                //to match it in the future. \\n                //e.g. )( \\n                //So just skip the current char\\n                if (close >= open) {\\n                    helper(idx+1, curr, open, close, s);\\n                } else {\\n                    //If we can append the close parens, try adding it to the current solution\\n                    curr.push_back(currChar);\\n                    helper(idx+1, curr, open, close+1, s);\\n                    curr.pop_back();\\n                    //Also try without adding the closing parens.\\n                    helper(idx+1, curr, open, close, s);\\n                }\\n            } else {\\n                //Always try adding an open parens because it can be potentially be matched in the future.\\n                //So try adding it to the current solution\\n                curr.push_back(currChar);\\n                helper(idx+1, curr, open+1, close, s);\\n                curr.pop_back();\\n                //Also try without adding the open parens.\\n                helper(idx+1, curr, open, close, s);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        string curr = \"\";\\n        int open = 0;\\n        int close = 0;\\n        \\n        int idx = 0;\\n        vector<string> results;\\n        helper(idx, curr, open, close, s);\\n        \\n        for (string r : res) results.push_back(r);\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxLen = 0;\\n    unordered_set<string> res;\\n    void helper(int idx, string& curr, int open, int close, const string& s){\\n        \\n        if (idx == s.size()){\\n            //If the number of open and close parens are not equal, there\\'s no valid solution\\n            if (open != close) return;\\n            \\n            //See if the curr string is a longer solution than what we\\'ve seen before,\\n            //if so, then clear all the previous solutions\\n            if (curr.size() > maxLen){\\n                maxLen = curr.size();\\n                res.clear();\\n            }\\n            //Insert the curr solution if it\\'s as long as what we\\'ve seen so far.\\n            if (curr.size() == maxLen){\\n                res.insert(curr);    \\n            }\\n            \\n            return;\\n        }\\n        \\n        int currChar = s[idx];\\n        \\n        //If the current character is not a parens, just insert and recurse\\n        if (currChar != \\'(\\' && currChar != \\')\\'){\\n            curr.push_back(currChar);\\n            helper(idx+1, curr, open, close, s);\\n            curr.pop_back();\\n        } else {\\n            if (currChar == \\')\\'){\\n                //If current solution already contains the same number of open and close parens, \\n                //adding a closing paren will cause the solution to be invalid, because it will be impossible\\n                //to match it in the future. \\n                //e.g. )( \\n                //So just skip the current char\\n                if (close >= open) {\\n                    helper(idx+1, curr, open, close, s);\\n                } else {\\n                    //If we can append the close parens, try adding it to the current solution\\n                    curr.push_back(currChar);\\n                    helper(idx+1, curr, open, close+1, s);\\n                    curr.pop_back();\\n                    //Also try without adding the closing parens.\\n                    helper(idx+1, curr, open, close, s);\\n                }\\n            } else {\\n                //Always try adding an open parens because it can be potentially be matched in the future.\\n                //So try adding it to the current solution\\n                curr.push_back(currChar);\\n                helper(idx+1, curr, open+1, close, s);\\n                curr.pop_back();\\n                //Also try without adding the open parens.\\n                helper(idx+1, curr, open, close, s);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        string curr = \"\";\\n        int open = 0;\\n        int close = 0;\\n        \\n        int idx = 0;\\n        vector<string> results;\\n        helper(idx, curr, open, close, s);\\n        \\n        for (string r : res) results.push_back(r);\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404522,
                "title": "c-easy-to-understand-no-duplicated",
                "content": "# Intuition\\nCalculate number of open and close brackets you have to remove to make it valid.\\nTry every possible combination.\\n\\n# Explanation\\nTo calculate the number of open and close brackets that can be removed:\\nE.g. `())`\\nAt index 0, openLeft = 1.\\nAt index 1, since openLeft is > 0, openLeft should decrement as it can be closed. (openLeft = 0)\\nAt index 2, since openLeft is == 0, it is an invalid close bracket. (openLeft = 0, closeLeft = 1)\\n\\nE.g. `(()`\\nAt index 0, openLeft = 1.\\nAt index 1, openLeft = 2.\\nAt index 2, decrement openLeft by 1, since 1 of the open bracket can be closed. (openLeft = 1, closeLeft = 0)\\n\\nHow duplication is handled:\\nE.g. `(()`\\nIn this case, the algorithm will only try to remove the first `(` that it sees.\\nThis is done by checking that the last character added is not `(`.\\nIf `(` is added previously, it can\\'t skip `(` on the next iteration.\\n# Complexity\\nTime: `O(2^N)` where N is the length of the string\\nSpace: `O(N*2^N)`\\n\\n# C++\\n```C++\\nvector<string> removeInvalidParentheses(string s) {\\n\\t// check for number of open and close brackets that you have to remove\\n\\tint openLeft = 0;\\n\\tint closeLeft = 0;\\n\\tfor (char &c : s) {\\n\\t\\tif (c == \\'(\\') {\\n\\t\\t\\topenLeft++;\\n\\t\\t} else if (c == \\')\\') {\\n\\t\\t\\tif (openLeft > 0) {\\n\\t\\t\\t\\topenLeft--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloseLeft++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> res;\\n\\tstring cur;\\n\\tremoveInvalid(s, 0, openLeft, closeLeft, 0, cur, res);\\n\\treturn res;\\n}\\n\\nvoid removeInvalid(string &s, int index, int openLeft, int closeLeft, int open,\\n\\t\\t\\t\\t   string &cur, vector<string> &res) {\\n\\tif (openLeft < 0 || closeLeft < 0 || open < 0) {\\n\\t\\treturn;\\n\\t}\\n\\tif (index == s.length()) {\\n\\t\\tif (openLeft == 0 && closeLeft == 0 && open == 0) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tchar c = s[index];\\n\\tif (c == \\'(\\') {\\n\\t\\t// skip\\n\\t\\tif (cur.length() == 0 || cur[cur.length() - 1] != \\'(\\') {\\n\\t\\t\\tremoveInvalid(s, index+1, openLeft-1, closeLeft, open, cur, res);\\n\\t\\t}\\n\\t\\t// use\\n\\t\\tcur += \\'(\\';\\n\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft, open+1, cur, res);\\n\\t} else if (c == \\')\\') {\\n\\t\\tif (cur.length() == 0 || cur[cur.length() - 1] != \\')\\') {\\n\\t\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft-1, open, cur, res);\\n\\t\\t}\\n\\t\\tcur += \\')\\';\\n\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft, open-1, cur, res);\\n\\t} else {\\n\\t\\tcur += c;\\n\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft, open, cur, res);\\n\\t}\\n\\t// backtrack, remove previous character\\n\\tcur.pop_back();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<string> removeInvalidParentheses(string s) {\\n\\t// check for number of open and close brackets that you have to remove\\n\\tint openLeft = 0;\\n\\tint closeLeft = 0;\\n\\tfor (char &c : s) {\\n\\t\\tif (c == \\'(\\') {\\n\\t\\t\\topenLeft++;\\n\\t\\t} else if (c == \\')\\') {\\n\\t\\t\\tif (openLeft > 0) {\\n\\t\\t\\t\\topenLeft--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloseLeft++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> res;\\n\\tstring cur;\\n\\tremoveInvalid(s, 0, openLeft, closeLeft, 0, cur, res);\\n\\treturn res;\\n}\\n\\nvoid removeInvalid(string &s, int index, int openLeft, int closeLeft, int open,\\n\\t\\t\\t\\t   string &cur, vector<string> &res) {\\n\\tif (openLeft < 0 || closeLeft < 0 || open < 0) {\\n\\t\\treturn;\\n\\t}\\n\\tif (index == s.length()) {\\n\\t\\tif (openLeft == 0 && closeLeft == 0 && open == 0) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tchar c = s[index];\\n\\tif (c == \\'(\\') {\\n\\t\\t// skip\\n\\t\\tif (cur.length() == 0 || cur[cur.length() - 1] != \\'(\\') {\\n\\t\\t\\tremoveInvalid(s, index+1, openLeft-1, closeLeft, open, cur, res);\\n\\t\\t}\\n\\t\\t// use\\n\\t\\tcur += \\'(\\';\\n\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft, open+1, cur, res);\\n\\t} else if (c == \\')\\') {\\n\\t\\tif (cur.length() == 0 || cur[cur.length() - 1] != \\')\\') {\\n\\t\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft-1, open, cur, res);\\n\\t\\t}\\n\\t\\tcur += \\')\\';\\n\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft, open-1, cur, res);\\n\\t} else {\\n\\t\\tcur += c;\\n\\t\\tremoveInvalid(s, index+1, openLeft, closeLeft, open, cur, res);\\n\\t}\\n\\t// backtrack, remove previous character\\n\\tcur.pop_back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397918,
                "title": "clean-es6-javascript-backtracking-that-is-easy-to-understand",
                "content": "This isn\\'t the fastest solution but is easy to understand.\\nAs iterated in most other solutions, here are some optimizations I made:\\n- we use a `Set` instead of an array to keep track of all possible expressions (`ways`) to avoid duplicates; easily converted back to an array using `...` ES6 rest-spread syntax\\n- Instead of using a stack/array to keep track of opened brackets, we can just use a number, e.g. `openedCount`. Instead of using `openedCount` and `closedCount`, we can just use one number: `bracketBalance`, aka. `bal`\\n- each character traversed in the string presents us **TWO** choices: we don\\'t include it in the final string, or we do. NOT including a character == removing it.\\n- at any point, if our accumulated string expression has more closed brackets than opened, e.g. `)(`, we are done with that branch of search, it is hopeless... no matter how many open brackets you find after, `)(` is a lost cause. But, if `str` was something like `((((`, there\\'s a chance we would still find some closing brackets to balance it out, so we don\\'t stop searching\\n- we deal with `endReached` cleanly, after all characters in string are traversed. We could do this when `start === s.length - 1` as well\\n\\n```\\nconst removeInvalidParentheses = function(s) {\\n    let ways = new Set([\\'\\']);\\n    let msf = 0; // max length so far\\n    let bal = 0; // bracket balance, positive = more opened, negative = more closed\\n    helper(0, bal, \\'\\')\\n    return [...ways]; // convert Set to array\\n    \\n    function helper(start, balance, str) {\\n        if(balance < 0) return; // if str e.g. `)((`, it can\\'t turn back!\\n\\t\\t\\n        const endReached = start === s.length;\\n        if(endReached) {\\n            if(str.length < msf || balance !== 0) return; // more exit-early is better\\n            if(str.length > msf) ways = new Set(); // discard previous results, new str is the least removed.\\n            ways.add(str);\\n            msf = str.length;\\n            return; // we are done with this search branch\\n        }\\n        \\n        const char = s.charAt(start);\\n        if(\\'()\\'.indexOf(char) === -1) return helper(start+1, balance, str+char);\\n        \\n        helper(start+1, balance, str); // choice 1 - remove current character and leave it out of final string expression\\n        helper(start+1, balance + (char === \\'(\\' ? 1 : -1), str+char); // choice 2 - include it, but it will affect the bracket balance\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst removeInvalidParentheses = function(s) {\\n    let ways = new Set([\\'\\']);\\n    let msf = 0; // max length so far\\n    let bal = 0; // bracket balance, positive = more opened, negative = more closed\\n    helper(0, bal, \\'\\')\\n    return [...ways]; // convert Set to array\\n    \\n    function helper(start, balance, str) {\\n        if(balance < 0) return; // if str e.g. `)((`, it can\\'t turn back!\\n\\t\\t\\n        const endReached = start === s.length;\\n        if(endReached) {\\n            if(str.length < msf || balance !== 0) return; // more exit-early is better\\n            if(str.length > msf) ways = new Set(); // discard previous results, new str is the least removed.\\n            ways.add(str);\\n            msf = str.length;\\n            return; // we are done with this search branch\\n        }\\n        \\n        const char = s.charAt(start);\\n        if(\\'()\\'.indexOf(char) === -1) return helper(start+1, balance, str+char);\\n        \\n        helper(start+1, balance, str); // choice 1 - remove current character and leave it out of final string expression\\n        helper(start+1, balance + (char === \\'(\\' ? 1 : -1), str+char); // choice 2 - include it, but it will affect the bracket balance\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391773,
                "title": "easy-peasy-python-bfs-level-order-solution",
                "content": "\\t#If a valid answer is found, which means count of ( equals count of ), all nodes of next layer will be invalid, as the count of ( and ) will be imbalanced. So this is not a problem.\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        if not s:\\n            return [\"\"]\\n        \\n        q = [(s, 0)]\\n        visited = set()\\n        visited.add(s)\\n        found = False\\n        res = []\\n        \\n        while q:\\n            # see each level at a time\\n            # if found is true, that means, this is the max numbers that could have\\n            # been removed.\\n            for i in range(len(q)):\\n                top, idx = q.pop(0)\\n\\n                if (self.isValid(top)):\\n                    found = True\\n                    res.append(top)\\n\\n                if found:\\n                    continue\\n\\n                for j in range(idx, len(top)):\\n                    # there can be other chars too\\n                    if top[j] != \"(\" and top[j] != \\')\\':\\n                        continue\\n\\n                    newStr = top[:j] + top[j+1:]\\n\\n                    if newStr not in visited:\\n                        visited.add(newStr)\\n                        # I removed i, so new string will still start from the\\n                        # ith index\\n                        q.append((newStr, j))\\n            if found:\\n                break\\n        \\n        return res\\n    \\n    def isValid(self, s):\\n        count = 0\\n        for ch in s:\\n            if ch == \"(\":\\n                count += 1\\n            elif ch == \")\":\\n                count -= 1\\n                if count < 0:\\n                    return False\\n        \\n        return count == 0",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\t#If a valid answer is found, which means count of ( equals count of ), all nodes of next layer will be invalid, as the count of ( and ) will be imbalanced. So this is not a problem.\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        if not s:\\n            return [\"\"]\\n        \\n        q = [(s, 0)]\\n        visited = set()\\n        visited.add(s)\\n        found = False\\n        res = []\\n        \\n        while q:\\n            # see each level at a time\\n            # if found is true, that means, this is the max numbers that could have\\n            # been removed.\\n            for i in range(len(q)):\\n                top, idx = q.pop(0)\\n\\n                if (self.isValid(top)):\\n                    found = True\\n                    res.append(top)\\n\\n                if found:\\n                    continue\\n\\n                for j in range(idx, len(top)):\\n                    # there can be other chars too\\n                    if top[j] != \"(\" and top[j] != \\')\\':\\n                        continue\\n\\n                    newStr = top[:j] + top[j+1:]\\n\\n                    if newStr not in visited:\\n                        visited.add(newStr)\\n                        # I removed i, so new string will still start from the\\n                        # ith index\\n                        q.append((newStr, j))\\n            if found:\\n                break\\n        \\n        return res\\n    \\n    def isValid(self, s):\\n        count = 0\\n        for ch in s:\\n            if ch == \"(\":\\n                count += 1\\n            elif ch == \")\":\\n                count -= 1\\n                if count < 0:\\n                    return False\\n        \\n        return count == 0",
                "codeTag": "Python3"
            },
            {
                "id": 387228,
                "title": "java-set",
                "content": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        int left = 0;\\n        int right = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                left++;\\n            } else if (c == \\')\\') {\\n                if (left > 0) {\\n                    left--;\\n                } else {\\n                    right++;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(0, left, right, s, res, \"\");\\n        return new ArrayList<>(res);\\n    }\\n    void dfs(int start, int left, int right, String s, Set<String> res, String p) {\\n        if (start == s.length()) {\\n            if (left == 0 && right == 0) {\\n                if (isValid(p)) {\\n                    res.add(p);\\n                }\\n            }\\n            return;\\n        }\\n        if (s.charAt(start) == \\'(\\' && left > 0) {\\n            dfs(start + 1, left - 1, right, s, res, p);\\n        } else if (s.charAt(start) == \\')\\' && right > 0) {\\n            dfs(start + 1, left, right - 1, s, res, p);\\n        }\\n        dfs(start + 1, left, right, s, res, p + s.charAt(start));\\n    }\\n    boolean isValid(String s) {\\n        int left = 0;\\n        int right = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                left++;\\n            } else if (c == \\')\\') {\\n                if (left > 0) {\\n                    left--;\\n                } else {\\n                    right++;\\n                }\\n            }\\n        }\\n        return left == 0 && right == 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        int left = 0;\\n        int right = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                left++;\\n            } else if (c == \\')\\') {\\n                if (left > 0) {\\n                    left--;\\n                } else {\\n                    right++;\\n                }\\n            }\\n        }\\n        Set<String> res = new HashSet<>();\\n        dfs(0, left, right, s, res, \"\");\\n        return new ArrayList<>(res);\\n    }\\n    void dfs(int start, int left, int right, String s, Set<String> res, String p) {\\n        if (start == s.length()) {\\n            if (left == 0 && right == 0) {\\n                if (isValid(p)) {\\n                    res.add(p);\\n                }\\n            }\\n            return;\\n        }\\n        if (s.charAt(start) == \\'(\\' && left > 0) {\\n            dfs(start + 1, left - 1, right, s, res, p);\\n        } else if (s.charAt(start) == \\')\\' && right > 0) {\\n            dfs(start + 1, left, right - 1, s, res, p);\\n        }\\n        dfs(start + 1, left, right, s, res, p + s.charAt(start));\\n    }\\n    boolean isValid(String s) {\\n        int left = 0;\\n        int right = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                left++;\\n            } else if (c == \\')\\') {\\n                if (left > 0) {\\n                    left--;\\n                } else {\\n                    right++;\\n                }\\n            }\\n        }\\n        return left == 0 && right == 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369810,
                "title": "stack-and-dfs-solution",
                "content": "```java\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        // traverse the string to find the misplace parentheses\\n        char[] chs = s.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int misplaceLeft = 0;\\n        int misplaceRight = 0;\\n        \\n        for (int i = 0; i < chs.length; i++) {\\n            char cur = chs[i];\\n            if (cur == \\'(\\') {\\n                stack.push(cur);\\n            }\\n            if (cur == \\')\\') {\\n                if (stack.size() > 0) {\\n                    stack.pop();\\n                } else {\\n                    misplaceRight++;\\n                }\\n            }\\n        }\\n        misplaceLeft = stack.size();\\n        \\n        // result and visited array function\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs(result, sb, s, 0, 0, misplaceLeft, misplaceRight , 0);\\n        return result;\\n    }\\n    \\n    private void dfs(List<String> result, StringBuilder sb, String s, \\n                     int left, int right, int misplaceLeft, int misplaceRight, int index) {\\n        if (left < right) return;\\n        if (index == s.length()){\\n            if (misplaceLeft == 0 && misplaceRight == 0) {\\n                String curResult = sb.toString();\\n                if (!result.contains(curResult)) result.add(curResult);\\n            }\\n            return;\\n        }\\n        \\n        char cur = s.charAt(index);\\n        // if it is not a Parentheses\\n        if (cur != \\'(\\' && cur != \\')\\') {\\n            sb.append(cur);\\n            dfs(result, sb, s, left, right, misplaceLeft, misplaceRight, index+1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        // if it is a left Parentheses\\n        if (cur == \\'(\\') {\\n            // ignore the left Parentheses\\n            if (misplaceLeft > 0) {\\n                dfs(result, sb, s, left, right, misplaceLeft-1, misplaceRight, index+1);\\n            }\\n            // count this left Parentheses\\n            sb.append(\\'(\\');\\n            dfs(result, sb, s, left+1, right, misplaceLeft, misplaceRight, index+1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        // if it is a right Parentheses\\n        if (cur == \\')\\') {\\n            // ignore the right Parentheses\\n            if (misplaceRight > 0) {\\n                dfs(result, sb, s, left, right, misplaceLeft, misplaceRight-1, index+1);\\n            }\\n            // count this right Parentheses\\n            sb.append(\\')\\');\\n            dfs(result, sb, s, left, right+1, misplaceLeft, misplaceRight, index+1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n        // traverse the string to find the misplace parentheses\\n        char[] chs = s.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int misplaceLeft = 0;\\n        int misplaceRight = 0;\\n        \\n        for (int i = 0; i < chs.length; i++) {\\n            char cur = chs[i];\\n            if (cur == \\'(\\') {\\n                stack.push(cur);\\n            }\\n            if (cur == \\')\\') {\\n                if (stack.size() > 0) {\\n                    stack.pop();\\n                } else {\\n                    misplaceRight++;\\n                }\\n            }\\n        }\\n        misplaceLeft = stack.size();\\n        \\n        // result and visited array function\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs(result, sb, s, 0, 0, misplaceLeft, misplaceRight , 0);\\n        return result;\\n    }\\n    \\n    private void dfs(List<String> result, StringBuilder sb, String s, \\n                     int left, int right, int misplaceLeft, int misplaceRight, int index) {\\n        if (left < right) return;\\n        if (index == s.length()){\\n            if (misplaceLeft == 0 && misplaceRight == 0) {\\n                String curResult = sb.toString();\\n                if (!result.contains(curResult)) result.add(curResult);\\n            }\\n            return;\\n        }\\n        \\n        char cur = s.charAt(index);\\n        // if it is not a Parentheses\\n        if (cur != \\'(\\' && cur != \\')\\') {\\n            sb.append(cur);\\n            dfs(result, sb, s, left, right, misplaceLeft, misplaceRight, index+1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        // if it is a left Parentheses\\n        if (cur == \\'(\\') {\\n            // ignore the left Parentheses\\n            if (misplaceLeft > 0) {\\n                dfs(result, sb, s, left, right, misplaceLeft-1, misplaceRight, index+1);\\n            }\\n            // count this left Parentheses\\n            sb.append(\\'(\\');\\n            dfs(result, sb, s, left+1, right, misplaceLeft, misplaceRight, index+1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        // if it is a right Parentheses\\n        if (cur == \\')\\') {\\n            // ignore the right Parentheses\\n            if (misplaceRight > 0) {\\n                dfs(result, sb, s, left, right, misplaceLeft, misplaceRight-1, index+1);\\n            }\\n            // count this right Parentheses\\n            sb.append(\\')\\');\\n            dfs(result, sb, s, left, right+1, misplaceLeft, misplaceRight, index+1);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365059,
                "title": "java-bfs",
                "content": "```\\nclass Solution \\n{\\n    public List<String> removeInvalidParentheses(String s) \\n    {\\n        Queue<String> q = new LinkedList();\\n        Set<String> visited = new HashSet();\\n        q.add(s);\\n        \\n        List<String> result = new ArrayList();\\n        boolean found = false;\\n        while (!q.isEmpty())\\n        {\\n            String curr = q.poll();\\n            if (is_valid(curr))\\n            {\\n                result.add(curr);\\n                found = true;\\n            }\\n            \\n            if (!found)\\n            {\\n                next(q, visited, curr);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void next(Queue<String> q, Set<String> visited, String s)\\n    {\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\')\\n            {\\n                String n = s.substring(0, i) + s.substring(i + 1);\\n                if (!visited.contains(n))\\n                {\\n                    q.add(n);\\n                    visited.add(n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    boolean is_valid(String s)\\n    {\\n        int count = 0;\\n        for (char c : s.toCharArray())\\n        {\\n            if (c == \\'(\\')\\n            {\\n                ++count;\\n            }\\n            else if (c == \\')\\')\\n            {\\n                --count;\\n                if (count == -1) return false;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public List<String> removeInvalidParentheses(String s) \\n    {\\n        Queue<String> q = new LinkedList();\\n        Set<String> visited = new HashSet();\\n        q.add(s);\\n        \\n        List<String> result = new ArrayList();\\n        boolean found = false;\\n        while (!q.isEmpty())\\n        {\\n            String curr = q.poll();\\n            if (is_valid(curr))\\n            {\\n                result.add(curr);\\n                found = true;\\n            }\\n            \\n            if (!found)\\n            {\\n                next(q, visited, curr);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void next(Queue<String> q, Set<String> visited, String s)\\n    {\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\')\\n            {\\n                String n = s.substring(0, i) + s.substring(i + 1);\\n                if (!visited.contains(n))\\n                {\\n                    q.add(n);\\n                    visited.add(n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    boolean is_valid(String s)\\n    {\\n        int count = 0;\\n        for (char c : s.toCharArray())\\n        {\\n            if (c == \\'(\\')\\n            {\\n                ++count;\\n            }\\n            else if (c == \\')\\')\\n            {\\n                --count;\\n                if (count == -1) return false;\\n            }\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230029,
                "title": "python-solution",
                "content": "Time complexity: `O(2^n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def backtrack(i, left, right, leftr, rightr):\\n            if i == len(s):\\n                if leftr == 0 and rightr == 0:\\n                    res.add(\"\".join(expr))\\n                return\\n            if right > left:\\n                return\\n            if not (s[i] == \"(\" or s[i] == \")\"):\\n                expr.append(s[i])\\n                backtrack(i+1, left, right, leftr, rightr)\\n            else:\\n                if s[i] == \"(\":\\n                    if leftr > 0:\\n                        backtrack(i+1, left, right, leftr-1, rightr)\\n                    expr.append(\"(\")\\n                    backtrack(i+1, left+1, right, leftr, rightr)\\n                else:\\n                    if rightr > 0:\\n                        backtrack(i+1, left, right, leftr, rightr-1)\\n                    expr.append(\")\")\\n                    backtrack(i+1, left, right+1, leftr, rightr)\\n            expr.pop()\\n   \\n        res = set()\\n        expr = []\\n        leftr = 0\\n        rightr = 0\\n        for i, c in enumerate(s):\\n            if c == \"(\":\\n                leftr += 1\\n            elif c == \")\":\\n                if leftr > 0:\\n                    leftr -= 1\\n                else:\\n                    rightr += 1\\n        backtrack(0, 0, 0, leftr, rightr)\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def backtrack(i, left, right, leftr, rightr):\\n            if i == len(s):\\n                if leftr == 0 and rightr == 0:\\n                    res.add(\"\".join(expr))\\n                return\\n            if right > left:\\n                return\\n            if not (s[i] == \"(\" or s[i] == \")\"):\\n                expr.append(s[i])\\n                backtrack(i+1, left, right, leftr, rightr)\\n            else:\\n                if s[i] == \"(\":\\n                    if leftr > 0:\\n                        backtrack(i+1, left, right, leftr-1, rightr)\\n                    expr.append(\"(\")\\n                    backtrack(i+1, left+1, right, leftr, rightr)\\n                else:\\n                    if rightr > 0:\\n                        backtrack(i+1, left, right, leftr, rightr-1)\\n                    expr.append(\")\")\\n                    backtrack(i+1, left, right+1, leftr, rightr)\\n            expr.pop()\\n   \\n        res = set()\\n        expr = []\\n        leftr = 0\\n        rightr = 0\\n        for i, c in enumerate(s):\\n            if c == \"(\":\\n                leftr += 1\\n            elif c == \")\":\\n                if leftr > 0:\\n                    leftr -= 1\\n                else:\\n                    rightr += 1\\n        backtrack(0, 0, 0, leftr, rightr)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206862,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    public static class BFSObject {\\n        \\n        public int level;\\n        public String str;\\n        public BFSObject(String str, int level) {\\n            this.str = str;\\n            this.level = level;\\n        }\\n    }\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        \\n        List<String> result = new ArrayList<>();\\n        if(s == null || s.length() == 0) {\\n            result.add(\"\");\\n            return result;\\n        }\\n        Queue<BFSObject> queue = new LinkedList<>();\\n        queue.add(new BFSObject(s, 0));\\n        int ansLevel = Integer.MAX_VALUE;\\n        Set<String> set = new HashSet<>();\\n        while(!queue.isEmpty()) {\\n            \\n            BFSObject bfsObject = queue.poll();\\n            String str = bfsObject.str;\\n            int level = bfsObject.level;\\n            //boolean isValid = isValid(str);\\n             if(ansLevel < level)  {\\n                    break;\\n            }\\n            if(level>s.length()) break;\\n            \\n            if(isValid(str)) {\\n                if (ansLevel >= level) {\\n\\t\\t\\t\\t\\tansLevel = level;\\n\\n\\t\\t\\t\\t\\tresult.add(str);\\n\\t\\t\\t\\t} else if(ansLevel < level)  {\\n                    break;\\n                }\\n                \\n            } else {\\n                for(int i=0;i<str.length();i++) {\\n                    if(str.charAt(i) == \\'(\\' || str.charAt(i) == \\')\\') {\\n                       \\n                       String queueString = str.substring(0,i) + str.substring(i+1, str.length());\\n\\t\\t\\t\\t\\t\\tif(set.contains(queueString)) {\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tset.add(queueString);\\n\\t\\t\\t\\t\\t\\tqueue.add(new BFSObject(queueString, level + 1));\\n                    }\\n                    \\n                }\\n            }    \\n        }\\n        return result;\\n        \\n    }\\n    \\n    private boolean isValid(String str) {\\n        \\n        if(str == null || str.length() == 0)\\n            return true;\\n        char[] chars = str.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        \\n        int i =0;\\n        int n = chars.length;\\n        while(i<n) {\\n            if(chars[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n            } else if(chars[i] == \\')\\') {\\n                   \\n                if(st.isEmpty()) return false;\\n                if(st.peek() != \\'(\\') {\\n                    return false;\\n                }\\n                st.pop();    \\n            }\\n            i++;\\n        }\\n        if(!st.isEmpty()) return false;\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public static class BFSObject {\\n        \\n        public int level;\\n        public String str;\\n        public BFSObject(String str, int level) {\\n            this.str = str;\\n            this.level = level;\\n        }\\n    }\\n    \\n    public List<String> removeInvalidParentheses(String s) {\\n        \\n        List<String> result = new ArrayList<>();\\n        if(s == null || s.length() == 0) {\\n            result.add(\"\");\\n            return result;\\n        }\\n        Queue<BFSObject> queue = new LinkedList<>();\\n        queue.add(new BFSObject(s, 0));\\n        int ansLevel = Integer.MAX_VALUE;\\n        Set<String> set = new HashSet<>();\\n        while(!queue.isEmpty()) {\\n            \\n            BFSObject bfsObject = queue.poll();\\n            String str = bfsObject.str;\\n            int level = bfsObject.level;\\n            //boolean isValid = isValid(str);\\n             if(ansLevel < level)  {\\n                    break;\\n            }\\n            if(level>s.length()) break;\\n            \\n            if(isValid(str)) {\\n                if (ansLevel >= level) {\\n\\t\\t\\t\\t\\tansLevel = level;\\n\\n\\t\\t\\t\\t\\tresult.add(str);\\n\\t\\t\\t\\t} else if(ansLevel < level)  {\\n                    break;\\n                }\\n                \\n            } else {\\n                for(int i=0;i<str.length();i++) {\\n                    if(str.charAt(i) == \\'(\\' || str.charAt(i) == \\')\\') {\\n                       \\n                       String queueString = str.substring(0,i) + str.substring(i+1, str.length());\\n\\t\\t\\t\\t\\t\\tif(set.contains(queueString)) {\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tset.add(queueString);\\n\\t\\t\\t\\t\\t\\tqueue.add(new BFSObject(queueString, level + 1));\\n                    }\\n                    \\n                }\\n            }    \\n        }\\n        return result;\\n        \\n    }\\n    \\n    private boolean isValid(String str) {\\n        \\n        if(str == null || str.length() == 0)\\n            return true;\\n        char[] chars = str.toCharArray();\\n        Stack<Character> st = new Stack<>();\\n        \\n        int i =0;\\n        int n = chars.length;\\n        while(i<n) {\\n            if(chars[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n            } else if(chars[i] == \\')\\') {\\n                   \\n                if(st.isEmpty()) return false;\\n                if(st.peek() != \\'(\\') {\\n                    return false;\\n                }\\n                st.pop();    \\n            }\\n            i++;\\n        }\\n        if(!st.isEmpty()) return false;\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200953,
                "title": "javascript-ugly-as-sin-but-runs-at-60ms-and-beats-96-49-of-other-solutions",
                "content": "Very similar to C++ solutions, but as sets are sort of a \\'generic\\' type in JS, we have to check to make sure we don\\'t have replicas/repeats. \\n\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\n\\n\\n\\nvar removeInvalidParentheses = function(s) {\\n     let left = 0,\\n         right = 0,\\n         pair = 0;\\n    \\n    let res = [];\\n    \\n    for(var i = 0; i < s.length; i++) { \\n        if(s[i] === \\'(\\') left++;\\n        else if(s[i] === \\')\\') {\\n            if(left > 0) left--;\\n            else right++;\\n        }\\n    }\\n        \\n    var dfs = function(pair, index, left, right, s, solution, res) { \\n        if(s.length === index) { \\n            if(left === 0 && right === 0 && pair === 0) { \\n            for(var i = 0; i < res.length; i++) { \\n                if(res[i] === solution) return;\\n            }\\n            res.push(solution);\\n            }\\n            return;\\n        }\\n        \\n        if(s[index] === \\'(\\') { \\n            if(left > 0) { \\n                dfs(pair, index + 1, left - 1, right, s, solution, res);\\n            }\\n            dfs(pair + 1, index + 1, left, right, s, solution+s[index], res);\\n        } else if(s[index] === \\')\\') { \\n            if(right > 0) dfs(pair, index + 1, left, right - 1, s, solution, res);\\n            if(pair > 0) dfs(pair - 1, index + 1, left, right, s, solution+s[index], res);\\n        } else { \\n            dfs(pair, index + 1, left, right, s, solution+s[index], res);\\n        }\\n\\n    };\\n    dfs(0, 0, left, right, s, \"\", res);\\n    \\n    return res;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\n\\n\\n\\nvar removeInvalidParentheses = function(s) {\\n     let left = 0,\\n         right = 0,\\n         pair = 0;\\n    \\n    let res = [];\\n    \\n    for(var i = 0; i < s.length; i++) { \\n        if(s[i] === \\'(\\') left++;\\n        else if(s[i] === \\')\\') {\\n            if(left > 0) left--;\\n            else right++;\\n        }\\n    }\\n        \\n    var dfs = function(pair, index, left, right, s, solution, res) { \\n        if(s.length === index) { \\n            if(left === 0 && right === 0 && pair === 0) { \\n            for(var i = 0; i < res.length; i++) { \\n                if(res[i] === solution) return;\\n            }\\n            res.push(solution);\\n            }\\n            return;\\n        }\\n        \\n        if(s[index] === \\'(\\') { \\n            if(left > 0) { \\n                dfs(pair, index + 1, left - 1, right, s, solution, res);\\n            }\\n            dfs(pair + 1, index + 1, left, right, s, solution+s[index], res);\\n        } else if(s[index] === \\')\\') { \\n            if(right > 0) dfs(pair, index + 1, left, right - 1, s, solution, res);\\n            if(pair > 0) dfs(pair - 1, index + 1, left, right, s, solution+s[index], res);\\n        } else { \\n            dfs(pair, index + 1, left, right, s, solution+s[index], res);\\n        }\\n\\n    };\\n    dfs(0, 0, left, right, s, \"\", res);\\n    \\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186597,
                "title": "very-easy-to-understand-python-dfs",
                "content": "I\\'m following this post:\\nhttps://leetcode.com/problems/remove-invalid-parentheses/discuss/75027/Easy-Short-Concise-and-Fast-Java-DFS-3-ms-solution\\n\\nJust try to implement it in a easier to understand way\\n```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        res = []\\n        self.left_to_right(s, res, 0, 0)\\n        return res\\n\\n\\n    def left_to_right(self, s, res, i_start, j_search_start):\\n        \"\"\"\\n        scan from left to right, remove surplus \\')\\'\\n        \"\"\"\\n        # DFS\\n        count = 0\\n        for i in range(i_start, len(s)):\\n            if s[i] == \\'(\\':  # \\'(\\n                count += 1\\n            if s[i] == \\')\\':  # \\')\\n                count -= 1\\n            # Do nothing if it\\'s neither \\')\\' or \\'(\\'\\n\\n            if count < 0:\\n                # search for \\')\\'\\n                for j in range(j_search_start, i + 1):  # j_search_start~i\\n                    if s[j] == \\')\\' \\\\\\n                            and ((j == j_search_start) or s[j - 1] != s[j]):  # remove the first \\')\\' among consecutive ones\\n                        print(\\'i: %d, j: %d\\'%(i,j))\\n                        # remove s[j] and continue searching\\n                        char_removed = s[:j] + s[j+1:]\\n                        self.left_to_right(char_removed, res, i,j)\\n                return  # only search in the char_removed substring\\n\\n        # if finished removing suplus \\')\\' by scanning left to right,\\n        # scan for \\'(\\' right to left\\n        self.right_to_left(s, res, len(s)-1, len(s)-1)\\n\\n\\n    def right_to_left(self, s, res, i_start, j_search_start):\\n        \"\"\"\\n        scan from right to left, remove surplus \\'(\\'\\n        append result to res\\n        \"\"\"\\n        # DFS\\n        count = 0\\n        for i in range(i_start, -1, -1):  # i_start~0\\n            if s[i] == \\')\\':  # \\'(\\n                count += 1\\n            if s[i] == \\'(\\':  # \\')\\n                count -= 1\\n            # Do nothing if it\\'s neither \\')\\' or \\'(\\'\\n\\n            if count < 0:\\n                # search for \\')\\'\\n                for j in range(j_search_start, i-1, -1):  # j_search_start~i (right to left)\\n                    if s[j] == \\'(\\' \\\\\\n                            and ((j == j_search_start) or s[j+1] != s[j]):\\n                        # remove the first \\')\\' among consecutive ones (when scanning from right to left)\\n                        # remove s[j] and continue searching\\n                        char_removed = s[:j] + s[j+1:]\\n                        self.right_to_left(char_removed, res, i-1,j-1)\\n                return\\n\\n        # base case: finished scanning\\n        print(\\'found %s\\'%s)\\n        res.append(s)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        res = []\\n        self.left_to_right(s, res, 0, 0)\\n        return res\\n\\n\\n    def left_to_right(self, s, res, i_start, j_search_start):\\n        \"\"\"\\n        scan from left to right, remove surplus \\')\\'\\n        \"\"\"\\n        # DFS\\n        count = 0\\n        for i in range(i_start, len(s)):\\n            if s[i] == \\'(\\':  # \\'(\\n                count += 1\\n            if s[i] == \\')\\':  # \\')\\n                count -= 1\\n            # Do nothing if it\\'s neither \\')\\' or \\'(\\'\\n\\n            if count < 0:\\n                # search for \\')\\'\\n                for j in range(j_search_start, i + 1):  # j_search_start~i\\n                    if s[j] == \\')\\' \\\\\\n                            and ((j == j_search_start) or s[j - 1] != s[j]):  # remove the first \\')\\' among consecutive ones\\n                        print(\\'i: %d, j: %d\\'%(i,j))\\n                        # remove s[j] and continue searching\\n                        char_removed = s[:j] + s[j+1:]\\n                        self.left_to_right(char_removed, res, i,j)\\n                return  # only search in the char_removed substring\\n\\n        # if finished removing suplus \\')\\' by scanning left to right,\\n        # scan for \\'(\\' right to left\\n        self.right_to_left(s, res, len(s)-1, len(s)-1)\\n\\n\\n    def right_to_left(self, s, res, i_start, j_search_start):\\n        \"\"\"\\n        scan from right to left, remove surplus \\'(\\'\\n        append result to res\\n        \"\"\"\\n        # DFS\\n        count = 0\\n        for i in range(i_start, -1, -1):  # i_start~0\\n            if s[i] == \\')\\':  # \\'(\\n                count += 1\\n            if s[i] == \\'(\\':  # \\')\\n                count -= 1\\n            # Do nothing if it\\'s neither \\')\\' or \\'(\\'\\n\\n            if count < 0:\\n                # search for \\')\\'\\n                for j in range(j_search_start, i-1, -1):  # j_search_start~i (right to left)\\n                    if s[j] == \\'(\\' \\\\\\n                            and ((j == j_search_start) or s[j+1] != s[j]):\\n                        # remove the first \\')\\' among consecutive ones (when scanning from right to left)\\n                        # remove s[j] and continue searching\\n                        char_removed = s[:j] + s[j+1:]\\n                        self.right_to_left(char_removed, res, i-1,j-1)\\n                return\\n\\n        # base case: finished scanning\\n        print(\\'found %s\\'%s)\\n        res.append(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181753,
                "title": "simple-java-solution",
                "content": "```\\n   public class Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n      List<String> res = new ArrayList<>();\\n      if (s == null) return res;\\n      Set<String> visited = new HashSet<>();\\n      Queue<String> queue = new LinkedList<>();\\n      queue.add(s);\\n      visited.add(s);\\n      while (!queue.isEmpty()) {\\n        s = queue.poll();    \\n        if (isValid(s)) {\\n          res.add(s);\\n          break;\\n        } \\n        for (int i = 0; i < s.length(); i++) {\\n          if (s.charAt(i) != \\'(\\' && s.charAt(i) != \\')\\') continue;\\n          String t = s.substring(0, i) + s.substring(i + 1);\\n          if (!visited.contains(t)) {\\n            queue.add(t);\\n            visited.add(t);\\n          }\\n        }\\n      }\\n        while(!queue.isEmpty()) {\\n                String ll = queue.poll();\\n                if(isValid(ll)) res.add(ll);\\n            }\\n      \\n      return res;\\n    }\\n    \\n    boolean isValid(String s) {\\n      int count = 0;\\n      for (char c : s.toCharArray()) {\\n        if (c == \\'(\\') count++;\\n        if (c == \\')\\' && count-- == 0) return false;\\n      }\\n      return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n   public class Solution {\\n    public List<String> removeInvalidParentheses(String s) {\\n      List<String> res = new ArrayList<>();\\n      if (s == null) return res;\\n      Set<String> visited = new HashSet<>();\\n      Queue<String> queue = new LinkedList<>();\\n      queue.add(s);\\n      visited.add(s);\\n      while (!queue.isEmpty()) {\\n        s = queue.poll();    \\n        if (isValid(s)) {\\n          res.add(s);\\n          break;\\n        } \\n        for (int i = 0; i < s.length(); i++) {\\n          if (s.charAt(i) != \\'(\\' && s.charAt(i) != \\')\\') continue;\\n          String t = s.substring(0, i) + s.substring(i + 1);\\n          if (!visited.contains(t)) {\\n            queue.add(t);\\n            visited.add(t);\\n          }\\n        }\\n      }\\n        while(!queue.isEmpty()) {\\n                String ll = queue.poll();\\n                if(isValid(ll)) res.add(ll);\\n            }\\n      \\n      return res;\\n    }\\n    \\n    boolean isValid(String s) {\\n      int count = 0;\\n      for (char c : s.toCharArray()) {\\n        if (c == \\'(\\') count++;\\n        if (c == \\')\\' && count-- == 0) return false;\\n      }\\n      return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135410,
                "title": "python-bfs-commented-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        \"\"\"\\n        input = ()\\n        output = [()]\\n        \\n        #this can generate a duplicate in the input\\n        input = ())\\n        output = [()]\\n        \\n        #same\\n        input = (()\\n        output = [()]\\n        \\n        #empty case\\n        input = \"\"\\n        output = [\"\"]\\n        \\n        #this one removed minimum of 2 to make it valid\\n        input = ())(\\n        output = [()]\\n        \\n        #example given\\n        input = ()())()\\n        output = [\"()()()\", \"(())()\"]\\n        \"\"\"\\n        \\n        self.solution_found = False\\n        self.visited_potential_solutions = set()\\n        self.results = set()\\n        self.bfs(s,0)\\n        return list(self.results)\\n\\n    #breath first search approach\\n    def bfs(self, s, characters_removed):\\n        if s is \"\" or s is None:\\n            return\\n\\n        queue = []\\n        queue.append(s)\\n        \\n        while queue:\\n            #dequeue\\n            current = queue.pop(0)\\n            # print(\\'current\\', current)\\n            \\n            #visit node\\n            if self.is_valid(current):\\n                # print(\\'is_valid\\', True)\\n                self.solution_found = True\\n                self.results.add(current)\\n                continue\\n            # print(\\'is_valid\\', False)\\n            \\n            #this will prevent adding an extra level of possible\\n            #solutions to process in the queue, because we will\\n            #stop after finding the minimum possible removals\\n            if self.solution_found:\\n                continue\\n                \\n            # print(\\'adding more potential solutions\\')\\n            \\n            #since no solution was found:\\n            #add next level of possible solutions of removing\\n            #another character to the queue\\n            for i,c in enumerate(current):\\n                #check if element is parenthesis, if not\\n                #continue, we dont want to remove other characters\\n                if not self.is_parenthesis(c):\\n                    continue\\n                #adding current string without character i\\n                potential_solution = current[:i]+current[i+1:]\\n                \\n                # print(\\'potential_solution\\', potential_solution)\\n                \\n                #only add to the queue if it does not exist to avoid duplicates\\n                #the issue it was adding many simmilar potential solutions\\n                #like for: \")((((((((\" removing one char of that example will\\n                #end adding:\\n                #\\'((((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #as you can see there are a lot of duplicates, we want to avoid that\\n                if potential_solution not in self.visited_potential_solutions:\\n                    self.visited_potential_solutions.add(potential_solution)\\n                    queue.append(potential_solution)\\n    \\n    def is_valid(self, s):\\n        summatory = 0\\n        for c in s:\\n            # print(\\'summatory\\', summatory)\\n            if c == \\'(\\':\\n                summatory += 1\\n            if c == \\')\\':\\n                summatory -= 1\\n                if summatory < 0:\\n                    return False\\n        # print(\\'end summatory\\', summatory)\\n        return summatory == 0\\n\\n    def is_parenthesis(self, c):\\n        return c in [\\'(\\', \\')\\']\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeInvalidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        \"\"\"\\n        input = ()\\n        output = [()]\\n        \\n        #this can generate a duplicate in the input\\n        input = ())\\n        output = [()]\\n        \\n        #same\\n        input = (()\\n        output = [()]\\n        \\n        #empty case\\n        input = \"\"\\n        output = [\"\"]\\n        \\n        #this one removed minimum of 2 to make it valid\\n        input = ())(\\n        output = [()]\\n        \\n        #example given\\n        input = ()())()\\n        output = [\"()()()\", \"(())()\"]\\n        \"\"\"\\n        \\n        self.solution_found = False\\n        self.visited_potential_solutions = set()\\n        self.results = set()\\n        self.bfs(s,0)\\n        return list(self.results)\\n\\n    #breath first search approach\\n    def bfs(self, s, characters_removed):\\n        if s is \"\" or s is None:\\n            return\\n\\n        queue = []\\n        queue.append(s)\\n        \\n        while queue:\\n            #dequeue\\n            current = queue.pop(0)\\n            # print(\\'current\\', current)\\n            \\n            #visit node\\n            if self.is_valid(current):\\n                # print(\\'is_valid\\', True)\\n                self.solution_found = True\\n                self.results.add(current)\\n                continue\\n            # print(\\'is_valid\\', False)\\n            \\n            #this will prevent adding an extra level of possible\\n            #solutions to process in the queue, because we will\\n            #stop after finding the minimum possible removals\\n            if self.solution_found:\\n                continue\\n                \\n            # print(\\'adding more potential solutions\\')\\n            \\n            #since no solution was found:\\n            #add next level of possible solutions of removing\\n            #another character to the queue\\n            for i,c in enumerate(current):\\n                #check if element is parenthesis, if not\\n                #continue, we dont want to remove other characters\\n                if not self.is_parenthesis(c):\\n                    continue\\n                #adding current string without character i\\n                potential_solution = current[:i]+current[i+1:]\\n                \\n                # print(\\'potential_solution\\', potential_solution)\\n                \\n                #only add to the queue if it does not exist to avoid duplicates\\n                #the issue it was adding many simmilar potential solutions\\n                #like for: \")((((((((\" removing one char of that example will\\n                #end adding:\\n                #\\'((((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #\\')(((((((\\'\\n                #as you can see there are a lot of duplicates, we want to avoid that\\n                if potential_solution not in self.visited_potential_solutions:\\n                    self.visited_potential_solutions.add(potential_solution)\\n                    queue.append(potential_solution)\\n    \\n    def is_valid(self, s):\\n        summatory = 0\\n        for c in s:\\n            # print(\\'summatory\\', summatory)\\n            if c == \\'(\\':\\n                summatory += 1\\n            if c == \\')\\':\\n                summatory -= 1\\n                if summatory < 0:\\n                    return False\\n        # print(\\'end summatory\\', summatory)\\n        return summatory == 0\\n\\n    def is_parenthesis(self, c):\\n        return c in [\\'(\\', \\')\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75066,
                "title": "simple-ruby-solution-beats-100-of-solutions",
                "content": "based off this excellent post:\\nhttps://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution\\n````\\n\\ndef remove_invalid_parentheses(s)\\n  @results = []\\n  remove(s, 0, 0, ['(', ')'])\\n  return @results\\nend\\n\\ndef remove(s, prev_i, prev_j, par)\\n  counter = 0\\n  (prev_i...s.length).each do |i|\\n    counter += 1 if s[i] == par[0]\\n    counter -= 1 if s[i] == par[1]\\n    next if counter >= 0\\n    (prev_j..i).each do |j|\\n      if s[j] == par[1] && (s[j-1] != par[1] || j == prev_j)\\n        remove(s[0...j] + s[(j+1)..-1], i, j, par)\\n      end\\n    end\\n    return\\n  end\\n  r_s = s.reverse\\n  if par[0] == '('\\n    remove(r_s, 0, 0, [')','('])\\n  else\\n    @results << r_s\\n  end\\nend\\n\\n````",
                "solutionTags": [],
                "code": "````\\n\\ndef remove_invalid_parentheses(s)\\n  @results = []\\n  remove(s, 0, 0, ['(', ')'])\\n  return @results\\nend\\n\\ndef remove(s, prev_i, prev_j, par)\\n  counter = 0\\n  (prev_i...s.length).each do |i|\\n    counter += 1 if s[i] == par[0]\\n    counter -= 1 if s[i] == par[1]\\n    next if counter >= 0\\n    (prev_j..i).each do |j|\\n      if s[j] == par[1] && (s[j-1] != par[1] || j == prev_j)\\n        remove(s[0...j] + s[(j+1)..-1], i, j, par)\\n      end\\n    end\\n    return\\n  end\\n  r_s = s.reverse\\n  if par[0] == '('\\n    remove(r_s, 0, 0, [')','('])\\n  else\\n    @results << r_s\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 75073,
                "title": "my-0ms-c-solution-improved-depth-limited-dfs-beat-91-01",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tvector<string> ans;\\n\\tvector<int> delLeft;\\n\\tvoid getAns(string& s, string cur, int pos, int cntl, int cntr, int cnt) {\\n\\t\\tif (!(cntl || cntr)) ans.push_back(cur + s.substr(pos));\\n\\t\\telse {\\n\\t\\t\\tfor (int tail = s.length() - cntl - cntr;pos <= tail;++pos) {\\n\\t\\t\\t\\tif (s[pos] == ')') {\\n\\t\\t\\t\\t\\tif (cntr && (cur.empty() || cur.back() != ')'))\\n\\t\\t\\t\\t\\t\\tgetAns(s, cur, pos + 1, cntl, cntr - 1, cnt);\\n\\t\\t\\t\\t\\tif (cnt == 0) return;\\n\\t\\t\\t\\t\\t--cnt;\\n\\t\\t\\t\\t\\tcur += ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s[pos] == '(') {\\n\\t\\t\\t\\t\\tif (cntr == 0 && cntl > delLeft[pos] && (cur.empty() || cur.back() != '('))\\n\\t\\t\\t\\t\\t\\tgetAns(s, cur, pos + 1, cntl - 1, cntr, cnt);\\n\\t\\t\\t\\t\\t++cnt;\\n\\t\\t\\t\\t\\tcur += '(';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse cur += s[pos];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<string> removeInvalidParentheses(string s) {\\n\\t\\tif (s == \"\") return vector<string> (1, \"\");\\n\\t\\tint cntr = 0;\\n\\t\\tdelLeft.resize(s.length());\\n\\t\\tdelLeft[s.length() - 1] = 0;\\n\\t\\tfor (int i = s.length() - 1;i > 0;--i) {\\n\\t\\t\\tif (s[i] == ')') ++cntr, delLeft[i - 1] = delLeft[i];\\n\\t\\t\\telse if (s[i] == '(') {\\n\\t\\t\\t\\tif (cntr) --cntr, delLeft[i - 1] = delLeft[i];\\n\\t\\t\\t\\telse delLeft[i - 1] = delLeft[i] + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse delLeft[i - 1] = delLeft[i];\\n\\t\\t}\\n\\t\\tans.resize(0);\\n\\t\\tif (s[0] == '('&&cntr == 0) getAns(s, \"\", 0, delLeft[0] + 1, cntr, 0);\\n\\t\\telse if (s[0] == '(') getAns(s, \"\", 0, delLeft[0], cntr - 1, 0);\\n\\t\\telse if (s[0] == ')') getAns(s, \"\", 0, delLeft[0], cntr + 1, 0);\\n\\t\\telse getAns(s, \"\", 0, delLeft[0], cntr, 0);\\n\\t\\treturn ans;\\n\\t}\\n};\\n````\\nThis solution is based on depth-limited-DFS, and I judged whether a parenthesis must be removed, so that we can deal the problem without judge the string is valid or not.\\n\\nA right parenthesis must be removed when the string has no free left parenthesis before it, we can solve it in the function.\\n\\nTo judge a left parenthesis cannot be solved in the function as we don't know the right part of the string, so we can use a array to record how many left parentheses must be removed after the parenthesis. if the remain number can be removed is no larger than that, the left parenthesis cannot be removed. \\n\\nWe can sure a result string is valid with above improve, so that we can add it into the vector without scan it.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvector<string> ans;\\n\\tvector<int> delLeft;\\n\\tvoid getAns(string& s, string cur, int pos, int cntl, int cntr, int cnt) {\\n\\t\\tif (!(cntl || cntr)) ans.push_back(cur + s.substr(pos));\\n\\t\\telse {\\n\\t\\t\\tfor (int tail = s.length() - cntl - cntr;pos <= tail;++pos) {\\n\\t\\t\\t\\tif (s[pos] == ')') {\\n\\t\\t\\t\\t\\tif (cntr && (cur.empty() || cur.back() != ')'))\\n\\t\\t\\t\\t\\t\\tgetAns(s, cur, pos + 1, cntl, cntr - 1, cnt);\\n\\t\\t\\t\\t\\tif (cnt == 0) return;\\n\\t\\t\\t\\t\\t--cnt;\\n\\t\\t\\t\\t\\tcur += ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s[pos] == '(') {\\n\\t\\t\\t\\t\\tif (cntr == 0 && cntl > delLeft[pos] && (cur.empty() || cur.back() != '('))\\n\\t\\t\\t\\t\\t\\tgetAns(s, cur, pos + 1, cntl - 1, cntr, cnt);\\n\\t\\t\\t\\t\\t++cnt;\\n\\t\\t\\t\\t\\tcur += '(';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse cur += s[pos];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<string> removeInvalidParentheses(string s) {\\n\\t\\tif (s == \"\") return vector<string> (1, \"\");\\n\\t\\tint cntr = 0;\\n\\t\\tdelLeft.resize(s.length());\\n\\t\\tdelLeft[s.length() - 1] = 0;\\n\\t\\tfor (int i = s.length() - 1;i > 0;--i) {\\n\\t\\t\\tif (s[i] == ')') ++cntr, delLeft[i - 1] = delLeft[i];\\n\\t\\t\\telse if (s[i] == '(') {\\n\\t\\t\\t\\tif (cntr) --cntr, delLeft[i - 1] = delLeft[i];\\n\\t\\t\\t\\telse delLeft[i - 1] = delLeft[i] + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse delLeft[i - 1] = delLeft[i];\\n\\t\\t}\\n\\t\\tans.resize(0);\\n\\t\\tif (s[0] == '('&&cntr == 0) getAns(s, \"\", 0, delLeft[0] + 1, cntr, 0);\\n\\t\\telse if (s[0] == '(') getAns(s, \"\", 0, delLeft[0], cntr - 1, 0);\\n\\t\\telse if (s[0] == ')') getAns(s, \"\", 0, delLeft[0], cntr + 1, 0);\\n\\t\\telse getAns(s, \"\", 0, delLeft[0], cntr, 0);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75076,
                "title": "fast-o-n-3-dynamic-programming-solution-asymptotically-faster-than-bfs-dfs-search-solutions",
                "content": "This is a dynamic programming solution that outperforms 94% of the C# solutions. From the chart, it looks like this is the second fastest implementation. The BFS, DFS solutions are potentially exponential in n. Further improvements can be made in reducing string allocations.\\n\\n```\\npublic class Solution {\\n        public IList<string> RemoveInvalidParentheses(string s)\\n        {\\n            var list = new HashSet<string>();\\n            Dfs(MinParenRemoved(s), s, 0, s.Length - 1, x => list.Add(x));\\n            return list.ToList();\\n        }\\n\\n        public int[,] MinParenRemoved(string s)\\n        {\\n            var dp = new int[s.Length + 1, s.Length + 1];\\n\\n            for (int i=0; i<s.Length; i++)\\n                dp[i,i] = s[i] == '(' || s[i] == ')' ? 1 : 0;\\n\\n            for (int len=1; len<s.Length; len++)\\n                for (int i = 0; i + len < s.Length; i++)\\n                {\\n                    int j = i+len;\\n                    char ch = s[j];\\n                    int min = dp[i, j - 1] + (ch=='(' || ch==')' ? 1 : 0);\\n                    if (ch == ')')\\n                    {\\n                        for (int k = i; k < j; k++)\\n                            if (s[k] == '(')\\n                            {\\n                                int lmin = i>k-1 ? 0 : dp[i, k - 1];\\n                                int rmin = k+1>j-1 ? 0 : dp[k + 1, j - 1];\\n                                if (lmin + rmin < min)\\n                                {\\n                                    min = lmin + rmin; // MinParenRemoved at most 1 smaller\\n                                    break;\\n                                }\\n                            }\\n                    }\\n                    dp[i,j] = min;\\n                }\\n                \\n            return dp;\\n        }\\n\\n        void Dfs(int[,] dp, string s, int left, int right, Action<string> action)\\n        {\\n            // Remove extraneous end characters\\n            while (left <= right && s[left]==')') // Optimization\\n                left++;\\n                \\n            while (left <= right && s[right]=='(')  // Necessary\\n                right--;\\n\\n            // We only print out well-formed strings\\n            if (left > right || dp[left, right] == 0)\\n            {\\n                action(s.Substring(left, right - left + 1));\\n                return;\\n            }\\n\\n            if (s[right] != ')')\\n            {\\n                Dfs(dp, s, left, right - 1, str => action(str + s[right]));\\n                return;\\n            }\\n\\n            int min = dp[left, right];\\n            if (min > dp[left, right - 1])\\n                Dfs(dp, s, left, right - 1, action);\\n\\n            for (int i = left; i < right; i++)\\n            {\\n                var ch = s[i];\\n                if (ch != '(') continue;\\n                int lmin = left > i - 1 ? 0 : dp[left, i - 1];\\n                int rmin = i + 1 > right - 1 ? 0 : dp[i + 1, right - 1];\\n                if (lmin + rmin <= min)\\n                    Dfs(dp, s, left, i - 1,\\n                        s2 => Dfs(dp, s, i + 1, right-1,\\n                            s3 => action(s2 + \"(\" + s3 + \")\")));\\n            }\\n        }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        public IList<string> RemoveInvalidParentheses(string s)\\n        {\\n            var list = new HashSet<string>();\\n            Dfs(MinParenRemoved(s), s, 0, s.Length - 1, x => list.Add(x));\\n            return list.ToList();\\n        }\\n\\n        public int[,] MinParenRemoved(string s)\\n        {\\n            var dp = new int[s.Length + 1, s.Length + 1];\\n\\n            for (int i=0; i<s.Length; i++)\\n                dp[i,i] = s[i] == '(' || s[i] == ')' ? 1 : 0;\\n\\n            for (int len=1; len<s.Length; len++)\\n                for (int i = 0; i + len < s.Length; i++)\\n                {\\n                    int j = i+len;\\n                    char ch = s[j];\\n                    int min = dp[i, j - 1] + (ch=='(' || ch==')' ? 1 : 0);\\n                    if (ch == ')')\\n                    {\\n                        for (int k = i; k < j; k++)\\n                            if (s[k] == '(')\\n                            {\\n                                int lmin = i>k-1 ? 0 : dp[i, k - 1];\\n                                int rmin = k+1>j-1 ? 0 : dp[k + 1, j - 1];\\n                                if (lmin + rmin < min)\\n                                {\\n                                    min = lmin + rmin; // MinParenRemoved at most 1 smaller\\n                                    break;\\n                                }\\n                            }\\n                    }\\n                    dp[i,j] = min;\\n                }\\n                \\n            return dp;\\n        }\\n\\n        void Dfs(int[,] dp, string s, int left, int right, Action<string> action)\\n        {\\n            // Remove extraneous end characters\\n            while (left <= right && s[left]==')') // Optimization\\n                left++;\\n                \\n            while (left <= right && s[right]=='(')  // Necessary\\n                right--;\\n\\n            // We only print out well-formed strings\\n            if (left > right || dp[left, right] == 0)\\n            {\\n                action(s.Substring(left, right - left + 1));\\n                return;\\n            }\\n\\n            if (s[right] != ')')\\n            {\\n                Dfs(dp, s, left, right - 1, str => action(str + s[right]));\\n                return;\\n            }\\n\\n            int min = dp[left, right];\\n            if (min > dp[left, right - 1])\\n                Dfs(dp, s, left, right - 1, action);\\n\\n            for (int i = left; i < right; i++)\\n            {\\n                var ch = s[i];\\n                if (ch != '(') continue;\\n                int lmin = left > i - 1 ? 0 : dp[left, i - 1];\\n                int rmin = i + 1 > right - 1 ? 0 : dp[i + 1, right - 1];\\n                if (lmin + rmin <= min)\\n                    Dfs(dp, s, left, i - 1,\\n                        s2 => Dfs(dp, s, i + 1, right-1,\\n                            s3 => action(s2 + \"(\" + s3 + \")\")));\\n            }\\n        }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75088,
                "title": "4ms-c-dfs-solution",
                "content": "class Solution {\\n\\npublic:\\n    \\n    int size;\\n    int count;\\n    int del_left_min;\\n    int del_right_min;\\n    string str;\\n    vector<string> answer;\\n    \\n    void dfs(string s, int idx) {\\n        // count = counter of the parentheses so far in \"str\". '('= +1, ')'= -1;\\n        // invalid \"str\": count < 0 or deleting too many\\n        if (count < 0 || del_left_min < 0 || del_right_min < 0) return;\\n        \\n        // find a valid \"str\"\\n        else if (idx >= size) {\\n            if (count == 0) answer.push_back(str);\\n            return;\\n        }\\n        char cur_char = s[idx];\\n        bool isLetter = (cur_char != ')' && cur_char != '(');\\n        int inc = (cur_char == '(') ? 1 : -1;\\n        \\n        // if current char is a letter\\n        if (isLetter) {\\n            str.push_back(cur_char);\\n            dfs(s, idx + 1);\\n            str.pop_back();\\n        \\n        // if current char is a parenthesis\\n        } else {\\n            int pos = idx;\\n            while (pos < size && s[pos] == cur_char) pos++;\\n            int repeat_num = pos - idx;\\n            int &del_min = (cur_char == '(') ? del_left_min : del_right_min;\\n            del_min -= repeat_num;\\n            \\n            // use for loop to handle repeat parentheses\\n            // j = the number of parentheses selected\\n            for (int j = 0; j <= repeat_num; j++) {\\n                dfs(s, idx + repeat_num);\\n                str.push_back(cur_char);\\n                count += inc;\\n                if (j < repeat_num) del_min++;\\n            }\\n            count -= inc * (repeat_num + 1);\\n            for (int j = 0; j <= repeat_num; j++) str.pop_back();\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        str.clear();\\n        size = s.size();\\n        if (size == 0) {\\n            answer.push_back(str);\\n            return answer;\\n        }    \\n        \\n        // del_right_min = minimal number of \")\" to delete\\n        count = del_right_min = 0;\\n        for (int i = 0; i < size; i++) {\\n            if (s[i] == '(') count++;\\n            else if (s[i] == ')') {\\n                if (count == 0) del_right_min++;\\n                else count--;\\n            }    \\n        }\\n        \\n        // del_left_min = minimal number of \"(\" to delete\\n        count = del_left_min = 0;\\n        for (int i = size; i >= 0; i--) {\\n            if (s[i] == ')') count++;\\n            else if (s[i] == '(') {\\n                if (count == 0) del_left_min++;\\n                else count--;\\n            }\\n        }\\n        \\n        count = 0;\\n        dfs(s, 0);\\n        return answer;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\npublic:\\n    \\n    int size;\\n    int count;\\n    int del_left_min;\\n    int del_right_min;\\n    string str;\\n    vector<string> answer;\\n    \\n    void dfs(string s, int idx) {\\n        // count = counter of the parentheses so far in \"str\". '('= +1, ')'= -1;\\n        // invalid \"str\": count < 0 or deleting too many\\n        if (count < 0 || del_left_min < 0 || del_right_min < 0) return;\\n        \\n        // find a valid \"str\"\\n        else if (idx >= size) {\\n            if (count == 0) answer.push_back(str);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 75089,
                "title": "c-8ms-solution-dfs",
                "content": "standard DFS solution.\\n\\nVersion 0. check each of the substr, with each '(' or ')' kept or removed. There are totally 2^n possible substrings. (neglect characters other than '(' and ')').\\n\\nOptimization 1. when processing from left to right, we only consider the substr with no less '(' than ')'.\\n\\nOptimization 2. Actually, we can pre-process the string and find out how many '(' and ')' exist in the final results. Then, we know how many '(' and ')' we need remove, respectively. Thus, in the DFS, we stop if we exceed the  limits. \\n\\n\\n    class Solution {\\n    public:\\n    void dfs(set<string> &res, string &s, string sub, int l,int r,int dl,int dr, int maxDL,int maxDR, int n){\\n        if (l<r) return;  // optimization 1\\n        if (n==s.size()){\\n            if (l==r) res.insert(sub);\\n            return;\\n        }\\n        if (s[n]=='('){\\n            dfs(res,s,sub+'(',l+1,r,dl,dr,maxDL,maxDR,n+1);\\n            if (dl<maxDL)  dfs(res,s,sub,l,r,dl+1,dr,maxDL,maxDR,n+1); // only remove this '(' if we can still remove one.\\n        }else if (s[n]==')'){\\n            dfs(res,s,sub+')',l,r+1,dl,dr,maxDL,maxDR,n+1);\\n            if (dr<maxDR)  dfs(res,s,sub,l,r,dl,dr+1,maxDL,maxDR,n+1);  // only remove this ')' if we can still remove one.\\n        }else{\\n            dfs(res,s,sub+s[n],l,r,dl,dr,maxDL,maxDR,n+1);\\n        }\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) {\\n        vector<string> res;\\n        set<string> res_set;\\n        int finalZs=0,chars=0;\\n        int d=0,l=0,r=0;\\n        for (int i=0;i<s.size();i++){\\n            if (s[i]=='('){\\n                d++;\\n                l++;\\n            }else if (s[i]==')'){\\n                r++;\\n                if(d>0){\\n                    d--;finalZs++;\\n                }\\n            }\\n        }\\n        dfs(res_set,s,\"\",0,0,0,0,l-finalZs,r-finalZs,0);\\n        int maxL=0;\\n        for (auto&x:res_set){\\n            res.push_back(x);\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void dfs(set<string> &res, string &s, string sub, int l,int r,int dl,int dr, int maxDL,int maxDR, int n){\\n        if (l<r) return;  // optimization 1\\n        if (n==s.size()){\\n            if (l==r) res.insert(sub);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 75109,
                "title": "java-dfs-solution-with-optimizations",
                "content": "    public List<String> removeInvalidParentheses(String s) {\\n      List<String> res = new ArrayList<>();\\n      if(s==null || s.length()==0) {\\n        res.add(\"\");  \\n        return res;\\n      }    \\n      StringBuilder sb = new StringBuilder();\\n      int target = 0; // minimum number to be removed\\n      int leftCnt = 0; // count of \"(\"\\n      // calculate minimum number to be removed\\n      // by counting the numbers of matching pairs \"()\", \")(\" doesn't count\\n      for(int i=0; i<s.length(); i++) {\\n        if(leftCnt>0 && s.charAt(i)==')') {\\n          target--;\\n          leftCnt--;\\n        }\\n        else if(s.charAt(i)==')')\\n          target++;\\n        else if(s.charAt(i)=='(') {\\n          target++;\\n          leftCnt++;\\n        }  \\n      }\\n      Helper(s, sb, 0, 0, 0, target, res);    \\n      return res;    \\n    }\\n    private void Helper(String s, StringBuilder sb, int start, int count, \\n                        int removeNum, int target, List<String> res) {\\n      if(start>=s.length() && count==0) {//check if \"(\", \")\" are balanced\\n        res.add(sb.toString());\\n        return;\\n      }\\n      // used to store if both \"(\" and \")\" have occurred\\n      HashSet<Character> set = new HashSet<>();\\n      // The last character might be removed to form valid parentheses\\n      // that's when i == s.length()\\n      for(int i=start; i<=s.length(); i++) {\\n        if(count==0 && i<s.length() && s.charAt(i)==')') \\n          continue;\\n        // At the nth recursion, if both '(' and ')' have occurred, return early\\n        // to eliminate duplicate paths\\n        if(i<s.length() && set.contains(s.charAt(i))) {\\n          if(set.size()==2)\\n            return;\\n          else\\n            continue;\\n        }\\n        else {\\n          if(i<s.length())    \\n            set.add(s.charAt(i));\\n        }  \\n        int temp1 = count;\\n        int temp2 = removeNum;\\n        if(i<s.length() && s.charAt(i)=='(')\\n          count++;\\n        else if(i<s.length() && s.charAt(i)==')')\\n          count--;\\n        removeNum = removeNum + (i-start);\\n        if(removeNum>target) // return early if parentheses removed exceeds target \\n          return;\\n        if(i<s.length())\\n          sb.append(s.charAt(i));\\n        Helper(s, sb, i+1, count, removeNum, target, res);\\n        if(i<s.length())\\n          sb.deleteCharAt(sb.length()-1);\\n        count = temp1;\\n        removeNum = temp2;\\n      }\\n    } \\n\\n\\nThe basic idea is as follows:\\n\\n 1. First find out the minimum number of parentheses to be removed by scanning the string.\\n 2. Explore all combinations of the strings by DFS and add to the result if the parentheses are balanced and valid, return the current recursion call early if either of the following happens:\\n    (1) The number of removed parentheses have exceeded the minimum number calculated. \\n    (2) Both \"(\" and \")\" have occurred and the remaining combinations of the current recursion are duplicates.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "    public List<String> removeInvalidParentheses(String s) {\\n      List<String> res = new ArrayList<>();\\n      if(s==null || s.length()==0) {\\n        res.add(\"\");  \\n        return res;\\n      }    \\n      StringBuilder sb = new StringBuilder();\\n      int target = 0; // minimum number to be removed\\n      int leftCnt = 0; // count of \"(\"\\n      // calculate minimum number to be removed\\n      // by counting the numbers of matching pairs \"()\", \")(\" doesn't count\\n      for(int i=0; i<s.length(); i++) {\\n        if(leftCnt>0 && s.charAt(i)==')') {\\n          target--;\\n          leftCnt--;\\n        }\\n        else if(s.charAt(i)==')')\\n          target++;\\n        else if(s.charAt(i)=='(') {\\n          target++;\\n          leftCnt++;\\n        }  \\n      }\\n      Helper(s, sb, 0, 0, 0, target, res);    \\n      return res;    \\n    }\\n    private void Helper(String s, StringBuilder sb, int start, int count, \\n                        int removeNum, int target, List<String> res) {\\n      if(start>=s.length() && count==0) {//check if \"(\", \")\" are balanced\\n        res.add(sb.toString());\\n        return;\\n      }\\n      // used to store if both \"(\" and \")\" have occurred\\n      HashSet<Character> set = new HashSet<>();\\n      // The last character might be removed to form valid parentheses\\n      // that's when i == s.length()\\n      for(int i=start; i<=s.length(); i++) {\\n        if(count==0 && i<s.length() && s.charAt(i)==')') \\n          continue;\\n        // At the nth recursion, if both '(' and ')' have occurred, return early\\n        // to eliminate duplicate paths\\n        if(i<s.length() && set.contains(s.charAt(i))) {\\n          if(set.size()==2)\\n            return;\\n          else\\n            continue;\\n        }\\n        else {\\n          if(i<s.length())    \\n            set.add(s.charAt(i));\\n        }  \\n        int temp1 = count;\\n        int temp2 = removeNum;\\n        if(i<s.length() && s.charAt(i)=='(')\\n          count++;\\n        else if(i<s.length() && s.charAt(i)==')')\\n          count--;\\n        removeNum = removeNum + (i-start);\\n        if(removeNum>target) // return early if parentheses removed exceeds target \\n          return;\\n        if(i<s.length())\\n          sb.append(s.charAt(i));\\n        Helper(s, sb, i+1, count, removeNum, target, res);\\n        if(i<s.length())\\n          sb.deleteCharAt(sb.length()-1);\\n        count = temp1;\\n        removeNum = temp2;\\n      }\\n    } \\n\\n\\nThe basic idea is as follows:\\n\\n 1. First find out the minimum number of parentheses to be removed by scanning the string.\\n 2. Explore all combinations of the strings by DFS and add to the result if the parentheses are balanced and valid, return the current recursion call early if either of the following happens:\\n    (1) The number of removed parentheses have exceeded the minimum number calculated. \\n    (2) Both \"(\" and \")\" have occurred and the remaining combinations of the current recursion are duplicates.",
                "codeTag": "Unknown"
            },
            {
                "id": 75116,
                "title": "easy-understand-36ms-c-dfs",
                "content": "\\n\\n    class Solution {\\n    public:\\n        string str;\\n        int len;\\n        map<string, vector<string> > all; // to store middle results\\n        \\n        // the answer for string starting at index pos, with additional left brackets\\n        vector<string> dfs(int pos, int left) {\\n            string key = to_string(pos)+\"-\"+to_string(left);\\n            if (all.find(key)!=all.end())\\n                return all[key];\\n            \\n            vector<string> ans, temp;\\n            if (left<0 || pos==len) {\\n                if (left==0) ans.push_back(\"\");\\n                return ans;\\n            }\\n            \\n            int newLeft=left; // by default, in case str[pos] is letter\\n            if (str[pos]=='(') newLeft += 1; // in case we keep this '(', add one count of left brackets\\n            else if (str[pos]==')') newLeft -= 1; // in case we keep this ')', minus one count of left brackets\\n            \\n            for (auto& t : refine(dfs(pos+1, newLeft)))\\n                ans.push_back(str[pos] + t);\\n            \\n            if (str[pos]=='(' || str[pos]==')') // in case we remove '(' or ')', having the same num of left brackets\\n            \\tfor (auto& t : refine(dfs(pos+1, left)))\\n            \\t    ans.push_back(t);\\n            \\n            all[key]=ans;\\n            return ans;\\n        }\\n        \\n        vector<string> removeInvalidParentheses(string s) {\\n            str = s;\\n            len=str.length();\\n            return refine(dfs(0, 0));\\n        }\\n        \\n        // helpers:\\n        int max(int a, int b) {\\n        \\treturn a>b ? a : b;\\n    \\t}\\n        \\n        // keep strings with max length and remove duplicates\\n        vector<string> refine(vector<string> vec) {\\n            if (vec.empty())\\n                return vec;\\n                \\n            vector<string> temp;\\n            int maxlen=-1;\\n            for (auto& s : vec)\\n                maxlen=max(maxlen, s.length());\\n                \\n            set<string> seen;\\n            for (auto& s : vec)\\n                if (s.length()==maxlen && seen.find(s)==seen.end()) {\\n                    temp.push_back(s);\\n                    seen.insert(s);\\n                }\\n            return temp;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string str;\\n        int len;\\n        map<string, vector<string> > all; // to store middle results\\n        \\n        // the answer for string starting at index pos, with additional left brackets\\n        vector<string> dfs(int pos, int left) {\\n            string key = to_string(pos)+\"-\"+to_string(left);\\n            if (all.find(key)!=all.end())\\n                return all[key];\\n            \\n            vector<string> ans, temp;\\n            if (left<0 || pos==len) {\\n                if (left==0) ans.push_back(\"\");\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3804724,
                "title": "c-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    unordered_map<string,int> m;\\n    vector<string> removeInvalidParentheses(string s) {\\n        //try all possible ways --> Recursion\\n        //remove each char and check inValid chars in substring\\n        //\"()())()\" --> check inValid chars in [\")())()\", \"(())()\", \"()))()\", ...]\\n        solve(s,getMinInvalid(s));\\n        return res;\\n    }\\n    int getMinInvalid(string s){\\n        stack<char> st;\\n        for(int i:s){\\n            if(i==\\'(\\')  st.push(i);\\n            else if(i==\\')\\'){\\n                if(st.size()>0 && st.top()==\\'(\\')   st.pop();\\n                else    st.push(i);\\n            }\\n        }\\n        // \"(a)())()\"\\n        // st --> [)]\\n        return st.size();\\n    }\\n    void solve(string s,int minInv){\\n        if(m[s])    return;\\n        else    m[s]++;\\n        if(minInv==0){\\n            if(!getMinInvalid(s))   res.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            string left=s.substr(0,i);\\n            string right=s.substr(i+1);\\n            solve(left+right,minInv-1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    unordered_map<string,int> m;\\n    vector<string> removeInvalidParentheses(string s) {\\n        //try all possible ways --> Recursion\\n        //remove each char and check inValid chars in substring\\n        //\"()())()\" --> check inValid chars in [\")())()\", \"(())()\", \"()))()\", ...]\\n        solve(s,getMinInvalid(s));\\n        return res;\\n    }\\n    int getMinInvalid(string s){\\n        stack<char> st;\\n        for(int i:s){\\n            if(i==\\'(\\')  st.push(i);\\n            else if(i==\\')\\'){\\n                if(st.size()>0 && st.top()==\\'(\\')   st.pop();\\n                else    st.push(i);\\n            }\\n        }\\n        // \"(a)())()\"\\n        // st --> [)]\\n        return st.size();\\n    }\\n    void solve(string s,int minInv){\\n        if(m[s])    return;\\n        else    m[s]++;\\n        if(minInv==0){\\n            if(!getMinInvalid(s))   res.push_back(s);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            string left=s.substr(0,i);\\n            string right=s.substr(i+1);\\n            solve(left+right,minInv-1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705960,
                "title": "bfs-priorityqueue-c-similar-to-djisktra-algorithm",
                "content": "```\\nclass Space{\\n  public:\\n    bool isValid;\\n    int removals;\\n    string str;\\n    Space(bool isValid , int removals , string str){\\n        this->isValid = isValid;\\n        this->removals = removals;\\n        this->str = str;\\n    }\\n};\\n\\nclass Compare{\\n    public:\\n    bool operator()(Space &a , Space &b){\\n        if(a.isValid == b.isValid){\\n            return a.removals > b.removals;\\n        }\\n        else{\\n            return a.isValid < b.isValid;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    bool checkValidity(string str){\\n        stack<char> s;\\n        int n = str.size();\\n        for(int i=0 ; i<n ; i++){\\n            if((str[i] == \\'(\\')){\\n                s.push(str[i]);\\n            }\\n            else if(str[i] == \\')\\'){\\n                if(s.empty()) return false;\\n                else if(s.top()==\\'(\\'){\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.size();\\n        priority_queue<Space , vector<Space> , Compare> pq;\\n        vector<string> ans;\\n        \\n        pq.push(Space(checkValidity(s) , 0 , s));\\n        set<string> vis;\\n        vis.insert(s);\\n        int minRemovals = 1e6;\\n        while(pq.size() > 0){\\n            auto [valid , rems , currStr] = pq.top() ; pq.pop();\\n            // cout<<valid<<\" \"<<rems<<\" \"<<currStr<<endl;\\n            if(rems > minRemovals) break;\\n            if(valid){\\n                minRemovals = rems;\\n            }\\n            if(valid && (minRemovals == rems)){\\n                ans.push_back(currStr);\\n            }\\n            \\n            for(int i=0 ; i<currStr.size() ; i++){\\n                if(currStr[i]>=\\'a\\' && currStr[i]<=\\'z\\') continue;\\n                string left = currStr.substr(0 , i);\\n                // cout<<left<<\" is left\"<<endl;\\n                string right = currStr.substr(i+1);\\n                // cout<<right<<\" is rihgt\"<<endl;\\n                string newStr = left+right;\\n                if(vis.count(newStr) == 0 ){\\n                    vis.insert(newStr);\\n                    pq.push(Space(checkValidity(newStr) , rems+1 , newStr));\\n                }                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Space{\\n  public:\\n    bool isValid;\\n    int removals;\\n    string str;\\n    Space(bool isValid , int removals , string str){\\n        this->isValid = isValid;\\n        this->removals = removals;\\n        this->str = str;\\n    }\\n};\\n\\nclass Compare{\\n    public:\\n    bool operator()(Space &a , Space &b){\\n        if(a.isValid == b.isValid){\\n            return a.removals > b.removals;\\n        }\\n        else{\\n            return a.isValid < b.isValid;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    bool checkValidity(string str){\\n        stack<char> s;\\n        int n = str.size();\\n        for(int i=0 ; i<n ; i++){\\n            if((str[i] == \\'(\\')){\\n                s.push(str[i]);\\n            }\\n            else if(str[i] == \\')\\'){\\n                if(s.empty()) return false;\\n                else if(s.top()==\\'(\\'){\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.size();\\n        priority_queue<Space , vector<Space> , Compare> pq;\\n        vector<string> ans;\\n        \\n        pq.push(Space(checkValidity(s) , 0 , s));\\n        set<string> vis;\\n        vis.insert(s);\\n        int minRemovals = 1e6;\\n        while(pq.size() > 0){\\n            auto [valid , rems , currStr] = pq.top() ; pq.pop();\\n            // cout<<valid<<\" \"<<rems<<\" \"<<currStr<<endl;\\n            if(rems > minRemovals) break;\\n            if(valid){\\n                minRemovals = rems;\\n            }\\n            if(valid && (minRemovals == rems)){\\n                ans.push_back(currStr);\\n            }\\n            \\n            for(int i=0 ; i<currStr.size() ; i++){\\n                if(currStr[i]>=\\'a\\' && currStr[i]<=\\'z\\') continue;\\n                string left = currStr.substr(0 , i);\\n                // cout<<left<<\" is left\"<<endl;\\n                string right = currStr.substr(i+1);\\n                // cout<<right<<\" is rihgt\"<<endl;\\n                string newStr = left+right;\\n                if(vis.count(newStr) == 0 ){\\n                    vis.insert(newStr);\\n                    pq.push(Space(checkValidity(newStr) , rems+1 , newStr));\\n                }                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3688555,
                "title": "c-recursion-and-backtracking-with-explanation",
                "content": "## Table of Contents\\n\\n- [Explanation](#explanation)\\n- [Approach](#approach)\\n- [Complexity](#complexity)\\n- [Code](#code)\\n\\n# Explanation\\n\\nThe program uses [Backtracking](https://en.wikipedia.org/wiki/Backtracking) and [Recursion](https://en.wikipedia.org/wiki/Recursion_(computer_science))\\n\\n<details>\\n<summary>Click here for an explanation about <strong>Backtracking</strong></summary>\\n<blockquote><p>A backtracking algorithm is a type of search algorithm that is used for solving optimization and constraint satisfaction problems. It works by first exploring all possible paths through the problem solution space, and then systematically eliminating those paths that cannot lead to a valid solution.</p>\\n\\n<p>At each step of the backtracking process, the algorithm examines the current configuration to determine if it satisfies all constraints and if it is a valid solution. If not, the algorithm will \"backtrack\" by undoing any previous decisions and trying a different path. This process is repeated until a is found or all paths have been exhausted.</p>\\n\\n<p>Backtracking algorithms are commonly used in puzzle applications such as Sudoku and the Eight Queens Puzzle. They can also be applied to more complex problems such as network routing and scheduling. The key advantage of backtracking algorithms is their ability to search through a large solution space efficiently by eliminating unproductive paths early on.</p></blockquote>\\n</details>\\n\\n<details>\\n<summary>Click here for an explanation about <strong>Recursion</strong></summary>\\n<blockquote><p>A recursion algorithm is a programming technique that involves calling a function within itself. In other words, the function keeps calling itself until it reaches a base case or condition that stops the recursion. Recursion is used to solve problems that can be broken down into smaller sub-problems, and where the solution to the original problem depends on the solutions to the sub-problems.</p>\\n\\n<p>One use case for recursion is in traversing data structures like trees, where a node may have multiple child nodes, which in turn may have their own child nodes. Recursion can also be used in numerical methods, such as the Fibonacci sequence or factorials.</p>\\n\\n<p>However, it is important to be cautious when using recursion as it can lead to unwanted outcomes such as infinite loops or stack overflows if not implemented correctly. It is also generally less efficient than iteration, which is where a loop is used to repeat a process until a certain condition is met.</p></blockquote>\\n</details>\\n\\n# Approach\\n\\n1. First, we handle the edge case where the input string `s` is empty. In this case, we add an empty string to the list of valid expressions and return it.\\n2. We count the number of misplaced parentheses in the input string `s`. We iterate through each character of the string and maintain counters for misplaced open parentheses `misplacedOpen` and misplaced closing parentheses `misplacedClose`. Whenever we encounter a closing parenthesis without a corresponding open parenthesis, we increment `misplacedClose`. If we find an open parenthesis without a corresponding closing parenthesis, we increment `misplacedOpen`. These counts represent the minimum number of parentheses that need to be removed to make the string valid.\\n3. We use a recursive helper function `GenerateExpressions` to generate all valid expressions with the minimum number of removals. The function takes parameters such as the input string `s`, the current index, counts of misplaced open and closing parentheses, the current count of open parentheses, an expression list to store the generated expression, and a HashSet to store the unique valid expressions.\\n4. The `GenerateExpressions` function works as follows:\\n    - Base case: If the current index reaches the end of the string (index == s.Length), we check if the counts of misplaced open and closing parentheses are both zero. If they are, it means we have a valid expression. We convert the expression list to a string and add it to the HashSet of valid expressions.\\n    - Recursive cases:\\n      - If the current character is not a parenthesis `currentChar != \\'(\\' && currentChar != \\')\\'`, we add it to the expression list and recursively call the function for the next index.\\n      - If the current character is a misplaced opening parenthesis `currentChar == \\'(\\' && misplacedOpen > 0` or a misplaced closing parenthesis `currentChar == \\')\\' && misplacedClose > 0`, we can remove it by decrementing the corresponding misplaced count and recursively calling the function for the next index.\\n      - If the current character is a valid parenthesis (either an opening parenthesis with a corresponding count of open parentheses or a closing parenthesis with a count of open parentheses greater than zero), we add it to the `expression` list and adjust the open count accordingly. Then, we recursively call the function for the next index.\\n      - After each recursive call, we remove the last character from the expression list to backtrack and explore other possibilities.\\n5. Finally, we convert the HashSet of valid expressions to a List and return it as the result.\\n\\n# Complexity\\n\\n- Time complexity: $$O(2^M * N)$$\\n\\nLet $$N$$ be the length of the input string `s`. In the worst case, the number of recursive calls is exponential. Each recursive call processes one character of the string and performs constant-time operations. Therefore, the overall time complexity is $$O(2^M * N)$$, where $$M$$ is the number of misplaced parentheses $$(M <= N)$$.\\n\\n- Space complexity: $$O(2^M + N)$$\\n\\nThe space required for the HashSet `validExpressions` is proportional to the number of unique valid expressions generated, which can be at most $$2^M$$. The recursion depth is limited by the length of the input string, so the maximum depth is $$N$$. The additional space used by the recursive calls and the `expression` list is proportional to the recursion depth, which is $$N$$. Therefore, the overall space complexity is $$O(2^M + N)$$.\\n\\n# Code\\n```\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public IList<string> RemoveInvalidParentheses(string s) {\\n        HashSet<string> validExpressions = new HashSet<string>();\\n\\n        // Edge case: empty string\\n        if (s == null || s.Length == 0) {\\n            validExpressions.Add(\"\");\\n            return new List<string>(validExpressions);\\n        }\\n\\n        // Count the number of misplaced parentheses\\n        int misplacedOpen = 0;\\n        int misplacedClose = 0;\\n\\n        foreach (char c in s) {\\n            if (c == \\'(\\') {\\n                misplacedOpen++;\\n            } else if (c == \\')\\') {\\n                if (misplacedOpen > 0) {\\n                    misplacedOpen--;\\n                } else {\\n                    misplacedClose++;\\n                }\\n            }\\n        }\\n\\n        // Recursive helper function to generate valid expressions\\n        GenerateExpressions(s, 0, misplacedOpen, misplacedClose, 0, new List<char>(), validExpressions);\\n\\n        return new List<string>(validExpressions);\\n    }\\n\\n    private void GenerateExpressions(string s, int index, int misplacedOpen, int misplacedClose, int openCount, List<char> expression, HashSet<string> validExpressions) {\\n        // Base case: reached the end of the string\\n        if (index == s.Length) {\\n            if (misplacedOpen == 0 && misplacedClose == 0) {\\n                validExpressions.Add(new string(expression.ToArray()));\\n            }\\n            return;\\n        }\\n\\n        char currentChar = s[index];\\n\\n        // Case 1: Skip the current character\\n        if (currentChar != \\'(\\' && currentChar != \\')\\') {\\n            expression.Add(currentChar);\\n            GenerateExpressions(s, index + 1, misplacedOpen, misplacedClose, openCount, expression, validExpressions);\\n            expression.RemoveAt(expression.Count - 1);\\n        } else {\\n            // Case 2: Remove the current character\\n            if ((currentChar == \\'(\\' && misplacedOpen > 0) || (currentChar == \\')\\' && misplacedClose > 0)) {\\n                GenerateExpressions(s, index + 1, misplacedOpen - (currentChar == \\'(\\' ? 1 : 0), misplacedClose - (currentChar == \\')\\' ? 1 : 0), openCount, expression, validExpressions);\\n            }\\n\\n            // Case 3: Keep the current character\\n            expression.Add(currentChar);\\n\\n            if (currentChar == \\'(\\') {\\n                GenerateExpressions(s, index + 1, misplacedOpen, misplacedClose, openCount + 1, expression, validExpressions);\\n            } else if (openCount > 0) {\\n                GenerateExpressions(s, index + 1, misplacedOpen, misplacedClose, openCount - 1, expression, validExpressions);\\n            }\\n\\n            expression.RemoveAt(expression.Count - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public IList<string> RemoveInvalidParentheses(string s) {\\n        HashSet<string> validExpressions = new HashSet<string>();\\n\\n        // Edge case: empty string\\n        if (s == null || s.Length == 0) {\\n            validExpressions.Add(\"\");\\n            return new List<string>(validExpressions);\\n        }\\n\\n        // Count the number of misplaced parentheses\\n        int misplacedOpen = 0;\\n        int misplacedClose = 0;\\n\\n        foreach (char c in s) {\\n            if (c == \\'(\\') {\\n                misplacedOpen++;\\n            } else if (c == \\')\\') {\\n                if (misplacedOpen > 0) {\\n                    misplacedOpen--;\\n                } else {\\n                    misplacedClose++;\\n                }\\n            }\\n        }\\n\\n        // Recursive helper function to generate valid expressions\\n        GenerateExpressions(s, 0, misplacedOpen, misplacedClose, 0, new List<char>(), validExpressions);\\n\\n        return new List<string>(validExpressions);\\n    }\\n\\n    private void GenerateExpressions(string s, int index, int misplacedOpen, int misplacedClose, int openCount, List<char> expression, HashSet<string> validExpressions) {\\n        // Base case: reached the end of the string\\n        if (index == s.Length) {\\n            if (misplacedOpen == 0 && misplacedClose == 0) {\\n                validExpressions.Add(new string(expression.ToArray()));\\n            }\\n            return;\\n        }\\n\\n        char currentChar = s[index];\\n\\n        // Case 1: Skip the current character\\n        if (currentChar != \\'(\\' && currentChar != \\')\\') {\\n            expression.Add(currentChar);\\n            GenerateExpressions(s, index + 1, misplacedOpen, misplacedClose, openCount, expression, validExpressions);\\n            expression.RemoveAt(expression.Count - 1);\\n        } else {\\n            // Case 2: Remove the current character\\n            if ((currentChar == \\'(\\' && misplacedOpen > 0) || (currentChar == \\')\\' && misplacedClose > 0)) {\\n                GenerateExpressions(s, index + 1, misplacedOpen - (currentChar == \\'(\\' ? 1 : 0), misplacedClose - (currentChar == \\')\\' ? 1 : 0), openCount, expression, validExpressions);\\n            }\\n\\n            // Case 3: Keep the current character\\n            expression.Add(currentChar);\\n\\n            if (currentChar == \\'(\\') {\\n                GenerateExpressions(s, index + 1, misplacedOpen, misplacedClose, openCount + 1, expression, validExpressions);\\n            } else if (openCount > 0) {\\n                GenerateExpressions(s, index + 1, misplacedOpen, misplacedClose, openCount - 1, expression, validExpressions);\\n            }\\n\\n            expression.RemoveAt(expression.Count - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593424,
                "title": "easy-to-understand-stack-dfs-c",
                "content": "\\n\\n# Approach \\nUsing stack \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    unordered_map<string,int> mp;\\n    \\n    int getMinInValid(string s)\\n    {\\n        stack<char> st;\\n        int i = 0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size() > 0 && st.top() == \\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(\\')\\');\\n            }\\n            i++;\\n        }\\n        return st.size();\\n    }\\n    \\n    void solve(string s,int minInv){\\n\\n        if(mp[s] != 0) \\n            return;\\n        else\\n            mp[s]++; //mp[s] = 1\\n        //base case\\n        if(minInv < 0){\\n            return;\\n        }\\n        if(minInv == 0)\\n        {\\n            if(!getMinInValid(s))\\n                res.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            solve(left+right, minInv-1);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        solve(s, getMinInValid(s));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Stack",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    unordered_map<string,int> mp;\\n    \\n    int getMinInValid(string s)\\n    {\\n        stack<char> st;\\n        int i = 0;\\n        while(i < s.size())\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(\\'(\\');\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size() > 0 && st.top() == \\'(\\')\\n                    st.pop();\\n                else\\n                    st.push(\\')\\');\\n            }\\n            i++;\\n        }\\n        return st.size();\\n    }\\n    \\n    void solve(string s,int minInv){\\n\\n        if(mp[s] != 0) \\n            return;\\n        else\\n            mp[s]++; //mp[s] = 1\\n        //base case\\n        if(minInv < 0){\\n            return;\\n        }\\n        if(minInv == 0)\\n        {\\n            if(!getMinInValid(s))\\n                res.push_back(s);\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            string left = s.substr(0,i);\\n            string right = s.substr(i+1);\\n            solve(left+right, minInv-1);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> removeInvalidParentheses(string s) \\n    {\\n        solve(s, getMinInValid(s));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399544,
                "title": "bfs-dfs-c-code",
                "content": "**DFS CODE **\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string , int> mp;\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.size();\\n        int k = find(s);\\n        solve(s , k);\\n        return ans;\\n    }\\n    void solve(string s, int del)\\n    {\\n        if(mp[s]!=0){\\n            return;\\n        }\\n//this is done to avoid repetions \\n        else\\n        {\\n            mp[s]++;\\n        }\\n        if(del<0){\\n            return ;\\n        }\\n        if(del == 0)\\n        {\\n            if(find(s) == 0)\\n                ans.push_back(s);\\n            return;\\n        }\\n        for(int i =0;i<s.size();i++)\\n        {\\n            //deleting the index i \\n            string l = s.substr(0 , i);\\n            string r = s.substr(i+1);\\n            solve(l+r , del-1);\\n        }\\n        return;\\n    }\\n    int find(string s)\\n    {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size() > 0 and st.top() == \\'(\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(\\')\\');\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n\\n\\n```\\n//BFS APPROACH\\n\\nvector<string> removeInvalidParentheses(string s) {\\n        queue<string> q;\\n        q.push(s);\\n        int level = solve(s);\\n        //at level , we need to check each and every string \\n        set<string> st;\\n        int curr_level = 0;\\n        vector<string> ans;\\n        st.insert(s);\\n        if(level == 0){\\n            return {s};\\n        }\\n        while(q.size())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string curr = q.front();\\n                q.pop();\\n                \\n                for(int i = 0;i<curr.size();i++)\\n                {\\n                    string l = curr.substr(0 , i);\\n                    string r = curr.substr(i+1);\\n                    if(st.find(l+r)==st.end())\\n                    {\\n                        string k = l+r;\\n                        if(solve(k) == 0 and curr_level+1 == level)\\n                        {\\n                            ans.push_back(k);\\n                            continue;\\n                        }\\n                        q.push(k);\\n                        st.insert(k);\\n                    }\\n                }\\n                \\n            }\\n            curr_level++;\\n        }\\n        set<string> f;\\n        for(auto it : ans)\\n        {\\n            f.insert(it);\\n        }\\n        vector<string> d;\\n        for(auto it : f)\\n        {\\n            d.push_back(it);\\n        }\\n        return d;\\n    }\\n    int solve(string s)\\n    {\\n        stack<int> st;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size() > 0 and st.top()==\\'(\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(\\')\\');\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string , int> mp;\\n    vector<string> removeInvalidParentheses(string s) {\\n        int n = s.size();\\n        int k = find(s);\\n        solve(s , k);\\n        return ans;\\n    }\\n    void solve(string s, int del)\\n    {\\n        if(mp[s]!=0){\\n            return;\\n        }\\n//this is done to avoid repetions \\n        else\\n        {\\n            mp[s]++;\\n        }\\n        if(del<0){\\n            return ;\\n        }\\n        if(del == 0)\\n        {\\n            if(find(s) == 0)\\n                ans.push_back(s);\\n            return;\\n        }\\n        for(int i =0;i<s.size();i++)\\n        {\\n            //deleting the index i \\n            string l = s.substr(0 , i);\\n            string r = s.substr(i+1);\\n            solve(l+r , del-1);\\n        }\\n        return;\\n    }\\n    int find(string s)\\n    {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size() > 0 and st.top() == \\'(\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(\\')\\');\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```\n```\\n//BFS APPROACH\\n\\nvector<string> removeInvalidParentheses(string s) {\\n        queue<string> q;\\n        q.push(s);\\n        int level = solve(s);\\n        //at level , we need to check each and every string \\n        set<string> st;\\n        int curr_level = 0;\\n        vector<string> ans;\\n        st.insert(s);\\n        if(level == 0){\\n            return {s};\\n        }\\n        while(q.size())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string curr = q.front();\\n                q.pop();\\n                \\n                for(int i = 0;i<curr.size();i++)\\n                {\\n                    string l = curr.substr(0 , i);\\n                    string r = curr.substr(i+1);\\n                    if(st.find(l+r)==st.end())\\n                    {\\n                        string k = l+r;\\n                        if(solve(k) == 0 and curr_level+1 == level)\\n                        {\\n                            ans.push_back(k);\\n                            continue;\\n                        }\\n                        q.push(k);\\n                        st.insert(k);\\n                    }\\n                }\\n                \\n            }\\n            curr_level++;\\n        }\\n        set<string> f;\\n        for(auto it : ans)\\n        {\\n            f.insert(it);\\n        }\\n        vector<string> d;\\n        for(auto it : f)\\n        {\\n            d.push_back(it);\\n        }\\n        return d;\\n    }\\n    int solve(string s)\\n    {\\n        stack<int> st;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size() > 0 and st.top()==\\'(\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(\\')\\');\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361768,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> ans;\\n    void dfs(string& s, string& path, int i, int l_cnt, int r_cnt, int l, int r)\\n    {\\n        if(i == s.length())\\n        {\\n            if(l==0 && r==0) ans.insert(path);\\n            return;\\n        }\\n\\n        //check left side\\n        if(s[i] == \\'(\\' && l>0)\\n            dfs(s, path, i+1, l_cnt, r_cnt, l-1, r);\\n        //check right side\\n        if(s[i] == \\')\\' && r>0)\\n            dfs(s, path, i+1, l_cnt, r_cnt, l, r-1);\\n        \\n        path.push_back(s[i]);\\n        if(s[i] != \\')\\' && s[i] != \\'(\\')\\n            dfs(s, path, i+1, l_cnt, r_cnt, l, r);\\n        else if(s[i] == \\'(\\')\\n            dfs(s, path, i+1, l_cnt+1, r_cnt, l, r);\\n        else if(r_cnt < l_cnt)\\n            dfs(s, path, i+1, l_cnt, r_cnt+1, l, r);\\n\\n        path.pop_back();\\n    }\\n\\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        int n = s.length();\\n        if(n == 0) return {\"\"};\\n        int l = 0, r=0;\\n        //check the l, r how many need to remove\\n        for(int i = 0;i < n; ++i)\\n        {\\n            if(s[i] == \\'(\\') \\n                l++;\\n            else if (s[i] == \\')\\')\\n            {\\n                if(l==0) \\n                    r++;\\n                else \\n                    l--;\\n            }\\n        }\\n\\n        string path = \"\";\\n        //dfs check\\n        dfs(s, path, 0, 0, 0, l, r);\\n\\n        vector<string> res;\\n        for(auto ss : ans)\\n        {\\n            res.push_back(ss);\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> ans;\\n    void dfs(string& s, string& path, int i, int l_cnt, int r_cnt, int l, int r)\\n    {\\n        if(i == s.length())\\n        {\\n            if(l==0 && r==0) ans.insert(path);\\n            return;\\n        }\\n\\n        //check left side\\n        if(s[i] == \\'(\\' && l>0)\\n            dfs(s, path, i+1, l_cnt, r_cnt, l-1, r);\\n        //check right side\\n        if(s[i] == \\')\\' && r>0)\\n            dfs(s, path, i+1, l_cnt, r_cnt, l, r-1);\\n        \\n        path.push_back(s[i]);\\n        if(s[i] != \\')\\' && s[i] != \\'(\\')\\n            dfs(s, path, i+1, l_cnt, r_cnt, l, r);\\n        else if(s[i] == \\'(\\')\\n            dfs(s, path, i+1, l_cnt+1, r_cnt, l, r);\\n        else if(r_cnt < l_cnt)\\n            dfs(s, path, i+1, l_cnt, r_cnt+1, l, r);\\n\\n        path.pop_back();\\n    }\\n\\n    vector<string> removeInvalidParentheses(string s) {\\n        \\n        int n = s.length();\\n        if(n == 0) return {\"\"};\\n        int l = 0, r=0;\\n        //check the l, r how many need to remove\\n        for(int i = 0;i < n; ++i)\\n        {\\n            if(s[i] == \\'(\\') \\n                l++;\\n            else if (s[i] == \\')\\')\\n            {\\n                if(l==0) \\n                    r++;\\n                else \\n                    l--;\\n            }\\n        }\\n\\n        string path = \"\";\\n        //dfs check\\n        dfs(s, path, 0, 0, 0, l, r);\\n\\n        vector<string> res;\\n        for(auto ss : ans)\\n        {\\n            res.push_back(ss);\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566098,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1566009,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1771291,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1573959,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1572213,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1841682,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1574429,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1572805,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 2049861,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 2035051,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1566098,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1566009,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1771291,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1573959,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1572213,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1841682,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1574429,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 1572805,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 2049861,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            },
            {
                "id": 2035051,
                "content": [
                    {
                        "username": "code-junkie",
                        "content": "There are many posts discussion solution to the problem, but I didn\\'t find any good post discussing the time complexity. Only found @jeantimex post and thanks to him for providing answer. \\n\\nSo here is it goes:\\n\\nLet `n` be the number of parentheses in the string. While doing `BFS` we remove one one parantheses character from the given string and keep on doing it till we get a result (even an empty string is also an answer). So, in the worst case we traverse till the end. Therefore,\\n\\n`T(n) = n * C(n, n) + (n - 1) * C(n, n -1) + .... + C(n, 1)`\\n\\nLets break up the terms for better understanding one first level we have `n` characters to remove from `C(n,n)` total number of string, at second level length of strings is `n-1` and there are `C(n,n-1)` such strings, and so on.\\n\\nNow, summation of `T(n) = n*2^(n-1)`. Here, is how it is achieved:\\n\\nWe know binomial theorm,\\n\\n`(1+x)^n = C(n,0) + C(n,1)*x + C(n,2)*x^2 + ... + C(n,n)*x^n`\\n\\nTaking derivative w.r.t `x`\\n\\n`n*(1 + x)^(n-1) = C(n,1) + 2*C(n,2)*x + ... + n*C(n,n)*x^(n-1)`\\n\\nSubstituting `x = 1`,\\n\\n`n*2^(n-1) = C(n,1) + 2*C(n,2) + ... + (n-1)*C(n, n-1) + n*C(n,n)`\\n\\nI hope this helps"
                    },
                    {
                        "username": "_king_",
                        "content": "Thanks for sharing the awesome solutions however, we are preparing from interview perspective and I would like to say at the end, we would like to know the time and space complexity to know if we have foud the better solution and run time in ms is pretty much not a useful info for our preparation."
                    },
                    {
                        "username": "meow_power",
                        "content": "\\nREAD THIS TO FUCK ANY PROBLEM WITH YOUR EYES!!!!!!!\\n\\nHow would you get the intuition that this problem is a graph problem specifically of BFS problem and not a DFS problem? \\n\\nThe important thing to note here is that any graph problem that is given to you it will not be written in a very clear manner that it is a graph problem the thing is you have to deduce this fact.\\n\\nA graph is a collection of nodes and edges, where each node represents a state or an object and each edge represents a relationship or a transition between nodes. In this case, each string is represented as a node and each possible removal of a parenthesis is represented as an edge between nodes.\\n\\nFor example, consider the input string \"(a)b)c)\". The initial state, or the starting node, is the input string itself. By removing one invalid parenthesis at a time, we can generate new strings, or new nodes in the graph, such as \"(a)bc)\", \"(ab)c)\", and \"(abc)\". Each of these strings is a child node of the initial node and is connected to it via an edge, representing the removal of one parenthesis.\\n\\nWe can continue this process for each of the generated strings, creating new nodes and edges until we reach a valid string, which is a string that has no invalid parentheses. Each valid string is an end node in the graph.\\n\\nThe goal of the problem is to find the shortest path from the starting node to one or more end nodes, where the shortest path is defined as the path that requires the minimum number of removals (or the minimum number of edges).\\n\\nBFS is a suitable algorithm for this problem because it guarantees that the first valid string it finds is the one that requires the minimum number of removals. This is because it explores all the nodes at the same depth before moving on to the next depth, so it will explore all the strings that can be generated by removing one parenthesis before it explores strings that can be generated by removing two or more parentheses. This guarantees that the first valid string it finds is the one that requires the minimum number of removals.\\n\\n\"Depth\" in this context refers to the number of removals required to reach a certain string from the initial string. Each string that can be generated by removing one parenthesis from the initial string is at a depth of 1, each string that can be generated by removing two parenthesis from the initial string is at a depth of 2, and so on.\\n\\nWhen BFS explores the graph, it starts with the initial string and generates new strings by removing one parenthesis at a time. It explores all the strings that can be generated by removing one parenthesis before moving on to the next depth, which is strings that can be generated by removing two parenthesis. This is why BFS guarantees that the first valid string it finds is the one that requires the minimum number of removals, because it explores all the nodes at the same depth before moving on to the next depth.\\n\\nAlso, it is important to note that, the depth of a node in a graph is the number of edges between the node and the root node. In this case, the root node is the initial string, and each edge represents a removal of one parenthesis."
                    },
                    {
                        "username": "gauri03",
                        "content": "quite well written! thanks for this tip!"
                    },
                    {
                        "username": "jianminchen",
                        "content": "June 22, 2020\\n**301. Remove Invalid Parentheses**\\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\\n\\n**Introduction**\\n\\nIt is hard level algorithm and most famous one used for algorithm interview. I spent a lot of hours starting from 2017 to work on a few solutions. I think that it is better to work on easy level algorithm first, and then master tree algorithm first, and then work on this hard level algorithm. \\n\\nI am preparing one month for Facebook July 2020 phone screen, so I have to take a few hours to warmup this algorithm. \\n\\n[C# study code and apply TED principle practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360141/C-study-code-and-apply-TED-principle-practice-back-in-2017)\\n[C# BFS algorithm practice in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360163/C-BFS-algorithm-practice-in-2017)\\n[C# BFS practice back in 2017](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360197/C-BFS-practice-back-in-2017)\\n[C# DFS practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/360140/C-DFS-practice-in-2018)\\n[Story first, code follows - practice in 2018](https://leetcode.com/problems/remove-invalid-parentheses/discuss/158584/Story-first-code-follows-practice-in-2018)\\n\\n2020\\nJune 22, 2020\\n[C# BFS warmup practice in 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/701047/C-BFS-warmup-practice-in-2020)\\nJune 23, 2020\\nBFS algorithm - keep minimum steps to make it work first\\n[C# BFS approach without pruning practice in June 2020](https://leetcode.com/problems/remove-invalid-parentheses/discuss/702517/C-BFS-approach-without-pruning-practice-in-June-2020)"
                    },
                    {
                        "username": "GladysWang",
                        "content": "I see a lot of answers solving this question by DFS, but by my first impression, it\\'s much eaiser to do it by BFS.\\n\\nSo it there any advantages/dsiadvantages between DFS and BFS?\\n\\nThank you guys for any comments.\\n"
                    },
                    {
                        "username": "rukt",
                        "content": "test case 127 is broken, when i click copy testcase it literally says s = Enter Testcase. its a blank testcase. please help. \\n\\nclass Solution:\\n    def removeInvalidParentheses(self, s: str) -> List[str]:\\n        def helper(s):\\n            res = 0\\n            for i in s:\\n                if i == \\'(\\': res += 1\\n                elif i == \\')\\': res -= 1\\n                if res < 0: return False\\n            return res == 0\\n\\n        q, newq = [s], []\\n        done = False\\n        if not s: return [s]\\n        if helper(s): return [s]\\n        while not done:\\n            newq = []\\n            for curr in q:\\n                for i in range(len(curr)):\\n                    news = curr[:i] + curr[i+1:]\\n                    if news not in newq:\\n                        newq.append(news)\\n                    if helper(news):\\n                        done = True\\n            # print(newq)\\n            q = newq.copy()\\n        return [i for i in newq if helper(i)]"
                    },
                    {
                        "username": "ShivamJJ",
                        "content": "Code Link:-   https://github.com/shivammaheshwari9837/DS-and-Algorithms/blob/master/Queue/Remove%20invalid%20parentheses.cpp"
                    },
                    {
                        "username": "pdksock",
                        "content": "Not sure what is wrong here. Need help.\\n![image](https://assets.leetcode.com/users/pdksock/image_1561926976.png)\\n"
                    },
                    {
                        "username": "mrinal2193",
                        "content": "don\\'t return an empty vector. just add a condition there that if the vector is empty push_back an empty string into it. Like let\\'s say your answer vector in named res the res.push_back(\"\");\\nand then return it. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A HashSet that checks your current permutation against all other previously calculated and added permutations, is very useful here. I went from TLE to beat 94% with 4-5 lines of extra code."
                    },
                    {
                        "username": "sansshobhit",
                        "content": "https://leetcode.com/problems/remove-invalid-parentheses/submissions/1034712474/\\n\\nMy submission is giving TLE on input \\ns =\\n\"((((((((((((((((((((aaaaa\"\\nBut if I use this input as a testcase then it is working fine. It only goes off when I submit. Can someone help me."
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "mine is giving MLE on it"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flood Fill",
        "question_content": "<p>An image is represented by an <code>m x n</code> integer grid <code>image</code> where <code>image[i][j]</code> represents the pixel value of the image.</p>\n\n<p>You are also given three integers <code>sr</code>, <code>sc</code>, and <code>color</code>. You should perform a <strong>flood fill</strong> on the image starting from the pixel <code>image[sr][sc]</code>.</p>\n\n<p>To perform a <strong>flood fill</strong>, consider the starting pixel, plus any pixels connected <strong>4-directionally</strong> to the starting pixel of the same color as the starting pixel, plus any pixels connected <strong>4-directionally</strong> to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with <code>color</code>.</p>\n\n<p>Return <em>the modified image after performing the flood fill</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg\" style=\"width: 613px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n<strong>Output:</strong> [[2,2,2],[2,2,0],[2,0,1]]\n<strong>Explanation:</strong> From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n<strong>Output:</strong> [[0,0,0],[0,0,0]]\n<strong>Explanation:</strong> The starting pixel is already colored 0, so no changes are made to the image.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == image.length</code></li>\n\t<li><code>n == image[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= image[i][j], color &lt; 2<sup>16</sup></code></li>\n\t<li><code>0 &lt;= sr &lt; m</code></li>\n\t<li><code>0 &lt;= sc &lt; n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1590584,
                "title": "c-simple-dfs-97-6-faster-91-6-better-memory-use",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& image, int i, int j,int val, int newColor)\\n    {\\n        if(i<0 || i>=image.size() || j<0 || j>= image[0].size() || image[i][j] == newColor || image[i][j] != val)\\n        {\\n            return;\\n        }\\n        image[i][j] = newColor;\\n        dfs(image,i-1,j,val,newColor);\\n        dfs(image,i+1,j,val,newColor);\\n        dfs(image,i,j-1,val,newColor);\\n        dfs(image,i,j+1,val,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor)\\n    {\\n        int val = image[sr][sc];\\n        dfs(image,sr,sc,val,newColor);\\n        return image;\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL TO YOU THEN  PLEASE UPVOTE!!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& image, int i, int j,int val, int newColor)\\n    {\\n        if(i<0 || i>=image.size() || j<0 || j>= image[0].size() || image[i][j] == newColor || image[i][j] != val)\\n        {\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 109584,
                "title": "java-9-liner-dfs",
                "content": "Time complexity: O(m*n), space complexity: O(1). m is number of rows, n is number of columns.\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image;\\n        fill(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    private void fill(int[][] image, int sr, int sc, int color, int newColor) {\\n        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != color) return;\\n        image[sr][sc] = newColor;\\n        fill(image, sr + 1, sc, color, newColor);\\n        fill(image, sr - 1, sc, color, newColor);\\n        fill(image, sr, sc + 1, color, newColor);\\n        fill(image, sr, sc - 1, color, newColor);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image;\\n        fill(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    private void fill(int[][] image, int sr, int sc, int color, int newColor) {\\n        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != color) return;\\n        image[sr][sc] = newColor;\\n        fill(image, sr + 1, sc, color, newColor);\\n        fill(image, sr - 1, sc, color, newColor);\\n        fill(image, sr, sc + 1, color, newColor);\\n        fill(image, sr, sc - 1, color, newColor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109604,
                "title": "easy-python-dfs-no-need-for-visited",
                "content": "The idea is simple. Simply perform a DFS on the source cell. Continue the DFS if:\\n\\n1. Next cell is within bounds.\\n2. Next cell is the same color as source cell.\\n\\nThere is a tricky case where the new color is the same as the original color and if the DFS is done on it, there will be an infinite loop. If new color is same as original color, there is nothing to be done and we can simply return the `image`.\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        rows, cols, orig_color = len(image), len(image[0]), image[sr][sc]\\n        def traverse(row, col):\\n            if (not (0 <= row < rows and 0 <= col < cols)) or image[row][col] != orig_color:\\n                return\\n            image[row][col] = newColor\\n            [traverse(row + x, col + y) for (x, y) in ((0, 1), (1, 0), (0, -1), (-1, 0))]\\n        if orig_color != newColor:\\n            traverse(sr, sc)\\n        return image\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        rows, cols, orig_color = len(image), len(image[0]), image[sr][sc]\\n        def traverse(row, col):\\n            if (not (0 <= row < rows and 0 <= col < cols)) or image[row][col] != orig_color:\\n                return\\n            image[row][col] = newColor\\n            [traverse(row + x, col + y) for (x, y) in ((0, 1), (1, 0), (0, -1), (-1, 0))]\\n        if orig_color != newColor:\\n            traverse(sr, sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442143,
                "title": "how-do-you-think-about-solving-a-question-using-dfs-learn-before-you-code",
                "content": "There are three things that you need to consider once you have identified that a question can be sovled using DFS\\n\\n1. The base case ( return condition )\\n2. Mark that node as visited \\n2. Given that I am at a particular node what operations do I need to perform \\n\\n\\nThe below solution explains how the above methodology can be used to sovle any DFS solution \\n\\n1. The base case : \\n\\nThe current node cannot \\na ) Exit the matrix bounding condition\\nb ) DIfferent from the base color\\nc ) Be a node that we have already visited\\n\\n```\\n        if(sc < 0 || sc >= cl || sr < 0 || sr >= rl || image[sr][sc] != baseColor || visited[sr][sc]) {\\n            return;\\n        }\\n```\\n\\n2. Mark the node as visited ( I have used another matrix to do it. There are different ways to do it\\n```\\n        visited[sr][sc] = true;\\n```\\n\\n3. The operation that I need to perform at every node is to check tell all the nodes that are adjucent to me to check their if they are the same color as I am and if yes change their color ( Now the recursion - > every node needs to do what I am doing ) \\n\\n```\\n        image[sr][sc] = newColor;\\n        dfs(image, sr + 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr, sc + 1, newColor, baseColor, visited);\\n        dfs(image, sr - 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr , sc - 1, newColor, baseColor, visited);\\n```\\n\\n\\nComplete solution\\n\\n```\\n    public static int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        boolean[][] visited =  new boolean[image.length][image[0].length];\\n        dfs(image, sr, sc, newColor, image[sr][sc], visited);\\n        return image;\\n    }\\n\\n    public static void dfs(int[][] image, int sr, int sc, int newColor, int baseColor, boolean[][] visited) {\\n        int rl = image.length;\\n        int cl = image[0].length;\\n        \\n        // This is the base condition of return. \\n        if(sc < 0 || sc >= cl || sr < 0 || sr >= rl || image[sr][sc] != baseColor || visited[sr][sc]) {\\n            return;\\n        }\\n        \\n        // Mark the node as visited. \\n        visited[sr][sc] = true;\\n        \\n        // At every node what am I supposed to do ? This is the operation these are the operations.\\n        image[sr][sc] = newColor;\\n        dfs(image, sr + 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr, sc + 1, newColor, baseColor, visited);\\n        dfs(image, sr - 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr , sc - 1, newColor, baseColor, visited);\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        if(sc < 0 || sc >= cl || sr < 0 || sr >= rl || image[sr][sc] != baseColor || visited[sr][sc]) {\\n            return;\\n        }\\n```\n```\\n        visited[sr][sc] = true;\\n```\n```\\n        image[sr][sc] = newColor;\\n        dfs(image, sr + 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr, sc + 1, newColor, baseColor, visited);\\n        dfs(image, sr - 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr , sc - 1, newColor, baseColor, visited);\\n```\n```\\n    public static int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        boolean[][] visited =  new boolean[image.length][image[0].length];\\n        dfs(image, sr, sc, newColor, image[sr][sc], visited);\\n        return image;\\n    }\\n\\n    public static void dfs(int[][] image, int sr, int sc, int newColor, int baseColor, boolean[][] visited) {\\n        int rl = image.length;\\n        int cl = image[0].length;\\n        \\n        // This is the base condition of return. \\n        if(sc < 0 || sc >= cl || sr < 0 || sr >= rl || image[sr][sc] != baseColor || visited[sr][sc]) {\\n            return;\\n        }\\n        \\n        // Mark the node as visited. \\n        visited[sr][sc] = true;\\n        \\n        // At every node what am I supposed to do ? This is the operation these are the operations.\\n        image[sr][sc] = newColor;\\n        dfs(image, sr + 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr, sc + 1, newColor, baseColor, visited);\\n        dfs(image, sr - 1, sc, newColor, baseColor, visited);\\n        dfs(image, sr , sc - 1, newColor, baseColor, visited);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473494,
                "title": "java-dfs-bfs-solutions-space-complexity-analysis-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DFS (with helper function)**\\n```java\\nclass Solution {\\n    int[] DIRS = {0, 1, 0, -1, 0};\\n    int m, n;\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image; // same color -> no need to replace\\n        m = image.length; n = image[0].length;\\n        dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\n    void dfs(int[][] image, int r, int c, int oldColor, int newColor) {\\n        if (r < 0 || r == m || c < 0 || c == n || image[r][c] != oldColor) return;\\n        image[r][c] = newColor; // also mean we marked it as visited!\\n        for (int i = 0; i < 4; i++)\\n            dfs(image, r + DIRS[i], c + DIRS[i+1], oldColor, newColor);\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 50` is number of rows, `N <= 50` is number of columns in the matrix.\\n- Space: `O(M * N)`, it\\'s the depth stack memory, in worst case is `O(M * N)`, can check this discussion: https://stackoverflow.com/a/50912382/4084297\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS (Directly in input function)**\\n```java\\nclass Solution {\\n    int[] DIR = new int[]{0, 1, 0, -1, 0};\\n    public int[][] floodFill(int[][] image, int r, int c, int newColor) {\\n        if (image[r][c] == newColor) return image; // same color -> no need to replace\\n        \\n        int m = image.length, n = image[0].length;\\n        int oldColor = image[r][c];\\n        image[r][c] = newColor; // set new color\\n        for (int i = 0; i < 4; i++) {\\n            int nr = r + DIR[i], nc = c + DIR[i+1];\\n            if (nr < 0 || nr == m || nc < 0 || nc == n || image[nr][nc] != oldColor) continue;\\n            floodFill(image, nr, nc, newColor);\\n        }\\n        return image;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 50` is number of rows, `N <= 50` is number of columns in the matrix.\\n- Space: `O(M * N)`, it\\'s the depth stack memory, in worst case is `O(M * N)`, can check this discussion: https://stackoverflow.com/a/50912382/4084297\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: BFS**\\n```java\\nclass Solution {\\n    int[] DIRS = {0, 1, 0, -1, 0};\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image; // same color -> no need to replace\\n\\n        int m = image.length, n = image[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{sr, sc});\\n        int oldColor = image[sr][sc];\\n        image[sr][sc] = newColor;\\n        while (!q.isEmpty()) {\\n            int[] top = q.poll();\\n            for (int i = 0; i < 4; i++) {\\n                int nr = top[0] + DIRS[i];\\n                int nc = top[1] + DIRS[i + 1];\\n                if (nr < 0 || nr == m || nc < 0 || nc == n || image[nr][nc] != oldColor) continue;\\n                image[nr][nc] = newColor; // also mean we marked it as visited!\\n                q.offer(new int[]{nr, nc});\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 50` is number of rows, `N <= 50` is number of columns in the matrix.\\n- Space: `O(M * N)`, the space used by the queue in bfs, in worst case is `O(M * N)`, can check this discussion: https://stackoverflow.com/a/50912382/4084297",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int[] DIRS = {0, 1, 0, -1, 0};\\n    int m, n;\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image; // same color -> no need to replace\\n        m = image.length; n = image[0].length;\\n        dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\n    void dfs(int[][] image, int r, int c, int oldColor, int newColor) {\\n        if (r < 0 || r == m || c < 0 || c == n || image[r][c] != oldColor) return;\\n        image[r][c] = newColor; // also mean we marked it as visited!\\n        for (int i = 0; i < 4; i++)\\n            dfs(image, r + DIRS[i], c + DIRS[i+1], oldColor, newColor);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int[] DIR = new int[]{0, 1, 0, -1, 0};\\n    public int[][] floodFill(int[][] image, int r, int c, int newColor) {\\n        if (image[r][c] == newColor) return image; // same color -> no need to replace\\n        \\n        int m = image.length, n = image[0].length;\\n        int oldColor = image[r][c];\\n        image[r][c] = newColor; // set new color\\n        for (int i = 0; i < 4; i++) {\\n            int nr = r + DIR[i], nc = c + DIR[i+1];\\n            if (nr < 0 || nr == m || nc < 0 || nc == n || image[nr][nc] != oldColor) continue;\\n            floodFill(image, nr, nc, newColor);\\n        }\\n        return image;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int[] DIRS = {0, 1, 0, -1, 0};\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image; // same color -> no need to replace\\n\\n        int m = image.length, n = image[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{sr, sc});\\n        int oldColor = image[sr][sc];\\n        image[sr][sc] = newColor;\\n        while (!q.isEmpty()) {\\n            int[] top = q.poll();\\n            for (int i = 0; i < 4; i++) {\\n                int nr = top[0] + DIRS[i];\\n                int nc = top[1] + DIRS[i + 1];\\n                if (nr < 0 || nr == m || nc < 0 || nc == n || image[nr][nc] != oldColor) continue;\\n                image[nr][nc] = newColor; // also mean we marked it as visited!\\n                q.offer(new int[]{nr, nc});\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187701,
                "title": "python-nice-clean-dfs-bfs-solutions",
                "content": "* BFS\\n```\\nclass Solution:\\n    def floodFill(self, image, sr, sc, newColor):\\n        old, m, n = image[sr][sc], len(image), len(image[0])\\n        if old != newColor: \\n            q = collections.deque([(sr, sc)])\\n            while q:\\n                i, j = q.popleft()\\n                image[i][j] = newColor\\n                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                    if 0 <= x < m and 0 <= y < n and image[x][y] == old: \\n                        q.append((x, y))\\n        return image\\n```\\n* DFS\\n```\\nclass Solution:\\n    def floodFill(self, image, sr, sc, newColor):\\n        def dfs(i, j):\\n            image[i][j] = newColor\\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if 0 <= x < m and 0 <= y < n and image[x][y] == old:\\n                    dfs(x, y)\\n        old, m, n = image[sr][sc], len(image), len(image[0])\\n        if old != newColor: \\n            dfs(sr, sc)\\n        return image\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image, sr, sc, newColor):\\n        old, m, n = image[sr][sc], len(image), len(image[0])\\n        if old != newColor: \\n            q = collections.deque([(sr, sc)])\\n            while q:\\n                i, j = q.popleft()\\n                image[i][j] = newColor\\n                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                    if 0 <= x < m and 0 <= y < n and image[x][y] == old: \\n                        q.append((x, y))\\n        return image\\n```\n```\\nclass Solution:\\n    def floodFill(self, image, sr, sc, newColor):\\n        def dfs(i, j):\\n            image[i][j] = newColor\\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if 0 <= x < m and 0 <= y < n and image[x][y] == old:\\n                    dfs(x, y)\\n        old, m, n = image[sr][sc], len(image), len(image[0])\\n        if old != newColor: \\n            dfs(sr, sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513930,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-python3-dfs-recursion",
                "content": "**Problem Statement:**\\n\\nAn image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\\n\\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\\n\\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\\n\\nReturn the modified image after performing the flood fill.\\n    \\n    \\n\\n# **Java Solution:**\\n```\\n// Runtime: 1 ms, faster than 90.98% of Java online submissions for Flood Fill.\\n// Time Complexity : O(n*m)\\n// Space Complexity : O(n*m)\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        // Avoid infinite loop if the new and old colors are the same...\\n        if(image[sr][sc] == color) return image;\\n        // Run the fill function starting at the position given...\\n        fill(image, sr, sc, color, image[sr][sc]);\\n        return image;\\n    }\\n    public void fill(int[][] image, int sr, int sc, int color, int cur) {\\n        // If sr is less than 0 or greater equals to the length of image...\\n        // Or, If sc is less than 0 or greater equals to the length of image[0]...\\n        if(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) return;\\n        // If image[sr][sc] is not equal to previous color...\\n        if(cur != image[sr][sc]) return;\\n        // Update the image[sr][sc] as a color...\\n        image[sr][sc] = color;\\n        // Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n        fill(image, sr-1, sc, color, cur);\\n        fill(image, sr+1, sc, color, cur);\\n        fill(image, sr, sc-1, color, cur);\\n        fill(image, sr, sc+1, color, cur);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Time Complexity : O(n*m)\\n// Space Complexity : O(n*m)\\nclass Solution {\\npublic:\\n    void fill(vector<vector<int>>& image, int sr, int sc, int color, int cur) {\\n        // If sr is less than 0 or greater equals to the length of image...\\n        // Or, If sc is less than 0 or greater equals to the length of image[0]...\\n        if(sr < 0 || sr >= image.size() || sc < 0 || sc >= image[0].size()) return;\\n        // If image[sr][sc] is not equal to previous color...\\n        if(cur != image[sr][sc]) return;\\n        // Update the image[sr][sc] as a color...\\n        image[sr][sc] = color;\\n        // Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n        fill(image, sr-1, sc, color, cur);\\n        fill(image, sr+1, sc, color, cur);\\n        fill(image, sr, sc-1, color, cur);\\n        fill(image, sr, sc+1, color, cur);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        // Avoid infinite loop if the new and old colors are the same...\\n        if(image[sr][sc] == color) return image;\\n        // Run the fill function starting at the position given...\\n        fill(image, sr, sc, color, image[sr][sc]);\\n        return image;\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\n# Time Complexity : O(n*m)\\n# Space Complexity : O(n*m)\\nclass Solution(object):\\n    def fill(self, image, sr, sc, color, cur):\\n        # If sr is less than 0 or greater equals to the length of image...\\n        # Or, If sc is less than 0 or greater equals to the length of image[0]...\\n        if sr < 0 or sr >= len(image) or sc < 0 or sc >= len(image[0]): return;\\n        # If image[sr][sc] is not equal to previous color...\\n        if cur != image[sr][sc]: return;\\n        # Update the image[sr][sc] as a color...\\n        image[sr][sc] = color;\\n        # Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n        self.fill(image, sr-1, sc, color, cur);\\n        self.fill(image, sr+1, sc, color, cur);\\n        self.fill(image, sr, sc-1, color, cur);\\n        self.fill(image, sr, sc+1, color, cur);\\n    def floodFill(self, image, sr, sc, color):\\n        # Avoid infinite loop if the new and old colors are the same...\\n        if image[sr][sc] == color: return image;\\n        # Run the fill function starting at the position given...\\n        self.fill(image, sr, sc, color, image[sr][sc]);\\n        return image;\\n```\\n\\n# **JavaScript  Solution:**\\n```\\n// Time Complexity : O(n*m)\\n// Space Complexity : O(n*m)\\nvar floodFill = function(image, sr, sc, color) {\\n    // Avoid infinite loop if the new and old colors are the same...\\n    if(image[sr][sc] == color) return image;\\n    // Run the fill function starting at the position given...\\n    fill(image, sr, sc, color, image[sr][sc]);\\n    return image;\\n}\\nvar fill = function(image, sr, sc, color, cur) {\\n    // If sr is less than 0 or greater equals to the length of image...\\n    // Or, If sc is less than 0 or greater equals to the length of image[0]...\\n    if(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) return;\\n    // If image[sr][sc] is not equal to previous color...\\n    if(cur != image[sr][sc]) return;\\n    // Update the image[sr][sc] as a color...\\n    image[sr][sc] = color;\\n    // Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n    fill(image, sr-1, sc, color, cur);\\n    fill(image, sr+1, sc, color, cur);\\n    fill(image, sr, sc-1, color, cur);\\n    fill(image, sr, sc+1, color, cur);\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 1 ms, faster than 90.98% of Java online submissions for Flood Fill.\\n// Time Complexity : O(n*m)\\n// Space Complexity : O(n*m)\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        // Avoid infinite loop if the new and old colors are the same...\\n        if(image[sr][sc] == color) return image;\\n        // Run the fill function starting at the position given...\\n        fill(image, sr, sc, color, image[sr][sc]);\\n        return image;\\n    }\\n    public void fill(int[][] image, int sr, int sc, int color, int cur) {\\n        // If sr is less than 0 or greater equals to the length of image...\\n        // Or, If sc is less than 0 or greater equals to the length of image[0]...\\n        if(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) return;\\n        // If image[sr][sc] is not equal to previous color...\\n        if(cur != image[sr][sc]) return;\\n        // Update the image[sr][sc] as a color...\\n        image[sr][sc] = color;\\n        // Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n        fill(image, sr-1, sc, color, cur);\\n        fill(image, sr+1, sc, color, cur);\\n        fill(image, sr, sc-1, color, cur);\\n        fill(image, sr, sc+1, color, cur);\\n    }\\n}\\n```\n```\\n// Time Complexity : O(n*m)\\n// Space Complexity : O(n*m)\\nclass Solution {\\npublic:\\n    void fill(vector<vector<int>>& image, int sr, int sc, int color, int cur) {\\n        // If sr is less than 0 or greater equals to the length of image...\\n        // Or, If sc is less than 0 or greater equals to the length of image[0]...\\n        if(sr < 0 || sr >= image.size() || sc < 0 || sc >= image[0].size()) return;\\n        // If image[sr][sc] is not equal to previous color...\\n        if(cur != image[sr][sc]) return;\\n        // Update the image[sr][sc] as a color...\\n        image[sr][sc] = color;\\n        // Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n        fill(image, sr-1, sc, color, cur);\\n        fill(image, sr+1, sc, color, cur);\\n        fill(image, sr, sc-1, color, cur);\\n        fill(image, sr, sc+1, color, cur);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        // Avoid infinite loop if the new and old colors are the same...\\n        if(image[sr][sc] == color) return image;\\n        // Run the fill function starting at the position given...\\n        fill(image, sr, sc, color, image[sr][sc]);\\n        return image;\\n    }\\n};\\n```\n```\\n# Time Complexity : O(n*m)\\n# Space Complexity : O(n*m)\\nclass Solution(object):\\n    def fill(self, image, sr, sc, color, cur):\\n        # If sr is less than 0 or greater equals to the length of image...\\n        # Or, If sc is less than 0 or greater equals to the length of image[0]...\\n        if sr < 0 or sr >= len(image) or sc < 0 or sc >= len(image[0]): return;\\n        # If image[sr][sc] is not equal to previous color...\\n        if cur != image[sr][sc]: return;\\n        # Update the image[sr][sc] as a color...\\n        image[sr][sc] = color;\\n        # Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n        self.fill(image, sr-1, sc, color, cur);\\n        self.fill(image, sr+1, sc, color, cur);\\n        self.fill(image, sr, sc-1, color, cur);\\n        self.fill(image, sr, sc+1, color, cur);\\n    def floodFill(self, image, sr, sc, color):\\n        # Avoid infinite loop if the new and old colors are the same...\\n        if image[sr][sc] == color: return image;\\n        # Run the fill function starting at the position given...\\n        self.fill(image, sr, sc, color, image[sr][sc]);\\n        return image;\\n```\n```\\n// Time Complexity : O(n*m)\\n// Space Complexity : O(n*m)\\nvar floodFill = function(image, sr, sc, color) {\\n    // Avoid infinite loop if the new and old colors are the same...\\n    if(image[sr][sc] == color) return image;\\n    // Run the fill function starting at the position given...\\n    fill(image, sr, sc, color, image[sr][sc]);\\n    return image;\\n}\\nvar fill = function(image, sr, sc, color, cur) {\\n    // If sr is less than 0 or greater equals to the length of image...\\n    // Or, If sc is less than 0 or greater equals to the length of image[0]...\\n    if(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) return;\\n    // If image[sr][sc] is not equal to previous color...\\n    if(cur != image[sr][sc]) return;\\n    // Update the image[sr][sc] as a color...\\n    image[sr][sc] = color;\\n    // Make four recursive calls to the function with (sr-1, sc), (sr+1, sc), (sr, sc-1) and (sr, sc+1)...\\n    fill(image, sr-1, sc, color, cur);\\n    fill(image, sr+1, sc, color, cur);\\n    fill(image, sr, sc-1, color, cur);\\n    fill(image, sr, sc+1, color, cur);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626282,
                "title": "python-dfs-along-with-thinking-process-diagrams",
                "content": "We are going to start from the cell at `sr` and `sc` and **radiate** the newColor with depth first search (DFS).\\nVisually speaking, it would look like this:\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1589193648.png)\\n\\nWe are going to radiate with our DFS in four directions (up, down, left and right) until we hit the following scenarios:\\n* The indices are beyond the image grid indcies (indicated by blue arrows protruding beyond the image grid)\\n* The new cell is of different color (indicated by red crosses in the image)\\n* The new cell is of same color (the arrow pointing downwards for the the topmost picture) \\n\\n``` python\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        rows = len(image)\\n        cols = len(image[0])\\n        color_to_change = image[sr][sc]\\n        \\n        def dfs(r, c):\\n            nonlocal rows, cols, newColor, image\\n            \\n            if r < 0 or c < 0 or r>rows-1 or c>cols-1 or image[r][c]==newColor or image[r][c]!=color_to_change:\\n                return\\n            \\n            image[r][c] = newColor\\n            \\n\\t\\t\\t# radiate in four directions\\n            dfs(r+1,c)\\n            dfs(r-1,c)\\n            dfs(r,c+1)\\n            dfs(r,c-1)\\n        \\n        dfs(sr, sc)\\n        \\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "``` python\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        rows = len(image)\\n        cols = len(image[0])\\n        color_to_change = image[sr][sc]\\n        \\n        def dfs(r, c):\\n            nonlocal rows, cols, newColor, image\\n            \\n            if r < 0 or c < 0 or r>rows-1 or c>cols-1 or image[r][c]==newColor or image[r][c]!=color_to_change:\\n                return\\n            \\n            image[r][c] = newColor\\n            \\n\\t\\t\\t# radiate in four directions\\n            dfs(r+1,c)\\n            dfs(r-1,c)\\n            dfs(r,c+1)\\n            dfs(r,c-1)\\n        \\n        dfs(sr, sc)\\n        \\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233498,
                "title": "concise-dfs-javascript",
                "content": "```\\nconst floodFill = (image, sr, sc, newColor, firstColor = image[sr][sc]) => {\\n    // handle if the coordinate is out of bounds\\n\\t// or if it is already the new color\\n\\t// or if it\\'s not from the original color we\\'re trying to change\\n    if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[sr].length || image[sr][sc] !== firstColor || image[sr][sc] === newColor)   {\\n        return image; // return image as-is\\n    }\\n    \\n    image[sr][sc] = newColor;\\n    \\n    floodFill(image, sr + 1, sc, newColor, firstColor);\\n    floodFill(image, sr - 1, sc, newColor, firstColor);\\n    floodFill(image, sr, sc + 1, newColor, firstColor);\\n    floodFill(image, sr, sc - 1, newColor, firstColor);\\n    \\n\\t// return modified image\\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst floodFill = (image, sr, sc, newColor, firstColor = image[sr][sc]) => {\\n    // handle if the coordinate is out of bounds\\n\\t// or if it is already the new color\\n\\t// or if it\\'s not from the original color we\\'re trying to change\\n    if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[sr].length || image[sr][sc] !== firstColor || image[sr][sc] === newColor)   {\\n        return image; // return image as-is\\n    }\\n    \\n    image[sr][sc] = newColor;\\n    \\n    floodFill(image, sr + 1, sc, newColor, firstColor);\\n    floodFill(image, sr - 1, sc, newColor, firstColor);\\n    floodFill(image, sr, sc + 1, newColor, firstColor);\\n    floodFill(image, sr, sc - 1, newColor, firstColor);\\n    \\n\\t// return modified image\\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2707985,
                "title": "python-flood-fill-algorithm-98-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        \\n        start_color = image[sr][sc]\\n        \\n        def flood_fill(x, y):\\n            if x < 0 or x >= len(image): return\\n            if y < 0 or y >= len(image[0]): return\\n            \\n            if image[x][y] == color: return\\n            if image[x][y] != start_color: return\\n            \\n            image[x][y] = color\\n            \\n            flood_fill(x-1, y)\\n            flood_fill(x+1, y)\\n            flood_fill(x, y+1)\\n            flood_fill(x, y-1)\\n        \\n        flood_fill(sr, sc)\\n        return image\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        \\n        start_color = image[sr][sc]\\n        \\n        def flood_fill(x, y):\\n            if x < 0 or x >= len(image): return\\n            if y < 0 or y >= len(image[0]): return\\n            \\n            if image[x][y] == color: return\\n            if image[x][y] != start_color: return\\n            \\n            image[x][y] = color\\n            \\n            flood_fill(x-1, y)\\n            flood_fill(x+1, y)\\n            flood_fill(x, y+1)\\n            flood_fill(x, y-1)\\n        \\n        flood_fill(sr, sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627915,
                "title": "c-standard-solution-schema-you-can-apply-to-other-tasks-list-visited",
                "content": "There are many solutions with recursion. Many of them are optimized to the task, but let\\'s use this simple problem to study a standard solution without a recursion.\\nYou will be able to use it for many other matrix-related tasks and not only matrix.\\n\\nThis simple algorithm can be easily extended:\\n* `togo` list, safe and clean\\n* `seen` matrix to avoid loops\\n* `dirs` to loop over all possible directions\\n* process `togo` till it\\'s empty and add elements to that queue as you find them\\n\\nIf that desription was too fast, then here is a longer version:\\n* keep places to go in a queue, `togo`, e.g. `vector<T> togo`. I will explain what is `T` later.\\n* keep track of visited places in a matrix of the same size as original: `vector<vector<int>> seen`. You can call it `visited`, but usually it leads to more typos. This helps to never go to the same place twice\\n* keep the queue safe and clean, then the queue will be shorter and will never have duplicates; also you will not waste time on adding elems to the queue if they are not valid saving time and memory\\n* walk through the queue (list) and add elements to be checked \\nIt\\'s like hunting for mushrooms: you take one, see several others at the same time and add them to your \"togo\" list. Keep gooing till you get all of them.\\n\\nTips:\\n* always use \"rows\"/\"r\" and \"cols\"/\"c\", not \"x\" and \"y\", because rows and cols fit for 2D array nicely (`matrix[r][c]`), while `x` and `y` are opposite (you\\'ll need `matrix[y][x]` which will blow your mind.\\n* `togo` can be easily adjusted for various tasks, e.g. it can keep `int` for 1D array and `vector<int>` for 2D array. It can keep some extra variables for other tasks, like a cost of a path\\n* use `dirs` for all possible directions. No matter what the tasks says, you can easily adjust it: move only down and right or all 4 directions or all 8 - you\\'ll easily extend it\\n* `togo` can be easily converted to a priority queue, e.g. when you will need to find the shortest path\\n* always set `seen` immediately after you checked it to avoid bugs\\n\\nDrawbacks of a simple recursion:\\n* requires memory on stack\\n* complicated or no control over the order of places to be checked (compare to priority queue)\\n* hard to stop when the solution is already found\\n\\nStandard schema:\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int rows=image.size(), cols=image[0].size(), oldColor=image[sr][sc];\\n        list<vector<int>> togo; togo.push_back({sr,sc});\\n        int seen[51][51] = {{0}};\\n        int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        while(togo.size()) {\\n            int r=togo.front()[0], c=togo.front()[1]; togo.pop_front();\\n            image[r][c]=newColor;\\n            for(auto& d:dirs) {\\n                int rr=r+d[0], cc=c+d[1];\\n                if(rr<0 || rr>=rows ||cc<0 ||cc>=cols) continue; // keep togo safe\\n                if(image[rr][cc]!=oldColor) continue;            // keep togo clean\\n                if(seen[rr][cc]) continue;\\n                seen[rr][cc]=1;\\n                togo.push_back({rr,cc});\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nIn this task we know that the `newColor` should not be \"repainted\" so we can use the matrix itself instead of \"seen\". \\n12 ms, beats 98%\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int rows=image.size(), cols=image[0].size(), oldColor=image[sr][sc];\\n        if(newColor==oldColor) return image;\\n        list<vector<int>> togo; togo.push_back({sr,sc});\\n        int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        while(togo.size()) {\\n            int r=togo.front()[0], c=togo.front()[1]; togo.pop_front();\\n            image[r][c]=newColor;\\n            for(auto& d:dirs) {\\n                int rr=r+d[0], cc=c+d[1];\\n                if(rr<0 || rr>=rows ||cc<0 ||cc>=cols) continue; // keep togo safe\\n                if(image[rr][cc]!=oldColor) continue;            // keep togo clean\\n                togo.push_back({rr,cc});\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int rows=image.size(), cols=image[0].size(), oldColor=image[sr][sc];\\n        list<vector<int>> togo; togo.push_back({sr,sc});\\n        int seen[51][51] = {{0}};\\n        int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        while(togo.size()) {\\n            int r=togo.front()[0], c=togo.front()[1]; togo.pop_front();\\n            image[r][c]=newColor;\\n            for(auto& d:dirs) {\\n                int rr=r+d[0], cc=c+d[1];\\n                if(rr<0 || rr>=rows ||cc<0 ||cc>=cols) continue; // keep togo safe\\n                if(image[rr][cc]!=oldColor) continue;            // keep togo clean\\n                if(seen[rr][cc]) continue;\\n                seen[rr][cc]=1;\\n                togo.push_back({rr,cc});\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int rows=image.size(), cols=image[0].size(), oldColor=image[sr][sc];\\n        if(newColor==oldColor) return image;\\n        list<vector<int>> togo; togo.push_back({sr,sc});\\n        int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n        while(togo.size()) {\\n            int r=togo.front()[0], c=togo.front()[1]; togo.pop_front();\\n            image[r][c]=newColor;\\n            for(auto& d:dirs) {\\n                int rr=r+d[0], cc=c+d[1];\\n                if(rr<0 || rr>=rows ||cc<0 ||cc>=cols) continue; // keep togo safe\\n                if(image[rr][cc]!=oldColor) continue;            // keep togo clean\\n                togo.push_back({rr,cc});\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109613,
                "title": "java-c-clean-code",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\n    private void dfs(int[][] image, int i, int j, int c0, int c1) {\\n        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != c0) return;\\n        image[i][j] = c1;\\n        dfs(image, i, j - 1, c0, c1);\\n        dfs(image, i, j + 1, c0, c1);\\n        dfs(image, i - 1, j, c0, c1);\\n        dfs(image, i + 1, j, c0, c1);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>>& image, int i, int j, int c0, int c1) {\\n        if (i < 0 || j < 0 || i >= image.size() || j >= image[0].size() || image[i][j] != c0) return;\\n        image[i][j] = c1;\\n        dfs(image, i, j - 1, c0, c1);\\n        dfs(image, i, j + 1, c0, c1);\\n        dfs(image, i - 1, j, c0, c1);\\n        dfs(image, i + 1, j, c0, c1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\n    private void dfs(int[][] image, int i, int j, int c0, int c1) {\\n        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != c0) return;\\n        image[i][j] = c1;\\n        dfs(image, i, j - 1, c0, c1);\\n        dfs(image, i, j + 1, c0, c1);\\n        dfs(image, i - 1, j, c0, c1);\\n        dfs(image, i + 1, j, c0, c1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>>& image, int i, int j, int c0, int c1) {\\n        if (i < 0 || j < 0 || i >= image.size() || j >= image[0].size() || image[i][j] != c0) return;\\n        image[i][j] = c1;\\n        dfs(image, i, j - 1, c0, c1);\\n        dfs(image, i, j + 1, c0, c1);\\n        dfs(image, i - 1, j, c0, c1);\\n        dfs(image, i + 1, j, c0, c1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626540,
                "title": "javascript-2-intuitive-solutions-using-dfs-and-bfs",
                "content": "## Solutions 1 - DFS\\n```javascript\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const currColor = image[sr][sc];\\n    if(newColor === currColor) return image;\\n    \\n    function callDFS(img, row, col) {\\n        if(row >= img.length || row < 0 || col >= img[0].length || col < 0 || img[row][col] !== currColor) return;\\n        img[row][col] = newColor;\\n\\t\\tcallDFS(img, row-1, col);  //up\\n        callDFS(img, row+1, col);  //down\\n        callDFS(img, row, col+1);  //right \\n        callDFS(img, row, col-1);  //left\\n        return img;\\n    }\\n    return callDFS(image, sr, sc);\\n};\\n```\\n##  Solutions 2 - BFS\\n```javascript\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const currColor = image[sr][sc];\\n    if(currColor === newColor) return image;\\n    const queue = [[sr, sc]];\\n    \\n    while(queue.length) {\\n        const [row, col] = queue.shift();\\n        if(image[row][col] === currColor) {\\n            image[row][col] = newColor\\n\\t\\t\\tif(row-1 >= 0) queue.push([row-1, col]);  //up\\n            if(row+1 < image.length) queue.push([row+1, col]);  //down\\n            if(col+1 < image[0].length) queue.push([row, col+1]);  //right\\n            if(col-1 >= 0) queue.push([row, col-1]);  //left\\n        }\\n    }\\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const currColor = image[sr][sc];\\n    if(newColor === currColor) return image;\\n    \\n    function callDFS(img, row, col) {\\n        if(row >= img.length || row < 0 || col >= img[0].length || col < 0 || img[row][col] !== currColor) return;\\n        img[row][col] = newColor;\\n\\t\\tcallDFS(img, row-1, col);  //up\\n        callDFS(img, row+1, col);  //down\\n        callDFS(img, row, col+1);  //right \\n        callDFS(img, row, col-1);  //left\\n        return img;\\n    }\\n    return callDFS(image, sr, sc);\\n};\\n```\n```javascript\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const currColor = image[sr][sc];\\n    if(currColor === newColor) return image;\\n    const queue = [[sr, sc]];\\n    \\n    while(queue.length) {\\n        const [row, col] = queue.shift();\\n        if(image[row][col] === currColor) {\\n            image[row][col] = newColor\\n\\t\\t\\tif(row-1 >= 0) queue.push([row-1, col]);  //up\\n            if(row+1 < image.length) queue.push([row+1, col]);  //down\\n            if(col+1 < image[0].length) queue.push([row, col+1]);  //right\\n            if(col-1 >= 0) queue.push([row, col-1]);  //left\\n        }\\n    }\\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626424,
                "title": "python-js-go-c-sol-by-dfs-w-comment",
                "content": "Python/JS/Go/C++ sol by DFS and BFS\\n\\n---\\n\\n**Implementation** by DFS:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        \\n        h, w = len(image), len(image[0])\\n        \\n\\t\\t\\n        def dfs( r, c, src_color):\\n            \\n            if r < 0 or c < 0 or r >= h or c >= w or image[r][c] == newColor or image[r][c] != src_color:\\n                # Reject for invalid coordination, repeated traversal, or different color\\n                return\\n            \\n            # update color\\n            image[r][c] = newColor\\n            \\n            \\n            # DFS to 4-connected neighbors\\n            dfs( r-1, c, src_color )\\n            dfs( r+1, c, src_color )\\n            dfs( r, c-1, src_color )\\n            dfs( r, c+1, src_color )\\n            \\n        # ---------------------------------------------------------------------------\\n        \\n        dfs(sr, sc, src_color = image[sr][sc] )\\n        \\n        return image\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    \\n    let [h, w] = [image.length, image[0].length];\\n    \\n    let dfs = function(r, c, srcColor){\\n        \\n        if( (r < 0 ) || ( r >=  h ) || ( c < 0) || ( c >= w) \\n                     || ( image[r][c] == newColor )          \\n                     || ( image[r][c] != srcColor )            ){\\n        \\n            // Reject for invalid coordination, repeated traversal, or different color      \\n            return;\\n                         \\n        }\\n        \\n        \\n        // update color\\n        image[r][c] = newColor;\\n        \\n        \\n        // DFS to 4-connected neighbors\\n        dfs( r-1, c, srcColor );\\n        dfs( r+1, c, srcColor );\\n        dfs( r, c-1, srcColor );\\n        dfs( r, c+1, srcColor );\\n        \\n        return;\\n    }\\n    \\n    dfs(sr, sc, image[sr][sc] );\\n    \\n    return image;\\n    \\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    \\n    h := len(image)\\n    w := len(image[0])\\n    \\n    var dfs func( int, int, int)\\n    \\n    dfs = func( r, c, srcColor int){\\n\\n        if( (r < 0 ) || ( r >=  h ) || ( c < 0) || ( c >= w) || \\n                     ( image[r][c] == newColor )             ||\\n                     ( image[r][c] != srcColor )            ){\\n\\n            // Reject for invalid coordination, repeated traversal, or different color      \\n            return;\\n        }\\n\\n\\n        // update color\\n        image[r][c] = newColor;\\n\\n\\n        // DFS to 4-connected neighbors\\n        dfs( r-1, c, srcColor );\\n        dfs( r+1, c, srcColor );\\n        dfs( r, c-1, srcColor );\\n        dfs( r, c+1, srcColor );\\n\\n        return;\\n    }\\n    \\n    // =====================\\n    \\n    dfs(sr, sc, image[sr][sc] );\\n    return image\\n}\\n```\\n\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        const int h = image.size(), w = image[0].size();\\n        \\n        std::function<void(int, int, int)> dfs;\\n        \\n        dfs = [&](int r, int c, int srcColor) -> void{\\n          \\n            if( (r < 0 ) || ( r >=  h ) || ( c < 0) || ( c >= w) \\n                         || ( image[r][c] == newColor )          \\n                         || ( image[r][c] != srcColor )            ){\\n\\n                // Reject for invalid coordination, repeated traversal, or different color      \\n                return;\\n            }\\n\\n\\n            // update color\\n            image[r][c] = newColor;\\n\\n\\n            // DFS to 4-connected neighbors\\n            dfs( r-1, c, srcColor );\\n            dfs( r+1, c, srcColor );\\n            dfs( r, c-1, srcColor );\\n            dfs( r, c+1, srcColor );\\n\\n            return;\\n        };\\n        // ==================================\\n        \\n        dfs( sr, sc, image[sr][sc] );\\n        \\n        return image;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by BFS:\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        \\n        h, w = len(image), len(image[0])\\n        \\n        src_color = image[sr][sc]\\n        \\n        traversal_queue = deque( [(sr, sc)] )\\n        \\n        while traversal_queue:\\n            \\n            cur_r, cur_c = traversal_queue.popleft()\\n            \\n            if cur_r < 0 or cur_r >= h or cur_c < 0 or cur_c >= w or image[cur_r][cur_c] == newColor  or image[cur_r][cur_c] != src_color:\\n                continue\\n            \\n            # update color\\n            image[cur_r][cur_c] = newColor\\n            \\n            \\n            # BFS to 4-connected neighbors\\n            traversal_queue.append( (cur_r-1, cur_c) )\\n            traversal_queue.append( (cur_r+1, cur_c) )\\n            traversal_queue.append( (cur_r, cur_c-1) )\\n            traversal_queue.append( (cur_r, cur_c+1) )\\n        \\n        return image\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        \\n        h, w = len(image), len(image[0])\\n        \\n\\t\\t\\n        def dfs( r, c, src_color):\\n            \\n            if r < 0 or c < 0 or r >= h or c >= w or image[r][c] == newColor or image[r][c] != src_color:\\n                # Reject for invalid coordination, repeated traversal, or different color\\n                return\\n            \\n            # update color\\n            image[r][c] = newColor\\n            \\n            \\n            # DFS to 4-connected neighbors\\n            dfs( r-1, c, src_color )\\n            dfs( r+1, c, src_color )\\n            dfs( r, c-1, src_color )\\n            dfs( r, c+1, src_color )\\n            \\n        # ---------------------------------------------------------------------------\\n        \\n        dfs(sr, sc, src_color = image[sr][sc] )\\n        \\n        return image\\n```\n```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    \\n    let [h, w] = [image.length, image[0].length];\\n    \\n    let dfs = function(r, c, srcColor){\\n        \\n        if( (r < 0 ) || ( r >=  h ) || ( c < 0) || ( c >= w) \\n                     || ( image[r][c] == newColor )          \\n                     || ( image[r][c] != srcColor )            ){\\n        \\n            // Reject for invalid coordination, repeated traversal, or different color      \\n            return;\\n                         \\n        }\\n        \\n        \\n        // update color\\n        image[r][c] = newColor;\\n        \\n        \\n        // DFS to 4-connected neighbors\\n        dfs( r-1, c, srcColor );\\n        dfs( r+1, c, srcColor );\\n        dfs( r, c-1, srcColor );\\n        dfs( r, c+1, srcColor );\\n        \\n        return;\\n    }\\n    \\n    dfs(sr, sc, image[sr][sc] );\\n    \\n    return image;\\n    \\n    \\n};\\n```\n```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    \\n    h := len(image)\\n    w := len(image[0])\\n    \\n    var dfs func( int, int, int)\\n    \\n    dfs = func( r, c, srcColor int){\\n\\n        if( (r < 0 ) || ( r >=  h ) || ( c < 0) || ( c >= w) || \\n                     ( image[r][c] == newColor )             ||\\n                     ( image[r][c] != srcColor )            ){\\n\\n            // Reject for invalid coordination, repeated traversal, or different color      \\n            return;\\n        }\\n\\n\\n        // update color\\n        image[r][c] = newColor;\\n\\n\\n        // DFS to 4-connected neighbors\\n        dfs( r-1, c, srcColor );\\n        dfs( r+1, c, srcColor );\\n        dfs( r, c-1, srcColor );\\n        dfs( r, c+1, srcColor );\\n\\n        return;\\n    }\\n    \\n    // =====================\\n    \\n    dfs(sr, sc, image[sr][sc] );\\n    return image\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        const int h = image.size(), w = image[0].size();\\n        \\n        std::function<void(int, int, int)> dfs;\\n        \\n        dfs = [&](int r, int c, int srcColor) -> void{\\n          \\n            if( (r < 0 ) || ( r >=  h ) || ( c < 0) || ( c >= w) \\n                         || ( image[r][c] == newColor )          \\n                         || ( image[r][c] != srcColor )            ){\\n\\n                // Reject for invalid coordination, repeated traversal, or different color      \\n                return;\\n            }\\n\\n\\n            // update color\\n            image[r][c] = newColor;\\n\\n\\n            // DFS to 4-connected neighbors\\n            dfs( r-1, c, srcColor );\\n            dfs( r+1, c, srcColor );\\n            dfs( r, c-1, srcColor );\\n            dfs( r, c+1, srcColor );\\n\\n            return;\\n        };\\n        // ==================================\\n        \\n        dfs( sr, sc, image[sr][sc] );\\n        \\n        return image;\\n        \\n    }\\n};\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        \\n        h, w = len(image), len(image[0])\\n        \\n        src_color = image[sr][sc]\\n        \\n        traversal_queue = deque( [(sr, sc)] )\\n        \\n        while traversal_queue:\\n            \\n            cur_r, cur_c = traversal_queue.popleft()\\n            \\n            if cur_r < 0 or cur_r >= h or cur_c < 0 or cur_c >= w or image[cur_r][cur_c] == newColor  or image[cur_r][cur_c] != src_color:\\n                continue\\n            \\n            # update color\\n            image[cur_r][cur_c] = newColor\\n            \\n            \\n            # BFS to 4-connected neighbors\\n            traversal_queue.append( (cur_r-1, cur_c) )\\n            traversal_queue.append( (cur_r+1, cur_c) )\\n            traversal_queue.append( (cur_r, cur_c-1) )\\n            traversal_queue.append( (cur_r, cur_c+1) )\\n        \\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851473,
                "title": "java-dfs-beats-100-and-bfs-beats-84-86",
                "content": "***Please upvote if it helps, it\\u2018s important for me.***\\n\\n**1\\u3001BFS using queue.**\\n```\\nWe can solve this problem without using queue \"visited\", because \"target\" must != \"newColor\\u201D.\\nThe annotation is the version of adding \"visited\".\\n```\\n\\n```\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int target = image[sr][sc];image[sr][sc] = newColor;\\n        if(target == newColor){\\n            return image;\\n        }\\n\\n        final int[][] directions = {{1,0},{0,1},{-1,0},{0,-1}};\\n        Queue<int[]> queue = new LinkedList<>();\\n//        Queue<int[]> visited = new LinkedList<>();\\n        queue.add(new int[]{sr,sc});\\n\\n        while(!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n//            visited.add(cur);\\n            for(int[] dir : directions){\\n                int row = cur[0] + dir[1];\\n                int col = cur[1] + dir[0];\\n//                if(isVaild(row,col,image,target) && !visited.contains(new int[]{row,col})){\\n                if(isVaild(row,col,image,target)){// target must != newColor,so if isVaild(row,col,image,target) is false, means this point is visited.\\n                    image[row][col] = newColor;\\n                    queue.add(new int[]{row,col});\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n\\n    private boolean isVaild(int row,int col,int[][] image,int target){\\n        if(row >= image.length || row < 0 || col >= image[0].length || col < 0 || image[row][col] != target){\\n            return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n**2\\u3001DFS using  recursion is faster than BFS**\\n```\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int target = image[sr][sc];\\n        if(target == newColor){\\n            return image;\\n        }\\n        dfs(sr,sc,target,newColor,image);\\n        return image;\\n    }\\n    private void dfs(int row,int col,int target,int newColor,int[][] image){\\n        if(row < image.length && row >= 0 && col < image[0].length && col >= 0 && image[row][col] == target) {\\n            image[row][col] = newColor;\\n            dfs(row - 1, col, target, newColor, image);\\n            dfs(row, col - 1, target, newColor, image);\\n            dfs(row + 1, col, target, newColor, image);\\n            dfs(row, col + 1, target, newColor, image);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nWe can solve this problem without using queue \"visited\", because \"target\" must != \"newColor\\u201D.\\nThe annotation is the version of adding \"visited\".\\n```\n```\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int target = image[sr][sc];image[sr][sc] = newColor;\\n        if(target == newColor){\\n            return image;\\n        }\\n\\n        final int[][] directions = {{1,0},{0,1},{-1,0},{0,-1}};\\n        Queue<int[]> queue = new LinkedList<>();\\n//        Queue<int[]> visited = new LinkedList<>();\\n        queue.add(new int[]{sr,sc});\\n\\n        while(!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n//            visited.add(cur);\\n            for(int[] dir : directions){\\n                int row = cur[0] + dir[1];\\n                int col = cur[1] + dir[0];\\n//                if(isVaild(row,col,image,target) && !visited.contains(new int[]{row,col})){\\n                if(isVaild(row,col,image,target)){// target must != newColor,so if isVaild(row,col,image,target) is false, means this point is visited.\\n                    image[row][col] = newColor;\\n                    queue.add(new int[]{row,col});\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n\\n    private boolean isVaild(int row,int col,int[][] image,int target){\\n        if(row >= image.length || row < 0 || col >= image[0].length || col < 0 || image[row][col] != target){\\n            return false;\\n        }\\n        return true;\\n    }\\n```\n```\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int target = image[sr][sc];\\n        if(target == newColor){\\n            return image;\\n        }\\n        dfs(sr,sc,target,newColor,image);\\n        return image;\\n    }\\n    private void dfs(int row,int col,int target,int newColor,int[][] image){\\n        if(row < image.length && row >= 0 && col < image[0].length && col >= 0 && image[row][col] == target) {\\n            image[row][col] = newColor;\\n            dfs(row - 1, col, target, newColor, image);\\n            dfs(row, col - 1, target, newColor, image);\\n            dfs(row + 1, col, target, newColor, image);\\n            dfs(row, col + 1, target, newColor, image);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109586,
                "title": "9-lines-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int m = image.size(), n = image[0].size();\\n        DFS(image, sr, sc, m, n, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    void DFS(vector<vector<int>>& image, int r, int c, int m, int n, int target, int newColor){\\n        if(r < 0 || c < 0 || r == m || c == n || image[r][c] == newColor || image[r][c] != target) return;\\n        image[r][c] = newColor;\\n        DFS(image, r + 1, c, m, n, target, newColor);\\n        DFS(image, r - 1, c, m, n, target, newColor);\\n        DFS(image, r, c + 1, m, n, target, newColor);\\n        DFS(image, r, c - 1, m, n, target, newColor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int m = image.size(), n = image[0].size();\\n        DFS(image, sr, sc, m, n, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    void DFS(vector<vector<int>>& image, int r, int c, int m, int n, int target, int newColor){\\n        if(r < 0 || c < 0 || r == m || c == n || image[r][c] == newColor || image[r][c] != target) return;\\n        image[r][c] = newColor;\\n        DFS(image, r + 1, c, m, n, target, newColor);\\n        DFS(image, r - 1, c, m, n, target, newColor);\\n        DFS(image, r, c + 1, m, n, target, newColor);\\n        DFS(image, r, c - 1, m, n, target, newColor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188583,
                "title": "simple-recursive-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a recursive approach to traverse through the image, starting from the given pixel. We set the start color of the given pixel as the initial color to be replaced. Then we check whether the current pixel has the same color as the start color and also whether it has not already been replaced with the new color. If both the conditions are true, we change the color of the current pixel to the new color and recursively call the function to its 4-directional neighbors(up,left,down,right). We repeat this process until we have traversed all the pixels with the start color.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe function visits every pixel in the image exactly once, hence the time complexity of the function is $$O(m*n)$$, where m is the number of rows and n is the number of columns in the image.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the function is $$O(m*n)$$ due to the recursive calls on the function stack.\\n# Code\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        # Set the initial color to be replaced\\n        start_color = image[sr][sc]\\n        \\n        # Get the number of rows and columns in the image\\n        rows,cols = len(image),len(image[0])\\n        \\n        # Recursive function to perform flood fill\\n        def backtrack(i,j,grid):\\n            # Base case: return if the index is out of bounds\\n            if i<0 or i>=rows or j<0 or j>=cols:\\n                return \\n        # Base case: return if the current pixel is not the start color or already changed to the new color\\n            if start_color != grid[i][j] or grid[i][j]==color:\\n                return\\n            # Set the color of the current pixel to the new color\\n            grid[i][j] = color\\n            # Recursively perform flood fill on the 4-directional neighbors of the current pixel\\n            backtrack(i-1,j,grid) # up\\n            backtrack(i,j-1,grid) # left\\n            backtrack(i+1,j,grid) # down\\n            backtrack(i,j+1,grid) # right\\n        \\n        # Call the backtrack function with the starting pixel and return the modified image\\n        backtrack(sr,sc,image)\\n        return image\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        # Set the initial color to be replaced\\n        start_color = image[sr][sc]\\n        \\n        # Get the number of rows and columns in the image\\n        rows,cols = len(image),len(image[0])\\n        \\n        # Recursive function to perform flood fill\\n        def backtrack(i,j,grid):\\n            # Base case: return if the index is out of bounds\\n            if i<0 or i>=rows or j<0 or j>=cols:\\n                return \\n        # Base case: return if the current pixel is not the start color or already changed to the new color\\n            if start_color != grid[i][j] or grid[i][j]==color:\\n                return\\n            # Set the color of the current pixel to the new color\\n            grid[i][j] = color\\n            # Recursively perform flood fill on the 4-directional neighbors of the current pixel\\n            backtrack(i-1,j,grid) # up\\n            backtrack(i,j-1,grid) # left\\n            backtrack(i+1,j,grid) # down\\n            backtrack(i,j+1,grid) # right\\n        \\n        # Call the backtrack function with the starting pixel and return the modified image\\n        backtrack(sr,sc,image)\\n        return image\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323847,
                "title": "solution-swift-flood-fill-test-cases",
                "content": "```swift\\nclass Solution {\\n    func floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n        var img = image\\n        dfs(&img, sr, sc, img[sr][sc], newColor)\\n        return img\\n    }\\n    private func dfs(_ image: inout [[Int]], _ sr: Int, _ sc: Int, _ pix: Int, _ newColor: Int) {\\n        if (sr < 0 || sr >= image.count) { return }\\n        if (sc < 0 || sc >= image[0].count) { return }\\n        let pixOld = image[sr][sc]\\n        if pixOld == newColor || pixOld != pix { return }\\n        image[sr][sc] = newColor\\n        for p in [(0,1),(0,-1),(1,0),(-1,0)] {\\n            dfs(&image, (sr + p.0), (sc + p.1), pix, newColor)\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel),\\n    // all pixels connected by a path of the same color as the starting pixel\\n    // (i.e., the blue pixels) are colored with the new color.\\n    // Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\\n    func test0() {\\n        let value = solution.floodFill([[1,1,1],\\n                                        [1,1,0],\\n                                        [1,0,1]], 1, 1, 2)\\n        \\n        XCTAssertEqual(value, [[2,2,2],\\n                               [2,2,0],\\n                               [2,0,1]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.floodFill([[0,0,0],\\n                                        [0,0,0]], 0, 0, 2)\\n        \\n        XCTAssertEqual(value, [[2,2,2],\\n                               [2,2,2]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n        var img = image\\n        dfs(&img, sr, sc, img[sr][sc], newColor)\\n        return img\\n    }\\n    private func dfs(_ image: inout [[Int]], _ sr: Int, _ sc: Int, _ pix: Int, _ newColor: Int) {\\n        if (sr < 0 || sr >= image.count) { return }\\n        if (sc < 0 || sc >= image[0].count) { return }\\n        let pixOld = image[sr][sc]\\n        if pixOld == newColor || pixOld != pix { return }\\n        image[sr][sc] = newColor\\n        for p in [(0,1),(0,-1),(1,0),(-1,0)] {\\n            dfs(&image, (sr + p.0), (sc + p.1), pix, newColor)\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel),\\n    // all pixels connected by a path of the same color as the starting pixel\\n    // (i.e., the blue pixels) are colored with the new color.\\n    // Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\\n    func test0() {\\n        let value = solution.floodFill([[1,1,1],\\n                                        [1,1,0],\\n                                        [1,0,1]], 1, 1, 2)\\n        \\n        XCTAssertEqual(value, [[2,2,2],\\n                               [2,2,0],\\n                               [2,0,1]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.floodFill([[0,0,0],\\n                                        [0,0,0]], 0, 0, 2)\\n        \\n        XCTAssertEqual(value, [[2,2,2],\\n                               [2,2,2]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791198,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\n    private void dfs(int[][] image, int i, int j, int c0, int c1) {\\n        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != c0) return;\\n        image[i][j] = c1;\\n        dfs(image, i, j - 1, c0, c1);\\n        dfs(image, i, j + 1, c0, c1);\\n        dfs(image, i - 1, j, c0, c1);\\n        dfs(image, i + 1, j, c0, c1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            dfs(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n\\n    private void dfs(int[][] image, int i, int j, int c0, int c1) {\\n        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != c0) return;\\n        image[i][j] = c1;\\n        dfs(image, i, j - 1, c0, c1);\\n        dfs(image, i, j + 1, c0, c1);\\n        dfs(image, i - 1, j, c0, c1);\\n        dfs(image, i + 1, j, c0, c1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544231,
                "title": "python-bfs-simplest-solution",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        m = len(image)\\n        n = len(image[0])\\n        \\n        visited = [[None for _ in range(n)] for _ in range(m)]\\n        initialColor = image[sr][sc]\\n        queue = [(sr,sc)]\\n        \\n        while queue:\\n            sr, sc = queue.pop(0)\\n            visited[sr][sc] = True\\n            image[sr][sc] = newColor\\n            for dsr, dsc in [(sr+1, sc), (sr-1, sc), (sr, sc+1), (sr, sc-1)]:\\n                if 0 <= dsr < m and 0 <= dsc < n and not visited[dsr][dsc] and image[dsr][dsc] == initialColor:\\n                    queue.append((dsr, dsc))\\n        return image\\n            \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        m = len(image)\\n        n = len(image[0])\\n        \\n        visited = [[None for _ in range(n)] for _ in range(m)]\\n        initialColor = image[sr][sc]\\n        queue = [(sr,sc)]\\n        \\n        while queue:\\n            sr, sc = queue.pop(0)\\n            visited[sr][sc] = True\\n            image[sr][sc] = newColor\\n            for dsr, dsc in [(sr+1, sc), (sr-1, sc), (sr, sc+1), (sr, sc-1)]:\\n                if 0 <= dsr < m and 0 <= dsc < n and not visited[dsr][dsc] and image[dsr][dsc] == initialColor:\\n                    queue.append((dsr, dsc))\\n        return image\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 819539,
                "title": "swift-3-solutions-with-dfs-recursive-and-iterative-bfs-100",
                "content": "**DFS in recursive style**\\n*Time: O(n), Space: O(n) where n is the size of \"image\"*\\n```\\nfunc floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n\\tlet color = image[sr][sc]\\n\\tif color == newColor { return image }\\n\\t\\n\\tvar result = image\\n\\tdfs(&result, sr, sc, color, newColor)\\n\\t\\n\\treturn result\\n}\\n\\nfunc dfs(_ image: inout [[Int]], _ row: Int, _ col: Int, _ oldColor: Int, _ newColor: Int) {\\n\\tif row < 0 || row >= image.count || col < 0 || col >= image[0].count { return }\\n\\tif image[row][col] != oldColor { return } \\n\\n\\timage[row][col] = newColor\\n\\n\\tdfs(&image, row - 1, col, oldColor, newColor)\\n\\tdfs(&image, row + 1, col, oldColor, newColor)\\n\\tdfs(&image, row, col - 1, oldColor, newColor)\\n\\tdfs(&image, row, col + 1, oldColor, newColor)\\n}\\n```\\n\\n**DFS in iterative style with a stack**\\n*Time: O(n), Space: O(n) where n is the size of \"image\"*\\n```\\nfunc floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n\\tlet oldColor = image[sr][sc]\\n\\tif oldColor == newColor { return image }\\n\\n\\tlet height = image.count\\n\\tlet width = image[0].count\\n\\tvar result = image\\n\\tvar stack = [(Int, Int)]()\\n\\tstack.append((sr, sc))\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet (row, col) = stack.popLast()!\\n\\t\\tif row < 0 || row >= height || col < 0 || col >= width { continue }\\n\\t\\tif result[row][col] != oldColor { continue } \\n\\n\\t\\tresult[row][col] = newColor\\n\\n\\t\\tstack.append((row - 1, col))\\n\\t\\tstack.append((row + 1, col))\\n\\t\\tstack.append((row, col - 1))\\n\\t\\tstack.append((row, col + 1))\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\n**BFS**\\n*Time: O(n), Space: O(n) where n is the size of \"image\"*\\n```\\nfunc floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n\\tlet oldColor = image[sr][sc]\\n\\tif oldColor == newColor { return image }\\n\\n\\tlet height = image.count\\n\\tlet width = image[0].count\\n\\tvar result = image\\n\\tvar queue = [(Int, Int)]()\\n\\tvar queueIndex = 0 // head of \"queue\"\\n\\tvar queueCount = 1 // count of \"queue\"\\n\\tqueue.append((sr, sc))\\n\\n\\twhile queueIndex < queueCount {\\n\\t\\tlet (row, col) = queue[queueIndex]\\n\\t\\tqueueIndex += 1\\n\\n\\t\\tif row < 0 || row >= height || col < 0 || col >= width { continue }\\n\\t\\tif result[row][col] != oldColor { continue } \\n\\n\\t\\tresult[row][col] = newColor\\n\\n\\t\\tqueue.append((row - 1, col))\\n\\t\\tqueue.append((row + 1, col))\\n\\t\\tqueue.append((row, col - 1))\\n\\t\\tqueue.append((row, col + 1))\\n\\t\\tqueueCount += 4 \\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n\\tlet color = image[sr][sc]\\n\\tif color == newColor { return image }\\n\\t\\n\\tvar result = image\\n\\tdfs(&result, sr, sc, color, newColor)\\n\\t\\n\\treturn result\\n}\\n\\nfunc dfs(_ image: inout [[Int]], _ row: Int, _ col: Int, _ oldColor: Int, _ newColor: Int) {\\n\\tif row < 0 || row >= image.count || col < 0 || col >= image[0].count { return }\\n\\tif image[row][col] != oldColor { return } \\n\\n\\timage[row][col] = newColor\\n\\n\\tdfs(&image, row - 1, col, oldColor, newColor)\\n\\tdfs(&image, row + 1, col, oldColor, newColor)\\n\\tdfs(&image, row, col - 1, oldColor, newColor)\\n\\tdfs(&image, row, col + 1, oldColor, newColor)\\n}\\n```\n```\\nfunc floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n\\tlet oldColor = image[sr][sc]\\n\\tif oldColor == newColor { return image }\\n\\n\\tlet height = image.count\\n\\tlet width = image[0].count\\n\\tvar result = image\\n\\tvar stack = [(Int, Int)]()\\n\\tstack.append((sr, sc))\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet (row, col) = stack.popLast()!\\n\\t\\tif row < 0 || row >= height || col < 0 || col >= width { continue }\\n\\t\\tif result[row][col] != oldColor { continue } \\n\\n\\t\\tresult[row][col] = newColor\\n\\n\\t\\tstack.append((row - 1, col))\\n\\t\\tstack.append((row + 1, col))\\n\\t\\tstack.append((row, col - 1))\\n\\t\\tstack.append((row, col + 1))\\n\\t}\\n\\n\\treturn result\\n}\\n```\n```\\nfunc floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\\n\\tlet oldColor = image[sr][sc]\\n\\tif oldColor == newColor { return image }\\n\\n\\tlet height = image.count\\n\\tlet width = image[0].count\\n\\tvar result = image\\n\\tvar queue = [(Int, Int)]()\\n\\tvar queueIndex = 0 // head of \"queue\"\\n\\tvar queueCount = 1 // count of \"queue\"\\n\\tqueue.append((sr, sc))\\n\\n\\twhile queueIndex < queueCount {\\n\\t\\tlet (row, col) = queue[queueIndex]\\n\\t\\tqueueIndex += 1\\n\\n\\t\\tif row < 0 || row >= height || col < 0 || col >= width { continue }\\n\\t\\tif result[row][col] != oldColor { continue } \\n\\n\\t\\tresult[row][col] = newColor\\n\\n\\t\\tqueue.append((row - 1, col))\\n\\t\\tqueue.append((row + 1, col))\\n\\t\\tqueue.append((row, col - 1))\\n\\t\\tqueue.append((row, col + 1))\\n\\t\\tqueueCount += 4 \\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 522907,
                "title": "javascript-solution-95",
                "content": "```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    fill(image, sr, sc, image[sr][sc], newColor);\\n    return image;\\n};\\n\\nvar fill = (image, x, y, oldColor, newColor) => {\\n    if (x < 0 || y < 0 || x >= image.length || y >= image[x].length ||\\n       image[x][y] === newColor || image[x][y] !== oldColor) {\\n        return;\\n    }\\n    image[x][y] = newColor;\\n    fill(image, x + 1, y, oldColor, newColor);\\n    fill(image, x, y + 1, oldColor, newColor);\\n    fill(image, x - 1, y, oldColor, newColor);\\n    fill(image, x, y - 1, oldColor, newColor);\\n}\\n```\\n\\nRuntime: 68 ms, faster than 95.64% of JavaScript online submissions for Flood Fill.\\nMemory Usage: 36.2 MB, less than 100.00% of JavaScript online submissions for Flood Fill.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    fill(image, sr, sc, image[sr][sc], newColor);\\n    return image;\\n};\\n\\nvar fill = (image, x, y, oldColor, newColor) => {\\n    if (x < 0 || y < 0 || x >= image.length || y >= image[x].length ||\\n       image[x][y] === newColor || image[x][y] !== oldColor) {\\n        return;\\n    }\\n    image[x][y] = newColor;\\n    fill(image, x + 1, y, oldColor, newColor);\\n    fill(image, x, y + 1, oldColor, newColor);\\n    fill(image, x - 1, y, oldColor, newColor);\\n    fill(image, x, y - 1, oldColor, newColor);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1883431,
                "title": "c-dfs-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(vector<vector<int>>& image,int sr,int sc,int newColor,int x)\\n\\t\\t{\\n\\t\\t\\tif(sr<0 or sr>=image.size() or sc<0 or sc>=image[0].size() or image[sr][sc]!=x or image[sr][sc]==newColor)return;\\n\\n\\t\\t\\timage[sr][sc]=newColor;\\n\\t\\t\\tdfs(image,sr-1,sc,newColor,x);\\n\\t\\t\\t dfs(image,sr,sc+1,newColor,x);\\n\\t\\t\\t dfs(image,sr+1,sc,newColor,x);\\n\\t\\t\\t dfs(image,sr,sc-1,newColor,x);\\n\\t\\t}\\n\\t\\tvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n\\t\\tint x=image[sr][sc];\\n\\t\\tdfs(image,sr,sc,newColor,x);\\n\\t\\treturn image;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(vector<vector<int>>& image,int sr,int sc,int newColor,int x)\\n\\t\\t{\\n\\t\\t\\tif(sr<0 or sr>=image.size() or sc<0 or sc>=image[0].size() or image[sr][sc]!=x or image[sr][sc]==newColor)return;\\n\\n\\t\\t\\timage[sr][sc]=newColor;\\n\\t\\t\\tdfs(image,sr-1,sc,newColor,x);\\n\\t\\t\\t dfs(image,sr,sc+1,newColor,x);\\n\\t\\t\\t dfs(image,sr+1,sc,newColor,x);\\n\\t\\t\\t dfs(image,sr,sc-1,newColor,x);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3476692,
                "title": "java-100-faster-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Note : After reading the intuition must read the example provided to understand the solution because words provided may be confusing.**\\nWe will be given a index of an matrix and what we need to do is just traverse in all direction from that particular given index and change all the image[i][j] color to the given target color having the color same as the original color of the given index.\\n\\nExample 1: Given image with color\\n```\\n[3,3,1,3,1,2]\\n[3,2,1,1,1,2]\\n[1,3,2,1,2,1]\\n[1,1,1,2,2,1]\\n```\\nso the given index is (2,3) and color is 4\\nthen index image[2][3] we have color 1 then we will traverse in all the four direction and change the color to 4 whose default color is 1.\\nWe will only traverse in top, bottom, right and left directions.\\nAfter the recursive traverse we got matrix as :\\n```\\n[3,3,4,3,4,2]\\n[3,2,4,4,4,2]\\n[1,3,2,4,2,1]\\n[1,1,1,2,2,1]\\n```\\n**Note : You will not change all color whose value is 1 we have only change the color from the target index and there respective four directions.**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        //helper functions contains\\n        //matrix of color\\n        //target index (i,j) which is sr and sc\\n        //target color which we will used to set the new color\\n        //the original color which we will use to check and change the color in all directions\\n        helper(image,sr,sc,color,image[sr][sc]);\\n        return image;\\n    }\\n    public void helper(int image[][],int i,int j,int color,int num){\\n        //checking if the index i and j are pointing inside the matrix\\n        if(i < 0 || j < 0 || i >= image.length || j >= image[0].length){\\n            return ;\\n        }\\n        //checking if its not desired color which we not need to change\\n        //or checking if we already changed the element because its \\n        //recursive solution we might see us in the same position again\\n        if(image[i][j] != num || image[i][j] == color){\\n            return ;\\n        }\\n        //set the new color\\n        image[i][j] = color;\\n        //traverse\\n        helper(image,i+1,j,color,num);//bottom\\n        helper(image,i-1,j,color,num);//top\\n        helper(image,i,j+1,color,num);//right\\n        helper(image,i,j-1,color,num);//left\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\n[3,3,1,3,1,2]\\n[3,2,1,1,1,2]\\n[1,3,2,1,2,1]\\n[1,1,1,2,2,1]\\n```\n```\\n[3,3,4,3,4,2]\\n[3,2,4,4,4,2]\\n[1,3,2,4,2,1]\\n[1,1,1,2,2,1]\\n```\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        //helper functions contains\\n        //matrix of color\\n        //target index (i,j) which is sr and sc\\n        //target color which we will used to set the new color\\n        //the original color which we will use to check and change the color in all directions\\n        helper(image,sr,sc,color,image[sr][sc]);\\n        return image;\\n    }\\n    public void helper(int image[][],int i,int j,int color,int num){\\n        //checking if the index i and j are pointing inside the matrix\\n        if(i < 0 || j < 0 || i >= image.length || j >= image[0].length){\\n            return ;\\n        }\\n        //checking if its not desired color which we not need to change\\n        //or checking if we already changed the element because its \\n        //recursive solution we might see us in the same position again\\n        if(image[i][j] != num || image[i][j] == color){\\n            return ;\\n        }\\n        //set the new color\\n        image[i][j] = color;\\n        //traverse\\n        helper(image,i+1,j,color,num);//bottom\\n        helper(image,i-1,j,color,num);//top\\n        helper(image,i,j+1,color,num);//right\\n        helper(image,i,j-1,color,num);//left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606130,
                "title": "why-we-dont-need-a-visited-matrix-to-track-easy-answer-full-solution-in-cpp",
                "content": "When you think it will be dfs , you will think of a visited matrix .. but here we dont need one!\\nWhy ?????\\n\\nWe know without visited matrix we can enter into a infinite loop .. but here it\\'s not possible \\nWhy?\\n\\nSuppose we have a the following matrix \\n\\n```\\n[[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]] , color=2 , start at (1,2)\\n```\\n![image](https://assets.leetcode.com/users/images/b5492bc5-8d20-4368-9594-83a268c6f08e_1663771961.4269106.jpeg)\\n\\nSo we will start at (1,2) and go it left ,right, down  ,up .. in every direction since each is same as source .\\n\\nSince we havenot taken a visited array \\n**After going to left it will come back to source , but it wont be a infinite loop because source value is already changed to 2**\\n\\n![image](https://assets.leetcode.com/users/images/3d81e01f-3b5b-4a87-a688-9bb19527267b_1663772208.1555164.jpeg)\\n\\nSource Code :\\n\\n```\\nclass Solution {\\n    void dfs (vector<vector<int>>&image,int sr ,int sc , int row ,int col ,int source,int color)\\n    {   \\n        if(sr<0||sr>=row||sc<0||sc>=col)  // condition for not going out of bounds\\n            return;\\n        \\n       if(image[sr][sc]!=source)  // this the condition which prevents infinite loop \\n            return ;\\n        image[sr][sc]=color;\\n        dfs(image,sr-1,sc,row,col,source,color); // left\\n        dfs(image,sr+1,sc,row,col,source,color); //right\\n        dfs(image,sr,sc+1,row,col,source,color); //top\\n        dfs(image,sr,sc-1,row,col,source,color); // bottom\\n    }\\npublic:\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        \\n        int source = image[sr][sc];\\n        if(image[sr][sc]==color)\\n            return image;\\n        int row  =image.size();\\n        int col = image[0].size();\\n        dfs(image,sr,sc,row,col,source,color);\\n        \\n        return image;  \\n    }\\n};\\n```\\n\\n***I hope you got it now ! If  NO , drop a comment ,I will answer .***",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n[[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]] , color=2 , start at (1,2)\\n```\n```\\nclass Solution {\\n    void dfs (vector<vector<int>>&image,int sr ,int sc , int row ,int col ,int source,int color)\\n    {   \\n        if(sr<0||sr>=row||sc<0||sc>=col)  // condition for not going out of bounds\\n            return;\\n        \\n       if(image[sr][sc]!=source)  // this the condition which prevents infinite loop \\n            return ;\\n        image[sr][sc]=color;\\n        dfs(image,sr-1,sc,row,col,source,color); // left\\n        dfs(image,sr+1,sc,row,col,source,color); //right\\n        dfs(image,sr,sc+1,row,col,source,color); //top\\n        dfs(image,sr,sc-1,row,col,source,color); // bottom\\n    }\\npublic:\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        \\n        int source = image[sr][sc];\\n        if(image[sr][sc]==color)\\n            return image;\\n        int row  =image.size();\\n        int col = image[0].size();\\n        dfs(image,sr,sc,row,col,source,color);\\n        \\n        return image;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188824,
                "title": "java-solution-dfs-100",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if(color != newColor)\\n            dfschange(image, sr, sc, newColor, color);\\n        return image;\\n    }\\n    public void dfschange(int[][] image, int sr, int sc, int newColor, int orignal){\\n        if(sr < 0 || sr >= image.length || sc < 0 || sc >= image[sr].length || image[sr][sc] != orignal)\\n            return;\\n        image[sr][sc] = newColor;\\n        dfschange(image, sr + 1, sc, newColor, orignal);\\n        dfschange(image, sr - 1, sc, newColor, orignal);\\n        dfschange(image, sr, sc + 1, newColor, orignal);\\n        dfschange(image, sr, sc - 1, newColor, orignal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if(color != newColor)\\n            dfschange(image, sr, sc, newColor, color);\\n        return image;\\n    }\\n    public void dfschange(int[][] image, int sr, int sc, int newColor, int orignal){\\n        if(sr < 0 || sr >= image.length || sc < 0 || sc >= image[sr].length || image[sr][sc] != orignal)\\n            return;\\n        image[sr][sc] = newColor;\\n        dfschange(image, sr + 1, sc, newColor, orignal);\\n        dfschange(image, sr - 1, sc, newColor, orignal);\\n        dfschange(image, sr, sc + 1, newColor, orignal);\\n        dfschange(image, sr, sc - 1, newColor, orignal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161460,
                "title": "c-dfs-clean-code",
                "content": "``` c++\\nclass Solution {\\npublic:\\n    int color = -1;\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if(color == -1) color = image[sr][sc];\\n        if(image.empty() || sr == -1 || sr == image.size() || sc == -1\\n           || sc == image[0].size() || image[sr][sc] != color || color == newColor) \\n            return image;\\n        image[sr][sc] = newColor;\\n        floodFill(image, sr - 1, sc, newColor);\\n        floodFill(image, sr + 1, sc, newColor);\\n        floodFill(image, sr, sc - 1, newColor);\\n        floodFill(image, sr, sc + 1, newColor);\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` c++\\nclass Solution {\\npublic:\\n    int color = -1;\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if(color == -1) color = image[sr][sc];\\n        if(image.empty() || sr == -1 || sr == image.size() || sc == -1\\n           || sc == image[0].size() || image[sr][sc] != color || color == newColor) \\n            return image;\\n        image[sr][sc] = newColor;\\n        floodFill(image, sr - 1, sc, newColor);\\n        floodFill(image, sr + 1, sc, newColor);\\n        floodFill(image, sr, sc - 1, newColor);\\n        floodFill(image, sr, sc + 1, newColor);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285314,
                "title": "python-3-beginner-friendly-dfs-solution-explained-step-by-step",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        r,c = len(image), len(image[0])\\n        start_color = image[sr][sc] #Since we are replacing the value in the matrix, we MUST record our start color prior to any operation\\n        \\n        def paint_dfs(i,j): #here we set up our dfs function\\n            #for dfs function, I\\'d set up our boundaries first, so here comes boundaries for i and j\\n            if 0 <= i < r and 0 <= j < c and image[i][j] == start_color: #image[i][j]==start_color here because of the contraint of problem\\n                image[i][j] = color #paint new color\\n                return paint_dfs(i+1,j) and paint_dfs(i-1,j) and paint_dfs(i,j+1) and paint_dfs(i,j-1) #conduct our painting in adjacent square\\n                # [paint_dfs(i+x,j+y) for (x,y) in ((0,1),(1,0),(0,-1),(-1,0))] -----the alternative line of return, for your reference\\n            \\n            return image #else case, we simply return image without any operation, so image remains image\\n        \\n        if start_color != color: # we must exclude the case that start_color and color are the same, or it will turn out to be a infinite loop\\n            image = paint_dfs(sr,sc) #call the dfs function to start the operation\\n                \\n        return image # return image here because we change our color in image, without establishing any new matrix\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        r,c = len(image), len(image[0])\\n        start_color = image[sr][sc] #Since we are replacing the value in the matrix, we MUST record our start color prior to any operation\\n        \\n        def paint_dfs(i,j): #here we set up our dfs function\\n            #for dfs function, I\\'d set up our boundaries first, so here comes boundaries for i and j\\n            if 0 <= i < r and 0 <= j < c and image[i][j] == start_color: #image[i][j]==start_color here because of the contraint of problem\\n                image[i][j] = color #paint new color\\n                return paint_dfs(i+1,j) and paint_dfs(i-1,j) and paint_dfs(i,j+1) and paint_dfs(i,j-1) #conduct our painting in adjacent square\\n                # [paint_dfs(i+x,j+y) for (x,y) in ((0,1),(1,0),(0,-1),(-1,0))] -----the alternative line of return, for your reference\\n            \\n            return image #else case, we simply return image without any operation, so image remains image\\n        \\n        if start_color != color: # we must exclude the case that start_color and color are the same, or it will turn out to be a infinite loop\\n            image = paint_dfs(sr,sc) #call the dfs function to start the operation\\n                \\n        return image # return image here because we change our color in image, without establishing any new matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252617,
                "title": "c-bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n         vector<vector<int>>visited(image.size(),vector<int>(image[0].size(),0));\\n        \\n        queue<pair<int,int>>pq;\\n        pq.push({sr,sc});\\n        visited[sr][sc]=1;\\n        \\n        while(pq.size()>0)\\n        {\\n            int i=pq.front().first;\\n            int j=pq.front().second;\\n            \\n            pq.pop();\\n            \\n            if(i-1>=0&&image[i-1][j]==image[i][j]&& visited[i-1][j]==0)\\n            {\\n                visited[i][j]=1;\\n                pq.push({i-1,j});\\n            }\\n            if(j-1>=0&&image[i][j-1]==image[i][j]&& visited[i][j-1]==0)\\n            {\\n                visited[i][j-1]=1;\\n                pq.push({i,j-1});\\n            }\\n            if(i+1<image.size()&&image[i+1][j]==image[i][j]&& visited[i+1][j]==0)\\n            {\\n                visited[i+1][j]=1;\\n                pq.push({i+1,j});\\n            }\\n            if(j+1<image[0].size()&&image[i][j+1]==image[i][j]&& visited[i][j+1]==0)\\n            {\\n                visited[i][j+1]=1;\\n                pq.push({i,j+1});\\n            }\\n            image[i][j]=newColor;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n         vector<vector<int>>visited(image.size(),vector<int>(image[0].size(),0));\\n        \\n        queue<pair<int,int>>pq;\\n        pq.push({sr,sc});\\n        visited[sr][sc]=1;\\n        \\n        while(pq.size()>0)\\n        {\\n            int i=pq.front().first;\\n            int j=pq.front().second;\\n            \\n            pq.pop();\\n            \\n            if(i-1>=0&&image[i-1][j]==image[i][j]&& visited[i-1][j]==0)\\n            {\\n                visited[i][j]=1;\\n                pq.push({i-1,j});\\n            }\\n            if(j-1>=0&&image[i][j-1]==image[i][j]&& visited[i][j-1]==0)\\n            {\\n                visited[i][j-1]=1;\\n                pq.push({i,j-1});\\n            }\\n            if(i+1<image.size()&&image[i+1][j]==image[i][j]&& visited[i+1][j]==0)\\n            {\\n                visited[i+1][j]=1;\\n                pq.push({i+1,j});\\n            }\\n            if(j+1<image[0].size()&&image[i][j+1]==image[i][j]&& visited[i][j+1]==0)\\n            {\\n                visited[i][j+1]=1;\\n                pq.push({i,j+1});\\n            }\\n            image[i][j]=newColor;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227533,
                "title": "easy-dfs-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<vector<int>>&image,vector<vector<bool>>&vis,int sr,int sc,int newColor,int prev)\\n    {\\n        if(sr<0 || sc<0 || sr>=image.size() || sc>=image[0].size() || image[sr][sc]!=prev || vis[sr][sc])\\n        {\\n            return;\\n        }\\n        vis[sr][sc]=true;\\n        image[sr][sc]=newColor;\\n        helper(image,vis,sr+1,sc,newColor,prev);\\n        helper(image,vis,sr,sc+1,newColor,prev);\\n        helper(image,vis,sr-1,sc,newColor,prev);\\n        helper(image,vis,sr,sc-1,newColor,prev);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) \\n    {\\n        int n=image.size(),m=image[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        helper(image,vis,sr,sc,newColor,image[sr][sc]);\\n        return image;\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<vector<int>>&image,vector<vector<bool>>&vis,int sr,int sc,int newColor,int prev)\\n    {\\n        if(sr<0 || sc<0 || sr>=image.size() || sc>=image[0].size() || image[sr][sc]!=prev || vis[sr][sc])\\n        {\\n            return;\\n        }\\n        vis[sr][sc]=true;\\n        image[sr][sc]=newColor;\\n        helper(image,vis,sr+1,sc,newColor,prev);\\n        helper(image,vis,sr,sc+1,newColor,prev);\\n        helper(image,vis,sr-1,sc,newColor,prev);\\n        helper(image,vis,sr,sc-1,newColor,prev);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) \\n    {\\n        int n=image.size(),m=image[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        helper(image,vis,sr,sc,newColor,image[sr][sc]);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170393,
                "title": "c-simple-dfs-very-easy-code-with-comments",
                "content": "\\n# Complexity \\uD83D\\uDE80\\n- Time complexity:O(m*n), where m*n is the number of pixels/cells in the image.In worst case, We might process every pixel/cell.\\n\\n# Code \\uD83D\\uDE80\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int color,int r,int c,int cellColor){\\n        //base case\\n        if(i<0 || i>=r || j<0 || j>=c || mat[i][j] != cellColor){\\n            return;\\n        }\\n        \\n        //update color of curr adjacent cell\\n        mat[i][j] = color;\\n        \\n        //call dfs on 4 dirxn\\n        dfs(mat,i-1,j,color,r,c,cellColor);\\n        dfs(mat,i+1,j,color,r,c,cellColor);\\n        dfs(mat,i,j+1,color,r,c,cellColor);\\n        dfs(mat,i,j-1,color,r,c,cellColor);\\n    }\\n    \\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& mat, int sr, int sc, int color) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        \\n        int cellColor = mat[sr][sc];\\n        if(cellColor == color) return mat;\\n        \\n        dfs(mat,sr,sc,color,r,c,cellColor);\\n        return mat;\\n    }\\n};\\n```\\n# IF YOU FIND THIS CODE HELPFUL,THEN  PLEASE UPVOTE \\u2705!!!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int color,int r,int c,int cellColor){\\n        //base case\\n        if(i<0 || i>=r || j<0 || j>=c || mat[i][j] != cellColor){\\n            return;\\n        }\\n        \\n        //update color of curr adjacent cell\\n        mat[i][j] = color;\\n        \\n        //call dfs on 4 dirxn\\n        dfs(mat,i-1,j,color,r,c,cellColor);\\n        dfs(mat,i+1,j,color,r,c,cellColor);\\n        dfs(mat,i,j+1,color,r,c,cellColor);\\n        dfs(mat,i,j-1,color,r,c,cellColor);\\n    }\\n    \\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& mat, int sr, int sc, int color) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        \\n        int cellColor = mat[sr][sc];\\n        if(cellColor == color) return mat;\\n        \\n        dfs(mat,sr,sc,color,r,c,cellColor);\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638381,
                "title": "python-dfs-clean",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        color = image[sr][sc]\\n        \\n        def dfs(sr, sc):\\n            if sr not in range(len(image)): return\\n            if sc not in range(len(image[0])): return\\n            if image[sr][sc] == newColor: return\\n            if image[sr][sc] != color: return\\n            \\n            image[sr][sc] = newColor\\n            \\n            dfs(sr+1, sc)\\n            dfs(sr-1, sc)\\n            dfs(sr, sc+1)\\n            dfs(sr, sc-1)\\n        \\n        dfs(sr, sc)\\n        return image",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        color = image[sr][sc]\\n        \\n        def dfs(sr, sc):\\n            if sr not in range(len(image)): return\\n            if sc not in range(len(image[0])): return\\n            if image[sr][sc] == newColor: return\\n            if image[sr][sc] != color: return\\n            \\n            image[sr][sc] = newColor\\n            \\n            dfs(sr+1, sc)\\n            dfs(sr-1, sc)\\n            dfs(sr, sc+1)\\n            dfs(sr, sc-1)\\n        \\n        dfs(sr, sc)\\n        return image",
                "codeTag": "Java"
            },
            {
                "id": 630987,
                "title": "in-c",
                "content": "```\\n\\nvoid paint(int** image, int imageSize, int* imageColSize,\\n          int sr, int sc, int newColor, int oldColor)\\n{\\n    if (sr < 0 || sr >= imageSize)\\n        return;\\n    if (sc < 0 || sc >= imageColSize[0])\\n        return;\\n    \\n    if (image[sr][sc] == oldColor) {\\n        image[sr][sc] = newColor;\\n        paint(image, imageSize, imageColSize, sr - 1, sc, newColor, oldColor);\\n        paint(image, imageSize, imageColSize, sr + 1, sc, newColor, oldColor);\\n        paint(image, imageSize, imageColSize, sr, sc - 1, newColor, oldColor);\\n        paint(image, imageSize, imageColSize, sr, sc + 1, newColor, oldColor);\\n    }\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** floodFill(int** image, int imageSize, int* imageColSize,\\n                int sr, int sc, int newColor,\\n                int* returnSize, int** returnColumnSizes)\\n{\\n    int i;\\n    \\n    *returnSize = imageSize;\\n    *returnColumnSizes = malloc(sizeof(int) * imageSize);\\n    for (i = 0; i < imageSize; i++)\\n        (*returnColumnSizes)[i] = imageColSize[i];\\n\\n    if (newColor != image[sr][sc])\\n        paint(image, imageSize, imageColSize,\\n              sr, sc, newColor, image[sr][sc]);\\n    \\n    return image;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nvoid paint(int** image, int imageSize, int* imageColSize,\\n          int sr, int sc, int newColor, int oldColor)\\n{\\n    if (sr < 0 || sr >= imageSize)\\n        return;\\n    if (sc < 0 || sc >= imageColSize[0])\\n        return;\\n    \\n    if (image[sr][sc] == oldColor) {\\n        image[sr][sc] = newColor;\\n        paint(image, imageSize, imageColSize, sr - 1, sc, newColor, oldColor);\\n        paint(image, imageSize, imageColSize, sr + 1, sc, newColor, oldColor);\\n        paint(image, imageSize, imageColSize, sr, sc - 1, newColor, oldColor);\\n        paint(image, imageSize, imageColSize, sr, sc + 1, newColor, oldColor);\\n    }\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** floodFill(int** image, int imageSize, int* imageColSize,\\n                int sr, int sc, int newColor,\\n                int* returnSize, int** returnColumnSizes)\\n{\\n    int i;\\n    \\n    *returnSize = imageSize;\\n    *returnColumnSizes = malloc(sizeof(int) * imageSize);\\n    for (i = 0; i < imageSize; i++)\\n        (*returnColumnSizes)[i] = imageColSize[i];\\n\\n    if (newColor != image[sr][sc])\\n        paint(image, imageSize, imageColSize,\\n              sr, sc, newColor, image[sr][sc]);\\n    \\n    return image;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382755,
                "title": "java-simple-bfs-solution",
                "content": "```\\nclass Solution {\\n    int[] dr = new int[] {0, 0 , 1, -1};\\n    int[] dc = new int[] {-1, 1, 0, 0};\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int R = image.length;\\n        int C = image[0].length;\\n        \\n        int oldColor = image[sr][sc];\\n        if (oldColor == newColor)\\n            return image;\\n        Queue<Point> q = new ArrayDeque<Point>();\\n        q.add(new Point(sr, sc));\\n        \\n        while(!q.isEmpty()) {\\n            Point p = q.poll();\\n            image[p.x][p.y] = newColor;\\n            for (int i = 0; i < 4; i++) {\\n                int x = p.x + dr[i];\\n                int y = p.y + dc[i];\\n                if (isValid(image, oldColor, x, y, R, C)) {\\n                    q.add(new Point(x, y));\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n    \\n    \\n     private boolean isValid(int[][] image, int oldColor, int x, int y, int R, int C) {\\n            if (x >= 0 && x < R && y >= 0 && y < C && image[x][y] == oldColor)\\n                return true;\\n         return false;\\n        }\\n    \\n    class Point{\\n        int x;\\n        int y;\\n        \\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] dr = new int[] {0, 0 , 1, -1};\\n    int[] dc = new int[] {-1, 1, 0, 0};\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int R = image.length;\\n        int C = image[0].length;\\n        \\n        int oldColor = image[sr][sc];\\n        if (oldColor == newColor)\\n            return image;\\n        Queue<Point> q = new ArrayDeque<Point>();\\n        q.add(new Point(sr, sc));\\n        \\n        while(!q.isEmpty()) {\\n            Point p = q.poll();\\n            image[p.x][p.y] = newColor;\\n            for (int i = 0; i < 4; i++) {\\n                int x = p.x + dr[i];\\n                int y = p.y + dc[i];\\n                if (isValid(image, oldColor, x, y, R, C)) {\\n                    q.add(new Point(x, y));\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n    \\n    \\n     private boolean isValid(int[][] image, int oldColor, int x, int y, int R, int C) {\\n            if (x >= 0 && x < R && y >= 0 && y < C && image[x][y] == oldColor)\\n                return true;\\n         return false;\\n        }\\n    \\n    class Point{\\n        int x;\\n        int y;\\n        \\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669996,
                "title": "dfs-bfs-solutions-explained-iterative-recursive",
                "content": "**Approach**\\nThis is a problem which can be solved with both Depth-First-Search and Breadth-First-Search. Neither method is better than the other one, so I encourage you to try understanding each method. They are quite similar, and can be broken down into a few parts:\\n1. Check to see if ```color``` is the same as the color of our starting point, ```image[sr][sc]```. If it is, then we just need to return the original ```image```. We use this step because we could run into some infinite loop issues if we don\\'t explicitly check for this. Additionally, we will keep track of our start color, ```image[sr][sc]```, since this will be overwritten later (stored in ```start_color```). \\n2. Begin at ```(sr,sc)``` and set ```image[sr][sc]``` to ```color```. Then, we need to check all 4-dimensionally adjacent spaces to see if they are equal to ```start_color```. If they are, then we need to perform this step again starting at that index. \\n\\t- The order that we will take care of these 4-dimensionally adjacent spaces differs between DFS (where we will travel all the way in one direction and then make our way back) versus BFS (where we search all around the original space and slowly make our way outwards)\\n\\t- Sometimes the space we are looking at may be on an edge in ```image```, so we need to make sure that the ```row``` and ```col``` of the adjacent spaces are within the bounds of our grid \\u2013 ```0 <= row < len(image) and 0 <= col < len(image[0])```.\\n\\n**Recursive DFS Solution:**\\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n\\tstart_color = image[sr][sc] #keep track of original color\\n\\tif start_color == color: #the color is already this one so do nothing\\n\\t\\treturn image\\n\\tm = len(image) #length of image\\n\\tn = len(image[0]) #column length\\n\\n\\tdef dfs(r, c): #dfs helper method\\n\\t\\timage[r][c] = color #set spot to color\\n\\t\\tfor (row, col) in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: #look at 4-dimensionally adjacent places\\n\\t\\t\\tif 0 <= row < m and 0 <= col < n and image[row][col] == start_color: #check if in bounds and equal to start_color\\n\\t\\t\\t\\tdfs(row, col) #if so, we must search here\\n\\tdfs(sr, sc) #start searching at (sr,sc)\\n\\treturn image\\n```\\nIn this DFS method we use a recursive helper, ```dfs```. We don\\'t run into an infinite loop of re-looking at previously visited spaces since they will have been changed from their original color to ```start_color```. \\n\\n**Iterative DFS Solution:**\\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n\\tstart_color = image[sr][sc] #keep track of original color\\n\\tif start_color == color: #the color is already this one so do nothing\\n\\t\\treturn image\\n\\tm = len(image) #length of image\\n\\tn = len(image[0]) #column length\\n\\t\\n\\tstack = [(sr, sc)] #stack to keep track of spots we must search\\n\\twhile stack: #while there are places to look at\\n\\t\\t(r, c) = stack.pop() #get the next spot\\n\\t\\timage[r][c] = color #set it to color\\n\\t\\tfor (row, col) in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: #look at 4-dimensionally adjacent places\\n\\t\\t\\tif 0 <= row < m and 0 <= col < n and image[row][col] == start_color: #check if in bounds and equal to start_color\\n\\t\\t\\t\\tstack.append((row, col)) #if so, we must search here\\n\\treturn image\\n```\\nStacks are a super useful method of recreating a recursive DFS method iteratively since it behaves almost exactly like the computer would handle the list of recursive calls it needs to handle in the previous method \\u2013 it deals with the most recent one first.\\n\\n**Iterative BFS Solution:**\\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n\\tstart_color = image[sr][sc] #keep track of original color\\n\\tif start_color == color: #the color is already this one so do nothing\\n\\t\\treturn image\\n\\tm = len(image) #length of image\\n\\tn = len(image[0]) #column length\\n\\t\\n\\tqueue = collections.deque([(sr, sc)]) #queue to keep track of spaces we need to look at\\n\\twhile queue: #while there are places to look at\\n\\t\\t(r, c) = queue.popleft() #get the next spot\\n\\t\\timage[r][c] = color #set it to color\\n\\t\\tfor (row, col) in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: #look at 4-dimensionally adjacent places\\n\\t\\t\\tif 0 <= row < m and 0 <= col < n and image[row][col] == start_color: #check if in bounds and equal to start_color\\n\\t\\t\\t\\tqueue.append((row, col)) #if so, we must search this place too\\n\\treturn image\\n```\\nQueues are useful for BFS solutions since we will analyze the space that was added the longest time ago. In this case, we use python\\'s ```collections.deque``` to give us quick queue operations.\\n\\nRecursive BFS solutions are much more confusing and challenging to construct than recursive DFS solutions, so I won\\'t be including one.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```color```\n```image[sr][sc]```\n```image```\n```image[sr][sc]```\n```start_color```\n```(sr,sc)```\n```image[sr][sc]```\n```color```\n```start_color```\n```image```\n```row```\n```col```\n```0 <= row < len(image) and 0 <= col < len(image[0])```\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n\\tstart_color = image[sr][sc] #keep track of original color\\n\\tif start_color == color: #the color is already this one so do nothing\\n\\t\\treturn image\\n\\tm = len(image) #length of image\\n\\tn = len(image[0]) #column length\\n\\n\\tdef dfs(r, c): #dfs helper method\\n\\t\\timage[r][c] = color #set spot to color\\n\\t\\tfor (row, col) in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: #look at 4-dimensionally adjacent places\\n\\t\\t\\tif 0 <= row < m and 0 <= col < n and image[row][col] == start_color: #check if in bounds and equal to start_color\\n\\t\\t\\t\\tdfs(row, col) #if so, we must search here\\n\\tdfs(sr, sc) #start searching at (sr,sc)\\n\\treturn image\\n```\n```dfs```\n```start_color```\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n\\tstart_color = image[sr][sc] #keep track of original color\\n\\tif start_color == color: #the color is already this one so do nothing\\n\\t\\treturn image\\n\\tm = len(image) #length of image\\n\\tn = len(image[0]) #column length\\n\\t\\n\\tstack = [(sr, sc)] #stack to keep track of spots we must search\\n\\twhile stack: #while there are places to look at\\n\\t\\t(r, c) = stack.pop() #get the next spot\\n\\t\\timage[r][c] = color #set it to color\\n\\t\\tfor (row, col) in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: #look at 4-dimensionally adjacent places\\n\\t\\t\\tif 0 <= row < m and 0 <= col < n and image[row][col] == start_color: #check if in bounds and equal to start_color\\n\\t\\t\\t\\tstack.append((row, col)) #if so, we must search here\\n\\treturn image\\n```\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n\\tstart_color = image[sr][sc] #keep track of original color\\n\\tif start_color == color: #the color is already this one so do nothing\\n\\t\\treturn image\\n\\tm = len(image) #length of image\\n\\tn = len(image[0]) #column length\\n\\t\\n\\tqueue = collections.deque([(sr, sc)]) #queue to keep track of spaces we need to look at\\n\\twhile queue: #while there are places to look at\\n\\t\\t(r, c) = queue.popleft() #get the next spot\\n\\t\\timage[r][c] = color #set it to color\\n\\t\\tfor (row, col) in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: #look at 4-dimensionally adjacent places\\n\\t\\t\\tif 0 <= row < m and 0 <= col < n and image[row][col] == start_color: #check if in bounds and equal to start_color\\n\\t\\t\\t\\tqueue.append((row, col)) #if so, we must search this place too\\n\\treturn image\\n```\n```collections.deque```",
                "codeTag": "Python3"
            },
            {
                "id": 1508578,
                "title": "flood-fill-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void fill(vector<vector<int>>& image, int x, int y, int r, int c, int nc, int color)\\n    {\\n\\t\\t// Check boundary conditions\\n        if(x < 0 || y < 0 || x > r || y > c || image[x][y] != color)\\n            return;\\n        \\n\\t\\t// Change the color\\n        image[x][y] = nc;\\n        \\n\\t\\t// Recursive calls for all the 4 directions\\n        fill(image,x-1,y,r,c,nc,color);    // Top\\n        fill(image,x+1,y,r,c,nc,color);    // Bottom\\n        fill(image,x,y-1,r,c,nc,color);    // Left\\n        fill(image,x,y+1,r,c,nc,color);    // Right\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) \\n    {\\n\\t\\t// Total rows and columns\\n        int r = image.size()-1;\\n        int c = image[0].size()-1;\\n        \\n\\t\\t// Source color\\n        int color = image[sr][sc];\\n        \\n\\t\\t// Check if source color is equal to new color\\n\\t\\t// If same then return \\n        if(color == newColor)\\n            return image;\\n        \\n\\t\\t// Call for dfs\\n        fill(image,sr,sc,r,c,newColor,color);\\n        \\n\\t\\t// Return the answer\\n        return image;\\n    }\\n};\\n```\\n**If you like then do upvote\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fill(vector<vector<int>>& image, int x, int y, int r, int c, int nc, int color)\\n    {\\n\\t\\t// Check boundary conditions\\n        if(x < 0 || y < 0 || x > r || y > c || image[x][y] != color)\\n            return;\\n        \\n\\t\\t// Change the color\\n        image[x][y] = nc;\\n        \\n\\t\\t// Recursive calls for all the 4 directions\\n        fill(image,x-1,y,r,c,nc,color);    // Top\\n        fill(image,x+1,y,r,c,nc,color);    // Bottom\\n        fill(image,x,y-1,r,c,nc,color);    // Left\\n        fill(image,x,y+1,r,c,nc,color);    // Right\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) \\n    {\\n\\t\\t// Total rows and columns\\n        int r = image.size()-1;\\n        int c = image[0].size()-1;\\n        \\n\\t\\t// Source color\\n        int color = image[sr][sc];\\n        \\n\\t\\t// Check if source color is equal to new color\\n\\t\\t// If same then return \\n        if(color == newColor)\\n            return image;\\n        \\n\\t\\t// Call for dfs\\n        fill(image,sr,sc,r,c,newColor,color);\\n        \\n\\t\\t// Return the answer\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109576,
                "title": "c-dfs-solution",
                "content": "````\\npublic class Solution {    \\n    int r = 0;\\n    int c = 0;    \\n    public void DFS(int[,] image, int row, int col, int newColor, int startColor){\\n        if ( row < 0 || row >= r || col < 0 || col >= c || image[row, col] == newColor || image[row,col] != startColor)\\n            return;\\n        image[row, col] = newColor;\\n        DFS(image, row + 1, col, newColor, startColor);\\n        DFS(image, row - 1, col, newColor, startColor);\\n        DFS(image, row, col - 1, newColor, startColor);\\n        DFS(image, row, col + 1, newColor, startColor);        \\n    }\\n    \\n    public int[,] FloodFill(int[,] image, int sr, int sc, int newColor) {\\n        r = image.GetLength(0);\\n        c = image.GetLength(1);\\n        int startColor = image[sr,sc];\\n        DFS(image, sr, sc, newColor, startColor);\\n        return image;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\npublic class Solution {    \\n    int r = 0;\\n    int c = 0;    \\n    public void DFS(int[,] image, int row, int col, int newColor, int startColor){\\n        if ( row < 0 || row >= r || col < 0 || col >= c || image[row, col] == newColor || image[row,col] != startColor)\\n            return;\\n        image[row, col] = newColor;\\n        DFS(image, row + 1, col, newColor, startColor);\\n        DFS(image, row - 1, col, newColor, startColor);\\n        DFS(image, row, col - 1, newColor, startColor);\\n        DFS(image, row, col + 1, newColor, startColor);        \\n    }\\n    \\n    public int[,] FloodFill(int[,] image, int sr, int sc, int newColor) {\\n        r = image.GetLength(0);\\n        c = image.GetLength(1);\\n        int startColor = image[sr,sc];\\n        DFS(image, sr, sc, newColor, startColor);\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765226,
                "title": "dfs",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        if image[sr][sc] == color :\\n            return image\\n        self.dfs(image,sr,sc,color,image[sr][sc])\\n        return image\\n    def dfs(self,image,sr,sc,color,current) :\\n        if sc<0 or sr<0 or sr>=len(image) or sc>=len(image[0]) :\\n            return\\n        if current!=image[sr][sc] :\\n            return \\n        image[sr][sc] = color\\n        self.dfs(image,sr+1,sc,color,current) \\n        self.dfs(image,sr-1,sc,color,current) \\n        self.dfs(image,sr,sc+1,color,current) \\n        self.dfs(image,sr,sc-1,color,current) \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        if image[sr][sc] == color :\\n            return image\\n        self.dfs(image,sr,sc,color,image[sr][sc])\\n        return image\\n    def dfs(self,image,sr,sc,color,current) :\\n        if sc<0 or sr<0 or sr>=len(image) or sc>=len(image[0]) :\\n            return\\n        if current!=image[sr][sc] :\\n            return \\n        image[sr][sc] = color\\n        self.dfs(image,sr+1,sc,color,current) \\n        self.dfs(image,sr-1,sc,color,current) \\n        self.dfs(image,sr,sc+1,color,current) \\n        self.dfs(image,sr,sc-1,color,current) \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516471,
                "title": "4-directionally",
                "content": "is vague and took me longer to understand than to do the entire prompt, last I checked there were more than 4 directions, northwest, southwest, northeast, southeast....",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2369796,
                "title": "c-faster-solution-recursion-easy-to-understand",
                "content": "```\\nvector<vector<int>> fill(vector<vector<int>>& v, int sr, int sc, int color, int k, int n, int m)\\n    {\\n        if(sr < 0 || sr >= n)\\n        {\\n            return v;\\n        }\\n        if(sc < 0 || sc >= m)\\n        {\\n            return v;\\n        }\\n        if(v[sr][sc] == k)\\n        {\\n            v[sr][sc] = color;\\n            v = fill(v, sr, sc - 1, color, k, n, m);\\n            v = fill(v, sr, sc + 1, color, k, n, m);\\n            v = fill(v, sr - 1, sc, color, k, n, m);\\n            v = fill(v, sr + 1, sc, color, k, n, m);\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& v, int sr, int sc, int color) {\\n        int k = v[sr][sc];\\n        if(color == k)\\n        {\\n            return v;\\n        }\\n        int n = v.size();\\n        int m = v[0].size();\\n        return fill(v, sr, sc, color, k, n, m);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvector<vector<int>> fill(vector<vector<int>>& v, int sr, int sc, int color, int k, int n, int m)\\n    {\\n        if(sr < 0 || sr >= n)\\n        {\\n            return v;\\n        }\\n        if(sc < 0 || sc >= m)\\n        {\\n            return v;\\n        }\\n        if(v[sr][sc] == k)\\n        {\\n            v[sr][sc] = color;\\n            v = fill(v, sr, sc - 1, color, k, n, m);\\n            v = fill(v, sr, sc + 1, color, k, n, m);\\n            v = fill(v, sr - 1, sc, color, k, n, m);\\n            v = fill(v, sr + 1, sc, color, k, n, m);\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& v, int sr, int sc, int color) {\\n        int k = v[sr][sc];\\n        if(color == k)\\n        {\\n            return v;\\n        }\\n        int n = v.size();\\n        int m = v[0].size();\\n        return fill(v, sr, sc, color, k, n, m);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029619,
                "title": "2-approaches-dfs-bfs-c-solutions-with-time-complexities",
                "content": "Approach 1: DFS\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        // getting the color of the source vertex\\n        int prevc=image[sr][sc];\\n        \\n        // calling dfs\\n        dfs(image,sr,sc,prevc,newColor);\\n        \\n        return image;\\n        \\n    }\\n        \\n    void dfs(vector<vector<int>>& image, int i, int j,int prevc, int newColor)\\n    {\\n        int n=image.size();\\n        int m=image[0].size();\\n        \\n        // Base Cases\\n        \\n        if(i<0 || j<0 || i>=n || j>=m)\\n            return;\\n        if(image[i][j]!=prevc)\\n            return;\\n        if(image[i][j]==newColor)   // think of test case like this [[0,0,0],[0,1,1]] i=1,j=1,newColor=1\\n            return;\\n        \\n        // Assign newColor to the current vertex as we have successfully passed all the bases cases for this vertex\\n        \\n        image[i][j]=newColor;\\n        \\n        // calling dfs for the 4 valid directions\\n        \\n        dfs(image,i+1,j,prevc,newColor); // down\\n        dfs(image,i-1,j,prevc,newColor); // up\\n        dfs(image,i,j+1,prevc,newColor); // right\\n        dfs(image,i,j-1,prevc,newColor); // left\\n           \\n    }\\n};\\n\\nTime Complexity: O(m+n)\\n```\\n\\n\\nApproach 2: BFS\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //  valid directions\\n        vector<pair<int,int>> directions={{1,0},{-1,0},{0,1},{0,-1}};\\n\\t\\t\\n        int n=image.size();\\n        int m=image[0].size();\\n        \\n       int oldcolor=image[sr][sc];\\n        \\n        if(image[sr][sc]==newColor)    // think of test case like this [[0,0,0],[0,1,1]] i=1,j=1,newColor=1\\n            return image;\\n        \\n        // standard bfs\\n\\t\\t// assigning newColor to image will act as visited for that vertex \\n\\t\\t// so we don\\'t need any visited array here\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        image[sr][sc]=newColor;\\n        \\n        while(!q.empty())\\n        {\\n            auto top=q.front();\\n            q.pop();\\n            \\n            for(auto dir:directions)\\n            {\\n                int i=top.first+dir.first;\\n                int j=top.second+dir.second;\\n                \\n                if(isvalid(i,j,n,m) && image[i][j]==oldcolor)\\n                {\\n                    q.push({i,j});           \\n                    image[i][j]=newColor;\\n                }\\n                    \\n            }\\n        }\\n        return image;\\n        \\n    }\\n    \\n    bool isvalid(int i,int j,int n,int m)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return 0;\\n        else\\n            return 1;\\n        \\n    }\\n};\\n\\nTime Complexity: O(m+n)\\n```\\n\\nDO UPVOTE IF U FIND IT HELPFUL :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        // getting the color of the source vertex\\n        int prevc=image[sr][sc];\\n        \\n        // calling dfs\\n        dfs(image,sr,sc,prevc,newColor);\\n        \\n        return image;\\n        \\n    }\\n        \\n    void dfs(vector<vector<int>>& image, int i, int j,int prevc, int newColor)\\n    {\\n        int n=image.size();\\n        int m=image[0].size();\\n        \\n        // Base Cases\\n        \\n        if(i<0 || j<0 || i>=n || j>=m)\\n            return;\\n        if(image[i][j]!=prevc)\\n            return;\\n        if(image[i][j]==newColor)   // think of test case like this [[0,0,0],[0,1,1]] i=1,j=1,newColor=1\\n            return;\\n        \\n        // Assign newColor to the current vertex as we have successfully passed all the bases cases for this vertex\\n        \\n        image[i][j]=newColor;\\n        \\n        // calling dfs for the 4 valid directions\\n        \\n        dfs(image,i+1,j,prevc,newColor); // down\\n        dfs(image,i-1,j,prevc,newColor); // up\\n        dfs(image,i,j+1,prevc,newColor); // right\\n        dfs(image,i,j-1,prevc,newColor); // left\\n           \\n    }\\n};\\n\\nTime Complexity: O(m+n)\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //  valid directions\\n        vector<pair<int,int>> directions={{1,0},{-1,0},{0,1},{0,-1}};\\n\\t\\t\\n        int n=image.size();\\n        int m=image[0].size();\\n        \\n       int oldcolor=image[sr][sc];\\n        \\n        if(image[sr][sc]==newColor)    // think of test case like this [[0,0,0],[0,1,1]] i=1,j=1,newColor=1\\n            return image;\\n        \\n        // standard bfs\\n\\t\\t// assigning newColor to image will act as visited for that vertex \\n\\t\\t// so we don\\'t need any visited array here\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        image[sr][sc]=newColor;\\n        \\n        while(!q.empty())\\n        {\\n            auto top=q.front();\\n            q.pop();\\n            \\n            for(auto dir:directions)\\n            {\\n                int i=top.first+dir.first;\\n                int j=top.second+dir.second;\\n                \\n                if(isvalid(i,j,n,m) && image[i][j]==oldcolor)\\n                {\\n                    q.push({i,j});           \\n                    image[i][j]=newColor;\\n                }\\n                    \\n            }\\n        }\\n        return image;\\n        \\n    }\\n    \\n    bool isvalid(int i,int j,int n,int m)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return 0;\\n        else\\n            return 1;\\n        \\n    }\\n};\\n\\nTime Complexity: O(m+n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772478,
                "title": "python-3-150ms-clean-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        rows = len(image)\\n        cols = len(image[0])\\n        a = image[sr][sc]\\n        \\n        def dfs(r, c):\\n            nonlocal rows, cols, newColor, image\\n            if r < 0 or c < 0 or r>rows-1 or c>cols-1 or image[r][c]==newColor or image[r][c]!=a:\\n                return\\n            \\n            image[r][c] = newColor\\n            dfs(r+1,c)\\n            dfs(r-1,c)\\n            dfs(r,c+1)\\n            dfs(r,c-1)\\n        \\n        dfs(sr, sc)\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        rows = len(image)\\n        cols = len(image[0])\\n        a = image[sr][sc]\\n        \\n        def dfs(r, c):\\n            nonlocal rows, cols, newColor, image\\n            if r < 0 or c < 0 or r>rows-1 or c>cols-1 or image[r][c]==newColor or image[r][c]!=a:\\n                return\\n            \\n            image[r][c] = newColor\\n            dfs(r+1,c)\\n            dfs(r-1,c)\\n            dfs(r,c+1)\\n            dfs(r,c-1)\\n        \\n        dfs(sr, sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493270,
                "title": "simple-to-read-c-dfs",
                "content": "Quite a simple C# solution using Stack for DFS\\n\\n```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor)\\n            return image;\\n        \\n        var originalColor = image[sr][sc];\\n        \\n        var changeStack = new Stack<(int i, int j)>();\\n        changeStack.Push((sr, sc));\\n        \\n        while(changeStack.Count > 0) {\\n            var (i, j) = changeStack.Pop();\\n            \\n            if (i < 0 || i > image.Length - 1 ||\\n                j < 0 || j > image[0].Length - 1)\\n                continue;\\n            \\n            // we break this branch if current color is\\n            // - not the same as original color\\n            // - is already of the target color\\n            if (image[i][j] != originalColor || image[i][j] == newColor)\\n                continue;\\n            \\n            image[i][j] = newColor;\\n\\n            changeStack.Push((i - 1, j)); // top\\n            changeStack.Push((i + 1, j)); // bottom\\n            changeStack.Push((i, j + 1)); // right\\n            changeStack.Push((i, j - 1)); // left\\n        }\\n        \\n        return image;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor)\\n            return image;\\n        \\n        var originalColor = image[sr][sc];\\n        \\n        var changeStack = new Stack<(int i, int j)>();\\n        changeStack.Push((sr, sc));\\n        \\n        while(changeStack.Count > 0) {\\n            var (i, j) = changeStack.Pop();\\n            \\n            if (i < 0 || i > image.Length - 1 ||\\n                j < 0 || j > image[0].Length - 1)\\n                continue;\\n            \\n            // we break this branch if current color is\\n            // - not the same as original color\\n            // - is already of the target color\\n            if (image[i][j] != originalColor || image[i][j] == newColor)\\n                continue;\\n            \\n            image[i][j] = newColor;\\n\\n            changeStack.Push((i - 1, j)); // top\\n            changeStack.Push((i + 1, j)); // bottom\\n            changeStack.Push((i, j + 1)); // right\\n            changeStack.Push((i, j - 1)); // left\\n        }\\n        \\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626329,
                "title": "c-using-recursion-93-7-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image,int i,int j,int color,int paint)\\n    {\\n        if(i<0 || j<0)\\n            return;\\n        if(i>=image.size() || j>=image[0].size())\\n            return;\\n        if(image[i][j]!=color)\\n        {\\n            return;\\n        }\\n        image[i][j]=paint;\\n        dfs(image,i+1,j,color,paint);\\n        dfs(image,i-1,j,color,paint);\\n        dfs(image,i,j+1,color,paint);\\n        dfs(image,i,j-1,color,paint);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if(image.size() && image[sr][sc]!=newColor)\\n        {\\n            dfs(image,sr,sc,image[sr][sc],newColor);\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image,int i,int j,int color,int paint)\\n    {\\n        if(i<0 || j<0)\\n            return;\\n        if(i>=image.size() || j>=image[0].size())\\n            return;\\n        if(image[i][j]!=color)\\n        {\\n            return;\\n        }\\n        image[i][j]=paint;\\n        dfs(image,i+1,j,color,paint);\\n        dfs(image,i-1,j,color,paint);\\n        dfs(image,i,j+1,color,paint);\\n        dfs(image,i,j-1,color,paint);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if(image.size() && image[sr][sc]!=newColor)\\n        {\\n            dfs(image,sr,sc,image[sr][sc],newColor);\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509217,
                "title": "c-simple-dfs-and-bfs-solutions",
                "content": "DFS:\\n```\\nclass Solution {\\n    public:\\n        vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) \\n        {\\n            if(newColor != image[sr][sc]) \\n                fill(image, sr, sc, newColor, image[sr][sc]);\\n            return image;\\n        }\\n\\n    protected:\\n        void fill(vector<vector<int>>& image, int r, int c, int newColor, int oldColor)\\n        {\\n            if(r < 0 || r >= image.size() || c < 0 || c >= image[0].size() || image[r][c] != oldColor) return;\\n            image[r][c] = newColor;\\n            fill(image, r-1, c, newColor, oldColor);\\n            fill(image, r+1, c, newColor, oldColor);\\n            fill(image, r, c-1, newColor, oldColor);\\n            fill(image, r, c+1, newColor, oldColor);\\n        }\\n};\\n```\\n\\nBFS:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int oldColor = image[sr][sc];\\n        if(oldColor == newColor) return image;\\n        const vector<pair<int, int>> moves = {{0,-1}, {0,1}, {1,0}, {-1,0}};\\n        queue<pair<int, int>> q({{sr, sc}});\\n        while(q.size())\\n        {\\n            auto [row,col] = q.front(); q.pop();\\n            image[row][col] = newColor;\\n            for(auto& [R,C] : moves)\\n            {\\n                int r = row+R, c = col+C;\\n                if(r < 0 || r >= image.size() || c < 0 || c >= image[0].size() || image[r][c] != oldColor) continue;\\n                q.push({r,c});\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) \\n        {\\n            if(newColor != image[sr][sc]) \\n                fill(image, sr, sc, newColor, image[sr][sc]);\\n            return image;\\n        }\\n\\n    protected:\\n        void fill(vector<vector<int>>& image, int r, int c, int newColor, int oldColor)\\n        {\\n            if(r < 0 || r >= image.size() || c < 0 || c >= image[0].size() || image[r][c] != oldColor) return;\\n            image[r][c] = newColor;\\n            fill(image, r-1, c, newColor, oldColor);\\n            fill(image, r+1, c, newColor, oldColor);\\n            fill(image, r, c-1, newColor, oldColor);\\n            fill(image, r, c+1, newColor, oldColor);\\n        }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int oldColor = image[sr][sc];\\n        if(oldColor == newColor) return image;\\n        const vector<pair<int, int>> moves = {{0,-1}, {0,1}, {1,0}, {-1,0}};\\n        queue<pair<int, int>> q({{sr, sc}});\\n        while(q.size())\\n        {\\n            auto [row,col] = q.front(); q.pop();\\n            image[row][col] = newColor;\\n            for(auto& [R,C] : moves)\\n            {\\n                int r = row+R, c = col+C;\\n                if(r < 0 || r >= image.size() || c < 0 || c >= image[0].size() || image[r][c] != oldColor) continue;\\n                q.push({r,c});\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139730,
                "title": "explanation-of-stackoverflow-using-dfs-java",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n            \\n\\n       if(image[sr][sc]!=newColor) \\n           helper(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n        }\\n    \\n\\n\\n        public void helper(int[][] grid,int sr,int sc,int color,int newColor)\\n        {\\n            if(sr<0 || sr>=grid.length || sc< 0 || sc>=grid[sr].length || grid[sr][sc]!=color)\\n            {\\n                return ;\\n                \\n            }\\n\\n            \\n                grid[sr][sc]=newColor;\\n\\n\\n           \\n             helper(grid,sr-1,sc,color,newColor);\\n            helper(grid,sr+1,sc,color,newColor);    helper(grid,sr,sc-1,color,newColor);  helper(grid,sr,sc+1,color,newColor);\\n        }\\n\\n}\\n```\\nonly when you dont have the condition where both the newcolor and the given are same\\nif (image[sr][sc] == newColor) return image\\n\\nif you have this condition then there is no overflow\\n\\n\\nthe description is not fully given and I believe if it is already recolored to the new one then even though you keep on changing it will be the same color and will result in loop and resulting in stack overflow. so we return if it is already colored to what we want to change.\\n\\n111\\n111\\nfor this if you want to change the first one to 1.\\nthen based on the code written above it will not have any stopping condition and will result in stackoverflow\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n            \\n\\n       if(image[sr][sc]!=newColor) \\n           helper(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n        }\\n    \\n\\n\\n        public void helper(int[][] grid,int sr,int sc,int color,int newColor)\\n        {\\n            if(sr<0 || sr>=grid.length || sc< 0 || sc>=grid[sr].length || grid[sr][sc]!=color)\\n            {\\n                return ;\\n                \\n            }\\n\\n            \\n                grid[sr][sc]=newColor;\\n\\n\\n           \\n             helper(grid,sr-1,sc,color,newColor);\\n            helper(grid,sr+1,sc,color,newColor);    helper(grid,sr,sc-1,color,newColor);  helper(grid,sr,sc+1,color,newColor);\\n        }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135325,
                "title": "ruby-56ms-100",
                "content": "```\\n# @param {Integer[][]} image\\n# @param {Integer} sr\\n# @param {Integer} sc\\n# @param {Integer} new_color\\n# @return {Integer[][]}\\ndef flood_fill(image, sr, sc, new_color)    \\n    color = image[sr][sc]\\n    image[sr][sc] = new_color\\n    return image if color == new_color #if no painting req\\n    flood_fill(image, sr-1, sc, new_color) if sr > 0 and image[sr-1][sc] == color\\n    flood_fill(image, sr, sc-1, new_color) if sc > 0 and image[sr][sc-1] == color\\n    flood_fill(image, sr+1, sc, new_color) if sr+1 < image.size and image[sr+1][sc] == color\\n    flood_fill(image, sr, sc+1, new_color) if sc+1 < image[0].size and image[sr][sc+1] == color\\n    return image\\nend\\n```\\nterminate if color == new color \\notherwise DFS and modify image matrix.\\n\\n\\n`If you use Ruby you are not alone.` ",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[][]} image\\n# @param {Integer} sr\\n# @param {Integer} sc\\n# @param {Integer} new_color\\n# @return {Integer[][]}\\ndef flood_fill(image, sr, sc, new_color)    \\n    color = image[sr][sc]\\n    image[sr][sc] = new_color\\n    return image if color == new_color #if no painting req\\n    flood_fill(image, sr-1, sc, new_color) if sr > 0 and image[sr-1][sc] == color\\n    flood_fill(image, sr, sc-1, new_color) if sc > 0 and image[sr][sc-1] == color\\n    flood_fill(image, sr+1, sc, new_color) if sr+1 < image.size and image[sr+1][sc] == color\\n    flood_fill(image, sr, sc+1, new_color) if sc+1 < image[0].size and image[sr][sc+1] == color\\n    return image\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2835910,
                "title": "dfs-explained-c-no-visited-matrix-required",
                "content": "Here is my dfs approach with explaination:-\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image, int initial, int i, int j, int color){\\n        int n= image.size(); int m= image[0].size();   // n is the no. of columns and m is the no. of rows\\n        if (i<0 || j<0 || i>=n || j>=m)return;   // if the index goes out of bound/matrix\\n        if (image[i][j]!=initial || image[i][j]==color)return; // if the color does not match or initially it has been colored(to avoid self infinite loop)\\n        image[i][j]= color;  // change the color as after the above conditions is satisfied means it is the required cell\\n        dfs(image,initial,i-1,j,color);  // look for left\\n        dfs(image,initial,i+1,j,color); // look for right\\n        dfs(image,initial,i,j-1,color); // look for up\\n        dfs(image,initial,i,j+1,color); // look for down\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        dfs(image,image[sr][sc],sr,sc,color); // call dfs from the source cell.\\n        return image;\\n    }\\n};\\n```\\nfor bfs solution visit : https://leetcode.com/problems/flood-fill/discuss/2835897/Easy-C%2B%2B-Solution-oror-BFS-oror-DFS-oror-Both-Approaches",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image, int initial, int i, int j, int color){\\n        int n= image.size(); int m= image[0].size();   // n is the no. of columns and m is the no. of rows\\n        if (i<0 || j<0 || i>=n || j>=m)return;   // if the index goes out of bound/matrix\\n        if (image[i][j]!=initial || image[i][j]==color)return; // if the color does not match or initially it has been colored(to avoid self infinite loop)\\n        image[i][j]= color;  // change the color as after the above conditions is satisfied means it is the required cell\\n        dfs(image,initial,i-1,j,color);  // look for left\\n        dfs(image,initial,i+1,j,color); // look for right\\n        dfs(image,initial,i,j-1,color); // look for up\\n        dfs(image,initial,i,j+1,color); // look for down\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        dfs(image,image[sr][sc],sr,sc,color); // call dfs from the source cell.\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786816,
                "title": "flood-fill-java-solution-simple-recursion-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179746,
                "title": "java-bfs-solution-using-point-class",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{1,0}, {0,1},{-1,0},{0,-1}};\\n    class Point{\\n      int x;\\n      int y;\\n      public Point(int x, int y){\\n        this.x = x;\\n        this.y = y;\\n      }\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int m = image.length;\\n        int n = image[0].length;\\n        int old = image[sr][sc];\\n        if (old == newColor) return image;\\n            \\n        Queue<Point> q = new LinkedList<>();\\n        q.offer(new Point(sr, sc));\\n        \\n        while (!q.isEmpty()){\\n            Point p = q.poll();\\n            image[p.x][p.y] = newColor;\\n            for(int[] d: dirs){\\n                int x = p.x + d[0];\\n                int y = p.y + d[1];\\n                if (isValid(image, x, y, m,n, old)) q.offer(new Point(x,y));              \\n            }\\n        }\\n        return image;    \\n    }\\n    \\n    public boolean isValid(int[][] image, int i, int j, int m, int n, int color){\\n        return i >=0 && i < m && j >= 0 && j < n && image[i][j] == color;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{1,0}, {0,1},{-1,0},{0,-1}};\\n    class Point{\\n      int x;\\n      int y;\\n      public Point(int x, int y){\\n        this.x = x;\\n        this.y = y;\\n      }\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int m = image.length;\\n        int n = image[0].length;\\n        int old = image[sr][sc];\\n        if (old == newColor) return image;\\n            \\n        Queue<Point> q = new LinkedList<>();\\n        q.offer(new Point(sr, sc));\\n        \\n        while (!q.isEmpty()){\\n            Point p = q.poll();\\n            image[p.x][p.y] = newColor;\\n            for(int[] d: dirs){\\n                int x = p.x + d[0];\\n                int y = p.y + d[1];\\n                if (isValid(image, x, y, m,n, old)) q.offer(new Point(x,y));              \\n            }\\n        }\\n        return image;    \\n    }\\n    \\n    public boolean isValid(int[][] image, int i, int j, int m, int n, int color){\\n        return i >=0 && i < m && j >= 0 && j < n && image[i][j] == color;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783652,
                "title": "java-super-easy-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N * M)\\nWhere N is row & M is column\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N * M)\\nWhere N is row & M is column\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f4aaf27d-f354-418a-b872-21178c6f3b4c_1689694320.232002.png)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        int initialColor = image[sr][sc]; // Store the initial color of the starting pixel\\n        int[][] result = image; // Create a copy of the image to store the result\\n        \\n        int[] delRow = {-1, 0, 1, 0}; // Changes in row index to traverse neighbors (up, right, down, left)\\n        int[] delCol = {0, 1, 0, -1}; // Changes in column index to traverse neighbors (up, right, down, left)\\n        \\n        // Perform the DFS traversal to fill the connected region with the new color\\n        dfs(sr, sc, result, image, newColor, delRow, delCol, initialColor);\\n        \\n        return result; // Return the updated image after flood fill\\n    }\\n    \\n\\n    private void dfs(int row, int col, int[][] result, int[][] image, int newColor, int[] delRow, int[] delCol, int initialColor) {\\n        \\n        // Fill the current pixel with the new color\\n        result[row][col] = newColor; \\n        \\n        int numRows = image.length; // Number of rows in the image\\n        int numCols = image[0].length; // Number of columns in the image\\n        \\n        // Traverse the neighbors of the current pixel\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + delRow[i]; // Calculate the new row index for the neighbor\\n            int newCol = col + delCol[i]; // Calculate the new column index for the neighbor\\n            \\n            // Check if the neighbor pixel is within the image boundaries,\\n            //has the initial color,\\n            // and has not been filled with the new color\\n            if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols\\n                    && image[newRow][newCol] == initialColor && result[newRow][newCol] != newColor)\\n            {\\n                // Recursively perform the flood fill operation on the neighbor pixel\\n                dfs(newRow, newCol, result, image, newColor, delRow, delCol, initialColor);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        int initialColor = image[sr][sc]; // Store the initial color of the starting pixel\\n        int[][] result = image; // Create a copy of the image to store the result\\n        \\n        int[] delRow = {-1, 0, 1, 0}; // Changes in row index to traverse neighbors (up, right, down, left)\\n        int[] delCol = {0, 1, 0, -1}; // Changes in column index to traverse neighbors (up, right, down, left)\\n        \\n        // Perform the DFS traversal to fill the connected region with the new color\\n        dfs(sr, sc, result, image, newColor, delRow, delCol, initialColor);\\n        \\n        return result; // Return the updated image after flood fill\\n    }\\n    \\n\\n    private void dfs(int row, int col, int[][] result, int[][] image, int newColor, int[] delRow, int[] delCol, int initialColor) {\\n        \\n        // Fill the current pixel with the new color\\n        result[row][col] = newColor; \\n        \\n        int numRows = image.length; // Number of rows in the image\\n        int numCols = image[0].length; // Number of columns in the image\\n        \\n        // Traverse the neighbors of the current pixel\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + delRow[i]; // Calculate the new row index for the neighbor\\n            int newCol = col + delCol[i]; // Calculate the new column index for the neighbor\\n            \\n            // Check if the neighbor pixel is within the image boundaries,\\n            //has the initial color,\\n            // and has not been filled with the new color\\n            if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols\\n                    && image[newRow][newCol] == initialColor && result[newRow][newCol] != newColor)\\n            {\\n                // Recursively perform the flood fill operation on the neighbor pixel\\n                dfs(newRow, newCol, result, image, newColor, delRow, delCol, initialColor);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409319,
                "title": "dfs-accepted-and-easy-to-understand-solution-in-c",
                "content": "# **Approach:**\\n1> Store the current value\\n2> check whether the element we\\'re referred is not already colored, if yes than return back \\n3> If not than make it colored and call for its 4direction neighbour\\'s whose value is curr.\\n\\n**Code:**\\n```\\nclass Solution {\\nprivate:\\n    void helper( vector<vector<int>> &image, int i, int j, int curr, int color, int n, int m){\\n        if(i<0 or i>=n or j<0 or j>=m){\\n            return;\\n        }\\n        if(image[i][j] == color){\\n            return;\\n        }\\n        if(image[i][j] == curr){\\n            image[i][j] = color;\\n            helper(image, i, j+1, curr, color, n, m);\\n            helper(image, i+1, j, curr, color, n, m);\\n            helper(image, i-1, j, curr, color, n, m);\\n            helper(image, i, j-1, curr, color, n, m);\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        \\n        int temp = image[sr][sc];\\n        int n=image.size(), m=image[0].size();\\n        helper(image, sr, sc, temp, color, n, m);\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void helper( vector<vector<int>> &image, int i, int j, int curr, int color, int n, int m){\\n        if(i<0 or i>=n or j<0 or j>=m){\\n            return;\\n        }\\n        if(image[i][j] == color){\\n            return;\\n        }\\n        if(image[i][j] == curr){\\n            image[i][j] = color;\\n            helper(image, i, j+1, curr, color, n, m);\\n            helper(image, i+1, j, curr, color, n, m);\\n            helper(image, i-1, j, curr, color, n, m);\\n            helper(image, i, j-1, curr, color, n, m);\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        \\n        int temp = image[sr][sc];\\n        int n=image.size(), m=image[0].size();\\n        helper(image, sr, sc, temp, color, n, m);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349822,
                "title": "both-bfs-and-dfs-solution",
                "content": "\\n\\n\\n     class Solution {\\n     public:\\n    \\n    void dfs(int row,int col,vector<vector<int>>&image,vector<vector<int>>&vect,int ncolor,int ocolor){\\n        if(row<0 or row>=image.size() or col<0 or col>=image[0].size() or vect[row][col]==ncolor or image[row][col]!=ocolor)return;\\n        vect[row][col]=ncolor;\\n        vector<int>dir={-1,0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int nrow=row+dir[i];\\n            int ncol=col+dir[i+1];\\n            dfs(nrow,ncol,image,vect,ncolor,ocolor);\\n        }\\n    }\\n    \\n    void bfs(int row,int col,vector<vector<int>>&image,vector<vector<int>>&vect,int ncolor,int ocolor){\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        vect[row][col]=ncolor;\\n        while(!q.empty()){\\n            int fir=q.front().first;\\n            int sec=q.front().second;\\n            q.pop();\\n            vector<int>dir={-1,0,1,0,-1};\\n            for(int i=0;i<4;i++){\\n                int nrow=fir+dir[i];\\n                int ncol=sec+dir[i+1];\\n                if(nrow>=0 and nrow<image.size() and ncol>=0 and ncol<image[0].size() and image[nrow][ncol]==ocolor and vect[nrow][ncol]!=ncolor){\\n                    q.push({nrow,ncol});\\n                    vect[nrow][ncol]=ncolor;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n         vector<vector<int>>vect=image;\\n         int ocolor=image[sr][sc];\\n         dfs(sr,sc,image,vect,newColor,ocolor);\\n         return vect;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n    \\n    void dfs(int row,int col,vector<vector<int>>&image,vector<vector<int>>&vect,int ncolor,int ocolor){\\n        if(row<0 or row>=image.size() or col<0 or col>=image[0].size() or vect[row][col]==ncolor or image[row][col]!=ocolor)return;\\n        vect[row][col]=ncolor;\\n        vector<int>dir={-1,0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 3090391,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& image, int i, int j,int val, int newColor)\\n{\\n    if(i<0 || i>=image.size() || j<0 || j>= image[0].size() ||\\n       image[i][j] == newColor || image[i][j] != val)\\n    {\\n        return;\\n    }\\n    image[i][j] = newColor;\\n    dfs(image,i-1,j,val,newColor);\\n    dfs(image,i+1,j,val,newColor);\\n    dfs(image,i,j-1,val,newColor);\\n    dfs(image,i,j+1,val,newColor);\\n}\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor)\\n    {\\n        int val = image[sr][sc];\\n        dfs(image,sr,sc,val,newColor);\\n        return image;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& image, int i, int j,int val, int newColor)\\n{\\n    if(i<0 || i>=image.size() || j<0 || j>= image[0].size() ||\\n       image[i][j] == newColor || image[i][j] != val)\\n    {\\n        return;\\n    }\\n    image[i][j] = newColor;\\n    dfs(image,i-1,j,val,newColor);\\n    dfs(image,i+1,j,val,newColor);\\n    dfs(image,i,j-1,val,newColor);\\n    dfs(image,i,j+1,val,newColor);\\n}\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor)\\n    {\\n        int val = image[sr][sc];\\n        dfs(image,sr,sc,val,newColor);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175773,
                "title": "java-solution-dfs",
                "content": "I personally really like this problem. HOWEVER, the problem description is so unclear and so buggy. Leetcode has to improve it. It\\'s really hard for people to understand what the problem asks for until we read the solution.\\n\\nHere is my solution in Java:\\n\\n```\\nclass Solution \\n{\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) \\n    {\\n        // O(n) time | O(n) space\\n        int color = image[sr][sc];\\n        \\n        if(color != newColor)   DFS(image, sr, sc, color, newColor);\\n        \\n        return image;\\n    }\\n    \\n    public void DFS(int[][] image, int x, int y, int color, int newColor)\\n    {\\n        if(image[x][y] == color)\\n        {\\n            image[x][y] = newColor;\\n            \\n            if(x >= 1)  DFS(image, x-1, y, color, newColor);\\n            if(y >= 1)  DFS(image, x, y-1, color, newColor);\\n            if(x+1 < image.length)  DFS(image, x+1, y, color, newColor);\\n            if(y+1 < image[0].length)   DFS(image, x, y+1, color, newColor);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) \\n    {\\n        // O(n) time | O(n) space\\n        int color = image[sr][sc];\\n        \\n        if(color != newColor)   DFS(image, sr, sc, color, newColor);\\n        \\n        return image;\\n    }\\n    \\n    public void DFS(int[][] image, int x, int y, int color, int newColor)\\n    {\\n        if(image[x][y] == color)\\n        {\\n            image[x][y] = newColor;\\n            \\n            if(x >= 1)  DFS(image, x-1, y, color, newColor);\\n            if(y >= 1)  DFS(image, x, y-1, color, newColor);\\n            if(x+1 < image.length)  DFS(image, x+1, y, color, newColor);\\n            if(y+1 < image[0].length)   DFS(image, x, y+1, color, newColor);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108826,
                "title": "easy-c-solution-simple-bfs-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& image,int sr, int sc, int newColor,int n,int m)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        int color=image[sr][sc];\\n        image[sr][sc]=newColor;\\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n               int newX=x+dx[i];\\n               int newY=y+dy[i];\\n               if(newX>=0 && newY>=0 && newX<n && newY<m && image[newX][newY]==color)\\n               {\\n                   q.push({newX,newY});\\n                   image[newX][newY]=newColor;\\n               }\\n                   \\n            }\\n            \\n        }\\n        \\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int n=image.size();\\n        int m=image[0].size();\\n        if(image[sr][sc]!=newColor)\\n        bfs(image, sr, sc,  newColor,n,m);\\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    void bfs(vector<vector<int>>& image,int sr, int sc, int newColor,int n,int m)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc}",
                "codeTag": "Java"
            },
            {
                "id": 2100259,
                "title": "easy-to-understand-java-solution-with-some-pictures-for-better-explanation",
                "content": "well you might have an idea about the dfs traversal of a graph !!\\nhowever guessing that some of you might be beginners **I  have just added an picturized explanation of how do we get the 4 conditions of dfs function in my code\\n**\\n\\n![image](https://assets.leetcode.com/users/images/2e39ce6a-3f2c-4a9a-850c-60e8084ffb0c_1654134599.9125593.jpeg)\\n\\n*Do upvote if you like the solution and ask if you have any kind of doubts !!!*\\n\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor)\\n    {\\n     if(image[sr][sc] == newColor)\\n         return image;\\n         \\n       dfs(image , sr, sc , image[sr][sc] , newColor);\\n        return image;\\n        \\n    }\\n    \\n    \\n    \\n    private void dfs(int[][]image , int sr , int sc , int color , int newColor)\\n    {\\n        if((sr < 0 || sr >= image.length) || (sc < 0 || sc >= image[0].length) || image[sr][sc] != color)\\n            return;\\n        \\n        image[sr][sc] = newColor;\\n        dfs(image , sr + 1 , sc , color , newColor);\\n        dfs(image , sr - 1 , sc , color , newColor);\\n        dfs(image , sr ,  sc+1 , color , newColor);\\n        dfs(image , sr , sc - 1 , color , newColor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor)\\n    {\\n     if(image[sr][sc] == newColor)\\n         return image;\\n         \\n       dfs(image , sr, sc , image[sr][sc] , newColor);\\n        return image;\\n        \\n    }\\n    \\n    \\n    \\n    private void dfs(int[][]image , int sr , int sc , int color , int newColor)\\n    {\\n        if((sr < 0 || sr >= image.length) || (sc < 0 || sc >= image[0].length) || image[sr][sc] != color)\\n            return;\\n        \\n        image[sr][sc] = newColor;\\n        dfs(image , sr + 1 , sc , color , newColor);\\n        dfs(image , sr - 1 , sc , color , newColor);\\n        dfs(image , sr ,  sc+1 , color , newColor);\\n        dfs(image , sr , sc - 1 , color , newColor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020734,
                "title": "python-simple-dfs-solution-43ms-beats-99-94-with-explanation",
                "content": "**Explanation**\\nWe search through the image using depth-first-search ([dfs](https://en.wikipedia.org/wiki/Depth-first_search)), and each time we check if:\\n1. The row specified is within bounds\\n2. The column specified is within bounds\\n3. The current pixel isn\\'t the starting pixel (`newColor`)\\n4. The current pixel is the same color as the starting pixel (`newColor`\\'s color/value)\\n\\nIf all of these conditions are satisfied, then we update the current pixel to be the same color as the starting pixel (perform a flood fill), and after that we recurse to the next pixel in 4 directions: \\n1. `dfs(sr-1, sc)`: to the left\\n2. `dfs(sr+1, sc)`: to the right\\n3. `dfs(sr, sc-1)`: up\\n4. `dfs(sr, sc+1)`: down\\n\\n![image](https://assets.leetcode.com/users/images/54feba8c-e8ef-4be6-80ff-53a2f182e500_1652047553.4994512.png)\\n\\n```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        rows = len(image)\\n        cols = len(image[0])\\n        original_color = image[sr][sc]\\n        \\n        def dfs(sr, sc):\\n            if sr not in range(rows): return\\n            if sc not in range(cols): return\\n            if image[sr][sc] == newColor: return\\n            if image[sr][sc] != original_color: return\\n            \\n            image[sr][sc] = newColor\\n            \\n            dfs(sr-1, sc)\\n            dfs(sr+1, sc)\\n            dfs(sr, sc-1)\\n            dfs(sr, sc+1)\\n        \\n        dfs(sr, sc)\\n        return image\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        rows = len(image)\\n        cols = len(image[0])\\n        original_color = image[sr][sc]\\n        \\n        def dfs(sr, sc):\\n            if sr not in range(rows): return\\n            if sc not in range(cols): return\\n            if image[sr][sc] == newColor: return\\n            if image[sr][sc] != original_color: return\\n            \\n            image[sr][sc] = newColor\\n            \\n            dfs(sr-1, sc)\\n            dfs(sr+1, sc)\\n            dfs(sr, sc-1)\\n            dfs(sr, sc+1)\\n        \\n        dfs(sr, sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012321,
                "title": "javascript-solution",
                "content": "```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let value=image[sr][sc];\\n    if(value===newColor){ return image; }\\n    let row=image.length; let colm=image[0].length;\\n    fill(sr,sc);\\n    return image;\\n    function fill(i,j){\\n        if(i<0 || j<0 ||i===row || j===colm || image[i][j]!==value){ return; }\\n        image[i][j]=newColor;\\n        fill(i+1,j); fill(i-1,j); fill(i,j+1); fill(i,j-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let value=image[sr][sc];\\n    if(value===newColor){ return image; }\\n    let row=image.length; let colm=image[0].length;\\n    fill(sr,sc);\\n    return image;\\n    function fill(i,j){\\n        if(i<0 || j<0 ||i===row || j===colm || image[i][j]!==value){ return; }\\n        image[i][j]=newColor;\\n        fill(i+1,j); fill(i-1,j); fill(i,j+1); fill(i,j-1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529928,
                "title": "go-clean-code",
                "content": "```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    row,coloumn := len(image) , len(image[0])\\n    \\n    var dfs func(r,c int)\\n    \\n    color := image[sr][sc]\\n    \\n    if color == newColor {\\n        return image\\n    }\\n    \\n    dfs = func(r,c int){\\n        if image[r][c] == color{\\n            image[r][c] = newColor\\n            if r >= 1 {\\n                dfs(r-1,c)\\n            }\\n            if r+1 < row {\\n                dfs(r+1,c)\\n            }\\n            if c>= 1{\\n                dfs(r,c-1)\\n            }\\n            if c+1 < coloumn{\\n                dfs(r,c+1)\\n            }\\n        }\\n    }\\n    dfs(sr,sc)\\n    return image\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    row,coloumn := len(image) , len(image[0])\\n    \\n    var dfs func(r,c int)\\n    \\n    color := image[sr][sc]\\n    \\n    if color == newColor {\\n        return image\\n    }\\n    \\n    dfs = func(r,c int){\\n        if image[r][c] == color{\\n            image[r][c] = newColor\\n            if r >= 1 {\\n                dfs(r-1,c)\\n            }\\n            if r+1 < row {\\n                dfs(r+1,c)\\n            }\\n            if c>= 1{\\n                dfs(r,c-1)\\n            }\\n            if c+1 < coloumn{\\n                dfs(r,c+1)\\n            }\\n        }\\n    }\\n    dfs(sr,sc)\\n    return image\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1018934,
                "title": "c-recursive-solution-explaining-what-the-h-ll-are-those-parameters",
                "content": "I think the parameters are a little confusing so it is worth spending a few sentences to explain what those parameters are. \\n```int** image``` is the 2D image you are working on. \\n```int imageSize``` is the number of rows the image has. If the variable name is ```rowSize```, then it would make more sense. \\n```int* imageColSize``` is an array that contains the size of each column in this 2D image. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tFor example, if the image is 3x3, then imageColSize = [3, 3, 3]\\n\\n```int sr```  the x coordinate of the pixel you are working on. \\n```int sc``` the y coordinate of the pixel. \\n```newColor``` the value of the new color. \\n\\n```int* returnSize``` is a pointer that points to the integer that stores the number of rows in this picture. \\nAll you need to do is: ```*returnSize = imageSize; ```\\n\\n```int** returnColumnSizes``` is the pointer that points to an int array that stores the size of each column of this 2D image. (It was confusing to me at first. But think of ```int** returnColumnSizes``` is a pointer that points to an int array that is identical to ```int* imageColSize```.  However, you have to malloc() the array that ```int** returnColumnSizes``` points to. This is demonstrated in the solution below. \\n\\nSome of these variables have very confusing names so I recommend you change the name of those parameters when you write your own solution. \\n\\nThis question is very similar to the island question. \\n\\nAlright, so after explaining the parameters, here is the solution: (codes are broken into sections to improve readability)\\n```\\nvoid solveRecursively(int** image, int imageSize, int* imageColSize, \\n                     int x, int y, int newColor, int originalColor){\\n    if(x >= 0 && x < imageSize && y >= 0 && y < imageColSize[x] && image[x][y] == originalColor){\\n        image[x][y] = newColor; \\n        solveRecursively(image, imageSize, imageColSize, x - 1, y, newColor, originalColor); \\n        solveRecursively(image, imageSize, imageColSize, x + 1, y, newColor, originalColor); \\n        solveRecursively(image, imageSize, imageColSize, x, y + 1, newColor, originalColor); \\n        solveRecursively(image, imageSize, imageColSize, x, y - 1, newColor, originalColor); \\n    }\\n}\\n```\\n```\\nint** floodFill(int** image, int imageSize, int* imageColSize, \\n                int sr, int sc, int newColor, \\n                int* returnSize, int** returnColumnSizes){\\n    /* copy the size of the row */ \\n    *returnSize = imageSize; \\n    \\n    /* copy the size of colums */ \\n    *returnColumnSizes = (int*)malloc(sizeof(int) * *returnSize); \\n    for(int i = 0; i < *returnSize; i++){\\n        printf(\"%d\\\\n\", imageColSize[0]);\\n        (*returnColumnSizes)[i] = imageColSize[0];\\n    }\\n    \\n    /* This method works based on the assumption that newColor is different from the original color. \\n       If those two color are the same, there is nothing to modify. Return right away. */\\n    if(newColor == image[sr][sc]) \\n        return image; \\n    \\n    solveRecursively(image, imageSize, imageColSize, sr, sc, newColor, image[sr][sc]);\\n\\n    return image; \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```int** image```\n```int imageSize```\n```rowSize```\n```int* imageColSize```\n```int sr```\n```int sc```\n```newColor```\n```int* returnSize```\n```*returnSize = imageSize; ```\n```int** returnColumnSizes```\n```int** returnColumnSizes```\n```int* imageColSize```\n```int** returnColumnSizes```\n```\\nvoid solveRecursively(int** image, int imageSize, int* imageColSize, \\n                     int x, int y, int newColor, int originalColor){\\n    if(x >= 0 && x < imageSize && y >= 0 && y < imageColSize[x] && image[x][y] == originalColor){\\n        image[x][y] = newColor; \\n        solveRecursively(image, imageSize, imageColSize, x - 1, y, newColor, originalColor); \\n        solveRecursively(image, imageSize, imageColSize, x + 1, y, newColor, originalColor); \\n        solveRecursively(image, imageSize, imageColSize, x, y + 1, newColor, originalColor); \\n        solveRecursively(image, imageSize, imageColSize, x, y - 1, newColor, originalColor); \\n    }\\n}\\n```\n```\\nint** floodFill(int** image, int imageSize, int* imageColSize, \\n                int sr, int sc, int newColor, \\n                int* returnSize, int** returnColumnSizes){\\n    /* copy the size of the row */ \\n    *returnSize = imageSize; \\n    \\n    /* copy the size of colums */ \\n    *returnColumnSizes = (int*)malloc(sizeof(int) * *returnSize); \\n    for(int i = 0; i < *returnSize; i++){\\n        printf(\"%d\\\\n\", imageColSize[0]);\\n        (*returnColumnSizes)[i] = imageColSize[0];\\n    }\\n    \\n    /* This method works based on the assumption that newColor is different from the original color. \\n       If those two color are the same, there is nothing to modify. Return right away. */\\n    if(newColor == image[sr][sc]) \\n        return image; \\n    \\n    solveRecursively(image, imageSize, imageColSize, sr, sc, newColor, image[sr][sc]);\\n\\n    return image; \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911831,
                "title": "python-bfs",
                "content": "We basically replace all of the connected elements in image, connected by the color at image[sr][sc].\\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        \\n        color_to_fill = image[sr][sc]\\n        queue = deque()\\n        seen = set()\\n        queue.append((sr, sc))\\n        while queue:\\n            popped = queue.popleft()\\n            seen.add(popped)\\n            image[popped[0]][popped[1]] = newColor\\n            \\n            directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n            for diff_x, diff_y in directions:\\n                new_x = popped[0] + diff_x\\n                new_y = popped[1] + diff_y\\n                if 0 <= new_x < len(image) and 0 <= new_y < len(image[0]) and (new_x, new_y) not in seen and image[new_x][new_y] == color_to_fill:\\n                    queue.append((new_x, new_y))\\n        \\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        \\n        color_to_fill = image[sr][sc]\\n        queue = deque()\\n        seen = set()\\n        queue.append((sr, sc))\\n        while queue:\\n            popped = queue.popleft()\\n            seen.add(popped)\\n            image[popped[0]][popped[1]] = newColor\\n            \\n            directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n            for diff_x, diff_y in directions:\\n                new_x = popped[0] + diff_x\\n                new_y = popped[1] + diff_y\\n                if 0 <= new_x < len(image) and 0 <= new_y < len(image[0]) and (new_x, new_y) not in seen and image[new_x][new_y] == color_to_fill:\\n                    queue.append((new_x, new_y))\\n        \\n        return image\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 557447,
                "title": "c-dfs-recursive-iterative-bfs",
                "content": "**DFS Recursive**\\n```\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        if(image[sr][sc] == newColor)\\n            return image;\\n        \\n        DFS(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    public void DFS(int[][] image, int sr, int sc, int baseColor, int newColor)\\n    {\\n        int maxRow = image.Length, maxCol = image[0].Length;   \\n        if(sr < 0 || sr >= maxRow || sc < 0 || sc >= maxCol || image[sr][sc] != baseColor)\\n            return;\\n        \\n        image[sr][sc] = newColor;\\n        \\n        DFS(image, sr + 1, sc, baseColor, newColor); // down\\n        DFS(image, sr - 1, sc, baseColor, newColor); // up\\n        DFS(image, sr, sc - 1, baseColor, newColor); // left\\n        DFS(image, sr, sc + 1, baseColor, newColor); // right\\n    }\\n```\\n**DFS Iterative**\\n```\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        if(image[sr][sc] == newColor)\\n            return image;\\n        \\n        int[,] dir = new int[,]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int sourceColor = image[sr][sc];\\n        Stack<(int,int)> stack = new Stack<(int,int)>();\\n        stack.Push((sr, sc));\\n        \\n        while(stack.Count > 0)\\n        {\\n            var curr = stack.Pop();\\n            image[curr.Item1][curr.Item2] = newColor;\\n            \\n            for(int i = 0; i < dir.GetLength(0); i++)\\n            {\\n                int newR = curr.Item1 + dir[i, 0];\\n                int newC = curr.Item2 + dir[i, 1];\\n                \\n                if(newR >= 0 && newR < image.Length && newC >= 0 && newC < image[0].Length && image[newR][newC] == sourceColor)\\n                    stack.Push((newR, newC));\\n            }\\n        }\\n        \\n        return image;\\n    }\\n```\\n**BFS**\\n```\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        if(image[sr][sc] == newColor)\\n            return image;\\n        \\n        int sourceColor = image[sr][sc];\\n        int[,] dir = new int[,]{{-1, 0},{1, 0},{0, -1,},{0 ,1}};\\n        Queue<(int, int)> queue = new Queue<(int, int)>();\\n        queue.Enqueue((sr, sc));        \\n        \\n        while(queue.Count > 0)\\n        {\\n            var curr = queue.Dequeue();             \\n            image[curr.Item1][curr.Item2] = newColor;\\n            \\n            for(int i = 0; i < dir.GetLength(0); i++)\\n            {  \\n                int newR = curr.Item1 + dir[i, 0];\\n                int newC = curr.Item2 + dir[i, 1];\\n                \\n                if(newR >= 0 && newR < image.Length && newC >= 0 && newC < image[0].Length && image[newR][newC] == sourceColor)\\n                    queue.Enqueue((newR, newC));\\n            }\\n        }\\n        \\n        return image;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        if(image[sr][sc] == newColor)\\n            return image;\\n        \\n        DFS(image, sr, sc, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    public void DFS(int[][] image, int sr, int sc, int baseColor, int newColor)\\n    {\\n        int maxRow = image.Length, maxCol = image[0].Length;   \\n        if(sr < 0 || sr >= maxRow || sc < 0 || sc >= maxCol || image[sr][sc] != baseColor)\\n            return;\\n        \\n        image[sr][sc] = newColor;\\n        \\n        DFS(image, sr + 1, sc, baseColor, newColor); // down\\n        DFS(image, sr - 1, sc, baseColor, newColor); // up\\n        DFS(image, sr, sc - 1, baseColor, newColor); // left\\n        DFS(image, sr, sc + 1, baseColor, newColor); // right\\n    }\\n```\n```\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        if(image[sr][sc] == newColor)\\n            return image;\\n        \\n        int[,] dir = new int[,]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int sourceColor = image[sr][sc];\\n        Stack<(int,int)> stack = new Stack<(int,int)>();\\n        stack.Push((sr, sc));\\n        \\n        while(stack.Count > 0)\\n        {\\n            var curr = stack.Pop();\\n            image[curr.Item1][curr.Item2] = newColor;\\n            \\n            for(int i = 0; i < dir.GetLength(0); i++)\\n            {\\n                int newR = curr.Item1 + dir[i, 0];\\n                int newC = curr.Item2 + dir[i, 1];\\n                \\n                if(newR >= 0 && newR < image.Length && newC >= 0 && newC < image[0].Length && image[newR][newC] == sourceColor)\\n                    stack.Push((newR, newC));\\n            }\\n        }\\n        \\n        return image;\\n    }\\n```\n```\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        if(image[sr][sc] == newColor)\\n            return image;\\n        \\n        int sourceColor = image[sr][sc];\\n        int[,] dir = new int[,]{{-1, 0},{1, 0},{0, -1,},{0 ,1}};\\n        Queue<(int, int)> queue = new Queue<(int, int)>();\\n        queue.Enqueue((sr, sc));        \\n        \\n        while(queue.Count > 0)\\n        {\\n            var curr = queue.Dequeue();             \\n            image[curr.Item1][curr.Item2] = newColor;\\n            \\n            for(int i = 0; i < dir.GetLength(0); i++)\\n            {  \\n                int newR = curr.Item1 + dir[i, 0];\\n                int newC = curr.Item2 + dir[i, 1];\\n                \\n                if(newR >= 0 && newR < image.Length && newC >= 0 && newC < image[0].Length && image[newR][newC] == sourceColor)\\n                    queue.Enqueue((newR, newC));\\n            }\\n        }\\n        \\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329550,
                "title": "javascript-dfs-with-stack-no-recusion",
                "content": "Using a stack we can traverse through the adjacent cells that have the same color as the first pixel we visited. \\n1. If the color of the first visited pixel is the same as the new color we can just return the image.\\n2. We only add coordinates to the stack if they are the same as the first color and if they are within bounds of the image. \\n3. Once the stack is empty we have visited all the adjacent pixels and we\\'re done\\n```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const currentColor = image[sr][sc];\\n    \\n    // No change needed\\n    if (currentColor === newColor)\\n        return image;\\n    \\n    const rowLength = image.length-1;\\n    const colLength = image[0].length-1;\\n    \\n    let stack = [[sr,sc]];\\n    \\n    while (stack.length !== 0) {\\n        let curr = stack.pop();\\n        let [row, col] = curr;\\n        \\n        if (row > 0 && image[row-1][col] === currentColor)\\n            stack.push([row-1, col]);\\n        if (row < rowLength && image[row+1][col] === currentColor)\\n            stack.push([row+1, col]);\\n        if (col > 0 && image[row][col-1] === currentColor)\\n            stack.push([row, col-1]);\\n        if (col < colLength && image[row][col+1] === currentColor)\\n            stack.push([row, col+1]);\\n        \\n        // Set the color\\n        image[row][col] = newColor;\\n    }\\n    \\n    return image;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const currentColor = image[sr][sc];\\n    \\n    // No change needed\\n    if (currentColor === newColor)\\n        return image;\\n    \\n    const rowLength = image.length-1;\\n    const colLength = image[0].length-1;\\n    \\n    let stack = [[sr,sc]];\\n    \\n    while (stack.length !== 0) {\\n        let curr = stack.pop();\\n        let [row, col] = curr;\\n        \\n        if (row > 0 && image[row-1][col] === currentColor)\\n            stack.push([row-1, col]);\\n        if (row < rowLength && image[row+1][col] === currentColor)\\n            stack.push([row+1, col]);\\n        if (col > 0 && image[row][col-1] === currentColor)\\n            stack.push([row, col-1]);\\n        if (col < colLength && image[row][col+1] === currentColor)\\n            stack.push([row, col+1]);\\n        \\n        // Set the color\\n        image[row][col] = newColor;\\n    }\\n    \\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112767,
                "title": "python-dfs-solution-90ms",
                "content": "```\\ndef floodFill(self, image, sr, sc, newColor):\\n        # time O(n^2) space O(n)\\n        # runtime: 90ms\\n        rows, cols = len(image), len(image[0])\\n        dir = ((-1,0),(1,0),(0,1),(0,-1))\\n        visited = set(); pixel = image[sr][sc] # store pixel value\\n        def dfs(i, j): \\n            if (i,j) in visited: return\\n            visited.add((i,j)) \\n            for d in dir: # traverse neighbors\\n                x, y = i+d[0], j+d[1] \\n                if 0<= x < rows and 0<= y < cols and image[x][y] == pixel:\\n                    image[x][y] = newColor\\n                    dfs(x,y)\\n        if newColor != pixel: \\n            image[sr][sc]=newColor\\n            dfs(sr, sc) \\n        return image\\n# credit to dfs template\\n# https://discuss.leetcode.com/topic/66065/python-dfs-bests-85-tips-for-all-dfs-in-matrix-question\\n```",
                "solutionTags": [],
                "code": "```\\ndef floodFill(self, image, sr, sc, newColor):\\n        # time O(n^2) space O(n)\\n        # runtime: 90ms\\n        rows, cols = len(image), len(image[0])\\n        dir = ((-1,0),(1,0),(0,1),(0,-1))\\n        visited = set(); pixel = image[sr][sc] # store pixel value\\n        def dfs(i, j): \\n            if (i,j) in visited: return\\n            visited.add((i,j)) \\n            for d in dir: # traverse neighbors\\n                x, y = i+d[0], j+d[1] \\n                if 0<= x < rows and 0<= y < cols and image[x][y] == pixel:\\n                    image[x][y] = newColor\\n                    dfs(x,y)\\n        if newColor != pixel: \\n            image[sr][sc]=newColor\\n            dfs(sr, sc) \\n        return image\\n# credit to dfs template\\n# https://discuss.leetcode.com/topic/66065/python-dfs-bests-85-tips-for-all-dfs-in-matrix-question\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3679101,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int prev = 0;\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m = image.size();\\n        int n = image[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        prev = image[sr][sc];\\n        bfs(sr,sc,color,vis,image);\\n        return image;\\n    }\\n    \\n    void bfs(int sr, int sc, int color, vector<vector<int>>& vis, vector<vector<int>>& image){\\n        int m = vis.size();\\n        int n = vis[0].size();\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        vis[sr][sc] = 1;\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            for(int i=0;i<4;i++){\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && image[nrow][ncol] == prev && vis[nrow][ncol] == 0){\\n                    image[nrow][ncol] = color;\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prev = 0;\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m = image.size();\\n        int n = image[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        prev = image[sr][sc];\\n        bfs(sr,sc,color,vis,image);\\n        return image;\\n    }\\n    \\n    void bfs(int sr, int sc, int color, vector<vector<int>>& vis, vector<vector<int>>& image){\\n        int m = vis.size();\\n        int n = vis[0].size();\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        vis[sr][sc] = 1;\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            for(int i=0;i<4;i++){\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && image[nrow][ncol] == prev && vis[nrow][ncol] == 0){\\n                    image[nrow][ncol] = color;\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532234,
                "title": "clear-dfs-golang-solution-100",
                "content": "# Intuition\\nThe problem is a classic \"flood fill\" problem that can be solved using Depth-First Search (DFS) or Breadth-First Search (BFS). The goal is to start from a pixel (represented by a cell in the matrix), and to change its color and the color of all the adjacent pixels of the same color to a new color.\\n\\n# Approach\\nThe approach to solving this problem involves using the Depth-First Search (DFS) algorithm. The DFS algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.\\n\\nIn this case, we start at the given pixel, and then continue to the adjacent pixels (up, down, left, and right), but only if they have the same color as the starting pixel and are within the boundaries of the image. If the starting pixel already has the new color, we don\\'t need to do anything.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(m*n), where m is the number of rows and n is the number of columns in the image. This is because in the worst case, we might need to visit all the pixels.\\n\\n- Space complexity:\\nThe space complexity is also O(m*n), because in the worst case, if all pixels in the image have the same color, the depth of the recursion could go up to mn.\\n\\n# Code\\n```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    sourceColor := image[sr][sc]\\n    if sourceColor != newColor {\\n        dfs(image, sr, sc, sourceColor, newColor)\\n    }\\n    return image\\n}\\n\\nfunc dfs(image [][]int, x int, y int, sourceColor int, newColor int) {\\n    if x < 0 || x >= len(image) || y < 0 || y >= len(image[0]) || image[x][y] != sourceColor {\\n        return\\n    }\\n    image[x][y] = newColor\\n    dfs(image, x-1, y, sourceColor, newColor)\\n    dfs(image, x+1, y, sourceColor, newColor)\\n    dfs(image, x, y-1, sourceColor, newColor)\\n    dfs(image, x, y+1, sourceColor, newColor)\\n}\\n```\\n\\n### Please vote \\u2191 for this solution if you like it",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    sourceColor := image[sr][sc]\\n    if sourceColor != newColor {\\n        dfs(image, sr, sc, sourceColor, newColor)\\n    }\\n    return image\\n}\\n\\nfunc dfs(image [][]int, x int, y int, sourceColor int, newColor int) {\\n    if x < 0 || x >= len(image) || y < 0 || y >= len(image[0]) || image[x][y] != sourceColor {\\n        return\\n    }\\n    image[x][y] = newColor\\n    dfs(image, x-1, y, sourceColor, newColor)\\n    dfs(image, x+1, y, sourceColor, newColor)\\n    dfs(image, x, y-1, sourceColor, newColor)\\n    dfs(image, x, y+1, sourceColor, newColor)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302026,
                "title": "python-99-27-faster-bfs-dfs-easy",
                "content": "**BFS Solution:**\\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        m=len(image)\\n        n=len(image[0])\\n        og=image[sr][sc]\\n        if og==color:\\n            return image\\n        image[sr][sc]=color\\n        q=deque()\\n        q.append([sr,sc])\\n        while len(q)>0:\\n            a,b=q.popleft()\\n            if b>0 and image[a][b-1]==og: #left\\n                image[a][b-1]=color\\n                q.append([a,b-1])\\n            if b<n-1 and image[a][b+1]==og: #right\\n                image[a][b+1]=color\\n                q.append([a,b+1])\\n            if a>0 and image[a-1][b]==og: #up\\n                image[a-1][b]=color\\n                q.append([a-1,b])\\n            if a<m-1 and image[a+1][b]==og: #down\\n                image[a+1][b]=color\\n                q.append([a+1,b])\\n        return image\\n```\\n\\n**DFS Solution:**\\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        def dfs(sv):\\n            a,b=sv[0],sv[1]\\n            image[a][b]=color\\n            if b>0 and image[a][b-1]==og: #left\\n                image[a][b-1]=color\\n                dfs([a,b-1])\\n            if b<n-1 and image[a][b+1]==og: #right\\n                image[a][b+1]=color\\n                dfs([a,b+1])\\n            if a>0 and image[a-1][b]==og: #up\\n                image[a-1][b]=color\\n                dfs([a-1,b])\\n            if a<m-1 and image[a+1][b]==og: #down\\n                image[a+1][b]=color\\n                dfs([a+1,b])\\n        m=len(image)\\n        n=len(image[0])\\n        og=image[sr][sc]\\n        if og==color:\\n            return image\\n        dfs([sr,sc])\\n        return image\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        m=len(image)\\n        n=len(image[0])\\n        og=image[sr][sc]\\n        if og==color:\\n            return image\\n        image[sr][sc]=color\\n        q=deque()\\n        q.append([sr,sc])\\n        while len(q)>0:\\n            a,b=q.popleft()\\n            if b>0 and image[a][b-1]==og: #left\\n                image[a][b-1]=color\\n                q.append([a,b-1])\\n            if b<n-1 and image[a][b+1]==og: #right\\n                image[a][b+1]=color\\n                q.append([a,b+1])\\n            if a>0 and image[a-1][b]==og: #up\\n                image[a-1][b]=color\\n                q.append([a-1,b])\\n            if a<m-1 and image[a+1][b]==og: #down\\n                image[a+1][b]=color\\n                q.append([a+1,b])\\n        return image\\n```\n```\\ndef floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        def dfs(sv):\\n            a,b=sv[0],sv[1]\\n            image[a][b]=color\\n            if b>0 and image[a][b-1]==og: #left\\n                image[a][b-1]=color\\n                dfs([a,b-1])\\n            if b<n-1 and image[a][b+1]==og: #right\\n                image[a][b+1]=color\\n                dfs([a,b+1])\\n            if a>0 and image[a-1][b]==og: #up\\n                image[a-1][b]=color\\n                dfs([a-1,b])\\n            if a<m-1 and image[a+1][b]==og: #down\\n                image[a+1][b]=color\\n                dfs([a+1,b])\\n        m=len(image)\\n        n=len(image[0])\\n        og=image[sr][sc]\\n        if og==color:\\n            return image\\n        dfs([sr,sc])\\n        return image\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3287523,
                "title": "best-o-n-m-solution",
                "content": "# Approach 1\\nUsing BFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n        vector<vector<int>> ans = image;\\n        queue <pair<int, int>> q;\\n        int iniColor = image[sr][sc];\\n        ans[sr][sc] = color;\\n        q.push({sr, sc});\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&\\n                    ans[nrow][ncol] != color && image[nrow][ncol] == iniColor) {\\n                        q.push({nrow, ncol});\\n                        ans[nrow][ncol] = color;\\n                    }       \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing DFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<int>>& image, vector<vector<int>>& ans, \\n            int iniColor, int color, int drow[], int dcol[]) {\\n                int n = image.size();\\n                int m = image[0].size();\\n                ans[row][col] = color;\\n                for (int i = 0; i < 4; i++) {\\n                    int nrow = row + drow[i];\\n                    int ncol = col + dcol[i];\\n                    if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&\\n                        ans[nrow][ncol] != color && image[nrow][ncol] == iniColor) \\n                            dfs(nrow, ncol, image, ans, iniColor, color, drow, dcol);       \\n                }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans = image;\\n        int iniColor = image[sr][sc];\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        dfs(sr, sc, image, ans, iniColor, color, drow, dcol);  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n        vector<vector<int>> ans = image;\\n        queue <pair<int, int>> q;\\n        int iniColor = image[sr][sc];\\n        ans[sr][sc] = color;\\n        q.push({sr, sc});\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = r + drow[i];\\n                int ncol = c + dcol[i];\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&\\n                    ans[nrow][ncol] != color && image[nrow][ncol] == iniColor) {\\n                        q.push({nrow, ncol});\\n                        ans[nrow][ncol] = color;\\n                    }       \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<int>>& image, vector<vector<int>>& ans, \\n            int iniColor, int color, int drow[], int dcol[]) {\\n                int n = image.size();\\n                int m = image[0].size();\\n                ans[row][col] = color;\\n                for (int i = 0; i < 4; i++) {\\n                    int nrow = row + drow[i];\\n                    int ncol = col + dcol[i];\\n                    if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&\\n                        ans[nrow][ncol] != color && image[nrow][ncol] == iniColor) \\n                            dfs(nrow, ncol, image, ans, iniColor, color, drow, dcol);       \\n                }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans = image;\\n        int iniColor = image[sr][sc];\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        dfs(sr, sc, image, ans, iniColor, color, drow, dcol);  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015620,
                "title": "java-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        if(image[sr][sc]==color) return image;\\n        dfs(image,sr,sc,color,image[sr][sc]);\\n        return image;\\n    }\\n\\n    public void dfs(int[][] image, int sr, int sc, int color,int prevColor) {\\n        if(sr>=0 && sr<image.length && sc>=0 && sc<image[0].length && image[sr][sc]==prevColor){\\n            image[sr][sc]=color;\\n            dfs(image,sr+1,sc,color,prevColor);dfs(image,sr-1,sc,color,prevColor);\\n            dfs(image,sr,sc+1,color,prevColor);dfs(image,sr,sc-1,color,prevColor);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        if(image[sr][sc]==color) return image;\\n        dfs(image,sr,sc,color,image[sr][sc]);\\n        return image;\\n    }\\n\\n    public void dfs(int[][] image, int sr, int sc, int color,int prevColor) {\\n        if(sr>=0 && sr<image.length && sc>=0 && sc<image[0].length && image[sr][sc]==prevColor){\\n            image[sr][sc]=color;\\n            dfs(image,sr+1,sc,color,prevColor);dfs(image,sr-1,sc,color,prevColor);\\n            dfs(image,sr,sc+1,color,prevColor);dfs(image,sr,sc-1,color,prevColor);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962217,
                "title": "python-simple-dfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe run a DFS on the 4 neighbours of the current node by ensuring that the indexes are not out of bounds and that the next node has the right color.\\n\\n**Upvote if it helps!** \\uD83D\\uDE42\\n\\n# Code\\n```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, color):\\n        init_color = image[sr][sc]\\n        visited = set() \\n        N = len(image) - 1\\n        n = len(image[0]) - 1\\n\\n        def dfs(visited, x, y):  #function for dfs \\n            if (x,y) not in visited:\\n                visited.add((x,y))\\n                g, h, d, b = max(0, x - 1), max(0, y - 1), min(N, x + 1), min(n, y + 1)\\n                if image[g][y] == init_color:\\n                     dfs(visited, g, y)\\n                if image[x][h] == init_color:\\n                     dfs(visited, x, h)\\n                if image[d][y] == init_color:\\n                     dfs(visited, d, y)\\n                if image[x][b] == init_color:\\n                     dfs(visited, x, b)\\n                if image[x][y] == init_color:\\n                    image[x][y] = color\\n\\n        dfs(visited, sr, sc)\\n        return image\\n                \\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, color):\\n        init_color = image[sr][sc]\\n        visited = set() \\n        N = len(image) - 1\\n        n = len(image[0]) - 1\\n\\n        def dfs(visited, x, y):  #function for dfs \\n            if (x,y) not in visited:\\n                visited.add((x,y))\\n                g, h, d, b = max(0, x - 1), max(0, y - 1), min(N, x + 1), min(n, y + 1)\\n                if image[g][y] == init_color:\\n                     dfs(visited, g, y)\\n                if image[x][h] == init_color:\\n                     dfs(visited, x, h)\\n                if image[d][y] == init_color:\\n                     dfs(visited, d, y)\\n                if image[x][b] == init_color:\\n                     dfs(visited, x, b)\\n                if image[x][y] == init_color:\\n                    image[x][y] = color\\n\\n        dfs(visited, sr, sc)\\n        return image\\n                \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826241,
                "title": "bfs-using-queue",
                "content": "Here\\'s my simple BFS solution using queue\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dir{0, 1, 0, -1, 0};\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int start = image[sr][sc];\\n        queue<pair<int, int> > Q;\\n        int r = image.size();\\n        int c = image.front().size();\\n        Q.push({sr,sc});\\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            while(sz--)\\n            {\\n                auto tp = Q.front();\\n                Q.pop();\\n                image[tp.first][tp.second] = color;\\n                for(int i=0;i<4;i++)\\n                {\\n                    int new_r = tp.first + dir[i];\\n                    int new_c = tp.second + dir[i+1];\\n                    if(new_r >= 0 && new_r < r && new_c >= 0 && new_c < c && image[new_r][new_c] == start && image[new_r][new_c] != color)\\n                    {\\n                        Q.push({new_r, new_c});\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> dir{0, 1, 0, -1, 0};\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int start = image[sr][sc];\\n        queue<pair<int, int> > Q;\\n        int r = image.size();\\n        int c = image.front().size();\\n        Q.push({sr,sc});\\n        while(!Q.empty())\\n        {\\n            int sz = Q.size();\\n            while(sz--)\\n            {\\n                auto tp = Q.front();\\n                Q.pop();\\n                image[tp.first][tp.second] = color;\\n                for(int i=0;i<4;i++)\\n                {\\n                    int new_r = tp.first + dir[i];\\n                    int new_c = tp.second + dir[i+1];\\n                    if(new_r >= 0 && new_r < r && new_c >= 0 && new_c < c && image[new_r][new_c] == start && image[new_r][new_c] != color)\\n                    {\\n                        Q.push({new_r, new_c});\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707006,
                "title": "java-simple-dfs-solution-100",
                "content": "We record the current color of the cell and repaint it. We check whether the top/bottom/left/right element exists and has the same color as the cell\\'s old color. If so, transfer control to the next cell by recursion and repeat the actions. As a result, the \"recursion wave\" will pass through all the cells that meet the condition and color them.\\n\\n```java\\npublic static int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    if (sr > image.length && sc > image[0].length) return image;\\n    if (image[sr][sc] == color) return image;\\n\\t\\n    flood(image, sr, sc, color);\\n\\t\\n    return image;\\n}\\n\\nprivate static void flood(int[][] image, int sr, int sc, int color) {\\n    int oldColor = image[sr][sc];\\n    image[sr][sc] = color;\\n\\t\\n    if (sr < image.length - 1 && oldColor == image[sr + 1][sc]) {\\n        flood(image, sr + 1, sc, color);\\n    }\\n\\t\\n    if (sr > 0 && oldColor == image[sr - 1][sc]) {\\n        flood(image, sr - 1, sc, color);\\n    }\\n\\t\\n    if (sc < image[sr].length - 1 && oldColor == image[sr][sc + 1]) {\\n        flood(image, sr, sc + 1, color);\\n    }\\n\\t\\n    if (sc > 0 && oldColor == image[sr][sc - 1]) {\\n        flood(image, sr, sc - 1, color);\\n    }\\n}\\n```\\n\\n**I hope the explanation and code is clear! Good luck!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\npublic static int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    if (sr > image.length && sc > image[0].length) return image;\\n    if (image[sr][sc] == color) return image;\\n\\t\\n    flood(image, sr, sc, color);\\n\\t\\n    return image;\\n}\\n\\nprivate static void flood(int[][] image, int sr, int sc, int color) {\\n    int oldColor = image[sr][sc];\\n    image[sr][sc] = color;\\n\\t\\n    if (sr < image.length - 1 && oldColor == image[sr + 1][sc]) {\\n        flood(image, sr + 1, sc, color);\\n    }\\n\\t\\n    if (sr > 0 && oldColor == image[sr - 1][sc]) {\\n        flood(image, sr - 1, sc, color);\\n    }\\n\\t\\n    if (sc < image[sr].length - 1 && oldColor == image[sr][sc + 1]) {\\n        flood(image, sr, sc + 1, color);\\n    }\\n\\t\\n    if (sc > 0 && oldColor == image[sr][sc - 1]) {\\n        flood(image, sr, sc - 1, color);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2669997,
                "title": "python-dfs-clear-concise-recursive-solution-with-no-visited-set",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        deltas = [(1,0), (-1, 0), (0, 1), (0, -1)]\\n        starting_color = image[sr][sc]\\n                \\n        def dfs(r, c):\\n            row_boundary = 0 <= r < len(image)\\n            col_boundary = 0 <= c < len(image[0])\\n            if not row_boundary or not col_boundary or image[r][c] == color or image[r][c] != starting_color:\\n                return \\n            image[r][c] = color\\n            for delta_row, delta_col in deltas:\\n                dfs(r + delta_row, c + delta_col)\\n        \\n        dfs(sr, sc)\\n        return image",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        deltas = [(1,0), (-1, 0), (0, 1), (0, -1)]\\n        starting_color = image[sr][sc]\\n                \\n        def dfs(r, c):\\n            row_boundary = 0 <= r < len(image)\\n            col_boundary = 0 <= c < len(image[0])\\n            if not row_boundary or not col_boundary or image[r][c] == color or image[r][c] != starting_color:\\n                return \\n            image[r][c] = color\\n            for delta_row, delta_col in deltas:\\n                dfs(r + delta_row, c + delta_col)\\n        \\n        dfs(sr, sc)\\n        return image",
                "codeTag": "Java"
            },
            {
                "id": 2597294,
                "title": "python-bfs-easy-approach",
                "content": "Please upvote :)\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def bfs(self,sr,sc,color,image,start):\\n        image[sr][sc]=color\\n        q=deque()\\n        q.append([sr,sc])\\n        n=len(image)\\n        m=len(image[0])\\n        while len(q)>0:\\n            d,f=q.popleft()\\n            movements=[[-1, 0], [1, 0], [0, -1], [0, 1]]\\n            for dr,dc in movements:\\n                x=d+dr\\n                y=f+dc\\n                if x<n and x>=0 and y<m and y>=0 and image[x][y]==start:\\n                    image[x][y]=color\\n                    q.append([x,y])\\n        return image\\n            \\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start=image[sr][sc]\\n        if image[sr][sc]!=color:\\n            return self.bfs(sr,sc,color,image,start)\\n        else:\\n            return image\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def bfs(self,sr,sc,color,image,start):\\n        image[sr][sc]=color\\n        q=deque()\\n        q.append([sr,sc])\\n        n=len(image)\\n        m=len(image[0])\\n        while len(q)>0:\\n            d,f=q.popleft()\\n            movements=[[-1, 0], [1, 0], [0, -1], [0, 1]]\\n            for dr,dc in movements:\\n                x=d+dr\\n                y=f+dc\\n                if x<n and x>=0 and y<m and y>=0 and image[x][y]==start:\\n                    image[x][y]=color\\n                    q.append([x,y])\\n        return image\\n            \\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start=image[sr][sc]\\n        if image[sr][sc]!=color:\\n            return self.bfs(sr,sc,color,image,start)\\n        else:\\n            return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574740,
                "title": "dfs-javascript-solution-67-ms",
                "content": "### Solution:\\n```js\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const color = image[sr][sc];\\n    const dfs = (image, r, c, color, newColor) => {\\n        if (image[r][c] === color) {\\n            image[r][c] = newColor;\\n            if (r >= 1) {\\n                dfs(image, r-1, c, color, newColor);\\n            }\\n            if (c >= 1) {\\n                dfs(image, r, c-1, color, newColor);\\n            }\\n            if (r+1 < image.length) {\\n                dfs(image, r+1, c, color, newColor);\\n            }\\n            if (c+1 < image[0].length) {\\n                dfs(image, r, c+1, color, newColor);\\n            }\\n        }\\n    }\\n    if (newColor !== color) {\\n        dfs(image, sr, sc, color, newColor);\\n        return image;\\n    } else {\\n        return image;\\n    }\\n};\\n```\\n\\n### LeetCode Output:\\nRuntime: **67 ms**\\nMemory Usage: **44.1 MB**\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/799511464/)",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, newColor) {\\n    const color = image[sr][sc];\\n    const dfs = (image, r, c, color, newColor) => {\\n        if (image[r][c] === color) {\\n            image[r][c] = newColor;\\n            if (r >= 1) {\\n                dfs(image, r-1, c, color, newColor);\\n            }\\n            if (c >= 1) {\\n                dfs(image, r, c-1, color, newColor);\\n            }\\n            if (r+1 < image.length) {\\n                dfs(image, r+1, c, color, newColor);\\n            }\\n            if (c+1 < image[0].length) {\\n                dfs(image, r, c+1, color, newColor);\\n            }\\n        }\\n    }\\n    if (newColor !== color) {\\n        dfs(image, sr, sc, color, newColor);\\n        return image;\\n    } else {\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2223903,
                "title": "c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        int color = image[sr][sc];\\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n    \\n    void dfs(vector<vector<int>>& image, int r, int c, int color, int newColor) {\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\\n            if (r+1 < image.size()) dfs(image, r+1, c, color, newColor);\\n            if (c+1 < image[0].size()) dfs(image, r, c+1, color, newColor);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        int color = image[sr][sc];\\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n    \\n    void dfs(vector<vector<int>>& image, int r, int c, int color, int newColor) {\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\\n            if (r+1 < image.size()) dfs(image, r+1, c, color, newColor);\\n            if (c+1 < image[0].size()) dfs(image, r, c+1, color, newColor);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133386,
                "title": "javascript-clear-simple-dfs-bfs",
                "content": "**DFS Approach**\\n```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let start = image[sr][sc];\\n    image[sr][sc] = newColor;\\n    dfs(image, sr, sc, start, newColor);\\n    return image;\\n};\\n\\nfunction dfs(image, sr, sc, start, newColor) {\\n    if (isValid(image, sr-1, sc, start, newColor)) {\\n        image[sr-1][sc] = newColor;\\n        dfs(image, sr-1, sc, start, newColor);\\n    }\\n    if (isValid(image, sr+1, sc, start, newColor)) {\\n        image[sr+1][sc] = newColor;\\n        dfs(image, sr+1, sc, start, newColor);\\n    }\\n    if (isValid(image, sr, sc-1, start, newColor)) {\\n        image[sr][sc-1] = newColor;\\n        dfs(image, sr, sc-1, start, newColor);\\n    }\\n    if (isValid(image, sr, sc+1, start, newColor)) {\\n        image[sr][sc+1] = newColor;\\n        dfs(image, sr, sc+1, start, newColor);\\n    }\\n}\\n\\nfunction isValid(image, x, y, startColor, newColor) {\\n    if (x >= 0 && x < image.length && y >= 0 && y < image[0].length && image[x][y] === startColor && image[x][y] !== newColor) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n```\\n\\n**BFS Approach**\\n```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let start = image[sr][sc];\\n    let queue = [[sr,sc]];\\n    image[sr][sc] = newColor;\\n    while (queue.length > 0) {\\n        console.log(queue);\\n        let [x, y] = queue.shift();\\n        processNeighbors(queue, image, x, y, start, newColor); \\n    }\\n    return image;\\n};\\n\\nfunction processNeighbors(queue, image, sr, sc, start, newColor) {\\n    if (isValid(image, sr-1, sc, start, newColor)) {\\n        image[sr-1][sc] = newColor;\\n        queue.push([sr-1, sc]);\\n    }\\n    if (isValid(image, sr+1, sc, start, newColor)) {\\n        image[sr+1][sc] = newColor;\\n        queue.push([sr+1, sc]);\\n    }\\n    if (isValid(image, sr, sc-1, start, newColor)) {\\n        image[sr][sc-1] = newColor;\\n        queue.push([sr, sc-1]);\\n    }\\n    if (isValid(image, sr, sc+1, start, newColor)) {\\n        image[sr][sc+1] = newColor;\\n        queue.push([sr, sc+1]);\\n    }\\n}\\n\\nfunction isValid(image, x, y, startColor, newColor) {\\n    if (x >= 0 && x < image.length && y >= 0 && y < image[0].length && image[x][y] === startColor && image[x][y] !== newColor) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let start = image[sr][sc];\\n    image[sr][sc] = newColor;\\n    dfs(image, sr, sc, start, newColor);\\n    return image;\\n};\\n\\nfunction dfs(image, sr, sc, start, newColor) {\\n    if (isValid(image, sr-1, sc, start, newColor)) {\\n        image[sr-1][sc] = newColor;\\n        dfs(image, sr-1, sc, start, newColor);\\n    }\\n    if (isValid(image, sr+1, sc, start, newColor)) {\\n        image[sr+1][sc] = newColor;\\n        dfs(image, sr+1, sc, start, newColor);\\n    }\\n    if (isValid(image, sr, sc-1, start, newColor)) {\\n        image[sr][sc-1] = newColor;\\n        dfs(image, sr, sc-1, start, newColor);\\n    }\\n    if (isValid(image, sr, sc+1, start, newColor)) {\\n        image[sr][sc+1] = newColor;\\n        dfs(image, sr, sc+1, start, newColor);\\n    }\\n}\\n\\nfunction isValid(image, x, y, startColor, newColor) {\\n    if (x >= 0 && x < image.length && y >= 0 && y < image[0].length && image[x][y] === startColor && image[x][y] !== newColor) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n```\n```\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let start = image[sr][sc];\\n    let queue = [[sr,sc]];\\n    image[sr][sc] = newColor;\\n    while (queue.length > 0) {\\n        console.log(queue);\\n        let [x, y] = queue.shift();\\n        processNeighbors(queue, image, x, y, start, newColor); \\n    }\\n    return image;\\n};\\n\\nfunction processNeighbors(queue, image, sr, sc, start, newColor) {\\n    if (isValid(image, sr-1, sc, start, newColor)) {\\n        image[sr-1][sc] = newColor;\\n        queue.push([sr-1, sc]);\\n    }\\n    if (isValid(image, sr+1, sc, start, newColor)) {\\n        image[sr+1][sc] = newColor;\\n        queue.push([sr+1, sc]);\\n    }\\n    if (isValid(image, sr, sc-1, start, newColor)) {\\n        image[sr][sc-1] = newColor;\\n        queue.push([sr, sc-1]);\\n    }\\n    if (isValid(image, sr, sc+1, start, newColor)) {\\n        image[sr][sc+1] = newColor;\\n        queue.push([sr, sc+1]);\\n    }\\n}\\n\\nfunction isValid(image, x, y, startColor, newColor) {\\n    if (x >= 0 && x < image.length && y >= 0 && y < image[0].length && image[x][y] === startColor && image[x][y] !== newColor) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815491,
                "title": "python-easy-solution",
                "content": "class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n          \\n        def dfs(image,sr,sc,newColor):\\n            nonlocal sourceColor\\n            \\n            ##Out of bound check\\n            if sr<0 or sr>=len(image):\\n                return\\n            if sc<0 or sc>=len(image[0]):\\n                return \\n            if image[sr][sc]!=sourceColor:\\n                return \\n            \\n            image[sr][sc]=newColor\\n\\n            dfs(image,sr-1,sc,newColor)##top\\n            dfs(image,sr,sc-1,newColor)##left\\n            dfs(image,sr,sc+1,newColor)##right\\n            dfs(image,sr+1,sc,newColor)#down\\n            \\n            \\n        sourceColor=image[sr][sc]\\n        if newColor==sourceColor:\\n            return image\\n        dfs(image,sr,sc,newColor)\\n        return image\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n          \\n        def dfs(image,sr,sc,newColor):\\n            nonlocal sourceColor\\n            \\n            ##Out of bound check\\n            if sr<0 or sr>=len(image):\\n                return\\n            if sc<0 or sc>=len(image[0]):\\n                return \\n            if image[sr][sc]!=sourceColor:\\n                return \\n            \\n            image[sr][sc]=newColor\\n\\n            dfs(image,sr-1,sc,newColor)##top\\n            dfs(image,sr,sc-1,newColor)##left\\n            dfs(image,sr,sc+1,newColor)##right\\n            dfs(image,sr+1,sc,newColor)#down\\n            \\n            \\n        sourceColor=image[sr][sc]\\n        if newColor==sourceColor:\\n            return image\\n        dfs(image,sr,sc,newColor)\\n        return image\\n",
                "codeTag": "Java"
            },
            {
                "id": 1750076,
                "title": "go-golang-dfs-solution-with-commentary",
                "content": "```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    // if starting pixel is already of the new color\\n    // the image won\\'t be changed, because either no one connects to it\\n    // ex: 1 1 1\\n    //     1 2 1\\n    //.    1 0 1\\n    // sr, sc = 1, newColor = 2\\n    // or everyone that is connected to it\\n    // already has the new color\\n    // ex: 1 2 2\\n    //     1 2 1\\n    //.    1 0 1\\n    if (image[sr][sc] != newColor) {\\n        dfs(image, sr, sc, image[sr][sc], newColor)\\n    }\\n    return image\\n}\\n\\nfunc dfs(image [][]int, r, c, color, newColor int) {\\n    // check that the new target pixel has a valid color\\n    if image[r][c] != color {\\n        return\\n    }\\n    \\n    // paint\\n    image[r][c] = newColor\\n\\t\\n    // check 4 directions\\n    \\n    // move to the south of the same column\\n    if (r >= 1) {\\n        dfs(image, r-1, c, color, newColor)\\n    }\\n    \\n    // move to the east of the same row\\n    if (c >= 1) {\\n        dfs(image, r, c-1, color, newColor)\\n    }\\n    \\n    // move to the north if the same column\\n    if (r+1 < len(image)) {\\n        dfs(image, r+1, c, color, newColor)\\n    }\\n    \\n    // move to the west of the same row\\n    if (c+1 < len(image[0])) {\\n        dfs(image, r, c+1, color, newColor)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\\n    // if starting pixel is already of the new color\\n    // the image won\\'t be changed, because either no one connects to it\\n    // ex: 1 1 1\\n    //     1 2 1\\n    //.    1 0 1\\n    // sr, sc = 1, newColor = 2\\n    // or everyone that is connected to it\\n    // already has the new color\\n    // ex: 1 2 2\\n    //     1 2 1\\n    //.    1 0 1\\n    if (image[sr][sc] != newColor) {\\n        dfs(image, sr, sc, image[sr][sc], newColor)\\n    }\\n    return image\\n}\\n\\nfunc dfs(image [][]int, r, c, color, newColor int) {\\n    // check that the new target pixel has a valid color\\n    if image[r][c] != color {\\n        return\\n    }\\n    \\n    // paint\\n    image[r][c] = newColor\\n\\t\\n    // check 4 directions\\n    \\n    // move to the south of the same column\\n    if (r >= 1) {\\n        dfs(image, r-1, c, color, newColor)\\n    }\\n    \\n    // move to the east of the same row\\n    if (c >= 1) {\\n        dfs(image, r, c-1, color, newColor)\\n    }\\n    \\n    // move to the north if the same column\\n    if (r+1 < len(image)) {\\n        dfs(image, r+1, c, color, newColor)\\n    }\\n    \\n    // move to the west of the same row\\n    if (c+1 < len(image[0])) {\\n        dfs(image, r, c+1, color, newColor)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1655758,
                "title": "python-simple-recursive-dfs-explained",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        row = len(image)\\n        col = len(image[0])\\n        startingColor = image[sr][sc]\\n        \\n        visited = [[0 for x in range(col)] for y in range(row)]\\n        \\n        def dfs(i, j):\\n            # if the current node is not of the starting color\\n            # or is not a valid cell, return, we don\\'t have work here\\n            if i < 0 or i > row - 1 or j < 0 or j > col - 1 or image[i][j] != startingColor:\\n                return\\n            \\n            # return if current node is visited\\n            # mark it as visited otherwise\\n            if visited[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            # update the color on this node\\n            image[i][j] = newColor\\n            \\n            # recursively try all adjacent cells of the current node\\n            return dfs(i-1, j) or dfs(i+1, j) or dfs(i, j-1) or dfs(i, j+1)\\n        \\n        dfs(sr, sc)\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        row = len(image)\\n        col = len(image[0])\\n        startingColor = image[sr][sc]\\n        \\n        visited = [[0 for x in range(col)] for y in range(row)]\\n        \\n        def dfs(i, j):\\n            # if the current node is not of the starting color\\n            # or is not a valid cell, return, we don\\'t have work here\\n            if i < 0 or i > row - 1 or j < 0 or j > col - 1 or image[i][j] != startingColor:\\n                return\\n            \\n            # return if current node is visited\\n            # mark it as visited otherwise\\n            if visited[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            # update the color on this node\\n            image[i][j] = newColor\\n            \\n            # recursively try all adjacent cells of the current node\\n            return dfs(i-1, j) or dfs(i+1, j) or dfs(i, j-1) or dfs(i, j+1)\\n        \\n        dfs(sr, sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545242,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} newColor\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let originalColor = image[sr][sc]\\n    fill(image,sr,sc,newColor,originalColor)\\n    return image\\n};\\n\\nfunction fill(image,r,c,newColor,originalColor) {\\n    if(r >= image.length || r < 0 || c >= image[0].length || c < 0 || image[r][c] == newColor || image[r][c] != originalColor) {\\n        return\\n    }\\n    image[r][c] = newColor\\n    // top\\n    fill(image,r-1,c,newColor,originalColor)\\n    // bottom\\n    fill(image,r+1,c,newColor,originalColor)\\n    // left\\n    fill(image,r,c-1,newColor,originalColor)\\n    // right\\n    fill(image,r,c+1,newColor,originalColor)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} newColor\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, newColor) {\\n    let originalColor = image[sr][sc]\\n    fill(image,sr,sc,newColor,originalColor)\\n    return image\\n};\\n\\nfunction fill(image,r,c,newColor,originalColor) {\\n    if(r >= image.length || r < 0 || c >= image[0].length || c < 0 || image[r][c] == newColor || image[r][c] != originalColor) {\\n        return\\n    }\\n    image[r][c] = newColor\\n    // top\\n    fill(image,r-1,c,newColor,originalColor)\\n    // bottom\\n    fill(image,r+1,c,newColor,originalColor)\\n    // left\\n    fill(image,r,c-1,newColor,originalColor)\\n    // right\\n    fill(image,r,c+1,newColor,originalColor)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419965,
                "title": "you-don-t-need-visited",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        solve(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }\\n    \\n    public void solve(int[][] image, int i, int j,int oc, int c){\\n        if(i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != oc || image[i][j] == c) return;\\n        image[i][j] = c; // modify the matrix itself, and no need to maintain a visited array\\n        solve(image,i-1,j,oc,c);\\n        solve(image,i,j-1,oc,c);\\n        solve(image,i+1,j,oc,c);\\n        solve(image,i,j+1,oc,c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        \\n        solve(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }\\n    \\n    public void solve(int[][] image, int i, int j,int oc, int c){\\n        if(i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != oc || image[i][j] == c) return;\\n        image[i][j] = c; // modify the matrix itself, and no need to maintain a visited array\\n        solve(image,i-1,j,oc,c);\\n        solve(image,i,j-1,oc,c);\\n        solve(image,i+1,j,oc,c);\\n        solve(image,i,j+1,oc,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627115,
                "title": "python-bfs",
                "content": "IDEA: Keep on appending the neighbours while updating the value at current position\\n\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        if image[sr][sc] == newColor: return image\\n\\n        # BFS Implementation \\n        fringe, old_color = [(sr,sc)], image[sr][sc]\\n        while fringe:\\n            curr_row, curr_col = fringe.pop(0)\\n\\n            if 0 <= curr_row < len(image) and 0 <= curr_col < len(image[0]) and image[curr_row][curr_col] == old_color:\\n                image[curr_row][curr_col] = newColor\\n                fringe.append((curr_row - 1, curr_col))\\n                fringe.append((curr_row + 1, curr_col))\\n                fringe.append((curr_row, curr_col + 1))\\n                fringe.append((curr_row, curr_col - 1))\\n\\n        return image\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        if image[sr][sc] == newColor: return image\\n\\n        # BFS Implementation \\n        fringe, old_color = [(sr,sc)], image[sr][sc]\\n        while fringe:\\n            curr_row, curr_col = fringe.pop(0)\\n\\n            if 0 <= curr_row < len(image) and 0 <= curr_col < len(image[0]) and image[curr_row][curr_col] == old_color:\\n                image[curr_row][curr_col] = newColor\\n                fringe.append((curr_row - 1, curr_col))\\n                fringe.append((curr_row + 1, curr_col))\\n                fringe.append((curr_row, curr_col + 1))\\n                fringe.append((curr_row, curr_col - 1))\\n\\n        return image\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626776,
                "title": "ruby-dfs-recursion-beats-90-with-explanation-and-a-question-for-others",
                "content": "1. This is a perfect problem to solve recursively/use DFS.  We know we want to take any adj pixels and change their colors if the color of that pixel matches the first pixel\\'s color.\\n2. The first base case (image[sr][sc] == new_color) exists to make sure we skip any case where our first click is on a \"new_color\" pixel. We can just return since it\\'s already correctly filled.\\n3. When we fill, we want to check to make sure the pixel is the right color, then change the color.  \\n4. The conditionals check if the location for up, down, left and right are in bounds.  I\\'ve used a dirs array and helper method for checking in bounds before and for some reason, this seems to have the best performance.  Last week, I had a HackerRank tech screen and this implementation passed but the in-bounds helper method had a stack overflow on the super long test case.  To be honest, I\\'m not entirely sure why it should make a difference so if anyone knows, I\\'d love to hear it.\\n\\n```\\ndef flood_fill(image, sr, sc, new_color)\\n    return image if image[sr][sc] == new_color \\n    fill(image, sr, sc, new_color, image[sr][sc])\\n    return image\\nend\\n\\ndef fill(image, sr, sc, new_color, old_color)\\n    return if image[sr][sc] != old_color\\n    image[sr][sc] = new_color\\n    fill(image, sr-1, sc, new_color, old_color) if sr > 0 \\n    fill(image, sr, sc-1, new_color, old_color) if sc > 0 \\n    fill(image, sr+1, sc, new_color, old_color) if sr < image.length-1\\n    fill(image, sr, sc+1, new_color, old_color) if sc < image[0].length-1\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef flood_fill(image, sr, sc, new_color)\\n    return image if image[sr][sc] == new_color \\n    fill(image, sr, sc, new_color, image[sr][sc])\\n    return image\\nend\\n\\ndef fill(image, sr, sc, new_color, old_color)\\n    return if image[sr][sc] != old_color\\n    image[sr][sc] = new_color\\n    fill(image, sr-1, sc, new_color, old_color) if sr > 0 \\n    fill(image, sr, sc-1, new_color, old_color) if sc > 0 \\n    fill(image, sr+1, sc, new_color, old_color) if sr < image.length-1\\n    fill(image, sr, sc+1, new_color, old_color) if sc < image[0].length-1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 480901,
                "title": "python-dfs-and-bfs",
                "content": "1. DFS\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        neis = [[0,1],[1,0],[-1,0],[0,-1]]\\n        m = len(image)\\n        n = len(image[0])\\n        \\n        def dfs(row,col,oldColor):\\n            for nei in neis:\\n                x = row+nei[0]\\n                y = col+nei[1]\\n                if x<m and x>=0 and y<n and y>=0 and image[x][y]==oldColor:\\n                    image[x][y]=newColor\\n                    dfs(x,y,oldColor)\\n        \\n        if image[sr][sc]==newColor:\\n            return image\\n        else:\\n            oldColor = image[sr][sc]\\n            image[sr][sc]=newColor\\n            dfs(sr,sc,oldColor)\\n            return image\\n \\n```\\n\\n2. BFS\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        neis = [[0,1],[1,0],[-1,0],[0,-1]]\\n        m = len(image)\\n        n = len(image[0])\\n        \\n        def bfs(row,col,oldColor):\\n            q = [[row,col]]\\n            while q:\\n                x_,y_ = q.pop(0)\\n                for nei in neis:\\n                    x = x_+nei[0]\\n                    y = y_+nei[1]\\n                    if x<m and x>=0 and y<n and y>=0 and image[x][y]==oldColor:\\n                        image[x][y]=newColor\\n                        q.append([x,y])\\n                        \\n        \\n        if image[sr][sc]==newColor:\\n            return image\\n        else:\\n            oldColor = image[sr][sc]\\n            image[sr][sc]=newColor\\n            bfs(sr,sc,oldColor)\\n            return image\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        neis = [[0,1],[1,0],[-1,0],[0,-1]]\\n        m = len(image)\\n        n = len(image[0])\\n        \\n        def dfs(row,col,oldColor):\\n            for nei in neis:\\n                x = row+nei[0]\\n                y = col+nei[1]\\n                if x<m and x>=0 and y<n and y>=0 and image[x][y]==oldColor:\\n                    image[x][y]=newColor\\n                    dfs(x,y,oldColor)\\n        \\n        if image[sr][sc]==newColor:\\n            return image\\n        else:\\n            oldColor = image[sr][sc]\\n            image[sr][sc]=newColor\\n            dfs(sr,sc,oldColor)\\n            return image\\n \\n```\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        neis = [[0,1],[1,0],[-1,0],[0,-1]]\\n        m = len(image)\\n        n = len(image[0])\\n        \\n        def bfs(row,col,oldColor):\\n            q = [[row,col]]\\n            while q:\\n                x_,y_ = q.pop(0)\\n                for nei in neis:\\n                    x = x_+nei[0]\\n                    y = y_+nei[1]\\n                    if x<m and x>=0 and y<n and y>=0 and image[x][y]==oldColor:\\n                        image[x][y]=newColor\\n                        q.append([x,y])\\n                        \\n        \\n        if image[sr][sc]==newColor:\\n            return image\\n        else:\\n            oldColor = image[sr][sc]\\n            image[sr][sc]=newColor\\n            bfs(sr,sc,oldColor)\\n            return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300641,
                "title": "6-lines-python-dfs",
                "content": "```python\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        if image[sr][sc] != newColor:\\n            old, image[sr][sc], m, n = image[sr][sc], newColor, len(image), len(image[0])\\n            for i, j in zip((sr, sr+1, sr, sr-1), (sc+1, sc, sc-1, sc)):\\n                if 0 <= i < m and 0 <= j < n and image[i][j] == old:\\n                    self.floodFill(image, i, j, newColor)\\n        return image\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        if image[sr][sc] != newColor:\\n            old, image[sr][sc], m, n = image[sr][sc], newColor, len(image), len(image[0])\\n            for i, j in zip((sr, sr+1, sr, sr-1), (sc+1, sc, sc-1, sc)):\\n                if 0 <= i < m and 0 <= j < n and image[i][j] == old:\\n                    self.floodFill(image, i, j, newColor)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144296,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        color = image[sr][sc]\\n        if newColor == color:\\n            return image\\n\\n        self.dfs(image, sr, sc, newColor, color)\\n        return image\\n\\n    def dfs(self, image, r, c, newColor, color):\\n        m, n = len(image), len(image[0])\\n        directions = [(0,-1), (1,0), (0,1), (-1,0)]\\n        image[r][c] = newColor\\n        for d in directions:\\n            nr, nc = r + d[0], c + d[1]\\n            if 0 <= nr < m and 0 <= nc < n and image[nr][nc] == color:\\n                self.dfs(image, nr, nc, newColor, color)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        color = image[sr][sc]\\n        if newColor == color:\\n            return image\\n\\n        self.dfs(image, sr, sc, newColor, color)\\n        return image\\n\\n    def dfs(self, image, r, c, newColor, color):\\n        m, n = len(image), len(image[0])\\n        directions = [(0,-1), (1,0), (0,1), (-1,0)]\\n        image[r][c] = newColor\\n        for d in directions:\\n            nr, nc = r + d[0], c + d[1]\\n            if 0 <= nr < m and 0 <= nc < n and image[nr][nc] == color:\\n                self.dfs(image, nr, nc, newColor, color)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109582,
                "title": "c-dfs-with-comments",
                "content": "This is easy practice problem of DFS. There is no need of having visited array.\\n```\\nclass Solution {\\n    int orig, nc; // store golobals to reduce function call args size\\n    void dfs(vector<vector<int>>& i, int r, int c) {\\n        if (r >= i.size() || c >= i[0].size())\\n            return;\\n        if (i[r][c] != orig) // this pixel isn't same, don't replace\\n            return;\\n        i[r][c] = nc;\\n        dfs(i, r-1, c);\\n        dfs(i, r, c+1);\\n        dfs(i, r+1, c);\\n        dfs(i, r, c-1); \\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if (newColor == image[sr][sc])\\n            return image; // we don't need anything to do\\n        orig = image[sr][sc];\\n        nc = newColor;\\n        dfs(image, sr, sc);\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int orig, nc; // store golobals to reduce function call args size\\n    void dfs(vector<vector<int>>& i, int r, int c) {\\n        if (r >= i.size() || c >= i[0].size())\\n            return;\\n        if (i[r][c] != orig) // this pixel isn't same, don't replace\\n            return;\\n        i[r][c] = nc;\\n        dfs(i, r-1, c);\\n        dfs(i, r, c+1);\\n        dfs(i, r+1, c);\\n        dfs(i, r, c-1); \\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if (newColor == image[sr][sc])\\n            return image; // we don't need anything to do\\n        orig = image[sr][sc];\\n        nc = newColor;\\n        dfs(image, sr, sc);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932583,
                "title": "flood-fill-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void changeColor(vector<vector<int>>& image, int x, int y, int color, int original)\\n    {\\n        if(image[x][y]==original)\\n        {\\n            image[x][y] = color;\\n\\n            if ((x + 1) < image.size() && image[x + 1][y] == original)\\n                changeColor(image, x + 1, y, color, original);\\n            if ((y + 1) < image[0].size() && image[x][y + 1] == original)\\n                changeColor(image, x, y + 1, color, original);\\n            if ((x - 1) >= 0 && image[x - 1][y] == original)\\n                changeColor(image, x - 1, y, color, original);\\n            if ((y - 1) >= 0 && image[x][y - 1] == original)\\n                changeColor(image, x, y - 1, color, original);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int original = image[sr][sc];\\n        if(color==original)\\n            return image;\\n        \\n        changeColor(image, sr, sc, color, original);\\n        return image;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1be26002-a6ae-4e0c-a9ae-7ae512906fbd_1692465338.9774837.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void changeColor(vector<vector<int>>& image, int x, int y, int color, int original)\\n    {\\n        if(image[x][y]==original)\\n        {\\n            image[x][y] = color;\\n\\n            if ((x + 1) < image.size() && image[x + 1][y] == original)\\n                changeColor(image, x + 1, y, color, original);\\n            if ((y + 1) < image[0].size() && image[x][y + 1] == original)\\n                changeColor(image, x, y + 1, color, original);\\n            if ((x - 1) >= 0 && image[x - 1][y] == original)\\n                changeColor(image, x - 1, y, color, original);\\n            if ((y - 1) >= 0 && image[x][y - 1] == original)\\n                changeColor(image, x, y - 1, color, original);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int original = image[sr][sc];\\n        if(color==original)\\n            return image;\\n        \\n        changeColor(image, sr, sc, color, original);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772563,
                "title": "simple-dfs-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def floodFill(self, grid: List[List[int]], x: int, y: int, color: int) -> List[List[int]]:\\n        curr = grid[x][y]\\n        n = len(grid)\\n        m = len(grid[0])\\n        def dfs(i, j):\\n            if 0 <= i < n and 0 <= j < m and grid[i][j] == curr and grid[i][j] != color:\\n                grid[i][j] = color\\n                dfs(i+1, j)\\n                dfs(i-1, j)\\n                dfs(i, j+1)\\n                dfs(i, j-1)\\n        dfs(x, y)\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, grid: List[List[int]], x: int, y: int, color: int) -> List[List[int]]:\\n        curr = grid[x][y]\\n        n = len(grid)\\n        m = len(grid[0])\\n        def dfs(i, j):\\n            if 0 <= i < n and 0 <= j < m and grid[i][j] == curr and grid[i][j] != color:\\n                grid[i][j] = color\\n                dfs(i+1, j)\\n                dfs(i-1, j)\\n                dfs(i, j+1)\\n                dfs(i, j-1)\\n        dfs(x, y)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756831,
                "title": "c-beautiful-dfs-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void floodFillDFS(int row, int col, int initialColor, int newColor, vector<vector<int>>& image) {\\n\\n        // Base case for recursion\\n        if (row < 0 || col < 0 || row >= image.size() || col >= image[0].size() || image[row][col] != initialColor)\\n            return;\\n\\n        // Update the current pixel color\\n        image[row][col] = newColor;\\n        \\n        // Recursive calls in 4 directions\\n        floodFillDFS(row - 1, col, initialColor, newColor, image); // Up\\n        floodFillDFS(row + 1, col, initialColor, newColor, image); // Down\\n        floodFillDFS(row, col - 1, initialColor, newColor, image); // Left\\n        floodFillDFS(row, col + 1, initialColor, newColor, image); // Right\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int initialColor = image[sr][sc];\\n        \\n        if (initialColor != newColor) {\\n            floodFillDFS(sr, sc, initialColor, newColor, image);\\n        }\\n        \\n        return image;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\n# Intuition\\n**DFS starting from the given pixel** and **update the color of each visited pixel** if it has the **same color as the initial color of given pixel**. By **exploring the neighboring pixels** in a **4-directional manner (up, down, left, and right)**, we can cover all the connected pixels of the same color.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the **initial color of the given pixel and final color are not the same colors**, **call the DFS function**.\\n- The **DFS function takes 5 parameters**:-\\n**row, column, initialColor, newColor, image grid**\\n\\n- **Inside the function:-**\\n  1) (base case) If the **row or column gets out of index of image vector** or the **color at the row and column is not equal to inital color, return**.\\n    2) (Update step) **Update the color at row and column to new color**.\\n    3) (Recursive step) **Recursively check for neighbouring pixels**.\\n- **Return the image.**\\n\\n\\n---\\n\\n# Complexity\\n- **Time complexity: O(m*n)** where m and n are dimensions of the grid.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(m*n)** For the call stack using recursion.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void floodFillDFS(int row, int col, int initialColor, int newColor, vector<vector<int>>& image) {\\n\\n        // Base case for recursion\\n        if (row < 0 || col < 0 || row >= image.size() || col >= image[0].size() || image[row][col] != initialColor)\\n            return;\\n\\n        // Update the current pixel color\\n        image[row][col] = newColor;\\n        \\n        // Recursive calls in 4 directions\\n        floodFillDFS(row - 1, col, initialColor, newColor, image); // Up\\n        floodFillDFS(row + 1, col, initialColor, newColor, image); // Down\\n        floodFillDFS(row, col - 1, initialColor, newColor, image); // Left\\n        floodFillDFS(row, col + 1, initialColor, newColor, image); // Right\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int initialColor = image[sr][sc];\\n        \\n        if (initialColor != newColor) {\\n            floodFillDFS(sr, sc, initialColor, newColor, image);\\n        }\\n        \\n        return image;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649068,
                "title": "easy-solution-like-or-upvote-if-it-helps-and-also-comment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach:\\n * The flood fill algorithm is used to fill connected regions of an image or a grid with a specific color.\\n * In this solution, we use a depth-first search (DFS) approach to perform the flood fill operation.\\n *\\n * 1. Create a boolean matrix \"vis\" to keep track of visited cells to avoid revisiting.\\n * 2. Get the original color of the starting cell (image[sr][sc]).\\n * 3. Call the recursive helper method ff to perform the flood fill operation.\\n *\\n * The helper method ff:\\n * - Checks if the current cell is out of bounds, already visited, or has a different color than the original color.\\n *   If any of these conditions are true, it returns.\\n * - If the current cell is valid, it updates the color of the cell to the target color and marks it as visited.\\n * - Recursively calls ff on the neighboring cells (up, down, left, right) to continue the flood fill operation.\\n *\\n * Finally, return the modified image.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        boolean [][] vis = new boolean[image.length][image[0].length];\\n        int orgColor = image[sr][sc];\\n        ff(image,sr,sc,color,vis,orgColor);\\n        return image;\\n    }\\n    public static void ff(int[][] image, int sr, int sc, int color,boolean[][] vis,int orgColor) {\\n        if(sr<0 ||sc< 0 || sc >= image[0].length || sr >= image.length ||   vis[sr][sc] == true||image[sr][sc] != orgColor) {\\n            return;\\n        }\\n        if(!vis[sr][sc])         {\\n            image[sr][sc] = color;\\n            vis[sr][sc] = true;\\n        }\\n        ff(image,sr-1,sc,color,vis,orgColor);\\n        ff(image,sr+1,sc,color,vis,orgColor);\\n        ff(image,sr,sc-1,color,vis,orgColor);\\n        ff(image,sr,sc+1,color,vis,orgColor);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        boolean [][] vis = new boolean[image.length][image[0].length];\\n        int orgColor = image[sr][sc];\\n        ff(image,sr,sc,color,vis,orgColor);\\n        return image;\\n    }\\n    public static void ff(int[][] image, int sr, int sc, int color,boolean[][] vis,int orgColor) {\\n        if(sr<0 ||sc< 0 || sc >= image[0].length || sr >= image.length ||   vis[sr][sc] == true||image[sr][sc] != orgColor) {\\n            return;\\n        }\\n        if(!vis[sr][sc])         {\\n            image[sr][sc] = color;\\n            vis[sr][sc] = true;\\n        }\\n        ff(image,sr-1,sc,color,vis,orgColor);\\n        ff(image,sr+1,sc,color,vis,orgColor);\\n        ff(image,sr,sc-1,color,vis,orgColor);\\n        ff(image,sr,sc+1,color,vis,orgColor);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625804,
                "title": "dfs-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image , int sr , int sc , int color , int currcolor)\\n    {\\n        if(sr<0 || sc<0 || sr>=image.size() || sc>=image[0].size() || image[sr][sc]!=currcolor || image[sr][sc]==color)\\n        {\\n            return;\\n        }\\n        \\n        image[sr][sc] = color; //marking all adjacent as new color\\n\\n        dfs(image , sr+1 ,sc , color , currcolor);\\n        dfs(image , sr ,sc+1 , color , currcolor);\\n        dfs(image , sr-1 ,sc , color , currcolor);\\n        dfs(image , sr ,sc-1 , color , currcolor);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        int currcolor  = image[sr][sc];\\n        dfs(image , sr , sc , color , currcolor);\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image , int sr , int sc , int color , int currcolor)\\n    {\\n        if(sr<0 || sc<0 || sr>=image.size() || sc>=image[0].size() || image[sr][sc]!=currcolor || image[sr][sc]==color)\\n        {\\n            return;\\n        }\\n        \\n        image[sr][sc] = color; //marking all adjacent as new color\\n\\n        dfs(image , sr+1 ,sc , color , currcolor);\\n        dfs(image , sr ,sc+1 , color , currcolor);\\n        dfs(image , sr-1 ,sc , color , currcolor);\\n        dfs(image , sr ,sc-1 , color , currcolor);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        int currcolor  = image[sr][sc];\\n        dfs(image , sr , sc , color , currcolor);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365469,
                "title": "best-and-easy-solution-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] img, int i, int j, int col) {\\n        if(img[i][j]==col)return img;\\n        fill(img,i,j,img[i][j], col);\\n        return img;\\n    }\\n\\n    public void fill(int[][] img, int i, int j, int col, int newcol){\\n        if(i<0 || j<0 || i>=img.length || j>=img[0].length || img[i][j]!=col)return;\\n        img[i][j]=newcol;\\n        fill(img, i-1, j, col, newcol);\\n        fill(img, i+1, j, col, newcol);\\n        fill(img, i, j-1, col, newcol);\\n        fill(img, i, j+1, col, newcol);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] img, int i, int j, int col) {\\n        if(img[i][j]==col)return img;\\n        fill(img,i,j,img[i][j], col);\\n        return img;\\n    }\\n\\n    public void fill(int[][] img, int i, int j, int col, int newcol){\\n        if(i<0 || j<0 || i>=img.length || j>=img[0].length || img[i][j]!=col)return;\\n        img[i][j]=newcol;\\n        fill(img, i-1, j, col, newcol);\\n        fill(img, i+1, j, col, newcol);\\n        fill(img, i, j-1, col, newcol);\\n        fill(img, i, j+1, col, newcol);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332535,
                "title": "easiest-dfs-ever-python-simple-english-language-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        def dfs(sr,sc,image,color,row,cols,source):\\n            #lets move towards edge case wt it its out of bond?? return nothing right\\n            if sr>=row or sr<0 or sc>=cols or sc<0:\\n                return\\n            #wt if our row and grid value is not equal to source?? edge case\\n            if image[sr][sc]!=source:\\n                return\\n            image[sr][sc]=color\\n            dfs(sr-1,sc,image,color,row,cols,source) #top search\\n            dfs(sr+1,sc,image,color,row,cols,source) #bottom search\\n            dfs(sr,sc-1,image,color,row,cols,source) #left search\\n            dfs(sr,sc+1,image,color,row,cols,source) #right search\\n        if image[sr][sc]==color:\\n            return image\\n        source=image[sr][sc]\\n        rows=len(image)\\n        cols=len(image[0])\\n        dfs(sr,sc,image,color,rows,cols,source)\\n        return image\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        def dfs(sr,sc,image,color,row,cols,source):\\n            #lets move towards edge case wt it its out of bond?? return nothing right\\n            if sr>=row or sr<0 or sc>=cols or sc<0:\\n                return\\n            #wt if our row and grid value is not equal to source?? edge case\\n            if image[sr][sc]!=source:\\n                return\\n            image[sr][sc]=color\\n            dfs(sr-1,sc,image,color,row,cols,source) #top search\\n            dfs(sr+1,sc,image,color,row,cols,source) #bottom search\\n            dfs(sr,sc-1,image,color,row,cols,source) #left search\\n            dfs(sr,sc+1,image,color,row,cols,source) #right search\\n        if image[sr][sc]==color:\\n            return image\\n        source=image[sr][sc]\\n        rows=len(image)\\n        cols=len(image[0])\\n        dfs(sr,sc,image,color,rows,cols,source)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205778,
                "title": "faster-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n   int [][]ans=image;\\n        int iniColor=image[sr][sc];\\n\\n        int delRow[]={-1,1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n        DFS(image,sr,sc,color,iniColor,ans,delRow,delCol);\\n        return ans;\\n    }\\n\\n    public void DFS(int[][] image,int sr, int sc, int color,int iniColor,int [][]ans,\\n    int delRow[],int delCol[]){\\n        ans[sr][sc]=color;\\n        int n=image.length;\\n        int m=image[0].length;\\n\\n        for(int i=0;i<4;i++){\\n            int nrow=sr+delRow[i];\\n            int ncol=sc+delCol[i];\\n\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && image[nrow][ncol]==iniColor &&\\n            ans[nrow][ncol]!=color){\\n                DFS(image,nrow,ncol,color,iniColor,ans,delRow,delCol);\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n   int [][]ans=image;\\n        int iniColor=image[sr][sc];\\n\\n        int delRow[]={-1,1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n        DFS(image,sr,sc,color,iniColor,ans,delRow,delCol);\\n        return ans;\\n    }\\n\\n    public void DFS(int[][] image,int sr, int sc, int color,int iniColor,int [][]ans,\\n    int delRow[],int delCol[]){\\n        ans[sr][sc]=color;\\n        int n=image.length;\\n        int m=image[0].length;\\n\\n        for(int i=0;i<4;i++){\\n            int nrow=sr+delRow[i];\\n            int ncol=sc+delCol[i];\\n\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && image[nrow][ncol]==iniColor &&\\n            ans[nrow][ncol]!=color){\\n                DFS(image,nrow,ncol,color,iniColor,ans,delRow,delCol);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166831,
                "title": "easy-iterative-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        if image[sr][sc] == color:\\n            return image\\n\\n        r = len(image)         #number of rows in matrix image\\n        c = len(image[0])      #number of columns in matrix image\\n        q = [(sr,sc)]          #queue to store adjacent unvisited cells  \\n        \\n        visited = {(sr,sc)}    # Set to store visited cells (to avoid cycle)\\n        while q:               # Execute until we are getting adjacent valid cells\\n\\n            x = q.pop()\\n            x1 = x[0]\\n            y1 = x[1]\\n            c1 = image[x1][y1]\\n\\n            if x1-1 >=0:\\n                if (x1-1,y1) not in visited and image[x1-1][y1] == c1 \\n                    q.append((x1-1,y1))\\n                    visited.add((x1-1,y1))\\n                    \\n            if x1+1 < r :\\n                if (x1+1,y1) not in visited and image[x1+1][y1] == c1:\\n                    q.append((x1+1,y1))\\n                    visited.add((x1+1,y1))\\n                   \\n            if y1-1 >=0:\\n                if (x1,y1-1) not in visited and image[x1][y1-1] == c1:\\n                    q.append((x1,y1-1))\\n                    visited.add((x1,y1-1))\\n                    \\n            if y1+1 < c :\\n                if (x1,y1+1) not in visited and image[x1][y1+1] == c1:\\n                    q.append((x1,y1+1))\\n                    visited.add((x1,y1+1))\\n\\n        # Now color all the valid cells with the given color\\n        for i in visited:\\n            image[i[0]][i[1]] = color\\n                    \\n        return image\\n        \\n        \\n\\n\\n            \\n\\n\\n             \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        if image[sr][sc] == color:\\n            return image\\n\\n        r = len(image)         #number of rows in matrix image\\n        c = len(image[0])      #number of columns in matrix image\\n        q = [(sr,sc)]          #queue to store adjacent unvisited cells  \\n        \\n        visited = {(sr,sc)}    # Set to store visited cells (to avoid cycle)\\n        while q:               # Execute until we are getting adjacent valid cells\\n\\n            x = q.pop()\\n            x1 = x[0]\\n            y1 = x[1]\\n            c1 = image[x1][y1]\\n\\n            if x1-1 >=0:\\n                if (x1-1,y1) not in visited and image[x1-1][y1] == c1 \\n                    q.append((x1-1,y1))\\n                    visited.add((x1-1,y1))\\n                    \\n            if x1+1 < r :\\n                if (x1+1,y1) not in visited and image[x1+1][y1] == c1:\\n                    q.append((x1+1,y1))\\n                    visited.add((x1+1,y1))\\n                   \\n            if y1-1 >=0:\\n                if (x1,y1-1) not in visited and image[x1][y1-1] == c1:\\n                    q.append((x1,y1-1))\\n                    visited.add((x1,y1-1))\\n                    \\n            if y1+1 < c :\\n                if (x1,y1+1) not in visited and image[x1][y1+1] == c1:\\n                    q.append((x1,y1+1))\\n                    visited.add((x1,y1+1))\\n\\n        # Now color all the valid cells with the given color\\n        for i in visited:\\n            image[i[0]][i[1]] = color\\n                    \\n        return image\\n        \\n        \\n\\n\\n            \\n\\n\\n             \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130915,
                "title": "fast-compact-and-space-efficient",
                "content": "# Intuition\\nDepth first search\\n\\n# Approach\\nif pixel color is same as new color then just return image it will save time\\n\\n# Complexity\\n- Time complexity:\\nO(i*j)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int i, int j, int color) {\\n        if(color==image[i][j])return image;\\n        paintPixel(i,j,image.length,image[0].length,image,color,image[i][j]);\\n        return image;\\n    }\\n    void paintPixel(int i,int j, int n, int m, int[][] grid,int c, int v){\\n        if(grid[i][j]==v ){\\n            grid[i][j]=c;\\n            if(isValidPixel(i+1,j,n,m))paintPixel(i+1,j,n,m,grid,c,v);\\n            if(isValidPixel(i,j+1,n,m))paintPixel(i,j+1,n,m,grid,c,v);\\n            if(isValidPixel(i-1,j,n,m))paintPixel(i-1,j,n,m,grid,c,v);\\n            if(isValidPixel(i,j-1,n,m))paintPixel(i,j-1,n,m,grid,c,v);      \\n        }\\n    }\\n    boolean isValidPixel(int i,int j, int n, int m){\\n        return (i>=0 && j>=0 && i<n && j<m );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int i, int j, int color) {\\n        if(color==image[i][j])return image;\\n        paintPixel(i,j,image.length,image[0].length,image,color,image[i][j]);\\n        return image;\\n    }\\n    void paintPixel(int i,int j, int n, int m, int[][] grid,int c, int v){\\n        if(grid[i][j]==v ){\\n            grid[i][j]=c;\\n            if(isValidPixel(i+1,j,n,m))paintPixel(i+1,j,n,m,grid,c,v);\\n            if(isValidPixel(i,j+1,n,m))paintPixel(i,j+1,n,m,grid,c,v);\\n            if(isValidPixel(i-1,j,n,m))paintPixel(i-1,j,n,m,grid,c,v);\\n            if(isValidPixel(i,j-1,n,m))paintPixel(i,j-1,n,m,grid,c,v);      \\n        }\\n    }\\n    boolean isValidPixel(int i,int j, int n, int m){\\n        return (i>=0 && j>=0 && i<n && j<m );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062997,
                "title": "0ms-dfs-java-solution-with-explaination",
                "content": "\\n# Approach\\n- Create a helper function that takes in the current row and column, the target color, and the replacement color as parameters.\\n- Within the function, first check if the current row or column is out of bounds of the image or if the current pixel color is not equal to the target color. If either is true, return.\\n- Otherwise, set the current pixel color to the replacement color.\\n- Call the helper function recursively on the pixels above, below, to the left, and to the right of the current pixel, with the same target and replacement color.\\n- Call the helper function with the initial starting row and column, target color, and replacement color.\\n- Return the modified image.\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        int srcColor=image[sr][sc];\\n        if(srcColor!=color){\\n            traverse(image,sr,sc,color,srcColor);\\n        }\\n        return image;\\n    }\\n\\n    public void traverse(int[][] image, int row, int col, int target, int srcColor) {\\n        if(row < 0 || row >= image.length || col < 0 || col >= image[row].length || image[row][col] != srcColor) {\\n            return;\\n        }\\n        image[row][col] = target;\\n        traverse(image, row, col + 1, target, srcColor);\\n        traverse(image, row, col -1, target, srcColor);\\n        traverse(image, row + 1, col, target, srcColor);\\n        traverse(image, row - 1, col, target, srcColor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        int srcColor=image[sr][sc];\\n        if(srcColor!=color){\\n            traverse(image,sr,sc,color,srcColor);\\n        }\\n        return image;\\n    }\\n\\n    public void traverse(int[][] image, int row, int col, int target, int srcColor) {\\n        if(row < 0 || row >= image.length || col < 0 || col >= image[row].length || image[row][col] != srcColor) {\\n            return;\\n        }\\n        image[row][col] = target;\\n        traverse(image, row, col + 1, target, srcColor);\\n        traverse(image, row, col -1, target, srcColor);\\n        traverse(image, row + 1, col, target, srcColor);\\n        traverse(image, row - 1, col, target, srcColor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024503,
                "title": "c-python-7ms-beats-93-96",
                "content": "\\n# Approach\\nFirst store the original color of the current pixel, check whether it is same as the required color or not, if same the return else change it to required color and the call the function again to do the same for pixels connected 4-directionally.\\n\\n\\n# Code\\nC++ / CPP\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int og_color = image[sr][sc];\\n        if( og_color == color ) return image;\\n\\n        image[sr][sc] = color;\\n\\n        if( sr>0 and image[sr-1][sc] == og_color ) floodFill(image, sr-1,sc,color);\\n\\n        if( sc>0 and image[sr][sc-1] == og_color) floodFill(image, sr,sc-1,color);\\n\\n        if( sr<image.size()-1 and image[sr+1][sc] == og_color) floodFill(image, sr+1,sc,color);\\n\\n        if( sc<image[0].size()-1 and image[sr][sc+1] == og_color) floodFill(image, sr,sc+1,color);\\n\\n            \\n        return image;\\n    }\\n};\\n```\\n---\\nPYTHON\\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        curr = image[sr][sc]\\n        if curr == color: return image\\n\\n        image[sr][sc] = color\\n\\n        if( sr > 0 and image[sr-1][sc] == curr ): self.floodFill(image, sr-1, sc, color)\\n\\n        if( sc > 0 and image[sr][sc-1] == curr ): self.floodFill(image, sr, sc-1, color)\\n\\n        if( sr < len(image)-1 and image[sr+1][sc] == curr ): self.floodFill(image, sr+1, sc, color)\\n\\n        if( sc < len(image[0])-1 and image[sr][sc+1] == curr ): self.floodFill(image, sr, sc+1, color)\\n\\n        return image\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int og_color = image[sr][sc];\\n        if( og_color == color ) return image;\\n\\n        image[sr][sc] = color;\\n\\n        if( sr>0 and image[sr-1][sc] == og_color ) floodFill(image, sr-1,sc,color);\\n\\n        if( sc>0 and image[sr][sc-1] == og_color) floodFill(image, sr,sc-1,color);\\n\\n        if( sr<image.size()-1 and image[sr+1][sc] == og_color) floodFill(image, sr+1,sc,color);\\n\\n        if( sc<image[0].size()-1 and image[sr][sc+1] == og_color) floodFill(image, sr,sc+1,color);\\n\\n            \\n        return image;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        curr = image[sr][sc]\\n        if curr == color: return image\\n\\n        image[sr][sc] = color\\n\\n        if( sr > 0 and image[sr-1][sc] == curr ): self.floodFill(image, sr-1, sc, color)\\n\\n        if( sc > 0 and image[sr][sc-1] == curr ): self.floodFill(image, sr, sc-1, color)\\n\\n        if( sr < len(image)-1 and image[sr+1][sc] == curr ): self.floodFill(image, sr+1, sc, color)\\n\\n        if( sc < len(image[0])-1 and image[sr][sc+1] == curr ): self.floodFill(image, sr, sc+1, color)\\n\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999802,
                "title": "python3-dfs-using-a-list-as-stack-and-store-indicators-in-a-2d-list",
                "content": "This is a similar problem with **200. Number of Islands (Medium)**.  \\nhttps://leetcode.com/problems/number-of-islands/discuss/2999675/python3-DFS-using-set()-or-2D-list  \\n\\nhttps://leetcode.com/submissions/detail/871422206/  \\nRuntime: 168 ms, faster than 37.66% of Python3 online submissions for Flood Fill.  \\nMemory Usage: 14.1 MB, less than 65.57% of Python3 online submissions for Flood Fill.  \\n```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        color_curr = image[sr][sc]\\n        if color_curr==color: return image\\n        n_row, n_col = len(image), len(image[0])\\n        visited = [[0]*n_col for _ in range(n_row)]\\n        image[sr][sc], l = color, [(sr, sc)]\\n        while l:\\n            ii, jj = l.pop(0)\\n            up, right, down, left = (ii-1,jj), (ii,jj+1), (ii+1,jj), (ii,jj-1)\\n            directions = []\\n            if up[0]>=0: directions.append(up)\\n            if right[1]<n_col: directions.append(right)\\n            if down[0]<n_row: directions.append(down)\\n            if left[1]>=0: directions.append(left)\\n            for d in directions:\\n                if image[d[0]][d[1]]==color_curr and visited[d[0]][d[1]]==0:\\n                    image[d[0]][d[1]] = color\\n                    visited[d[0]][d[1]] = 1\\n                    l.append(d)\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        color_curr = image[sr][sc]\\n        if color_curr==color: return image\\n        n_row, n_col = len(image), len(image[0])\\n        visited = [[0]*n_col for _ in range(n_row)]\\n        image[sr][sc], l = color, [(sr, sc)]\\n        while l:\\n            ii, jj = l.pop(0)\\n            up, right, down, left = (ii-1,jj), (ii,jj+1), (ii+1,jj), (ii,jj-1)\\n            directions = []\\n            if up[0]>=0: directions.append(up)\\n            if right[1]<n_col: directions.append(right)\\n            if down[0]<n_row: directions.append(down)\\n            if left[1]>=0: directions.append(left)\\n            for d in directions:\\n                if image[d[0]][d[1]]==color_curr and visited[d[0]][d[1]]==0:\\n                    image[d[0]][d[1]] = color\\n                    visited[d[0]][d[1]] = 1\\n                    l.append(d)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966533,
                "title": "simple-fastest-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int color) \\n    {\\n        if (image[sr][sc] != color)\\n        {\\n            Fill(image, sr, sc, image[sr][sc], color);\\n        }\\n        return image;\\n    }\\n    \\n    private static void Fill(int[][] image, int sr, int sc, int replacingColor, int newColor)\\n    {\\n        image[sr][sc] = newColor;\\n\\n        if (sr > 0 && image[sr - 1][sc] == replacingColor)\\n        {\\n            Fill(image, sr - 1, sc, replacingColor, newColor);\\n        }\\n        if (sr < image.Length - 1 && image[sr + 1][sc] == replacingColor)\\n        {\\n            Fill(image, sr + 1, sc, replacingColor, newColor);\\n        }\\n        if (sc > 0 && image[sr][sc - 1] == replacingColor)\\n        {\\n            Fill(image, sr, sc - 1, replacingColor, newColor);\\n        }\\n        if (sc < image[sr].Length - 1 && image[sr][sc + 1] == replacingColor)\\n        {\\n            Fill(image, sr, sc + 1, replacingColor, newColor);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int color) \\n    {\\n        if (image[sr][sc] != color)\\n        {\\n            Fill(image, sr, sc, image[sr][sc], color);\\n        }\\n        return image;\\n    }\\n    \\n    private static void Fill(int[][] image, int sr, int sc, int replacingColor, int newColor)\\n    {\\n        image[sr][sc] = newColor;\\n\\n        if (sr > 0 && image[sr - 1][sc] == replacingColor)\\n        {\\n            Fill(image, sr - 1, sc, replacingColor, newColor);\\n        }\\n        if (sr < image.Length - 1 && image[sr + 1][sc] == replacingColor)\\n        {\\n            Fill(image, sr + 1, sc, replacingColor, newColor);\\n        }\\n        if (sc > 0 && image[sr][sc - 1] == replacingColor)\\n        {\\n            Fill(image, sr, sc - 1, replacingColor, newColor);\\n        }\\n        if (sc < image[sr].Length - 1 && image[sr][sc + 1] == replacingColor)\\n        {\\n            Fill(image, sr, sc + 1, replacingColor, newColor);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934990,
                "title": "simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int sr, int sc, int newcolor,vector<vector<int>>& ans,int initial){\\n              ans[sr][sc] = newcolor; //Setting new color to the cell\\n              vector<int> delrow = {-1,0,1,0}; //Left right up down traversal\\n              vector<int> delcol = {0,-1,0,1};\\n                int m = ans.size();\\n                int n = ans[0].size();      \\n                //Simple bfs\\n              queue<pair<int,int>> q;\\n              q.push({sr,sc});\\n              while(!q.empty()){\\n                  int r = q.front().first;\\n                  int c = q.front().second;\\n                  q.pop();\\n                  //Checking in its all adjacent directions\\n                     for(int i=0;i<4;i++){\\n                   int nrow = r+delrow[i];\\n                   int ncol = c+delcol[i];\\n                   if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && \\n                   ans[nrow][ncol] == initial && ans[nrow][ncol] != newcolor){\\n                       ans[nrow][ncol]=newcolor;\\n                       q.push({nrow,ncol});\\n                   }\\n              }\\n              }\\n             \\n\\n\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n         vector<vector<int>> ans = image;\\n         int m = ans.size();\\n         int n = ans[0].size();     \\n         int initial = ans[sr][sc]; //Storing the color to be altered\\n              bfs(sr,sc,color,ans,initial);\\n              return ans;\\n             }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(int sr, int sc, int newcolor,vector<vector<int>>& ans,int initial){\\n              ans[sr][sc] = newcolor; //Setting new color to the cell\\n              vector<int> delrow = {-1,0,1,0}; //Left right up down traversal\\n              vector<int> delcol = {0,-1,0,1};\\n                int m = ans.size();\\n                int n = ans[0].size();      \\n                //Simple bfs\\n              queue<pair<int,int>> q;\\n              q.push({sr,sc});\\n              while(!q.empty()){\\n                  int r = q.front().first;\\n                  int c = q.front().second;\\n                  q.pop();\\n                  //Checking in its all adjacent directions\\n                     for(int i=0;i<4;i++){\\n                   int nrow = r+delrow[i];\\n                   int ncol = c+delcol[i];\\n                   if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && \\n                   ans[nrow][ncol] == initial && ans[nrow][ncol] != newcolor){\\n                       ans[nrow][ncol]=newcolor;\\n                       q.push({nrow,ncol});\\n                   }\\n              }\\n              }\\n             \\n\\n\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n         vector<vector<int>> ans = image;\\n         int m = ans.size();\\n         int n = ans[0].size();     \\n         int initial = ans[sr][sc]; //Storing the color to be altered\\n              bfs(sr,sc,color,ans,initial);\\n              return ans;\\n             }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925612,
                "title": "javascript-stacks-queues-and-recursion-modern-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart with stacks and iterate while `stack !== 0`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd to a stack `image[sr, sc]` and as long as `length !== 0` keep checking neighbours if they\\'re the same value as the initial target.\\n\\nIf current element from the stack is the same as the `newColor` continue with the loop.\\n\\n# Stacks\\n```\\nconst floodFill = (image, sr, sc, newColor) => {\\n    const stack = [[sr, sc]];\\n    const color = image[sr][sc];\\n    while(!!stack.length) {\\n        const [r, c] = stack.pop();\\n        if (image[r][c] === newColor) continue;\\n        if (image[r + 1]?.[c] === color) stack.push([r + 1, c]);\\n        if (image[r - 1]?.[c] === color) stack.push([r - 1, c]);\\n        if (image[r]  [c + 1] === color) stack.push([r, c + 1]);\\n        if (image[r]  [c - 1] === color) stack.push([r, c - 1]);\\n        image[r][c] = newColor;\\n    }\\n    return image;\\n};\\n```\\n\\n\\n# Queues\\n```\\nconst floodFill = (image, sr, sc, newColor) => {\\n    const stack = [[sr, sc]];\\n    const color = image[sr][sc];\\n    while(!!stack.length) {\\n        const [r, c] = queue.pop();\\n        if (image[r][c] === newColor) continue;\\n        if (image[r + 1]?.[c] === color) queue.unshift([r + 1, c]);\\n        if (image[r - 1]?.[c] === color) queue.unshift([r - 1, c]);\\n        if (image[r]  [c + 1] === color) queue.unshift([r, c + 1]);\\n        if (image[r]  [c - 1] === color) queue.unshift([r, c - 1]);\\n        image[r][c] = newColor;\\n    }\\n    return image;\\n};\\n```\\n\\n\\n# Recursion\\n```\\nvar floodFill = function(image, sr, sc, color) {\\n    const target = image[sr][sc];\\n    const [m, n] = [image.length, image[sr].length];\\n    function traverse(sr, sc) {\\n        if (sr <  0 || sc <  0) return;\\n        if (sr >= m || sc >= n) return;\\n        if (image[sr][sc] === color) return;\\n        if (image[sr][sc] !== target) return;\\n\\n        image[sr][sc] = color;\\n        traverse(sr, sc + 1);\\n        traverse(sr, sc - 1);\\n        traverse(sr + 1, sc);\\n        traverse(sr - 1, sc);\\n    }\\n    traverse(sr, sc);\\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nconst floodFill = (image, sr, sc, newColor) => {\\n    const stack = [[sr, sc]];\\n    const color = image[sr][sc];\\n    while(!!stack.length) {\\n        const [r, c] = stack.pop();\\n        if (image[r][c] === newColor) continue;\\n        if (image[r + 1]?.[c] === color) stack.push([r + 1, c]);\\n        if (image[r - 1]?.[c] === color) stack.push([r - 1, c]);\\n        if (image[r]  [c + 1] === color) stack.push([r, c + 1]);\\n        if (image[r]  [c - 1] === color) stack.push([r, c - 1]);\\n        image[r][c] = newColor;\\n    }\\n    return image;\\n};\\n```\n```\\nconst floodFill = (image, sr, sc, newColor) => {\\n    const stack = [[sr, sc]];\\n    const color = image[sr][sc];\\n    while(!!stack.length) {\\n        const [r, c] = queue.pop();\\n        if (image[r][c] === newColor) continue;\\n        if (image[r + 1]?.[c] === color) queue.unshift([r + 1, c]);\\n        if (image[r - 1]?.[c] === color) queue.unshift([r - 1, c]);\\n        if (image[r]  [c + 1] === color) queue.unshift([r, c + 1]);\\n        if (image[r]  [c - 1] === color) queue.unshift([r, c - 1]);\\n        image[r][c] = newColor;\\n    }\\n    return image;\\n};\\n```\n```\\nvar floodFill = function(image, sr, sc, color) {\\n    const target = image[sr][sc];\\n    const [m, n] = [image.length, image[sr].length];\\n    function traverse(sr, sc) {\\n        if (sr <  0 || sc <  0) return;\\n        if (sr >= m || sc >= n) return;\\n        if (image[sr][sc] === color) return;\\n        if (image[sr][sc] !== target) return;\\n\\n        image[sr][sc] = color;\\n        traverse(sr, sc + 1);\\n        traverse(sr, sc - 1);\\n        traverse(sr + 1, sc);\\n        traverse(sr - 1, sc);\\n    }\\n    traverse(sr, sc);\\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2835897,
                "title": "easy-c-solution-bfs-dfs-both-approaches",
                "content": "**BFS APPROACH**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n= image.size(); int m= image[0].size();\\n        bool vis[n][m]; // create visited array\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        int original= image[sr][sc];\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while (!q.empty()){\\n            int i= q.front().first; int j= q.front().second;\\n            vis[i][j]=1;\\n            image[i][j]= color;\\n            if (i-1>=0 && !vis[i-1][j] && image[i-1][j]==original){\\n                q.push({i-1,j});\\n            }\\n            if (i+1<n && !vis[i+1][j] && image[i+1][j]==original){\\n                q.push({i+1,j});\\n            }\\n            if (j-1>=0 && !vis[i][j-1] && image[i][j-1]==original){\\n                q.push({i,j-1});\\n            }\\n            if (j+1<m && !vis[i][j+1] && image[i][j+1]==original){\\n                q.push({i,j+1});\\n            }\\n            q.pop();\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\n**DFS APPROACH**\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image, int initial, int i, int j, int color){\\n        int n= image.size(); int m= image[0].size();\\n        if (i<0 || j<0 || i>=n || j>=m)return;\\n        if (image[i][j]!=initial || image[i][j]==color)return;\\n        image[i][j]= color;\\n        dfs(image,initial,i-1,j,color);\\n        dfs(image,initial,i+1,j,color);\\n        dfs(image,initial,i,j-1,color);\\n        dfs(image,initial,i,j+1,color);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        dfs(image,image[sr][sc],sr,sc,color);\\n        return image;\\n    }\\n};\\n```\\nSee DFS explaination at : https://leetcode.com/problems/flood-fill/discuss/2835910/DFS-Explained-oror-C%2B%2B-oror-No-Visited-Matrix-Required",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n= image.size(); int m= image[0].size();\\n        bool vis[n][m]; // create visited array\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        int original= image[sr][sc];\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while (!q.empty()){\\n            int i= q.front().first; int j= q.front().second;\\n            vis[i][j]=1;\\n            image[i][j]= color;\\n            if (i-1>=0 && !vis[i-1][j] && image[i-1][j]==original){\\n                q.push({i-1,j});\\n            }\\n            if (i+1<n && !vis[i+1][j] && image[i+1][j]==original){\\n                q.push({i+1,j});\\n            }\\n            if (j-1>=0 && !vis[i][j-1] && image[i][j-1]==original){\\n                q.push({i,j-1});\\n            }\\n            if (j+1<m && !vis[i][j+1] && image[i][j+1]==original){\\n                q.push({i,j+1});\\n            }\\n            q.pop();\\n        }\\n        return image;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image, int initial, int i, int j, int color){\\n        int n= image.size(); int m= image[0].size();\\n        if (i<0 || j<0 || i>=n || j>=m)return;\\n        if (image[i][j]!=initial || image[i][j]==color)return;\\n        image[i][j]= color;\\n        dfs(image,initial,i-1,j,color);\\n        dfs(image,initial,i+1,j,color);\\n        dfs(image,initial,i,j-1,color);\\n        dfs(image,initial,i,j+1,color);\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        dfs(image,image[sr][sc],sr,sc,color);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813658,
                "title": "1ms-solution-fully-explained-every-line-of-code-dfs-approach-o-n-x-m-java",
                "content": "\\n# Approach : Using DFS Approach (You can also use BFS Approach)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n x m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n x m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# If you find this solution easy to understand and helpful, then please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code (Explained in Comments)\\n```\\nclass Solution \\n{\\n    private void dfs(int row, int col\\n    ,int[][] ans, int[][] image\\n    ,int newcolor ,int[] deltarow, int[] deltacol\\n    ,int inicolor )\\n    {\\n        ans[row][col]=newcolor;//coloring with new color\\n        int m=image.length;\\n        int n=image[0].length;\\n        for(int i=0;i<4;i++)//tarverses on 4 neighbour\\n        {\\n            int nrow=row + deltarow[i];//neighbour row\\n            int ncol=col + deltacol[i];//neighbour column\\n            if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && image[nrow][ncol]==inicolor &&ans[nrow][ncol] !=newcolor)//valid neighbour row and column and does it has the same initial color and does it has been visited i.e does it has the new color\\n              dfs(nrow,ncol,ans,image,newcolor,deltarow,deltacol,inicolor);\\n        }\\n\\n    }\\n\\n\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) \\n    {\\n        int inicolor=image[sr][sc];//storing the initial color\\n        int newcolor=color;\\n        int[][] ans=image;//copy the color in array\\n        int[] deltarow={-1,0,1,0};//for deltarow\\n        int[] deltacol={0,1,0,-1};//for deltacolumn\\n\\n        dfs(sr,sc,ans,image,newcolor,deltarow,deltacol,inicolor);\\n        return ans;//returning the answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\n    private void dfs(int row, int col\\n    ,int[][] ans, int[][] image\\n    ,int newcolor ,int[] deltarow, int[] deltacol\\n    ,int inicolor )\\n    {\\n        ans[row][col]=newcolor;//coloring with new color\\n        int m=image.length;\\n        int n=image[0].length;\\n        for(int i=0;i<4;i++)//tarverses on 4 neighbour\\n        {\\n            int nrow=row + deltarow[i];//neighbour row\\n            int ncol=col + deltacol[i];//neighbour column\\n            if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && image[nrow][ncol]==inicolor &&ans[nrow][ncol] !=newcolor)//valid neighbour row and column and does it has the same initial color and does it has been visited i.e does it has the new color\\n              dfs(nrow,ncol,ans,image,newcolor,deltarow,deltacol,inicolor);\\n        }\\n\\n    }\\n\\n\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) \\n    {\\n        int inicolor=image[sr][sc];//storing the initial color\\n        int newcolor=color;\\n        int[][] ans=image;//copy the color in array\\n        int[] deltarow={-1,0,1,0};//for deltarow\\n        int[] deltacol={0,1,0,-1};//for deltacolumn\\n\\n        dfs(sr,sc,ans,image,newcolor,deltarow,deltacol,inicolor);\\n        return ans;//returning the answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777702,
                "title": "fast-and-simple-java-0ms",
                "content": "Code:\\n```\\nclass Solution {\\n    public void fill(int[][] arr,int m,int n,int c,int oc){\\n        if(oc==c)return;\\n        if(m>=0 && m<arr.length && n>=0 && n<arr[0].length && arr[m][n]==oc){\\n            arr[m][n]=c;\\n            fill(arr,m-1,n,c,oc);\\n            fill(arr,m+1,n,c,oc);\\n            fill(arr,m,n-1,c,oc);\\n            fill(arr,m,n+1,c,oc);\\n        }\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        fill(image,sr,sc,color,image[sr][sc]);\\n        return image;\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/d0b0cb8c-eff3-4d38-aa44-4bbc584fc20d_1667110535.1822808.gif)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void fill(int[][] arr,int m,int n,int c,int oc){\\n        if(oc==c)return;\\n        if(m>=0 && m<arr.length && n>=0 && n<arr[0].length && arr[m][n]==oc){\\n            arr[m][n]=c;\\n            fill(arr,m-1,n,c,oc);\\n            fill(arr,m+1,n,c,oc);\\n            fill(arr,m,n-1,c,oc);\\n            fill(arr,m,n+1,c,oc);\\n        }\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        fill(image,sr,sc,color,image[sr][sc]);\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707790,
                "title": "flood-fill-python",
                "content": "I have this problem explained and solved on my channel , please check it out.\\nhttps://youtube.com/playlist?list=PLxukZCav2iGzzFMWq-esWbEEZ0KJ17t9L\\nalso please, give your valueable feedback.\\n```````\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        if image[sr][sc] == color :\\n            return image\\n        self.dfs(image,sr,sc,color,image[sr][sc])\\n        return image\\n    def dfs(self,image,sr,sc,color,current) :\\n        if sc<0 or sr<0 or sr>=len(image) or sc>=len(image[0]) :\\n            return\\n        if current!=image[sr][sc] :\\n            return \\n        image[sr][sc] = color\\n        self.dfs(image,sr+1,sc,color,current) \\n        self.dfs(image,sr-1,sc,color,current) \\n        self.dfs(image,sr,sc+1,color,current) \\n        self.dfs(image,sr,sc-1,color,current) \\n        \\n```````",
                "solutionTags": [
                    "Python"
                ],
                "code": "``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2649770,
                "title": "c-simple-bfs-faster-and-easy-solution",
                "content": "Simple solution just maintained a queue which remembers the location of elements we visited and checking their 4-dir if they have same color :\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        queue<pair<int,int>> q;\\n        if(image[sr][sc]==color) return image;\\n        int c=image[sr][sc];\\n        image[sr][sc]=color;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            int f=q.front().first;\\n            int s=q.front().second;\\n            q.pop();\\n            if(f-1 >= 0 and image[f-1][s]==c){\\n                q.push({f-1,s});\\n                image[f-1][s]=color;\\n            } \\n            if(s-1 >= 0 and image[f][s-1]==c){\\n                q.push({f,s-1});\\n                image[f][s-1]=color;\\n            } \\n            if(f+1 < image.size()  and image[f+1][s]==c){\\n                q.push({f+1,s});\\n                image[f+1][s]=color;\\n            } \\n            if(s+1 < image[0].size()  and image[f][s+1]==c){\\n                q.push({f,s+1});\\n                image[f][s+1]=color;\\n            }\\n            //cout << q.size();\\n        }\\n        return image;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        queue<pair<int,int>> q;\\n        if(image[sr][sc]==color) return image;\\n        int c=image[sr][sc];\\n        image[sr][sc]=color;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            int f=q.front().first;\\n            int s=q.front().second;\\n            q.pop();\\n            if(f-1 >= 0 and image[f-1][s]==c){\\n                q.push({f-1,s});\\n                image[f-1][s]=color;\\n            } \\n            if(s-1 >= 0 and image[f][s-1]==c){\\n                q.push({f,s-1});\\n                image[f][s-1]=color;\\n            } \\n            if(f+1 < image.size()  and image[f+1][s]==c){\\n                q.push({f+1,s});\\n                image[f+1][s]=color;\\n            } \\n            if(s+1 < image[0].size()  and image[f][s+1]==c){\\n                q.push({f,s+1});\\n                image[f][s+1]=color;\\n            }\\n            //cout << q.size();\\n        }\\n        return image;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2607092,
                "title": "simple-dfs-java-solution-1ms-faster-than-99",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) \\n    {\\n        if(image[sr][sc] == color)\\n            return image;\\n        \\n        helper(image , sr , sc , image[sr][sc],color);\\n        return image;\\n    }\\n    \\n    private void helper(int[][] grid , int current_row , int current_column , int color, int new_color)\\n    {\\n        if(current_row < 0 || current_column < 0 || current_row >= grid.length || current_column >= grid[0].length || grid[current_row][current_column] != color)\\n            return;\\n        \\n            grid[current_row][current_column] = new_color;\\n        \\n        //going up\\n            helper(grid , current_row-1 , current_column , color, new_color);\\n        \\n        //going right\\n            helper(grid , current_row , current_column+1 , color, new_color);\\n        \\n        //going down\\n            helper(grid , current_row+1 , current_column , color, new_color);\\n        \\n        //going left\\n            helper(grid , current_row , current_column-1 , color, new_color);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) \\n    {\\n        if(image[sr][sc] == color)\\n            return image;\\n        \\n        helper(image , sr , sc , image[sr][sc],color);\\n        return image;\\n    }\\n    \\n    private void helper(int[][] grid , int current_row , int current_column , int color, int new_color)\\n    {\\n        if(current_row < 0 || current_column < 0 || current_row >= grid.length || current_column >= grid[0].length || grid[current_row][current_column] != color)\\n            return;\\n        \\n            grid[current_row][current_column] = new_color;\\n        \\n        //going up\\n            helper(grid , current_row-1 , current_column , color, new_color);\\n        \\n        //going right\\n            helper(grid , current_row , current_column+1 , color, new_color);\\n        \\n        //going down\\n            helper(grid , current_row+1 , current_column , color, new_color);\\n        \\n        //going left\\n            helper(grid , current_row , current_column-1 , color, new_color);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284886,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        if(image[sr][sc]==color) \\n            return image;\\n        \\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        int n=image.size(), m=image[0].size();\\n        if(!color){\\n            return vector<vector<int>>(n,vector<int>(m,0));\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        \\n        int val=image[sr][sc];\\n        while(!q.empty()){\\n            auto [x,y] = q.front();\\n            q.pop();\\n            \\n            image[x][y]=color;\\n            \\n            for(int k=0;k<4;++k){\\n                int di=x+dx[k];\\n                int dj=y+dy[k];\\n                if(di>=0 and dj>=0 and di<n and dj<m and image[di][dj]==val and image[di][dj]!=color){\\n                    q.push({di,dj});\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        if(image[sr][sc]==color) \\n            return image;\\n        \\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        int n=image.size(), m=image[0].size();\\n        if(!color){\\n            return vector<vector<int>>(n,vector<int>(m,0));\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        \\n        int val=image[sr][sc];\\n        while(!q.empty()){\\n            auto [x,y] = q.front();\\n            q.pop();\\n            \\n            image[x][y]=color;\\n            \\n            for(int k=0;k<4;++k){\\n                int di=x+dx[k];\\n                int dj=y+dy[k];\\n                if(di>=0 and dj>=0 and di<n and dj<m and image[di][dj]==val and image[di][dj]!=color){\\n                    q.push({di,dj});\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831316,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int[][] floodFill(int[][] a, int s, int si, int n) {\\n        task(a,s,si,n,a[s][si]);\\n        return a;\\n    }\\n    static void task(int[][] a, int s, int si, int n, int k)\\n    {\\n        if(s<0||s>=a.length||si<0||si>=a[0].length||a[s][si]==n||a[s][si]!=k)\\n            return;\\n        a[s][si]=n;\\n        task(a,s,si+1,n,k);\\n        task(a,s,si-1,n,k);\\n        task(a,s+1,si,n,k);\\n        task(a,s-1,si,n,k);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int[][] floodFill(int[][] a, int s, int si, int n) {\\n        task(a,s,si,n,a[s][si]);\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1786359,
                "title": "733-flood-fill",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        if(sr==sc && sc==newColor && image[sr][sc]==newColor) return image;\\n        \\n        queue<pair<int,int>> q;\\n        \\n        int m=image.size();\\n        int n=image[0].size();\\n        \\n        q.push({sr,sc});\\n        int prev=image[sr][sc];\\n        \\n        image[sr][sc]=newColor;\\n        \\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n           \\n            q.pop();\\n            \\n            int dx[]={1,0,-1,0};\\n            int dy[]={0,1,0,-1};\\n            \\n            for(int ind=0;ind<4;ind++){\\n                int newX=x+dx[ind];\\n                int newY=y+dy[ind];\\n                \\n                if(newX>=0 && newY>=0 && newX<m && newY<n && image[newX][newY]==prev){\\n                \\n                    image[newX][newY]=newColor;\\n                    q.push({newX,newY});\\n                } \\n            }\\n            \\n        }\\n        \\n        return image;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        if(sr==sc && sc==newColor && image[sr][sc]==newColor) return image;\\n        \\n        queue<pair<int,int>> q;\\n        \\n        int m=image.size();\\n        int n=image[0].size();\\n        \\n        q.push({sr,sc});\\n        int prev=image[sr][sc];\\n        \\n        image[sr][sc]=newColor;\\n        \\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n           \\n            q.pop();\\n            \\n            int dx[]={1,0,-1,0};\\n            int dy[]={0,1,0,-1};\\n            \\n            for(int ind=0;ind<4;ind++){\\n                int newX=x+dx[ind];\\n                int newY=y+dy[ind];\\n                \\n                if(newX>=0 && newY>=0 && newX<m && newY<n && image[newX][newY]==prev){\\n                \\n                    image[newX][newY]=newColor;\\n                    q.push({newX,newY});\\n                } \\n            }\\n            \\n        }\\n        \\n        return image;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721491,
                "title": "simple-java-solution-using-dfs-100-faster",
                "content": "**Upvote if you LIKE**  \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n       int o=image[sr][sc];\\n        helper(image,sr,sc,newColor,o);\\n        return image;\\n       \\n    }\\n    \\n    void helper(int[][] img,int r,int c,int n,int o) {\\n        if(r>=img.length || c>=img[0].length || r<0 || c<0 || img[r][c]==n || img[r][c]!=o)   return;\\n        img[r][c]=n;\\n        helper(img,r+1,c,n,o);\\n        helper(img,r-1,c,n,o);\\n        helper(img,r,c+1,n,o);\\n        helper(img,r,c-1,n,o);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n       int o=image[sr][sc];\\n        helper(image,sr,sc,newColor,o);\\n        return image;\\n       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1712377,
                "title": "recursion-c-dfs-easy-to-understand",
                "content": "```\\n void call(vector<vector<int>>& image, int i, int j, int newColor,int sr,int sc,int oddColor){\\n        \\n        if(i<0 or j<0) return;\\n        if(i>=sr or j>=sc) return;\\n        \\n        if(image[i][j]==newColor) return; //already done\\n        \\n        if(image[i][j]!=oddColor) return; //diff color\\n        \\n        \\n        if(image[i][j]==oddColor)\\n        image[i][j] = newColor; //visited mark\\n        \\n        call(image,i+1,j,newColor,sr,sc,oddColor);\\n        call(image,i-1,j,newColor,sr,sc,oddColor);\\n        call(image,i,j+1,newColor,sr,sc,oddColor);\\n        call(image,i,j-1,newColor,sr,sc,oddColor);\\n        \\n    }\\n    \\n    \\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        int oddColor = image[sr][sc];\\n call(image,sr,sc,newColor,image.size(),image[0].size(),oddColor);\\n        return image;\\n    }\\n```\\n\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n void call(vector<vector<int>>& image, int i, int j, int newColor,int sr,int sc,int oddColor){\\n        \\n        if(i<0 or j<0) return;\\n        if(i>=sr or j>=sc) return;\\n        \\n        if(image[i][j]==newColor) return; //already done\\n        \\n        if(image[i][j]!=oddColor) return; //diff color\\n        \\n        \\n        if(image[i][j]==oddColor)\\n        image[i][j] = newColor; //visited mark\\n        \\n        call(image,i+1,j,newColor,sr,sc,oddColor);\\n        call(image,i-1,j,newColor,sr,sc,oddColor);\\n        call(image,i,j+1,newColor,sr,sc,oddColor);\\n        call(image,i,j-1,newColor,sr,sc,oddColor);\\n        \\n    }\\n    \\n    \\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        \\n        int oddColor = image[sr][sc];\\n call(image,sr,sc,newColor,image.size(),image[0].size(),oddColor);\\n        return image;\\n    }\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570802,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) \\n    {\\n        if (image[sr][sc] != newColor)\\n            ChangeColor(sr, sc, image, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    void ChangeColor(int row, int col, int[][] image, int oldColor, int newColor)\\n    {\\n        if (image[row][col] == oldColor)\\n        {\\n            image[row][col] = newColor;\\n            if (row > 0)\\n                ChangeColor(row - 1, col, image, oldColor, newColor);\\n            if (row < image.Length - 1)\\n                ChangeColor(row + 1, col, image, oldColor, newColor);\\n            if (col > 0)\\n                ChangeColor(row, col - 1, image, oldColor, newColor);\\n            if (col < image[0].Length - 1)\\n                ChangeColor(row, col + 1, image, oldColor, newColor);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) \\n    {\\n        if (image[sr][sc] != newColor)\\n            ChangeColor(sr, sc, image, image[sr][sc], newColor);\\n        return image;\\n    }\\n    \\n    void ChangeColor(int row, int col, int[][] image, int oldColor, int newColor)\\n    {\\n        if (image[row][col] == oldColor)\\n        {\\n            image[row][col] = newColor;\\n            if (row > 0)\\n                ChangeColor(row - 1, col, image, oldColor, newColor);\\n            if (row < image.Length - 1)\\n                ChangeColor(row + 1, col, image, oldColor, newColor);\\n            if (col > 0)\\n                ChangeColor(row, col - 1, image, oldColor, newColor);\\n            if (col < image[0].Length - 1)\\n                ChangeColor(row, col + 1, image, oldColor, newColor);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467979,
                "title": "python-dfs-o-1-space",
                "content": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        orig_color = image[sr][sc]\\n        rows, cols = len(image), len(image[0])\\n        \\n        def dfs(i,j):\\n            if not (0 <= i < rows) or not (0 <= j < cols) or image[i][j] == -1 or image[i][j] != orig_color:\\n                return\\n            \\n            image[i][j] = -1\\n            \\n            dfs(i-1,j)\\n            dfs(i+1,j)\\n            dfs(i,j-1)\\n            dfs(i,j+1)\\n            \\n            image[i][j] = newColor\\n        dfs(sr,sc)\\n        return image\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        orig_color = image[sr][sc]\\n        rows, cols = len(image), len(image[0])\\n        \\n        def dfs(i,j):\\n            if not (0 <= i < rows) or not (0 <= j < cols) or image[i][j] == -1 or image[i][j] != orig_color:\\n                return\\n            \\n            image[i][j] = -1\\n            \\n            dfs(i-1,j)\\n            dfs(i+1,j)\\n            dfs(i,j-1)\\n            dfs(i,j+1)\\n            \\n            image[i][j] = newColor\\n        dfs(sr,sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444660,
                "title": "bfs-dfs-both-super-easy",
                "content": "Go through the method if any problems comment down below... upvote if you like it\\n```\\n\\nbool isValid(vector<vector<int> > & arr,int i,int j,int el){\\n        return not(i<0 or j<0 or i>=arr.size() or j>=arr[0].size() or el!=arr[i][j]);\\n    }\\n    \\n    \\n    \\n    void bfs(int sr,int sc,int k,int ele,vector< vector<int> > & arr){\\n        queue<pair<int,int> > q;\\n        q.push(make_pair(sr,sc));\\n        while(not q.empty()){\\n            auto current=q.front();\\n            q.pop();\\n            int i=current.first,j=current.second;\\n            arr[i][j]=k;\\n            if(isValid(arr,i-1,j,ele)) q.push(make_pair(i-1,j));\\n            if(isValid(arr,i,j-1,ele)) q.push(make_pair(i,j-1));\\n            if(isValid(arr,i+1,j,ele)) q.push(make_pair(i+1,j));\\n            if(isValid(arr,i,j+1,ele)) q.push(make_pair(i,j+1));\\n        }\\n    }\\n\\n    \\n\\n\\n    void dfs(int i,int j,int k,int ele,vector< vector<int> > & arr){\\n        if(i<0 or j<0 or i>=arr.size() or j>=arr[0].size() or arr[i][j]!=ele) return;\\n        arr[i][j]=k;\\n        dfs(i-1,j,k,ele,arr);\\n        dfs(i,j-1,k,ele,arr);\\n        dfs(i+1,j,k,ele,arr);\\n        dfs(i,j+1,k,ele,arr);\\n    }\\n    vector<vector<int> > floodFill(vector<vector<int> >& image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            // dfs(sr,sc,newColor,image[sr][sc],image);\\n            bfs(sr,sc,newColor,image[sr][sc],image);\\n        return image;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nbool isValid(vector<vector<int> > & arr,int i,int j,int el){\\n        return not(i<0 or j<0 or i>=arr.size() or j>=arr[0].size() or el!=arr[i][j]);\\n    }\\n    \\n    \\n    \\n    void bfs(int sr,int sc,int k,int ele,vector< vector<int> > & arr){\\n        queue<pair<int,int> > q;\\n        q.push(make_pair(sr,sc));\\n        while(not q.empty()){\\n            auto current=q.front();\\n            q.pop();\\n            int i=current.first,j=current.second;\\n            arr[i][j]=k;\\n            if(isValid(arr,i-1,j,ele)) q.push(make_pair(i-1,j));\\n            if(isValid(arr,i,j-1,ele)) q.push(make_pair(i,j-1));\\n            if(isValid(arr,i+1,j,ele)) q.push(make_pair(i+1,j));\\n            if(isValid(arr,i,j+1,ele)) q.push(make_pair(i,j+1));\\n        }\\n    }\\n\\n    \\n\\n\\n    void dfs(int i,int j,int k,int ele,vector< vector<int> > & arr){\\n        if(i<0 or j<0 or i>=arr.size() or j>=arr[0].size() or arr[i][j]!=ele) return;\\n        arr[i][j]=k;\\n        dfs(i-1,j,k,ele,arr);\\n        dfs(i,j-1,k,ele,arr);\\n        dfs(i+1,j,k,ele,arr);\\n        dfs(i,j+1,k,ele,arr);\\n    }\\n    vector<vector<int> > floodFill(vector<vector<int> >& image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor)\\n            // dfs(sr,sc,newColor,image[sr][sc],image);\\n            bfs(sr,sc,newColor,image[sr][sc],image);\\n        return image;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434872,
                "title": "c-bfs-tle-solved-without-using-visited-array-as-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n\\t//You all are getting tle when newcolor==currentcolor due to which bfs is iterationg over and over\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int nc) {\\n        queue<pair<int,int> > q;\\n        int i,j,m=image.size(),n=image[0].size();\\n        q.push({sr,sc});\\n        q.push({-1,-1});\\n        int cc=image[sr][sc];\\n        if(nc==cc){\\n            return image;       //if newColor is equal to current color at sr,sc then the output image will be same as input image \\n\\t\\t\\t//cuz we need to change the current color with the same color for every cell in path of sr,sc\\n\\t\\t\\t//hence we don\\'t need any extra visited array\\n        }\\n        vector<vector<int> > dir({\\n            {0,1},{1,0},{-1,0},{0,-1}\\n        });\\n        while(!q.empty()){\\n            if(q.front().first!=-1){\\n                int cx=q.front().first;\\n                int cy=q.front().second;\\n                q.pop();\\n                image[cx][cy]=nc;\\n                for(i=0;i<4;i++){\\n                    int nx=cx+dir[i][0];\\n                    int ny=cy+dir[i][1];\\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && image[nx][ny]==cc){\\n                        q.push({nx,ny});\\n                    }\\n                }        \\n            }\\n            else{\\n                q.pop();\\n                if(!q.empty()){\\n                    q.push({-1,-1});\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//You all are getting tle when newcolor==currentcolor due to which bfs is iterationg over and over\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int nc) {\\n        queue<pair<int,int> > q;\\n        int i,j,m=image.size(),n=image[0].size();\\n        q.push({sr,sc});\\n        q.push({-1,-1});\\n        int cc=image[sr][sc];\\n        if(nc==cc){\\n            return image;       //if newColor is equal to current color at sr,sc then the output image will be same as input image \\n\\t\\t\\t//cuz we need to change the current color with the same color for every cell in path of sr,sc\\n\\t\\t\\t//hence we don\\'t need any extra visited array\\n        }\\n        vector<vector<int> > dir({\\n            {0,1},{1,0},{-1,0},{0,-1}\\n        });\\n        while(!q.empty()){\\n            if(q.front().first!=-1){\\n                int cx=q.front().first;\\n                int cy=q.front().second;\\n                q.pop();\\n                image[cx][cy]=nc;\\n                for(i=0;i<4;i++){\\n                    int nx=cx+dir[i][0];\\n                    int ny=cy+dir[i][1];\\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && image[nx][ny]==cc){\\n                        q.push({nx,ny});\\n                    }\\n                }        \\n            }\\n            else{\\n                q.pop();\\n                if(!q.empty()){\\n                    q.push({-1,-1});\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296151,
                "title": "java-easy-dfs",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        fill(image,sr,sc,newColor,new boolean[image.length][image[0].length],-1);\\n        return image;\\n    }\\n    public void fill(int arr[][],int i,int j,int val,boolean visited[][],int prev){\\n      if(i < 0 || j < 0 || i >= arr.length || j >= arr[0].length || visited[i][j]){\\n        return ;\\n      }\\n      if(prev != -1 && arr[i][j] != prev){\\n        return;\\n      }\\n      prev = arr[i][j];\\n      arr[i][j] = val;\\n      visited[i][j] = true;\\n      //call for all directions\\n      fill(arr,i+1,j,val,visited,prev);\\n      fill(arr,i,j+1,val,visited,prev);\\n      fill(arr,i-1,j,val,visited,prev);\\n      fill(arr,i,j-1,val,visited,prev);\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        fill(image,sr,sc,newColor,new boolean[image.length][image[0].length],-1);\\n        return image;\\n    }\\n    public void fill(int arr[][],int i,int j,int val,boolean visited[][],int prev){\\n      if(i < 0 || j < 0 || i >= arr.length || j >= arr[0].length || visited[i][j]){\\n        return ;\\n      }\\n      if(prev != -1 && arr[i][j] != prev){\\n        return;\\n      }\\n      prev = arr[i][j];\\n      arr[i][j] = val;\\n      visited[i][j] = true;\\n      //call for all directions\\n      fill(arr,i+1,j,val,visited,prev);\\n      fill(arr,i,j+1,val,visited,prev);\\n      fill(arr,i-1,j,val,visited,prev);\\n      fill(arr,i,j-1,val,visited,prev);\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040069,
                "title": "java-flood-fill-o-m-n-beats-100-0ms",
                "content": "\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if(image[sr][sc] == newColor)\\n            return image;\\n        floodFill(image,sr,sc,image[sr][sc],image.length,image[0].length,newColor);\\n        return image;\\n    }\\n    \\n    public void floodFill(int[][] image,int cr,int cc,int color,int m,int n,int newColor){\\n        \\n        if(image[cr][cc] != color)\\n            return;\\n        \\n        image[cr][cc] = newColor;\\n        if(cr >= 1)\\n            floodFill(image,cr-1,cc,color,m,n,newColor);\\n        if(cc < n-1)\\n            floodFill(image,cr,cc+1,color,m,n,newColor);\\n        if(cr < m-1)\\n            floodFill(image,cr+1,cc,color,m,n,newColor);\\n        if(cc >= 1)\\n            floodFill(image,cr,cc-1,color,m,n,newColor);\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if(image[sr][sc] == newColor)\\n            return image;\\n        floodFill(image,sr,sc,image[sr][sc],image.length,image[0].length,newColor);\\n        return image;\\n    }\\n    \\n    public void floodFill(int[][] image,int cr,int cc,int color,int m,int n,int newColor){\\n        \\n        if(image[cr][cc] != color)\\n            return;\\n        \\n        image[cr][cc] = newColor;\\n        if(cr >= 1)\\n            floodFill(image,cr-1,cc,color,m,n,newColor);\\n        if(cc < n-1)\\n            floodFill(image,cr,cc+1,color,m,n,newColor);\\n        if(cr < m-1)\\n            floodFill(image,cr+1,cc,color,m,n,newColor);\\n        if(cc >= 1)\\n            floodFill(image,cr,cc-1,color,m,n,newColor);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 878510,
                "title": "java-bfs-1ms-easy",
                "content": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int startColor = image[sr][sc];\\n        Queue<Node> q = new LinkedList<>();\\n        boolean[][] vis = new boolean[image.length][image[0].length];\\n        \\n        q.add(new Node(sr,sc));\\n        vis[sr][sc] = true;\\n        \\n        while(!q.isEmpty()) {\\n            Node n = q.poll();\\n            image[n.r][n.c] = newColor;\\n            //up\\n            if (n.r-1>=0 && image[n.r-1][n.c] == startColor && !vis[n.r-1][n.c]) {\\n                vis[n.r-1][n.c] = true;\\n                q.add(new Node(n.r-1,n.c));\\n            }\\n            // down\\n            if (n.r+1<image.length && image[n.r+1][n.c] == startColor && !vis[n.r+1][n.c]) {\\n                vis[n.r+1][n.c] = true;\\n                q.add(new Node(n.r+1,n.c));\\n            }\\n            //left\\n            if (n.c-1>=0 && image[n.r][n.c-1] == startColor && !vis[n.r][n.c-1]) {\\n                vis[n.r][n.c-1] = true;\\n                q.add(new Node(n.r,n.c-1));\\n            }\\n            //right\\n            if (n.c+1<image[0].length && image[n.r][n.c+1] == startColor && !vis[n.r][n.c+1]) {\\n                vis[n.r][n.c+1] = true;\\n                q.add(new Node(n.r,n.c+1));\\n            }\\n        }\\n        \\n        return image;\\n    }\\n}\\n\\nclass Node {\\n    int r;\\n    int c;\\n    public Node(int r, int c) {\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int startColor = image[sr][sc];\\n        Queue<Node> q = new LinkedList<>();\\n        boolean[][] vis = new boolean[image.length][image[0].length];\\n        \\n        q.add(new Node(sr,sc));\\n        vis[sr][sc] = true;\\n        \\n        while(!q.isEmpty()) {\\n            Node n = q.poll();\\n            image[n.r][n.c] = newColor;\\n            //up\\n            if (n.r-1>=0 && image[n.r-1][n.c] == startColor && !vis[n.r-1][n.c]) {\\n                vis[n.r-1][n.c] = true;\\n                q.add(new Node(n.r-1,n.c));\\n            }\\n            // down\\n            if (n.r+1<image.length && image[n.r+1][n.c] == startColor && !vis[n.r+1][n.c]) {\\n                vis[n.r+1][n.c] = true;\\n                q.add(new Node(n.r+1,n.c));\\n            }\\n            //left\\n            if (n.c-1>=0 && image[n.r][n.c-1] == startColor && !vis[n.r][n.c-1]) {\\n                vis[n.r][n.c-1] = true;\\n                q.add(new Node(n.r,n.c-1));\\n            }\\n            //right\\n            if (n.c+1<image[0].length && image[n.r][n.c+1] == startColor && !vis[n.r][n.c+1]) {\\n                vis[n.r][n.c+1] = true;\\n                q.add(new Node(n.r,n.c+1));\\n            }\\n        }\\n        \\n        return image;\\n    }\\n}\\n\\nclass Node {\\n    int r;\\n    int c;\\n    public Node(int r, int c) {\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859814,
                "title": "python-easy-to-understand-dfs-iterative-solution-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \\n        stack --> store the nodes being explored\\n        visited --> track the visited nodes\\n        \\n        dirc_vector --> direction to navigate the image pixels\\n        \"\"\"\\n        if not image:\\n            return\\n        dirc_vector = [(1,0),(0,1),(-1,0),(0,-1)]\\n        stack = []\\n        level = image[sr][sc]   # storing the value at the start pixel \\n        stack.append((sr,sc))\\n        visited = set()\\n        while stack:\\n            r,c = stack.pop()\\n            image[r][c] = newColor    # change the pixel values to the new color \\n            for dirc in dirc_vector:\\n                rr = r + dirc[0]\\n                cc = c + dirc[1]  \\n                # check if the generated rr,cc are within the boundary of the image\\n                # check if image[rr][cc] is equal to 1 \\n                if 0<=rr<len(image) and 0<=cc<len(image[0]) and (rr,cc) not in visited and image[rr][cc] == level:\\n                    visited.add((rr,cc))\\n                    stack.append((rr,cc))\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \\n        stack --> store the nodes being explored\\n        visited --> track the visited nodes\\n        \\n        dirc_vector --> direction to navigate the image pixels\\n        \"\"\"\\n        if not image:\\n            return\\n        dirc_vector = [(1,0),(0,1),(-1,0),(0,-1)]\\n        stack = []\\n        level = image[sr][sc]   # storing the value at the start pixel \\n        stack.append((sr,sc))\\n        visited = set()\\n        while stack:\\n            r,c = stack.pop()\\n            image[r][c] = newColor    # change the pixel values to the new color \\n            for dirc in dirc_vector:\\n                rr = r + dirc[0]\\n                cc = c + dirc[1]  \\n                # check if the generated rr,cc are within the boundary of the image\\n                # check if image[rr][cc] is equal to 1 \\n                if 0<=rr<len(image) and 0<=cc<len(image[0]) and (rr,cc) not in visited and image[rr][cc] == level:\\n                    visited.add((rr,cc))\\n                    stack.append((rr,cc))\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656952,
                "title": "c-iterative-dfs-solution",
                "content": "Explanation on the intuition as well as the recursion version of this solution can be found: \\n\\nhttps://leetcode.com/problems/flood-fill/discuss/656933/C%2B%2B-recursive-DFS-solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if(image.size()==0 || image[0].size()==0)\\n            return image;\\n        \\n        int m=image.size(),n=image[0].size(),r=0,c=0;\\n        int color=image[sr][sc];\\n \\n        stack<pair<int,int>> process;\\n        process.push({sr,sc});\\n        while(!process.empty())\\n        {\\n            auto& p=process.top();\\n            r=p.first;\\n            c=p.second;\\n            image[r][c]=newColor;\\n            process.pop();\\n            \\n            if(r-1>=0 && image[r-1][c]==color && image[r-1][c]!=newColor)\\n                process.push({r-1,c});\\n            if(r+1<m && image[r+1][c]==color && image[r+1][c]!=newColor)\\n                process.push({r+1,c});\\n            if(c-1>=0 && image[r][c-1]==color && image[r][c-1]!=newColor)\\n                process.push({r,c-1});\\n            if(c+1<n && image[r][c+1]==color && image[r][c+1]!=newColor)\\n                process.push({r,c+1});\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        if(image.size()==0 || image[0].size()==0)\\n            return image;\\n        \\n        int m=image.size(),n=image[0].size(),r=0,c=0;\\n        int color=image[sr][sc];\\n \\n        stack<pair<int,int>> process;\\n        process.push({sr,sc});\\n        while(!process.empty())\\n        {\\n            auto& p=process.top();\\n            r=p.first;\\n            c=p.second;\\n            image[r][c]=newColor;\\n            process.pop();\\n            \\n            if(r-1>=0 && image[r-1][c]==color && image[r-1][c]!=newColor)\\n                process.push({r-1,c});\\n            if(r+1<m && image[r+1][c]==color && image[r+1][c]!=newColor)\\n                process.push({r+1,c});\\n            if(c-1>=0 && image[r][c-1]==color && image[r][c-1]!=newColor)\\n                process.push({r,c-1});\\n            if(c+1<n && image[r][c+1]==color && image[r][c+1]!=newColor)\\n                process.push({r,c+1});\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626440,
                "title": "c-simple-bfs-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        int rows = image.Length;\\n        int cols = image[0].Length;\\n        var queue = new Queue<(int Row, int Col)>();\\n        var shifts = new List<(int,int)>() { (-1, 0), (0, -1), (0, 1), (1, 0) };\\n        int oldColor = image[sr][sc];\\n        if (oldColor == newColor)\\n            return image;\\n        queue.Enqueue((sr, sc));\\n        while (queue.Count > 0) {\\n            var cell = queue.Dequeue();\\n            image[cell.Row][cell.Col] = newColor;\\n            foreach (var p in shifts) {\\n                int r = cell.Row + p.Item1;\\n                int c = cell.Col + p.Item2;\\n                if (r >= 0 && r < rows && c >= 0 && c < cols && image[r][c] == oldColor)\\n                    queue.Enqueue((r,c));  \\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\\n        int rows = image.Length;\\n        int cols = image[0].Length;\\n        var queue = new Queue<(int Row, int Col)>();\\n        var shifts = new List<(int,int)>() { (-1, 0), (0, -1), (0, 1), (1, 0) };\\n        int oldColor = image[sr][sc];\\n        if (oldColor == newColor)\\n            return image;\\n        queue.Enqueue((sr, sc));\\n        while (queue.Count > 0) {\\n            var cell = queue.Dequeue();\\n            image[cell.Row][cell.Col] = newColor;\\n            foreach (var p in shifts) {\\n                int r = cell.Row + p.Item1;\\n                int c = cell.Col + p.Item2;\\n                if (r >= 0 && r < rows && c >= 0 && c < cols && image[r][c] == oldColor)\\n                    queue.Enqueue((r,c));  \\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626177,
                "title": "rust-4ms-recursive-dfs-0ms-iterative-dfs",
                "content": "#### Recursive DFS\\n\\nRuntime(\\\\*): 4 ms.\\n```rust\\nimpl Solution {\\n    pub fn flood_fill(mut image: Vec<Vec<i32>>, sr: i32, sc: i32, new_color: i32) -> Vec<Vec<i32>> {\\n        let old_color = image[sr as usize][sc as usize];\\n        if old_color != new_color {\\n            Self::fill(&mut image, sr as usize, sc as usize, old_color, new_color);\\n        }\\n        image\\n    }\\n    \\n    fn fill(image: &mut Vec<Vec<i32>>, i: usize, j: usize, old_color: i32, new_color: i32) {\\n        if image[i][j] != old_color {\\n            return;\\n        }\\n        image[i][j] = new_color;\\n        if i > 0 {\\n            Self::fill(image, i - 1, j, old_color, new_color);\\n        }\\n        if i < image.len() - 1 {\\n            Self::fill(image, i + 1, j, old_color, new_color);\\n        }\\n        if j > 0 {\\n            Self::fill(image, i, j - 1, old_color, new_color);\\n        }\\n        if j < image[0].len() - 1 {\\n            Self::fill(image, i, j + 1, old_color, new_color);\\n        }\\n    }\\n}\\n```\\n\\n#### Iterative DFS\\n\\nRuntime(\\\\*): 0 ms.\\n```rust\\nimpl Solution {\\n    pub fn flood_fill(mut image: Vec<Vec<i32>>, sr: i32, sc: i32, new_color: i32) -> Vec<Vec<i32>> {\\n        let old_color = image[sr as usize][sc as usize];\\n        if old_color == new_color {\\n            return image;\\n        }\\n        let mut stack = vec![(sr as usize, sc as usize)];\\n        while let Some((i, j)) = stack.pop() {\\n            if image[i][j] != old_color {\\n                continue;\\n            }\\n            image[i][j] = new_color;\\n            if i > 0 {\\n                stack.push((i - 1, j));\\n            }\\n            if i < image.len() - 1 {\\n                stack.push((i + 1, j))\\n            }\\n            if j > 0 {\\n                stack.push((i, j - 1));\\n            }\\n            if j < image[0].len() - 1 {\\n                stack.push((i, j + 1));\\n            }   \\n        }\\n        image\\n    }\\n}\\n```\\n\\n----\\n(\\\\*): Leetcode\\'s benchmarks do not seem particularly accurate, and re-submissions of the same code multiple times sometimes exhibits large variance, so please take these with a ~~pinch~~ _huge bucket_ of salt.",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn flood_fill(mut image: Vec<Vec<i32>>, sr: i32, sc: i32, new_color: i32) -> Vec<Vec<i32>> {\\n        let old_color = image[sr as usize][sc as usize];\\n        if old_color != new_color {\\n            Self::fill(&mut image, sr as usize, sc as usize, old_color, new_color);\\n        }\\n        image\\n    }\\n    \\n    fn fill(image: &mut Vec<Vec<i32>>, i: usize, j: usize, old_color: i32, new_color: i32) {\\n        if image[i][j] != old_color {\\n            return;\\n        }\\n        image[i][j] = new_color;\\n        if i > 0 {\\n            Self::fill(image, i - 1, j, old_color, new_color);\\n        }\\n        if i < image.len() - 1 {\\n            Self::fill(image, i + 1, j, old_color, new_color);\\n        }\\n        if j > 0 {\\n            Self::fill(image, i, j - 1, old_color, new_color);\\n        }\\n        if j < image[0].len() - 1 {\\n            Self::fill(image, i, j + 1, old_color, new_color);\\n        }\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn flood_fill(mut image: Vec<Vec<i32>>, sr: i32, sc: i32, new_color: i32) -> Vec<Vec<i32>> {\\n        let old_color = image[sr as usize][sc as usize];\\n        if old_color == new_color {\\n            return image;\\n        }\\n        let mut stack = vec![(sr as usize, sc as usize)];\\n        while let Some((i, j)) = stack.pop() {\\n            if image[i][j] != old_color {\\n                continue;\\n            }\\n            image[i][j] = new_color;\\n            if i > 0 {\\n                stack.push((i - 1, j));\\n            }\\n            if i < image.len() - 1 {\\n                stack.push((i + 1, j))\\n            }\\n            if j > 0 {\\n                stack.push((i, j - 1));\\n            }\\n            if j < image[0].len() - 1 {\\n                stack.push((i, j + 1));\\n            }   \\n        }\\n        image\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626128,
                "title": "cpp-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void floodFillRec(vector<vector<int>>& image, int sr, int sc, int startingColor, int newColor){\\n        if(sr==image.size()||sr<0||sc<0||sc==image[sr].size()||image[sr][sc]!=startingColor)\\n            return;\\n        image[sr][sc]=newColor;\\n        floodFillRec(image,sr+1,sc,startingColor,newColor);\\n        floodFillRec(image,sr-1,sc,startingColor,newColor);\\n        floodFillRec(image,sr,sc+1,startingColor,newColor);\\n        floodFillRec(image,sr,sc-1,startingColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int startingColor=image[sr][sc];\\n        image[sr][sc]=newColor;\\n        if(startingColor==newColor)\\n            return image;\\n        floodFillRec(image,sr+1,sc,startingColor,newColor);\\n        floodFillRec(image,sr-1,sc,startingColor,newColor);\\n        floodFillRec(image,sr,sc+1,startingColor,newColor);\\n        floodFillRec(image,sr,sc-1,startingColor,newColor);\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void floodFillRec(vector<vector<int>>& image, int sr, int sc, int startingColor, int newColor){\\n        if(sr==image.size()||sr<0||sc<0||sc==image[sr].size()||image[sr][sc]!=startingColor)\\n            return;\\n        image[sr][sc]=newColor;\\n        floodFillRec(image,sr+1,sc,startingColor,newColor);\\n        floodFillRec(image,sr-1,sc,startingColor,newColor);\\n        floodFillRec(image,sr,sc+1,startingColor,newColor);\\n        floodFillRec(image,sr,sc-1,startingColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int startingColor=image[sr][sc];\\n        image[sr][sc]=newColor;\\n        if(startingColor==newColor)\\n            return image;\\n        floodFillRec(image,sr+1,sc,startingColor,newColor);\\n        floodFillRec(image,sr-1,sc,startingColor,newColor);\\n        floodFillRec(image,sr,sc+1,startingColor,newColor);\\n        floodFillRec(image,sr,sc-1,startingColor,newColor);\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500456,
                "title": "easy-understand-python-solution",
                "content": "class Solution(object):\\n\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        self.old = image[sr][sc]\\n        self.dfs(image,sr,sc,newColor)\\n        return image\\n    def dfs(self,image,i,j,newColor):\\n        if i<0 or i>= len(image) or j<0 or j>=len(image[0]):\\n            return\\n        if image[i][j] == newColor:\\n            return\\n        if image[i][j] == self.old:\\n            image[i][j] = newColor\\n            self.dfs(image,i+1,j,newColor)\\n            self.dfs(image,i-1,j,newColor)\\n            self.dfs(image,i,j+1,newColor)\\n            self.dfs(image,i,j-1,newColor)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def floodFill(self, image, sr, sc, newColor):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type newColor: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        self.old = image[sr][sc]\\n        self.dfs(image,sr,sc,newColor)\\n        return image\\n    def dfs(self,image,i,j,newColor):\\n        if i<0 or i>= len(image) or j<0 or j>=len(image[0]):\\n            return\\n        if image[i][j] == newColor:\\n            return\\n        if image[i][j] == self.old:\\n            image[i][j] = newColor\\n            self.dfs(image,i+1,j,newColor)\\n            self.dfs(image,i-1,j,newColor)\\n            self.dfs(image,i,j+1,newColor)\\n            self.dfs(image,i,j-1,newColor)\\n",
                "codeTag": "Java"
            },
            {
                "id": 238053,
                "title": "template-solution-for-matrix-dfs-and-bfs-java",
                "content": "```\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor) \\n            dfs(image, sr, sc, newColor, image[sr][sc]);\\n        return image;\\n    }\\n    \\n    public void dfs(int[][] image, int sr, int sc, int newColor, int replaceColor) {\\n        if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != replaceColor) return;\\n        \\n        image[sr][sc] = newColor;\\n        dfs(image, sr + 1, sc, newColor, replaceColor);\\n        dfs(image, sr - 1, sc, newColor, replaceColor);\\n        dfs(image, sr, sc + 1, newColor, replaceColor);\\n        dfs(image, sr, sc - 1, newColor, replaceColor);\\n        \\n    }\\n    \\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image;\\n        int[][] di = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        \\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.offer(new int[]{sr,sc});\\n        int oldColor = image[sr][sc];\\n        \\n        while (!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            \\n            image[curr[0]][curr[1]] = newColor;\\n            \\n            for (int i=0; i < di.length ; i++) {\\n                \\n                int r = curr[0] + di[i][0];\\n                int c = curr[1] + di[i][1];\\n                \\n                if (isValidIndexs(r,c,image) && image[r][c] == oldColor) {\\n                    q.offer(new int[]{r, c});\\n                }\\n            }\\n        }\\n        \\n        return image;\\n        \\n    }\\n    \\n    public boolean isValidIndexs(int r, int c, int[][] matrix) {\\n        return c >=0 && c < matrix[0].length && r >=0 && r < matrix.length;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] != newColor) \\n            dfs(image, sr, sc, newColor, image[sr][sc]);\\n        return image;\\n    }\\n    \\n    public void dfs(int[][] image, int sr, int sc, int newColor, int replaceColor) {\\n        if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != replaceColor) return;\\n        \\n        image[sr][sc] = newColor;\\n        dfs(image, sr + 1, sc, newColor, replaceColor);\\n        dfs(image, sr - 1, sc, newColor, replaceColor);\\n        dfs(image, sr, sc + 1, newColor, replaceColor);\\n        dfs(image, sr, sc - 1, newColor, replaceColor);\\n        \\n    }\\n    \\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if (image[sr][sc] == newColor) return image;\\n        int[][] di = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        \\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.offer(new int[]{sr,sc});\\n        int oldColor = image[sr][sc];\\n        \\n        while (!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            \\n            image[curr[0]][curr[1]] = newColor;\\n            \\n            for (int i=0; i < di.length ; i++) {\\n                \\n                int r = curr[0] + di[i][0];\\n                int c = curr[1] + di[i][1];\\n                \\n                if (isValidIndexs(r,c,image) && image[r][c] == oldColor) {\\n                    q.offer(new int[]{r, c});\\n                }\\n            }\\n        }\\n        \\n        return image;\\n        \\n    }\\n    \\n    public boolean isValidIndexs(int r, int c, int[][] matrix) {\\n        return c >=0 && c < matrix[0].length && r >=0 && r < matrix.length;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109596,
                "title": "java-easy-bfs",
                "content": "```\\n        public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n            int[] directions = new int[]{0, 1, 0, -1, 0};\\n            int m = image.length;\\n            int n = image[0].length;\\n            int originalValue = image[sr][sc];\\n            image[sr][sc] = newColor;\\n\\n            boolean[][] visited = new boolean[m][n];\\n\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.offer(new int[]{sr, sc});\\n            while (!queue.isEmpty()) {\\n                int[] curr = queue.poll();\\n                visited[curr[0]][curr[1]] = true;\\n                for (int i = 0; i < directions.length - 1; i++) {\\n                    int nextR = curr[0] + directions[i];\\n                    int nextC = curr[1] + directions[i + 1];\\n                    if (nextR < 0 || nextC < 0 || nextR >= m || nextC >= n || image[nextR][nextC] != originalValue || visited[nextR][nextC]) {\\n                        continue;\\n                    }\\n                    image[nextR][nextC] = newColor;\\n                    queue.offer(new int[]{nextR, nextC});\\n                }\\n            }\\n            return image;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n            int[] directions = new int[]{0, 1, 0, -1, 0};\\n            int m = image.length;\\n            int n = image[0].length;\\n            int originalValue = image[sr][sc];\\n            image[sr][sc] = newColor;\\n\\n            boolean[][] visited = new boolean[m][n];\\n\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.offer(new int[]{sr, sc});\\n            while (!queue.isEmpty()) {\\n                int[] curr = queue.poll();\\n                visited[curr[0]][curr[1]] = true;\\n                for (int i = 0; i < directions.length - 1; i++) {\\n                    int nextR = curr[0] + directions[i];\\n                    int nextC = curr[1] + directions[i + 1];\\n                    if (nextR < 0 || nextC < 0 || nextR >= m || nextC >= n || image[nextR][nextC] != originalValue || visited[nextR][nextC]) {\\n                        continue;\\n                    }\\n                    image[nextR][nextC] = newColor;\\n                    queue.offer(new int[]{nextR, nextC});\\n                }\\n            }\\n            return image;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915550,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,int& oldcolor,int& newcolor,map<pair<int,int>,bool>& visited,vector<vector<int>>& arr){\\n        visited[{x,y}]=true;\\n        arr[x][y]=newcolor;\\n        int dx[]={-1,0,1,0};\\n        int dy[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+dx[i];\\n            int newY=y+dy[i];\\n            if(newX>=0&&newX<arr.size()\\n            && newY>=0&&newY<arr[0].size()\\n            &&!visited[{newX,newY}]\\n            &&arr[newX][newY]==oldcolor){\\n                dfs(newX,newY,oldcolor,newcolor,visited,arr);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int oldcolor=image[sr][sc];\\n        map<pair<int,int>, bool> visited;\\n        vector<vector<int>> arr=image;\\n        dfs(sr,sc,oldcolor,color,visited,arr);\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,int& oldcolor,int& newcolor,map<pair<int,int>,bool>& visited,vector<vector<int>>& arr){\\n        visited[{x,y}]=true;\\n        arr[x][y]=newcolor;\\n        int dx[]={-1,0,1,0};\\n        int dy[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+dx[i];\\n            int newY=y+dy[i];\\n            if(newX>=0&&newX<arr.size()\\n            && newY>=0&&newY<arr[0].size()\\n            &&!visited[{newX,newY}]\\n            &&arr[newX][newY]==oldcolor){\\n                dfs(newX,newY,oldcolor,newcolor,visited,arr);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int oldcolor=image[sr][sc];\\n        map<pair<int,int>, bool> visited;\\n        vector<vector<int>> arr=image;\\n        dfs(sr,sc,oldcolor,color,visited,arr);\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868749,
                "title": "c-dfs-bfs",
                "content": "# DFS\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int val = image[sr][sc], m = image.size(), n = image[0].size();\\n        changeColor(image, sr, sc, val, color, m, n);\\n        return image;\\n    }\\n\\nprivate:\\n    void changeColor(vector<vector<int>>& image, int i, int j, int& val, int& color, int& m, int& n) {\\n        if (i < 0 || j < 0 || i >= m || j >= n || image[i][j] == color || image[i][j] != val)\\n            return;\\n        image[i][j] = color;\\n        changeColor(image, i, j-1, val, color, m, n);\\n        changeColor(image, i, j+1, val, color, m, n);\\n        changeColor(image, i+1, j, val, color, m, n);\\n        changeColor(image, i-1, j, val, color, m, n);\\n    }\\n};\\n```\\n\\n# BFS\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        // same color, no need to replace\\n        if (image[sr][sc] == color)\\n            return image;\\n\\n        int val = image[sr][sc], m = image.size(), n = image[0].size();\\n\\n        queue<pair<int, int>> Q;\\n        Q.emplace(sr, sc); \\n        image[sr][sc] = color;\\n\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\\n\\n        while (!Q.empty()) {\\n            auto [r, c] = Q.front(); Q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n                if (nr < 0 || nc < 0 || nr == m || nc == n || image[nr][nc] != val)\\n                    continue;\\n                image[nr][nc] = color;\\n                Q.emplace(nr, nc); \\n            }\\n        }\\n\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int val = image[sr][sc], m = image.size(), n = image[0].size();\\n        changeColor(image, sr, sc, val, color, m, n);\\n        return image;\\n    }\\n\\nprivate:\\n    void changeColor(vector<vector<int>>& image, int i, int j, int& val, int& color, int& m, int& n) {\\n        if (i < 0 || j < 0 || i >= m || j >= n || image[i][j] == color || image[i][j] != val)\\n            return;\\n        image[i][j] = color;\\n        changeColor(image, i, j-1, val, color, m, n);\\n        changeColor(image, i, j+1, val, color, m, n);\\n        changeColor(image, i+1, j, val, color, m, n);\\n        changeColor(image, i-1, j, val, color, m, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        // same color, no need to replace\\n        if (image[sr][sc] == color)\\n            return image;\\n\\n        int val = image[sr][sc], m = image.size(), n = image[0].size();\\n\\n        queue<pair<int, int>> Q;\\n        Q.emplace(sr, sc); \\n        image[sr][sc] = color;\\n\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\\n\\n        while (!Q.empty()) {\\n            auto [r, c] = Q.front(); Q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n                if (nr < 0 || nc < 0 || nr == m || nc == n || image[nr][nc] != val)\\n                    continue;\\n                image[nr][nc] = color;\\n                Q.emplace(nr, nc); \\n            }\\n        }\\n\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609595,
                "title": "simple-solution-using-java-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public void DFS(int[][] image,int i,int j,int actualColor,int color,boolean[][]visited)\\n    {\\n        if(i<0 || i>=image.length || j<0 || j>=image[0].length || image[i][j]!=actualColor || visited[i][j] == true)\\n            return;\\n        visited[i][j] = true;\\n        image[i][j] = color;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            DFS(image,newRow,newCol,actualColor,color,visited);\\n        }\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        boolean[][] visited = new boolean[image.length][image[0].length];\\n        int actualColor = image[sr][sc];\\n        DFS(image,sr,sc,actualColor,color,visited);\\n        return image;\\n    }\\n}\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public void DFS(int[][] image,int i,int j,int actualColor,int color,boolean[][]visited)\\n    {\\n        if(i<0 || i>=image.length || j<0 || j>=image[0].length || image[i][j]!=actualColor || visited[i][j] == true)\\n            return;\\n        visited[i][j] = true;\\n        image[i][j] = color;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            DFS(image,newRow,newCol,actualColor,color,visited);\\n        }\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        boolean[][] visited = new boolean[image.length][image[0].length];\\n        int actualColor = image[sr][sc];\\n        DFS(image,sr,sc,actualColor,color,visited);\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607331,
                "title": "bfs-brute-force-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code you provided implements a flood fill algorithm using a queue to fill a region of connected pixels with a specified color in a given image.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. A `visited` matrix is created with the same dimensions as the input `image` to keep track of the pixels that have been visited during the flood fill process. All elements in the `visited` matrix are initially set to 0.\\n\\n2. A queue `q` is initialized to store the coordinates of the pixels that need to be processed. The starting pixel (`sr`, `sc`) is pushed into the queue, indicating the beginning of the flood fill.\\n\\n3. The starting pixel (`sr`, `sc`) is marked as visited by setting `visited[sr][sc]` to true.\\n\\n4. The value of the color of the starting pixel is stored in the variable `che`. This value will be used to compare with neighboring pixels during the flood fill process.\\n\\n5. Two arrays, `alpha` and `beta`, are defined to represent the possible movements in the vertical and horizontal directions, respectively. The four combinations of `(alpha[i], beta[i])` represent moving up, down, left, and right in the image grid.\\n\\n6. The flood fill process begins with a while loop that continues until the queue `q` becomes empty.\\n\\n7. Inside the loop, the first element (`fr`) is removed from the front of the queue using `q.front()` and `q.pop()`.\\n\\n8. For each of the four possible movements (up, down, left, and right), the coordinates of the neighboring pixel are calculated (`x` and `y`).\\n\\n9. The conditions `x<n && y<m && x>=0 && y>=0 && visited[x][y]==false` ensure that the neighboring pixel is within the image boundaries and has not been visited before.\\n\\n10. If the neighboring pixel has the same color as the starting pixel (`image[x][y]==che`), it is considered part of the same region. Therefore, it is pushed into the queue for further processing, marked as visited in the `visited` matrix, and its coordinates are printed.\\n\\n11. After processing all the neighboring pixels of the current pixel, the while loop continues until the queue is empty and no more pixels are left to be processed.\\n\\n12. Finally, after the flood fill is complete, a nested loop iterates over all the pixels of the original image. If a pixel was visited during the flood fill process (`visited[i][j]==1`), its color is updated to the specified `color`.\\n\\n13. The modified image is returned as the result of the function.\\n\\nOverall, the code performs a breadth-first search (BFS) using a queue to find and update all connected pixels with the same color in the input image to the specified new color.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n         vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n         queue<pair<int,int>>q;\\n         int n=image.size();\\n         int m=image[0].size();\\n         q.push({sr,sc});\\n         visited[sr][sc]=true;\\n        //  return visited;\\n        int che=image[sr][sc];\\n        int alpha[4]={0,0,1,-1};\\n        int beta[4]={1,-1,0,0};\\n        while(!q.empty()){\\n            pair<int,int>fr=q.front();\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n\\n                int x=fr.first+alpha[i];\\n                int y=fr.second+beta[i];\\n                if(x<n && y<m && x>=0 && y>=0 && visited[x][y]==false){\\n                    if(image[x][y]==che){\\n                        q.push({x,y});\\n                        visited[x][y]=true;\\n                        cout<<x<<\" \"<<y<<endl;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j]==1){\\n                    image[i][j]=color;\\n                }\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n         vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n         queue<pair<int,int>>q;\\n         int n=image.size();\\n         int m=image[0].size();\\n         q.push({sr,sc});\\n         visited[sr][sc]=true;\\n        //  return visited;\\n        int che=image[sr][sc];\\n        int alpha[4]={0,0,1,-1};\\n        int beta[4]={1,-1,0,0};\\n        while(!q.empty()){\\n            pair<int,int>fr=q.front();\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n\\n                int x=fr.first+alpha[i];\\n                int y=fr.second+beta[i];\\n                if(x<n && y<m && x>=0 && y>=0 && visited[x][y]==false){\\n                    if(image[x][y]==che){\\n                        q.push({x,y});\\n                        visited[x][y]=true;\\n                        cout<<x<<\" \"<<y<<endl;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j]==1){\\n                    image[i][j]=color;\\n                }\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3540660,
                "title": "breadth-first-traversal-bfs-optimal-space-complexity-graph-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we\\'re using breadth first search algorithm to color the neighbouring vertices in all 4-directions. Using bfs algorithm will give optimal space complexity than dfs algorithm. So first you have to give newcolor to the given starting row and starting coloum then visit neighbouring nodes and make sure which color they had if they have oldcolor change it to newcolor and repeat this process untli all adjacent 4-directional neighbour got newcolor. Finally return image\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nHere are the complete steps for the BFS-based flood fill algorithm:\\n\\n1. Initialize a queue with [(sr, sc)], where (sr, sc) represents the starting row and column.\\n2. Create a set or array to keep track of visited cells.\\n3. Get the dimensions of the image: row = len(image), col = len(image[0]).\\n4. Define the directions to explore neighboring cells: directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] (right, down, left, up).\\n5. Get the original color of the starting cell: originalColor = image[sr][sc].\\n6. While the queue is not empty:\\n   - Dequeue the current cell (x, y) from the front of the queue.\\n   - If the current cell is not visited:\\n     - Mark the current cell as visited by setting image[x][y] = newColor.\\n     - Enqueue all valid neighboring cells that have the original color and are not visited by adding them to the queue.\\n7. Return the modified image.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nHere the major advantage of using this bfs can have optimal space complexity. Depth-first-search algorithm needs extra stack space which is avoided here. \\n\\n# Code\\n```\\nclass Solution:\\n    def floodFill(self, image, sr, sc, newColor):\\n        row = len(image)\\n        col = len(image[0])\\n        \\n        queue = [(sr, sc)]\\n        \\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        def is_valid(x, y):\\n            return x >= 0 and x < row and y >= 0 and y < col\\n        \\n        # Check if the initial position is already of the new color\\n        if image[sr][sc] == newColor:\\n            return image\\n        \\n        oldColor = image[sr][sc]\\n        \\n        while queue:\\n            x, y = queue.pop(0)\\n            \\n            # Check if the pixel has the old color\\n            if image[x][y] == oldColor:\\n                image[x][y] = newColor\\n                \\n                for dx, dy in directions:\\n                    nx = x + dx\\n                    ny = y + dy\\n                    \\n                    if is_valid(nx, ny) and image[nx][ny] == oldColor:\\n                        queue.append((nx, ny))\\n        \\n        return image\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def floodFill(self, image, sr, sc, newColor):\\n        row = len(image)\\n        col = len(image[0])\\n        \\n        queue = [(sr, sc)]\\n        \\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        def is_valid(x, y):\\n            return x >= 0 and x < row and y >= 0 and y < col\\n        \\n        # Check if the initial position is already of the new color\\n        if image[sr][sc] == newColor:\\n            return image\\n        \\n        oldColor = image[sr][sc]\\n        \\n        while queue:\\n            x, y = queue.pop(0)\\n            \\n            # Check if the pixel has the old color\\n            if image[x][y] == oldColor:\\n                image[x][y] = newColor\\n                \\n                for dx, dy in directions:\\n                    nx = x + dx\\n                    ny = y + dy\\n                    \\n                    if is_valid(nx, ny) and image[nx][ny] == oldColor:\\n                        queue.append((nx, ny))\\n        \\n        return image\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445650,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0,-1}, {0,1}, {1,0}, {-1,0}};\\n    void dfs(int i, int j, vector<vector<int>>& image, int oldColor, int newColor){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if( i < 0 || i>=n || j < 0 || j >= m || image[i][j] != oldColor)\\n            return;\\n        \\n        image[i][j] = newColor;\\n        for(auto &dir : dirs) {\\n            dfs(i+dir.first, j+dir.second, image, oldColor, newColor);\\n        }\\n    }\\n    void bfs(int i, int j, vector<vector<int>> &img, int old, int newc) {\\n        int n = img.size();\\n        int m = img[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        img[i][j] = newc;\\n\\n        int dir[4][2] = {{-1,0} , {1,0}, {0,-1}, {0,1}};\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n\\n            for(int i=0; i<4; i++){\\n                int newi = curr.first + dir[i][0];\\n                int newj = curr.second + dir[i][1];\\n\\n                if(newi < 0 || newi>=n || newj < 0 || newj >= m || img[newi][newj] != old)\\n                    continue;\\n                q.push({newi, newj});\\n                img[newi][newj] = newc;\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if(color != newColor)\\n            bfs(sr, sc, image, image[sr][sc], newColor);\\n        return image;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        src_col = image[sr][sc]\\n        if src_col == color:\\n            return image\\n        \\n        flood = [(sr,sc)]\\n        width = len(image)\\n        height = len(image[0])\\n        while flood:\\n            curr = flood.pop(0)\\n            image[curr[0]][curr[1]] = color\\n            if (up:=curr[0]-1) >= 0 and src_col == image[up][curr[1]]:\\n                flood.append((up, curr[1]))\\n\\n            if (down:=curr[0]+1) < width and src_col == image[down][curr[1]]:\\n                flood.append((down, curr[1]))\\n\\n            if (left:=curr[1]-1) >= 0 and src_col == image[curr[0]][left]:\\n                flood.append((curr[0], left))\\n            \\n            if (right:=curr[1]+1) < height and src_col == image[curr[0]][right]:\\n                flood.append((curr[0], right))\\n\\n        return image\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        if (image[sr][sc] == color) {\\n            return image;\\n        }\\n        fill(image, sr, sc, image[sr][sc], color);\\n        return image;\\n    }\\n    public void fill(int[][] image, int sr, int sc, int org, int color) {\\n        if (sr >= 0 && sc >= 0 && sr < image.length && sc < image[0].length && image[sr][sc] == org) {\\n            image[sr][sc] = color;\\n            fill(image, sr-1, sc, org, color);\\n            fill(image, sr+1, sc, org, color);\\n            fill(image, sr, sc-1, org, color);\\n            fill(image, sr, sc+1, org, color);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0,-1}, {0,1}, {1,0}, {-1,0}};\\n    void dfs(int i, int j, vector<vector<int>>& image, int oldColor, int newColor){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if( i < 0 || i>=n || j < 0 || j >= m || image[i][j] != oldColor)\\n            return;\\n        \\n        image[i][j] = newColor;\\n        for(auto &dir : dirs) {\\n            dfs(i+dir.first, j+dir.second, image, oldColor, newColor);\\n        }\\n    }\\n    void bfs(int i, int j, vector<vector<int>> &img, int old, int newc) {\\n        int n = img.size();\\n        int m = img[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        img[i][j] = newc;\\n\\n        int dir[4][2] = {{-1,0} , {1,0}, {0,-1}, {0,1}};\\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n\\n            for(int i=0; i<4; i++){\\n                int newi = curr.first + dir[i][0];\\n                int newj = curr.second + dir[i][1];\\n\\n                if(newi < 0 || newi>=n || newj < 0 || newj >= m || img[newi][newj] != old)\\n                    continue;\\n                q.push({newi, newj});\\n                img[newi][newj] = newc;\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if(color != newColor)\\n            bfs(sr, sc, image, image[sr][sc], newColor);\\n        return image;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        src_col = image[sr][sc]\\n        if src_col == color:\\n            return image\\n        \\n        flood = [(sr,sc)]\\n        width = len(image)\\n        height = len(image[0])\\n        while flood:\\n            curr = flood.pop(0)\\n            image[curr[0]][curr[1]] = color\\n            if (up:=curr[0]-1) >= 0 and src_col == image[up][curr[1]]:\\n                flood.append((up, curr[1]))\\n\\n            if (down:=curr[0]+1) < width and src_col == image[down][curr[1]]:\\n                flood.append((down, curr[1]))\\n\\n            if (left:=curr[1]-1) >= 0 and src_col == image[curr[0]][left]:\\n                flood.append((curr[0], left))\\n            \\n            if (right:=curr[1]+1) < height and src_col == image[curr[0]][right]:\\n                flood.append((curr[0], right))\\n\\n        return image\\n```\n```Java []\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        if (image[sr][sc] == color) {\\n            return image;\\n        }\\n        fill(image, sr, sc, image[sr][sc], color);\\n        return image;\\n    }\\n    public void fill(int[][] image, int sr, int sc, int org, int color) {\\n        if (sr >= 0 && sc >= 0 && sr < image.length && sc < image[0].length && image[sr][sc] == org) {\\n            image[sr][sc] = color;\\n            fill(image, sr-1, sc, org, color);\\n            fill(image, sr+1, sc, org, color);\\n            fill(image, sr, sc-1, org, color);\\n            fill(image, sr, sc+1, org, color);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420500,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static void move( int[][] i , int r , int  c , int nc , int pc ){\\n\\n        if( r == -1 || r == i.length || c == -1 || c == i[0].length ) return;\\n\\n        if( i[r][c] != pc ) return;\\n        \\n        i[r][c] = nc;\\n\\n        move( i , r , c + 1 , nc , pc );\\n        move( i , r - 1 , c , nc , pc );\\n        move( i , r + 1 , c , nc , pc );\\n        move( i , r , c - 1 , nc , pc );\\n\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        if( image[sr][sc] == color ) return image;\\n        \\n        move( image , sr , sc , color , image[sr][sc] );\\n\\n        return image;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static void move( int[][] i , int r , int  c , int nc , int pc ){\\n\\n        if( r == -1 || r == i.length || c == -1 || c == i[0].length ) return;\\n\\n        if( i[r][c] != pc ) return;\\n        \\n        i[r][c] = nc;\\n\\n        move( i , r , c + 1 , nc , pc );\\n        move( i , r - 1 , c , nc , pc );\\n        move( i , r + 1 , c , nc , pc );\\n        move( i , r , c - 1 , nc , pc );\\n\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        if( image[sr][sc] == color ) return image;\\n        \\n        move( image , sr , sc , color , image[sr][sc] );\\n\\n        return image;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393972,
                "title": "python-simple-solution-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, color):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        oldColor=image[sr][sc]\\n\\n        if oldColor==color:\\n            return image\\n        def dfs(img,r,c):\\n            if r<0 or r>=len(img) or c<0 or c>=len(img[0]) or img[r][c]!=oldColor:\\n                return \\n            img[r][c]=color\\n            dfs(img,r-1,c)\\n            dfs(img,r+1,c)\\n            dfs(img,r,c-1)\\n            dfs(img,r,c+1)\\n            \\n        dfs(image,sr,sc)\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def floodFill(self, image, sr, sc, color):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :type sr: int\\n        :type sc: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        oldColor=image[sr][sc]\\n\\n        if oldColor==color:\\n            return image\\n        def dfs(img,r,c):\\n            if r<0 or r>=len(img) or c<0 or c>=len(img[0]) or img[r][c]!=oldColor:\\n                return \\n            img[r][c]=color\\n            dfs(img,r-1,c)\\n            dfs(img,r+1,c)\\n            dfs(img,r,c-1)\\n            dfs(img,r,c+1)\\n            \\n        dfs(image,sr,sc)\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393918,
                "title": "java-simple-solution-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        dfs(image, sr, sc, image[sr][sc], color);\\n        return image;\\n    }\\n\\n    public void dfs(int[][] image, int sr, int sc, int oldColor, int color){\\n        // check base conditions\\n        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor || image[sr][sc] == color) return;\\n        // color image\\n        image[sr][sc] = color;\\n        // call dfs on all 4 directions\\n        dfs(image, sr + 1, sc, oldColor, color);\\n        dfs(image, sr - 1, sc, oldColor, color);\\n        dfs(image, sr, sc + 1, oldColor, color);\\n        dfs(image, sr, sc - 1, oldColor, color);\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        dfs(image, sr, sc, image[sr][sc], color);\\n        return image;\\n    }\\n\\n    public void dfs(int[][] image, int sr, int sc, int oldColor, int color){\\n        // check base conditions\\n        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor || image[sr][sc] == color) return;\\n        // color image\\n        image[sr][sc] = color;\\n        // call dfs on all 4 directions\\n        dfs(image, sr + 1, sc, oldColor, color);\\n        dfs(image, sr - 1, sc, oldColor, color);\\n        dfs(image, sr, sc + 1, oldColor, color);\\n        dfs(image, sr, sc - 1, oldColor, color);\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380817,
                "title": "swift-easy-solution-100",
                "content": "```\\nclass Solution {\\n    func floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ color: Int) -> [[Int]] {\\n        if image[sr][sc] == color { \\n            return image\\n        }\\n        var currentImage = image\\n        fill(&currentImage, sr, sc, image[sr][sc], color)\\n        return currentImage\\n    }\\n\\n    private func fill(_ image: inout [[Int]], _ sr: Int, _ sc: Int, _ color: Int, _ newColor: Int) -> Void {\\n        if sr < 0 || sc < 0 || sr >= image.count || sc >= image[0].count || image[sr][sc] != color {\\n            return\\n        }\\n        image[sr][sc] = newColor\\n        fill(&image, sr - 1, sc, color, newColor)\\n        fill(&image, sr + 1, sc, color, newColor)\\n        fill(&image, sr, sc - 1, color, newColor)\\n        fill(&image, sr, sc + 1, color, newColor)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ color: Int) -> [[Int]] {\\n        if image[sr][sc] == color { \\n            return image\\n        }\\n        var currentImage = image\\n        fill(&currentImage, sr, sc, image[sr][sc], color)\\n        return currentImage\\n    }\\n\\n    private func fill(_ image: inout [[Int]], _ sr: Int, _ sc: Int, _ color: Int, _ newColor: Int) -> Void {\\n        if sr < 0 || sc < 0 || sr >= image.count || sc >= image[0].count || image[sr][sc] != color {\\n            return\\n        }\\n        image[sr][sc] = newColor\\n        fill(&image, sr - 1, sc, color, newColor)\\n        fill(&image, sr + 1, sc, color, newColor)\\n        fill(&image, sr, sc - 1, color, newColor)\\n        fill(&image, sr, sc + 1, color, newColor)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325129,
                "title": "java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust apply the basic BFS technique to solve this question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS Algorithim \\n\\n# Code\\n```\\nclass Pair\\n{\\n    int row;\\n    int col;\\n    Pair(int r,int c)\\n    {\\n        this.row=r;\\n        this.col=c;\\n    }\\n}\\nclass Solution \\n{\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) \\n    {\\n             int n=image.length;\\n             int m=image[0].length;\\n             int iniclr=image[sr][sc];\\n             int newclr=color;\\n             Queue<Pair>q=new LinkedList<>();\\n             q.add(new Pair(sr,sc));\\n             int delrow[]={-1,0,1,0};\\n             int delcol[]={0,-1,0,1}; \\n             int ans[][]=image;\\n\\n             while(!q.isEmpty())\\n             {\\n                 int r=q.peek().row;\\n                 int c=q.peek().col;\\n                 ans[r][c]=newclr;\\n                  q.poll();\\n                 for(int i=0;i<4;i++)\\n                 {\\n                    int nrow=r+delrow[i];\\n                    int ncol=c+delcol[i];\\n                    if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && image[nrow][ncol]==iniclr && ans[nrow][ncol]!=newclr)\\n                    {\\n                        q.add(new Pair(nrow,ncol));\\n                    }\\n                 }\\n             }\\n\\n             return ans;\\n    }\\n}\\n\\n\\n\\n**PLS UPVOTE** \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair\\n{\\n    int row;\\n    int col;\\n    Pair(int r,int c)\\n    {\\n        this.row=r;\\n        this.col=c;\\n    }\\n}\\nclass Solution \\n{\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) \\n    {\\n             int n=image.length;\\n             int m=image[0].length;\\n             int iniclr=image[sr][sc];\\n             int newclr=color;\\n             Queue<Pair>q=new LinkedList<>();\\n             q.add(new Pair(sr,sc));\\n             int delrow[]={-1,0,1,0};\\n             int delcol[]={0,-1,0,1}; \\n             int ans[][]=image;\\n\\n             while(!q.isEmpty())\\n             {\\n                 int r=q.peek().row;\\n                 int c=q.peek().col;\\n                 ans[r][c]=newclr;\\n                  q.poll();\\n                 for(int i=0;i<4;i++)\\n                 {\\n                    int nrow=r+delrow[i];\\n                    int ncol=c+delcol[i];\\n                    if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && image[nrow][ncol]==iniclr && ans[nrow][ncol]!=newclr)\\n                    {\\n                        q.add(new Pair(nrow,ncol));\\n                    }\\n                 }\\n             }\\n\\n             return ans;\\n    }\\n}\\n\\n\\n\\n**PLS UPVOTE** \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321489,
                "title": "easy-bfs-solution-no-visited-matrix-required",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n= image.size();\\n        int m= image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int ori= image[sr][sc];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        if (ori==color)return image;\\n        image[sr][sc]= color;\\n        while (!q.empty()){\\n            pair<int,int> ele= q.front(); q.pop();\\n            for (int i=0; i<4; i++){\\n                int x= ele.first+ dx[i];\\n                int y= ele.second+ dy[i];\\n                if (x>=0 && y>=0 && x<n && y<m && image[x][y]==ori){\\n                    q.push({x,y});\\n                    image[x][y]= color;\\n                }\\n            }\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n= image.size();\\n        int m= image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int ori= image[sr][sc];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        if (ori==color)return image;\\n        image[sr][sc]= color;\\n        while (!q.empty()){\\n            pair<int,int> ele= q.front(); q.pop();\\n            for (int i=0; i<4; i++){\\n                int x= ele.first+ dx[i];\\n                int y= ele.second+ dy[i];\\n                if (x>=0 && y>=0 && x<n && y<m && image[x][y]==ori){\\n                    q.push({x,y});\\n                    image[x][y]= color;\\n                }\\n            }\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313649,
                "title": "easy-100-faster-java-solution",
                "content": "# Complexity\\n- Time complexity:\\n- O(M*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        if (image[sr][sc] == color) return image;\\n        int newColor = image[sr][sc];\\n        fun(image,sr,sc,color,newColor);\\n        return image;\\n    }\\n\\n    public void fun(int[][] image, int sr, int sc, int color,int newColor){\\n        if(sr<0 || sr>= image.length || sc<0 || sc>= image[0].length || image[sr][sc] != newColor) return;\\n        image[sr][sc] = color;\\n        fun(image,sr+1,sc,color,newColor);\\n        fun(image,sr-1,sc,color,newColor);\\n        fun(image,sr,sc+1,color,newColor);\\n        fun(image,sr,sc-1,color,newColor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        if (image[sr][sc] == color) return image;\\n        int newColor = image[sr][sc];\\n        fun(image,sr,sc,color,newColor);\\n        return image;\\n    }\\n\\n    public void fun(int[][] image, int sr, int sc, int color,int newColor){\\n        if(sr<0 || sr>= image.length || sc<0 || sc>= image[0].length || image[sr][sc] != newColor) return;\\n        image[sr][sc] = color;\\n        fun(image,sr+1,sc,color,newColor);\\n        fun(image,sr-1,sc,color,newColor);\\n        fun(image,sr,sc+1,color,newColor);\\n        fun(image,sr,sc-1,color,newColor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304998,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n    public void dfs(int[][] image, int r, int c, int color, int newColor) {\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\\n            if (r+1 < image.length) dfs(image, r+1, c, color, newColor);\\n            if (c+1 < image[0].length) dfs(image, r, c+1, color, newColor);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n    public void dfs(int[][] image, int r, int c, int color, int newColor) {\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\\n            if (r+1 < image.length) dfs(image, r+1, c, color, newColor);\\n            if (c+1 < image[0].length) dfs(image, r, c+1, color, newColor);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271796,
                "title": "typescript-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(n) === O(rows * cols)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction floodFill(image: number[][], sr: number, sc: number, color: number): number[][] {\\n    // Store the number of rows and columns in the image array\\n    const ROWS: number = image.length;\\n    const COLS: number = image[0].length;\\n\\n    // Store the color of the starting pixel\\n    const startColor: number = image[sr][sc];\\n\\n    // If the starting color is already the new color, return the original image\\n    if(startColor === color) {\\n        return image;\\n    }\\n\\n    // DFS (Depth First Search) algorithm\\n    function dfs(row: number, col: number): void {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS || image[row][col] !== startColor) {\\n            return;\\n        }\\n\\n        // Change the color of the current pixel to the new color\\n        image[row][col] = color;\\n\\n        // Recursively call dfs on the neighboring pixels\\n        dfs(row - 1, col); // up\\n        dfs(row + 1, col); // down\\n        dfs(row, col - 1); // left\\n        dfs(row, col + 1); // right\\n    }\\n\\n    // Call dfs on the starting pixel\\n    dfs(sr, sc);\\n\\n    return image;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction floodFill(image: number[][], sr: number, sc: number, color: number): number[][] {\\n    // Store the number of rows and columns in the image array\\n    const ROWS: number = image.length;\\n    const COLS: number = image[0].length;\\n\\n    // Store the color of the starting pixel\\n    const startColor: number = image[sr][sc];\\n\\n    // If the starting color is already the new color, return the original image\\n    if(startColor === color) {\\n        return image;\\n    }\\n\\n    // DFS (Depth First Search) algorithm\\n    function dfs(row: number, col: number): void {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS || image[row][col] !== startColor) {\\n            return;\\n        }\\n\\n        // Change the color of the current pixel to the new color\\n        image[row][col] = color;\\n\\n        // Recursively call dfs on the neighboring pixels\\n        dfs(row - 1, col); // up\\n        dfs(row + 1, col); // down\\n        dfs(row, col - 1); // left\\n        dfs(row, col + 1); // right\\n    }\\n\\n    // Call dfs on the starting pixel\\n    dfs(sr, sc);\\n\\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3236918,
                "title": "beats-82-92-memory-both-dfs-and-bfs-approaches-c",
                "content": "\\n\\n# DFS Approach\\n```\\nclass Solution {\\npublic:\\n\\n     void dfs(int n,int m,int row, int col,vector<vector<int>>& ans,vector<vector<int>>& image,int ic,int color,int dr[],int dc[]){\\n         ans[row][col] = color;\\n         for(int i=0;i<4;i++){\\n             int nr = row + dr[i]; /////neighbour row\\n             int nc = col + dc[i]; /////neighbour col\\n             if(nr >= 0 && nr < n && nc >=0 && nc < m && ans[nr][nc] != color && image[nr][nc] == ic){\\n                 ans[nr][nc] = color;\\n                 dfs(n,m,nr,nc,ans,image,ic,color,dr,dc);\\n             }\\n         }\\n     }\\n\\n\\n\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n        int ic = image[sr][sc]; //// initial color\\n        vector<vector<int>>ans = image; /// 2-D vector ans is acting as a visited array\\n        int dr[] = {-1,0,1,0};  // for traversing matrix w.r.t a paricular cell\\n        int dc[] = {0,1,0,-1};\\n         dfs(n,m,sr,sc,ans,image,ic,color,dr,dc);\\n        \\n        return ans;  \\n    }\\n};\\n```\\n\\n\\n\\n# BFS Approach\\n```\\nclass Solution {\\npublic:\\n    void bfs(int n,int m,int row, int col,vector<vector<int>>& ans,vector<vector<int>>& image,int ic,int color,int dr[],int dc[]){\\n        ans[row][col] = color;\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size() != 0){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nr = r + dr[i]; /////neighbour row\\n                int nc = c + dc[i]; /////neighbour col\\n                if(nr >= 0 && nr < n && nc >=0 && nc < m && ans[nr][nc] != color && image[nr][nc] == ic){\\n                    ans[nr][nc] = color;\\n                    q.push({nr,nc});\\n                }\\n        }\\n        }\\n        \\n    }\\n\\n\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n        int ic = image[sr][sc]; //// initial color\\n        vector<vector<int>>ans = image; /// 2-D vector ans is acting as a visited array\\n        int dr[] = {-1,0,1,0};  // for traversing matrix w.r.t a paricular cell\\n        int dc[] = {0,1,0,-1};\\n        bfs(n,m,sr,sc,ans,image,ic,color,dr,dc);\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     void dfs(int n,int m,int row, int col,vector<vector<int>>& ans,vector<vector<int>>& image,int ic,int color,int dr[],int dc[]){\\n         ans[row][col] = color;\\n         for(int i=0;i<4;i++){\\n             int nr = row + dr[i]; /////neighbour row\\n             int nc = col + dc[i]; /////neighbour col\\n             if(nr >= 0 && nr < n && nc >=0 && nc < m && ans[nr][nc] != color && image[nr][nc] == ic){\\n                 ans[nr][nc] = color;\\n                 dfs(n,m,nr,nc,ans,image,ic,color,dr,dc);\\n             }\\n         }\\n     }\\n\\n\\n\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n        int ic = image[sr][sc]; //// initial color\\n        vector<vector<int>>ans = image; /// 2-D vector ans is acting as a visited array\\n        int dr[] = {-1,0,1,0};  // for traversing matrix w.r.t a paricular cell\\n        int dc[] = {0,1,0,-1};\\n         dfs(n,m,sr,sc,ans,image,ic,color,dr,dc);\\n        \\n        return ans;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void bfs(int n,int m,int row, int col,vector<vector<int>>& ans,vector<vector<int>>& image,int ic,int color,int dr[],int dc[]){\\n        ans[row][col] = color;\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size() != 0){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nr = r + dr[i]; /////neighbour row\\n                int nc = c + dc[i]; /////neighbour col\\n                if(nr >= 0 && nr < n && nc >=0 && nc < m && ans[nr][nc] != color && image[nr][nc] == ic){\\n                    ans[nr][nc] = color;\\n                    q.push({nr,nc});\\n                }\\n        }\\n        }\\n        \\n    }\\n\\n\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n        int ic = image[sr][sc]; //// initial color\\n        vector<vector<int>>ans = image; /// 2-D vector ans is acting as a visited array\\n        int dr[] = {-1,0,1,0};  // for traversing matrix w.r.t a paricular cell\\n        int dc[] = {0,1,0,-1};\\n        bfs(n,m,sr,sc,ans,image,ic,color,dr,dc);\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207250,
                "title": "beats-100-simple-solution-using-dfs-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static void dfs(int[][] image, int row, int col,int old, int color){\\n        if(row<0 || row>=image.length || col<0 || col>=image[0].length || image[row][col] != old ){\\n            return;\\n        }\\n        image[row][col]=color;\\n        dfs(image, row+1, col, old, color);\\n        dfs(image, row-1, col, old, color);\\n        dfs(image, row, col+1, old, color);\\n        dfs(image, row, col-1, old, color);\\n\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       if(image[sr][sc] != color){\\n           dfs(image, sr, sc,image[sr][sc],color);\\n       }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void dfs(int[][] image, int row, int col,int old, int color){\\n        if(row<0 || row>=image.length || col<0 || col>=image[0].length || image[row][col] != old ){\\n            return;\\n        }\\n        image[row][col]=color;\\n        dfs(image, row+1, col, old, color);\\n        dfs(image, row-1, col, old, color);\\n        dfs(image, row, col+1, old, color);\\n        dfs(image, row, col-1, old, color);\\n\\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       if(image[sr][sc] != color){\\n           dfs(image, sr, sc,image[sr][sc],color);\\n       }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204728,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image, int sr, int sc, int color,int row,int col,int source){\\n        if(sr<0 || sr>=row || sc<0 || sc>=col){\\n            return;\\n        }\\n        else if(image[sr][sc]!=source){\\n            return;\\n        }\\n        image[sr][sc]=color;\\n        dfs(image,sr-1,sc,color,row,col,source);\\n        //calling to top\\n        dfs(image,sr+1,sc,color,row,col,source);\\n        //calling to bottom\\n        dfs(image,sr,sc-1,color,row,col,source);\\n        //calling to left\\n        dfs(image,sr,sc+1,color,row,col,source);\\n        //calling to right\\n\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        if(color==image[sr][sc]){\\n            return image;\\n        }\\n        int row=image.size();\\n        int col=image[0].size();\\n        int source = image[sr][sc];\\n        dfs(image,sr,sc,color,row,col,source);\\n        return image ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& image, int sr, int sc, int color,int row,int col,int source){\\n        if(sr<0 || sr>=row || sc<0 || sc>=col){\\n            return;\\n        }\\n        else if(image[sr][sc]!=source){\\n            return;\\n        }\\n        image[sr][sc]=color;\\n        dfs(image,sr-1,sc,color,row,col,source);\\n        //calling to top\\n        dfs(image,sr+1,sc,color,row,col,source);\\n        //calling to bottom\\n        dfs(image,sr,sc-1,color,row,col,source);\\n        //calling to left\\n        dfs(image,sr,sc+1,color,row,col,source);\\n        //calling to right\\n\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        if(color==image[sr][sc]){\\n            return image;\\n        }\\n        int row=image.size();\\n        int col=image[0].size();\\n        int source = image[sr][sc];\\n        dfs(image,sr,sc,color,row,col,source);\\n        return image ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185874,
                "title": "easiest-solution-dfs-java",
                "content": "- 277/277 cases passed (0 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 63.19 % of java submissions (43.2 MB)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    void change(int[][] image, int r, int c, int prevC,int nextC){\\n        if(r<0 || c<0 || r>=image.length || c>=image[0].length || image[r][c]==nextC || image[r][c]!=prevC)return;\\n\\n        image[r][c]=nextC;\\n        change(image, r, c+1, prevC,nextC);\\n        change(image, r, c-1, prevC,nextC);\\n        change(image, r+1, c, prevC,nextC);\\n        change(image, r-1, c, prevC,nextC); \\n        \\n    }\\n\\n    public int[][] floodFill(int[][] image, int row, int column, int color) {\\n        change(image, row, column, image[row][column], color);\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    void change(int[][] image, int r, int c, int prevC,int nextC){\\n        if(r<0 || c<0 || r>=image.length || c>=image[0].length || image[r][c]==nextC || image[r][c]!=prevC)return;\\n\\n        image[r][c]=nextC;\\n        change(image, r, c+1, prevC,nextC);\\n        change(image, r, c-1, prevC,nextC);\\n        change(image, r+1, c, prevC,nextC);\\n        change(image, r-1, c, prevC,nextC); \\n        \\n    }\\n\\n    public int[][] floodFill(int[][] image, int row, int column, int color) {\\n        change(image, row, column, image[row][column], color);\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569586,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1567115,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1782933,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1753116,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1635170,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1754427,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1746460,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1857929,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1572422,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1728040,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1569586,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1567115,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1782933,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1753116,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1635170,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1754427,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1746460,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1857929,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1572422,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1728040,
                "content": [
                    {
                        "username": "poorsolutions",
                        "content": "I spent like an hour trying to figure this out. Why is this considered a easy? Are dynamic/bfs problems that are more than a basic question still considered easy? Seems like this problem should be a medium."
                    },
                    {
                        "username": "aaronshaver",
                        "content": "It did feel like a Medium to me too"
                    },
                    {
                        "username": "SubinSunny",
                        "content": "[@anuragtekam0](/anuragtekam0) where did you learn that? can you provide the link?"
                    },
                    {
                        "username": "Rimberse",
                        "content": "It feels like it belongs to easy, because you can just apply DFS template and solve it.\\nIt has no annoying edge-cases or verifications. You aren\\'t required to do anything else.\\nBut to be fair, imho graph problems belong to \\'Medium\\' category, since you have to know BFS/DFS and algos beforehand."
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "I mean, it\\'s easy for the topic, but in general it\\'s kinda medium."
                    },
                    {
                        "username": "ckc9759",
                        "content": "It\\'s an easy question only because you have to apply basic recursive dfs. DFS can be really challenging, lengthy and time taking to understand and code sometimes. Considering the level of dfs in this particular question, it\\'s an easy one as u have to do only 3 things : base condition, visited condition and recursive call which is almost there in every bfs dfs algos."
                    },
                    {
                        "username": "anuragtekam0",
                        "content": "Just learned dfs/bfs on graphs and solved it, seems really easy to me."
                    },
                    {
                        "username": "chikmid",
                        "content": "I dont understand what they mean by 4-directionally connected. What does it mean? why is the 1 in the right bottom corner ignored in the example?"
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "Because it\\'s not touched by any other 1 in direction up down left or right"
                    },
                    {
                        "username": "arbind-m",
                        "content": "don\\'t know, i also not know why the last 1 ignored"
                    },
                    {
                        "username": "ckc9759",
                        "content": "It is because you have no path to reach there using 1s. A 0 is in the path and hence, u can\\'t reach there. The question mentions u can only traverse to those pixels which have the same value and are connect in any NSEW direction."
                    },
                    {
                        "username": "ra_hul",
                        "content": "its ignored because it\\'s unreachable. The condition is you move in 4-directions only iff they match the color that was initially at (sr, sc)"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro all the four directions(up,down,right,left) must be connected or must have the same number as the initial number\\n"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "it means top down left right but the bottom right is connected diagonally bottom right to the middle cell so it is not in the 4 directional path"
                    },
                    {
                        "username": "frankprvt",
                        "content": "I think it means the two pixels need to share a same edge."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I like cats"
                    },
                    {
                        "username": "Priyanka5673",
                        "content": "best comment haha\\n"
                    },
                    {
                        "username": "thedenisnikulin",
                        "content": "nice bro"
                    },
                    {
                        "username": "user0049Bu",
                        "content": "I don\\'t like the task description. It\\'s unclear from  my point of view.\\nI can not think about how to solve the task, I had to try to undertand this unclear description."
                    },
                    {
                        "username": "honeybadgerofdoom",
                        "content": "4-Directionally connected means connected horizontally or vertically. In the first example, upper-left, upper-right, and lower-left are colored because they are connected to pixels that are 4-directionally connected (specification says \"plus any pixels connected 4-directionally to those pixels (also with the same color), and so on\"). Lower-right is not colored because it is not 4-directionally connected nor is it touching any pixel which is."
                    },
                    {
                        "username": "sundram99",
                        "content": "this help a lot, thanks "
                    },
                    {
                        "username": "tanmoyie",
                        "content": "thanks for the interpretation"
                    },
                    {
                        "username": "AnuKumar_92",
                        "content": "Still not clear."
                    },
                    {
                        "username": "SumanMax",
                        "content": "Instead of upper-left or lower-right, can you please confirm if these are the 4 directions if starting point is (x, y) => {(x+1, y), (x-1, y), (x, y+1), (x, y-1)}\\n "
                    },
                    {
                        "username": "guddnr2424",
                        "content": "second case is really ambiguous. you should read second-case carefully"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "THEY GAVE THAT ON PURPOSE"
                    },
                    {
                        "username": "ahoang512",
                        "content": "Agreed. "
                    },
                    {
                        "username": "karteek1999",
                        "content": "I am facing StackOverflowError when I try to run the solution in leetcode, where as the exact same code works properly in my local IDE, Any idea why this might be happening?\\n"
                    },
                    {
                        "username": "user7253JE",
                        "content": "Same happened to me, looking into other solutions I had to add an additional check before calling the recursive method:\\nif(image[sr][sc] == color) return image;\\nI am assuming Leetcode runs on low memory hence when not writing efficient code this could happen"
                    },
                    {
                        "username": "jpjitendrapal",
                        "content": "4-directionally should be explained in detail"
                    },
                    {
                        "username": "danielezhu",
                        "content": "Hi all, I\\'m pretty new to the LeetCode platform, so please pardon me if this is a dumb question. Basically, I noticed that when I submitted the same exact solution multiple times, the first time it ran in 60 ms and beat 100% of python solutions, but the second time I submitted the exact same thing, it took 64 ms (and beat only around 77%). Is there any reason for this? \\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553745.png)\\n![image](https://assets.leetcode.com/users/ghostdash/image_1548553806.png)\\n\\n"
                    },
                    {
                        "username": "f20210468",
                        "content": "This message is pretty late, but the entire idea of \"Beats x%\" is useless, as many more things are coming into account, like server response time and so on."
                    },
                    {
                        "username": "najwer23",
                        "content": "[@HapticBovine](/HapticBovine) quality content :D"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Yes. You can go from 5% to 100% just by submitting again.\\n\\nThe purpose is to help you realize that your programming career is not determined by anything more than luck and persistence. Thinking has nothing to do with it."
                    },
                    {
                        "username": "myapapaya",
                        "content": "I ran into a discrepancy between running the same code in LeetCode and VS Code. When I run this code in LeetCode, I get \"RecursionError: maximum recursion depth exceeded in comparison\":\n`class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image`\n\nHowever, when I run this modified code in vsCode, it runs fine and returns the proper output [[2, 2, 2], [2, 2, 0], [2, 0, 1]]:\n\n` class Solution:\n    def floodFill(self, image, sr, sc, color):\n        lastRowIdx = len(image) - 1\n        lastColIdx = len(image[0]) - 1\n        initColor = image[sr][sc]\n    \n        def recursiveFill(row, col, imageGrid):\n            if (row < 0 or row > lastRowIdx or col < 0 or col > lastColIdx):\n                return\n            \n            if (imageGrid[row][col] == initColor):\n                imageGrid[row][col] = color\n\n                #print(row, col)     #TEST\n                #print(imageGrid)    #TEST\n                \n                recursiveFill(row - 1, col, imageGrid)\n                recursiveFill(row + 1, col, imageGrid)\n                recursiveFill(row, col - 1, imageGrid)\n                recursiveFill(row, col + 1, imageGrid) \n\n            \n        recursiveFill(sr, sc, image)\n        \n        return image\n\n\ngraphInput = [[1,1,1],[1,1,0],[1,0,1]]\ntest = Solution()\nprint(test.floodFill(graphInput, 1, 1, 2))\n`\nAnyone have any idea why this is happening?"
                    },
                    {
                        "username": "myapapaya",
                        "content": "[@chernodub98](/chernodub98) Didn\\'t realize that was happening. I just added code to check for the 2nd test case (if color == initColor: return image) and it works now. Thank you so much! "
                    },
                    {
                        "username": "chernodub98",
                        "content": "the second test case is being run immediately after the first one. And you don\\'t have checks for this."
                    }
                ]
            },
            {
                "id": 1767658,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1729837,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1573735,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1569710,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1744968,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 2001740,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1883002,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1796632,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1783570,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1772601,
                "content": [
                    {
                        "username": "Hardik1830",
                        "content": "explanation should be more understandable."
                    },
                    {
                        "username": "HackHustler",
                        "content": "what it is giving tle?  can anyone help me here?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        //either solve by dfs or bfs\\n        //solving it with bfs\\n        //tempering data is crime, creating a copy of the image \\n        vector<vector<int>>ans= image;\\n\\n        int n= ans.size();\\n        int m= ans[0].size();\\n\\n        int vis[n][m];\\n        for(int i=0;i<n;i++){\\n            for( int j=0;j<m;j++){\\n                vis[i][j]=0;\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        vis[sr][sc]=color;\\n        int inicolor= image[sr][sc];\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n            int r= q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow= r+ drow[i];\\n                int ncol= c+dcol[i];\\n\\n                ///checking the boundary condition \\n                if(nrow>=0 && nrow <n && ncol>=0 && ncol<m && \\n                ans[nrow][ncol]==inicolor && vis[nrow][ncol]==0) {\\n                    vis[nrow][ncol]=color;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "I guess you should put \" ans[nrow][ncol] == color \" inside the if statement."
                    },
                    {
                        "username": "rishabh_bhatnagar",
                        "content": "![image](https://assets.leetcode.com/users/rishabh_bhatnagar/image_1589213131.png)\\nabove screenshot shows the difference in output. running the code gives correct output\\nwhereas after submission it shows error. don\\'t know why.\\n"
                    },
                    {
                        "username": "wufengxuan1230",
                        "content": "although I finished it, but it took me about 3 minutes to understand the meaning."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "nikal lavde"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "It took me nearly 10 to 15 min just to understand the question. Did not find solution till now."
                    },
                    {
                        "username": "raushan606",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer. \nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\n\nThe test case where it is failing: \nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\no/p = [[2,2,0],[2,2,0]]\nexpected = [[2,2,2],[2,2,2]]\n\nBut I am getting correct answer on my local machine.\n\nclass Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n                Queue<int[]> q = new LinkedList<>();\n        q.add(new int[] { sr, sc });\n        int pixel = image[sr][sc];\n        while (!q.isEmpty()) {\n            int[] cell = q.poll();\n            int r = cell[0];\n            int c = cell[1];\n\n            image[r][c] = newColor;\n            if (r - 1 >= 0 && image[r - 1][c] == pixel && image[r - 1][c] != newColor) \n                q.add(new int[] { r - 1, c });\n            if (r + 1 <= image.length - 1 && image[r + 1][c] == pixel && image[r + 1][c] != newColor)\n                q.add(new int[] { r + 1, c });\n            if (c - 1 >= 0 && image[r][c - 1] == pixel && image[r][c - 1] != newColor)\n                q.add(new int[] { r, c - 1 });\n            if (c + 1 <= image.length - 1 && image[r][c + 1] == pixel && image[r][c + 1] != newColor)\n                q.add(new int[] { r, c + 1 });\n        }\n\n        return image;\n    }\n}\n\nPlease anybody point out my mistake I am doing in this code."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "If you\\'re running into stack overflow no matter what, make sure to check for the edge case where image[sr][sc] = color. In other words, if your new color is the same as your old color, just return the image as it is."
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "you sir are  a  lifesaver"
                    },
                    {
                        "username": "Pikiato",
                        "content": "Do this kind of question actually comes up during interviews ? I\\'m applying for Front-end devs .. Do I have to worry about dealing with this ? "
                    },
                    {
                        "username": "blue_flag",
                        "content": "I find this problem ambiguous for case when starting color is equal to color to be filled."
                    },
                    {
                        "username": "KananMehta",
                        "content": "I think this problem is broken. I went back and resubmitted an old solution from september and it fails"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "I am trying to solve it using BFS iterative method but getting Wrong answer. But when I run this code on my local machine with same test case then it is giving correct answer.\\nWhat will the possible reason for this? I am pasting the bfs solution Java code below.\\n\\nThe test case where it is failing:\\nimage = [[0,0,0],[0,0,0]] sr=1, sc = 0, color = 2\\no/p = [[2,2,0],[2,2,0]]\\nexpected = [[2,2,2],[2,2,2]]\\n\\nBut I am getting correct answer on my local machine.\\n\\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n=image.size(),m=image[0].size();\\n        queue<pair<int,int>> q;\\n        vector<int> dir({-1,0,1,0,-1});\\n        vector<vector<int>> v=image;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int init_color=image[sr][sc];\\n        q.push({sr,sc});\\n        vis[sr][sc]=true;\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            v[r][c]=color;\\n            for(int i=0;i<dir.size()-1;i++){\\n                int row=r+dir[i];\\n                int col=c+dir[i+1];\\n                if(row>=0 && row<n && col>=0 && col<m && image[row][col]==init_color && !vis[row][col]){\\n                    vis[row][col]=true;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AANAND-RIMAL",
                        "content": "There seems to be an  small error in your code that is causing the issue in the test case. In the line where you\\'re creating the vis vector, you have vector<vector> vis(n, vector(n, false));. It should be vector<vector<bool>> vis(n, vector<bool>(m, false)); to correctly initialize a 2D vector of boolean values. "
                    },
                    {
                        "username": "orangewave",
                        "content": "I'm having the same issue. My code runs fine on my local machine (python) but it does not work on leetcode. My variables randomly get changed to 0. It is really strange:\n\n'''\nclass Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        self.image = image\n        m = len(self.image[0]) # x, sc\n        n = len(self.image) # y, sr\n        colorToFlood = self.image[sr][sc]\n        def dfs(y, x):\n            self.image[y][x] = color\n            directions = [(0,1), (1,0), (-1, 0), (0, -1)]\n            for d in directions:\n                ydir = y + d[0]\n                xdir = x + d[1]\n                if (0 <= xdir and xdir < m and 0 <= ydir and ydir < n and self.image[ydir][xdir] == colorToFlood):\n                    dfs(ydir, xdir)\n        dfs(sr, sc)\n        return self.image\n\n'''\n"
                    }
                ]
            },
            {
                "id": 1576822,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 1574206,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 1571891,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 2065057,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 2041314,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 2039908,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 2024956,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 2009852,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 1999871,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 1997405,
                "content": [
                    {
                        "username": "user5095J",
                        "content": "As far as I understood 4-directionally connected means vertical and horziantel connected (see Wikipedia and other discussions here), however in the first example 3 corners are considered connected that way though it seems they shouldn\\'t. What do I overlook here?"
                    },
                    {
                        "username": "pstrait",
                        "content": "Corners aren\\'t connected to the starting cell, but you may have overlooked this line from the instructions: \"plus any pixels connected 4-directionally to those pixels (also with the same color)\""
                    },
                    {
                        "username": "jithinbp",
                        "content": "Consider it like 1 is infected by 2 the condition for infection to spread is that the adjacent element(top, bottom, left, right) must be 1.\\nonce the infection is spread to adjacent elements we will get more carriers for spreading infection 2 but the conditions must be followed that ie, it must be adjacent and the color is the starting color(here, 1)\\n\\nhope this will help :) "
                    },
                    {
                        "username": "ArvindYadav10",
                        "content": "![image](https://assets.leetcode.com/users/images/3bc8097f-4cf9-450c-a6e2-3b58307f2921_1597335692.0153337.png)\\n"
                    },
                    {
                        "username": "mikagrubinen",
                        "content": "Hello,\\n\\nI am having problems to solve this in C. I don\\'t understand what these two parameters are and why are they used for \"..int** columnSizes, int* returnSize\".\\n\\nAny help would be appreciated.\\n\\nThanks"
                    },
                    {
                        "username": "LMS5400",
                        "content": "what does sr and sc stand for? is this x,y?"
                    },
                    {
                        "username": "LMS5400",
                        "content": "bah!, row column. names bro! they help!"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "are kehna kya chahte ho ?\\n"
                    },
                    {
                        "username": "muvgoggins",
                        "content": "this question is so unclear"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "need help with this dfs code , getting deadlysignal\\n\\nclass Solution {\\npublic:\\n    int M,N;\\n    void dfs(int i,int j,vector<vector<int>> &image,int scolor,int color){\\n        image[i][j]=color;\\n        int row[]={-1,0,1,0};\\n        int col[]={0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int nrow=i+row[k];\\n            int ncol=j+col[k];\\n            if(nrow>=0 && nrow<M && ncol>=0 && ncol<N && image[nrow][ncol]==scolor){\\n                dfs(nrow,ncol,image,scolor,color);\\n            }\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        int scolor=image[sr][sc];\\n        M=m,N=n;\\n        vector<vector<int>> ans=image;\\n        dfs(sr,sc,ans,scolor,color);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "vibhor2003",
                        "content": "I managed to come up with a logic for this but my code is exceeding the time limit lol. Will have to find a better way to code this, my current idea uses a queue to keep track of the pixels visited (bfs basically)... I will return to this question later."
                    },
                    {
                        "username": "dreamingbod",
                        "content": "this question needs two conditions at the same time:\\n(1) only same number as image[sr][sc] can flood fill(2) just up/down/left/right-side pixel those ever flood fill"
                    },
                    {
                        "username": "codymj",
                        "content": "Seems harder than it is. The key is to know you\\'re doing the same operation on many pixels which lends itself to be a recursion problem. From there, it\\'s just about checking boundaries and if the pixel has already been filled."
                    }
                ]
            },
            {
                "id": 1994759,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1983642,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1978874,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1957675,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1946610,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1936334,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1925586,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1876135,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1872735,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1867673,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "Tricky problem. Had trouble figuring out how to find an element is NOT adjacent to the same start color "
                    },
                    {
                        "username": "danicruz0415",
                        "content": "I resolved the problem and in the browser console works perfectly fine. But somehow when I run it it shows \"Runtime Error: process exited with signal SIGSEGV\". I looked up the error and it seems a C++ error but I am using JavaScript. Someone else has encounter this error? I saw a [GitHub issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7230) with this and it was closed pretty much with a \"see how other users did it\" answer, instead of actually addressing the problem. "
                    },
                    {
                        "username": "apu47",
                        "content": "I attempted an iterative BFS solution, but it occurs to me that the BFS function runs recursively, causing an error. Can anyone help me out here ? \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> BFS(int sr, int sc, int color, vector<vector<int>> &img){\\n        int i, j, m = img.size(), n = img[0].size(), prevcolor = img[sr][sc];\\n\\n        cout<<\"start\\\\n\";\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, int>> q;\\n        q.push({sr, sc});\\n        vis[sr][sc] = 1;\\n        img[sr][sc] = color;\\n\\n        while(!q.empty()){\\n            pair<int, int> qtop = q.front();\\n            q.pop();\\n            sr = qtop.first;\\n            sc = qtop.second;\\n\\n            for(i = -1; i <= 1; i++){\\n                for(j = -1; j <= 1; j++){\\n                    if(!(i == 0 || j == 0)) continue;\\n                    int nsr = sr + i;\\n                    int nsc = sc + j;\\n\\n                    if((nsr >= 0 && nsr < n) && (nsc >= 0 && nsc < m) && (!vis[nsr][nsc]) && (img[nsr][nsc] == prevcolor)){\\n                        vis[nsr][nsc] = 1;\\n                        img[nsr][nsc] = color;\\n                        q.push({nsr, nsc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        cout<<\"end\\\\n\";\\n\\n        return img;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n\\n        return BFS(sr, sc, color, image);\\n    }\\n};"
                    },
                    {
                        "username": "thesofakillers",
                        "content": "tf are these variable names \"sr, sc\" which one is y and x? "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "starting row and start column I guess. Generally in these grid/matrix question. r = row; c=column. "
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "Please tell where I\\'m wrong. Thanks.\\n\\nclass Solution {\\nprivate:\\n    void bfs(vector<vector<int>>& image, int in, int sr,int sc,int color){\\n        queue<pair<int,int>>q;\\n        q.push({sr,sc});\\n        if(image[sr][sc]==color) return;\\n        image[sr][sc] = color;\\n        while(!q.empty()){\\n            int nr = q.front().first;\\n            int nc = q.front().second;\\n            q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                if(abs(i)==abs(j)) continue;\\n                int newrow = nr+i;\\n                int newcol = nc+j;\\n                image[newrow][newcol] = color;\\n                q.push({newrow,newcol});\\n            }\\n        }\\n    }\\n    }\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int n = image.size();\\n        int m = image[0].size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                bfs(image,image[i][j],sr,sc,color);\\n            }\\n        }\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "https://leetcode.com/problems/flood-fill/submissions/975015183/\nwhat is wrong with my solution in PHP? It throws \"Memory Limit Exceeded\". But I just adapted the solution in Java of this guy on Youtube:\nhttps://www.youtube.com/watch?v=aehEcTEPtCs\nI mean, it says \"Wrong Answer\" in the submission, but actually when I press \"Run\" it says \"MLE\" so I cannot even test i debug it (though it shouldn't be anything to debug I guess)"
                    },
                    {
                        "username": "gary8520",
                        "content": "The is ambiguous about malloc in C.\n for convention:\n```\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n  const size_t colsz = (size_t) *imageColSize;\n  *returnSize = imageSize;\n  *returnColumnSizes = (int*)malloc(sizeof(int));\n  **returnColumnSizes = colsz;\n  int ** result = (int**) malloc(imageSize \\* sizeof(int*));\n  for(int i=0; i<imageSize; i++) {\n    result[i] = (int*) malloc(colsz * sizeof(int));\n  }\n```\n\nI am always get error  ==21==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000094 at pc 0x559f79bab66c bp 0x7ffc0a70a270 sp 0x7ffc0a70a260\nbut I can print my output of my `result` 2D array before return the function. it is means is not crash in my function.\nWhat is the usage about the array of array in main() ?????????\n"
                    },
                    {
                        "username": "Yosef5",
                        "content": "\nmy solution is stack overflowing on leetcode ive checked the conditions and run it on other compilers vs code and online but it fine \nive spent way too much time on this  found no way to stop stack overflowing \n```cpp\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n         \n            int  initCol = image[sr][sc];\n            image[sr][sc] = color;\n             if(sc + 1 < (int)image[0].size()  &&  image[sr][sc+1] == initCol)\n                floodFill(image,sr,sc+1,color);\n            if(sr - 1 >= 0  &&  image[sr-1][sc] == initCol)\n                floodFill(image,sr-1,sc,color);\n            if(sc - 1 >= 0  &&  image[sr][sc-1] == initCol)\n                floodFill(image,sr,sc-1,color);\n            if(sr + 1 < (int)image.size()  &&  image[sr+1][sc] == initCol)\n                floodFill(image,sr+1,sc,color) ;\n\n            return image;\n    }\n```\n "
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "Why it is showing Runtime Error my code is working fine!   This is my code:-  \\nfunction fillTheColor(image,r,c,color,curVal){\\n        console.log(r,c,image)\\n        if(r<0 || r>=image.length || c<0 || c>=image[0].length) return ;\\n        if(image[r][c]!=curVal) return ;\\n        image[r][c]=color;\\n        fillTheColor(image,r+1,c,color,curVal);\\n        fillTheColor(image,r-1,c,color,curVal);\\n        fillTheColor(image,r,c+1,color,curVal);\\n        fillTheColor(image,r,c-1,color,curVal);\\n}\\n\\nvar floodFill = function(image, sr, sc, color) {\\n    \\n        if(image[sr][sc]==color) return color;\\n\\n     fillTheColor(image,sr,sc,color,image[sr][sc])\\n     console.log(image)\\n        return image;\\n};"
                    },
                    {
                        "username": "mo1ok",
                        "content": "This is not LC-easy. This is more like LC-medium"
                    }
                ]
            },
            {
                "id": 1859592,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1859534,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1858384,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1855618,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1848484,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1846108,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1845660,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1828984,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1826772,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1798159,
                "content": [
                    {
                        "username": "mo1ok",
                        "content": "sr and sc are really bad variable names. Although I understand them, i have no idea what those acronyms are referring to."
                    },
                    {
                        "username": "zhujunsheng666",
                        "content": "image = [[0,0,0],[0,0,1]]\\nsr = 1\\nsc = 0\\ncolor = 2\\nwhy the answer is [[2,2,2],[2,2,1]]\\nI think it should be [[2,2,0],[2,2,1]]\\nbecause the image[0][2] can\\'t be infected in two floods! \\nwhere am I wrong? "
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "can someone please tell me what is wrong with my code? \\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n\\n    void DFS(int r, int c, vector<vector<int>>& image, int iniColor, int newColor){\\n        \\n        if(r<0||c<0||r==image.size()||c==image[0].size()) return;\\n        if(image[r][c]!=iniColor) return;\\n        image[r][c]=newColor;\\n        DFS(r-1,c,image,iniColor,newColor);\\n        DFS(r+1,c,image,iniColor,newColor);\\n        DFS(r,c-1,image,iniColor,newColor);\\n        DFS(r,c+1,image,iniColor,newColor);\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> ans=image;\\n        DFS(sr,sc,ans,image[sr][sc],color);\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\n\\nThe code gives some error but if I just replace second line of dfs function with,\\n\\n `your inline code...your inline code...`\\nif(image[r][c] == newColor||image[r][c]!=iniColor) return; \\n`your inline code...your inline code...`\\n\\nthe code works fine. As far as i know, the two lines are similar and they should work equally well....Please help"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "Should we modify the same input or make a copy and then solve this question? Keeping interview perspective in mind."
                    },
                    {
                        "username": "ShardulSurve",
                        "content": "class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n\\n        int n = image.length;\\n        int m= image[0].length;\\n        int [][] ans = image;\\n        // int [][] vis = new int[n][m];\\n\\n        int iniColor = image[sr][sc];\\n\\n        bfs(image, iniColor, color, ans ,  sr,  sc);\\n\\n        return ans;\\n\\n        \\n    }\\n\\n   public void bfs(int [][] image, int iniColor, int color, int [][]ans, int sr, int sc)\\n    {\\n\\n        int n = image.length;\\n        int m = image[0].length;\\n\\n        int [] dr = {-1,0,1,0};\\n        int [] dc = {0,-1,0,1};\\n\\n        ans[sr][sc]=color;\\n\\n        Queue<Pair> q = new LinkedList<>();\\n\\n        q.add( new Pair(sr,sc));\\n\\n        while(!q.isEmpty())\\n        {\\n            // int size = q.size();\\n            Pair  p = q.poll();\\n\\n            int row = p.first;\\n            int col = p.second;\\n\\n\\n            for(int i = 0 ; i<4 ; i++)\\n            {\\n\\n              int  del_row = row + dr[i];\\n              int  del_col = col + dc[i];\\n\\n                if(del_row>=0 && del_row<n && del_col>=0 && del_col<m && ans[del_row][del_col]==iniColor )\\n                {\\n\\n                     ans[del_row][del_col]=color;\\n                    q.add(new Pair(del_row,del_col));\\n                    \\n                }\\n\\n            }\\n           \\n\\n        }\\n\\n    }\\n\\n}\\n\\nclass Pair\\n{\\n    int first;\\n    int second;\\n\\n    public Pair(int first , int second)\\n    {\\n        this.first=first;\\n        this.second = second;\\n\\n    }\\n\\n}\\n\\n\\n\\nWhy does this code gives me TLE but when I add (&& ans[del_row][del_col]!=color) inside IF statement it gets accepted. Can anyone please explain ? thanks"
                    },
                    {
                        "username": "ankush920",
                        "content": "simple but optimized code for quick idea in c++\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nuse to traverse all useful index\\n\\nApproach\\nusing stack to store all the eligible index\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\n\\nSpace complexity:\\nO(m*n)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n \\n int m = image.size();\\n if( m==0)     //base condition\\n {\\nreturn image;\\n }\\n  int n = image[0].size();\\n       \\n stack<pair<int,int>>answer; ///to store value which remain for traversal \\n int store = image[sr][sc];\\n pair<int ,int>p1(sr,sc);\\n answer.push(p1);\\n \\nwhile( !answer.empty())\\n{\\n    pair<int,int>p = answer.top();\\nint i =p.first ; \\nint j =p.second;\\n\\nanswer.pop();\\nif( i >=m || j>=n || i<0 ||j<0||image[i][j]!=store ||image[i][j]==color ) ///some edge case condition \\n {    continue;\\n}\\n\\nimage[i][j]=color;\\npair<int,int> p1(i+1,j) , p2(i,j+1), p3(i-1 ,j) ,p4(i,j-1);\\n\\nanswer.push(p1);\\nanswer.push(p2);\\nanswer.push(p3);\\nanswer.push(p4);\\n\\n}  \\nreturn image;   \\n    }\\n};"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Thanks to CHAT-GPT who explained this algorithm."
                    },
                    {
                        "username": "psionl0",
                        "content": "Aarrgghh! Intermittent seg faults are the worst!\\n\\nSometimes my code works on test case 1 and sometimes it seg faults. The code will always fail on test case 256: [[8,4,5,3,2,2,2,6,9,5],[ 3,1,3,7,4,8,9,0,1,6],[0,7,1,7,5,2,2,8,6,9],[9,1,0,5,8,8,0,5,5,9],[3,4,9,5,4,8,0,2,7,5],[5,1,1,8,1,6,5,9,7,8],[9,7,9,4,5,3,4,1,8,2],[5,1,6,3,5,4,8,9,0,8],[8,8,6,1,0,8,0,6,9,9],[4,1,8,7,3,6,9,6,6,1]] sr=8, sc=0, color=9\\n\\nYet even then, judiciously inserted print statements show that the code is successfully running dfs and returning the results to floodFill. The seg fault apparently happens when floodFill returns to the (hidden) calling routine.\\n8 0\\n7 0\\n9 0\\n8 -1\\n8 1\\n7 1\\n9 1\\n8 0\\n8 2\\nNavigated dfs\\nReturn Array dimensioned\\nVisited array freed\\n\\nNeedless to say, the code runs faultlessly on my PC. I am ready to give up unless somebody has some suggestions.\\n"
                    },
                    {
                        "username": "user9306W",
                        "content": "I have written the following but I after a second thought, I felt it should not work, because \\'visited = [ ]\\' would empty the array everytime for the recursion call and not effectively keep tracking of those already visited pixels, so the recursion should just keep running between two pixels without stopping.\\nHowever, when I run this code, it actually worked, and even beats 80% in running time after submission. \\nI want to know how can this code work... Or it in reality is wrong, it\\'s just that the testing cases didn\\'t spot it. \\n\\nclass Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        start = image[sr][sc]\\n        if start == color:\\n            return image\\n        image[sr][sc] = color\\n        visited = []\\n        visited.append([sr, sc])\\n        if sc > 0 and [sr, sc-1] not in visited and start == image[sr][sc-1]:\\n            self.floodFill(image, sr, sc-1, color)\\n        if sc < len(image[0])-1 and [sr, sc+1] not in visited and start == image[sr][sc+1]:\\n            self.floodFill(image, sr, sc+1, color)\\n        if sr > 0 and [sr-1, sc] not in visited and start == image[sr-1][sc]:\\n             self.floodFill(image, sr-1, sc, color)\\n        if sr < len(image) -1 and [sr+1, sc] not in visited and start == image[sr+1][sc]:\\n            self.floodFill(image, sr+1, sc, color)\\n        return image\\n\\nMuch appreciated!!!"
                    },
                    {
                        "username": "sandeep202",
                        "content": "//WHAT IS WRONG IN THIS CODE CAN SOMEONE HELP ME FIGURE IT OUT . I\\'VE SPENT MORE THAN A COUPLE OF HOURS IN FIGURING OUT THE PROBLEM.\\n `\\n// Java implementation of the approach\\nimport java.util.*;\\nimport java.awt.Point;\\nclass Solution {\\n\\n    public void ff(int[][] image, int sr,int sc , int row, int col, int prevcol, int color){\\n        if(sr<0 || sc<0|| sr>=row || sc>=col )return;\\n        if(image[sr][sc]!= color)return;\\n        image[sr][sc]=color;\\n        int top =sr-1;\\n        int bottom = sr+1;\\n        int left = sc-1;\\n        int right = sc+1;\\n        ff(image,top,sc,row,col,prevcol,color);\\n        ff(image,bottom,sc,row,col,prevcol,color);\\n        ff(image,sr,left,row,col,prevcol,color);\\n        ff(image,sr,right,row,col,prevcol,color);\\n        \\n    }\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n    int prevcol = image[sr][sc];\\n    if(image[sr][sc]==color)return image;\\n    ff(image,sr,sc,image.length,image[0].length,prevcol,color);\\n        return image;\\n        \\n    }\\n}`\\n"
                    }
                ]
            },
            {
                "id": 1792258,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1775900,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1774034,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1766638,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1762561,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1760255,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1750245,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1747115,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1745837,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1743847,
                "content": [
                    {
                        "username": "user5112t",
                        "content": "class Solution {\\npublic:\\n    bool inside(int x,int y,int n, int m){\\n        if(x<0||x>=n||y<0||y>=m)return 0;\\n        else return 1;\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int dx[] = {1,0,-1,0};\\n        int dy[] = {0,1,0,-1};\\n        int m,n;\\n        n = image[0].size();\\n        m = image.size();\\n\\n        int prevc = image[sr][sc];\\n        image[sr][sc] = color;\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        while(!q.empty()){\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                if(inside(cur.first+dx[k],cur.second+dy[k],n,m)){\\n                    pair<int,int> neigh = {cur.first+dx[k],cur.second+dy[k]};\\n                    if(image[neigh.first][neigh.second] == prevc){ // relax\\n                        image[neigh.first][neigh.second] = color;\\n                        q.push(neigh);\\n                    }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}; `your inline code...your inline code...`\\n\\n\\n\\n\\nwhy this code is showing runtime error"
                    },
                    {
                        "username": "blue_flag",
                        "content": "try for 1st and 2nd example test case only. If that works then check the 3rd example"
                    },
                    {
                        "username": "dompolochak",
                        "content": "I keep getting a heap overload error for my solution but i cant figure out why it doesnt work can some please tell me what\\'s wrong \\n\\n `class Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        stack<pair<int,int>> s;\\n        pair<int,int> curr;\\n        int oldColor = image[sr][sc];\\n\\n        if(color == oldColor)\\n            return image;\\n        \\n\\n        s.push({sr,sc});\\n\\n        while(!s.empty()){\\n            curr= s.top();\\n            s.pop();\\n\\n            image[curr.first][curr.second]=color;\\n \\n            if(curr.first>0 && image[curr.first -1][curr.second] == oldColor){\\n                s.push({curr.first -1, curr.second});\\n            }\\n            if(curr.first<image[sr].size()-1 && image[curr.first +1][curr.second] == oldColor){\\n                s.push({curr.first +1, curr.second});\\n            }\\n            if(curr.second>0 && image[curr.first][curr.second-1] == oldColor){\\n                s.push({curr.first, curr.second -1});\\n            }\\n            if(curr.second<image.size()-1 && image[curr.first][curr.second+1] == oldColor){\\n                s.push({curr.first, curr.second +1});\\n            }\\n        }\\n\\n        return image;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "akhmadzoripov",
                        "content": "Try adding into each if statements the \" image[curr.first][curr.second...] == color \""
                    },
                    {
                        "username": "minhajsixybte",
                        "content": "the problem description is really confusing with \"4 directionally connected\" and \"so on...\" stuff"
                    },
                    {
                        "username": "rohan_181",
                        "content": "whats wrong with my Code\\n\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& image, int sr, int sc, int color, int key){\\n        int n = image.size();\\n        int m = image[0].size();\\n        if(sr >= 0 && sr < n && sc >= 0 && sc < m ){\\n            if(image[sr][sc] == key){ \\n                image[sr][sc] = color;\\n                helper(image, sr+1, sc, color, key);\\n                helper(image, sr-1, sc, color, key);\\n                helper(image, sr, sc+1, color, key);\\n                helper(image, sr, sc-1, color, key);\\n            }\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int key = image[sr][sc];\\n        helper(image, sr, sc, color, key);\\n        return image;\\n    }\\n};"
                    },
                    {
                        "username": "ivan3man",
                        "content": "[@P3rs0na](/P3rs0na) u r a hero my dud"
                    },
                    {
                        "username": "P3rs0na",
                        "content": "when all numbers in the matrix is same you go into infinity loop. \nHence, you should added this before calling helper,\n// return matrix as it is if starting color is equal to replace color. (Refer Test Example 2 in the question description)\nif image[sr][sc] == color {\n    return image\n}\n\nBecause if starting color and target color is same then there will never be any changes in the matrix, as replacing 1 with 1 doesn't changes the composition of the matrix."
                    },
                    {
                        "username": "nizarkadri",
                        "content": "Meaning of connected 4 directionationally :\\n4-connected pixels are neighbors to every pixel that touches one of their edges. These pixels are connected horizontally and vertically. In terms of pixel coordinates, every pixel that has the coordinates  (x +- 1, y) or (x, y +- 1) is connected to the pixel at (x,y)\\n"
                    },
                    {
                        "username": "ANmishra-a",
                        "content": " Flood fill algorithm can be thought of as a virus spreading through a population. The virus starts at a specific person (the starting pixel), and can only infect other people if they have a specific trait (the original color of the starting pixel) and if they come in contact with an infected person (a pixel with the same color as the starting pixel).\\n\\nThe algorithm works by starting at the given starting pixel, checking if the current pixel has the same color as the starting pixel, and if it does, replacing the color with the new color. Then, it recursively performs the same process for all the connected 4-directionally pixels. This is similar to how a virus can spread through a population, moving from one person to another through close contact.\\n\\nThe algorithm keeps going through the population (image) until all the people with the specific trait (pixels with the same color as the starting pixel) are infected (recolored with the new color) or in other words until the virus has spread through the entire population.\\n\\n_________________________*******************************************__________________________________________\\n\\n\\n\\nvar floodFill = function (image, sr, sc, color) {\\n  let orignalColor = image[sr][sc]; // taking the reference of the original color\\n  if (orignalColor === color) {\\n    return image; // return the image as it is if the color of the pixel is already, the color we have to change to\\n  }\\n  let rows = image.length;\\n  let cols = image[0].length;\\n  function dfs(row, col) {\\n    if (\\n      row < 0 ||\\n      row >= rows ||\\n      col < 0 ||\\n      col >= cols ||\\n      image[row][col] !== orignalColor\\n    ) {\\n      return;\\n    }\\n    image[row][col] = color;\\n    dfs(row - 1, col);\\n    dfs(row + 1, col);\\n    dfs(row, col - 1);\\n    dfs(row, col + 1);\\n  }\\n  dfs(sr, sc);\\n  return image;\\n};"
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy.  Thanks."
                    },
                    {
                        "username": "CCThumper",
                        "content": "Great analogy!  But wouldn\\'t virus spread be more like breadth-first rather than depth-first.  I think I\\'ll try both.  Maybe even use PyGame to simulate the spread over time."
                    },
                    {
                        "username": "ayushap05",
                        "content": "My code is running fine on VSCode but is giving error in Leetcode compiler. Can Anyone one tell me why? I tried to find out the error by using cout in each if conditions to see where it went wrong but non of the if condition are being executed and somehow the dfs function is begin called automatically.\\n\\npublic:\\n\\n    void dfs(vector<vector<int>>& image,int row,int col,int color,int nColor)\\n    {\\n        cout<<row<<\" \"<<col<<\" \";\\n        cout<<image[row][col]<<\" \"<<nColor<<endl;\\n        int m = image.size(),n = image[0].size();\\n        if(image[row][col] == color)\\n        {\\n            image[row][col] = nColor;\\n\\n            if(row-1>=0 && image[row-1][col] == color)\\n            {\\n                cout<<1<<\" : \";\\n                dfs(image,row-1,col,color,nColor);\\n            }\\n            if(row+1<m && image[row+1][col] == color)\\n            {\\n                cout<<2<<\" : \";\\n                dfs(image,row+1,col,color,nColor);\\n            }\\n            if(col-1>=0 && image[row][col-1] == color)\\n            {\\n                cout<<3<<\" : \";\\n                dfs(image,row,col-1,color,nColor);\\n            }\\n            if(col+1<n && image[row][col+1] == color)\\n            {\\n                cout<<4<<\" : \";\\n                dfs(image,row,col+1,color,nColor);\\n            }\\n        }\\n        else\\n            return;\\n    }\\n    \\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        //image[sr][sc] = newColor;\\n        dfs(image,sr,sc,image[sr][sc],newColor);\\n        return image;\\n    }"
                    },
                    {
                        "username": "ttran010",
                        "content": "my code is similar to the given solution but I keep getting an error. I found out that my color variable, the argument given to us, changes even though I never modify it. can someone explain why this is happening?\\n\\n ```class Solution:\\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\\n        old_color = image[sr][sc]\\n        row_max = len(image) - 1\\n        col_max = len(image[0]) - 1\\n        def fourFill(index):\\n            row, col = index\\n            if 0 <= row <= row_max and 0 <= col <= col_max:\\n                if image[row][col] == old_color:\\n                    image[row][col] = color\\n                    print(color)\\n                    fourFill((row+1, col))\\n                    fourFill((row-1, col))\\n                    fourFill((row, col-1))\\n                    fourFill((row, col+1))\\n        fourFill((sr, sc))\\n        return image```"
                    },
                    {
                        "username": "ayushap05",
                        "content": "Something similar happened to my code also. Let me know if you found any reason for this behaviour."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "what is difference between TC of matrix through array or matrix through vector\\nfor array TC is O(nsquare) but through vector TC is ??"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "What I understood ,Correct me if  I am wrong!\nThe cells represent  initial color.\nsr=0,sc=0 ,so Flood Fill starts from (1,1) ,image[1,1]=1,so change the color value to the desired value i.e 2.Next we can move to [0,1] or [1,0] or [2,1] or[1,2] and check if initial color of image[1,1] which was 1 is equal in this 4 cells,if it is equal we will increase the color value of the cell to the desired color value.\nHere,[2,1] and [1,2] are 0 and not equal to the initial color of the cell [1,1]  which  was 1,so we cant move in that direction ."
                    }
                ]
            },
            {
                "id": 1740527,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1739620,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1736667,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1731673,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1729360,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1728398,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1728234,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1725878,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1724751,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1724328,
                "content": [
                    {
                        "username": "user1183vh",
                        "content": "Why does everyone change the initial image from arguments? Shouldn't it be immutable?"
                    },
                    {
                        "username": "gr4d13nt",
                        "content": "notice the ampersand"
                    },
                    {
                        "username": "AzamatAbduvohidov",
                        "content": "good one, I think it is a little bit harder than it looks."
                    },
                    {
                        "username": "Hemant_1451",
                        "content": "class Solution {\\npublic:\\n    void DFS(vector<vector<int>>&image, int r, int c, int color, int newColor) {\\n        if (r<0 || c<0 || r>=image.size() || c>=image[0].size()|| image[r][c] != color || image[r][c] == newColor)\\n        return;\\n        if (image[r][c] == color) {\\n            image[r][c] = newColor;\\n            DFS(image, r-1, c, color, newColor);\\n            DFS(image, r, c-1, color, newColor);\\n            DFS(image, r+1, c, color, newColor);\\n            DFS(image, r, c+1, color, newColor);\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\\n        int color = image[sr][sc];\\n        if (color != newColor)\\n        DFS(image, sr, sc, color, newColor);\\n        return image;\\n    }\\n   \\n};"
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Please help!!!\n\nI debugged my code and it was correct, but I always got Time Limit Exceeded and only passed 1/277\n\nCould anyone please have a look at my code please please? Highly appreciated!!!\n\n\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        # push the start point into the queue\n        # iterate the 4 directions and push adjacent\n        # deque/pop the start point, change the color\n        # if queue is None, return\n        queue = [(sr, sc)]\n        while (queue):\n            # current start row and column\n            sr1 = queue[0][0]\n            sc1 = queue[0][1]\n            for r, c in (sr1 + 1, sc1), (sr1, sc1 + 1), (sr1 - 1, sc1), (sr1, sc1 - 1):\n                if 0 <= r < len(image) and 0 <= c < len(image[0]) and (image[sr1][sc1] == image[r][c]) and ((r, c) not in queue):\n                    queue.append((r, c))\n            # flood the color to the point\n            image[sr1][sc1] = color\n            # pop the point from the queue\n            queue.pop(0)\n\n        return image\n"
                    },
                    {
                        "username": "jchatterjee",
                        "content": "Solved. Create a list of visited squares in the grid and keep populating them as you fill them."
                    },
                    {
                        "username": "Le_Capitaine_Joe",
                        "content": "Solved. Need to add edge case check: if color == image[sr][sc]: return image"
                    },
                    {
                        "username": "n1md7",
                        "content": "Do you guys know why this is not working?\\n\\nI use Typescript and I get C++ error :( \\n```\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n```\\n\\n```typescript\\nfunction floodFill(image: number[][], sr: number, sc: number, fillColor: number): number[][] {\\n  type Stack = {x: number, y: number};\\n  const stack: Stack[] = [ {x: sc, y: sr} ];\\n  const color = image[sr][sc];\\n  \\n  while(stack.length > 0) {\\n    const pixel = stack.pop();\\n    \\n    if(image[pixel.y][pixel.x] !== color) continue;\\n\\n    image[pixel.y][pixel.x] = fillColor;\\n    const currentColor = isValid(image);\\n\\n    if(currentColor(pixel.y, pixel.x + 1) === color) stack.push({y: pixel.y, x: pixel.x + 1});\\n    if(currentColor(pixel.y, pixel.x - 1) === color) stack.push({y: pixel.y, x: pixel.x - 1});\\n    if(currentColor(pixel.y + 1, pixel.x) === color) stack.push({y: pixel.y + 1, x: pixel.x});\\n    if(currentColor(pixel.y - 1, pixel.x) === color) stack.push({y: pixel.y - 1, x: pixel.x});\\n  }\\n\\n  return image;\\n}\\n\\nfunction isValid(image: number[][]){\\n  return (y: number, x: number) => {\\n    return image[y] && image[y][x];\\n  }\\n}\\n```"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "First i was not able to solve this easy problem. Because i couldn\\'t understand the problem statement properly.\\nThen i give up for 1 day then come back with more strongly.\\nMaybe giving more time will open the window for solving some problem.\\n\\nTips:\\nStatement is saying that from the source node 4-directional connected components with same color will be changed according to given color.\\nIt\\'s normal dfs now.\\nCode Link:\\nhttps://leetcode.com/problems/flood-fill/solutions/2951321/simple-dfs/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "I don\\'t understand what the statement is saying.\\nall the 4 directional value sum will be used to replace or not?\\nplease help me to find this."
                    },
                    {
                        "username": "vivekswami098",
                        "content": "Hey LeetCode, plz mark it a medium level question !!\\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\nconst floodFill = (image, sr, sc, color) => {\\n    const row = image.length;\\n    const col = image[0].length;\\n    const target = image[sr][sc];\\n    let queue = [];\\n    queue.push([sr, sc]);\\n    image[sr][sc] = color;\\n    while (queue.length > 0) {\\n        const [y,x] = queue.shift();\\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        });\\n    };\\n    console.log(\"here\");\\n    console.log(image);\\n    return image;\\n}; \\n```\\nStdout\\nhere\\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\\n\\nwhy this code is incorrect?"
                    }
                ]
            },
            {
                "id": 1724325,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1724305,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1723001,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1716196,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1711519,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1708549,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1706959,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1697098,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1690249,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            },
            {
                "id": 1688030,
                "content": [
                    {
                        "username": "devKangM",
                        "content": " ```\nconst floodFill = (image, sr, sc, color) => {\n    const row = image.length;\n    const col = image[0].length;\n    const target = image[sr][sc];\n    let queue = [];\n    queue.push([sr, sc]);\n    image[sr][sc] = color;\n    while (queue.length > 0) {\n        console.log(\"HEHE@\")\n        const [y,x] = queue.shift();\n        [[-1,0],[0,1],[1,0],[0,-1]].forEach(([dy,dx]) => {\n            const [ny, nx] = [dy+y, dx+x];\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ===  target) {\n                image[ny][nx] = color;\n                queue.push([ny,nx]);\n            }\n        });\n    };\n    console.log(\"here\");\n    console.log(image);\n    console.log(\"return here\")\n    return image;\n};\n\n```\n\n```\nStdout\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nHEHE@\nhere\n[ [ 2, 2, 2 ], [ 2, 2, 0 ], [ 2, 0, 1 ] ]\nreturn here\nHEHE@\nHEHE@\nHEHE@\n\n```\n\nwhy doesn't return image? \nAlready console logging \"here\", but why keep running?\nplease help me......\n"
                    },
                    {
                        "username": "devKangM",
                        "content": "```\\n/**\\n * @param {number[][]} image\\n * @param {number} sr\\n * @param {number} sc\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar floodFill = function(image, sr, sc, color) {\\n    const col = image.length;\\n    const row = image[0].length;\\n    const target = image[sc][sr];\\n    const dir = [[-1,0],[0,1],[1,0],[0,-1]];\\n\\n    let queue = [[sc, sr]];\\n    image[sc][sr] = color;\\n\\n    while (queue.length > 0) {\\n        let [y,x] = queue.shift();\\n        for (let i = 0; i < 4; i++) {\\n            const [dy, dx] = dir[i];\\n            const [ny, nx] = [dy+y, dx+x];\\n            if (ny > -1 && ny < col && nx > -1 && nx < row && image[ny][nx] ==  target) {\\n                image[ny][nx] = color;\\n                queue.push([ny,nx]);\\n            }\\n        }\\n    }\\n    return image;\\n};\\n```\\nI don\\'t know why this code is not working... please help me...\\n"
                    },
                    {
                        "username": "roivanoff",
                        "content": "Guys, need help. This code is working fine on my machine, but leetcode says stackoverflow. \\n\\n `public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n       int oldcolor = image[sr][sc];\\n       fillCell(image, sr, sc, oldcolor, color);\\n       return image;\\n    }\\n    private void fillCell(int[][] image, int x, int y, int oldColor, int newColor){\\n        if(image[x][y] == oldColor)\\n            image[x][y] = newColor;\\n        else\\n            return;\\n        int maxX = image.length;\\n        int maxY = image[0].length;\\n\\n        if(x - 1 >= 0)\\n            fillCell(image, x - 1,  y, oldColor,  newColor);\\n        if(y - 1 >= 0)\\n            fillCell(image, x ,  y - 1, oldColor,  newColor);\\n        if(y +1 < maxY)\\n            fillCell(image, x ,  y + 1, oldColor,  newColor);\\n        if(x + 1 < maxX)\\n            fillCell(image, x + 1,  y, oldColor,  newColor);\\n    }`"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        int m=image.size();\\n        int n=image[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({sr,sc});\\n        int c=image[sr][sc];\\n        int x[4]={-1,1,0,0};\\n        int y[4]={0,0,-1,1};\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        while(!q.empty())\\n        {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            image[i][j]=color;\\n            for(int d=0;d<4;d++)\\n            {\\n                int xc=i+x[d];\\n                int yc=j+y[d];\\n                if((xc>=0 && xc<m) && (yc>=0 & yc<n) && image[xc][yc]==c && !vis[xc][yc])\\n                {\\n                   if(image[xc][yc]!=color)\\n                   {\\n                        q.push({xc,yc});\\n                        vis[xc][yc]=1;\\n                   }\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nusing bfs"
                    },
                    {
                        "username": "nurlan01",
                        "content": "Can anyone explain what \"4 directionally connected\" mean, do it as you explain to 6 years child ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "If something is either on top, left, right or below me then that is 4 directionally connected.\\n\\nIf something is diagonal to me, then that is not directionally connected.\\n\\n"
                    },
                    {
                        "username": "SA-Inc",
                        "content": "Good and interesting task, but it is strange. Implemented two versions, BFS and DFS, and none of them not pass time limit test. Although before that I used two nested loops, for coloring by mask, everything was done"
                    },
                    {
                        "username": "Gayatri012",
                        "content": "A clarifying question I would have liked to ask in this question. If one of the neighboring cells in the 4 directions is of the color that needs to be updated (newColor, not the color of the starting cell), then should that cell be added in the group and then its neighboring cells be identified for modification?"
                    },
                    {
                        "username": "tejaskh3",
                        "content": "where am i wrong can anyone please tell me??\\n\\nclass Solution {\\npublic:\\nvoid dfs(int sr,int sc,int newColor,int iniColor,vector<vector<int>> &image,int *delrow,int *delcol){\\n    image[sr][sc]=newColor;\\n    int n=image.size();\\n    int m=image.size();\\n    for(int i=0;i<4;i++){\\n        int newRow=sr+delrow[i];\\n        int newCol=sc+delcol[i];\\n        if(newCol<m && newCol>=0 && newRow<n && newRow>=0 && image[newRow][newCol]==iniColor && image[newRow][newCol]!=newColor)\\n        dfs(newRow,newCol,newColor,iniColor,image,delrow,delcol);\\n    }\\n}\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n        vector<vector<int>> copy=image;\\n        int delcol[]={0,1,0,-1};\\n        int delrow[]={-1,0,1,0};\\n        dfs(sr,sc,color,image[sr][sc],copy,delrow,delcol);\\n        return copy;\\n    }\\n};"
                    },
                    {
                        "username": "user1482W",
                        "content": "Can anyone please help me understand why I keep getting a stackoverflow error for this? Thanks in advance!\\n\\npublic void func(int[][] image, int sr, int sc, int color, int actualColor)\\n    {\\n        int rmax = image.length;\\n        int rmin = image[0].length;\\n         \\n         if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != color)\\n            return;\\n\\n           if( image[sr][sc] == actualColor)\\n           {\\n                image[sr][sc] = color;\\n               ` func(image,sr+1,sc,color,actualColor);`  // stackoverflow error here\\n                func(image,sr-1,sc,color,actualColor);\\n                func(image,sr,sc+1,color,actualColor);\\n                func(image,sr,sc-1,color,actualColor);\\n            }   \\n         return;\\n    }\\n\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int actualColor = image[sr][sc];\\n\\n        func(image,sr,sc,color,actualColor);\\n\\n        return image;\\n      \\n\\n    }"
                    },
                    {
                        "username": "youngprogrammer1997",
                        "content": "Becausd of the second testcase. If everything is the same color and the new color is equal to that color, it causes a stack overflow. "
                    },
                    {
                        "username": "pratyaksh007",
                        "content": " `class Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\\n        \\n        int oldColor = image[sr][sc];\\n        if(oldColor==color)\\n            return image;\\n        int x = image.length;\\n        int y = image[0].length;\\n        helper(image,sr,sc,oldColor,color,x,y);\\n        return image;\\n    }\\n    void helper(int[][] image,int i,int j,int oldColor,int newColor,int x,int y)\\n    {\\n        if(i<0 || j<0 || i==x || j==y || image[i][j]!=oldColor)\\n            return;\\n        \\n\\t\\t//color that cell with new color\\n        image[i][j] = newColor;\\n\\t\\t\\n        //Down\\n        helper(image,i+1,j,oldColor,newColor,x,y);\\n        //up\\n        helper(image,i-1,j,oldColor,newColor,x,y);\\n        //right\\n        helper(image,i,j+1,oldColor,newColor,x,y);\\n        //left\\n        helper(image,i,j-1,oldColor,newColor,x,y);\\n    }\\n}\\nT.C :- O(m * n), m and n are total numbers of row and column`"
                    }
                ]
            }
        ]
    }
]