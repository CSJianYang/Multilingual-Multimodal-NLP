[
    {
        "title": "Check Completeness of a Binary Tree",
        "question_content": "Given the root of a binary tree, determine if it is a complete binary tree.\nIn a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n&nbsp;\nExample 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: true\nExplanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n\nExample 2:\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: false\nExplanation: The node with value 7 isn't as far left as possible.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 100].\n\t1 <= Node.val <= 1000",
        "solutions": [
            {
                "id": 205682,
                "title": "java-c-python-bfs-solution-and-dfs-soluiton",
                "content": "# **Solution 1, BFS**\\nUse BFS to do a level order traversal,\\nadd childrens to the bfs queue,\\nuntil we met the first empty node.\\n\\nFor a complete binary tree,\\nthere should not be any node after we met an empty one.\\n\\nTime `O(N)`, Space `O(N)`\\n\\n**Java:**\\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (bfs.peek() != null) {\\n            TreeNode node = bfs.poll();\\n            bfs.offer(node.left);\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty() && bfs.peek() == null)\\n            bfs.poll();\\n        return bfs.isEmpty();\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        int i = 0;\\n        while (i < bfs.size() && bfs[i]) {\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        while (i < bfs.size() && !bfs[i])\\n            i++;\\n        return i == bfs.size();\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def isCompleteTree(self, root):\\n        bfs = [root]\\n        i = 0\\n        while bfs[i]:\\n            bfs.append(bfs[i].left)\\n            bfs.append(bfs[i].right)\\n            i += 1\\n        return not any(bfs[i:])\\n```\\n<br>\\n\\nAlso you may want to return earlier.\\nWe can stop the first while loop when met the first null child.\\nFrom then on there should not be any more child.\\nThis optimisation help reduce half of operations.\\n\\n**Java**\\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (true) {\\n            TreeNode node = bfs.poll();\\n            if (node.left == null) {\\n                if (node.right != null)\\n                    return false;\\n                break;\\n            }\\n            bfs.offer(node.left);\\n            if (node.right == null) break;\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty()) {\\n            TreeNode node = bfs.poll();\\n            if (node.left != null || node.right != null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n<br><br>\\n\\n# **Solution 2, DFS**\\nLooking back to this problem, my first inituition is actually a dfs\\nif `root` is a complete tree , \\n`dfs(root)` return the count of nodes in a tree,\\notherwise it will return `-1`\\n\\nIf a tree is a complete FULL tree,\\nit must have 1,3,7,15,31..nodes,\\nwhich is pow of 2 minus 1.\\nAnd for x = 2^k -1, x has a property that `x & (x+1) == 0`.\\n\\nFor a complete tree, it must satify at least one of the following condition:\\nif left subtree is a full tree with `l` nodes,\\nright subtree must have `r` nodes that  `l / 2 <= r <= l`\\nif right subtree is a full tree with `r` nodes,\\nleft subtree must have `l` nodes that  `r <= l <= r * 2 + 1`.\\n\\nTime `O(N)`, Space `O(height)`\\n\\n**Java**\\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        return dfs(root) >= 0;\\n    }\\n    \\n    public int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        int l = dfs(root.left), r = dfs(root.right);\\n        if ((l & (l + 1)) == 0 && l / 2 <= r && r <= l)\\n            return l + r + 1;\\n        if ((r & (r + 1)) == 0 && r <= l && l <= r * 2 + 1)\\n            return l + r + 1;\\n        return -1 ;\\n    }\\n```\\n**Python**\\n```py\\n    def isCompleteTree(self, root):\\n        def dfs(root):\\n            if not root: return 0\\n            l, r = dfs(root.left), dfs(root.right)\\n            if l & (l + 1) == 0 and l / 2 <= r <= l:\\n                return l + r + 1\\n            if r & (r + 1) == 0 and r <= l <= r * 2 + 1:\\n                return l + r + 1\\n            return -1\\n        return dfs(root) > 0\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (bfs.peek() != null) {\\n            TreeNode node = bfs.poll();\\n            bfs.offer(node.left);\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty() && bfs.peek() == null)\\n            bfs.poll();\\n        return bfs.isEmpty();\\n    }\\n```\n```cpp\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        int i = 0;\\n        while (i < bfs.size() && bfs[i]) {\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        while (i < bfs.size() && !bfs[i])\\n            i++;\\n        return i == bfs.size();\\n    }\\n```\n```py\\n    def isCompleteTree(self, root):\\n        bfs = [root]\\n        i = 0\\n        while bfs[i]:\\n            bfs.append(bfs[i].left)\\n            bfs.append(bfs[i].right)\\n            i += 1\\n        return not any(bfs[i:])\\n```\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (true) {\\n            TreeNode node = bfs.poll();\\n            if (node.left == null) {\\n                if (node.right != null)\\n                    return false;\\n                break;\\n            }\\n            bfs.offer(node.left);\\n            if (node.right == null) break;\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty()) {\\n            TreeNode node = bfs.poll();\\n            if (node.left != null || node.right != null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        return dfs(root) >= 0;\\n    }\\n    \\n    public int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        int l = dfs(root.left), r = dfs(root.right);\\n        if ((l & (l + 1)) == 0 && l / 2 <= r && r <= l)\\n            return l + r + 1;\\n        if ((r & (r + 1)) == 0 && r <= l && l <= r * 2 + 1)\\n            return l + r + 1;\\n        return -1 ;\\n    }\\n```\n```py\\n    def isCompleteTree(self, root):\\n        def dfs(root):\\n            if not root: return 0\\n            l, r = dfs(root.left), dfs(root.right)\\n            if l & (l + 1) == 0 and l / 2 <= r <= l:\\n                return l + r + 1\\n            if r & (r + 1) == 0 and r <= l <= r * 2 + 1:\\n                return l + r + 1\\n            return -1\\n        return dfs(root) > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205768,
                "title": "java-easy-level-order-traversal-one-while-loop",
                "content": "When level-order traversal in a complete tree, after the last node, all nodes in the queue should be null. \\nOtherwise, the tree is not complete.\\n```\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            if(cur == null) end = true;\\n            else{\\n                if(end) return false;\\n                queue.add(cur.left);\\n                queue.add(cur.right);\\n            }\\n        }\\n        return true;\\n    }\\n```\\nTime Complexity: O(N), where N is the number of nodes.\\nSpace Complexity: O(N)",
                "solutionTags": [],
                "code": "```\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            if(cur == null) end = true;\\n            else{\\n                if(end) return false;\\n                queue.add(cur.left);\\n                queue.add(cur.right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298346,
                "title": "clean-codes-full-explanation-b-f-s-c-java-python3",
                "content": "# Intuition :\\n- Given the root of a binary tree, determine if it is a complete binary tree.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Breadth First Search\\n- Traverse the tree in `level-order` using a queue. At each level, we add the left and right child nodes of each node to the queue. \\n- If we encounter a `null` node, we still add it to the queue so that we can check if there are any more nodes left in the next step. \\n- Once we have traversed the entire tree, we check if there are any remaining nodes in the queue. \\n- If there are, it means the tree is not complete, and we return `false`. \\n- Otherwise, the tree is complete, and we return `true`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\n// Define the Solution class\\nclass Solution {\\n  \\n  // Define the isCompleteTree function that takes a TreeNode as input and returns a boolean\\n  public boolean isCompleteTree(TreeNode root) {\\n    // Check if the root node is null, if so, return true (an empty tree is complete)\\n    if (root == null)\\n      return true;\\n\\n    // Create a queue to store the nodes of the tree in level order\\n    Queue<TreeNode> q = new LinkedList<>(Arrays.asList(root));\\n\\n    // Traverse the tree in level order\\n    while (q.peek() != null) {\\n      // Remove the first node from the queue\\n      TreeNode node = q.poll();\\n      // Add the left and right child nodes of the current node to the queue\\n      q.offer(node.left);\\n      q.offer(node.right);\\n    }\\n\\n    // Remove any remaining null nodes from the end of the queue\\n    while (!q.isEmpty() && q.peek() == null)\\n      q.poll();\\n\\n    // Check if there are any remaining nodes in the queue\\n    // If so, the tree is not complete, so return false\\n    // Otherwise, the tree is complete, so return true\\n    return q.isEmpty();\\n  }\\n}\\n\\n```\\n```C++ []\\n// Define the Solution class\\nclass Solution {\\npublic:\\n    // Define the isCompleteTree function that takes a TreeNode pointer as input and returns a boolean\\n    bool isCompleteTree(TreeNode* root) {\\n        // Check if the root node is null, if so, return true (an empty tree is complete)\\n        if (root == nullptr)\\n            return true;\\n\\n        // Create a queue to store the nodes of the tree in level order\\n        queue<TreeNode*> q{{root}};\\n\\n        // Traverse the tree in level order\\n        while (q.front() != nullptr) {\\n            // Remove the first node from the queue\\n            TreeNode* node = q.front();\\n            q.pop();\\n            // Add the left and right child nodes of the current node to the queue\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n\\n        // Remove any remaining null nodes from the front of the queue\\n        while (!q.empty() && q.front() == nullptr)\\n            q.pop();\\n\\n        // Check if there are any remaining nodes in the queue\\n        // If so, the tree is not complete, so return false\\n        // Otherwise, the tree is complete, so return true\\n        return q.empty();\\n    }\\n};\\n\\n```\\n```Python []\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        # Check if the root node is None, if so, return True (an empty tree is complete)\\n        if not root:\\n            return True\\n\\n        # Create a deque to store the nodes of the tree in level order\\n        q = deque([root])\\n\\n        # Traverse the tree in level order\\n        while q[0] is not None:\\n            # Remove the first node from the deque\\n            node = q.popleft()\\n            # Add the left and right child nodes of the current node to the deque\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        # Remove any remaining None nodes from the beginning of the deque\\n        while q and q[0] is None:\\n            q.popleft()\\n\\n        # Check if there are any remaining nodes in the deque\\n        # If so, the tree is not complete, so return False\\n        # Otherwise, the tree is complete, so return True\\n        return not bool(q)\\n\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/b1973ae0-07a2-4280-b4dc-3ffc7493f3c3_1678845601.0422919.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\n// Define the Solution class\\nclass Solution {\\n  \\n  // Define the isCompleteTree function that takes a TreeNode as input and returns a boolean\\n  public boolean isCompleteTree(TreeNode root) {\\n    // Check if the root node is null, if so, return true (an empty tree is complete)\\n    if (root == null)\\n      return true;\\n\\n    // Create a queue to store the nodes of the tree in level order\\n    Queue<TreeNode> q = new LinkedList<>(Arrays.asList(root));\\n\\n    // Traverse the tree in level order\\n    while (q.peek() != null) {\\n      // Remove the first node from the queue\\n      TreeNode node = q.poll();\\n      // Add the left and right child nodes of the current node to the queue\\n      q.offer(node.left);\\n      q.offer(node.right);\\n    }\\n\\n    // Remove any remaining null nodes from the end of the queue\\n    while (!q.isEmpty() && q.peek() == null)\\n      q.poll();\\n\\n    // Check if there are any remaining nodes in the queue\\n    // If so, the tree is not complete, so return false\\n    // Otherwise, the tree is complete, so return true\\n    return q.isEmpty();\\n  }\\n}\\n\\n```\n```C++ []\\n// Define the Solution class\\nclass Solution {\\npublic:\\n    // Define the isCompleteTree function that takes a TreeNode pointer as input and returns a boolean\\n    bool isCompleteTree(TreeNode* root) {\\n        // Check if the root node is null, if so, return true (an empty tree is complete)\\n        if (root == nullptr)\\n            return true;\\n\\n        // Create a queue to store the nodes of the tree in level order\\n        queue<TreeNode*> q{{root}};\\n\\n        // Traverse the tree in level order\\n        while (q.front() != nullptr) {\\n            // Remove the first node from the queue\\n            TreeNode* node = q.front();\\n            q.pop();\\n            // Add the left and right child nodes of the current node to the queue\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n\\n        // Remove any remaining null nodes from the front of the queue\\n        while (!q.empty() && q.front() == nullptr)\\n            q.pop();\\n\\n        // Check if there are any remaining nodes in the queue\\n        // If so, the tree is not complete, so return false\\n        // Otherwise, the tree is complete, so return true\\n        return q.empty();\\n    }\\n};\\n\\n```\n```Python []\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        # Check if the root node is None, if so, return True (an empty tree is complete)\\n        if not root:\\n            return True\\n\\n        # Create a deque to store the nodes of the tree in level order\\n        q = deque([root])\\n\\n        # Traverse the tree in level order\\n        while q[0] is not None:\\n            # Remove the first node from the deque\\n            node = q.popleft()\\n            # Add the left and right child nodes of the current node to the deque\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        # Remove any remaining None nodes from the beginning of the deque\\n        while q and q[0] is None:\\n            q.popleft()\\n\\n        # Check if there are any remaining nodes in the deque\\n        # If so, the tree is not complete, so return False\\n        # Otherwise, the tree is complete, so return True\\n        return not bool(q)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206810,
                "title": "c-bfs",
                "content": "```\\nbool isCompleteTree(TreeNode* root) {\\n        bool pre = true;\\n        queue<TreeNode*> nq;\\n        nq.push(root);\\n        \\n        while(!nq.empty()){\\n            TreeNode* node = nq.front();\\n            nq.pop();\\n            \\n            if(node == NULL){\\n                pre = false;\\n            }\\n            else{\\n                if(pre == false)\\n                    return false;\\n                \\n                nq.push(node->left);\\n                nq.push(node->right);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isCompleteTree(TreeNode* root) {\\n        bool pre = true;\\n        queue<TreeNode*> nq;\\n        nq.push(root);\\n        \\n        while(!nq.empty()){\\n            TreeNode* node = nq.front();\\n            nq.pop();\\n            \\n            if(node == NULL){\\n                pre = false;\\n            }\\n            else{\\n                if(pre == false)\\n                    return false;\\n                \\n                nq.push(node->left);\\n                nq.push(node->right);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 398169,
                "title": "python-11-lines-use-the-fact-that-level-order-traversal-array-is-val-val-null-null",
                "content": "The level-order traversal array of a complete binary tree will never have a null node in between non-null nodes. If we encounter a null node, all the following nodes should also be null, otherwise it\\'s not complete. \\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        have_null = False\\n        Q = [root]\\n        \\n        while Q:\\n            cur_node = Q.pop(0)\\n            if not cur_node: \\n                have_null = True\\n                continue\\n            if have_null: return False\\n            Q.append(cur_node.left)\\n            Q.append(cur_node.right)\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        have_null = False\\n        Q = [root]\\n        \\n        while Q:\\n            cur_node = Q.pop(0)\\n            if not cur_node: \\n                have_null = True\\n                continue\\n            if have_null: return False\\n            Q.append(cur_node.left)\\n            Q.append(cur_node.right)\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533798,
                "title": "python-js-java-go-c-o-n-by-level-order-traversal-w-diagram",
                "content": "O(n) by level-order traversal.\\n\\n---\\n\\n**Hint**:\\n\\nComplete binary tree is a leftward compact tree.\\n\\nLaunch **level-order-traersal** (or **BFS** if we see binary tree as a *single source graph on root* )\\n\\nIf there is an **empty node** (i.e. **None**) somewhere **in the middle** before last node,\\nthen it is Not a *[complete binary tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)*, thus return False.\\n\\nOtherwise, it is complete and return True.\\n\\n---\\n\\n**Diagram** and **abstract model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583721519.png)\\n\\n\\n---\\n**Implementation**:\\n\\nPython:\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        \\n        \\n        traversal_queue = deque( [ root ] )\\n        prev_node = root\\n        \\n        \\n        # Launch Level-order traversal\\n        \\n        while traversal_queue:\\n            \\n            cur_node = traversal_queue.popleft()\\n            \\n            if cur_node:\\n                \\n                if not prev_node:\\n                    # Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return False\\n                \\n                traversal_queue.append( cur_node.left )\\n                traversal_queue.append( cur_node.right )\\n            \\n            # update previous node\\n            prev_node = cur_node\\n            \\n        return True\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer( root );\\n        \\n        TreeNode prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( queue.size() > 0 ){\\n            \\n            TreeNode curNode = queue.poll();\\n            \\n            if( curNode != null ){\\n                \\n                if( prevNode == null ){\\n                    // Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return false;\\n                }\\n                \\n                queue.offer( curNode.left );\\n                queue.offer( curNode.right );\\n            }\\n            // udpate previous node\\n            prevNode = curNode;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n\\nJavascript:\\n\\n```\\nvar isCompleteTree = function(root) {\\n    \\n    // Initialization\\n    let traversal_queue = [root];\\n    let prevNode = root;\\n    \\n    // Launch level-order traversal\\n    while( traversal_queue.length ){\\n        \\n        let curNode = traversal_queue.shift();\\n        \\n        if( curNode != null )\\n        {\\n            if( prevNode == null ){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }    \\n            \\n            traversal_queue.push( curNode.left );\\n            traversal_queue.push( curNode.right );\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode;\\n    }\\n    \\n    return true;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"container/list\"\\n)\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n    \\n    // Initialization\\n    traversalQ := list.New()\\n    traversalQ.PushBack( root )\\n    \\n    prevNode := root\\n    \\n    // Launch level-order traversal\\n    for traversalQ.Len() != 0 {\\n        \\n        queueHead := traversalQ.Front();\\n        traversalQ.Remove( queueHead )\\n        \\n        curNode := queueHead.Value.(*TreeNode)\\n        \\n        if( curNode != nil ){\\n            \\n            if( prevNode == nil){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }\\n            \\n            traversalQ.PushBack( curNode.Left )\\n            traversalQ.PushBack( curNode.Right )\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode\\n    }\\n    \\n    return true;\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        std::queue< TreeNode* > traversalQ;\\n        traversalQ.push( root );\\n        TreeNode* prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( traversalQ.size() ){\\n            \\n            TreeNode* curNode = traversalQ.front();\\n            traversalQ.pop();\\n            \\n            if( curNode != nullptr ){\\n                \\n                if( prevNode == nullptr ){\\n                    // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                    return false;\\n                }\\n                \\n                traversalQ.push( curNode->left );\\n                traversalQ.push( curNode->right );\\n            }\\n            \\n            // update previous node\\n            prevNode = curNode;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\\n\\n[Leetcode #107 Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)\\n\\n[Leetcode #222 Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Complete binary tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)\\n\\n[2] [GfG: Complete binary tree](https://bit.ly/3aFrrYQ)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        \\n        \\n        traversal_queue = deque( [ root ] )\\n        prev_node = root\\n        \\n        \\n        # Launch Level-order traversal\\n        \\n        while traversal_queue:\\n            \\n            cur_node = traversal_queue.popleft()\\n            \\n            if cur_node:\\n                \\n                if not prev_node:\\n                    # Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return False\\n                \\n                traversal_queue.append( cur_node.left )\\n                traversal_queue.append( cur_node.right )\\n            \\n            # update previous node\\n            prev_node = cur_node\\n            \\n        return True\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer( root );\\n        \\n        TreeNode prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( queue.size() > 0 ){\\n            \\n            TreeNode curNode = queue.poll();\\n            \\n            if( curNode != null ){\\n                \\n                if( prevNode == null ){\\n                    // Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return false;\\n                }\\n                \\n                queue.offer( curNode.left );\\n                queue.offer( curNode.right );\\n            }\\n            // udpate previous node\\n            prevNode = curNode;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nvar isCompleteTree = function(root) {\\n    \\n    // Initialization\\n    let traversal_queue = [root];\\n    let prevNode = root;\\n    \\n    // Launch level-order traversal\\n    while( traversal_queue.length ){\\n        \\n        let curNode = traversal_queue.shift();\\n        \\n        if( curNode != null )\\n        {\\n            if( prevNode == null ){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }    \\n            \\n            traversal_queue.push( curNode.left );\\n            traversal_queue.push( curNode.right );\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode;\\n    }\\n    \\n    return true;\\n};\\n```\n```\\nimport (\\n    \"container/list\"\\n)\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n    \\n    // Initialization\\n    traversalQ := list.New()\\n    traversalQ.PushBack( root )\\n    \\n    prevNode := root\\n    \\n    // Launch level-order traversal\\n    for traversalQ.Len() != 0 {\\n        \\n        queueHead := traversalQ.Front();\\n        traversalQ.Remove( queueHead )\\n        \\n        curNode := queueHead.Value.(*TreeNode)\\n        \\n        if( curNode != nil ){\\n            \\n            if( prevNode == nil){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }\\n            \\n            traversalQ.PushBack( curNode.Left )\\n            traversalQ.PushBack( curNode.Right )\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode\\n    }\\n    \\n    return true;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        std::queue< TreeNode* > traversalQ;\\n        traversalQ.push( root );\\n        TreeNode* prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( traversalQ.size() ){\\n            \\n            TreeNode* curNode = traversalQ.front();\\n            traversalQ.pop();\\n            \\n            if( curNode != nullptr ){\\n                \\n                if( prevNode == nullptr ){\\n                    // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                    return false;\\n                }\\n                \\n                traversalQ.push( curNode->left );\\n                traversalQ.push( curNode->right );\\n            }\\n            \\n            // update previous node\\n            prevNode = curNode;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242287,
                "title": "python-solution",
                "content": "DFS. Time complexity: `O(n)`, space complexity: `O(h)`.\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        # number of nodes, right_most_coords\\n        def dfs(root, coord):\\n            if not root:\\n                return 0, 0\\n            l = dfs(root.left, 2*coord)\\n            r = dfs(root.right, 2*coord+1)\\n            tot = l[0]+r[0]+1\\n            right_most = max(coord, l[1], r[1])\\n            return tot, right_most\\n        if not root:\\n            return True\\n        tot, right_most = dfs(root, 1)\\n        return tot == right_most\\n```\\n\\nBFS. Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        q = collections.deque([(root, 1)])\\n        res = []\\n        while q:\\n            u, coord = q.popleft()\\n            res.append(coord)\\n            if u.left:\\n                q.append((u.left, 2*coord))\\n            if u.right:\\n                q.append((u.right, 2*coord+1))\\n        return len(res) == res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        # number of nodes, right_most_coords\\n        def dfs(root, coord):\\n            if not root:\\n                return 0, 0\\n            l = dfs(root.left, 2*coord)\\n            r = dfs(root.right, 2*coord+1)\\n            tot = l[0]+r[0]+1\\n            right_most = max(coord, l[1], r[1])\\n            return tot, right_most\\n        if not root:\\n            return True\\n        tot, right_most = dfs(root, 1)\\n        return tot == right_most\\n```\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        q = collections.deque([(root, 1)])\\n        res = []\\n        while q:\\n            u, coord = q.popleft()\\n            res.append(coord)\\n            if u.left:\\n                q.append((u.left, 2*coord))\\n            if u.right:\\n                q.append((u.right, 2*coord+1))\\n        return len(res) == res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205699,
                "title": "c-java-track-leftmost-height",
                "content": "We traverse the tree and track the current height `h`. The very first leaf is the leftmost node, so its height sets `target_height`. \\n\\nFor remaining leaves, the height should be the same as `target_height`. Since the last level may not be filled, our height can become `target_height - 1`. In that case, we set `last_level_filled` to `1`, and check that the height of remaining leaves equals `target_height - last_level_filled`.\\n\\n**C++**\\n```\\nint target_height = 0, last_level_filled = false;\\nbool isCompleteTree(TreeNode* r, int h = 0) {\\n  if (r == nullptr) {\\n    if (target_height == 0) {\\n        target_height = h;\\n    } else if (h == target_height - 1) {\\n        last_level_filled = true;\\n    }\\n    return h == target_height - last_level_filled;\\n  }\\n  return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n}\\n```\\n**Java**\\n```\\nprivate int target_height = 0, last_level_filled = 0;\\nprivate boolean dfs(TreeNode r, int h) {\\n    if (r == null) {\\n        if (target_height == 0) {\\n            target_height = h;\\n        } else if (h == target_height - 1) {\\n            last_level_filled = 1;\\n        }\\n        return h == target_height - last_level_filled;\\n    }\\n    return dfs(r.left, h + 1) && dfs(r.right, h + 1);\\n}\\npublic boolean isCompleteTree(TreeNode root) {\\n    return dfs(root, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint target_height = 0, last_level_filled = false;\\nbool isCompleteTree(TreeNode* r, int h = 0) {\\n  if (r == nullptr) {\\n    if (target_height == 0) {\\n        target_height = h;\\n    } else if (h == target_height - 1) {\\n        last_level_filled = true;\\n    }\\n    return h == target_height - last_level_filled;\\n  }\\n  return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n}\\n```\n```\\nprivate int target_height = 0, last_level_filled = 0;\\nprivate boolean dfs(TreeNode r, int h) {\\n    if (r == null) {\\n        if (target_height == 0) {\\n            target_height = h;\\n        } else if (h == target_height - 1) {\\n            last_level_filled = 1;\\n        }\\n        return h == target_height - last_level_filled;\\n    }\\n    return dfs(r.left, h + 1) && dfs(r.right, h + 1);\\n}\\npublic boolean isCompleteTree(TreeNode root) {\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298689,
                "title": "c-bfs-90-beat-intution-approach",
                "content": "# Intuition\\npoints by points\\n\\n-> We need to traverse and check either there is any case where our tree become uncomplete or we can say false to our answer.\\n\\n-> If our a level is completely fill then we not to thing over it , by observing we are getting intution to travel it by level order. for level order traversal we have to use **queue**.\\n\\n-> From above discussion , we conclude to use level order traversal and look for each level seperately.\\n\\n-> **As much as left possible** means if there is any node exist in  last level it should be in left not in right.\\n\\n-> Now , let\\'s go for Approach.\\n\\n# Approach\\n-> From above\\n\\n-> If we find any node NULL then should not be any node after that , if there exist any node after a NULL node then it will not be our compelete tree and we can return false.\\n\\n-> we need to Check do i previously find any NULL node if yes and also getting another node apart from null then return false other wise return true after complete ittiration.\\n\\n-> Next you may understand by code directly.\\n\\nif you read it let me know by commenting or doing VOTE UP !!\\n\\nif you read it just Vote it UP!!\\n\\n# Complexity\\n- Time complexity:\\no(n) , need to check for all nodes.\\n\\n- Space complexity:\\nO(W)\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296050,
                "title": "python-simple-dfs-using-recursion",
                "content": "```\\nclass Solution(object):\\n    node_count = 0\\n    max_position = 0\\n\\n    def isCompleteTree(self, root):\\n        self.isCompleteTreeHelper(root, 1)\\n        return self.max_position == self.node_count\\n\\n    def isCompleteTreeHelper(self, root, position):\\n        if root is None:\\n            return\\n        self.node_count += 1\\n        self.max_position = max(self.max_position, position)\\n        self.isCompleteTreeHelper(root.left, 2 * position)\\n        self.isCompleteTreeHelper(root.right, 2 * position + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    node_count = 0\\n    max_position = 0\\n\\n    def isCompleteTree(self, root):\\n        self.isCompleteTreeHelper(root, 1)\\n        return self.max_position == self.node_count\\n\\n    def isCompleteTreeHelper(self, root, position):\\n        if root is None:\\n            return\\n        self.node_count += 1\\n        self.max_position = max(self.max_position, position)\\n        self.isCompleteTreeHelper(root.left, 2 * position)\\n        self.isCompleteTreeHelper(root.right, 2 * position + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910868,
                "title": "bfs-level-order-traversal-c",
                "content": "BFS : Level Order Traversal. C++\\n```\\n//please upvote, if you like my approach.\\n//pre-request : basic knowledge of level order traversal.\\n//we traverse the tree level wise, whenever we encounter a null value we keep track of that. \\n//if our first null is last value in binary tree, then our tree is complete binary tree. else not complete binary tree.\\nbool isCompleteTree(TreeNode* root) {\\n        bool value = false;\\n        if(root==NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(q.size()>0)\\n        {\\n            TreeNode *p = q.front();\\n            q.pop();\\n            if(p==NULL)\\n            {\\n                value=true;\\n            }\\n            else\\n            {\\n                if(value)\\n                    return false;\\n                q.push(p->left);\\n                q.push(p->right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n//please upvote, if you like my approach.\\n//pre-request : basic knowledge of level order traversal.\\n//we traverse the tree level wise, whenever we encounter a null value we keep track of that. \\n//if our first null is last value in binary tree, then our tree is complete binary tree. else not complete binary tree.\\nbool isCompleteTree(TreeNode* root) {\\n        bool value = false;\\n        if(root==NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(q.size()>0)\\n        {\\n            TreeNode *p = q.front();\\n            q.pop();\\n            if(p==NULL)\\n            {\\n                value=true;\\n            }\\n            else\\n            {\\n                if(value)\\n                    return false;\\n                q.push(p->left);\\n                q.push(p->right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205675,
                "title": "easy-recursive-solution-java",
                "content": "```\\n   public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTree(root,0,countNodes(root));\\n    }\\n    private boolean isCompleteTree(TreeNode root, int i, int n) { \\n        if (root == null)  return true; \\n        else if (i >= n) return false; \\n        return isCompleteTree(root.left, 2 * i + 1, n) && isCompleteTree(root.right, 2 * i + 2, n); \\n    } \\n     private  int countNodes(TreeNode root) { \\n        if (root == null) return 0; \\n        return 1 + countNodes(root.left) + countNodes(root.right); \\n    } \\n\\t",
                "solutionTags": [],
                "code": "```\\n   public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTree(root,0,countNodes(root));\\n    }\\n    private boolean isCompleteTree(TreeNode root, int i, int n) { \\n        if (root == null)  return true; \\n        else if (i >= n) return false; \\n        return isCompleteTree(root.left, 2 * i + 1, n) && isCompleteTree(root.right, 2 * i + 2, n); \\n    } \\n     private  int countNodes(TreeNode root) { \\n        if (root == null) return 0; \\n        return 1 + countNodes(root.left) + countNodes(root.right); \\n    } \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3298408,
                "title": "day-74-bfs-o-n-time-and-o-n-space-easiest-beginner-friendly-solution",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*The idea is to do a level order traversal of the binary tree using a queue. As we traverse each level, we keep track of whether we have encountered any null nodes in between non-null nodes. If we encounter a null node after encountering a non-null node, we set a flag isNullInBetweenNodes to true. If we encounter another non-null node after encountering a null node, then the tree is not complete, and we can return false. If we successfully complete the traversal of the entire tree without returning false, then the tree is complete, and we can return true.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create a queue and add the root node to it.\\n2. Initialize a boolean flag isNullInBetweenNodes to false.\\n3. While the queue is not empty, do the following:\\n    - a. Get the size of the queue and initialize a loop to iterate over each node in the level.\\n    - b. Dequeue the node at the front of the queue.\\n    - c. If the dequeued node is null, set the isNullInBetweenNodes flag to true.\\n    - d. If the dequeued node is not null and isNullInBetweenNodes is true, then the tree is not complete. Return false.\\n    - e. If the dequeued node is not null, add its left and right children to the queue.\\n1. If the loop completes without returning false, then the tree is complete. Return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> storeNodes;\\n        storeNodes.push(root);\\n        bool isNullInBetweenNodes = false;\\n        while (!storeNodes.empty()) {\\n            int totalNodesInLevel = storeNodes.size();\\n            while (totalNodesInLevel--) {\\n                TreeNode *currNode = storeNodes.front();\\n                storeNodes.pop();\\n                if (currNode == nullptr) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes == true) {\\n                        return false;\\n                    }\\n                    storeNodes.push(currNode -> left);\\n                    storeNodes.push(currNode -> right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean isNullInBetweenNodes = false;\\n        while (!queue.isEmpty()) {\\n            int totalNodesInLevel = queue.size();\\n            while (totalNodesInLevel-- > 0) {\\n                TreeNode currNode = queue.poll();\\n                if (currNode == null) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes) {\\n                        return false;\\n                    }\\n                    queue.add(currNode.left);\\n                    queue.add(currNode.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue = collections.deque([root])\\n        is_null_in_between_nodes = False\\n        while queue:\\n            total_nodes_in_level = len(queue)\\n            for i in range(total_nodes_in_level):\\n                curr_node = queue.popleft()\\n                if curr_node is None:\\n                    is_null_in_between_nodes = True\\n                else:\\n                    if is_null_in_between_nodes:\\n                        return False\\n                    queue.append(curr_node.left)\\n                    queue.append(curr_node.right)\\n        return True\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(N)**, where N is the number of nodes in the binary tree. We visit each node exactly once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(N)**, where N is the maximum number of nodes at any level of the binary tree. In the worst case, the last level of the binary tree may have N/2 nodes (in a complete binary tree), and thus the size of the queue can grow up to N/2.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> storeNodes;\\n        storeNodes.push(root);\\n        bool isNullInBetweenNodes = false;\\n        while (!storeNodes.empty()) {\\n            int totalNodesInLevel = storeNodes.size();\\n            while (totalNodesInLevel--) {\\n                TreeNode *currNode = storeNodes.front();\\n                storeNodes.pop();\\n                if (currNode == nullptr) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes == true) {\\n                        return false;\\n                    }\\n                    storeNodes.push(currNode -> left);\\n                    storeNodes.push(currNode -> right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean isNullInBetweenNodes = false;\\n        while (!queue.isEmpty()) {\\n            int totalNodesInLevel = queue.size();\\n            while (totalNodesInLevel-- > 0) {\\n                TreeNode currNode = queue.poll();\\n                if (currNode == null) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes) {\\n                        return false;\\n                    }\\n                    queue.add(currNode.left);\\n                    queue.add(currNode.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue = collections.deque([root])\\n        is_null_in_between_nodes = False\\n        while queue:\\n            total_nodes_in_level = len(queue)\\n            for i in range(total_nodes_in_level):\\n                curr_node = queue.popleft()\\n                if curr_node is None:\\n                    is_null_in_between_nodes = True\\n                else:\\n                    if is_null_in_between_nodes:\\n                        return False\\n                    queue.append(curr_node.left)\\n                    queue.append(curr_node.right)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298705,
                "title": "faster-than-100-bfs-concise-full-explained-c",
                "content": "# Intuition\\nIn a complete Binary tree, all the levels except the last level should be fully filled and the last level should be filled from the left side.\\n\\nSo, if there\\'s a NULL node at any level, it should not be followed by any Non-NULL node, neither in the same level, nor in the next level.\\n\\n# Approach\\nThis can be implemented using simple BFS. Insert the elements in the queue until there\\'s a NULL node encountered. Use a bool variable for that(nullfound used in the code). If a node exists after NULL is found, simply return false as the tree can not be a complete Binary Tree.\\n\\nIf no such case is encountered, return True;\\n\\n# Complexity\\n- Time complexity:\\nAt most all the nodes will be processed if the tree is a complete binary tree.\\nThis is a simple Level-order Traversal, so the TC will be O(n) where n is the total number of nodes in the tree.\\n\\n- Space complexity:\\nA queue is used to store the items for a level, so the SC will be the maximum width of the tree , i.e., O(w).\\n\\n**PLEASE UPVOTE IF YOU FIND MY SOLUTION HELPFUL :)**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullfound = false;\\n        while(!q.empty())\\n        {   \\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr == NULL)\\n            nullfound = true;\\n            else\\n            {\\n                if(nullfound)\\n                return false;\\n                else\\n                {\\n                    q.push(curr->left);\\n                    q.push(curr->right);\\n                }\\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullfound = false;\\n        while(!q.empty())\\n        {   \\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr == NULL)\\n            nullfound = true;\\n            else\\n            {\\n                if(nullfound)\\n                return false;\\n                else\\n                {\\n                    q.push(curr->left);\\n                    q.push(curr->right);\\n                }\\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506222,
                "title": "java-simple-bfs-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n\\t\\t\\t\\n\\t\\t\\t// Trick here is that if you encounter  null between two non-null values, it ain\\'t complete binary tree.\\n            if (node == null && queue.peek() != null) return false; \\n            \\n            if (node != null)  {\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n\\t\\t\\t\\n\\t\\t\\t// Trick here is that if you encounter  null between two non-null values, it ain\\'t complete binary tree.\\n            if (node == null && queue.peek() != null) return false; \\n            \\n            if (node != null)  {\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379607,
                "title": "java-easy-solution-using-queue-bfs-and-it-s-property-that-it-allows-null-values",
                "content": "1ms faster than 92.58% solutions and 36.4MB less than 100% solutions.\\n``` \\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        while(q.isEmpty()!=true){\\n            TreeNode temp = q.remove();\\n            if(temp==null){                             // As soon as a null is encountered, now no other non null value could be on the Queue. So I check, if there is any I return False, else True.\\n                while(q.isEmpty()!=true){\\n                    TreeNode temp2 = q.remove();\\n                    if(temp2!=null)\\n                        return false;\\n                }\\n                return true;\\n            }\\n            q.add(temp.left);\\n            q.add(temp.right);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "``` \\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        while(q.isEmpty()!=true){\\n            TreeNode temp = q.remove();\\n            if(temp==null){                             // As soon as a null is encountered, now no other non null value could be on the Queue. So I check, if there is any I return False, else True.\\n                while(q.isEmpty()!=true){\\n                    TreeNode temp2 = q.remove();\\n                    if(temp2!=null)\\n                        return false;\\n                }\\n                return true;\\n            }\\n            q.add(temp.left);\\n            q.add(temp.right);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298252,
                "title": "level-order-traversal-video-java-c-python",
                "content": "# Intuition\\nIn a complete binary tree the nodes are added from top to bottom and from left to right. So we use the same traversal method i.e level order traversal and if there is any null prior to any non null node, the ans is false.\\n\\n# Approach\\n1. Initiate a queue.\\n2. Add root Node to queue.\\n3. while queue.peek() != null remove node and add left and right child.\\n4. Finally remove all continious null values.\\n5. If queue is not empty return false/ else true. \\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fiCQAESE2Ts\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while (queue.peek() != null) {\\n            TreeNode node = queue.remove();\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        while (!queue.isEmpty() && queue.peek() == null)\\n            queue.remove();\\n        return queue.isEmpty();\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.front() != NULL) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while (!q.empty() && q.front() == NULL) {\\n            q.pop();\\n        }\\n        return q.empty();\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        queue = deque()\\n        queue.append(root)\\n        while queue[0] is not None:\\n            node = queue.popleft()\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        while queue and queue[0] is None:\\n            queue.popleft()\\n        return not queue\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while (queue.peek() != null) {\\n            TreeNode node = queue.remove();\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        while (!queue.isEmpty() && queue.peek() == null)\\n            queue.remove();\\n        return queue.isEmpty();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.front() != NULL) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while (!q.empty() && q.front() == NULL) {\\n            q.pop();\\n        }\\n        return q.empty();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        queue = deque()\\n        queue.append(root)\\n        while queue[0] is not None:\\n            node = queue.popleft()\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        while queue and queue[0] is None:\\n            queue.popleft()\\n        return not queue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150378,
                "title": "python-bfs-simple",
                "content": "```\\ndef isCompleteTree(self, root: TreeNode) -> bool:\\n        end = False\\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            node = queue.popleft()\\n            \\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                else:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n        \\n        return True\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef isCompleteTree(self, root: TreeNode) -> bool:\\n        end = False\\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            node = queue.popleft()\\n            \\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                else:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n        \\n        return True\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 492339,
                "title": "java-my-simple-solution-using-bfs",
                "content": "We do a BFS to check if we get a non-null node after a null node. If so, tree is not complete, else it is complete.\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n\\tif(root==null) return true;\\n\\tQueue<TreeNode> q = new LinkedList<>();\\n\\tq.offer(root);\\n\\tboolean flag = false;\\n\\twhile(!q.isEmpty()) {\\n\\t\\tTreeNode curr = q.poll();\\n\\t\\tif(curr != null && flag) return false;\\n\\t\\tif(curr == null) flag = true;\\n\\t\\telse {\\n\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\tq.offer(curr.right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n\\tif(root==null) return true;\\n\\tQueue<TreeNode> q = new LinkedList<>();\\n\\tq.offer(root);\\n\\tboolean flag = false;\\n\\twhile(!q.isEmpty()) {\\n\\t\\tTreeNode curr = q.poll();\\n\\t\\tif(curr != null && flag) return false;\\n\\t\\tif(curr == null) flag = true;\\n\\t\\telse {\\n\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\tq.offer(curr.right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 206520,
                "title": "easy-python-with-explanation-beats-100-so-far",
                "content": "Traverse the tree one level at a time, adding both children of each node to the queue as we go.  Keep a count of how many non-null nodes are left in the queue.  The first time we encounter a null node popped from the queue, if the counter shows nothing left, the tree is complete - otherwise not.\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        count = 1 if root else 0\\n        nodes = [root]\\n        while nodes:\\n            x = nodes.pop(0)\\n            if not x:\\n                return count == 0\\n            count -= 1\\n            nodes += [x.left, x.right]\\n            count = count + 1 if x.left else count\\n            count = count + 1 if x.right else count\\n        \\n        return true\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        count = 1 if root else 0\\n        nodes = [root]\\n        while nodes:\\n            x = nodes.pop(0)\\n            if not x:\\n                return count == 0\\n            count -= 1\\n            nodes += [x.left, x.right]\\n            count = count + 1 if x.left else count\\n            count = count + 1 if x.right else count\\n        \\n        return true\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687139,
                "title": "c-simplest-bfs-code",
                "content": "**PLEASE UPVOTE IF IT HELPS A BIT**\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        bool flag=true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto curr= q.front();\\n            q.pop();\\n            if(curr==NULL)\\n            {\\n                flag=false;\\n            }\\n            else\\n            {\\n                if(flag==false)\\n                {\\n                    return false;\\n                }\\n                q.push(curr->left);\\n                q.push(curr->right);\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        bool flag=true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto curr= q.front();\\n            q.pop();\\n            if(curr==NULL)\\n            {\\n                flag=false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 212108,
                "title": "c-4ms-dfs-o-n-speed-o-lg-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, int d, vector<int>& v) {\\n        if (root == NULL) {\\n            if (v.size() == 0) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            if (v.back() == d) {\\n                return true;\\n            }\\n            \\n            if (v.size() == 1 && v.back() == d + 1) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        return dfs(root->left,  d + 1, v) && \\n               dfs(root->right, d + 1, v);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        vector<int> v;\\n        v.reserve(2);\\n        return dfs(root, 0, v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, int d, vector<int>& v) {\\n        if (root == NULL) {\\n            if (v.size() == 0) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            if (v.back() == d) {\\n                return true;\\n            }\\n            \\n            if (v.size() == 1 && v.back() == d + 1) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        return dfs(root->left,  d + 1, v) && \\n               dfs(root->right, d + 1, v);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        vector<int> v;\\n        v.reserve(2);\\n        return dfs(root, 0, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301628,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236163,
                "title": "level-order-traversal-bfs-o-n-time-o-n-space-for-queue",
                "content": "**Algorithm** : \\n1. find the total Node in Tree using a Utility function.\\n2. first create a queue and push root Node.\\n3. maintain a `int count = 0` for storing How many nodes are processed.\\n4. do level order traversal and push all Node(both `NULL` and `Non-NULL`) and increase a count with `q.pop()` [after processing the item].\\n5. When You find first `NULL` in `queue` break the while loop (Why?). \\n6. Now compaire the count with Total Node in Tree.\\n7. if count is less then Total Node then return false.\\n8. else return true.\\n\\nWhy? -> In complete binary tree the level order traversal is as follow.\\n```\\n            [val,val,val.......,...val, val ......., val,null,null,null.........,null]\\n\\t\\t\\t|------------------------------------------|^|--------------------------|\\n\\t\\t\\t\\t\\tNon null root.                                 Null root\\n```\\n**So the Count Must be equal to Total Number of root after finding first NULL root in a Complete Binary Tree.**\\n```\\nprivate:\\n    int TotalNode(TreeNode *root){\\n        if(root==NULL) return 0;\\n        return 1 + TotalNode(root->left) + TotalNode(root->right);\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int totalEle = TotalNode(root);\\n        int count = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.empty()==false){\\n           \\n            TreeNode* curr = q.front();\\n            if(curr==NULL){\\n                break;\\n            }\\n            q.pop();\\n            count++;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        \\n        if(count<totalEle) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n            [val,val,val.......,...val, val ......., val,null,null,null.........,null]\\n\\t\\t\\t|------------------------------------------|^|--------------------------|\\n\\t\\t\\t\\t\\tNon null root.                                 Null root\\n```\n```\\nprivate:\\n    int TotalNode(TreeNode *root){\\n        if(root==NULL) return 0;\\n        return 1 + TotalNode(root->left) + TotalNode(root->right);\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int totalEle = TotalNode(root);\\n        int count = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.empty()==false){\\n           \\n            TreeNode* curr = q.front();\\n            if(curr==NULL){\\n                break;\\n            }\\n            q.pop();\\n            count++;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        \\n        if(count<totalEle) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484894,
                "title": "simplest-bfs-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root)\\n        return 1;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            TreeNode* curr=q.front();\\n            q.pop();\\n\\n            if(curr->left){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->left);\\n            } else{\\n                c=1;\\n            }\\n\\n            if(curr->right){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->right);\\n            } else{\\n                c=1;\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root)\\n        return 1;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            TreeNode* curr=q.front();\\n            q.pop();\\n\\n            if(curr->left){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->left);\\n            } else{\\n                c=1;\\n            }\\n\\n            if(curr->right){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->right);\\n            } else{\\n                c=1;\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298821,
                "title": "c-easy-to-understand-explained-with-example",
                "content": "# Intuition\\nThe problem requires us to determine if the given binary tree is a complete binary tree or not. \\nA complete binary tree is one in which all levels are completely filled except possibly the last level and all nodes are as far left as possible. Therefore, we need to traverse the binary tree level by level and ensure that it satisfies these properties.\\n\\n![image.png](https://assets.leetcode.com/users/images/78c4e2bd-fae2-4ee9-8720-fa41a2c05908_1678860865.4098353.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/bae5991d-d8d2-4a89-afc5-a4041708157c_1678861616.1194062.png)\\n\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use a breadth-first search (BFS) algorithm to traverse the binary tree level by level. \\n1. We start with the root node and add it to a queue. \\n2. Then, while the queue is not empty:\\n    - we process each node at the front of the queue, add its left and right children to the queue if they exist, and remove the processed node from the queue. \\n    - We keep track of whether we have seen a null node previously using a flag variable. \\n    - If we encounter a non-null node after seeing a null node, then the binary tree is not a complete binary tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Example\\n```\\n       1\\n     /   \\\\\\n    2     3\\n   / \\\\   / \\n  4   5 6   \\n / \\\\\\n8   9\\n```\\nThe level-by-level traversal using BFS would be:\\n\\n```\\n1st level: [1]\\n2nd level: [2, 3]\\n3rd level: [4, 5, 6], nullSeen=true as null node is encountered after 6\\n4th level: [8,9] \\n```\\nIn the last level when we process 8, nullSeen was true hence we return false as we encounter a non-null node after seeing a null node.\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**, where n is the number of nodes in the binary tree. This is because we need to visit each node once in the worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**. The space complexity is actually O(w), where w is the maximum width of the binary tree. In the worst case, the width of the binary tree can be as large as n/2 (for a complete binary tree), so the space complexity of the function is O(n/2) =O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true; // if the root is null, then the tree is complete\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; // flag that keeps track of whether we encountered a null node previously or not\\n\\n        while(!q.empty()){ \\n            int levelSize=q.size(); // number of nodes at this level\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; // if the node is null, set the nullSeen flag to true \\n                else{\\n                    if(nullSeen) return false; // if we already had a null node, then this binary tree is not complete\\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n       1\\n     /   \\\\\\n    2     3\\n   / \\\\   / \\n  4   5 6   \\n / \\\\\\n8   9\\n```\n```\\n1st level: [1]\\n2nd level: [2, 3]\\n3rd level: [4, 5, 6], nullSeen=true as null node is encountered after 6\\n4th level: [8,9] \\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true; // if the root is null, then the tree is complete\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; // flag that keeps track of whether we encountered a null node previously or not\\n\\n        while(!q.empty()){ \\n            int levelSize=q.size(); // number of nodes at this level\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; // if the node is null, set the nullSeen flag to true \\n                else{\\n                    if(nullSeen) return false; // if we already had a null node, then this binary tree is not complete\\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298211,
                "title": "c-easiest-approach-beats-100-level-order-traversal",
                "content": "# Intuition\\nThe problem asks us to determine whether a binary tree is a complete binary tree or not. A complete binary tree is a binary tree where every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.\\n\\n# Approach\\nTo solve this problem, we can do a level order traversal of the binary tree and keep track of the following:\\n\\n1. A flag that indicates if we have seen a non-full level (a level that is not completely filled).\\n2. A flag that indicates if we have seen a node that has only one child.\\n3. We start by pushing the root node into a queue. Then, we repeatedly dequeue a node from the queue and perform the following steps:\\n\\n4. If the dequeued node is null, we set the seen_non_full_level flag to true, indicating that we have seen a non-full level.\\n5. Otherwise, if we have already seen a non-full level and the node has only one child, then the binary tree is not a complete binary tree, and we return false.\\n6. Otherwise, we enqueue the left and right child of the node into the queue.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n), where n is the number of nodes in the binary tree. This is because we need to visit every node in the tree once during the level order traversal.\\n- Space complexity:\\nThe space complexity of the function is O(w), where w is the maximum width of the binary tree (i.e., the maximum number of nodes that can be in a single level). This is because we need to store at most w nodes in the queue at any given time during the level order traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seen_non_full_level = false;\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                seen_non_full_level = true;\\n            } else {\\n                if (seen_non_full_level) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\\\\\\\\\uD83D\\uDC47upvote Below if you liked the solution\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seen_non_full_level = false;\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                seen_non_full_level = true;\\n            } else {\\n                if (seen_non_full_level) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\\\\\\\\\uD83D\\uDC47upvote Below if you liked the solution\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298198,
                "title": "swift-bfs-3-sloc",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        var q = [root]    \\n        while let n = q.removeFirst() { q += [n.left, n.right] }\\n        return q.allSatisfy { $0 == nil }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        var q = [root]    \\n        while let n = q.removeFirst() { q += [n.left, n.right] }\\n        return q.allSatisfy { $0 == nil }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315536,
                "title": "using-recursion-in-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countt(TreeNode *root)                             ////count the number of nodes \\n  {\\n      if(!root)\\n      return 0;\\n      \\n      return 1+countt(root->left)+countt(root->right);\\n  }\\n    bool iscomplete(TreeNode *root,int id,int count)                    ///recursively check the nodes are valid or not as we do in heap \\n  {\\n      if(!root)\\n      return 1;\\n      \\n      if(id>=count)\\n      return false;\\n      \\n      return iscomplete(root->left,2*id+1,count) && iscomplete(root->right,2*id+2,count);\\n  }\\n    bool isCompleteTree(TreeNode* root) {\\n         int count=countt(root);\\n        int id=0;\\n        return iscomplete(root,0,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countt(TreeNode *root)                             ////count the number of nodes \\n  {\\n      if(!root)\\n      return 0;\\n      \\n      return 1+countt(root->left)+countt(root->right);\\n  }\\n    bool iscomplete(TreeNode *root,int id,int count)                    ///recursively check the nodes are valid or not as we do in heap \\n  {\\n      if(!root)\\n      return 1;\\n      \\n      if(id>=count)\\n      return false;\\n      \\n      return iscomplete(root->left,2*id+1,count) && iscomplete(root->right,2*id+2,count);\\n  }\\n    bool isCompleteTree(TreeNode* root) {\\n         int count=countt(root);\\n        int id=0;\\n        return iscomplete(root,0,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941333,
                "title": "python-easy-12-ms-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            if not node and q:\\n                return not any(q)\\n            elif node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            if not node and q:\\n                return not any(q)\\n            elif node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690494,
                "title": "well-commented-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode*root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n    bool isCBT(TreeNode*root,int i,int size){\\n        \\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        if(i>=size){\\n            return false;\\n        }\\n        else{\\n            return isCBT(root->left,2*i+1,size) && isCBT(root->right,2*i+2,size);\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        // here will need to check just 1 condition \\n        // if index of a node don\\'t exceed the total number of elements\\n        \\n        // to find the total number of element find the height of the tree and 2*h is total number of nodes\\n\\n        int size=countNodes(root);\\n        return isCBT(root,0,size);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode*root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n    bool isCBT(TreeNode*root,int i,int size){\\n        \\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        if(i>=size){\\n            return false;\\n        }\\n        else{\\n            return isCBT(root->left,2*i+1,size) && isCBT(root->right,2*i+2,size);\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        // here will need to check just 1 condition \\n        // if index of a node don\\'t exceed the total number of elements\\n        \\n        // to find the total number of element find the height of the tree and 2*h is total number of nodes\\n\\n        int size=countNodes(root);\\n        return isCBT(root,0,size);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485000,
                "title": "simplest-dfs-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Auxillary Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int count_nodes(TreeNode* root){\\n        if(!root) return 0;\\n        int l=count_nodes(root->left);\\n        int r=count_nodes(root->right);\\n        return l+r+1;\\n    }\\n\\n    bool check(TreeNode* root,int ind,int n){\\n        if(!root)\\n        return 1;\\n\\n        if(ind>=n)\\n        return 0;\\n\\n        bool l=check(root->left,2*ind+1,n) ;\\n        bool r= check(root->right,2*ind+2,n);\\n        return l and r;\\n        \\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root) return 1;  \\n\\n        int n=count_nodes(root);   //For counting number of nodes\\n        return check(root,0,n);  \\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int count_nodes(TreeNode* root){\\n        if(!root) return 0;\\n        int l=count_nodes(root->left);\\n        int r=count_nodes(root->right);\\n        return l+r+1;\\n    }\\n\\n    bool check(TreeNode* root,int ind,int n){\\n        if(!root)\\n        return 1;\\n\\n        if(ind>=n)\\n        return 0;\\n\\n        bool l=check(root->left,2*ind+1,n) ;\\n        bool r= check(root->right,2*ind+2,n);\\n        return l and r;\\n        \\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root) return 1;  \\n\\n        int n=count_nodes(root);   //For counting number of nodes\\n        return check(root,0,n);  \\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298313,
                "title": "java-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029782,
                "title": "javascript-clean-dfs-bfs-solutions",
                "content": "# Solution 1: DFS\\n```javascript\\nvar isCompleteTree = function(root) {\\n  \\n    function dfs(node) {\\n        if(!node) return [0];\\n        return [...dfs(node.left), ...dfs(node.right)].map(x => x + 1);\\n    }\\n    \\n    const heights = dfs(root);\\n    const maxH = heights[0];\\n    \\n    for(let i = 1; i < heights.length; i++) {\\n        if(heights[i] > heights[i-1]) return false;\\n        if(heights[i] < maxH-1) return false;\\n    }\\n    return true;\\n};\\n```\\n# Solution 2: BFS\\n```javascript\\nvar isCompleteTree = function(root) {\\n    let seenNull = false;\\n    let queue = [root];\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let nextNode of queue) {\\n            if(!nextNode) seenNull = true;\\n            else {\\n                if(seenNull) return false;\\n                next.push(nextNode.left);\\n                next.push(nextNode.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar isCompleteTree = function(root) {\\n  \\n    function dfs(node) {\\n        if(!node) return [0];\\n        return [...dfs(node.left), ...dfs(node.right)].map(x => x + 1);\\n    }\\n    \\n    const heights = dfs(root);\\n    const maxH = heights[0];\\n    \\n    for(let i = 1; i < heights.length; i++) {\\n        if(heights[i] > heights[i-1]) return false;\\n        if(heights[i] < maxH-1) return false;\\n    }\\n    return true;\\n};\\n```\n```javascript\\nvar isCompleteTree = function(root) {\\n    let seenNull = false;\\n    let queue = [root];\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let nextNode of queue) {\\n            if(!nextNode) seenNull = true;\\n            else {\\n                if(seenNull) return false;\\n                next.push(nextNode.left);\\n                next.push(nextNode.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 803885,
                "title": "python-easy-2-approaches",
                "content": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        index,count = 0,0\\n        Q = collections.deque([(root,index)])\\n        while Q:\\n            u,index = Q.popleft()\\n            count += 1\\n            if u.left:\\n                Q.append((u.left,2*index+1))\\n            if u.right:\\n                Q.append((u.right,2*index+2))\\n        return index+1 == count\\n```\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        Q = collections.deque([root])\\n        while Q[0]:\\n            u = Q.popleft()\\n            Q.append(u.left)\\n            Q.append(u.right)\\n        return not any(Q)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        index,count = 0,0\\n        Q = collections.deque([(root,index)])\\n        while Q:\\n            u,index = Q.popleft()\\n            count += 1\\n            if u.left:\\n                Q.append((u.left,2*index+1))\\n            if u.right:\\n                Q.append((u.right,2*index+2))\\n        return index+1 == count\\n```\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        Q = collections.deque([root])\\n        while Q[0]:\\n            u = Q.popleft()\\n            Q.append(u.left)\\n            Q.append(u.right)\\n        return not any(Q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538773,
                "title": "java-bfs-classical",
                "content": "First idea for all Binary tree is DFS, this is very classcial example to use BFS\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if (node == null) {\\n                found = true;\\n            } else {\\n                if (found) return false;\\n                q.offer(node.left);\\n                q.offer(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\nMORE easy understand version:\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return true;\\n        boolean foundPrev = false;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            int l = q.size();\\n            boolean found = false;\\n            for (int i = 0; i < l; i++) {\\n                TreeNode node = q.poll();\\n                if (node != null) {\\n                    if (found || foundPrev) return false;\\n                    q.offer(node.left);\\n                    q.offer(node.right);\\n                } else{\\n                    found = true;\\n                }\\n            }\\n            foundPrev = found;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if (node == null) {\\n                found = true;\\n            } else {\\n                if (found) return false;\\n                q.offer(node.left);\\n                q.offer(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return true;\\n        boolean foundPrev = false;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            int l = q.size();\\n            boolean found = false;\\n            for (int i = 0; i < l; i++) {\\n                TreeNode node = q.poll();\\n                if (node != null) {\\n                    if (found || foundPrev) return false;\\n                    q.offer(node.left);\\n                    q.offer(node.right);\\n                } else{\\n                    found = true;\\n                }\\n            }\\n            foundPrev = found;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329540,
                "title": "short-c-solution-with-comments-faster-than-93",
                "content": "* BFS traversal of a tree (level by level)\\n* If a tree is complete, no non-empty nodes after empty nodes.\\n\\n```\\nbool isCompleteTree(TreeNode* root) {\\n\\tqueue<TreeNode*> q;\\n\\tq.push(root);\\n\\tbool null_visited = false;\\n\\twhile(!q.empty()){\\n\\t\\tauto n = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (!n)\\n\\t\\t\\tnull_visited = true;\\n\\t\\telse{\\n\\t\\t\\tif (null_visited)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tq.push(n->left);\\n\\t\\t\\tq.push(n->right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isCompleteTree(TreeNode* root) {\\n\\tqueue<TreeNode*> q;\\n\\tq.push(root);\\n\\tbool null_visited = false;\\n\\twhile(!q.empty()){\\n\\t\\tauto n = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (!n)\\n\\t\\t\\tnull_visited = true;\\n\\t\\telse{\\n\\t\\t\\tif (null_visited)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tq.push(n->left);\\n\\t\\t\\tq.push(n->right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326507,
                "title": "javascript-beats-96-bfs",
                "content": "```\\n\\n```var isCompleteTree = function(root) {\\n    if(root == null) return true;\\n    var end=false;\\n    var q=[root];\\n    while(q.length>0){\\n         var cur=q.shift();\\n         if(cur == null){\\n             end=true;\\n         }else{\\n             if(end) return false;\\n             q.push(cur.left);\\n             q.push(cur.right);\\n         }\\n    }\\n    return true;\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298728,
                "title": "javascript-rust-go-easy-to-understand-bfs-solution-with-explanation",
                "content": "# Approach\\n\\nIn this problem, we need to determine if a binary tree is complete. A binary tree is considered complete if all levels of the tree are completely filled, except possibly for the last level, which must be filled from left to right.\\n\\nWe can use a breadth-first search (BFS) approach to traverse the binary tree level by level to solve this problem. It starts by initializing a queue with the root node of the tree and then enters a loop that continues until there are no more nodes in the queue.\\n\\nIn each iteration of the loop, we remove the next node from the **front** of the queue and check whether it is null or not. If the node is null, we can set a flag to indicate that the previous node was null and continue to the next node in the queue. If the node is not null, we can check whether the previous node was null or not and if the previous node was null, we return false because a binary tree cannot have a non-null node following a null node.\\n\\nIf the node is not null and the previous node was not null, we add the left and right children of the current node to the back of the queue. By doing so, we ensure that the function traverses the tree level by level and that all nodes on the same level are visited before any nodes on the next level.\\n\\nIf the loop completes without returning false, then the binary tree is considered complete and the function returns true.\\n\\n## JavaScript Code\\n```\\nconst isCompleteTree = function (root) {\\n  let queue = [root]; // Initialize a queue with the root node\\n\\n  // Keep track of whether the previous node was null or not\\n  let isPreviousNodeNull = false;\\n\\n  // Loop until there are no more nodes in the queue\\n  while (queue.length > 0) {\\n    // Get the next node from the queue\\n    const node = queue.shift(); \\n\\n    if (!node) {\\n      // If the node is null\\n      // Set the flag to true, indicating that the previous node was null\\n      isPreviousNodeNull = true;\\n      continue; // Continue to the next node in the queue\\n    }\\n\\n    // If the previous node was null but the current node is not, \\n    // then the binary tree is not complete\\n    if (isPreviousNodeNull) return false; \\n\\n    // Add the left and right children of the current node to the queue\\n    queue.push(node.left, node.right);\\n  }\\n  // If the loop completes without finding any missing nodes, \\n  // then the binary tree is complete\\n  return true;\\n};\\n\\n```\\n\\n## Rust Solution\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = std::collections::VecDeque::new();\\n        queue.push_back(root);\\n\\n        let mut is_previous_none = false;\\n\\n        while !queue.is_empty() {\\n            let node = queue.pop_front().unwrap();\\n\\n            if node.is_none() {\\n                is_previous_none = true;\\n                continue;\\n            }\\n\\n            if is_previous_none { return false; }\\n\\n            let node = node.unwrap();\\n            queue.push_back(node.borrow().left.clone());\\n            queue.push_back(node.borrow().right.clone());\\n        }\\n\\n        true\\n    }\\n}\\n```\\n\\n## Go Solution\\n```go\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tqueue := make([]*TreeNode, 0)\\n\\tqueue = append(queue, root)\\n\\n\\tisPreviousNull := false\\n\\tfor len(queue) > 0 {\\n\\t\\tnode := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\n\\t\\tif node == nil {\\n\\t\\t\\tisPreviousNull = true\\n            continue\\n\\t\\t}\\n\\n\\t\\tif isPreviousNull { return false }\\n\\n\\t\\tqueue = append(queue, node.Left, node.Right)\\n\\t}\\n\\n\\treturn true\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst isCompleteTree = function (root) {\\n  let queue = [root]; // Initialize a queue with the root node\\n\\n  // Keep track of whether the previous node was null or not\\n  let isPreviousNodeNull = false;\\n\\n  // Loop until there are no more nodes in the queue\\n  while (queue.length > 0) {\\n    // Get the next node from the queue\\n    const node = queue.shift(); \\n\\n    if (!node) {\\n      // If the node is null\\n      // Set the flag to true, indicating that the previous node was null\\n      isPreviousNodeNull = true;\\n      continue; // Continue to the next node in the queue\\n    }\\n\\n    // If the previous node was null but the current node is not, \\n    // then the binary tree is not complete\\n    if (isPreviousNodeNull) return false; \\n\\n    // Add the left and right children of the current node to the queue\\n    queue.push(node.left, node.right);\\n  }\\n  // If the loop completes without finding any missing nodes, \\n  // then the binary tree is complete\\n  return true;\\n};\\n\\n```\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = std::collections::VecDeque::new();\\n        queue.push_back(root);\\n\\n        let mut is_previous_none = false;\\n\\n        while !queue.is_empty() {\\n            let node = queue.pop_front().unwrap();\\n\\n            if node.is_none() {\\n                is_previous_none = true;\\n                continue;\\n            }\\n\\n            if is_previous_none { return false; }\\n\\n            let node = node.unwrap();\\n            queue.push_back(node.borrow().left.clone());\\n            queue.push_back(node.borrow().right.clone());\\n        }\\n\\n        true\\n    }\\n}\\n```\n```go\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tqueue := make([]*TreeNode, 0)\\n\\tqueue = append(queue, root)\\n\\n\\tisPreviousNull := false\\n\\tfor len(queue) > 0 {\\n\\t\\tnode := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\n\\t\\tif node == nil {\\n\\t\\t\\tisPreviousNull = true\\n            continue\\n\\t\\t}\\n\\n\\t\\tif isPreviousNull { return false }\\n\\n\\t\\tqueue = append(queue, node.Left, node.Right)\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298410,
                "title": "python-3-7-lines-w-explanation-t-m-100-97",
                "content": "Here\\'s the plan:\\n- BFS the tree, left to right, level by level.\\n- We mark the instance of the first null popped from the queue and then ensure the remaining queue is only null nodes.\\n- If so, both criteria are satisfied and True is returned. If not, False is returned.\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n                        \\n        queue = deque([root])                       #   <-- initialize the queue\\n\\n        while queue[0]:                             #   <-- if and while top queue node is not null, pop   \\n            node = queue.popleft()                  #       it and then push its left child and right  \\n            queue.extend([node.left, node.right])   #       child onto the queue.\\n\\n        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. \\n            queue.popleft()                         #        \\n\\n        return not queue                            #   <-- If the queue is not empty, it must be non-null, so \\n                                                    #       return False; if the queue is empty, return True.\\n```\\n[https://leetcode.com/problems/check-completeness-of-a-binary-tree/submissions/915322764/]()",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n                        \\n        queue = deque([root])                       #   <-- initialize the queue\\n\\n        while queue[0]:                             #   <-- if and while top queue node is not null, pop   \\n            node = queue.popleft()                  #       it and then push its left child and right  \\n            queue.extend([node.left, node.right])   #       child onto the queue.\\n\\n        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. \\n            queue.popleft()                         #        \\n\\n        return not queue                            #   <-- If the queue is not empty, it must be non-null, so \\n                                                    #       return False; if the queue is empty, return True.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435504,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        bool seenNull = false ;\\n        \\n        while(q.size()){\\n            int sz = q.size() ;\\n                auto node = q.front() ; q.pop() ;\\n                if(!node) seenNull = true ;\\n                else{\\n                    if(seenNull) return false ;\\n                    q.push(node->left) , q.push(node->right) ;\\n                }\\n        }\\n        return true ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        bool seenNull = false ;\\n        \\n        while(q.size()){\\n            int sz = q.size() ;\\n                auto node = q.front() ; q.pop() ;\\n                if(!node) seenNull = true ;\\n                else{\\n                    if(seenNull) return false ;\\n                    q.push(node->left) , q.push(node->right) ;\\n                }\\n        }\\n        return true ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967423,
                "title": "c-dfs-superfast",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n //just leave a comment if u have any doubt \\nclass Solution {\\npublic:\\n    int solve(TreeNode*root)\\n    {\\n        if(root==NULL)return 0;\\n        return 1+max(solve(root->left),solve(root->right));\\n    }\\n    int ch=-1,c=-1,r=-1;\\n    void dfs(TreeNode*root,int k)\\n    {\\n        if(k>1 && (!root->left || !root->right))r=0;\\n        if(c==0 || k<1 || r==0)return;\\n        if(k==1)\\n        {\\n            ch=1;\\n            if(c==1 && (root->right || root->left))c=0;\\n            else if(!root->right)c=1;\\n            else if(root->right && !root->left)c=0;\\n            return;\\n        }\\n        dfs(root->left,k-1);\\n        if(ch==-1 || c==0)return ;\\n        dfs(root->right,k-1);\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root->left && !root->right)return true;\\n        int h=solve(root);\\n        dfs(root,h-1);\\n        if(c!=0 && r!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n //just leave a comment if u have any doubt \\nclass Solution {\\npublic:\\n    int solve(TreeNode*root)\\n    {\\n        if(root==NULL)return 0;\\n        return 1+max(solve(root->left),solve(root->right));\\n    }\\n    int ch=-1,c=-1,r=-1;\\n    void dfs(TreeNode*root,int k)\\n    {\\n        if(k>1 && (!root->left || !root->right))r=0;\\n        if(c==0 || k<1 || r==0)return;\\n        if(k==1)\\n        {\\n            ch=1;\\n            if(c==1 && (root->right || root->left))c=0;\\n            else if(!root->right)c=1;\\n            else if(root->right && !root->left)c=0;\\n            return;\\n        }\\n        dfs(root->left,k-1);\\n        if(ch==-1 || c==0)return ;\\n        dfs(root->right,k-1);\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root->left && !root->right)return true;\\n        int h=solve(root);\\n        dfs(root,h-1);\\n        if(c!=0 && r!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834142,
                "title": "c-simple-easy-code-bfs-0ms",
                "content": "Just check in level order, weather the last element is NULL or not.\\nIf you face any element after the NULL element then its not a complete BT.\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        bool ch = true;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == NULL){ch=false;}\\n            else{\\n                if(!ch){return false;}\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        bool ch = true;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == NULL){ch=false;}\\n            else{\\n                if(!ch){return false;}\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756452,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = [root]\\n        prev = root\\n        while q:\\n            node = q.pop(0)\\n            if node:\\n                if not prev:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n            prev = node\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = [root]\\n        prev = root\\n        while q:\\n            node = q.pop(0)\\n            if node:\\n                if not prev:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n            prev = node\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1393027,
                "title": "c-level-order-traversal-short-solution-o-n",
                "content": "The idea is to use level order traversal and insert the null childen too.\\nWhen you find a null, look for a non null after it, if found, return false, else, return true.\\n```cpp\\nbool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while (!q.empty()) {\\n            TreeNode* t = q.front();\\n            q.pop();\\n            \\n            if (t == NULL) {\\n                while (!q.empty()) {\\n                    if (q.front() != NULL)\\n                        return false;\\n                    q.pop();\\n                }\\n                return true;\\n            } else {\\n                q.push(t->left);\\n                q.push(t->right);\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "The idea is to use level order traversal and insert the null childen too.\\nWhen you find a null, look for a non null after it, if found, return false, else, return true.\\n```cpp\\nbool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while (!q.empty()) {\\n            TreeNode* t = q.front();\\n            q.pop();\\n            \\n            if (t == NULL) {\\n                while (!q.empty()) {\\n                    if (q.front() != NULL)\\n                        return false;\\n                    q.pop();\\n                }\\n                return true;\\n            } else {\\n                q.push(t->left);\\n                q.push(t->right);\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206358,
                "title": "c-simple-short-normal-bfs-code-null-pointer-logic",
                "content": "**Logic behind the curtains is simple :** if you take any complete tree and do BFS on it then BFS queue will contain null pointers only at the end.... if you get any null pointer in middle of your BFS , then its not a complete tree.\\nHope wording would explain what i meant!! HAPPY CODING!\\n\\nMust hit a like if u get the logic and think that its a simple cool logic :).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkForAllNull(queue<TreeNode*> q){\\n        while(!q.empty()){\\n            if(q.front() !=NULL)\\n                return false;\\n            q.pop();\\n        }\\n        return true;\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,h=0;\\n        queue<TreeNode*> q;\\n        TreeNode *p;\\n        q.push(root);\\n        while(!q.empty()){\\n            p = q.front();\\n            if(p==NULL){ // Once null pointer starts... q should contain all null then to be a complete tree\\n                if(checkForAllNull(q))\\n                    return true;\\n                return false;\\n            }\\n            q.push(p->left);\\n            q.push(p->right);\\n            q.pop();\\n        }\\n        return true;\\n    }\\n   \\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool checkForAllNull(queue<TreeNode*> q){\\n        while(!q.empty()){\\n            if(q.front() !=NULL)\\n                return false;\\n            q.pop();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 331342,
                "title": "clean-and-easy-java-dfs-and-bfs-solution",
                "content": "There are basically two ways to solve this problem. The first one is DFS solution, which relys on the equal relationship two numbers: the number of nodes in tree and the largest node index in tree.    \\nFor example, index of root is 1, so it\\'s left child index is 2*1, right child is 2\\\\*1+1. And we record those two numbers. If they are the same, the tree is complete, else we will find maxindex > tree nodes.\\n```\\nclass Solution {\\n    int num; //the number node \\n    int index; //recored the largest index \\n    //for complete tree, max index == #node \\n    public boolean isCompleteTree(TreeNode root) {\\n        dfs(root, 1);\\n        return num == index; \\n    }\\n    public void dfs(TreeNode root, int cur){\\n        if(root == null) return; //leaf node \\n        //root != null\\n        num++;\\n        index = Math.max(index, cur);\\n        dfs(root.left, 2*cur);\\n        dfs(root.right, 2*cur+1);\\n    }\\n}\\n```\\nAnother way is level order traversal. If there are any solid nodes seperated by null node, tree is not complete. Therefore,use a boolean flag to represent if there has any null nodes before. If we met null but no solid node exist after that, it\\'s still a complete tree.\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false; //if null appreared before \\n        Queue<TreeNode> queue = new LinkedList<>(); //arraydeque don\\'t allow null but linkedlist val can be null\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode cur = queue.poll();\\n            if(cur == null){\\n                flag = true;\\n            }else if(flag == true){  \\n                return false;\\n            }else{ //cur != null but flag = true; null appreared before \\n                queue.offer(cur.left);\\n                queue.offer(cur.right);      \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int num; //the number node \\n    int index; //recored the largest index \\n    //for complete tree, max index == #node \\n    public boolean isCompleteTree(TreeNode root) {\\n        dfs(root, 1);\\n        return num == index; \\n    }\\n    public void dfs(TreeNode root, int cur){\\n        if(root == null) return; //leaf node \\n        //root != null\\n        num++;\\n        index = Math.max(index, cur);\\n        dfs(root.left, 2*cur);\\n        dfs(root.right, 2*cur+1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false; //if null appreared before \\n        Queue<TreeNode> queue = new LinkedList<>(); //arraydeque don\\'t allow null but linkedlist val can be null\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode cur = queue.poll();\\n            if(cur == null){\\n                flag = true;\\n            }else if(flag == true){  \\n                return false;\\n            }else{ //cur != null but flag = true; null appreared before \\n                queue.offer(cur.left);\\n                queue.offer(cur.right);      \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307377,
                "title": "python-bfs-with-explanation",
                "content": "O(n)\\nSpace: O(n)\\nAlgorithm: Do a BFS keeping track of the positions each node should occupy. If you have a completely filled tree the last element will be equal to exactly the length of the list, otherwise it means there was a gap earlier in the construction of the list.\\n\\n```\\ndef isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        res = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, pos = q.popleft()\\n            res.append(pos)\\n            if node.left:\\n                q.append((node.left, 2 * pos))\\n            if node.right:\\n                q.append((node.right, 2 * pos + 1))\\n            \\n        return len(res) == res[-1]",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "O(n)\\nSpace: O(n)\\nAlgorithm: Do a BFS keeping track of the positions each node should occupy. If you have a completely filled tree the last element will be equal to exactly the length of the list, otherwise it means there was a gap earlier in the construction of the list.\\n\\n```\\ndef isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        res = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, pos = q.popleft()\\n            res.append(pos)\\n            if node.left:\\n                q.append((node.left, 2 * pos))\\n            if node.right:\\n                q.append((node.right, 2 * pos + 1))\\n            \\n        return len(res) == res[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 205695,
                "title": "python-bfs-level-order-easy-to-understand",
                "content": "In order to determine whether a tree is complete visually, we essentially iterate level-order from left to right. This is accomplished in practice via a breadth first search, by enqueue-ing the left child before the right.\\n\\nThe key here is to find the first node that is missing a child - this determines that we have reached the lowest level. From here on, every visited node must have no children. Another key point to see is that we can never have a lone right child without a left child - if it were a complete tree, we could have swapped these children so the right is empty instead of the left.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root: return True\\n    \\n        queue = deque()\\n        queue.append(root)\\n        end = False\\n        while queue:\\n            node = queue.popleft()\\n\\n            # should all be leaf nodes\\n            if end and (node.left or node.right): return False\\n\\n            # last level, all following nodes must be leaves\\n            if not node.right: end = True\\n\\n            # impossible to have empty left but present right\\n            elif not node.left: return False\\n\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root: return True\\n    \\n        queue = deque()\\n        queue.append(root)\\n        end = False\\n        while queue:\\n            node = queue.popleft()\\n\\n            # should all be leaf nodes\\n            if end and (node.left or node.right): return False\\n\\n            # last level, all following nodes must be leaves\\n            if not node.right: end = True\\n\\n            # impossible to have empty left but present right\\n            elif not node.left: return False\\n\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667611,
                "title": "90-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        int n;\\n        bool a = false;\\n        TreeNode* node;\\n        q.push(root);\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                node = q.front();\\n                q.pop();\\n                if(a && (node->left || node->right))return false;\\n                if(node->left){\\n                    q.push(node->left);\\n                }else{\\n                    a = true;\\n                }\\n                if(a && node->right)return false;\\n                if(node->right){\\n                    q.push(node->right);\\n                }else{\\n                    a = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        int n;\\n        bool a = false;\\n        TreeNode* node;\\n        q.push(root);\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                node = q.front();\\n                q.pop();\\n                if(a && (node->left || node->right))return false;\\n                if(node->left){\\n                    q.push(node->left);\\n                }else{\\n                    a = true;\\n                }\\n                if(a && node->right)return false;\\n                if(node->right){\\n                    q.push(node->right);\\n                }else{\\n                    a = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301367,
                "title": "java-bfs-explained",
                "content": "---\\n# Do let me know if you have any doubt! \\uD83D\\uDE07\\n*(Previous post got removed)*\\n\\n---\\n### Code:\\n```\\n// A BFS traverses in a \\'left to right\\' fashion at each level\\n// So if it sees a null, it should not see a unempty node after that null.\\n// All the unempty nodes should lie before the null, i.e. as left as possible\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        // we haven\\'t seen a null\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            // if we see a null (node is null)\\n            if (curr == null) {\\n                seenNull = true;    // mark as seen\\n            } \\n            // node is not null\\n            else {\\n                // but if a null was encountered already\\n                if (seenNull) {\\n                    return false;   // not a complete tree\\n                }\\n                // otherwise, add the children to the queue\\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        // If we never found a incompleteness within the tree,\\n        // then at the end return true\\n        return true;\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            if (curr == null) {\\n                seenNull = true; \\n            } else {\\n                if (seenNull) return false;  \\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(n)$$\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// A BFS traverses in a \\'left to right\\' fashion at each level\\n// So if it sees a null, it should not see a unempty node after that null.\\n// All the unempty nodes should lie before the null, i.e. as left as possible\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        // we haven\\'t seen a null\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            // if we see a null (node is null)\\n            if (curr == null) {\\n                seenNull = true;    // mark as seen\\n            } \\n            // node is not null\\n            else {\\n                // but if a null was encountered already\\n                if (seenNull) {\\n                    return false;   // not a complete tree\\n                }\\n                // otherwise, add the children to the queue\\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        // If we never found a incompleteness within the tree,\\n        // then at the end return true\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            if (curr == null) {\\n                seenNull = true; \\n            } else {\\n                if (seenNull) return false;  \\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300691,
                "title": "tc-100-python-solution-using-bfs-traversal",
                "content": "![image.png](https://assets.leetcode.com/users/images/f7a9a2e7-c559-4c03-bbd2-8193a998c682_1678893049.0493286.png)\\n\\n\\n# Intuition\\nUsing BFS Traversal we can search level by level.\\n\\n# Approach\\nFollow the below steps :\\n1. Traverse through Level-by-Level\\n2. To check whether the last level is filled from left to right or not.\\n3. if we found a $$NULL$$ in the queue,\\n    i.  loop through the queue, to check whether we have any elements after the $$NULL$$ or not. if so, return $$False$$\\n    ii. else append the left and right node of the current node to the queue.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque([root])\\n\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                while q:\\n                    if q.popleft():\\n                        return False\\n        \\n        return True        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque([root])\\n\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                while q:\\n                    if q.popleft():\\n                        return False\\n        \\n        return True        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300310,
                "title": "simple-java-bfs-full-explanation-faster-100",
                "content": "COMPLETE BINARY TREE MEANS IT SHOULD HAVE NODE AT EACH LEVEL WHERE NO OF NODES EQUAL TO 2^LEVEL(WHERE LEVEL START FROM ZERO). BUT AT LAST LEVEL IT CAN HAVE ANY NUMBER BUT FROM LEFT TO RIGHT.\\n\\nSO WE CAN THINK THAT EXCEPT LAST LEVEL UPPER EVERY LEVEL WOULD BE FULL AND IT WILL NOT CONTAIN ANY NULL VALUE IF IT CONTAINS THEN IT NOT A COMPLETE BINARY TREE.\\n\\nNOW LET\\'S LOOK FOR LAST LEVEL. IT CONSIST OF TWO CASES  1) ALL ARE ON LEFT SIDE THEN RETURN TRUE\\nELSE \\nCASE 2) THERE MUS BE A NODE WHERE WHICH IS VIOLATING THE CONDITION i.e.(all nodes from left to right must be filled).SO IN THIS CASE DEFINITELY OUR QUEUE WILL NOT BE EMPTY AND WE WILL ENCOUNTER A NULL AND QUEUE PEEK WILL BE HAVING AN ELEMENT.SO RETURN FALSE.\\n\\n\\n\\n```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int lev=0;\\n        int count=0;\\n        while(q.isEmpty()==false)\\n        {\\n            \\n           TreeNode node=q.remove();\\n            \\n            if(node==null&&q.peek()!=null)return false;\\n            \\n             if(node!=null)\\n             {\\n              q.add(node.left);\\n              q.add(node.right);\\n             }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int lev=0;\\n        int count=0;\\n        while(q.isEmpty()==false)\\n        {\\n            \\n           TreeNode node=q.remove();\\n            \\n            if(node==null&&q.peek()!=null)return false;\\n            \\n             if(node!=null)\\n             {\\n              q.add(node.left);\\n              q.add(node.right);\\n             }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299863,
                "title": "c-solution-100-faster-beginner-friendly-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> __In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.\\nThe idea is to store every level and check every node in the current level for a left and right child__\\n\\n\\n# Approach\\n1. Using BFS store each level in a queue\\n2. For every parent there must be two children except the last nodes parent, it can have only one child or no children\\n3. Some conditions to keep in mind:\\n- The left child has to be there if a node has children nodes\\n- only the last node in the second-last level can have 0 or 1 child nodes, other than that all must have 2 child nodes , except the leaf nodes(the nodes where the tree path ends).\\n- If some right child of a node from a level is absent, it has to be the last node of the second-last level for the tree .\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution // 100% faster\\n{\\npublic:\\n    bool isCompleteTree(TreeNode *root)\\n    {\\n        queue<TreeNode *> q; // Create a queue to store the nodes\\n        q.push(root);        // Push the root node\\n        int right_child = 1; // Initially Assume that both the left and right child nodes exist\\n        do\\n        {\\n            int x = q.size(); // Get the size of the queue\\n            for (int i = 0; i < x; i++)\\n            {\\n                TreeNode *parent = q.front(); // Store the parent node\\n                q.pop();                      // Pop it from the queue\\n                int left_child = 1;           // Assume that the left child exists\\n                if (parent->left)             // If the left child actually exists\\n                {\\n                    // If previously some right child was absent\\n                    // Return false,\\n                    // Only the last node (right most) of the last level can be a absent\\n                    // And if some right child from a level is absent,\\n                    // It has to be the last level for the tree to be complete\\n                    // Otherwise the tree is not complete!\\n                    if (!right_child)\\n                        return false;\\n                    q.push(parent->left); // Push the left child into the queue\\n                }\\n                else\\n                    // Set the left_child as 0\\n                    // For a tree to be complete, if a left child is absent\\n                    // No other nodes should have any children\\n                    left_child = 0;\\n                if (parent->right) // If the right child exists\\n                {\\n                    // Check if its sibling node was not absent\\n                    // If a sibling node of the right child is absent\\n                    // The tree is not complete,\\n                    // Hence false should be returned\\n                    if (!left_child)\\n                        return false;\\n                    // If the sibling exists, push the right child into the queue\\n                    q.push(parent->right);\\n                }\\n                else\\n                    // If the right child is absent\\n                    // Set the right_child as 0\\n                    right_child = 0;\\n            }\\n        } while (!q.empty());\\n        // If no anomalies exist, return true\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution // 100% faster\\n{\\npublic:\\n    bool isCompleteTree(TreeNode *root)\\n    {\\n        queue<TreeNode *> q; // Create a queue to store the nodes\\n        q.push(root);        // Push the root node\\n        int right_child = 1; // Initially Assume that both the left and right child nodes exist\\n        do\\n        {\\n            int x = q.size(); // Get the size of the queue\\n            for (int i = 0; i < x; i++)\\n            {\\n                TreeNode *parent = q.front(); // Store the parent node\\n                q.pop();                      // Pop it from the queue\\n                int left_child = 1;           // Assume that the left child exists\\n                if (parent->left)             // If the left child actually exists\\n                {\\n                    // If previously some right child was absent\\n                    // Return false,\\n                    // Only the last node (right most) of the last level can be a absent\\n                    // And if some right child from a level is absent,\\n                    // It has to be the last level for the tree to be complete\\n                    // Otherwise the tree is not complete!\\n                    if (!right_child)\\n                        return false;\\n                    q.push(parent->left); // Push the left child into the queue\\n                }\\n                else\\n                    // Set the left_child as 0\\n                    // For a tree to be complete, if a left child is absent\\n                    // No other nodes should have any children\\n                    left_child = 0;\\n                if (parent->right) // If the right child exists\\n                {\\n                    // Check if its sibling node was not absent\\n                    // If a sibling node of the right child is absent\\n                    // The tree is not complete,\\n                    // Hence false should be returned\\n                    if (!left_child)\\n                        return false;\\n                    // If the sibling exists, push the right child into the queue\\n                    q.push(parent->right);\\n                }\\n                else\\n                    // If the right child is absent\\n                    // Set the right_child as 0\\n                    right_child = 0;\\n            }\\n        } while (!q.empty());\\n        // If no anomalies exist, return true\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299586,
                "title": "level-order-traversal-using-bfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do a level order traversal using BFS and if you find there is any NULL value between two elements in a level return false.\\n***SUPERR EASY!***\\n\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)+O(N)=O(N+2)+O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)+O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        ans.push_back(root);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp=q.front();q.pop();\\n            if(temp==NULL)continue;\\n            q.push(temp->left);\\n            ans.push_back(temp->left);\\n            q.push(temp->right);\\n            ans.push_back(temp->right);\\n        }\\n        int i=0;int lock=0;\\n        while(i<ans.size()){\\n            if(ans[i]==NULL)lock=1;\\n            else if(lock==1)return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n***UPVOTE PLEASE IF THIS WAS HELPFUL***",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        ans.push_back(root);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp=q.front();q.pop();\\n            if(temp==NULL)continue;\\n            q.push(temp->left);\\n            ans.push_back(temp->left);\\n            q.push(temp->right);\\n            ans.push_back(temp->right);\\n        }\\n        int i=0;int lock=0;\\n        while(i<ans.size()){\\n            if(ans[i]==NULL)lock=1;\\n            else if(lock==1)return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299390,
                "title": "99-faster-python-solution-dfs-easy-and-short-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNodes can be numbered levelwise and if it can be done correctly, a perfect binary tree would have all the node id\\'s in sequence\\n\\nLet\\'s say the tree should look like this:-\\n```\\n        1\\n     /     \\\\\\n    2        3\\n /    \\\\    /    \\\\\\n4      5  6       7\\n```\\nNotice that parent.left\\'s id is always 2\\\\*parent\\'s id and parent.right\\'s id is always 2\\\\*parent+1\\n\\nIn this way we can identify all the nodes sequentially. Even more, each level basically contains all the numbers of 2^LVL. i.e: 0th level has 2^0=1 node, 1st level has 2^1=2 nodes and 2nd level has 2^2=4 nodes.\\n\\nSo, if any of them goes out of sequence it only means there\\'s an intermediate left or right child that\\'s missing and making the tree incomplete. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate in the mentioned approach and number the node id\\'s accordingly and finally check if all the numbers are sequential.\\n\\nif node.id = 1\\nnode.left.id = 1\\\\*2 = 2\\nnode.right.id = 1\\\\*2+1 = 3\\n\\nWe always endup having unique numbers in this way, so after numbering them all we can just check if max(id) == count(nodes)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        node_ids = []\\n        def iterate(root, id = 1):\\n            if not root: return\\n            node_ids.append(id)\\n            iterate(root.left, id<<1)\\n            iterate(root.right, id<<1|1)\\n        \\n        iterate(root)\\n        return max(node_ids) == len(node_ids)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n        1\\n     /     \\\\\\n    2        3\\n /    \\\\    /    \\\\\\n4      5  6       7\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        node_ids = []\\n        def iterate(root, id = 1):\\n            if not root: return\\n            node_ids.append(id)\\n            iterate(root.left, id<<1)\\n            iterate(root.right, id<<1|1)\\n        \\n        iterate(root)\\n        return max(node_ids) == len(node_ids)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299314,
                "title": "rust-bfs-solution",
                "content": "So Approach is very simple. We are making bfs left - right for every level. When we found first None, all others nodes must be also None\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deq = VecDeque::from([root]);\\n        let mut is_none = false;\\n        while let Some(node) = deq.pop_front() {\\n            match node {\\n                Some(node) =>  {\\n                    if is_none {\\n                        return false\\n                    }\\n                    let node = node.borrow();\\n                    deq.push_back(node.left.clone());\\n                    deq.push_back(node.right.clone());\\n                },\\n                None =>  {\\n                    is_none = true;\\n                },\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deq = VecDeque::from([root]);\\n        let mut is_none = false;\\n        while let Some(node) = deq.pop_front() {\\n            match node {\\n                Some(node) =>  {\\n                    if is_none {\\n                        return false\\n                    }\\n                    let node = node.borrow();\\n                    deq.push_back(node.left.clone());\\n                    deq.push_back(node.right.clone());\\n                },\\n                None =>  {\\n                    is_none = true;\\n                },\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299052,
                "title": "simple-bfs-queue-o-n-approach-with-explanation",
                "content": "# **Simple BFS Approach!!**\\nAuthor:- Yash Gaherwar\\n# Approach\\nStandard BFS (Breadth First Search Approach)\\n1. Approach is to maintain one flag variable and check whether we encountered any NULL value or not.\\n2. If we encounter any NULL value then we set flag as true.\\n3. Suppose if after that we encounter any value other than NULL. Then this means that the tree is not complete and hence we return false.\\n4. It means that the all the leaf nodes are not left alignd. Hence answer is false otherwise simply return true.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        int flag=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(q.size()>0){\\n            TreeNode* nd=q.front();\\n            q.pop();\\n\\n            // If first NULL is encounter then set flag as 1\\n            if(nd==NULL){\\n                flag=1;\\n            }\\n            else{\\n            // If already in past we encounter NULL this means that tree is not Complete Binary Tree\\n                if(flag==1){\\n                    return false;\\n                }\\n\\n                q.push(nd->left);\\n                q.push(nd->right);\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        int flag=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(q.size()>0){\\n            TreeNode* nd=q.front();\\n            q.pop();\\n\\n            // If first NULL is encounter then set flag as 1\\n            if(nd==NULL){\\n                flag=1;\\n            }\\n            else{\\n            // If already in past we encounter NULL this means that tree is not Complete Binary Tree\\n                if(flag==1){\\n                    return false;\\n                }\\n\\n                q.push(nd->left);\\n                q.push(nd->right);\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298614,
                "title": "java-bfs-beats-80",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isCompleteTree(TreeNode root) {\\n    var flag = false;\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    while(!queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (node.left == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.left);\\n        \\n        if (node.right == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.right);\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isCompleteTree(TreeNode root) {\\n    var flag = false;\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    while(!queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (node.left == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.left);\\n        \\n        if (node.right == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.right);\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298601,
                "title": "easy-intuitive-approach-c-dfs",
                "content": "### Please upvote this post if it helps you\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA complete binary tree is one in which all levels are completely filled, with the exception of the bottom-most level, which is filled from left to right. This means that in a complete binary tree, all nodes are located as far to the left as possible, and the tree\\'s bottom level is filled from left to right.\\n\\nTo begin, the programme defines two helper functions: countNodes and isCBT.\\n\\n```countNodes``` returns the total number of nodes in the tree by recursively counting the number of nodes in each node\\'s left and right subtrees.\\n\\n```isCBT``` is the primary function that determines whether the binary tree is complete or not. It takes three arguments: \\n```(int i, TreeNode* root, int n) ```\\nIt recursively checks whether each node in the binary tree is within the bounds of a complete binary tree by traversing each node\\'s left and right subtrees. If a node is found that is outside the bounds, the function returns false, indicating that the binary tree is not complete. Otherwise, if all nodes are within the bounds, the function returns true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(h)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root){\\n        if(root == NULL)    return 0;\\n        return countNodes(root->left)+countNodes(root->right)+1;\\n    }\\n\\n    bool isCBT(int i, TreeNode* root, int n){\\n        if(root == NULL)\\n            return true;\\n        if(i >= n)\\n            return false;\\n        else{\\n            bool left = isCBT(2*i+1, root->left, n);\\n            bool right = isCBT(2*i+2, root->right, n);\\n            return (left && right);\\n        }\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = countNodes(root);\\n        return isCBT(0, root, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```countNodes```\n```isCBT```\n```(int i, TreeNode* root, int n) ```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root){\\n        if(root == NULL)    return 0;\\n        return countNodes(root->left)+countNodes(root->right)+1;\\n    }\\n\\n    bool isCBT(int i, TreeNode* root, int n){\\n        if(root == NULL)\\n            return true;\\n        if(i >= n)\\n            return false;\\n        else{\\n            bool left = isCBT(2*i+1, root->left, n);\\n            bool right = isCBT(2*i+2, root->right, n);\\n            return (left && right);\\n        }\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = countNodes(root);\\n        return isCBT(0, root, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298543,
                "title": "python-c-c-simple-and-fast-bonus-true-non-clickbait-o-1-space-solution",
                "content": "# Intuition\\nIf we know the depth of the left most branch, we know that the depth can never be more than this.\\n\\nIt can be one less than this, but once it is less, it must stay 1 less.\\n\\n# Approach\\n- Get the depth of the left most branch\\n- Call a recursive function that will try each branch and ensure it matches the target depth from above\\n- If a leaf depth is less than `target_depth` and we haven\\'t done so already, decrease `target_depth` by 1.\\n- Check if each leaf depth equals `target_depth`\\n\\nA minor improvement could be made such that early termination could be done as soon as the depth is over `target_depth`, that is, before reaching a node. I don\\'t think this is worth doing as waiting to reach the leaf is not much extra time, but doing the early bail would require an extra compare for each node. \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(h) (where _h_ is the height of the tree)\\n\\nEach node must be visited, so time is O(n)\\n\\nNeed to recurse upto the height of the tree, so need stack space based on the height. This will be O(logn) if the tree is roughly balanced, but could be O(n) if it\\'s completely unbalanced.\\n\\n**Since python doesn\\'t (really) support pass by reference, I solved it iteratively, using `todo` as a stack to allow for updating `used` and `target`.**\\n\\nThe problem could be done in O(1) space using a Morris Traversal. ~~I might look at adding that later.~~ Added a Morris Traversal solution.\\n\\n# Code\\n```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  todo = [[root, 0]]\\n  used = False\\n  while todo:\\n    node, depth = todo[-1]\\n    todo.pop()\\n    if not node:\\n      # Reduce the target depth now if we\\'re under and have not done it yet\\n      if not used and depth < target:\\n        used = True\\n        target -= 1\\n      if depth != target:\\n        return False\\n    else :\\n      # Add to the stack right first so that left must get processed before right\\n      todo.append([node.right, depth + 1])\\n      todo.append([node.left, depth + 1])\\n  return True\\n```\\n```c []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int* target_depth, bool* used) {\\n  if (!root) {\\n    /* Reduce the target depth now if we\\'re under and have not done it yet */\\n    if (!*used && curr_depth < *target_depth) {\\n      *used = true;\\n      --*target_depth;\\n    }\\n    return (curr_depth == *target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(struct TreeNode* root){\\n  bool used = false;\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int depth = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, &depth, &used);\\n}\\n```\\n```cpp []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int& target_depth, bool& used) {\\n  if (!root) {\\n    // Reduce the target depth now if we\\'re under and have not done it yet\\n    if (!used && curr_depth < target_depth) {\\n      used = true;\\n      --target_depth;\\n    }\\n    return (curr_depth == target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(TreeNode* root) {\\n  bool used = false;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  int depth = 0;\\n  for (auto* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, depth, used);\\n}\\n```\\n# Morris Traversal, O(n) Time, O(1) Space\\nJust for fun, and since others were clickbaiting with \"constant space\" solutions that weren\\'t, I decided to do an actual constant space solution.\\n\\nThe solutions is more complex, but uses an algorithm called a Morris Traversal. I won\\'t go into too much detail, but it relies on borrowing the NULL right branch to create a link back up the tree to the parent. Each time I have to move back up the tree, I need to remove the temporary link on the right branch and set it back to NULL. The fact that the right branch is modified means the entire tree must be processed before returning our result, otherwise the tree will not be restored.\\n\\nOther than using Morris Traversal, the solution is based on the same idea as the above.\\n\\n```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  used = False\\n\\n  def helper(depth: int) -> bool:\\n    nonlocal target\\n    nonlocal used\\n    # Reduce the target depth now if we\\'re under and have not done it yet\\n    if not used and depth < target: \\n      used = True\\n      target -= 1\\n    return depth == target    \\n\\n  # Use a Moris Traversal to process check the depth of the leaf nodes\\n  ret = True;\\n  depth = 1;\\n  while root:\\n    if not root.left:\\n      # Reached an empty left branch, check it\\'s valid\\n      ret = ret and helper(depth)\\n      root = root.right\\n      depth += 1\\n    else:        \\n      pre = root.left\\n      steps = 1\\n      while pre.right != root and pre.right:\\n        steps += 1\\n        pre = pre.right;\\n\\n      if pre.right != root:\\n        # First time visiting root, set a temp link back to the root\\n        pre.right = root\\n        root = root.left\\n        depth += 1\\n      else:\\n        # Second time visiting root, check the right most of the left branch \\n        ret = ret and helper(depth - 1)\\n        # Taking our temp link will reduce our depth\\n        depth -= steps\\n        # Remove temp link\\n        pre.right = None\\n        root = root.right\\n\\n  # Need one final check to check the right most branch. The depth will be over incremented\\n  return ret and helper(depth - 1)\\n```\\n```c []\\nstatic\\nbool is_complete_tree_helper(int depth, int* target, bool* used) {\\n  /* Reduce the target depth now if we\\'re under and have not done it yet */\\n  if (!*used && depth < *target) {\\n    *used = true;\\n    --*target;\\n  }\\n  return (depth == *target);\\n}\\n\\nbool isCompleteTree(struct TreeNode* root) {\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int target = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  /* Use a Moris Traversal to process check the depth of the leaf nodes */\\n  int ret = true;\\n  bool used = false;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      struct TreeNode* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        /* First time visiting root, set a temp link back to the root */\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        /* Second time visiting root, check the right most of the left branch */\\n        ret &= is_complete_tree_helper(depth - 1, &target, &used);\\n        /* Taking our temp link will reduce our depth */\\n        depth -= steps;\\n        /* Remove temp link */\\n        pre->right = NULL;\\n        root = root->right;\\n      }\\n    } else {\\n      /* Reached an empty left branch, check it\\'s valid */\\n      ret &= is_complete_tree_helper(depth, &target, &used);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  /* Need one final check to check the right most branch. The depth will be over incremented */\\n  return ret && is_complete_tree_helper(depth - 1, &target, &used);\\n}\\n```\\n```cpp []\\nbool isCompleteTree(TreeNode* root) {\\n  int target = 0;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  for (auto* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  bool used = false;\\n  auto helper = [&used, &target] (int depth) -> bool {\\n      // Reduce the target depth now if we\\'re under and have not done it yet\\n      if (!used && depth < target) {\\n        used = true;\\n        --target;\\n      }\\n      return (depth == target);    \\n    };\\n\\n  // Use a Moris Traversal to process check the depth of the leaf nodes\\n  int ret = true;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      auto* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        // First time visiting root, set a temp link back to the root\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        // Second time visiting root, check the right most of the left branch \\n        ret &= helper(depth - 1);\\n        // Taking our temp link will reduce our depth\\n        depth -= steps;\\n        // Remove temp link\\n        pre->right = nullptr;\\n        root = root->right;\\n      }\\n    } else {\\n      // Reached an empty left branch, check it\\'s valid\\n      ret &= helper(depth);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  // Need one final check to check the right most branch. The depth will be over incremented\\n  return ret && helper(depth - 1);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  todo = [[root, 0]]\\n  used = False\\n  while todo:\\n    node, depth = todo[-1]\\n    todo.pop()\\n    if not node:\\n      # Reduce the target depth now if we\\'re under and have not done it yet\\n      if not used and depth < target:\\n        used = True\\n        target -= 1\\n      if depth != target:\\n        return False\\n    else :\\n      # Add to the stack right first so that left must get processed before right\\n      todo.append([node.right, depth + 1])\\n      todo.append([node.left, depth + 1])\\n  return True\\n```\n```c []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int* target_depth, bool* used) {\\n  if (!root) {\\n    /* Reduce the target depth now if we\\'re under and have not done it yet */\\n    if (!*used && curr_depth < *target_depth) {\\n      *used = true;\\n      --*target_depth;\\n    }\\n    return (curr_depth == *target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(struct TreeNode* root){\\n  bool used = false;\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int depth = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, &depth, &used);\\n}\\n```\n```cpp []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int& target_depth, bool& used) {\\n  if (!root) {\\n    // Reduce the target depth now if we\\'re under and have not done it yet\\n    if (!used && curr_depth < target_depth) {\\n      used = true;\\n      --target_depth;\\n    }\\n    return (curr_depth == target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(TreeNode* root) {\\n  bool used = false;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  int depth = 0;\\n  for (auto* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, depth, used);\\n}\\n```\n```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  used = False\\n\\n  def helper(depth: int) -> bool:\\n    nonlocal target\\n    nonlocal used\\n    # Reduce the target depth now if we\\'re under and have not done it yet\\n    if not used and depth < target: \\n      used = True\\n      target -= 1\\n    return depth == target    \\n\\n  # Use a Moris Traversal to process check the depth of the leaf nodes\\n  ret = True;\\n  depth = 1;\\n  while root:\\n    if not root.left:\\n      # Reached an empty left branch, check it\\'s valid\\n      ret = ret and helper(depth)\\n      root = root.right\\n      depth += 1\\n    else:        \\n      pre = root.left\\n      steps = 1\\n      while pre.right != root and pre.right:\\n        steps += 1\\n        pre = pre.right;\\n\\n      if pre.right != root:\\n        # First time visiting root, set a temp link back to the root\\n        pre.right = root\\n        root = root.left\\n        depth += 1\\n      else:\\n        # Second time visiting root, check the right most of the left branch \\n        ret = ret and helper(depth - 1)\\n        # Taking our temp link will reduce our depth\\n        depth -= steps\\n        # Remove temp link\\n        pre.right = None\\n        root = root.right\\n\\n  # Need one final check to check the right most branch. The depth will be over incremented\\n  return ret and helper(depth - 1)\\n```\n```c []\\nstatic\\nbool is_complete_tree_helper(int depth, int* target, bool* used) {\\n  /* Reduce the target depth now if we\\'re under and have not done it yet */\\n  if (!*used && depth < *target) {\\n    *used = true;\\n    --*target;\\n  }\\n  return (depth == *target);\\n}\\n\\nbool isCompleteTree(struct TreeNode* root) {\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int target = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  /* Use a Moris Traversal to process check the depth of the leaf nodes */\\n  int ret = true;\\n  bool used = false;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      struct TreeNode* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        /* First time visiting root, set a temp link back to the root */\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        /* Second time visiting root, check the right most of the left branch */\\n        ret &= is_complete_tree_helper(depth - 1, &target, &used);\\n        /* Taking our temp link will reduce our depth */\\n        depth -= steps;\\n        /* Remove temp link */\\n        pre->right = NULL;\\n        root = root->right;\\n      }\\n    } else {\\n      /* Reached an empty left branch, check it\\'s valid */\\n      ret &= is_complete_tree_helper(depth, &target, &used);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  /* Need one final check to check the right most branch. The depth will be over incremented */\\n  return ret && is_complete_tree_helper(depth - 1, &target, &used);\\n}\\n```\n```cpp []\\nbool isCompleteTree(TreeNode* root) {\\n  int target = 0;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  for (auto* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  bool used = false;\\n  auto helper = [&used, &target] (int depth) -> bool {\\n      // Reduce the target depth now if we\\'re under and have not done it yet\\n      if (!used && depth < target) {\\n        used = true;\\n        --target;\\n      }\\n      return (depth == target);    \\n    };\\n\\n  // Use a Moris Traversal to process check the depth of the leaf nodes\\n  int ret = true;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      auto* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        // First time visiting root, set a temp link back to the root\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        // Second time visiting root, check the right most of the left branch \\n        ret &= helper(depth - 1);\\n        // Taking our temp link will reduce our depth\\n        depth -= steps;\\n        // Remove temp link\\n        pre->right = nullptr;\\n        root = root->right;\\n      }\\n    } else {\\n      // Reached an empty left branch, check it\\'s valid\\n      ret &= helper(depth);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  // Need one final check to check the right most branch. The depth will be over incremented\\n  return ret && helper(depth - 1);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3298514,
                "title": "c-bfs-easiest-solution-beats-96",
                "content": "# Intuition\\nIn breadth first search, a complete tree will have no non-null nodes after the first one.\\n\\n# Approach\\nAdd all nodes and their children to the bfs queue. When we dequeue the first null node, check if anything left in queue is non-null. If there are, we don\\'t have a complete tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> bfs = new Queue<TreeNode>();\\n        bfs.Enqueue(root);\\n\\n        while (bfs.Any())\\n        {\\n            var node = bfs.Dequeue();\\n\\n            if (node == null)\\n                return !bfs.Any(x => x != null);\\n\\n            bfs.Enqueue(node.left);\\n            bfs.Enqueue(node.right);                    \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> bfs = new Queue<TreeNode>();\\n        bfs.Enqueue(root);\\n\\n        while (bfs.Any())\\n        {\\n            var node = bfs.Dequeue();\\n\\n            if (node == null)\\n                return !bfs.Any(x => x != null);\\n\\n            bfs.Enqueue(node.left);\\n            bfs.Enqueue(node.right);                    \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298199,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt refers to the instinctive understanding of something, based on our past experience, knowledge, and common sense. In algorithm design, intuition helps us come up with ideas and insights on how to solve a problem efficiently.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to traverse the binary tree level by level using a queue. Starting with the root node, we add it to the queue and keep track of whether we have encountered any null nodes. We then continue dequeuing nodes from the queue and add their children to the queue. If we encounter a null node and we have not previously encountered one, we set a flag indicating that we have reached the end of the complete binary tree. If we encounter a non-null node after the flag has been set, we know that the binary tree is not complete.\\n\\nAt the end of the traversal, if we have not encountered any such scenario, we know that the binary tree is complete.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is $$O(n)$$ where n is the number of nodes in the binary tree. \\n- Space complexity:\\nThe space complexity is $$O(n)$$ since we are using a queue to store the nodes.\\n\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        boolean end = false;\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n            if (curr == null) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                queue.offer(curr.left);\\n                queue.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution(object):\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        \\n        q = deque([root])\\n        end = False\\n        \\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n        \\n        return True\\n\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        boolean end = false;\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n            if (curr == null) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                queue.offer(curr.left);\\n                queue.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution(object):\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        \\n        q = deque([root])\\n        end = False\\n        \\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n        \\n        return True\\n\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517490,
                "title": "bfs-does-magic-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n       \\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool flg=true;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n                        \\n            for(int i=0;i<n;i++){\\n                auto ele=q.front();\\n                q.pop();\\n                \\n                if(!ele){\\n                    flg=false;\\n                }\\n                \\n                else{\\n                    if(!flg)return false;\\n                    \\n                    q.push(ele->left);\\n                    q.push(ele->right);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n       \\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool flg=true;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n                        \\n            for(int i=0;i<n;i++){\\n                auto ele=q.front();\\n                q.pop();\\n                \\n                if(!ele){\\n                    flg=false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2068637,
                "title": "java-bfs-solution-1ms-90-beat",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861337,
                "title": "basic-level-order-traversal-c-for-beginners",
                "content": "Straight forward approach, return false, if a node has a right child but no left child, or the node doesnt have a right child but the next node has children/child.\\nOtherwise, after full traversal return true.\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* top = q.front();\\n            q.pop();\\n            if(top->left) q.push(top->left);\\n            if(top->right) q.push(top->right);\\n            if(!top->left and top->right or !top->right and !q.empty() and q.front()->left) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nTrue, not the most brilliant solution, but intuitive, comes to mind easily and a good enough approach for a beginner to start somewhere.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* top = q.front();\\n            q.pop();\\n            if(top->left) q.push(top->left);\\n            if(top->right) q.push(top->right);\\n            if(!top->left and top->right or !top->right and !q.empty() and q.front()->left) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799961,
                "title": "python-learned-from-nickwhite",
                "content": "Have to say, very clear when I listen to this guy explanation... I don\\'t know why  \\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        end = False\\n        while queue:\\n            node = queue.pop(0)\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                queue.append(node.left)\\n                queue.append(node.right)\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Have to say, very clear when I listen to this guy explanation... I don\\'t know why  \\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        end = False\\n        while queue:\\n            node = queue.pop(0)\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                queue.append(node.left)\\n                queue.append(node.right)\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1663015,
                "title": "swift-bfs",
                "content": "If the binary tree is complete, then the BFS queue will have either a suffix of null values or be empty. \\n\\n```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return true\\n        }\\n        \\n        var queue = [TreeNode?]()\\n        queue.append(root)\\n        \\n        while !queue.isEmpty {\\n            if let node = queue.removeFirst() {\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            } else {\\n                for node in queue where node != nil {\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return true\\n        }\\n        \\n        var queue = [TreeNode?]()\\n        queue.append(root)\\n        \\n        while !queue.isEmpty {\\n            if let node = queue.removeFirst() {\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            } else {\\n                for node in queue where node != nil {\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332230,
                "title": "c-labelling-5-line-dfs-code-concise-with-picture",
                "content": "\\n![image](https://assets.leetcode.com/users/images/b605af63-4931-4196-bca0-dd0994ec9e5d_1626061963.8985775.gif)\\n\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    unsigned long long int sum , count = 0;\\n\\n    void dfs(TreeNode* root,unsigned long long int label){\\n        if(!root)\\n            return;\\n        ++count;\\n        sum += label;\\n        dfs(root->left,2*label);\\n        dfs(root->right,2*label+1);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        dfs(root,1);       \\n        return (count*(count+1)/2 == sum);\\n    }\\n};\\n```\\n\\n\\nLabel root node as 1 , left node as 2*i and right node as 2*i+1\\nLet count denote the total nodes in the binary tree \\nAfter labelling , just check if count*(count+1)/2 == sum of labels \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    unsigned long long int sum , count = 0;\\n\\n    void dfs(TreeNode* root,unsigned long long int label){\\n        if(!root)\\n            return;\\n        ++count;\\n        sum += label;\\n        dfs(root->left,2*label);\\n        dfs(root->right,2*label+1);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        dfs(root,1);       \\n        return (count*(count+1)/2 == sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267640,
                "title": "java-level-order-iterative-solution-one-loop-solution-bfs",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        boolean last=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        \\n        while(q.size()>0){\\n            TreeNode temp=q.poll();\\n            \\n            if(temp==null) last=true;\\n            else{\\n                if(last==true) return false;\\n                    q.add(temp.left);\\n                    q.add(temp.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        boolean last=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        \\n        while(q.size()>0){\\n            TreeNode temp=q.poll();\\n            \\n            if(temp==null) last=true;\\n            else{\\n                if(last==true) return false;\\n                    q.add(temp.left);\\n                    q.add(temp.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948557,
                "title": "java-simple-dfs-approach-beats-100",
                "content": "```\\nclass Solution {\\n    boolean check = false;\\n    public boolean isCompleteTree(TreeNode root) {\\n        int h = height(root);\\n        return helper(root, h, 1);\\n    }\\n    \\n    public boolean helper(TreeNode root, int h, int depth){\\n        if(root == null){\\n            if(depth < h) return false;\\n            if(depth > h) return true;\\n            if(depth == h && !check) check = true;\\n            return true;\\n        }\\n        else if(depth == h && check) return false;\\n        return helper(root.left, h, depth + 1) && helper(root.right, h, depth + 1);\\n        \\n    }\\n    \\n    public int height(TreeNode root){\\n        if(root == null) return 0;\\n        else return 1 + Math.max(height(root.left), height(root.right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean check = false;\\n    public boolean isCompleteTree(TreeNode root) {\\n        int h = height(root);\\n        return helper(root, h, 1);\\n    }\\n    \\n    public boolean helper(TreeNode root, int h, int depth){\\n        if(root == null){\\n            if(depth < h) return false;\\n            if(depth > h) return true;\\n            if(depth == h && !check) check = true;\\n            return true;\\n        }\\n        else if(depth == h && check) return false;\\n        return helper(root.left, h, depth + 1) && helper(root.right, h, depth + 1);\\n        \\n    }\\n    \\n    public int height(TreeNode root){\\n        if(root == null) return 0;\\n        else return 1 + Math.max(height(root.left), height(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929980,
                "title": "c-short-level-order-traversal-solution",
                "content": "Idea is that by level order traversal, the nodes should form a contiguous sequence. So we just run a level-order traversal and check that once we hit a \"nullptr\" node, we will not hit any real nodes later. \\n\\nRun-time is `O(N)`, space is `O(N)`.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        std::queue<TreeNode*> q;\\n        TreeNode *last{root};\\n        q.emplace(root);\\n        while(!q.empty()) {\\n            TreeNode *cur{q.front()}; q.pop();\\n            if(!last && cur) return false;\\n            if(cur) q.emplace(cur->left), q.emplace(cur->right);\\n            last = cur;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        std::queue<TreeNode*> q;\\n        TreeNode *last{root};\\n        q.emplace(root);\\n        while(!q.empty()) {\\n            TreeNode *cur{q.front()}; q.pop();\\n            if(!last && cur) return false;\\n            if(cur) q.emplace(cur->left), q.emplace(cur->right);\\n            last = cur;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907914,
                "title": "c-solution",
                "content": "```\\n    public bool IsCompleteTree(TreeNode root) {\\n        var q=new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Any())\\n        {\\n            var cur=q.Dequeue();\\n            if(cur==null)\\n                break;\\n            q.Enqueue(cur.left);\\n            q.Enqueue(cur.right);\\n        }\\n        while(q.Any())\\n        {\\n            if(q.Dequeue()!=null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool IsCompleteTree(TreeNode root) {\\n        var q=new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Any())\\n        {\\n            var cur=q.Dequeue();\\n            if(cur==null)\\n                break;\\n            q.Enqueue(cur.left);\\n            q.Enqueue(cur.right);\\n        }\\n        while(q.Any())\\n        {\\n            if(q.Dequeue()!=null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830686,
                "title": "c-bfs-fast-self-explanatory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        bool flag = 0;\\n        deque<TreeNode*> q{root};\\n        while(!q.empty()) {\\n            TreeNode* cur = q.front();\\n            q.pop_front();\\n            if(!cur)\\n                flag = 1;\\n            else {\\n                if(flag)\\n                    return false;\\n                q.push_back(cur->left);\\n                q.push_back(cur->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        bool flag = 0;\\n        deque<TreeNode*> q{root};\\n        while(!q.empty()) {\\n            TreeNode* cur = q.front();\\n            q.pop_front();\\n            if(!cur)\\n                flag = 1;\\n            else {\\n                if(flag)\\n                    return false;\\n                q.push_back(cur->left);\\n                q.push_back(cur->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754079,
                "title": "java-bfs-1ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        boolean hitEnd = false; // this will mark the first incomplete row to ensure we don\\'t go passed it\\n        \\n        while (!q.isEmpty()) {\\n            \\n            int len = q.size();\\n            \\n            while (len > 0) {\\n                TreeNode curr = q.poll();\\n                \\n                // another node in this line was incomplete\\n                if (hitEnd && (curr.left != null || curr.right != null))\\n                    return false;\\n                \\n                // can\\'t have a right without a left\\n                if (curr.right != null && curr.left == null)\\n                    return false;\\n                else if (curr.left != null && curr.right == null) {\\n                    q.offer(curr.left);\\n                    hitEnd = true;\\n                } else if (curr.left != null && curr.right != null) {\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                } else { // both left and right null\\n                    hitEnd = true;\\n                }\\n                   \\n                len--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        boolean hitEnd = false; // this will mark the first incomplete row to ensure we don\\'t go passed it\\n        \\n        while (!q.isEmpty()) {\\n            \\n            int len = q.size();\\n            \\n            while (len > 0) {\\n                TreeNode curr = q.poll();\\n                \\n                // another node in this line was incomplete\\n                if (hitEnd && (curr.left != null || curr.right != null))\\n                    return false;\\n                \\n                // can\\'t have a right without a left\\n                if (curr.right != null && curr.left == null)\\n                    return false;\\n                else if (curr.left != null && curr.right == null) {\\n                    q.offer(curr.left);\\n                    hitEnd = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 440320,
                "title": "cookie-cutter-bfs-approach-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while(queue.peek() != null) {\\n            TreeNode current = queue.poll();\\n            queue.add(current.left);\\n            queue.add(current.right);\\n        }       \\n        //all values in queue must be null for it to be complete bt\\n        while(queue.size() > 0 && queue.peek() == null)\\n            queue.poll();\\n        return queue.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while(queue.peek() != null) {\\n            TreeNode current = queue.poll();\\n            queue.add(current.left);\\n            queue.add(current.right);\\n        }       \\n        //all values in queue must be null for it to be complete bt\\n        while(queue.size() > 0 && queue.peek() == null)\\n            queue.poll();\\n        return queue.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366228,
                "title": "fast-and-easy-solution-beats-97-8-using-queue-python",
                "content": "\\timport collections\\n\\n\\tclass Solution(object):\\n\\t\\tdef isCompleteTree(self, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not root: return True\\n\\n\\t\\t\\tqueue = collections.deque()\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\tflag = False\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurr = queue.popleft()\\n\\t\\t\\t\\tif curr is None:\\n\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif flag is True:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tqueue.append(curr.left)\\n\\t\\t\\t\\t\\tqueue.append(curr.right)\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\timport collections\\n\\n\\tclass Solution(object):\\n\\t\\tdef isCompleteTree(self, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not root: return True\\n\\n\\t\\t\\tqueue = collections.deque()\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\tflag = False\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurr = queue.popleft()\\n\\t\\t\\t\\tif curr is None:\\n\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif flag is True:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tqueue.append(curr.left)\\n\\t\\t\\t\\t\\tqueue.append(curr.right)\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 338689,
                "title": "my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> myqueue;\\n        myqueue.push(root);\\n        \\n        while(!myqueue.empty()){\\n            if(myqueue.front()){\\n                myqueue.push(myqueue.front()->left);\\n                myqueue.push(myqueue.front()->right);\\n                myqueue.pop();\\n            }else{\\n                myqueue.pop();\\n                while(!myqueue.empty()){\\n                    if(myqueue.front())\\n                        return false;\\n                    myqueue.pop();\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> myqueue;\\n        myqueue.push(root);\\n        \\n        while(!myqueue.empty()){\\n            if(myqueue.front()){\\n                myqueue.push(myqueue.front()->left);\\n                myqueue.push(myqueue.front()->right);\\n                myqueue.pop();\\n            }else{\\n                myqueue.pop();\\n                while(!myqueue.empty()){\\n                    if(myqueue.front())\\n                        return false;\\n                    myqueue.pop();\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272958,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        que = collections.deque([root])\\n        while que:\\n            for _ in range(len(que)):\\n                front = que.popleft()\\n                if front == None:\\n                    return all(node==None for node in que)\\n                else:\\n                    que.extend([front.left, front.right])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        que = collections.deque([root])\\n        while que:\\n            for _ in range(len(que)):\\n                front = que.popleft()\\n                if front == None:\\n                    return all(node==None for node in que)\\n                else:\\n                    que.extend([front.left, front.right])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225307,
                "title": "c-0ms-recursive-solution-one-pass",
                "content": "The idea is to check if the tree is complete and also if it\\'s perfect (each node has 0 or 2 children and all the leaves are on the last level), and to track the depth. Then we can derive current node results based on completeness and perfectness of left and right subtrees (and their depths).\\n\\n```\\nclass Solution {\\npublic:   \\n    struct TreeStats {\\n        bool complete;\\n        bool perfect;\\n        int depth;        \\n    };\\n    \\n    TreeStats calcStats(TreeNode* node) {\\n        if(node == 0) {\\n            return {true, true, 0};\\n        }\\n        \\n        TreeStats left = calcStats(node->left);\\n        TreeStats right = calcStats(node->right);\\n        \\n        const int diff = left.depth - right.depth;\\n        \\n        bool isComplete = (0 <= diff && diff <= 1) && left.complete && right.complete\\n            && (left.perfect && right.perfect || left.perfect && diff == 0 || right.perfect && diff == 1);\\n        \\n        bool isPerfect = left.perfect && right.perfect && diff == 0;\\n        \\n        int depth = max(left.depth, right.depth) + 1;\\n        \\n        return {isComplete, isPerfect, depth};\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        return calcStats(root).complete;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    struct TreeStats {\\n        bool complete;\\n        bool perfect;\\n        int depth;        \\n    };\\n    \\n    TreeStats calcStats(TreeNode* node) {\\n        if(node == 0) {\\n            return {true, true, 0};\\n        }\\n        \\n        TreeStats left = calcStats(node->left);\\n        TreeStats right = calcStats(node->right);\\n        \\n        const int diff = left.depth - right.depth;\\n        \\n        bool isComplete = (0 <= diff && diff <= 1) && left.complete && right.complete\\n            && (left.perfect && right.perfect || left.perfect && diff == 0 || right.perfect && diff == 1);\\n        \\n        bool isPerfect = left.perfect && right.perfect && diff == 0;\\n        \\n        int depth = max(left.depth, right.depth) + 1;\\n        \\n        return {isComplete, isPerfect, depth};\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        return calcStats(root).complete;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663206,
                "title": "c-simple-solution-bfs-dfs-without-count-nodes-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS, DFS and level ordering properties to find the completeness.\\n# Approach 1 : DFS\\n<!-- Describe your approach to solving the problem. -->\\n- First, we do a simple DFS to determine the number of nodes n.\\n\\n- Next, we start another DFS with root as node and assigning an index of 0 to it. If node == null, we have an empty subtree of node. For this case, we return true. Otherwise, we examine whether index >= n.\\n\\n- If index >= n, it means we\\'ve a non-null node having index greater or equal to the number of nodes in the given tree which tells that the given tree is not a complete binary tree. We return false.\\n\\n- Otherwise, we call dfs recursively for the left and right subtrees to see if any node in either subtree violates the complete binary tree property. To perform this recursion, we use`isCBT(node->left, 2*index + 1, n) && isCBT(node->right, 2*index + 2, n)`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nodes;\\n    void cntNodes(TreeNode* root){\\n        if(!root) return;\\n        cntNodes(root->left);\\n        nodes++;\\n        cntNodes(root->right);\\n    }\\n\\n    bool isCBT(TreeNode* root,int index,int nodes){\\n        if(!root)return true;\\n        if(index>=nodes)return false;\\n        return isCBT(root->left,2*index + 1,nodes) && isCBT(root->right,2*index + 2,nodes);\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        cntNodes(root);\\n        return isCBT(root,0,nodes);\\n    }\\n};\\n```\\n# Approach 2 : BFS\\n<!-- Describe your approach to solving the problem. -->\\n- We initialize nullNodeFound as false and start with the root node. \\n- If the tree is empty (root is null), we return true. \\n- During BFS, if a null node is encountered, nullNodeFound is set to true. \\n- If a non-null node is encountered after nullNodeFound is true, the tree is not complete, and we return false.\\n- If the traversal completes without violating this condition, the tree is considered complete, and we return true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        bool nullNode = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n\\n            if (node == nullptr) {\\n                nullNode = true;\\n            } else {\\n                if (nullNode) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Approach 3 : Using Leftmost height\\n<!-- Describe your approach to solving the problem. -->\\n- We traverse the tree and track the current height h in recursive variable. Set leftmost node height into leftMostHeight varible.\\n\\n- For remaining leaves, the height should be the same as leftMostHeight. If we encounter a null node with height less that leftMostHeight, that means last level should not be filled further to maintain completeness, our height can become `leftMostHeight - 1` i.e; last before level. \\n- In that case, we set `lastLevelIsFull = 1`, and check that the height of remaining leaves equals `leftMostHeight - lastLevelIsFull` .\\n\\n- `h == leftMostHeight - lastLevelIsFull `, with this condition, whenever we encounter a node again in last level, it returns false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (recursive stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leftMostHeight = 0, lastLevelIsFull = false;\\n    bool isCompleteTree(TreeNode* r, int h = 0) {\\n    if (r == nullptr) {\\n        if (leftMostHeight == 0) {\\n            leftMostHeight = h;\\n        } else if (h == leftMostHeight - 1) {\\n            lastLevelIsFull  = true;\\n        }\\n        return h == leftMostHeight - lastLevelIsFull ;\\n    }\\n    return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.**\\n\\n![3u04h5.jpg](https://assets.leetcode.com/users/images/601f60ec-ad18-4e2d-9439-daae38029ce1_1687292004.5022247.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nodes;\\n    void cntNodes(TreeNode* root){\\n        if(!root) return;\\n        cntNodes(root->left);\\n        nodes++;\\n        cntNodes(root->right);\\n    }\\n\\n    bool isCBT(TreeNode* root,int index,int nodes){\\n        if(!root)return true;\\n        if(index>=nodes)return false;\\n        return isCBT(root->left,2*index + 1,nodes) && isCBT(root->right,2*index + 2,nodes);\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        cntNodes(root);\\n        return isCBT(root,0,nodes);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        bool nullNode = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n\\n            if (node == nullptr) {\\n                nullNode = true;\\n            } else {\\n                if (nullNode) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int leftMostHeight = 0, lastLevelIsFull = false;\\n    bool isCompleteTree(TreeNode* r, int h = 0) {\\n    if (r == nullptr) {\\n        if (leftMostHeight == 0) {\\n            leftMostHeight = h;\\n        } else if (h == leftMostHeight - 1) {\\n            lastLevelIsFull  = true;\\n        }\\n        return h == leftMostHeight - lastLevelIsFull ;\\n    }\\n    return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302080,
                "title": "java-solution-using-bfs",
                "content": "***We use bfs because in BFS, we visit nodes from left to right at a level so if we see node after \"null\" then it means our binary tree is not a complete binary tree***\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        boolean nullNodeFound = false;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            \\n            if(node==null){\\n                nullNodeFound = true;\\n            }else{\\n                if(nullNodeFound==true){\\n                    return false;\\n                }\\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        boolean nullNodeFound = false;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            \\n            if(node==null){\\n                nullNodeFound = true;\\n            }else{\\n                if(nullNodeFound==true){\\n                    return false;\\n                }\\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301736,
                "title": "java-c-dfs-just-find-index-of-last-node-beats-100",
                "content": "# Upvote if you liked \\u2714\\u2705\\uD83E\\uDD29\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo need to do BFS or DFS traversal. Just find the index of last node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have taken binary tree as 1-indexed. So left child of root `ind` is   `2*ind` and right one is `2*ind+1`.\\n\\nSuppose `total` = total no of nodes in binary tree\\nand     `maxi`  = index of last node  of binary tree\\n\\nSo to become a Complete Binary Tree, it is needed `total == maxi`, otherwise it is not a Complete Binary Tree.\\n\\n[`Note` : To avoid overflow of indices i have taken `min(101, 2*ind)` instead of (`2*ind`) , as maximum no of node is only 100.  ]\\n\\n# Complexity\\n- Time complexity: $$O(N)$$, where `N` is no of node in binary tree. We are just traversing the entire binary tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(H)$$, where `H` is height of binary tree, required for call stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    int maxi = 0;\\n\\n    private int isCompleteTreeHelp(TreeNode root, int ind) {\\n        if (root == null) return 0;\\n        maxi = Math.max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root.left, Math.min(101, 2 * ind)) + isCompleteTreeHelp(root.right, Math.min(101, 2 * ind + 1));\\n    }\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTreeHelp(root, 1) == maxi ? true : false;\\n    }\\n}\\n```\\n\\n---\\n\\n# C++ Code :\\n```\\nclass Solution {\\n    int maxi = 0;\\n    int isCompleteTreeHelp(TreeNode* root, int ind) {\\n        if (root == NULL) return 0;\\n        maxi = max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root->left, min(101, 2 * ind)) + isCompleteTreeHelp(root->right, min(101, 2 * ind + 1));\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        return isCompleteTreeHelp(root, 1) == maxi;\\n    }\\n};\\n```\\n# Upvote if you liked \\u2714\\u2705\\uD83E\\uDD29\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/97f61d34-0d0e-41a4-95b3-2729e1643bb5_1678909132.7747173.jpeg)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxi = 0;\\n\\n    private int isCompleteTreeHelp(TreeNode root, int ind) {\\n        if (root == null) return 0;\\n        maxi = Math.max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root.left, Math.min(101, 2 * ind)) + isCompleteTreeHelp(root.right, Math.min(101, 2 * ind + 1));\\n    }\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTreeHelp(root, 1) == maxi ? true : false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int maxi = 0;\\n    int isCompleteTreeHelp(TreeNode* root, int ind) {\\n        if (root == NULL) return 0;\\n        maxi = max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root->left, min(101, 2 * ind)) + isCompleteTreeHelp(root->right, min(101, 2 * ind + 1));\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        return isCompleteTreeHelp(root, 1) == maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300958,
                "title": "tc-o-n-sc-o-n-n-no-of-nodes-in-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n        return true;\\n        boolean nullfound=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode temp=q.poll();\\n                if(temp==null)\\n                {\\n                    nullfound=true;\\n                }\\n                else {\\n                    if(nullfound)\\n                    {\\n                        return false;\\n                    }\\n                    else{\\n                        q.offer(temp.left);\\n                        q.offer(temp.right);\\n\\n                    }\\n                }\\n                \\n\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n        return true;\\n        boolean nullfound=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode temp=q.poll();\\n                if(temp==null)\\n                {\\n                    nullfound=true;\\n                }\\n                else {\\n                    if(nullfound)\\n                    {\\n                        return false;\\n                    }\\n                    else{\\n                        q.offer(temp.left);\\n                        q.offer(temp.right);\\n\\n                    }\\n                }\\n                \\n\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300184,
                "title": "rust-bfs-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::LinkedList;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = LinkedList::new();\\n        queue.push_back(root);\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(v) = v {\\n                queue.push_back(v.borrow().left.clone());\\n                queue.push_back(v.borrow().right.clone());\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(_) = v {\\n                return false\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::LinkedList;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = LinkedList::new();\\n        queue.push_back(root);\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(v) = v {\\n                queue.push_back(v.borrow().left.clone());\\n                queue.push_back(v.borrow().right.clone());\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(_) = v {\\n                return false\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299921,
                "title": "easy-java-solution-full-explaination-level-order-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First get all the data for each level and store it into a Collections such as listData. And when you encounter null node just push -1 into your list to keep track of the space between nodes and then for each list inside listData you need to count number of element whose value is greater than 0. because when we are at last list we make sure that all the above level make complete binary tree to verify that we just check the count is equal to the formula i.e. Math.pow(2,i)-1 which gives the total no. of element upto that level including root.And then for the last list we just check the list is completely full or its partially full from the left and there is no -1 in between 2 nodes having value greater than 0**\\n\\nExample for last list should be like :\\n1. [4,5,6,-1,-1] this is valid\\n2. [4,5,6,-1,7,-1,-1,-1] is not valid\\n3. [1,-1,-1,-1,-1,-1,-1,-1] is valid \\n4. [-1,-1,-1,-1,-1,6,7,8] is not valid \\nso basically there should be no -1 in the left part of the list \\nif its not a valid list return false else return true\\n\\n**Note : Here in my listData will contain one extra list at the end so just ignore it**\\n# Code\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0 ; i < size; i ++){\\n                TreeNode node = q.poll();\\n                if(node != null){\\n                    al.add(node.val);\\n                }else{\\n                    al.add(-1);\\n                    continue;\\n                }\\n                if(node.left != null){\\n                    q.add(node.left);\\n                }else{\\n                    q.add(null);\\n                }\\n                if(node.right != null){\\n                    q.add(node.right);\\n                }else{\\n                    q.add(null);\\n                }\\n            }\\n            list.add(al);\\n        }\\n        int count = 0;\\n        for(int i = 0 ; i < list.size()-1; i ++){\\n            if(i < list.size()-2){\\n                for(Integer num : list.get(i)){\\n                    if(num > 0){\\n                        count++;\\n                    }\\n                }\\n            }else{\\n                //check all the above level have total nodes as it should be in a complete binary tree\\n                if(count != (int)Math.pow(2,i)-1){\\n                    return false;\\n                }\\n                //check if the list is filled from the left \\n                int k = 0;\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) == -1){\\n                        break;\\n                    }\\n                    k++;\\n                }\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) > 0){\\n                        return false;\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0 ; i < size; i ++){\\n                TreeNode node = q.poll();\\n                if(node != null){\\n                    al.add(node.val);\\n                }else{\\n                    al.add(-1);\\n                    continue;\\n                }\\n                if(node.left != null){\\n                    q.add(node.left);\\n                }else{\\n                    q.add(null);\\n                }\\n                if(node.right != null){\\n                    q.add(node.right);\\n                }else{\\n                    q.add(null);\\n                }\\n            }\\n            list.add(al);\\n        }\\n        int count = 0;\\n        for(int i = 0 ; i < list.size()-1; i ++){\\n            if(i < list.size()-2){\\n                for(Integer num : list.get(i)){\\n                    if(num > 0){\\n                        count++;\\n                    }\\n                }\\n            }else{\\n                //check all the above level have total nodes as it should be in a complete binary tree\\n                if(count != (int)Math.pow(2,i)-1){\\n                    return false;\\n                }\\n                //check if the list is filled from the left \\n                int k = 0;\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) == -1){\\n                        break;\\n                    }\\n                    k++;\\n                }\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) > 0){\\n                        return false;\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299889,
                "title": "very-easy-efficient-c-soln-beginner-friendly-code-bfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will do BFS traversal since by this we can check all levels one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is quite simple we first put our root in the queue and do BFS traveral which will visit every level one by one. In each iteration we will check if the children node is present or not, if any of the children node is not present then its clear that after that node, no new node of the tree should be there, So we will just mark our flag with 1, and if afterward any node is found then we will simply return false else will iterate it thorougly and at last return true.\\n**PLease upvote guys if it helps or make sense to you.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(min(n,h))\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int flag=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            queue<TreeNode*> temp;\\n            while(size--)\\n            {\\n                TreeNode* top = q.front();\\n                q.pop();\\n                cout<<top->val<<\" \";\\n                if(top->left)\\n                {\\n                    if(flag==1)\\n                        return false;\\n                    temp.push(top->left);\\n                }\\n                else\\n                {\\n                    flag=1;\\n                    cout<<top->val;\\n                }\\n                if(top->right)\\n                {\\n                    if(flag==1)\\n                    return false;\\n                    temp.push(top->right);\\n                }\\n                else\\n                {\\n                    cout<<top->val;\\n                    flag=1;\\n                }\\n            }\\n            q=temp;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int flag=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            queue<TreeNode*> temp;\\n            while(size--)\\n            {\\n                TreeNode* top = q.front();\\n                q.pop();\\n                cout<<top->val<<\" \";\\n                if(top->left)\\n                {\\n                    if(flag==1)\\n                        return false;\\n                    temp.push(top->left);\\n                }\\n                else\\n                {\\n                    flag=1;\\n                    cout<<top->val;\\n                }\\n                if(top->right)\\n                {\\n                    if(flag==1)\\n                    return false;\\n                    temp.push(top->right);\\n                }\\n                else\\n                {\\n                    cout<<top->val;\\n                    flag=1;\\n                }\\n            }\\n            q=temp;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3299714,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root == NULL) return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seenNull = false;\\n        while(!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();   \\n            if(node == NULL) {\\n                seenNull = true;\\n                continue;\\n            }\\n            if(seenNull) {\\n                return false;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root == NULL) return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seenNull = false;\\n        while(!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();   \\n            if(node == NULL) {\\n                seenNull = true;\\n                continue;\\n            }\\n            if(seenNull) {\\n                return false;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299635,
                "title": "ruby-fast-concise-3-lines",
                "content": "```ruby\\ndef is_complete_tree(root)\\n    queue = [root]\\n    queue.push root.left, root.right while root = queue.shift\\n    queue.none?\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef is_complete_tree(root)\\n    queue = [root]\\n    queue.push root.left, root.right while root = queue.shift\\n    queue.none?\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3299492,
                "title": "simple-pyhton3-solution-upto-90-faster-o-n-simple-explaination-of-dfs",
                "content": "# Intuition\\n1. Start with a queue containing only the root node.\\n\\n2. While the first element in the queue is not None, remove the first element from the queue, and add its left and right children (if they exist) to the end of the queue.\\n\\n3. After the while loop, check if all remaining elements in the queue are None. If they are, the binary tree is complete; otherwise, it\\'s not complete.\\n\\nThis algorithm ensures that all nodes at each level are processed before moving on to the next level. If we encounter a **None element** in the queue before processing all nodes at a level, it means the binary tree is not complete.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        while queue[0] is not None:\\n            node = queue.pop(0)\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        return all([n is None for n in queue]) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        while queue[0] is not None:\\n            node = queue.pop(0)\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        return all([n is None for n in queue]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299425,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) \\n    {\\n        if(!root) return true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; \\n        while(!q.empty())\\n        { \\n            int levelSize=q.size();\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; \\n                else\\n                {\\n                    if(nullSeen) return false; \\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) \\n    {\\n        if(!root) return true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; \\n        while(!q.empty())\\n        { \\n            int levelSize=q.size();\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; \\n                else\\n                {\\n                    if(nullSeen) return false; \\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299357,
                "title": "short-sweet-c-iterative-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,bool &ans){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int n;\\n        TreeNode* p;\\n        bool k = false;\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                if(p->left == NULL){\\n                    k = true;\\n                }\\n                if(k&&(p->left != NULL || p->right != NULL)){\\n                    ans = false;\\n                    return;\\n                }\\n                if(p->left){\\n                    q.push(p->left);\\n                }\\n                else{\\n                    k = true;\\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                }else{\\n                    k = true;\\n                }\\n            }\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        bool ans = true;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,bool &ans){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int n;\\n        TreeNode* p;\\n        bool k = false;\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                if(p->left == NULL){\\n                    k = true;\\n                }\\n                if(k&&(p->left != NULL || p->right != NULL)){\\n                    ans = false;\\n                    return;\\n                }\\n                if(p->left){\\n                    q.push(p->left);\\n                }\\n                else{\\n                    k = true;\\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                }else{\\n                    k = true;\\n                }\\n            }\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        bool ans = true;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299209,
                "title": "try-once-more-with-my-hints-easy-bfs-solution-in-java",
                "content": "# Hints \\n- Use BFS.\\n- Queue helps us to traverse every level form left to right.\\n- While moving from left to right if got a null node and after that if there is any which is not null this means tree is incomplete.\\n- For every level traverse from left to right and check for 2 things\\n    - If current node is null record it\\n    - else check if any middle node is null return false if not then add left and right of current node in queue\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is number of nodes in tree\\n\\n- Space complexity: $$O(n)$$ where n is maximum number of nodes at any level of tree\\n\\n```\\nPlease upvote\\n```\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean nullBw = false;\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int x = 0; x<s; x++){\\n                TreeNode curr = q.poll();\\n                if(curr == null) nullBw = true;\\n                else {\\n                    if(nullBw) return false;\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPlease upvote\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean nullBw = false;\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int x = 0; x<s; x++){\\n                TreeNode curr = q.poll();\\n                if(curr == null) nullBw = true;\\n                else {\\n                    if(nullBw) return false;\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299100,
                "title": "java-dfs-solution-o-n-time",
                "content": "# Intuition\\nFind the total number of nodes in tree n. \\nCheck index of node, if index is greater than to n, it means tree is in complete.\\n\\nIndex:- 2 * root index + 1 (left) and 2 * root index + 2 (right)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind count of nodes in tree.\\ncheck node index, if index is greated than number of nodes return false, otherwise return true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n# Code\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        int totalNodes = countNodes(root);\\n        return isCompleteTree(root, 0, totalNodes);\\n    }\\n\\n    private boolean isCompleteTree(TreeNode root, int idx, int totalNodes) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (idx >= totalNodes) {\\n            return false;\\n        }\\n\\n        return isCompleteTree(root.left, 2 * idx + 1, totalNodes) && isCompleteTree(root.right, 2 * idx + 2, totalNodes);\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n}\\n```\\n\\n# Hindi Problem Explanation and Solution Approach\\nhttps://youtu.be/ovmWdCyIeU0",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        int totalNodes = countNodes(root);\\n        return isCompleteTree(root, 0, totalNodes);\\n    }\\n\\n    private boolean isCompleteTree(TreeNode root, int idx, int totalNodes) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (idx >= totalNodes) {\\n            return false;\\n        }\\n\\n        return isCompleteTree(root.left, 2 * idx + 1, totalNodes) && isCompleteTree(root.right, 2 * idx + 2, totalNodes);\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299098,
                "title": "java-simple-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<TreeNode> list=bfs(root);\\n        if(root==null) return false;\\n        boolean bool=true;\\n        for(int i=list.size()-1; i>=0; i--){\\n            if(bool && list.get(i)==null){\\n                list.remove(i);\\n                continue;\\n            }\\n            else bool=false;\\n            if(list.get(i)==null) return false;\\n        }\\n        return true;\\n         \\n    }\\n    public List<TreeNode> bfs(TreeNode root){\\n        Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n        List<TreeNode> list=new ArrayList<TreeNode>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode node=queue.poll();\\n            if(node==null) continue;\\n            list.add(node.left);\\n            list.add(node.right);\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<TreeNode> list=bfs(root);\\n        if(root==null) return false;\\n        boolean bool=true;\\n        for(int i=list.size()-1; i>=0; i--){\\n            if(bool && list.get(i)==null){\\n                list.remove(i);\\n                continue;\\n            }\\n            else bool=false;\\n            if(list.get(i)==null) return false;\\n        }\\n        return true;\\n         \\n    }\\n    public List<TreeNode> bfs(TreeNode root){\\n        Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n        List<TreeNode> list=new ArrayList<TreeNode>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode node=queue.poll();\\n            if(node==null) continue;\\n            list.add(node.left);\\n            list.add(node.right);\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299085,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode * > q;\\n        q.push(root);\\n        bool prev =  true;\\n\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                if(temp->left)\\n                {\\n                    if(prev ==false)\\n                    return false;\\n\\n                    q.push(temp->left);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n                if(temp->right )\\n                {\\n                    if(prev == false)\\n                    return false;\\n\\n                    q.push(temp->right);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode * > q;\\n        q.push(root);\\n        bool prev =  true;\\n\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                if(temp->left)\\n                {\\n                    if(prev ==false)\\n                    return false;\\n\\n                    q.push(temp->left);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n                if(temp->right )\\n                {\\n                    if(prev == false)\\n                    return false;\\n\\n                    q.push(temp->right);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299081,
                "title": "beats-84-in-time-and-46-in-space-bfs-queue",
                "content": "# Intuition\\nGiven a tree is binary, a complete binary tree if non null nodes are present from top to bottom and left to right at each level except at last level where last some node as null are acceptable. If we have null before non null value in that level, then it will be a incomplete binary tree.  \\n\\n# Approach\\nOn first occurrence of null set the **nullFound** variable and then if queue has non null value then the tree is not complete binary tree.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nullFound=0;\\n        TreeNode n = root;\\n        while(!q.isEmpty()){\\n            n = q.poll();\\n            if(n == null){\\n                nullFound=1;\\n            }\\n            else{\\n                if(nullFound==1)\\n                    return false;\\n                q.add(n.left);\\n                q.add(n.right);    \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nullFound=0;\\n        TreeNode n = root;\\n        while(!q.isEmpty()){\\n            n = q.poll();\\n            if(n == null){\\n                nullFound=1;\\n            }\\n            else{\\n                if(nullFound==1)\\n                    return false;\\n                q.add(n.left);\\n                q.add(n.right);    \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299065,
                "title": "1ms-simple-and-easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean bool = false;\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.offer(root);\\n        while(!que.isEmpty()){\\n            TreeNode node = que.poll();\\n            if(node == null) bool = true;\\n            else{\\n                 if(bool) return false;\\n                 que.offer(node.left);\\n                 que.offer(node.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean bool = false;\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.offer(root);\\n        while(!que.isEmpty()){\\n            TreeNode node = que.poll();\\n            if(node == null) bool = true;\\n            else{\\n                 if(bool) return false;\\n                 que.offer(node.left);\\n                 que.offer(node.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298817,
                "title": "first-way-to-perceive-the-question-for-beginners",
                "content": "# Intuition\\nTo find wheather we have complete binary tree or not we have to use BFS for traversal. As there could not be a node present if we miss any node\\'s child node. Hmm was that confusing? Take it as if a parent does not have a child node indicate that no further child node can be present as if there will be then we will not satisfy the condition of complete binary tree.\\n\\n# Approach\\nMake a stack and store all the level order traversal in stack check if top element\\'s child is abscent if it does then mark the val to 1 indicating no more child should be present. if they are still present then return false else return true.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        stack<TreeNode*> list;\\n        list.push(root);\\n        int val = 0;\\n        while(list.size() != 0){\\n            stack<TreeNode*> dum;\\n            while(list.size() != 0){\\n                if(val == 1 && list.top()->left != NULL)\\n                    return false;\\n                if(list.top()->left == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->left);\\n                if(val == 1 && list.top()->right != NULL)\\n                    return false;\\n                if(list.top()->right == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->right);\\n                list.pop();\\n            }\\n            while(dum.size() != 0){\\n                list.push(dum.top());\\n                dum.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        stack<TreeNode*> list;\\n        list.push(root);\\n        int val = 0;\\n        while(list.size() != 0){\\n            stack<TreeNode*> dum;\\n            while(list.size() != 0){\\n                if(val == 1 && list.top()->left != NULL)\\n                    return false;\\n                if(list.top()->left == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->left);\\n                if(val == 1 && list.top()->right != NULL)\\n                    return false;\\n                if(list.top()->right == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->right);\\n                list.pop();\\n            }\\n            while(dum.size() != 0){\\n                list.push(dum.top());\\n                dum.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298773,
                "title": "levelwise-traversal-of-tree-bfs-0-ms-solution-day-15-succesfull",
                "content": "# INTIUTION\\n\\n1. To determine if a binary tree is a complete tree, we can perform a **level-wise traversal (BFS)** and check each node of each level. \\n2.  If we encounter a null node before we reach the last level, then the binary tree is not complete.\\n\\n# Approach\\n**1.** We use a queue to do a level-order traversal of the tree. During the traversal, if we encounter a NULL node, we set a flag to indicate that we have found a missing node. \\n\\n**2.** If we encounter a non-NULL node after finding a missing node, then the tree is not complete.\\n\\n**3.** If we finish the traversal without finding any missing nodes, then the tree is complete.\\n\\n# Complexity\\n**Time complexity**: **O(n)** where n is the number of nodes in the binary tree.\\n**Space complexity**: **O(n**) as we use a queue to store nodes. In the worst case, the queue can contain all the nodes in the tree.\\n\\nFeel free to connect on  **[LinkedIn](https://www.linkedin.com/in/pawas-goyal/)** and if any suggestions comment down\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int foundNULL=false;\\n        while(!q.empty()){\\n            TreeNode *valnode=q.front();\\n            q.pop();\\n            if(valnode==NULL){\\n                foundNULL=true;\\n\\n            }\\n            else{\\n                if(foundNULL)return false;\\n                q.push(valnode->left);\\n                q.push(valnode->right);\\n            }\\n           \\n        }\\n        return true;\\n    }\\n};\\n```\\n![agXZX2w_700b.jpg](https://assets.leetcode.com/users/images/d17eeb25-29fa-42d5-8e93-99e395616ee8_1678856059.4601285.jpeg)\\n\\n**Please Upvote If u like the solution**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int foundNULL=false;\\n        while(!q.empty()){\\n            TreeNode *valnode=q.front();\\n            q.pop();\\n            if(valnode==NULL){\\n                foundNULL=true;\\n\\n            }\\n            else{\\n                if(foundNULL)return false;\\n                q.push(valnode->left);\\n                q.push(valnode->right);\\n            }\\n           \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298731,
                "title": "easy-solution-level-order-traversal",
                "content": "> # Approach\\nBy level order traversal we can traverse through levels and presence of previous left and right nodes are tracked with the help of boolean variables if current node has left or right children but previous node on level order traversal has one or no childern means it is not complete binary tree if it is filled with right child without left child then it is not complete binary tree else it will be complete binary tree. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        boolean first=true;\\n        TreeNode curr = root;\\n        queue.add(root);\\n        int i=1;\\n        boolean prevLeft,prevRight=prevLeft=false;\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            boolean hasLeft=false;\\n            boolean hasRight=false;\\n            while(size>0){\\n                curr = queue.poll();\\n                if(curr.left!=null){\\n                    queue.add(curr.left);\\n                    hasLeft=true;\\n                }\\n                else{\\n                    hasLeft=false;\\n                }\\n                if(curr.right!=null){\\n                    queue.add(curr.right);\\n                    hasRight=true;\\n                }\\n                else{\\n                    hasRight=false;\\n                }\\n                if(hasRight==true && hasLeft==false) return false;\\n            if(first){\\n                prevLeft=hasLeft;\\n                prevRight=hasRight;\\n            }\\n            else{\\n                if((hasLeft==true || hasRight==true) && (prevLeft==false || prevRight==false)) return false;\\n                else{\\n                    prevLeft=hasLeft;\\n                    prevRight=hasRight;\\n                }\\n            }\\n                size--;\\n            }\\n            first=false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        boolean first=true;\\n        TreeNode curr = root;\\n        queue.add(root);\\n        int i=1;\\n        boolean prevLeft,prevRight=prevLeft=false;\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            boolean hasLeft=false;\\n            boolean hasRight=false;\\n            while(size>0){\\n                curr = queue.poll();\\n                if(curr.left!=null){\\n                    queue.add(curr.left);\\n                    hasLeft=true;\\n                }\\n                else{\\n                    hasLeft=false;\\n                }\\n                if(curr.right!=null){\\n                    queue.add(curr.right);\\n                    hasRight=true;\\n                }\\n                else{\\n                    hasRight=false;\\n                }\\n                if(hasRight==true && hasLeft==false) return false;\\n            if(first){\\n                prevLeft=hasLeft;\\n                prevRight=hasRight;\\n            }\\n            else{\\n                if((hasLeft==true || hasRight==true) && (prevLeft==false || prevRight==false)) return false;\\n                else{\\n                    prevLeft=hasLeft;\\n                    prevRight=hasRight;\\n                }\\n            }\\n                size--;\\n            }\\n            first=false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298672,
                "title": "c-binary-trees-easy-approach",
                "content": "Here is my c++ ode for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root){return true;}\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.front()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while(!q.empty() && q.front()==NULL){q.pop();}\\n        return q.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root){return true;}\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.front()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while(!q.empty() && q.front()==NULL){q.pop();}\\n        return q.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298622,
                "title": "easy-python-solution-bfs-queue",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n\\n        def bfs(node):\\n\\n            if not node:\\n                return False\\n\\n            queue = []\\n            queue.append(node)\\n\\n            next = []\\n            flag = 0\\n            level = 0\\n            isLast = 1\\n\\n            while queue:\\n                temp = queue.pop(0)\\n\\n                if (not temp.left) and (temp.right):\\n                    return False\\n\\n                if temp.left:\\n                    if flag == 1:\\n                        return False\\n                    next.append(temp.left)\\n\\n                    if temp.left.left or temp.left.right:\\n                        isLast = 0\\n\\n                if temp.right:\\n                    next.append(temp.right)\\n                    if temp.right.left or temp.right.right:\\n                        isLast = 0\\n                else:\\n                    flag = 1\\n\\n                if len(queue) == 0:\\n                    level += 1\\n\\n                    if isLast == 1:\\n                        return True\\n\\n                    if len(next) != 2**level:\\n                        return False\\n\\n                    queue = next\\n                    next = []\\n                    flag = 0\\n                    isLast = 1\\n\\n            return True\\n        \\n        return bfs(root)           \\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n\\n        def bfs(node):\\n\\n            if not node:\\n                return False\\n\\n            queue = []\\n            queue.append(node)\\n\\n            next = []\\n            flag = 0\\n            level = 0\\n            isLast = 1\\n\\n            while queue:\\n                temp = queue.pop(0)\\n\\n                if (not temp.left) and (temp.right):\\n                    return False\\n\\n                if temp.left:\\n                    if flag == 1:\\n                        return False\\n                    next.append(temp.left)\\n\\n                    if temp.left.left or temp.left.right:\\n                        isLast = 0\\n\\n                if temp.right:\\n                    next.append(temp.right)\\n                    if temp.right.left or temp.right.right:\\n                        isLast = 0\\n                else:\\n                    flag = 1\\n\\n                if len(queue) == 0:\\n                    level += 1\\n\\n                    if isLast == 1:\\n                        return True\\n\\n                    if len(next) != 2**level:\\n                        return False\\n\\n                    queue = next\\n                    next = []\\n                    flag = 0\\n                    isLast = 1\\n\\n            return True\\n        \\n        return bfs(root)           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298523,
                "title": "awesome-logic-with-bfs-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:95%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:99%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q,gap=deque([root]),False\\n        while q:\\n            poping=q.popleft()\\n            if not poping: gap=True\\n            else:\\n                if gap: return False\\n                q.append(poping.left)\\n                q.append(poping.right)\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q,gap=deque([root]),False\\n        while q:\\n            poping=q.popleft()\\n            if not poping: gap=True\\n            else:\\n                if gap: return False\\n                q.append(poping.left)\\n                q.append(poping.right)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298484,
                "title": "beats-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool bfs(TreeNode* node){\\n        queue<TreeNode*>q;\\n        q.push(node);\\n        int lvl = 0;\\n        while(!q.empty()){\\n            int flag = 0;\\n            TreeNode* temp = q.front();\\n            int sz = q.size();\\n            cout<<sz;\\n            if( temp->left || temp->right){\\n                cout<<\" \"<<pow(2,lvl)<<endl;\\n                if(sz != pow(2,lvl)) return false;\\n            }\\n            for(int i=0; i<sz; i++){\\n                temp = q.front();\\n                q.pop();\\n                if(flag == 1 && (temp->left || temp->right)) return false;\\n                if(temp->left) q.push(temp->left);\\n                else flag = 1;\\n                if(!temp->left && temp->right) return false;\\n                if(temp->right) q.push(temp->right);\\n                else flag = 1; \\n            }\\n            lvl++;\\n        }\\n        return true;\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        return bfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool bfs(TreeNode* node){\\n        queue<TreeNode*>q;\\n        q.push(node);\\n        int lvl = 0;\\n        while(!q.empty()){\\n            int flag = 0;\\n            TreeNode* temp = q.front();\\n            int sz = q.size();\\n            cout<<sz;\\n            if( temp->left || temp->right){\\n                cout<<\" \"<<pow(2,lvl)<<endl;\\n                if(sz != pow(2,lvl)) return false;\\n            }\\n            for(int i=0; i<sz; i++){\\n                temp = q.front();\\n                q.pop();\\n                if(flag == 1 && (temp->left || temp->right)) return false;\\n                if(temp->left) q.push(temp->left);\\n                else flag = 1;\\n                if(!temp->left && temp->right) return false;\\n                if(temp->right) q.push(temp->right);\\n                else flag = 1; \\n            }\\n            lvl++;\\n        }\\n        return true;\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        return bfs(root);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3298257,
                "title": "level-order-traversal-c-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        // If the root is NULL, the tree is complete.\\n        if(!root) return true;\\n        \\n        // Create a queue to store the nodes of the tree.\\n        queue<TreeNode*> q;\\n        \\n        // Add the root node to the queue.\\n        q.push(root);\\n        \\n        // Flag to check if there is any non-full node encountered in the tree.\\n        bool Non_full_Node = false;\\n        \\n        // Loop until the queue is empty.\\n        while(!q.empty()){\\n            \\n            // Get the front node of the queue.\\n            TreeNode* node = q.front();\\n            \\n            // Pop the front node from the queue.\\n            q.pop();\\n            \\n            // If the node is NULL, set the non-full node flag to true.\\n            if(node == NULL)\\n                Non_full_Node = true;\\n            \\n            // If the node is not NULL, check if the previous node was non-full.\\n            else{\\n                \\n                // If the previous node was non-full, the tree is not complete.\\n                if(Non_full_Node == true) {\\n                    return false;\\n                }\\n                \\n                // Add the left child of the current node to the queue.\\n                q.push(node->left);\\n                \\n                // Add the right child of the current node to the queue.\\n                q.push(node->right);\\n            }\\n        }\\n        \\n        // If all nodes have been processed and no non-full node has been encountered, the tree is complete.\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        // If the root is NULL, the tree is complete.\\n        if(!root) return true;\\n        \\n        // Create a queue to store the nodes of the tree.\\n        queue<TreeNode*> q;\\n        \\n        // Add the root node to the queue.\\n        q.push(root);\\n        \\n        // Flag to check if there is any non-full node encountered in the tree.\\n        bool Non_full_Node = false;\\n        \\n        // Loop until the queue is empty.\\n        while(!q.empty()){\\n            \\n            // Get the front node of the queue.\\n            TreeNode* node = q.front();\\n            \\n            // Pop the front node from the queue.\\n            q.pop();\\n            \\n            // If the node is NULL, set the non-full node flag to true.\\n            if(node == NULL)\\n                Non_full_Node = true;\\n            \\n            // If the node is not NULL, check if the previous node was non-full.\\n            else{\\n                \\n                // If the previous node was non-full, the tree is not complete.\\n                if(Non_full_Node == true) {\\n                    return false;\\n                }\\n                \\n                // Add the left child of the current node to the queue.\\n                q.push(node->left);\\n                \\n                // Add the right child of the current node to the queue.\\n                q.push(node->right);\\n            }\\n        }\\n        \\n        // If all nodes have been processed and no non-full node has been encountered, the tree is complete.\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781521,
                "title": "java-c-bfs-level-order-traversal",
                "content": "# Intuition\\nWhen level-order traversal in a complete tree, after the last node, all nodes in the queue should be null.\\nOtherwise, the tree is not complete.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: We are doing just the Level Order Traversal so T.C - $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty())\\n        {\\n            TreeNode* cur = q.front();\\n            q.pop();\\n            if(cur == NULL)     // We encounter a NULL and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != NULL\\n            {\\n                if(end == true)  // means after encountering a NULL we again encountered a node like ex-2.\\n                    return false;\\n                q.push(cur->left);\\n                q.push(cur->right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n};\\n```\\n\\n\\n# Java Code\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean end = false;\\n        while(!q.isEmpty())\\n        {\\n            TreeNode cur = q.poll();\\n            if(cur == null)     // We encounter a null and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != null\\n            {\\n                if(end == true)  // means after encountering a null we again encountered a node like ex-2.\\n                    return false;\\n                q.offer(cur.left);\\n                q.offer(cur.right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty())\\n        {\\n            TreeNode* cur = q.front();\\n            q.pop();\\n            if(cur == NULL)     // We encounter a NULL and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != NULL\\n            {\\n                if(end == true)  // means after encountering a NULL we again encountered a node like ex-2.\\n                    return false;\\n                q.push(cur->left);\\n                q.push(cur->right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean end = false;\\n        while(!q.isEmpty())\\n        {\\n            TreeNode cur = q.poll();\\n            if(cur == null)     // We encounter a null and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != null\\n            {\\n                if(end == true)  // means after encountering a null we again encountered a node like ex-2.\\n                    return false;\\n                q.offer(cur.left);\\n                q.offer(cur.right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500312,
                "title": "easy-simple-small-fast",
                "content": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        t=[root]\\n        flg=0\\n        while(len(t)>0):\\n            if(len(t)==t.count(None)):\\n                print(\"yo\")\\n                break\\n            if(flg==1):\\n                return False\\n            \\n            n=len(t)\\n            tt=[]\\n            for i in range(n):\\n                if(t[i]!=None):\\n                    if(flg==1):\\n                        return False\\n                    tt.append(t[i].left)\\n                    tt.append(t[i].right)\\n                elif(t[i]==None):\\n                    flg=1\\n            t=tt\\n        return(True)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        t=[root]\\n        flg=0\\n        while(len(t)>0):\\n            if(len(t)==t.count(None)):\\n                print(\"yo\")\\n                break\\n            if(flg==1):\\n                return False\\n            \\n            n=len(t)\\n            tt=[]\\n            for i in range(n):\\n                if(t[i]!=None):\\n                    if(flg==1):\\n                        return False\\n                    tt.append(t[i].left)\\n                    tt.append(t[i].right)\\n                elif(t[i]==None):\\n                    flg=1\\n            t=tt\\n        return(True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344059,
                "title": "c-recursion-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //Step 1: calculate total nodes in a binary tree\\n    int totalNodes(TreeNode* root){\\n        if(root == NULL)return 0;\\n        int ans = 1 + totalNodes(root->left)+totalNodes(root->right);\\n        return ans;\\n    }\\n    //Step2 : check wheather it is CBT\\n    bool checkCBT(TreeNode* root, int i, int n){\\n        if(root == NULL){\\n            return true;\\n        }\\n        if(i >= n){\\n            // if it\\'s left or right child exceed the indes then it is not CBT\\n            return false;\\n        }\\n        else{\\n            bool left = checkCBT(root->left, 2*i+1, n); // calculate left\\n            bool right = checkCBT(root->right, 2*i+2, n); // caluclate right\\n            return (left&&right); // return left and right\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = totalNodes(root);\\n        return checkCBT(root, 0 , n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //Step 1: calculate total nodes in a binary tree\\n    int totalNodes(TreeNode* root){\\n        if(root == NULL)return 0;\\n        int ans = 1 + totalNodes(root->left)+totalNodes(root->right);\\n        return ans;\\n    }\\n    //Step2 : check wheather it is CBT\\n    bool checkCBT(TreeNode* root, int i, int n){\\n        if(root == NULL){\\n            return true;\\n        }\\n        if(i >= n){\\n            // if it\\'s left or right child exceed the indes then it is not CBT\\n            return false;\\n        }\\n        else{\\n            bool left = checkCBT(root->left, 2*i+1, n); // calculate left\\n            bool right = checkCBT(root->right, 2*i+2, n); // caluclate right\\n            return (left&&right); // return left and right\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = totalNodes(root);\\n        return checkCBT(root, 0 , n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097437,
                "title": "python-simple-solution",
                "content": "I used simple approach, tired to manage one queue called as q. I will append node only when its not None. If I found node.left or node.right as None, simply add that data as well. \\n\\nNow check where you found None in queue, if you get None make pre = False, means if you found number after Pre= False, that means this is not Complete Binary tree\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque()\\n        q.append(root)\\n        pre= True\\n        while q :\\n            \\n            curr = q.popleft()\\n            \\n            if curr is None :\\n                pre = False\\n            else :\\n                if pre == False :\\n                    return False \\n                \\n                q.append(curr.left)\\n                q.append(curr.right)\\n                \\n                \\n        return True\\n```\\n\\nplease upvote if you like the idea !",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque()\\n        q.append(root)\\n        pre= True\\n        while q :\\n            \\n            curr = q.popleft()\\n            \\n            if curr is None :\\n                pre = False\\n            else :\\n                if pre == False :\\n                    return False \\n                \\n                q.append(curr.left)\\n                q.append(curr.right)\\n                \\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028866,
                "title": "c-easy-solution-runtime-0ms-fastest-then-100-user-dfs-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Check Completeness of a Binary Tree.\\nMemory Usage: 10.4 MB, less than 76.06% of C++ online submissions for Check Completeness of a Binary Tree.**\\n\\nTime complexity is O(n) and space complexty is O(n)\\n\\n```\\nclass Solution {\\n    // counting no of nodes in a tree\\n    int countnode(TreeNode* root)\\n    {\\n        if(root==NULL) return 0;\\n        int ans=1+countnode(root->left)+countnode(root->right);\\n        return ans;\\n    }\\n    // checking tree is a complete binary tree or not\\n    bool iscbt(TreeNode* root, int index , int count)\\n    {\\n        if(root==NULL) return true;\\n        if(index>=count) return false;\\n        else\\n        {\\n            bool left=iscbt(root->left,2*index+1,count);\\n            bool right=iscbt(root->right,2*index+2,count);\\n            return left && right;\\n        }\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int count=countnode(root);\\n      \\n        int index=0;\\n        \\n        if(iscbt(root,index,count))  return true; // cbt(complete binary tree) is helper function  \\n        else return false;                        \\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    // counting no of nodes in a tree\\n    int countnode(TreeNode* root)\\n    {\\n        if(root==NULL) return 0;\\n        int ans=1+countnode(root->left)+countnode(root->right);\\n        return ans;\\n    }\\n    // checking tree is a complete binary tree or not\\n    bool iscbt(TreeNode* root, int index , int count)\\n    {\\n        if(root==NULL) return true;\\n        if(index>=count) return false;\\n        else\\n        {\\n            bool left=iscbt(root->left,2*index+1,count);\\n            bool right=iscbt(root->right,2*index+2,count);\\n            return left && right;\\n        }\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int count=countnode(root);\\n      \\n        int index=0;\\n        \\n        if(iscbt(root,index,count))  return true; // cbt(complete binary tree) is helper function  \\n        else return false;                        \\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026604,
                "title": "level-order",
                "content": "class Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root)  {\\n       queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* temp;\\n        TreeNode* temp1;\\n        while(!q.empty())\\n        {\\n            temp = q.front();\\n            q.pop();\\n            \\n            if(temp == nullptr){\\n                while(!q.empty())\\n                {\\n                    if(q.front()!= nullptr){\\n                        return false;\\n                    } \\n                    q.pop();\\n                }\\n                return true;\\n            }\\n           \\n                q.push(temp->left);\\n                q.push (temp->right);\\n           \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root)  {\\n       queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* temp;\\n        TreeNode* temp1;\\n        while(!q.empty())\\n        {\\n            temp = q.front();\\n            q.pop();\\n            \\n            if(temp == nullptr){\\n                while(!q.empty())\\n                {\\n                    if(q.front()!= nullptr){\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1974124,
                "title": "c-solution",
                "content": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        // we do BFS\\n        // if we meet the first node which has no left nor right child\\n        // we can assume that if the tree is complete, we would never meet any children any longer\\n        // if we meet any child after that then it means that the tree is not complete\\n        bool noMoreChild = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.size() > 0) {\\n            TreeNode* node = q.front();\\n            if (node->left == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n            }\\n            if (node->right == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->right);\\n            }\\n            q.pop();\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        // we do BFS\\n        // if we meet the first node which has no left nor right child\\n        // we can assume that if the tree is complete, we would never meet any children any longer\\n        // if we meet any child after that then it means that the tree is not complete\\n        bool noMoreChild = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.size() > 0) {\\n            TreeNode* node = q.front();\\n            if (node->left == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n            }\\n            if (node->right == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->right);\\n            }\\n            q.pop();\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906459,
                "title": "c-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        // Intution : \\n        // In a complete binary tree you will never encounter null node between the not-null nodes.\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// foundNull : used to check if a null node is found in between the not-null nodes.\\n        bool foundNull = false;\\n        while(!q.empty())\\n        {\\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr->left)\\n            {\\n                if(foundNull) // if foundNull is marked true then tree is not a complete tree\\n                    return false;\\n                q.push(curr->left);\\n            }\\n            else\\n                foundNull = true;  // is current node becomes NULL, mark foundNull as true\\n            if(curr->right)\\n            {\\n                if(foundNull)\\n                    return false;\\n                q.push(curr->right);\\n            }\\n            else\\n                foundNull = true;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        // Intution : \\n        // In a complete binary tree you will never encounter null node between the not-null nodes.\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// foundNull : used to check if a null node is found in between the not-null nodes.\\n        bool foundNull = false;\\n        while(!q.empty())\\n        {\\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr->left)\\n            {\\n                if(foundNull) // if foundNull is marked true then tree is not a complete tree\\n                    return false;\\n                q.push(curr->left);\\n            }\\n            else\\n                foundNull = true;  // is current node becomes NULL, mark foundNull as true\\n            if(curr->right)\\n            {\\n                if(foundNull)\\n                    return false;\\n                q.push(curr->right);\\n            }\\n            else\\n                foundNull = true;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798827,
                "title": "ruby-concise-and-fast",
                "content": "```\\ndef is_complete_tree(root)\\n    q=[root]\\n    while node=q.shift\\n        q<<node.left\\n        q<<node.right\\n    end\\n    q.uniq == [nil] ? true : false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_complete_tree(root)\\n    q=[root]\\n    while node=q.shift\\n        q<<node.left\\n        q<<node.right\\n    end\\n    q.uniq == [nil] ? true : false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1755977,
                "title": "java-solution-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        \\n        boolean gotNullNode = false;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for (;size>0;size--){\\n                var node = q.poll();\\n                \\n                if (node != null && gotNullNode){\\n                    return false;\\n                }\\n                \\n                if (node == null){\\n                    gotNullNode = true;\\n                } else {\\n                    q.add(node.left);\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        \\n        boolean gotNullNode = false;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for (;size>0;size--){\\n                var node = q.poll();\\n                \\n                if (node != null && gotNullNode){\\n                    return false;\\n                }\\n                \\n                if (node == null){\\n                    gotNullNode = true;\\n                } else {\\n                    q.add(node.left);\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482243,
                "title": "easy-javascript-solution-using-breadth-first-search",
                "content": "```\\nvar isCompleteTree = function(root) {\\n    let hasSeenNull = false\\n    let complete = true\\n    let queue = []\\n\\n\\n    const traverse = () => {\\n        if (!complete) return complete\\n\\n        const node = queue.shift()\\n\\n        if (!node) return false\\n\\n        const right = node.right\\n        const left = node.left\\n\\n        if (left ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(left)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        if (right ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(right)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        traverse ()\\n    }\\n\\n\\n    queue.push(root)\\n    \\n    traverse()\\n    \\n    return complete\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar isCompleteTree = function(root) {\\n    let hasSeenNull = false\\n    let complete = true\\n    let queue = []\\n\\n\\n    const traverse = () => {\\n        if (!complete) return complete\\n\\n        const node = queue.shift()\\n\\n        if (!node) return false\\n\\n        const right = node.right\\n        const left = node.left\\n\\n        if (left ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(left)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        if (right ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(right)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        traverse ()\\n    }\\n\\n\\n    queue.push(root)\\n    \\n    traverse()\\n    \\n    return complete\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1437393,
                "title": "c-bfs",
                "content": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool isEnd = false;\\n        while(!q.empty()){\\n            auto p = q.front(); q.pop();\\n            if(!p){\\n                isEnd = true;\\n                continue;\\n            } \\n            else if(isEnd) return false;\\n            q.push(p->left);\\n            q.push(p->right);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool isEnd = false;\\n        while(!q.empty()){\\n            auto p = q.front(); q.pop();\\n            if(!p){\\n                isEnd = true;\\n                continue;\\n            } \\n            else if(isEnd) return false;\\n            q.push(p->left);\\n            q.push(p->right);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374645,
                "title": "just-bfs-and-no-extra-code-100-fast-explained",
                "content": "just think it this way:\\n**If at least 1 null pointer is obtained in level traversal then no furthur nodes should be available for complete binary tree!!**\\n\\n```\\n bool isCompleteTree(TreeNode* root) {\\n         queue<TreeNode*> q;\\n        TreeNode* t;\\n        q.push(root);\\n        while(q.size()){\\n            int n=q.size();\\n            t=q.front(); q.pop();\\n\\t\\t\\tif(t){                                                                       // push even if children are null\\n                q.push(t->left);  \\n                q.push(t->right);\\n            }\\n            else{                                                                                    // if at least 1 null pointer is obtained \\n                while(q.size()&&q.front()==nullptr)q.pop();                                     // pop all null pointers \\n                if(q.size()) return 0;                                                          // still if queue is not empty then return false \\n            }\\n            \\n        }\\n        return 1;                 // if queue is empty return true\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n bool isCompleteTree(TreeNode* root) {\\n         queue<TreeNode*> q;\\n        TreeNode* t;\\n        q.push(root);\\n        while(q.size()){\\n            int n=q.size();\\n            t=q.front(); q.pop();\\n\\t\\t\\tif(t){                                                                       // push even if children are null\\n                q.push(t->left);  \\n                q.push(t->right);\\n            }\\n            else{                                                                                    // if at least 1 null pointer is obtained \\n                while(q.size()&&q.front()==nullptr)q.pop();                                     // pop all null pointers \\n                if(q.size()) return 0;                                                          // still if queue is not empty then return false \\n            }\\n            \\n        }\\n        return 1;                 // if queue is empty return true\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242350,
                "title": "java-bfs-level-order-traversal-100-performance",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        boolean last = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty())\\n        {\\n            int s = queue.size();\\n            if(last)//this level is last one.\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                   TreeNode node = queue.remove();\\n                    //as its last level we should not see any childs if so then return false.\\n                    if(node.left!=null || node.right!=null)\\n                        return false;\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                    TreeNode node = queue.remove();\\n                    //in this level we already got null child node, so we should not get any more child nodes for current level nodes.\\n                    if(last)\\n                    {\\n                        if(node.left!=null || node.right!=null)\\n                            return false;\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.left==null){\\n                        last=true;\\n                    }\\n                    else \\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.left);\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.right==null){\\n                        last=true;\\n                    }\\n                    else\\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.right);\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        boolean last = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty())\\n        {\\n            int s = queue.size();\\n            if(last)//this level is last one.\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                   TreeNode node = queue.remove();\\n                    //as its last level we should not see any childs if so then return false.\\n                    if(node.left!=null || node.right!=null)\\n                        return false;\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                    TreeNode node = queue.remove();\\n                    //in this level we already got null child node, so we should not get any more child nodes for current level nodes.\\n                    if(last)\\n                    {\\n                        if(node.left!=null || node.right!=null)\\n                            return false;\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.left==null){\\n                        last=true;\\n                    }\\n                    else \\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.left);\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.right==null){\\n                        last=true;\\n                    }\\n                    else\\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.right);\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216558,
                "title": "intuitive-bfs",
                "content": "**Every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible** in English is: no non-empty nodes after the first empty node hit in the BFS traversal order.\\n\\nDuring BFS, a node is polled from the queue and its non-empty children are added to the queue; for empty children, we mark `emptyHit` and move on. Nodes polled can never have non-empty children after `emptyHit`.\\n\\n```\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean emptyHit = false;\\n        while(!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.left);\\n            } else {\\n                emptyHit = true;\\n            }\\n            if (cur.right != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.right);\\n            } else {\\n                emptyHit = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean emptyHit = false;\\n        while(!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.left);\\n            } else {\\n                emptyHit = true;\\n            }\\n            if (cur.right != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.right);\\n            } else {\\n                emptyHit = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165388,
                "title": "c-0ms-100-iterative",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Check Completeness of a Binary Tree.\\nMemory Usage: 10.5 MB, less than 47.28% of C++ online submissions for Check Completeness of a Binary Tree.\\n```\\nclass Solution {\\npublic:\\n  bool isCompleteTree(TreeNode* root) {\\n    queue<TreeNode*> q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int n = q.size();\\n      while(n--){\\n        TreeNode *tmp = q.front(); q.pop();\\n        \\n        if(tmp->left) q.push(tmp->left);\\n        else{\\n          if(tmp->right) return false;\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n        if(tmp->right) q.push(tmp->right);\\n        else{\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isCompleteTree(TreeNode* root) {\\n    queue<TreeNode*> q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int n = q.size();\\n      while(n--){\\n        TreeNode *tmp = q.front(); q.pop();\\n        \\n        if(tmp->left) q.push(tmp->left);\\n        else{\\n          if(tmp->right) return false;\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n        if(tmp->right) q.push(tmp->right);\\n        else{\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164970,
                "title": "java-100-faster-simple-solution-preorder-traversal",
                "content": "```\\nclass Solution {\\n    \\n    int size=0, max=0;\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root==null) {\\n            return true;\\n        }\\n        \\n        helper (root,0);\\n        return size-1 == max;\\n    }\\n    \\n    void helper (TreeNode root, int position) {\\n        if (root != null) {\\n            max = Math.max(position, max);\\n            size++;\\n            helper (root.left, position*2+1);\\n            helper (root.right, position*2+2);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int size=0, max=0;\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root==null) {\\n            return true;\\n        }\\n        \\n        helper (root,0);\\n        return size-1 == max;\\n    }\\n    \\n    void helper (TreeNode root, int position) {\\n        if (root != null) {\\n            max = Math.max(position, max);\\n            size++;\\n            helper (root.left, position*2+1);\\n            helper (root.right, position*2+2);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106847,
                "title": "java-1ms-faster-than-68",
                "content": "```\\n/**\\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode\\n * left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; }\\n * TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left\\n * = left; this.right = right; } }\\n */\\nclass Solution {\\n\\tpublic boolean isCompleteTree(TreeNode root) {\\n\\n\\t\\tQueue<TreeNode> que = new LinkedList<>();\\n\\n\\t\\tque.offer(root);\\n\\t\\tboolean isNullSeen = false;\\n\\t\\twhile (!que.isEmpty()) {\\n\\n\\t\\t\\tint size = que.size();\\n\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode poll = que.poll();\\n\\t\\t\\t\\tif (poll == null) {\\n\\t\\t\\t\\t\\tisNullSeen = true;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (isNullSeen) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tque.offer(poll.left);\\n\\t\\t\\t\\t\\tque.offer(poll.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode\\n * left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; }\\n * TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left\\n * = left; this.right = right; } }\\n */\\nclass Solution {\\n\\tpublic boolean isCompleteTree(TreeNode root) {\\n\\n\\t\\tQueue<TreeNode> que = new LinkedList<>();\\n\\n\\t\\tque.offer(root);\\n\\t\\tboolean isNullSeen = false;\\n\\t\\twhile (!que.isEmpty()) {\\n\\n\\t\\t\\tint size = que.size();\\n\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode poll = que.poll();\\n\\t\\t\\t\\tif (poll == null) {\\n\\t\\t\\t\\t\\tisNullSeen = true;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (isNullSeen) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tque.offer(poll.left);\\n\\t\\t\\t\\t\\tque.offer(poll.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071429,
                "title": "go-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n \\nfunc isCompleteTree(root *TreeNode) bool {\\n    queue := []*TreeNode {root}\\n    stopped := false\\n\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        \\n\\t\\t// if the current node is nil, then, from now on, all the nodes on the same depth and all the leaf nodes should also be nil\\n        if cur == nil {\\n            stopped = true\\n            continue\\n        }\\n        \\n        if cur != nil && stopped {\\n            return false\\n        }\\n        \\n        queue = append(queue, cur.Left, cur.Right)\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n \\nfunc isCompleteTree(root *TreeNode) bool {\\n    queue := []*TreeNode {root}\\n    stopped := false\\n\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        \\n\\t\\t// if the current node is nil, then, from now on, all the nodes on the same depth and all the leaf nodes should also be nil\\n        if cur == nil {\\n            stopped = true\\n            continue\\n        }\\n        \\n        if cur != nil && stopped {\\n            return false\\n        }\\n        \\n        queue = append(queue, cur.Left, cur.Right)\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036947,
                "title": "c-bfs-faster-than-100-runtime-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* curr;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr==NULL)\\n                break;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        if(q.empty())\\n            return true;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* curr;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr==NULL)\\n                break;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        if(q.empty())\\n            return true;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023883,
                "title": "easy-bfs-dfs-python",
                "content": "**BFS: O(n) time and space**\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        if not root:\\n            return       \\n        ret = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, idx = q.popleft()\\n            ret.append(idx)\\n            if node.left:\\n                q+=[(node.left, 2*idx)]\\n            if node.right:\\n                q+=[(node.right, 2*idx+1)] \\n        return len(ret)==ret[-1]\\n```\\n\\n**DFS: O(n) time and space**\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        def dfs(node, idx):\\n            ret.append(idx)\\n            if node.left:\\n                dfs(node.left, 2*idx)\\n            if node.right:\\n                dfs(node.right, 2*idx+1)           \\n        ret = []\\n        if not root:\\n            return \\n        dfs(root, 1)\\n        return len(ret)==max(ret)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        if not root:\\n            return       \\n        ret = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, idx = q.popleft()\\n            ret.append(idx)\\n            if node.left:\\n                q+=[(node.left, 2*idx)]\\n            if node.right:\\n                q+=[(node.right, 2*idx+1)] \\n        return len(ret)==ret[-1]\\n```\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        def dfs(node, idx):\\n            ret.append(idx)\\n            if node.left:\\n                dfs(node.left, 2*idx)\\n            if node.right:\\n                dfs(node.right, 2*idx+1)           \\n        ret = []\\n        if not root:\\n            return \\n        dfs(root, 1)\\n        return len(ret)==max(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013096,
                "title": "c-bfs-simple-straight-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(NULL == root)\\n            return true;\\n        queue<TreeNode* > q;\\n        q.push(root);\\n        bool flag=false;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                root=q.front();\\n                q.pop();\\n                if(root==NULL){\\n                    flag=true;\\n                    continue;\\n                }\\n                if(flag)\\n                    return false;\\n                q.push(root->left);\\n                q.push(root->right);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(NULL == root)\\n            return true;\\n        queue<TreeNode* > q;\\n        q.push(root);\\n        bool flag=false;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                root=q.front();\\n                q.pop();\\n                if(root==NULL){\\n                    flag=true;\\n                    continue;\\n                }\\n                if(flag)\\n                    return false;\\n                q.push(root->left);\\n                q.push(root->right);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915474,
                "title": "beats-100-c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        if(!root)\\n            return true;\\n        \\n        int i = 0;\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        \\n        // traversing level wise until a NUll occurs\\n        while(i<bfs.size() && bfs[i]){\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        \\n        // clearing the cluster of NULLs if left\\n        while(i<bfs.size() && !bfs[i]){\\n            i++;\\n        }\\n    \\n        return i == bfs.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        if(!root)\\n            return true;\\n        \\n        int i = 0;\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        \\n        // traversing level wise until a NUll occurs\\n        while(i<bfs.size() && bfs[i]){\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        \\n        // clearing the cluster of NULLs if left\\n        while(i<bfs.size() && !bfs[i]){\\n            i++;\\n        }\\n    \\n        return i == bfs.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846490,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty()){\\n           TreeNode* curr = q.front();\\n            q.pop();\\n            for(TreeNode* p:{curr->left,curr->right}){\\n                if(p and end) return false;\\n                if(p) q.push(p);\\n                else end = true;\\n            }  \\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty()){\\n           TreeNode* curr = q.front();\\n            q.pop();\\n            for(TreeNode* p:{curr->left,curr->right}){\\n                if(p and end) return false;\\n                if(p) q.push(p);\\n                else end = true;\\n            }  \\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756546,
                "title": "java-o-n-beats-100-level-order-traversal",
                "content": "```\\nclass Solution {\\n    int k=-1;\\n    boolean printLevelOrder(TreeNode root)  \\n    { \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>(); \\n        queue.add(root); \\n        while (!queue.isEmpty())  \\n        { \\n            TreeNode tempNode = queue.poll(); \\n          //  System.out.print(tempNode.data + \" \"); \\n            if (tempNode.left != null) { \\n                if(k==-1)\\n                queue.add(tempNode.left);\\n                else{\\n                    return false;\\n                }\\n            } \\n            else{\\n                k=0;\\n            }\\n            if (tempNode.right != null) { \\n                if(k==-1)\\n                queue.add(tempNode.right);\\n                else\\n                    return false;\\n            } \\n            else\\n                k=0;\\n        }\\n        return true;\\n    } \\n    public boolean isCompleteTree(TreeNode root) {\\n        return printLevelOrder(root);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int k=-1;\\n    boolean printLevelOrder(TreeNode root)  \\n    { \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>(); \\n        queue.add(root); \\n        while (!queue.isEmpty())  \\n        { \\n            TreeNode tempNode = queue.poll(); \\n          //  System.out.print(tempNode.data + \" \"); \\n            if (tempNode.left != null) { \\n                if(k==-1)\\n                queue.add(tempNode.left);\\n                else{\\n                    return false;\\n                }\\n            } \\n            else{\\n                k=0;\\n            }\\n            if (tempNode.right != null) { \\n                if(k==-1)\\n                queue.add(tempNode.right);\\n                else\\n                    return false;\\n            } \\n            else\\n                k=0;\\n        }\\n        return true;\\n    } \\n    public boolean isCompleteTree(TreeNode root) {\\n        return printLevelOrder(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740650,
                "title": "java-code-easy-understanable",
                "content": "We will do the BFS traversal of the tree.\\nAnd whenever we encounter a null node it has to be the last node in the tree.\\n```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        boolean gotNull = false;\\n        while(!q.isEmpty()){\\n            TreeNode temp = q.poll();\\n            if(temp == null && !gotNull){\\n                gotNull = true;\\n                continue;\\n            }\\n            if(gotNull && temp != null){\\n                return false;\\n            }\\n            if(temp == null) continue;\\n            q.add(temp.left);\\n            q.add(temp.right);\\n            \\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        boolean gotNull = false;\\n        while(!q.isEmpty()){\\n            TreeNode temp = q.poll();\\n            if(temp == null && !gotNull){\\n                gotNull = true;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 714056,
                "title": "javascript-o-n-faster-than-97",
                "content": "```\\nvar isCompleteTree = function(root) {\\n    if(!!root){\\n        const queue = [root];\\n        while(queue.length){\\n            let curr = queue.shift();\\n            if(curr===null){\\n                for(node of queue){\\n                    if(node!==null) return false;\\n                }\\n                break;\\n            }\\n            queue.push(curr.left);\\n            queue.push(curr.right);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar isCompleteTree = function(root) {\\n    if(!!root){\\n        const queue = [root];\\n        while(queue.length){\\n            let curr = queue.shift();\\n            if(curr===null){\\n                for(node of queue){\\n                    if(node!==null) return false;\\n                }\\n                break;\\n            }\\n            queue.push(curr.left);\\n            queue.push(curr.right);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654045,
                "title": "simple-solution-in-python-with-explanation",
                "content": "First, let us consider the scenarios for any tree to be a complete tree.\\n* All levels must be filled up completely except for the last level.\\n* All the nodes in the last level should be as left as possible.\\n\\nBoth the scenarios can be put this way. If we do a BFS traversal, no valid node should appear after first NULL.\\n\\nLet\\'s prove this from the two examples given in the problem description.\\n\\n![image](https://assets.leetcode.com/users/satish_muddana/image_1590527114.png)\\n\\nIn the above tree, the first time NULL appears in a BFS traversal is after node 6. We don\\'t have any other valid nodes after 6. Hence this is a complete tree.\\n\\n![image](https://assets.leetcode.com/users/satish_muddana/image_1590527201.png)\\n\\nIn the above tree, the first time NULL apperas in a BFS traversal is after node 5. We have a valid node(node 7) after NULL. Hence this is not a complete tree.\\n\\nHere is the code for the same.\\n```\\nimport collections\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue_nodes = collections.deque()\\n        queue_nodes.append(root)\\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t#  break the traversal after the first null\\n            if not curr_node:\\n                break\\n            queue_nodes.append(curr_node.left)\\n            queue_nodes.append(curr_node.right)\\n            \\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t# check if there is a valid node.  Return False if node is valid\\n            if curr_node:\\n                return False\\n\\t\\t\\n        return True\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue_nodes = collections.deque()\\n        queue_nodes.append(root)\\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t#  break the traversal after the first null\\n            if not curr_node:\\n                break\\n            queue_nodes.append(curr_node.left)\\n            queue_nodes.append(curr_node.right)\\n            \\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t# check if there is a valid node.  Return False if node is valid\\n            if curr_node:\\n                return False\\n\\t\\t\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576080,
                "title": "java-simple-dfs-solution-with-explanations",
                "content": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Set<Integer> seenIndexes = new HashSet<>();\\n        dfs(root, 0, seenIndexes); // scan the tree and add all indexes (root index is )\\n        for (int i = 0; i < seenIndexes.size(); i++) { // scan indexes of all nodes\\n            if (!seenIndexes.contains(i)) return false; // if any index is missing\\n        }\\n        return true; // no index is missing\\n    }\\n    \\n    public void dfs(TreeNode root, int ind, Set<Integer> seenIndexes) {\\n        if (root == null) return;\\n        seenIndexes.add(ind); // store current index\\n        dfs(root.left, ind * 2 + 1, seenIndexes); // the index of the left node will be: ind * 2 + 1\\n        dfs(root.right, ind * 2 + 2, seenIndexes); // the index of the left node will be: ind * 2 + 2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Set<Integer> seenIndexes = new HashSet<>();\\n        dfs(root, 0, seenIndexes); // scan the tree and add all indexes (root index is )\\n        for (int i = 0; i < seenIndexes.size(); i++) { // scan indexes of all nodes\\n            if (!seenIndexes.contains(i)) return false; // if any index is missing\\n        }\\n        return true; // no index is missing\\n    }\\n    \\n    public void dfs(TreeNode root, int ind, Set<Integer> seenIndexes) {\\n        if (root == null) return;\\n        seenIndexes.add(ind); // store current index\\n        dfs(root.left, ind * 2 + 1, seenIndexes); // the index of the left node will be: ind * 2 + 1\\n        dfs(root.right, ind * 2 + 2, seenIndexes); // the index of the left node will be: ind * 2 + 2\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 551901,
                "title": "python-collection-of-bfs-solutions",
                "content": "**BFS** with an observation: `No null node on the left and above`\\n\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n            \"\"\"\\n            1\\n          2   3\\n        4       5\\n    \\n            1\\n          2   3\\n        4  5    \\n      6\\n            \"\"\"\\n            Q = [root]\\n            isNoneAbove = False\\n            while Q:\\n                lvlNodes = []\\n                isNoneLeft = False\\n                \\n                for node in Q:\\n                    if not node:\\n                        isNoneLeft = True\\n                    elif isNoneAbove or isNoneLeft:\\n                        return False\\n                    else:\\n    \\t\\t\\t\\t\\t# we don\\'t check children are null\\n                        lvlNodes += [node.left, node.right]\\n                \\n                isNoneAbove = isNoneLeft\\n                Q = lvlNodes\\n            return True\\n\\nUse **BFS** to do a level order traversal, add children to the bfs queue, until we met the first empty node. For a complete binary tree, there should not be any node after we met an empty one.\\n\\n    from collections import deque\\n    \\n    class Solution:\\n        def isCompleteTree(self, root: TreeNode) -> bool:\\n            deq = deque([root])\\n            while deq:\\n                node = deq.popleft()\\n                if not node:\\n                    break\\n                deq.append(node.left)\\n                deq.append(node.right)\\n            # there should not be any node after we met an empty one\\n            return not any(deq)\\n\\n**BFS** with an observation: `if each node is marked with a number, starting from 1 as the root node, then len(queue) == largest number at the end`\\n\\nMore details [here](https://leetcode.com/problems/check-completeness-of-a-binary-tree/solution/)\\n\\n    \"\"\"\\n    \\t   \\t   1\\n    \\t    2     3\\n    \\tnull  5\\n            10 11\\n    \"\"\"\\n        def isCompleteTree(self, root):\\n            nodes = [(root, 1)]\\n            i = 0\\n            while i < len(nodes):\\n                node, v = nodes[i]\\n                i += 1\\n                if node:\\n                    nodes.append((node.left, 2*v))\\n                    nodes.append((node.right, 2*v+1))\\n    \\n            return  nodes[-1][1] == len(nodes)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "**BFS** with an observation: `No null node on the left and above`\\n\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n            \"\"\"\\n            1\\n          2   3\\n        4       5\\n    \\n            1\\n          2   3\\n        4  5    \\n      6\\n            \"\"\"\\n            Q = [root]\\n            isNoneAbove = False\\n            while Q:\\n                lvlNodes = []\\n                isNoneLeft = False\\n                \\n                for node in Q:\\n                    if not node:\\n                        isNoneLeft = True\\n                    elif isNoneAbove or isNoneLeft:\\n                        return False\\n                    else:\\n    \\t\\t\\t\\t\\t# we don\\'t check children are null\\n                        lvlNodes += [node.left, node.right]\\n                \\n                isNoneAbove = isNoneLeft\\n                Q = lvlNodes\\n            return True\\n\\nUse **BFS** to do a level order traversal, add children to the bfs queue, until we met the first empty node. For a complete binary tree, there should not be any node after we met an empty one.\\n\\n    from collections import deque\\n    \\n    class Solution:\\n        def isCompleteTree(self, root: TreeNode) -> bool:\\n            deq = deque([root])\\n            while deq:\\n                node = deq.popleft()\\n                if not node:\\n                    break\\n                deq.append(node.left)\\n                deq.append(node.right)\\n            # there should not be any node after we met an empty one\\n            return not any(deq)\\n\\n**BFS** with an observation: `if each node is marked with a number, starting from 1 as the root node, then len(queue) == largest number at the end`\\n\\nMore details [here](https://leetcode.com/problems/check-completeness-of-a-binary-tree/solution/)\\n\\n    \"\"\"\\n    \\t   \\t   1\\n    \\t    2     3\\n    \\tnull  5\\n            10 11\\n    \"\"\"\\n        def isCompleteTree(self, root):\\n            nodes = [(root, 1)]\\n            i = 0\\n            while i < len(nodes):\\n                node, v = nodes[i]\\n                i += 1\\n                if node:\\n                    nodes.append((node.left, 2*v))\\n                    nodes.append((node.right, 2*v+1))\\n    \\n            return  nodes[-1][1] == len(nodes)",
                "codeTag": "Java"
            },
            {
                "id": 536677,
                "title": "go-golang-bfs-0ms-solution",
                "content": "```\\nfunc isCompleteTree(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    curr := []*TreeNode{root}\\n    next := []*TreeNode{}\\n    empty := false\\n    for len(curr) != 0 {\\n        for _, c := range curr {\\n            if c.Left == nil && c.Right != nil {\\n                return false\\n            }\\n            if c.Left != nil {\\n                if empty {\\n                    return false\\n                }\\n                next = append(next, c.Left)\\n            }\\n            if c.Right != nil {\\n                next = append(next, c.Right)\\n            } else {\\n                empty = true\\n            }\\n        } \\n        curr = next\\n        next = []*TreeNode{}\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isCompleteTree(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    curr := []*TreeNode{root}\\n    next := []*TreeNode{}\\n    empty := false\\n    for len(curr) != 0 {\\n        for _, c := range curr {\\n            if c.Left == nil && c.Right != nil {\\n                return false\\n            }\\n            if c.Left != nil {\\n                if empty {\\n                    return false\\n                }\\n                next = append(next, c.Left)\\n            }\\n            if c.Right != nil {\\n                next = append(next, c.Right)\\n            } else {\\n                empty = true\\n            }\\n        } \\n        curr = next\\n        next = []*TreeNode{}\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519073,
                "title": "c-simple-solution",
                "content": "Pretty self-explanatory C++ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {        \\n        std::queue<TreeNode *> Q;\\n        if (root != nullptr) Q.push(root);\\n        \\n        bool lastLevel = false;\\n        while (!Q.empty()) {\\n            int s = Q.size();\\n            for (int i = 0; i < s; ++i) {\\n                TreeNode *u = Q.front(); Q.pop();\\n                \\n                if (u->left != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->left);\\n                }\\n                else lastLevel = true;\\n                \\n                if (u->right != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->right);\\n                }\\n                else lastLevel = true;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {        \\n        std::queue<TreeNode *> Q;\\n        if (root != nullptr) Q.push(root);\\n        \\n        bool lastLevel = false;\\n        while (!Q.empty()) {\\n            int s = Q.size();\\n            for (int i = 0; i < s; ++i) {\\n                TreeNode *u = Q.front(); Q.pop();\\n                \\n                if (u->left != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->left);\\n                }\\n                else lastLevel = true;\\n                \\n                if (u->right != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->right);\\n                }\\n                else lastLevel = true;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438157,
                "title": "python-divide-and-conquer-solution",
                "content": "The helper function returns two number: MIN and MAX height of the subtree starting from current node.\\nIn each recursion, we got Min and Max from both left and right:\\nThere are only four valid situations:(five are listed, but one and five are actually the same)\\n![image](https://assets.leetcode.com/users/lechen999/image_1574787802.png)\\nIf the MINs and MAXs are within one of the valid situation, path the new MIN and new MAX.\\nOtherwise, pass the -inf and inf\\nIn other words, the return of height is conditional, only return the actual MIN and MAX height when this subtree starting from current node is complete.\\nEither one of the child\\'s MIN MAX is -inf and inf, this node\\'s MIN MAX will also be -inf and inf.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        height_min, height_max = self.helper(root)\\n        return height_max - height_min <= 1 # Only when height different less than one, this tree is complete\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0 # when reach the bottom, MIN MAX height are both zero\\n        left_min, left_max = self.helper(root.left)\\n        right_min, right_max = self.helper(root.right)\\n        if left_max >= left_min >= right_max >= right_min and left_max <= right_min + 1:  # to be clear, the logic here is redundent\\n\\t\\t# if left_min >= right_max and left_max <= right_min + 1: # this is the concise version\\n            return right_min + 1, left_max + 1  \\n        return float(\"-inf\"), float(\"inf\")\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        height_min, height_max = self.helper(root)\\n        return height_max - height_min <= 1 # Only when height different less than one, this tree is complete\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0 # when reach the bottom, MIN MAX height are both zero\\n        left_min, left_max = self.helper(root.left)\\n        right_min, right_max = self.helper(root.right)\\n        if left_max >= left_min >= right_max >= right_min and left_max <= right_min + 1:  # to be clear, the logic here is redundent\\n\\t\\t# if left_min >= right_max and left_max <= right_min + 1: # this is the concise version\\n            return right_min + 1, left_max + 1  \\n        return float(\"-inf\"), float(\"inf\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427990,
                "title": "java-easy-recursion-with-two-100-solution",
                "content": "\\n    private int count = 0;\\n    private int max = 0;\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null){\\n            return true;\\n        }\\n        dfs(root, 1);\\n        return max == count;\\n    }\\n    \\n    private void dfs(TreeNode root, int next){\\n        if (root == null) return;\\n        count++;\\n        max = Math.max(max, next);\\n        dfs(root.left, 2 * next);\\n        dfs(root.right, 2 * next + 1);\\n    }\\n\\xB7\\xB7\\xB7",
                "solutionTags": [],
                "code": "\\n    private int count = 0;\\n    private int max = 0;\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null){\\n            return true;\\n        }\\n        dfs(root, 1);\\n        return max == count;\\n    }\\n    \\n    private void dfs(TreeNode root, int next){\\n        if (root == null) return;\\n        count++;\\n        max = Math.max(max, next);\\n        dfs(root.left, 2 * next);\\n        dfs(root.right, 2 * next + 1);\\n    }\\n\\xB7\\xB7\\xB7",
                "codeTag": "Unknown"
            },
            {
                "id": 409836,
                "title": "simple-java-solution-bfs",
                "content": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        boolean inComplete = false; \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode curr = queue.poll();\\n                if(curr.left == null && curr.right != null) return false;\\n                if(inComplete && (curr.left !=null || curr.right != null)) return false;\\n                if(curr.left != null) queue.add(curr.left);\\n                if(curr.right != null) queue.add(curr.right);\\n                if (curr.right == null) inComplete = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        boolean inComplete = false; \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode curr = queue.poll();\\n                if(curr.left == null && curr.right != null) return false;\\n                if(inComplete && (curr.left !=null || curr.right != null)) return false;\\n                if(curr.left != null) queue.add(curr.left);\\n                if(curr.right != null) queue.add(curr.right);\\n                if (curr.right == null) inComplete = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364908,
                "title": "go-concise-solution",
                "content": "```\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tq := []*TreeNode{root}\\n\\tfor len(q) != 0 && q[0] != nil {\\n\\t\\tnode := q[0]\\n\\t\\tq = append(q, node.Left, node.Right)\\n\\t\\tq = q[1:]\\n\\t}\\n\\n\\tfor i := 0; i < len(q); i++ {\\n\\t\\tif q[i] != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tq := []*TreeNode{root}\\n\\tfor len(q) != 0 && q[0] != nil {\\n\\t\\tnode := q[0]\\n\\t\\tq = append(q, node.Left, node.Right)\\n\\t\\tq = q[1:]\\n\\t}\\n\\n\\tfor i := 0; i < len(q); i++ {\\n\\t\\tif q[i] != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363230,
                "title": "c-solution-using-bfs-faster-than-90",
                "content": "ALGO-->> As soon as we receive first null in tree, we will check for all the values that are remaining in stack, If any of these values are not NULL, it will retrun false. Traversal is done by Breadth first search(BFS).\\n\\n```\\nbool isCompleteTree(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return true;\\n        TreeNode *p,*r;\\n        std::queue<TreeNode *> q{};                   // Queue is created\\n        q.push(root);\\n        int count=0;\\n        while(!q.empty())                             // while q is empty it will run\\n        { \\n            int z=q.size();\\n            for(int i=0;i<z;i++)\\n            {\\n            p=q.front();\\n            q.pop();\\n                if(p==NULL)                           // as soon as first null is recived all the next \\n                {                                     // elements must be null in order to be a complete\\n                                                      // binary tree\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        r=q.front();\\n                        q.pop();\\n                        if(r!=NULL)\\n                            return false;\\n                    }\\n                  break;  \\n                }\\n                  \\n                  \\n              q.push(p->left);\\n              q.push(p->right);\\n            }\\n        }\\n   \\n        return true;                                  // If all nodes after first null are null, it returns true;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nbool isCompleteTree(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return true;\\n        TreeNode *p,*r;\\n        std::queue<TreeNode *> q{};                   // Queue is created\\n        q.push(root);\\n        int count=0;\\n        while(!q.empty())                             // while q is empty it will run\\n        { \\n            int z=q.size();\\n            for(int i=0;i<z;i++)\\n            {\\n            p=q.front();\\n            q.pop();\\n                if(p==NULL)                           // as soon as first null is recived all the next \\n                {                                     // elements must be null in order to be a complete\\n                                                      // binary tree\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        r=q.front();\\n                        q.pop();\\n                        if(r!=NULL)\\n                            return false;\\n                    }\\n                  break;  \\n                }\\n                  \\n                  \\n              q.push(p->left);\\n              q.push(p->right);\\n            }\\n        }\\n   \\n        return true;                                  // If all nodes after first null are null, it returns true;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330731,
                "title": "python-bfs-level-order-traversal",
                "content": "```\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        curr_level = [root]\\n        not_filled = 0\\n        while curr_level:\\n            next_level, l = [], 0\\n            for i, node in enumerate(curr_level):\\n                if node.left:\\n                    if l != 2 * i:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.left)\\n                if node.right:\\n                    if l != 2 * i + 1:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.right)\\n            if l > 0 and l < 2 * len(curr_level):\\n                not_filled += 1\\n                if not_filled >= 2:\\n                    return False\\n            curr_level = next_level\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        curr_level = [root]\\n        not_filled = 0\\n        while curr_level:\\n            next_level, l = [], 0\\n            for i, node in enumerate(curr_level):\\n                if node.left:\\n                    if l != 2 * i:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.left)\\n                if node.right:\\n                    if l != 2 * i + 1:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.right)\\n            if l > 0 and l < 2 * len(curr_level):\\n                not_filled += 1\\n                if not_filled >= 2:\\n                    return False\\n            curr_level = next_level\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328435,
                "title": "java-0ms-o-logn-time-solution-beat-100-with-detailed-explaination",
                "content": "```java\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return false;\\n        return isComplete(root)[0] > 0 ? true : false;\\n    }\\n    \\n\\t// return a array of length 2\\n\\t// first number : height of the tree, -1 means not complete\\n\\t// second number : 1 for perfect(defined below) tree, 0 for not perfect\\n    private int[] isComplete(TreeNode root) {\\n        int[] left = new int[]{0, 1};\\n        int[] right = new int[]{0, 1};\\n        if (root.left != null) {\\n            left = isComplete(root.left);\\n        }\\n        if (root.right != null) {\\n            right = isComplete(root.right);\\n        }\\n        if (left[0] == -1 || right[0] == -1) return new int[]{-1, 0};\\n        if (left[0] == right[0]) {\\n            if (left[1] == 1 && right[1] == 1) return new int[]{left[0] + 1, 1};\\n            return new int[]{left[1] == 0 ? -1 : (left[0] + 1), 0};\\n        } else if (left[0] == right[0] + 1) {\\n            return new int[]{right[1] == 1 ? (left[0] + 1) : -1, 0};\\n        } else {\\n            return new int[]{-1, 0};\\n        }\\n    }\\n}\\n```\\nExplaination:\\n**perfect : (self defined)a binary tree is perfect when it\\'s Complete and Symmetrical:**\\nwhen a tree is complete, there are some conditons:\\n- left subtree and right subtree of the root are complete (must)\\n- left subtree height == right subtree height OR left subtree height == right subtree height + 1\\n\\t1. when left subtree height == right subtree height:\\n\\t\\ta. left and right are both **perfect** -> target tree perfect\\n\\t\\tb. left perfect\\n\\t2. when left subtree height == right subtree height + 1:\\n\\t   a. right perfect",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return false;\\n        return isComplete(root)[0] > 0 ? true : false;\\n    }\\n    \\n\\t// return a array of length 2\\n\\t// first number : height of the tree, -1 means not complete\\n\\t// second number : 1 for perfect(defined below) tree, 0 for not perfect\\n    private int[] isComplete(TreeNode root) {\\n        int[] left = new int[]{0, 1};\\n        int[] right = new int[]{0, 1};\\n        if (root.left != null) {\\n            left = isComplete(root.left);\\n        }\\n        if (root.right != null) {\\n            right = isComplete(root.right);\\n        }\\n        if (left[0] == -1 || right[0] == -1) return new int[]{-1, 0};\\n        if (left[0] == right[0]) {\\n            if (left[1] == 1 && right[1] == 1) return new int[]{left[0] + 1, 1};\\n            return new int[]{left[1] == 0 ? -1 : (left[0] + 1), 0};\\n        } else if (left[0] == right[0] + 1) {\\n            return new int[]{right[1] == 1 ? (left[0] + 1) : -1, 0};\\n        } else {\\n            return new int[]{-1, 0};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312181,
                "title": "easy-understand-python-bfs",
                "content": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        bfs = [root]\\n\\n        while bfs:\\n            node = bfs.pop(0)\\n\\n            if node is None:\\n                return all([node is None for node in bfs])\\n\\n            else:\\n                bfs.append(node.left)\\n                bfs.append(node.right)\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        bfs = [root]\\n\\n        while bfs:\\n            node = bfs.pop(0)\\n\\n            if node is None:\\n                return all([node is None for node in bfs])\\n\\n            else:\\n                bfs.append(node.left)\\n                bfs.append(node.right)\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309914,
                "title": "java-bfs-queue-solution",
                "content": "We traverse the tree using BFS, keeping track of whether we have encountered a null value. If we have, then we expect all the following values to be null as well.\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean hasEncounteredNullValue = false;\\n        while (!queue.isEmpty()){\\n            TreeNode current = queue.remove();\\n            if (current == null){\\n                hasEncounteredNullValue = true;\\n            }\\n            else if (hasEncounteredNullValue){\\n                return false;\\n            }\\n            else{\\n                queue.add(current.left);\\n                queue.add(current.right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean hasEncounteredNullValue = false;\\n        while (!queue.isEmpty()){\\n            TreeNode current = queue.remove();\\n            if (current == null){\\n                hasEncounteredNullValue = true;\\n            }\\n            else if (hasEncounteredNullValue){\\n                return false;\\n            }\\n            else{\\n                queue.add(current.left);\\n                queue.add(current.right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221096,
                "title": "python-with-bfs",
                "content": "I used O(n) space complexity way.\\nFirst, represent the tree as a number list.\\nIf node\\'s value is null, mark as very big number.\\nLastly, just check whether index list increase or not.\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        from collections import deque\\n        q = deque([root])\\n        nums = []\\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                nums.append(float(\\'inf\\'))\\n                continue\\n            nums.append(node.val)\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "I used O(n) space complexity way.\\nFirst, represent the tree as a number list.\\nIf node\\'s value is null, mark as very big number.\\nLastly, just check whether index list increase or not.\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        from collections import deque\\n        q = deque([root])\\n        nums = []\\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                nums.append(float(\\'inf\\'))\\n                continue\\n            nums.append(node.val)\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 207371,
                "title": "beat-99-92-java-solution-recursive-way",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        boolean full;\\n        int height;\\n        Pair(int a, boolean b) {\\n            full = b; height = a;\\n        }\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Pair x = helper(root);\\n        if(x.height == -1) return false;\\n        return true;\\n    }\\n    public Pair helper(TreeNode root) {\\n        if(root == null) return new Pair(0, true);\\n        Pair a = helper(root.right);\\n        Pair b = helper(root.left);\\n        if(a.height < 0 || b.height < 0) return new Pair(-1, false);\\n        if(a.height > b.height || (a.height==b.height && !b.full) || b.height > a.height+1) return new Pair(-1, false);\\n        if(!a.full && b.height > a.height) return new Pair(-1, false);\\n        return new Pair(Math.max(a.height, b.height)+1, b.height > a.height ? false:a.full&&b.full);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        boolean full;\\n        int height;\\n        Pair(int a, boolean b) {\\n            full = b; height = a;\\n        }\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Pair x = helper(root);\\n        if(x.height == -1) return false;\\n        return true;\\n    }\\n    public Pair helper(TreeNode root) {\\n        if(root == null) return new Pair(0, true);\\n        Pair a = helper(root.right);\\n        Pair b = helper(root.left);\\n        if(a.height < 0 || b.height < 0) return new Pair(-1, false);\\n        if(a.height > b.height || (a.height==b.height && !b.full) || b.height > a.height+1) return new Pair(-1, false);\\n        if(!a.full && b.height > a.height) return new Pair(-1, false);\\n        return new Pair(Math.max(a.height, b.height)+1, b.height > a.height ? false:a.full&&b.full);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058788,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            TreeNode a = q.remove();\\n            if(a==null) {\\n                flag = true;\\n            }else{\\n                if(flag) return false;\\n                q.add(a.left);\\n                q.add(a.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            TreeNode a = q.remove();\\n            if(a==null) {\\n                flag = true;\\n            }else{\\n                if(flag) return false;\\n                q.add(a.left);\\n                q.add(a.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1832760,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832633,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832886,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832767,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832625,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832911,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832903,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832843,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832669,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1808090,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832760,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832633,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832886,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832767,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832625,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832911,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832903,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832843,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832669,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1808090,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 2025969,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1899884,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833625,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833463,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833444,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833439,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833420,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833190,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833100,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833084,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833028,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832917,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832875,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832803,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832764,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832756,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832734,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832723,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832720,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832690,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Lucky Integer in an Array",
        "question_content": "<p>Given an array of integers <code>arr</code>, a <strong>lucky integer</strong> is an integer that has a frequency in the array equal to its value.</p>\n\n<p>Return <em>the largest <strong>lucky integer</strong> in the array</em>. If there is no <strong>lucky integer</strong> return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,2,3,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The only lucky number in the array is 2 because frequency[2] == 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,2,2,3,3,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 1, 2 and 3 are all lucky numbers, return the largest of them.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,2,2,3,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There are no lucky numbers in the array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 500</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 557113,
                "title": "3-approaches-2-variations",
                "content": "**Intuition**\\nWe do not care about numbers greater than the size of the input array.\\n\\n> Note: see approach 3A and 3B for a O(1) memory solution.\\n\\n#### Approach 1: Counting Sort\\nWe could use a hash map or an array (since the nuber will not exceed `n`) to count the occurences. Then go from the highest number down, and return the first one that matches our criteria.\\n```cpp\\nint findLucky(vector<int>& arr) {\\n    int m[501] = {};\\n    for (auto n : arr)\\n        ++m[n];\\n    for (auto n = arr.size(); n > 0; --n)\\n        if (n == m[n])\\n            return n;\\n    return -1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(n)\\n\\n#### Approach 2A: Sort\\nWe can sort our array, and do a one-pass from largest element to the smallest. We return the first element which value equals it\\'s count.\\n\\n```cpp\\nint findLucky(vector<int>& arr) {\\n    sort(begin(arr), end(arr), greater<int>());\\n    int cnt = 1;\\n    for (int i = 1; i < arr.size(); ++i) {\\n        if (arr[i] == arr[i - 1])\\n            ++cnt;\\n        else {\\n            if (arr[i - 1] == cnt)\\n                return cnt;\\n            cnt = 1;\\n        }\\n    }\\n    return arr.back() == cnt ? cnt : - 1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n log n)\\n- Memory: O(log n), assuming we can modify the input array. Internally, a typical sort algorithm uses *log n* memory for the stack, but it can be greater than that based on the implementation.\\n\\n#### Approach 2B: Heap\\nThe benefit of a heap is that it does not sort elements upfront, but as you are popping them. When you find the lucky integer, you do not need to sort the rest of the heap.\\n\\nC++ allows \\'heapifying\\' the existing array, so we do not need an extra space for a priority queue or something.\\n\\n```cpp\\nint findLucky(vector<int>& arr) {\\n    make_heap(begin(arr), end(arr));\\n    int cnt = 1, last = -1;\\n    for (int i = 0; i < arr.size(); ++i) {\\n        if (arr.front() == last)\\n            ++cnt;\\n        else {\\n            if (last == cnt)\\n                return cnt;\\n            last = arr.front();\\n            cnt = 1;\\n        }\\n        pop_heap(arr.begin(), arr.end() - i);\\n    }\\n    return arr.front() == cnt ? cnt : - 1;    \\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n log n) in the worst case, less if the lucky integer is large. \\n- Memory: O(log n), assuming we can modify the input array. I am assuming that, internally, the `pop_heap` algorithm uses log n memory for the stack.\\n\\n#### Approach 3A: Linked List (Beast Mode)\\nThe idea is to use the input array to store counts. This approach, however, is quite tricky to implement correctly!\\n\\nWe can think of our array as a linked list, where `arr[i]` points to `arr[arr[i] - 1]` and so on, until the element that points to itself, or its outside of the array (and we do not care about that elements, per the intuition above).\\n\\nAfter we visit `arr[arr[i] - 1]`, we can use that element to track the count of `arr[i]`. For the count, we will use a negative value to distinguish between pointers and counts.\\n\\n```cpp\\n#define BEAST_MODE\\n```\\n```cpp\\nint findLucky(vector<int>& arr) {\\n    for (auto i = 0; i < arr.size(); ++i) {\\n        auto p = i, val = arr[i];\\n        while (val > 0 && val <= arr.size()) {\\n            auto n_val = arr[val - 1];\\n            arr[val - 1] = min(0, arr[val - 1]) - 1;\\n            if (val - 1 <= i || val - 1 == p)\\n                break;\\n            p = val - 1;\\n            val = n_val;\\n        }      \\n    }\\n    for (auto i = arr.size(); i > 0; --i)\\n        if (-arr[i - 1] == i)\\n            return i;\\n    return -1;\\n}\\n```\\n```cpp\\n#undef BEAST_MODE\\n```\\nThese lines may need some explanation.\\n```cpp\\n            if (val - 1 <= i || val - 1 == p)\\n                break;\\n```\\nHere, we break when the element points to itself, or points to a node that we visited earlier.\\n\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1), assuming we can modify the input array.\\n\\n#### Approach 3B: Input Array\\nHere, we will also use the input array to store the count. Since values are limited, we can just use the upper part of the integer to store counts.\\n\\n```cpp\\nint findLucky(vector<int>& arr) {\\n    for (auto n : arr) {\\n        n &= 0xFFFF;\\n        if (n <= arr.size())\\n            arr[n - 1] += 0x10000;\\n    }\\n    for (auto i = arr.size(); i > 0; --i)\\n        if ((arr[i - 1] >> 16) == i)\\n            return i;\\n    return -1;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1); we can restore the input array to the original state, if needed.",
                "solutionTags": [],
                "code": "```cpp\\nint findLucky(vector<int>& arr) {\\n    int m[501] = {};\\n    for (auto n : arr)\\n        ++m[n];\\n    for (auto n = arr.size(); n > 0; --n)\\n        if (n == m[n])\\n            return n;\\n    return -1;\\n}\\n```\n```cpp\\nint findLucky(vector<int>& arr) {\\n    sort(begin(arr), end(arr), greater<int>());\\n    int cnt = 1;\\n    for (int i = 1; i < arr.size(); ++i) {\\n        if (arr[i] == arr[i - 1])\\n            ++cnt;\\n        else {\\n            if (arr[i - 1] == cnt)\\n                return cnt;\\n            cnt = 1;\\n        }\\n    }\\n    return arr.back() == cnt ? cnt : - 1;\\n}\\n```\n```cpp\\nint findLucky(vector<int>& arr) {\\n    make_heap(begin(arr), end(arr));\\n    int cnt = 1, last = -1;\\n    for (int i = 0; i < arr.size(); ++i) {\\n        if (arr.front() == last)\\n            ++cnt;\\n        else {\\n            if (last == cnt)\\n                return cnt;\\n            last = arr.front();\\n            cnt = 1;\\n        }\\n        pop_heap(arr.begin(), arr.end() - i);\\n    }\\n    return arr.front() == cnt ? cnt : - 1;    \\n}\\n```\n```cpp\\n#define BEAST_MODE\\n```\n```cpp\\nint findLucky(vector<int>& arr) {\\n    for (auto i = 0; i < arr.size(); ++i) {\\n        auto p = i, val = arr[i];\\n        while (val > 0 && val <= arr.size()) {\\n            auto n_val = arr[val - 1];\\n            arr[val - 1] = min(0, arr[val - 1]) - 1;\\n            if (val - 1 <= i || val - 1 == p)\\n                break;\\n            p = val - 1;\\n            val = n_val;\\n        }      \\n    }\\n    for (auto i = arr.size(); i > 0; --i)\\n        if (-arr[i - 1] == i)\\n            return i;\\n    return -1;\\n}\\n```\n```cpp\\n#undef BEAST_MODE\\n```\n```cpp\\n            if (val - 1 <= i || val - 1 == p)\\n                break;\\n```\n```cpp\\nint findLucky(vector<int>& arr) {\\n    for (auto n : arr) {\\n        n &= 0xFFFF;\\n        if (n <= arr.size())\\n            arr[n - 1] += 0x10000;\\n    }\\n    for (auto i = arr.size(); i > 0; --i)\\n        if ((arr[i - 1] >> 16) == i)\\n            return i;\\n    return -1;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 554838,
                "title": "java-python-3-two-similar-clean-codes-array-and-hashmap-counter",
                "content": "**Method 1: array** \\n```java\\n    public int findLucky(int[] arr) {\\n        int[] cnt = new int[501];\\n        for (int a : arr) {\\n            ++cnt[a];\\n        }\\n        for (int i = 500; i > 0; --i) {\\n            if (cnt[i] == i) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n```python\\n    def findLucky(self, arr: List[int]) -> int:\\n        cnt = [0] * 501\\n        for a in arr:\\n            cnt[a] += 1\\n        for i in range(500, 0, -1):\\n            if cnt[i] == i:\\n                return i    \\n        return -1\\n```\\nor by **@chr1sC0d1ng**\\'s suggestion of optimization:\\n```python\\n    def findLucky(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        cnt = [0] * (n + 1)\\n        for a in arr:\\n            if a <= n:\\n                cnt[a] += 1\\n        for i in range(n, 0, -1):\\n            if cnt[i] == i:\\n                return i\\n        return -1\\n```\\n\\n----\\n\\n**Method 2**\\n```java\\n    public int findLucky(int[] arr) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int a : arr) {\\n            freq.put(a, 1 + freq.getOrDefault(a, 0)); // Accumulate the occurrence of a.\\n        }\\n        int ans = -1;\\n        for (Map.Entry<Integer, Integer> e : freq.entrySet()) {\\n            if (e.getKey() == e.getValue()) {\\n                ans = Math.max(ans, e.getKey());\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def findLucky(self, arr: List[int]) -> int:\\n        cnt = collections.Counter(arr)\\n        return max([k for k, v in cnt.items() if k == v] + [-1])\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int findLucky(int[] arr) {\\n        int[] cnt = new int[501];\\n        for (int a : arr) {\\n            ++cnt[a];\\n        }\\n        for (int i = 500; i > 0; --i) {\\n            if (cnt[i] == i) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def findLucky(self, arr: List[int]) -> int:\\n        cnt = [0] * 501\\n        for a in arr:\\n            cnt[a] += 1\\n        for i in range(500, 0, -1):\\n            if cnt[i] == i:\\n                return i    \\n        return -1\\n```\n```python\\n    def findLucky(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        cnt = [0] * (n + 1)\\n        for a in arr:\\n            if a <= n:\\n                cnt[a] += 1\\n        for i in range(n, 0, -1):\\n            if cnt[i] == i:\\n                return i\\n        return -1\\n```\n```java\\n    public int findLucky(int[] arr) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int a : arr) {\\n            freq.put(a, 1 + freq.getOrDefault(a, 0)); // Accumulate the occurrence of a.\\n        }\\n        int ans = -1;\\n        for (Map.Entry<Integer, Integer> e : freq.entrySet()) {\\n            if (e.getKey() == e.getValue()) {\\n                ans = Math.max(ans, e.getKey());\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def findLucky(self, arr: List[int]) -> int:\\n        cnt = collections.Counter(arr)\\n        return max([k for k, v in cnt.items() if k == v] + [-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 557078,
                "title": "java-100-time-100-space-o-n",
                "content": "```\\npublic int findLucky(int[] arr) {\\n        int[] nums = new int[501];\\n        for(int a : arr) nums[a]++;\\n        for(int i = 500;i>0;i--)\\n\\t\\t\\tif(nums[i]==i) return i;\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findLucky(int[] arr) {\\n        int[] nums = new int[501];\\n        for(int a : arr) nums[a]++;\\n        for(int i = 500;i>0;i--)\\n\\t\\t\\tif(nums[i]==i) return i;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684020,
                "title": "c-simple-clean-code-t-95-52",
                "content": "***Please upvote if you found the post helpful***\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        vector<int> hg;\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<arr.size();i++){\\n            freq[arr[i]]++;\\n        }\\n        for(auto num:freq){\\n            if(num.first==num.second)hg.push_back(num.first);\\n        }\\n        if(hg.size()>0)return *max_element(hg.begin(),hg.end());\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        vector<int> hg;\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<arr.size();i++){\\n            freq[arr[i]]++;\\n        }\\n        for(auto num:freq){\\n            if(num.first==num.second)hg.push_back(num.first);\\n        }\\n        if(hg.size()>0)return *max_element(hg.begin(),hg.end());\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555063,
                "title": "java-clean-o-n-solution-with-explanations",
                "content": "```\\npublic int findLucky(int[] arr) {\\n\\tMap<Integer, Integer> numToFrequency = new HashMap<>();\\n\\tfor (int num : arr) { // calculate frequency for each number\\n\\t\\tnumToFrequency.put(num, numToFrequency.getOrDefault(num, 0) + 1);\\n\\t}\\n\\tint max = -1;\\n\\tfor (int num : numToFrequency.keySet()) { // go over all of the numbers in the map\\n\\t\\tif (num == numToFrequency.get(num)) { // number which has a frequency equal to its value\\n\\t\\t\\tmax = Math.max(max, num); // keep the max value\\n\\t\\t}\\n\\t}\\n\\treturn max; // if no such number is found return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLucky(int[] arr) {\\n\\tMap<Integer, Integer> numToFrequency = new HashMap<>();\\n\\tfor (int num : arr) { // calculate frequency for each number\\n\\t\\tnumToFrequency.put(num, numToFrequency.getOrDefault(num, 0) + 1);\\n\\t}\\n\\tint max = -1;\\n\\tfor (int num : numToFrequency.keySet()) { // go over all of the numbers in the map\\n\\t\\tif (num == numToFrequency.get(num)) { // number which has a frequency equal to its value\\n\\t\\t\\tmax = Math.max(max, num); // keep the max value\\n\\t\\t}\\n\\t}\\n\\treturn max; // if no such number is found return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554920,
                "title": "javascript-hash-map",
                "content": "- Time Complexity: O(N)\\n- Space Somplexity: O(N)\\n```JavaScript\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const map = new Map();\\n    for (x of arr) {\\n        map.has(x) ? map.set(x, map.get(x) + 1) : map.set(x, 1);\\n    }\\n    return Math.max(...arr.filter(e => map.get(e) === e), -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const map = new Map();\\n    for (x of arr) {\\n        map.has(x) ? map.set(x, map.get(x) + 1) : map.set(x, 1);\\n    }\\n    return Math.max(...arr.filter(e => map.get(e) === e), -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1812301,
                "title": "easy-1ms-99-29-solution-with-explanation",
                "content": "**Hashing Approach for Find Lucky Integer in an Array**\\n\\nWe can count the occurrences of each number in one go even without sorting with the help of hashing. \\n\\nWe will follow these steps:\\n**Create a frequency array of size 501 as the value of the element could be a maximum of 500.**\\nTraverse the given array complete and store the count of each element in the frequency array.\\nNow **traverse** the frequency array from the end and if any element satisfies the condition then **return it**.\\n In the end, if no element satisfies the condition then **return -1.**\\n \\n **Java code:**\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] numbers = new int[501];\\n        \\n        for (int j : arr) { \\n\\t\\t\\tnumbers[j]++; \\n\\t\\t}\\n        \\n        for (int i = 500; i > 0; i--) { \\n\\t\\t\\tif (i == numbers[i]) return i; \\n\\t\\t}\\n        return -1;\\n    }\\n}\\n```\\n# Please ***UPVOTE*** if you find this solution helpful ***:D***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "C#"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] numbers = new int[501];\\n        \\n        for (int j : arr) { \\n\\t\\t\\tnumbers[j]++; \\n\\t\\t}\\n        \\n        for (int i = 500; i > 0; i--) { \\n\\t\\t\\tif (i == numbers[i]) return i; \\n\\t\\t}\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554803,
                "title": "python-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        count, res = {}, -1\\n        for n in arr:\\n            if n in count: count[n] += 1\\n            else: count[n] = 1\\n            \\n        for n in count:\\n            if count[n] == n: \\n                res = max(res, n)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        count, res = {}, -1\\n        for n in arr:\\n            if n in count: count[n] += 1\\n            else: count[n] = 1\\n            \\n        for n in count:\\n            if count[n] == n: \\n                res = max(res, n)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554944,
                "title": "only-3-steps-unordered-map-cpp-o-n-time",
                "content": "Three steps->\\n * Make a map for storing frequency of elements.\\n * Iterate over map checking any number == its frequency\\n * If above is true take its max \\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int maxele=-1;\\n        unordered_map<int,int> mp;\\n        for(auto k: arr)\\n            mp[k]++;                             //part 1      Created a map of element->frequency\\n        for(auto k: mp){\\n            if(k.first==k.second){                   //    part    2   If element==frequency \\n                maxele=max(maxele,k.first);            // part 3 take its max\\n            }\\n        }\\n        \\n        return maxele;\\n    }\\n};\\n```\\n**Please Upvote if you like**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int maxele=-1;\\n        unordered_map<int,int> mp;\\n        for(auto k: arr)\\n            mp[k]++;                             //part 1      Created a map of element->frequency\\n        for(auto k: mp){\\n            if(k.first==k.second){                   //    part    2   If element==frequency \\n                maxele=max(maxele,k.first);            // part 3 take its max\\n            }\\n        }\\n        \\n        return maxele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824850,
                "title": "java-beats-98-94-3-line-code-hashmap",
                "content": "**PLEASE UPVOTE THIS IF YOU LIKE IT**\\n# Approach\\nFinding out the frequency of each element using HashMap,then if the frequency matches the value then print that. but, since we have to return the largest so we will traverse from the last end;\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(arr);\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int j = arr.length - 1; j >= 0; j--) {\\n            if (map.containsKey(arr[j]) && map.get(arr[j]) == arr[j]) return arr[j];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(arr);\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int j = arr.length - 1; j >= 0; j--) {\\n            if (map.containsKey(arr[j]) && map.get(arr[j]) == arr[j]) return arr[j];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563806,
                "title": "fun-little-javascript-chained-return",
                "content": "Beats 99% too ;)\\n\\n```js\\nvar findLucky = function ( arr ) {\\n    return arr\\n        .reduce(( a, x ) => {\\n            a[x] = (a[x] || 0) + 1\\n            return a\\n        }, [])\\n        .filter(( x, i ) => x === i)\\n        .pop() || -1\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar findLucky = function ( arr ) {\\n    return arr\\n        .reduce(( a, x ) => {\\n            a[x] = (a[x] || 0) + 1\\n            return a\\n        }, [])\\n        .filter(( x, i ) => x === i)\\n        .pop() || -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554846,
                "title": "python3-easy-one-liner",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return max([k if k == v else -1 for k, v in collections.Counter(arr).items()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return max([k if k == v else -1 for k, v in collections.Counter(arr).items()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601421,
                "title": "python-easy-solution",
                "content": "```\\ndef findLucky(self, arr: List[int]) -> int:\\n        large = -1\\n        unique = set(arr)\\n        for item in unique:\\n            count = arr.count(item)\\n            if item == count:\\n                large = max(large, item)              \\n        return large\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findLucky(self, arr: List[int]) -> int:\\n        large = -1\\n        unique = set(arr)\\n        for item in unique:\\n            count = arr.count(item)\\n            if item == count:\\n                large = max(large, item)              \\n        return large\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1104175,
                "title": "using-just-one-frequency-array-simple-java-100-fast-solution",
                "content": "First make an array that will contain frequency of each elements.\\nNow traverse from last of that array and return where index number is equal to frequency.\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        int[] res = new int[501];\\n        for(int i = 0; i < arr.length; i++){\\n            res[arr[i]]++;\\n        }\\n        \\n        int j;\\n        for(j = res.length-1; j > 0; j--){\\n            if(j == res[j]){\\n                return j;\\n            }   \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        int[] res = new int[501];\\n        for(int i = 0; i < arr.length; i++){\\n            res[arr[i]]++;\\n        }\\n        \\n        int j;\\n        for(j = res.length-1; j > 0; j--){\\n            if(j == res[j]){\\n                return j;\\n            }   \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698857,
                "title": "simple-in-place-o-n-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int n,i,j,k;\\n        n=arr.size();\\n        for(i=0;i<n;i++) \\n        {\\n            if(arr[i]>n) arr[i]=-1; // For values greater than n\\n            else --arr[i];\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(arr[i]!=-1)\\n            arr[arr[i]%n] += n;  // To store frequency\\n        }\\n        for(i=0;i<n;i++) arr[i] /= n;\\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==(i+1)) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\nReference Link: https://www.***.org/count-frequencies-elements-array-o1-extra-space-time/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int n,i,j,k;\\n        n=arr.size();\\n        for(i=0;i<n;i++) \\n        {\\n            if(arr[i]>n) arr[i]=-1; // For values greater than n\\n            else --arr[i];\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(arr[i]!=-1)\\n            arr[arr[i]%n] += n;  // To store frequency\\n        }\\n        for(i=0;i<n;i++) arr[i] /= n;\\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]==(i+1)) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n\\nReference Link: https://www.***.org/count-frequencies-elements-array-o1-extra-space-time/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630282,
                "title": "3ms-70-faster-100-space",
                "content": "```\\npublic int findLucky(int[] arr) {\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int i : arr)\\n            count.put (i, count.getOrDefault(i, 0) + 1);\\n        \\n        int lucky = -1;\\n        for (int i : count.keySet()){\\n            if (i == count.get(i) && count.get(i) > lucky)\\n                lucky = i;\\n        }\\n        \\n        return lucky;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findLucky(int[] arr) {\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int i : arr)\\n            count.put (i, count.getOrDefault(i, 0) + 1);\\n        \\n        int lucky = -1;\\n        for (int i : count.keySet()){\\n            if (i == count.get(i) && count.get(i) > lucky)\\n                lucky = i;\\n        }\\n        \\n        return lucky;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 555376,
                "title": "python-56-ms-faster-than-100-00-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n\\tdef findLucky(self, arr: List[int]) -> int:\\n\\t\\ts=-1\\n\\t\\ta=Counter(arr)\\n\\t\\tb=list(set(arr))\\n\\t\\tfor i in b:\\n\\t\\t\\tif i==a[i]:\\n\\t\\t\\t\\ts=max(s,i)\\n\\t\\treturn s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findLucky(self, arr: List[int]) -> int:\\n\\t\\ts=-1\\n\\t\\ta=Counter(arr)\\n\\t\\tb=list(set(arr))\\n\\t\\tfor i in b:\\n\\t\\t\\tif i==a[i]:\\n\\t\\t\\t\\ts=max(s,i)\\n\\t\\treturn s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554836,
                "title": "java-using-hashmap",
                "content": "```\\n    public int findLucky(int[] arr) {\\n        int res = -1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : arr) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        for (int n : map.keySet()) {\\n            if (n == map.get(n)) {\\n                res = Math.max(n, res);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findLucky(int[] arr) {\\n        int res = -1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : arr) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        for (int n : map.keySet()) {\\n            if (n == map.get(n)) {\\n                res = Math.max(n, res);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098775,
                "title": "python-easy-to-understand-code-beats-100-memory-and-runtime",
                "content": "# Intuition\\nThe code appears to be trying to find a \"lucky\" integer in a given list, where a \"lucky\" integer is defined as an integer that appears exactly as many times as its value in the list.\\n\\n# Approach\\nThe code uses a brute-force approach to find the lucky integer. It iterates through the input list `arr`, counts the number of times each integer appears in the list, and checks if the count is equal to the value of the integer itself. If it is, the integer is considered lucky, and it is appended to the `f` list. Finally, if there are lucky integers in the list, it returns the largest lucky integer; otherwise, it returns -1.\\n\\n# Complexity\\n- Time complexity: The code uses a nested loop with `arr.count(arr[i])`, which has a time complexity of O(n^2), where n is the length of the input list `arr`. Sorting the `f` list adds an additional O(n*log(n)) time complexity. So, the overall time complexity is O(n^2 + n*log(n)), which simplifies to O(n^2) because the quadratic term dominates.\\n  \\n- Space complexity: The code uses additional space to store the `f` list, which can have a maximum of n elements, where n is the length of the input list `arr`. Therefore, the space complexity is O(n).\\n\\nOverall, the code can be optimized to achieve better time complexity by using a more efficient approach.[]()\\n# Code\\n```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        x=0\\n        f=[]\\n        for i in range(len(arr)):\\n            if arr.count(arr[i])==arr[i]:\\n                x+=1\\n                f.append(arr[i])\\n        if x==0:\\n            return -1\\n        else:\\n            f=sorted(f)\\n            return f[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        x=0\\n        f=[]\\n        for i in range(len(arr)):\\n            if arr.count(arr[i])==arr[i]:\\n                x+=1\\n                f.append(arr[i])\\n        if x==0:\\n            return -1\\n        else:\\n            f=sorted(f)\\n            return f[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151390,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]++;\\n        }\\n        int ans=-1;\\n        for(auto it:m)\\n        {\\n            if(it.first==it.second)\\n            {\\n                ans=max(ans,it.first);\\n                \\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/6938e743-dc73-4ca9-8592-bbca15f89ed3_1675693514.2845347.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]++;\\n        }\\n        int ans=-1;\\n        for(auto it:m)\\n        {\\n            if(it.first==it.second)\\n            {\\n                ans=max(ans,it.first);\\n                \\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454532,
                "title": "c-frequency-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int f[501] = {} ;\\n        for(auto &x : arr) ++f[x] ;\\n        for(int i = 500 ; i >= 1 ; --i){\\n            if(f[i] == i) return i ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int f[501] = {} ;\\n        for(auto &x : arr) ++f[x] ;\\n        for(int i = 500 ; i >= 1 ; --i){\\n            if(f[i] == i) return i ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947180,
                "title": "fastest-smartest-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) \\n    {\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        for(int i:arr)\\n            hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        int max=-1;\\n        for(Integer key:hmap.keySet())\\n        {\\n            if(hmap.get(key)==key && key>max)\\n                max=key;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findLucky(int[] arr) \\n    {\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        for(int i:arr)\\n            hmap.put(i,hmap.getOrDefault(i,0)+1);\\n        int max=-1;\\n        for(Integer key:hmap.keySet())\\n        {\\n            if(hmap.get(key)==key && key>max)\\n                max=key;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1461623,
                "title": "python-3-simple-solution-using-count-one-liner",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return max(i if arr.count(i) == i else -1 for i in arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return max(i if arr.count(i) == i else -1 for i in arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930162,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar findLucky = function(arr) {\\n    let max = -1\\n    \\n    const map = {}\\n    \\n    for(const number of arr) {\\n        if(map[number]) {\\n            map[number] += 1\\n        } else {\\n            map[number] = 1\\n        }\\n    }\\n    \\n    for(const key in map) {\\n        if(Number(key) === map[key] && map[key] > max) {\\n            max = map[key]\\n        }\\n    }\\n    \\n    return max\\n};\\n```\\n\\n```\\n// time O(n) space O(n)\\nvar findLucky = function(arr) {\\n    const map = new Map()\\n    const luckyNumbers = []\\n    \\n    for(const item of arr) {\\n        map.set(item, map.get(item) + 1 || 1)    \\n    }\\n    \\n    for(const [key, value] of map) {\\n        if(key === value) {\\n            luckyNumbers.push(key)\\n        }\\n    }\\n    \\n    return luckyNumbers.length ? Math.max(...luckyNumbers) : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar findLucky = function(arr) {\\n    let max = -1\\n    \\n    const map = {}\\n    \\n    for(const number of arr) {\\n        if(map[number]) {\\n            map[number] += 1\\n        } else {\\n            map[number] = 1\\n        }\\n    }\\n    \\n    for(const key in map) {\\n        if(Number(key) === map[key] && map[key] > max) {\\n            max = map[key]\\n        }\\n    }\\n    \\n    return max\\n};\\n```\n```\\n// time O(n) space O(n)\\nvar findLucky = function(arr) {\\n    const map = new Map()\\n    const luckyNumbers = []\\n    \\n    for(const item of arr) {\\n        map.set(item, map.get(item) + 1 || 1)    \\n    }\\n    \\n    for(const [key, value] of map) {\\n        if(key === value) {\\n            luckyNumbers.push(key)\\n        }\\n    }\\n    \\n    return luckyNumbers.length ? Math.max(...luckyNumbers) : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593169,
                "title": "javascript-o-n-w-comments",
                "content": "```\\nfunction findLucky(arr) {\\n    // map to counts of each number\\n    const map = new Map();\\n\\t\\n    // iter thru arr\\n    for (let i = 0; i < arr.length; i++) {\\n        // check if not seen number before\\n        if (!map.has(arr[i]))\\n            map.set(arr[i], 0);\\n        // increment count\\n        map.set(arr[i], map.get(arr[i]) + 1);\\n    }\\n\\t\\n    // current max number\\n    let max = -1;\\n\\t\\n\\t// go thru map entries\\n    for (const e of map.entries()) {\\n        // check if num equal to keys\\n        if (e[0] === e[1]) {\\n            // take max\\n            max = Math.max(max, e[0]);\\n        }\\n    }\\n\\t\\n    return max;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findLucky(arr) {\\n    // map to counts of each number\\n    const map = new Map();\\n\\t\\n    // iter thru arr\\n    for (let i = 0; i < arr.length; i++) {\\n        // check if not seen number before\\n        if (!map.has(arr[i]))\\n            map.set(arr[i], 0);\\n        // increment count\\n        map.set(arr[i], map.get(arr[i]) + 1);\\n    }\\n\\t\\n    // current max number\\n    let max = -1;\\n\\t\\n\\t// go thru map entries\\n    for (const e of map.entries()) {\\n        // check if num equal to keys\\n        if (e[0] === e[1]) {\\n            // take max\\n            max = Math.max(max, e[0]);\\n        }\\n    }\\n\\t\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 556751,
                "title": "java-faster-then-99-90-memory-usage-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int res = -1;\\n        \\n        if (arr == null || arr.length == 0)\\n            return res;\\n        \\n        int[] store = new int[500+1]; // if we read the Constraints, the max length is 500\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            store[arr[i]]++; // increment each elements in the store arr\\n        }\\n        \\n        for (int i = store.length - 1; i >= 1; i--) { // iterate from the end\\n            if (store[i] == i) // find the max element from the end, which equals condtions of the lucky integer\\n                return store[i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\ncomplexity = O(N)+constant(500)=O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int res = -1;\\n        \\n        if (arr == null || arr.length == 0)\\n            return res;\\n        \\n        int[] store = new int[500+1]; // if we read the Constraints, the max length is 500\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            store[arr[i]]++; // increment each elements in the store arr\\n        }\\n        \\n        for (int i = store.length - 1; i >= 1; i--) { // iterate from the end\\n            if (store[i] == i) // find the max element from the end, which equals condtions of the lucky integer\\n                return store[i];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555103,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int FindLucky(int[] arr) \\n    {\\n        var freq = new int[501];\\n        foreach(var num in arr)\\n            freq[num]++;\\n        \\n        for(int i = 500; i >= 1; i--)\\n            if(freq[i] == i)\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int FindLucky(int[] arr) \\n    {\\n        var freq = new int[501];\\n        foreach(var num in arr)\\n            freq[num]++;\\n        \\n        for(int i = 500; i >= 1; i--)\\n            if(freq[i] == i)\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005307,
                "title": "easy-java-solution-with-nested-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int rnNum = -1;\\n        for(int i = 0; i < arr.length; i++){\\n            int num = arr[i];\\n            int count = 0;\\n            for(int j = 0; j < arr.length; j++){\\n                int numIn = arr[j];\\n                if(num == numIn){\\n                    count++;\\n                }\\n            }\\n            if(num == count){\\n                if(num > rnNum){\\n                    rnNum = num;\\n                }\\n            }\\n        }\\n        return rnNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int rnNum = -1;\\n        for(int i = 0; i < arr.length; i++){\\n            int num = arr[i];\\n            int count = 0;\\n            for(int j = 0; j < arr.length; j++){\\n                int numIn = arr[j];\\n                if(num == numIn){\\n                    count++;\\n                }\\n            }\\n            if(num == count){\\n                if(num > rnNum){\\n                    rnNum = num;\\n                }\\n            }\\n        }\\n        return rnNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003950,
                "title": "using-hashmap-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                int val=hm.get(arr[i]);\\n                hm.put(arr[i],val+1);\\n            }else{\\n                hm.put(arr[i],1);\\n            }\\n        }\\n\\n        int max=-1;\\n        for(int num:hm.keySet()){\\n            if(num==hm.get(num)){\\n                max=num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                int val=hm.get(arr[i]);\\n                hm.put(arr[i],val+1);\\n            }else{\\n                hm.put(arr[i],1);\\n            }\\n        }\\n\\n        int max=-1;\\n        for(int num:hm.keySet()){\\n            if(num==hm.get(num)){\\n                max=num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655984,
                "title": "simple-solution-using-dictionary-in-python",
                "content": "\\n```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dic={}\\n        l=[]\\n        for i in arr:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        for i in dic:\\n            if i==dic[i]:\\n                l.append(i)\\n        if(len(l)<1):\\n            return -1\\n        return max(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dic={}\\n        l=[]\\n        for i in arr:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        for i in dic:\\n            if i==dic[i]:\\n                l.append(i)\\n        if(len(l)<1):\\n            return -1\\n        return max(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503221,
                "title": "pure-javascript-without-using-set-map-object",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    let count=0;\\n    let value=0;\\n    for(let i=0;i<arr.length;i++){\\n        for(let j=0;j<arr.length;j++){\\n            if( arr[i]===arr[j]){\\n                count++;\\n            }\\n        }\\n       \\n        if(count===arr[i] && value<arr[i]){\\n            value=arr[i];\\n        }\\n          count=0;\\n    }\\n\\n    return value>0 ? value : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    let count=0;\\n    let value=0;\\n    for(let i=0;i<arr.length;i++){\\n        for(let j=0;j<arr.length;j++){\\n            if( arr[i]===arr[j]){\\n                count++;\\n            }\\n        }\\n       \\n        if(count===arr[i] && value<arr[i]){\\n            value=arr[i];\\n        }\\n          count=0;\\n    }\\n\\n    return value>0 ? value : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461290,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        read the code and u will understand\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        //create a hashMap\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        // need arraylist to keep track of maxm of them\\n        List<Integer> ls= new ArrayList<>();\\n\\n\\n        for(int a: arr){\\n            // if contains\\n            if(map.containsKey(a)){\\n                map.put(a, map.get(a)+1);\\n            }else{\\n                map.put(a,1);\\n                    ls.add(a);\\n\\n            }\\n        }\\n        // we need to sort the arraylist in descending order\\n        Collections.sort(ls, Collections.reverseOrder());\\n\\n        for(int i=0;i<ls.size();i++){\\n            if(ls.get(i)==map.get(ls.get(i))) return ls.get(i);\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        //create a hashMap\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        // need arraylist to keep track of maxm of them\\n        List<Integer> ls= new ArrayList<>();\\n\\n\\n        for(int a: arr){\\n            // if contains\\n            if(map.containsKey(a)){\\n                map.put(a, map.get(a)+1);\\n            }else{\\n                map.put(a,1);\\n                    ls.add(a);\\n\\n            }\\n        }\\n        // we need to sort the arraylist in descending order\\n        Collections.sort(ls, Collections.reverseOrder());\\n\\n        for(int i=0;i<ls.size();i++){\\n            if(ls.get(i)==map.get(ls.get(i))) return ls.get(i);\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185304,
                "title": "easy-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n      unordered_map<int,int>mp;\\n      for( int x=0;x<arr.size();x++)\\n      {\\n          mp[arr[x]]++;\\n      }\\n      vector<int>ans;\\n      for(auto i:mp)\\n      {\\n          if(i.first==i.second)\\n          {\\n             ans.push_back(i.first);\\n          }\\n      }\\n      sort(ans.begin(),ans.end());\\n      if(ans.size()==0)\\n      {\\n          return -1;\\n      }\\n      else\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n      unordered_map<int,int>mp;\\n      for( int x=0;x<arr.size();x++)\\n      {\\n          mp[arr[x]]++;\\n      }\\n      vector<int>ans;\\n      for(auto i:mp)\\n      {\\n          if(i.first==i.second)\\n          {\\n             ans.push_back(i.first);\\n          }\\n      }\\n      sort(ans.begin(),ans.end());\\n      if(ans.size()==0)\\n      {\\n          return -1;\\n      }\\n      else\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793486,
                "title": "java-2-solutions-hashmap-frequency-array-easy",
                "content": "### **Please Upvote** :D\\n##### 1. Using HashMap:\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int n : arr) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        int max = -1;\\n\\n        for (int n : map.keySet()) {\\n            if (n == map.get(n)) {\\n                max = Math.max(max, n);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n + k), SC: O(k)\\n// n -> length of arr\\n// k -> size of hashmap / number of unique elements\\n```\\n##### 2. Using Frequency array:\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] freq = new int[501];\\n        for (int n : arr) freq[n]++;\\n\\n        int max = -1;\\n\\n        for (int i = 1; i < 501; i++) {\\n            if (freq[i] == i) {\\n                max = Math.max(max, i);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int n : arr) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        int max = -1;\\n\\n        for (int n : map.keySet()) {\\n            if (n == map.get(n)) {\\n                max = Math.max(max, n);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n + k), SC: O(k)\\n// n -> length of arr\\n// k -> size of hashmap / number of unique elements\\n```\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] freq = new int[501];\\n        for (int n : arr) freq[n]++;\\n\\n        int max = -1;\\n\\n        for (int i = 1; i < 501; i++) {\\n            if (freq[i] == i) {\\n                max = Math.max(max, i);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568215,
                "title": "time-complexity-of-my-solution",
                "content": "please can anyone help me with time coplexity of my noob solution,\\n```\\n\\t\\tlucky_list = []\\n        for i in set(arr):\\n            if arr.count(i) == i:\\n                lucky_list.append(i)\\n        if len(lucky_list)>0:\\n            return max(lucky_list)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\n\\t\\tlucky_list = []\\n        for i in set(arr):\\n            if arr.count(i) == i:\\n                lucky_list.append(i)\\n        if len(lucky_list)>0:\\n            return max(lucky_list)\\n        return -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2463673,
                "title": "runtime-3-ms-faster-than-97-29-of-c-online-submissions",
                "content": "```\\n/*** 1394. Find Lucky Integer in an Array ***/\\n\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        vector<int> ans;\\n        //hashing\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<arr.size();++i){\\n            mp[arr[i]]++;\\n        }\\n        for(auto i : mp){\\n           if(i.first==i.second) ans.push_back(i.second);\\n        }\\n        sort(ans.begin(),ans.end());\\n        if(ans.size()>=1) return ans[ans.size()-1];\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*** 1394. Find Lucky Integer in an Array ***/\\n\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        vector<int> ans;\\n        //hashing\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<arr.size();++i){\\n            mp[arr[i]]++;\\n        }\\n        for(auto i : mp){\\n           if(i.first==i.second) ans.push_back(i.second);\\n        }\\n        sort(ans.begin(),ans.end());\\n        if(ans.size()>=1) return ans[ans.size()-1];\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264998,
                "title": "easy-c-solution-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        vector<int> NumCnt (501, 0); // counts numbers\\n        int Answer = -1; // -1 if there is no lucky integer\\n        for (int i = 0; i < arr.size(); ++i)\\n            NumCnt[arr[i]]++; // counting frequencies\\n        for (int i = 0; i < arr.size(); ++i) // finding the answer\\n            if (arr[i] == NumCnt[arr[i]]) // if is a lucky integer\\n                if (Answer < arr[i]) // and its larger than the answer\\n                    Answer = arr[i]; // let the answer be the new lucky integer\\n        return Answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        vector<int> NumCnt (501, 0); // counts numbers\\n        int Answer = -1; // -1 if there is no lucky integer\\n        for (int i = 0; i < arr.size(); ++i)\\n            NumCnt[arr[i]]++; // counting frequencies\\n        for (int i = 0; i < arr.size(); ++i) // finding the answer\\n            if (arr[i] == NumCnt[arr[i]]) // if is a lucky integer\\n                if (Answer < arr[i]) // and its larger than the answer\\n                    Answer = arr[i]; // let the answer be the new lucky integer\\n        return Answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768913,
                "title": "easy-java-arrays",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] f =new int[arr.length];\\n        for(int i = 0;i<arr.length;i++){\\n            for(int j = 0;j<arr.length ;j++){\\n                if(arr[i]==arr[j]){\\n                    f[i]++;\\n                }\\n            }\\n        }\\n        int m=0,max=0;\\n        for(int i = 0 ;i<f.length;i++){\\n            if(max<f[i] && f[i]==arr[i]){\\n                max=f[i];\\n                m = i;\\n            }\\n        }\\n        if(max == 0 ){\\n            return -1;\\n        }\\n        return arr[m];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] f =new int[arr.length];\\n        for(int i = 0;i<arr.length;i++){\\n            for(int j = 0;j<arr.length ;j++){\\n                if(arr[i]==arr[j]){\\n                    f[i]++;\\n                }\\n            }\\n        }\\n        int m=0,max=0;\\n        for(int i = 0 ;i<f.length;i++){\\n            if(max<f[i] && f[i]==arr[i]){\\n                max=f[i];\\n                m = i;\\n            }\\n        }\\n        if(max == 0 ){\\n            return -1;\\n        }\\n        return arr[m];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728271,
                "title": "java-easy-solution-runtime-1ms",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int freq[]=new int[501];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            freq[arr[i]]++;\\n        }\\n        int lucky=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(freq[arr[i]]==arr[i])\\n                lucky=Math.max(lucky,arr[i]);\\n        }\\n        return lucky==0? -1 : lucky;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int freq[]=new int[501];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            freq[arr[i]]++;\\n        }\\n        int lucky=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(freq[arr[i]]==arr[i])\\n                lucky=Math.max(lucky,arr[i]);\\n        }\\n        return lucky==0? -1 : lucky;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216596,
                "title": "c-simple-map-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLucky(vector<int>& arr) {\\n\\t\\t\\tunordered_map<int, int> um;\\n\\t\\t\\tfor(auto i : arr){\\n\\t\\t\\t\\tum[i]++;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto i : um){\\n\\t\\t\\t\\tif(i.second == i.first){\\n\\t\\t\\t\\t\\tres = max(res, i.first);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(res == 0){\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findLucky(vector<int>& arr) {\\n\\t\\t\\tunordered_map<int, int> um;\\n\\t\\t\\tfor(auto i : arr){\\n\\t\\t\\t\\tum[i]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1182827,
                "title": "rust-faster-than-100",
                "content": "1. this solution makes use of compiler magic, as the data structure is cache-able for all sizes of input. \\n2. linear at worst no matter what right?  sure, but we can hit cache and leave the second for loop by abusing the ordering :)! very friendly for our processor\\'s branch prediction as well with the data structure. \\n\\n```rust\\n\\nuse std::collections::BTreeMap;\\nimpl Solution {\\n     pub fn find_lucky(arr: Vec<i32>) -> i32 {\\n        let mut is_it_lucky: BTreeMap<i32, i32> = std::collections::BTreeMap::new();\\n\\n        for value in arr {\\n            if is_it_lucky.contains_key(&value) {\\n                if let Some(number) = is_it_lucky.get_mut(&value) {\\n                    *number += 1;\\n                }\\n            } else {\\n                is_it_lucky.insert(value, 1);\\n            }\\n        }\\n\\n        for (key, value) in is_it_lucky.iter().rev() {\\n            if key == value {\\n                return *value;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```rust\\n\\nuse std::collections::BTreeMap;\\nimpl Solution {\\n     pub fn find_lucky(arr: Vec<i32>) -> i32 {\\n        let mut is_it_lucky: BTreeMap<i32, i32> = std::collections::BTreeMap::new();\\n\\n        for value in arr {\\n            if is_it_lucky.contains_key(&value) {\\n                if let Some(number) = is_it_lucky.get_mut(&value) {\\n                    *number += 1;\\n                }\\n            } else {\\n                is_it_lucky.insert(value, 1);\\n            }\\n        }\\n\\n        for (key, value) in is_it_lucky.iter().rev() {\\n            if key == value {\\n                return *value;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121583,
                "title": "rust-solution-in-a-single-statement-o-n-0ms-2mb",
                "content": "```rust\\nimpl Solution {\\n    pub fn find_lucky(arr: Vec<i32>) -> i32 {\\n        arr\\n            .iter()\\n            .fold(std::collections::HashMap::new(), |mut map, n| {\\n                map.entry(n).and_modify(|ct| {*ct+=1}).or_insert(1);\\n                map\\n            })\\n            .into_iter()\\n            .filter_map(|(&k,v)| if k==v {Some(k)} else {None})\\n            .max()\\n            .unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_lucky(arr: Vec<i32>) -> i32 {\\n        arr\\n            .iter()\\n            .fold(std::collections::HashMap::new(), |mut map, n| {\\n                map.entry(n).and_modify(|ct| {*ct+=1}).or_insert(1);\\n                map\\n            })\\n            .into_iter()\\n            .filter_map(|(&k,v)| if k==v {Some(k)} else {None})\\n            .max()\\n            .unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057766,
                "title": "scala-one-line",
                "content": "```object Solution {\\n    def findLucky(arr: Array[Int]): Int = {\\n        arr.zip(arr.map(x => arr.count(_ == x))).map(x => if (x._1 == x._2) x._1 else -1).max\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```object Solution {\\n    def findLucky(arr: Array[Int]): Int = {\\n        arr.zip(arr.map(x => arr.count(_ == x))).map(x => if (x._1 == x._2) x._1 else -1).max\\n        \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1055729,
                "title": "simple-c-solution",
                "content": "\\n```\\nint findLucky(int* arr, int arrSize){\\n    \\n    int i,j,sum=-1;\\n    \\n    for(i=0;i<arrSize;i++)\\n    {\\n        int sun=0;\\n        for(j=0;j<arrSize;j++)\\n        {\\n            if(arr[i]==arr[j])\\n            {\\n                sun=sun+1;\\n            }\\n        }\\n        if(sun==arr[i])\\n        {\\n            if(arr[i]>sum)\\n            {\\n                sum=arr[i];\\n            }\\n        }\\n    }\\n    \\n    return sum;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findLucky(int* arr, int arrSize){\\n    \\n    int i,j,sum=-1;\\n    \\n    for(i=0;i<arrSize;i++)\\n    {\\n        int sun=0;\\n        for(j=0;j<arrSize;j++)\\n        {\\n            if(arr[i]==arr[j])\\n            {\\n                sun=sun+1;\\n            }\\n        }\\n        if(sun==arr[i])\\n        {\\n            if(arr[i]>sum)\\n            {\\n                sum=arr[i];\\n            }\\n        }\\n    }\\n    \\n    return sum;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997657,
                "title": "easy-understanding-c-solution",
                "content": "Easy solution using count() method and storing maximum value in a variable.\\n\\nC++ \\n``` \\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int ans=0;\\n        for(int i=0;i<arr.size();){\\n            int temp=count(arr.begin()+i,arr.end(),arr[i]);\\n            if(temp==arr[i]){ans=arr[i];}\\n            i=i+temp;\\n        }\\n        if(ans==0){return -1;}\\n        return ans;\\n    }\\n};\\n```\\nCount() function counts frequency of given element in range specified.\\nWe sort array so that counting can be easy and incrementing \"i\" in for loop can be easy, we increment i by frequency of previous element.\\n*If you like or understand the solution dont forget to upvote ^^.*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int ans=0;\\n        for(int i=0;i<arr.size();){\\n            int temp=count(arr.begin()+i,arr.end(),arr[i]);\\n            if(temp==arr[i]){ans=arr[i];}\\n            i=i+temp;\\n        }\\n        if(ans==0){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996992,
                "title": "c-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int ans=-1;\\n        unordered_map<int, int> map;\\n        \\n        for(int i=0; i<n; i++){\\n            map[arr[i]]++;\\n        }\\n        \\n        for(auto num: map){\\n            if(num.second == num.first)\\n                ans=max(num.first, ans);\\n        }\\n        \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int ans=-1;\\n        unordered_map<int, int> map;\\n        \\n        for(int i=0; i<n; i++){\\n            map[arr[i]]++;\\n        }\\n        \\n        for(auto num: map){\\n            if(num.second == num.first)\\n                ans=max(num.first, ans);\\n        }\\n        \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979043,
                "title": "java-solution-o-n-time-o-1-space-1ms-faster-than-99",
                "content": "**Please upvote if you like and understand the solution.**\\n\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int count[] = new int[500];\\n        \\n        for(int i=0; i<arr.length; i++){\\n            count[arr[i]-1]++;\\n        }\\n        \\n        for(int i=499; i>=0; i--){\\n            if(count[i] == i+1)\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int count[] = new int[500];\\n        \\n        for(int i=0; i<arr.length; i++){\\n            count[arr[i]-1]++;\\n        }\\n        \\n        for(int i=499; i>=0; i--){\\n            if(count[i] == i+1)\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770368,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int freq[501] = {0};\\n        \\n        for(int i = 0;i<arr.size();i++){\\n            freq[arr[i]]++;\\n        }\\n        for(int i = 500;i>=1;i--){\\n            if (freq[i] == i) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int freq[501] = {0};\\n        \\n        for(int i = 0;i<arr.size();i++){\\n            freq[arr[i]]++;\\n        }\\n        for(int i = 500;i>=1;i--){\\n            if (freq[i] == i) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697604,
                "title": "python-concise-counter-solution-beats-90",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        counter = Counter(arr)\\n        \\n        result = [(k, v) for k, v in counter.items() if k == v]\\n        return max(result)[0] if result else -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        counter = Counter(arr)\\n        \\n        result = [(k, v) for k, v in counter.items() if k == v]\\n        return max(result)[0] if result else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632513,
                "title": "ruby-solution",
                "content": "```\\ndef find_lucky(arr)\\n    count = Hash.new { 0 }\\n    arr.each { |number| count[number] += 1 }\\n    count.keys.select { |key| key == count[key] }.max || -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_lucky(arr)\\n    count = Hash.new { 0 }\\n    arr.each { |number| count[number] += 1 }\\n    count.keys.select { |key| key == count[key] }.max || -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 623214,
                "title": "two-kinds-of-javascript-solution-which-beat-98",
                "content": ">Runtime: 52 ms, faster than 95.47% of JavaScript online submissions for Find Lucky Integer in an Array.\\nMemory Usage: 34.7 MB, less than 100.00% of JavaScript online submissions for Find Lucky Integer in an Array.\\n\\n```js\\nvar findLucky = function(arr) {\\n    const map = arr.reduce((map,e) => {\\n        if (map[e]) {\\n            map[e]++\\n        } else {\\n            map[e] = 1\\n        }\\n        return map\\n    }, {})\\n    let res = -1\\n    for (let key in map) {\\n        if (map[key] == key) {\\n            res = key\\n        }\\n    }\\n    return res\\n};\\n```\\n\\n\\n>Runtime: 56 ms, faster than 84.37% of JavaScript online submissions for Find Lucky Integer in an Array.\\nMemory Usage: 34.7 MB, less than 100.00% of JavaScript online submissions for Find Lucky Integer in an Array.\\n\\n```js\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const map = {}\\n    let res = -1\\n    arr.forEach((e,i) => {\\n        if (map[e]) {\\n            map[e]++\\n        } else {\\n            map[e] = 1\\n        }\\n    })\\n    for (let key in map) {\\n        if (map[key] == key) {\\n            res = key\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar findLucky = function(arr) {\\n    const map = arr.reduce((map,e) => {\\n        if (map[e]) {\\n            map[e]++\\n        } else {\\n            map[e] = 1\\n        }\\n        return map\\n    }, {})\\n    let res = -1\\n    for (let key in map) {\\n        if (map[key] == key) {\\n            res = key\\n        }\\n    }\\n    return res\\n};\\n```\n```js\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const map = {}\\n    let res = -1\\n    arr.forEach((e,i) => {\\n        if (map[e]) {\\n            map[e]++\\n        } else {\\n            map[e] = 1\\n        }\\n    })\\n    for (let key in map) {\\n        if (map[key] == key) {\\n            res = key\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 622194,
                "title": "javascript-solution-95-47-time-and-100-memory-efficient",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    let myMap= new Map()\\n    let max = 0;\\n    \\n    //create a map to store frequency counts\\n    for(let i of arr){\\n        if(myMap.has(i)){\\n            myMap.set(i, myMap.get(i)+1);\\n        }else{\\n            myMap.set(i,1);\\n        }\\n    }\\n    \\n    //loop through map to find lucky numbers and modify the max value\\n    for(let [index, value] of myMap){\\n        if(index == value){\\n            max = Math.max(max,value)\\n        }\\n    }\\n    \\n    return max > 0 ? max : -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    let myMap= new Map()\\n    let max = 0;\\n    \\n    //create a map to store frequency counts\\n    for(let i of arr){\\n        if(myMap.has(i)){\\n            myMap.set(i, myMap.get(i)+1);\\n        }else{\\n            myMap.set(i,1);\\n        }\\n    }\\n    \\n    //loop through map to find lucky numbers and modify the max value\\n    for(let [index, value] of myMap){\\n        if(index == value){\\n            max = Math.max(max,value)\\n        }\\n    }\\n    \\n    return max > 0 ? max : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620338,
                "title": "c-using-count-array-99-80-faster-and-100-less-storage",
                "content": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        vector<int> count_arr(501,0);\\n        int i,max=-1;\\n        \\n        for(i=0;i<arr.size();i++)\\n            count_arr[arr[i]]++;  //calculate the frequency of each element\\n        \\n        for(i=0;i<arr.size();i++)\\n            if(arr[i] == count_arr[arr[i]] && arr[i]>max)\\n                max = arr[i];\\n                \\n        return max;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        vector<int> count_arr(501,0);\\n        int i,max=-1;\\n        \\n        for(i=0;i<arr.size();i++)\\n            count_arr[arr[i]]++;  //calculate the frequency of each element\\n        \\n        for(i=0;i<arr.size();i++)\\n            if(arr[i] == count_arr[arr[i]] && arr[i]>max)\\n                max = arr[i];\\n                \\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 556234,
                "title": "c-simple-solution-using-map-t-84-83-m-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int>m;\\n        for(auto item:arr){\\n            m[item]++;\\n        }\\n        for(auto it=m.rbegin();it!=m.rend();it++){\\n            if(it->first==it->second)return it->first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int>m;\\n        for(auto item:arr){\\n            m[item]++;\\n        }\\n        for(auto it=m.rbegin();it!=m.rend();it++){\\n            if(it->first==it->second)return it->first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555745,
                "title": "javascript-100-time-and-memory",
                "content": "\\n```js\\nvar findLucky = function(arr) {\\n    let bucket = Array(501).fill(0);\\n    arr.forEach(a => bucket[a]++);\\n    for(let i =501; i>=1; i--){\\n        if(bucket[i] == i) return i\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar findLucky = function(arr) {\\n    let bucket = Array(501).fill(0);\\n    arr.forEach(a => bucket[a]++);\\n    for(let i =501; i>=1; i--){\\n        if(bucket[i] == i) return i\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082151,
                "title": "hashmap-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nWe use HashMap to solve this problem\\n# Approach\\nWe store frequency of nums in array into map, then iterate over map and if number is lucky we check that if it\\'s larger than current lucky number then we set it as lucky number\\n# Complexity\\n- Time complexity:\\nO(n) -> 2n iterations once over frequency map and once over array of nums\\n- Space complexity:\\nO(n) -> we use map to store frequency map to check for lucky numbers\\n# Code\\n```\\nfunction findLucky(arr: number[]): number {\\n    // declare HashMap to store numbers frequency\\n    const map = new Map<number, number>();\\n    // declare lucky number and set it as -1\\n    let lucky = -1;\\n    // iterate over numbers array and calculate frequency of each number\\n    arr.forEach((num) => map.set(num, map.has(num) ? map.get(num) + 1 : 1))\\n    // iterate over frequency map:\\n    map.forEach((value, key) => {\\n        // check if number is lucky and if true then set largest number as lucky number\\n        lucky = value === key ? Math.max(value, lucky) : lucky;\\n    })\\n    // return lucky number\\n    return lucky;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findLucky(arr: number[]): number {\\n    // declare HashMap to store numbers frequency\\n    const map = new Map<number, number>();\\n    // declare lucky number and set it as -1\\n    let lucky = -1;\\n    // iterate over numbers array and calculate frequency of each number\\n    arr.forEach((num) => map.set(num, map.has(num) ? map.get(num) + 1 : 1))\\n    // iterate over frequency map:\\n    map.forEach((value, key) => {\\n        // check if number is lucky and if true then set largest number as lucky number\\n        lucky = value === key ? Math.max(value, lucky) : lucky;\\n    })\\n    // return lucky number\\n    return lucky;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073451,
                "title": "c-solution-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nunordered_map<int, int> mp;: An unordered map is created to store the frequency of each number in the input vector arr. The key of the map represents the number, and the value represents the frequency of that number.\\n\\nfor (auto v : arr) { mp[v]++; }: This loop iterates through the elements of the input vector arr. For each element v, it increments the corresponding value in the map mp. This effectively counts the frequency of each number in the vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nint lucky = -1;: This initializes a variable lucky to -1. This variable will be used to keep track of the lucky number found in the vector. We initialize it to -1 because we don\\'t know yet if a lucky number exists in the vector.\\n\\nfor (auto k : mp) { ... }: This loop iterates through the key-value pairs in the map mp. Each pair consists of a number (k.first) and its frequency (k.second).\\n\\nif (k.first == k.second) { lucky = max(lucky, k.first); }: Inside the loop, it checks if the current number (k.first) is equal to its frequency (k.second). If they are equal, it means this number is lucky according to the definition. It then updates the lucky variable with the maximum of its current value and the current lucky number found. This is done using max(lucky, k.first) to ensure that we keep track of the largest lucky number found so far.\\n\\nFinally, the function returns the value of the lucky variable, which will be the largest lucky number found in the input vector arr.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        for (auto v : arr) {\\n            mp[v]++;\\n        }\\n        int lucky = -1; \\n        for (auto k : mp) {\\n            if (k.first == k.second) {\\n                lucky = max(lucky, k.first); \\n            }\\n        }\\n         return lucky;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        for (auto v : arr) {\\n            mp[v]++;\\n        }\\n        int lucky = -1; \\n        for (auto k : mp) {\\n            if (k.first == k.second) {\\n                lucky = max(lucky, k.first); \\n            }\\n        }\\n         return lucky;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814481,
                "title": "javascript-solution-using-map",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const myMap = new Map();\\nfor(let i=0; i<arr.length; i++){\\n    if(myMap.has(arr[i])){\\n        myMap.set(arr[i],myMap.get(arr[i])+1);\\n    }else{\\n        myMap.set(arr[i],1);\\n    }\\n}\\nlet luckyInt = -1;\\nfor(let i=0; i<arr.length; i++){\\n    if(myMap.get(arr[i]) == arr[i]){\\n        if(arr[i]>luckyInt){\\n            luckyInt = arr[i];\\n        }\\n    }\\n}\\nreturn luckyInt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const myMap = new Map();\\nfor(let i=0; i<arr.length; i++){\\n    if(myMap.has(arr[i])){\\n        myMap.set(arr[i],myMap.get(arr[i])+1);\\n    }else{\\n        myMap.set(arr[i],1);\\n    }\\n}\\nlet luckyInt = -1;\\nfor(let i=0; i<arr.length; i++){\\n    if(myMap.get(arr[i]) == arr[i]){\\n        if(arr[i]>luckyInt){\\n            luckyInt = arr[i];\\n        }\\n    }\\n}\\nreturn luckyInt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3554810,
                "title": "easy-solution-using-hashmap-java",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple keep track of numbers count using HashMap after that we have to just iterate over keyset and compare it with value if they are equal update the value like that we have to find the max element if no such number is present in the array then we have to return -1.\\n\\nPLEASE UPVOTE.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(arr[i])) map.put(arr[i],map.get(arr[i])+1);\\n            else map.put(arr[i],1);\\n        }\\n        int val=-1;\\n        for(int value:map.keySet()){\\n            if(value==map.get(value)) val=Math.max(val,value);\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(arr[i])) map.put(arr[i],map.get(arr[i])+1);\\n            else map.put(arr[i],1);\\n        }\\n        int val=-1;\\n        for(int value:map.keySet()){\\n            if(value==map.get(value)) val=Math.max(val,value);\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503413,
                "title": "easy-js-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function (arr) {\\n    var ln = -1, count;\\n    for (i = 0; i < arr.length; i++) {\\n        count = 0;\\n        if (arr[i] > ln) {\\n            for (j = 0; j < arr.length; j++) {\\n                if (arr[i] === arr[j]) count++;\\n            }\\n            if (count === arr[i]) ln = arr[i];\\n        }\\n    }\\n\\n    return ln\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function (arr) {\\n    var ln = -1, count;\\n    for (i = 0; i < arr.length; i++) {\\n        count = 0;\\n        if (arr[i] > ln) {\\n            for (j = 0; j < arr.length; j++) {\\n                if (arr[i] === arr[j]) count++;\\n            }\\n            if (count === arr[i]) ln = arr[i];\\n        }\\n    }\\n\\n    return ln\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359941,
                "title": "find-lucky-integer-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int i, lucky_number=-1;\\n        sort(arr.begin(), arr.end());\\n        for(i=arr.size()-1 ; i>=0 ; i--)\\n        {\\n            if(arr[i]==count(arr.begin(), arr.end(), arr[i]))\\n            {\\n                lucky_number = arr[i];\\n                return lucky_number;\\n            }\\n        }\\n        return lucky_number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int i, lucky_number=-1;\\n        sort(arr.begin(), arr.end());\\n        for(i=arr.size()-1 ; i>=0 ; i--)\\n        {\\n            if(arr[i]==count(arr.begin(), arr.end(), arr[i]))\\n            {\\n                lucky_number = arr[i];\\n                return lucky_number;\\n            }\\n        }\\n        return lucky_number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236827,
                "title": "easy-fast-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    var mymap = new Map();\\n    for(let i=0;i<arr.length;i++){\\n        if(!mymap.has(arr[i])){\\n        mymap.set(arr[i],1)\\n        }else{\\n            mymap.set(arr[i],((mymap.get(arr[i])) + 1));\\n        }\\n    }\\n    var num=0;\\n    for(let i=0;i<arr.length;i++){\\n        if(arr[i]===(mymap.get(arr[i])) && arr[i]>num){\\n            num = arr[i];\\n        }\\n    }\\n    if(num===0) return -1;\\n    return num;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    var mymap = new Map();\\n    for(let i=0;i<arr.length;i++){\\n        if(!mymap.has(arr[i])){\\n        mymap.set(arr[i],1)\\n        }else{\\n            mymap.set(arr[i],((mymap.get(arr[i])) + 1));\\n        }\\n    }\\n    var num=0;\\n    for(let i=0;i<arr.length;i++){\\n        if(arr[i]===(mymap.get(arr[i])) && arr[i]>num){\\n            num = arr[i];\\n        }\\n    }\\n    if(num===0) return -1;\\n    return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3119058,
                "title": "find-lucky-integer-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        max_num=-1\\n        for i in arr:\\n            if arr.count(i)==i:\\n                max_freq=i\\n                if max_num<max_freq:\\n                    max_num=max_freq\\n        return max_num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        max_num=-1\\n        for i in arr:\\n            if arr.count(i)==i:\\n                max_freq=i\\n                if max_num<max_freq:\\n                    max_num=max_freq\\n        return max_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982464,
                "title": "c-simple-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n      map<int,int>map;\\n      for(int i=0;i<arr.size();i++){\\n          map[arr[i]]++;\\n      }\\n      for(auto it=map.rbegin();it!=map.rend();it++){\\n         if(it->first==it->second)return it->first; \\n      }\\n     return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n      map<int,int>map;\\n      for(int i=0;i<arr.size();i++){\\n          map[arr[i]]++;\\n      }\\n      for(auto it=map.rbegin();it!=map.rend();it++){\\n         if(it->first==it->second)return it->first; \\n      }\\n     return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887806,
                "title": "java-from-94-to-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N + N)\\n\\nI use array count to store numbers\\' count.\\n# Code 1 | 94% faster | 2 ms\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] count = new int[501];\\n        for (int n : arr) {\\n            count[n]++;\\n        }\\n        int max = -1;\\n        for (int i = 1; i < count.length; i++) {\\n            if (count[i] == i) max = i;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nHere I use static array and clear it (i.e. fill with 0\\'s) after each method use, instead of creating array each time. So, I don\\'t use extra memory and as we can see it is more efficient in terms of time performance.\\n\\n# Code 2 | 100% faster | 1 ms\\n```\\nclass Solution {\\n\\n    static int[] count = new int[501];\\n    static int findLucky(int[] arr) {\\n        for (int n : arr) {\\n            count[n]++;\\n        }\\n        int max = -1;\\n        for (int i = 1; i < count.length; i++) {\\n            if (count[i] == i) max = i;\\n        }\\n        clearArray();\\n        return max;\\n    }\\n\\n    private static void clearArray() {\\n        for (int i = 0; i < count.length; i++) {\\n            count[i] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] count = new int[501];\\n        for (int n : arr) {\\n            count[n]++;\\n        }\\n        int max = -1;\\n        for (int i = 1; i < count.length; i++) {\\n            if (count[i] == i) max = i;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    static int[] count = new int[501];\\n    static int findLucky(int[] arr) {\\n        for (int n : arr) {\\n            count[n]++;\\n        }\\n        int max = -1;\\n        for (int i = 1; i < count.length; i++) {\\n            if (count[i] == i) max = i;\\n        }\\n        clearArray();\\n        return max;\\n    }\\n\\n    private static void clearArray() {\\n        for (int i = 0; i < count.length; i++) {\\n            count[i] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867028,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int> s;\\n        for(auto it:arr){\\n            s[it]++;\\n            \\n        }\\n        vector<int> sp;\\n        for(auto it:s){\\n            if(it.second==it.first){\\n                    sp.push_back(it.first);\\n            }\\n        }\\n        sort(sp.begin(),sp.end());\\n        int n=sp.size();\\n        if(n==0){\\n            return -1;\\n        }else{\\n            return sp[n-1];\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int> s;\\n        for(auto it:arr){\\n            s[it]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2846403,
                "title": "ruby-solution-one-liner",
                "content": "I really like that symbol to proc works here with hashes, e.g. \\n```ruby\\n>> {1 => 1, 2 => 2, 3 => 4}.select(&:==)\\n=> {1=>1, 2=>2}\\n```\\n\\nSo then this will work.\\n\\n```ruby\\ndef find_lucky(nums)\\n    nums.tally.select(&:==).keys.push(-1).max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n>> {1 => 1, 2 => 2, 3 => 4}.select(&:==)\\n=> {1=>1, 2=>2}\\n```\n```ruby\\ndef find_lucky(nums)\\n    nums.tally.select(&:==).keys.push(-1).max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2711565,
                "title": "python-simple-solution-faster-than-96-87-users-using-dictionary",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        d=dict()\\n        ans=-1\\n        for i in arr:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if k==v and v>ans:\\n                ans=v\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        d=dict()\\n        ans=-1\\n        for i in arr:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for k,v in d.items():\\n            if k==v and v>ans:\\n                ans=v\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691078,
                "title": "java-solution-runtime-5ms",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int n : arr)\\n        {\\n            map.put(n, map.getOrDefault(n, 0)+1);\\n        }\\n        int res = 0;\\n        \\n        for(Map.Entry<Integer, Integer> entry : map.entrySet())\\n        {\\n            if(entry.getKey() == entry.getValue() )\\n            {\\n                res = entry.getKey();\\n            }\\n        }\\n        \\n        if(res == 0)\\n        {\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int n : arr)\\n        {\\n            map.put(n, map.getOrDefault(n, 0)+1);\\n        }\\n        int res = 0;\\n        \\n        for(Map.Entry<Integer, Integer> entry : map.entrySet())\\n        {\\n            if(entry.getKey() == entry.getValue() )\\n            {\\n                res = entry.getKey();\\n            }\\n        }\\n        \\n        if(res == 0)\\n        {\\n            return -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688823,
                "title": "js-2-easy-solution-hashmap-sorting-stack",
                "content": "![image](https://assets.leetcode.com/users/images/3ce6dd1f-0f6c-4a89-86c9-ca38589087aa_1665464869.9853516.png)\\n\\n# sorting and stack\\n```\\nvar findLucky = function(arr) {\\n    arr = arr.sort((a,b) => a - b);\\n    let outputs = [{value: arr[0], count: 1}];\\n\\n    for (let i = 1; i < arr.length; i++) {\\n        const last = outputs[outputs.length - 1];\\n        if (last && arr[i] === last.value) {\\n            last.count++;\\n            if (last.count > last.value) {\\n                outputs.pop();\\n                while(arr[i+1] === last.value) i++;\\n            }\\n        } else {\\n            if (last && last.count !== last.value) {\\n                outputs.pop();\\n            }\\n            outputs.push({value: arr[i], count: 1});\\n        }\\n    }\\n\\n    const last = outputs[outputs.length - 1];\\n    if (last && last.count === last.value) {\\n        return last.value;\\n    } else {\\n        outputs.pop();\\n    }\\n    \\n    return outputs[outputs.length - 1]?.value || -1;\\n};\\n```\\n# hashmap\\n```\\nvar findLucky = function(arr) {\\n    const hashmap = {};\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if (!hashmap[arr[i]]) {\\n            hashmap[arr[i]] = 1;\\n        } else {\\n            hashmap[arr[i]]++;\\n        }\\n    }\\n    \\n    const temp = Object.entries(hashmap);\\n    for (let i = temp.length - 1; i >= 0; i--) {\\n        if (temp[i][0] == temp[i][1]) return temp[i][1];\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nvar findLucky = function(arr) {\\n    arr = arr.sort((a,b) => a - b);\\n    let outputs = [{value: arr[0], count: 1}];\\n\\n    for (let i = 1; i < arr.length; i++) {\\n        const last = outputs[outputs.length - 1];\\n        if (last && arr[i] === last.value) {\\n            last.count++;\\n            if (last.count > last.value) {\\n                outputs.pop();\\n                while(arr[i+1] === last.value) i++;\\n            }\\n        } else {\\n            if (last && last.count !== last.value) {\\n                outputs.pop();\\n            }\\n            outputs.push({value: arr[i], count: 1});\\n        }\\n    }\\n\\n    const last = outputs[outputs.length - 1];\\n    if (last && last.count === last.value) {\\n        return last.value;\\n    } else {\\n        outputs.pop();\\n    }\\n    \\n    return outputs[outputs.length - 1]?.value || -1;\\n};\\n```\n```\\nvar findLucky = function(arr) {\\n    const hashmap = {};\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if (!hashmap[arr[i]]) {\\n            hashmap[arr[i]] = 1;\\n        } else {\\n            hashmap[arr[i]]++;\\n        }\\n    }\\n    \\n    const temp = Object.entries(hashmap);\\n    for (let i = temp.length - 1; i >= 0; i--) {\\n        if (temp[i][0] == temp[i][1]) return temp[i][1];\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676259,
                "title": "javascript-faster-than-97-82-submissions",
                "content": "```\\nvar findLucky = function(arr) {\\n    let freq = new Map();\\n    for(let i in arr){\\n        if(freq[arr[i]]){\\n            freq[arr[i]]++\\n        }else{\\n            freq[arr[i]]=1;\\n        }\\n    }\\n    let a =Math.max(...Object.keys(freq).filter(index=> freq[index] === +index))\\n    if(a>0){\\n        return a\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLucky = function(arr) {\\n    let freq = new Map();\\n    for(let i in arr){\\n        if(freq[arr[i]]){\\n            freq[arr[i]]++\\n        }else{\\n            freq[arr[i]]=1;\\n        }\\n    }\\n    let a =Math.max(...Object.keys(freq).filter(index=> freq[index] === +index))\\n    if(a>0){\\n        return a\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634679,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        a=Counter(arr)\\n        l=[]\\n        for i in arr:\\n            if i==a[i]:\\n                l.append(i)\\n        if l:\\n            return max(l)\\n        return -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        a=Counter(arr)\\n        l=[]\\n        for i in arr:\\n            if i==a[i]:\\n                l.append(i)\\n        if l:\\n            return max(l)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615325,
                "title": "javascript-easy-and-optimal-solution-using-map",
                "content": "var findLucky = function(arr) {\\n\\n    var myMap = new Map();\\n    var max_in_lucky = -1;\\n    for(var i=0;i<arr.length;i++){\\n        if(!myMap.has(arr[i])){\\n            myMap.set(arr[i],1);\\n        }\\n        else{\\n           myMap.set(arr[i],((myMap.get(arr[i])) + 1));\\n        }\\n    }\\n    var pres_key;\\n    for(let [key,value] of myMap){\\n        if(key == value){\\n            pres_key = key;\\n        }\\n        if(pres_key>max_in_lucky){\\n            max_in_lucky = pres_key;\\n        }\\n    }\\n    return max_in_lucky;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var findLucky = function(arr) {\\n\\n    var myMap = new Map();\\n    var max_in_lucky = -1;\\n    for(var i=0;i<arr.length;i++){\\n        if(!myMap.has(arr[i])){\\n            myMap.set(arr[i],1);\\n        }\\n        else{\\n           myMap.set(arr[i],((myMap.get(arr[i])) + 1));\\n        }\\n    }\\n    var pres_key;\\n    for(let [key,value] of myMap){\\n        if(key == value){\\n            pres_key = key;\\n        }\\n        if(pres_key>max_in_lucky){\\n            max_in_lucky = pres_key;\\n        }\\n    }\\n    return max_in_lucky;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2561535,
                "title": "java-o-nlogn-o-n-both-approach",
                "content": "class Solution {\\n\\n    public int findLucky(int[] arr) {\\n\\t//time complexity : O(nlongn)\\n       Arrays.sort(arr);\\n        int max=-1;\\n        int count=1;\\n        int ans=0;\\n        int flag=0;\\n        for(int i=0;i<arr.length-1;i++){\\n            if(arr[i]==arr[i+1]){\\n                count++;\\n            }\\n            else{\\n                \\n                if(count==arr[i]){\\n                    ans=arr[i];\\n                    flag=1;\\n                }\\n                count=1;\\n            }\\n            if(arr.length-2==i){\\n                if(count==arr[i]){\\n                    ans=arr[i];\\n                    flag=1;\\n                }\\n            }\\n        }\\n        if(flag==1){\\n            return ans;\\n        }\\n        else{\\n            return -1;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//time complexity : O(n)\\n\\t\\t int ans[]=new int[1000];\\n        for(int i=0;i<arr.length;i++){\\n            ans[arr[i]]++;\\n        }\\n        int a=-1;\\n        for(int i=1;i<ans.length;i++){\\n            if(i==ans[i]){\\n                a=ans[i];\\n            }\\n        }\\n        return a;\\n\\t\\t\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findLucky(int[] arr) {\\n\\t//time complexity : O(nlongn)\\n       Arrays.sort(arr);\\n        int max=-1;\\n        int count=1;\\n        int ans=0;\\n        int flag=0;\\n        for(int i=0;i<arr.length-1;i++){\\n            if(arr[i]==arr[i+1]){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2558369,
                "title": "java-n-log-n-simple-solution",
                "content": "//**Dev Bhayani**\\n\\nclass Solution {\\n    public int findLucky(int[] a) {\\n       int n=a.length;\\n        int count=1;\\n        int x=0,f=0;\\n        Arrays.sort(a);\\n        if(n==1)\\n        {\\n            if(a[0]==1)\\n            {\\n                x=1;\\n                f=1;\\n            }\\n        }\\n        else\\n            {\\n                for(int i=0;i<n-1;i++)\\n                {\\n                    if(a[i]==a[i+1])\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        if(count==a[i])\\n                        {\\n                            x=a[i];\\n                            f=1;\\n                        }\\n                        count=1;\\n                    }\\n                    if(i==n-2)\\n                    {\\n                        if(count==a[i])\\n                        {\\n                            x=a[i];\\n                            f=1;\\n                        }\\n                        count=1;\\n                    }\\n                     \\n                }\\n             }\\n        if(f==0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return x;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findLucky(int[] a) {\\n       int n=a.length;\\n        int count=1;\\n        int x=0,f=0;\\n        Arrays.sort(a);\\n        if(n==1)\\n        {\\n            if(a[0]==1)\\n            {\\n                x=1;\\n                f=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2519297,
                "title": "python-2-solutions-faster-than-96-easy-to-understand",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        arr=sorted(arr,reverse=True)\\n        counterArr=Counter(arr)\\n        for key,value in counterArr.items():\\n            if key==value:\\n                return key\\n        return -1\\n\\t\\t\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        res=[]\\n        counterArr=Counter(arr)\\n        for key,value in counterArr.items():\\n            if key==value:\\n                res.append(key)\\n        if len(res)==0:\\n            return -1\\n        else:\\n            return max(res)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        arr=sorted(arr,reverse=True)\\n        counterArr=Counter(arr)\\n        for key,value in counterArr.items():\\n            if key==value:\\n                return key\\n        return -1\\n\\t\\t\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        res=[]\\n        counterArr=Counter(arr)\\n        for key,value in counterArr.items():\\n            if key==value:\\n                res.append(key)\\n        if len(res)==0:\\n            return -1\\n        else:\\n            return max(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518706,
                "title": "c-simple-very-easy-2-ms",
                "content": "![image](https://assets.leetcode.com/users/images/ad83343c-1837-4780-9c85-4391c346bca7_1662116812.3103995.png)\\n1. Because the numbers between 1 - 500  =>array : a[501] storage the frequency of numbers and padding\\n2. i<501 because the arr[i] <= 500\\n3. If the index  is equal to the  frequency of that number =>We may find one of lucky numbers\\n4. However\\uFF0Cwe have to find the largest lucky number=>int max \\n**********************************\\nint findLucky(int* arr, int arrSize){\\n\\n    int a[501]={0};\\n    int i,max=0;\\n    for(i=0;i<arrSize;i++)\\n        a[arr[i]]++;\\n    \\n    for(i=1;i<501;i++)\\n    {    \\n        if(i==a[i])\\n         max=a[i]>max?a[i]:max;\\n    }\\n    \\n    if(max>=1) return max;\\n    else return -1;\\n}\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/ad83343c-1837-4780-9c85-4391c346bca7_1662116812.3103995.png)\\n1. Because the numbers between 1 - 500  =>array : a[501] storage the frequency of numbers and padding\\n2. i<501 because the arr[i] <= 500\\n3. If the index  is equal to the  frequency of that number =>We may find one of lucky numbers\\n4. However\\uFF0Cwe have to find the largest lucky number=>int max \\n**********************************\\nint findLucky(int* arr, int arrSize){\\n\\n    int a[501]={0};\\n    int i,max=0;\\n    for(i=0;i<arrSize;i++)\\n        a[arr[i]]++;\\n    \\n    for(i=1;i<501;i++)\\n    {    \\n        if(i==a[i])\\n         max=a[i]>max?a[i]:max;\\n    }\\n    \\n    if(max>=1) return max;\\n    else return -1;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2460174,
                "title": "c-simple-solution-easy-to-understand-faster-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) \\n    {\\n        int ret = -1;\\n        unordered_map<int,int> ans;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            ans[arr[i]]++;\\n        }\\n        \\n        for(auto it : ans)\\n        {\\n            if(it.first == it.second)\\n            {\\n                ret = max(it.second,ret);\\n            }\\n                \\n        }\\n        \\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) \\n    {\\n        int ret = -1;\\n        unordered_map<int,int> ans;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            ans[arr[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2460105,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) \\n    {\\n        map<int,int>m;\\n        for(int i = 0; i < arr.size();i++)\\n        {\\n            m[arr[i]]++;\\n        }\\n        \\n        int ans = -1;\\n        for(auto it: m)\\n        {\\n            if(it.first == it.second)\\n            {\\n                if(it.first > ans)\\n                {\\n                    ans = it.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) \\n    {\\n        map<int,int>m;\\n        for(int i = 0; i < arr.size();i++)\\n        {\\n            m[arr[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2439340,
                "title": "c-counting-elements",
                "content": "```\\n\\tint findLucky(vector<int>& arr) {\\n        int cnt[501] = {}, ans = -1;\\n        for(int i : arr) ++cnt[i];\\n        for(int i : arr)\\n            if(cnt[i] == i && i > ans) ans = i;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint findLucky(vector<int>& arr) {\\n        int cnt[501] = {}, ans = -1;\\n        for(int i : arr) ++cnt[i];\\n        for(int i : arr)\\n            if(cnt[i] == i && i > ans) ans = i;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434157,
                "title": "c-solution-without-hashmap",
                "content": "**Without Hashmap**\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int last=arr[arr.size()-1],count=0;\\n        for(int i=arr.size()-1;i>-1;i--){\\n            if(last!=arr[i]){\\n                if(count==last)\\n                    return last;\\n                count=0;\\n            }\\n            count++;\\n            last=arr[i];\\n        }\\n        if(count==last)\\n            return last;\\n        return -1;\\n    }\\n};\\n```\\n\\n**With Hashmap**\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        sort(arr.begin(),arr.end());\\n        int last=arr[arr.size()-1];\\n        for(int i=arr.size()-1;i>-1;i--){\\n            mp[arr[i]]++;\\n            if(last!=arr[i]||i==0){\\n                if(mp[last]==last)\\n                    return last;\\n            }\\n            last=arr[i];\\n        }\\n        if(mp[last]==last)\\n            return last;\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int last=arr[arr.size()-1],count=0;\\n        for(int i=arr.size()-1;i>-1;i--){\\n            if(last!=arr[i]){\\n                if(count==last)\\n                    return last;\\n                count=0;\\n            }\\n            count++;\\n            last=arr[i];\\n        }\\n        if(count==last)\\n            return last;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        sort(arr.begin(),arr.end());\\n        int last=arr[arr.size()-1];\\n        for(int i=arr.size()-1;i>-1;i--){\\n            mp[arr[i]]++;\\n            if(last!=arr[i]||i==0){\\n                if(mp[last]==last)\\n                    return last;\\n            }\\n            last=arr[i];\\n        }\\n        if(mp[last]==last)\\n            return last;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398247,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int> m ;\\n        int maximum = -1;\\n        for(int i : arr) m[i]++;\\n        for(int i = 0 ; i < arr.size() ; i++){\\n            if(m[arr[i]] == arr[i])\\n            maximum = max(arr[i],maximum);\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int> m ;\\n        int maximum = -1;\\n        for(int i : arr) m[i]++;\\n        for(int i = 0 ; i < arr.size() ; i++){\\n            if(m[arr[i]] == arr[i])\\n            maximum = max(arr[i],maximum);\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377840,
                "title": "c-cpp-easy-code",
                "content": "class Solution {\\n\\npublic:\\n\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        int mx=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.first==x.second){\\n            mx=max(x.second,mx);\\n                }\\n        }\\n        if(mx==INT_MIN){\\n            return -1;\\n        }else\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        int mx=INT_MIN;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2324055,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int res = INT_MIN;\\n        \\n        for(auto x: arr)\\n        {\\n            mp[x]++;\\n        }\\n        \\n        bool flag = true;\\n        \\n        for(auto x: mp)\\n        {\\n            if(x.first == x.second)\\n            {\\n                res = max(res,x.first);\\n                \\n                flag = false;\\n            }\\n        }\\n        \\n        return flag == true ? -1 : res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int res = INT_MIN;\\n        \\n        for(auto x: arr)\\n        {\\n            mp[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2312414,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int res = -1;\\n        for(int i : arr) mp[i]++;\\n        for(int i : arr) {\\n            if(mp[i] == i) res = max(res, i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int res = -1;\\n        for(int i : arr) mp[i]++;\\n        for(int i : arr) {\\n            if(mp[i] == i) res = max(res, i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269311,
                "title": "java-binary-search-easy-solution",
                "content": "solution -1 \\nclass Solution {\\n    public int findLucky(int[] arr) {\\n       Arrays.sort(arr);\\n       int luckyInteger = -1;\\n        int i=0;\\n        while(i<=arr.length-1){\\n            int curr = arr[i];\\n            int j = binarySearch(arr, curr, i, arr.length - 1);\\n            if((j-i)+1==curr){\\n                luckyInteger = curr;\\n            }\\n            i=j+1;\\n        }\\n       return luckyInteger;\\n    }\\n    \\n    public int binarySearch(int arr[],int target,int left,int right){\\n        int index =-1;\\n        while(left<=right){\\n            int middle = left+(right-left)/2;\\n            if(arr[middle]==target){\\n                index=middle;\\n                left=middle+1;\\n            }\\n            else\\n            {\\n                right=middle-1;\\n            }\\n        }\\n        return index;\\n    }\\n    \\n \\t\\n}\\n\\n\\n                              solution -2\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\n\\tclass Solution{\\n\\tpublic int fibdLucky(int[] arr){\\n\\tint[] newArr = new int[501];\\n        \\n        for(int e : arr){\\n            newArr[e]++;\\n        }\\n        \\n        for(int i = 500 ; i > 0 ; i--){\\n            if(newArr[i] == i){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findLucky(int[] arr) {\\n       Arrays.sort(arr);\\n       int luckyInteger = -1;\\n        int i=0;\\n        while(i<=arr.length-1){\\n            int curr = arr[i];\\n            int j = binarySearch(arr, curr, i, arr.length - 1);\\n            if((j-i)+1==curr){\\n                luckyInteger = curr;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2251142,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int count = 0, result = -1, curr = -1, i = 0;\\n        for(i = 0; i < arr.size(); i++){\\n            if(arr[i] != curr) {\\n                if(count == curr) result = curr;\\n                count = 1;\\n                curr = arr[i];\\n            }\\n            else count++;\\n        }\\n        if(count == curr) result = curr;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int count = 0, result = -1, curr = -1, i = 0;\\n        for(i = 0; i < arr.size(); i++){\\n            if(arr[i] != curr) {\\n                if(count == curr) result = curr;\\n                count = 1;\\n                curr = arr[i];\\n            }\\n            else count++;\\n        }\\n        if(count == curr) result = curr;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233250,
                "title": "easy-java-solution-using-hashmap",
                "content": "Please upvote!\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n    HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i:arr)\\n        {\\n            if(map.containsKey(i))\\n            {\\n                map.put(i,map.get(i)+1);\\n            }\\n            else\\n            {\\n                map.put(i,1);\\n            }\\n        }\\n        int max = -1;\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i) == i)\\n            {\\n                max = Math.max(max,i);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n    HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i:arr)\\n        {\\n            if(map.containsKey(i))\\n            {\\n                map.put(i,map.get(i)+1);\\n            }\\n            else\\n            {\\n                map.put(i,1);\\n            }\\n        }\\n        int max = -1;\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i) == i)\\n            {\\n                max = Math.max(max,i);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211410,
                "title": "c-hashmap-very-simple-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/4ce66f51-6d7c-4d20-b3be-0d14e2f335a0_1656452648.7494698.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findLucky(vector<int>& arr) {\\n\\t\\t\\tmap<int,int>mp;\\n\\t\\t\\tint ans=-1;\\n\\t\\t\\tfor(int i=0;i<arr.size();i++)mp[arr[i]]++;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\tif(i.first==i.second) ans=max(ans,i.first);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findLucky(vector<int>& arr) {\\n\\t\\t\\tmap<int,int>mp;\\n\\t\\t\\tint ans=-1;\\n\\t\\t\\tfor(int i=0;i<arr.size();i++)mp[arr[i]]++;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\tif(i.first==i.second) ans=max(ans,i.first);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2172643,
                "title": "python-97-fast-easy-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        hm, ans = {}, -1\\n        for i in range(len(arr)):\\n\\t\\t\\t# Counting the frequecies\\n            hm[arr[i]] = 1 + hm.get(arr[i], 0)\\n        \\n        for key, value in hm.items():\\n\\t\\t\\t# If the key value matches its frequency value, then we have a found\\n            if key == value:\\n                ans = max(ans,key)\\n        return ans \\n```\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        hm, ans = {}, -1\\n        for i in range(len(arr)):\\n\\t\\t\\t# Counting the frequecies\\n            hm[arr[i]] = 1 + hm.get(arr[i], 0)\\n        \\n        for key, value in hm.items():\\n\\t\\t\\t# If the key value matches its frequency value, then we have a found\\n            if key == value:\\n                ans = max(ans,key)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167149,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int max=0;\\n        for(int x:arr)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        int[] a = new int[max+1];\\n        \\n        for(int x:arr)\\n            a[x]++;\\n    \\n        for(int i=a.length-1;i>0;i--)\\n        {\\n            if(a[i]==i)\\n            return i;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLucky(int[] arr) {\\n        int max=0;\\n        for(int x:arr)\\n        {\\n            if(x>max)\\n                max=x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2143720,
                "title": "c-easy-approach-examples-explained",
                "content": "```\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nExample  1 - [2,2,3,4]\\nMap....\\n2 - 2\\n3 - 1\\n4 - 1\\nFor loop will compare i.first == i.second\\n2 == 2\\nSo ans will be 2.\\n\\nExample 2 - [1,2,2,3,3,3]\\nMap...\\n1 - 1\\n2 - 2\\n3 - 3\\nNow all the numbers are lucky. \\nFor loop will go till end and store the largest lucky number.\\nSo ans will be 3.\\n\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        map<int,int> mp;             //create a map\\n        int ans = -1;                //initialize the ans to -1. if we do not find any number they -1 will be returnes\\n        \\n        for(int i=0;i<arr.size();i++)         //for loop to store the numbers into array\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        for(auto & i:mp)\\n        {\\n            if(i.first==i.second)          // If it is a lucky number then store it into ans\\n                ans = i.first; \\n        }\\n        \\n        return ans;                       //at the end return the ans.\\n    }\\n};\\n\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nExample  1 - [2,2,3,4]\\nMap....\\n2 - 2\\n3 - 1\\n4 - 1\\nFor loop will compare i.first == i.second\\n2 == 2\\nSo ans will be 2.\\n\\nExample 2 - [1,2,2,3,3,3]\\nMap...\\n1 - 1\\n2 - 2\\n3 - 3\\nNow all the numbers are lucky. \\nFor loop will go till end and store the largest lucky number.\\nSo ans will be 3.\\n\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        map<int,int> mp;             //create a map\\n        int ans = -1;                //initialize the ans to -1. if we do not find any number they -1 will be returnes\\n        \\n        for(int i=0;i<arr.size();i++)         //for loop to store the numbers into array\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        for(auto & i:mp)\\n        {\\n            if(i.first==i.second)          // If it is a lucky number then store it into ans\\n                ans = i.first; \\n        }\\n        \\n        return ans;                       //at the end return the ans.\\n    }\\n};\\n\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103066,
                "title": "python-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        \\n        charMap = {}\\n        \\n        for i in arr:\\n            charMap[i] = 1 + charMap.get(i, 0)\\n            \\n        res = []\\n        \\n        for i in charMap:\\n            if charMap[i] == i:\\n                res.append(i)\\n                \\n        res = sorted(res)    \\n        \\n        if len(res) > 0:\\n            return res[-1]\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        \\n        charMap = {}\\n        \\n        for i in arr:\\n            charMap[i] = 1 + charMap.get(i, 0)\\n            \\n        res = []\\n        \\n        for i in charMap:\\n            if charMap[i] == i:\\n                res.append(i)\\n                \\n        res = sorted(res)    \\n        \\n        if len(res) > 0:\\n            return res[-1]\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975749,
                "title": "c-solution-0ms-faster-than-100-10-3mb-less-than-58",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Find Lucky Integer in an Array.\\nMemory Usage: 10.3 MB, less than 58.38% of C++ online submissions for Find Lucky Integer in an Array.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int findLucky(vector<int>& arr) \\n    {\\n        std::unordered_map<int, int> freq;\\n        for (const int& n : arr)\\n        {\\n            freq[n]++;\\n        }\\n        \\n        int candidate = -1;\\n        for (const int& n : arr)\\n        {\\n            if (freq[n] == n)\\n            {\\n                candidate = std::max(candidate, n);\\n            }\\n        }\\n        return candidate;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findLucky(vector<int>& arr) \\n    {\\n        std::unordered_map<int, int> freq;\\n        for (const int& n : arr)\\n        {\\n            freq[n]++;\\n        }\\n        \\n        int candidate = -1;\\n        for (const int& n : arr)\\n        {\\n            if (freq[n] == n)\\n            {\\n                candidate = std::max(candidate, n);\\n            }\\n        }\\n        return candidate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909205,
                "title": "straight-forward-c",
                "content": "\\nTime complexity : O(N) \\nSpace Complexity : O(N)\\nPlease upvote if you liked the solution. \\n\\n```\\n int findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int, int> m;\\n        int res=-1;        \\n        for(int i=0;i<arr.size();i++){\\n\\t\\t// Just store the frequency with the numbers\\n            m[arr[i]]++;\\n\\t\\t\\t\\n        }\\n        for(auto x:m){\\n\\t\\t\\t// Iterate in the map and see which frequency matches withthe number \\n\\t\\t\\t\\n            if(x.first==x.second)\\n\\t\\t\\t// maintain the maximum of them\\n                res=max(res,x.second);\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n int findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int, int> m;\\n        int res=-1;        \\n        for(int i=0;i<arr.size();i++){\\n\\t\\t// Just store the frequency with the numbers\\n            m[arr[i]]++;\\n\\t\\t\\t\\n        }\\n        for(auto x:m){\\n\\t\\t\\t// Iterate in the map and see which frequency matches withthe number \\n\\t\\t\\t\\n            if(x.first==x.second)\\n\\t\\t\\t// maintain the maximum of them\\n                res=max(res,x.second);\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891347,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        ans=[]\\n        d={}\\n        for ar in arr:\\n            if ar in d:\\n                d[ar]+=1\\n            else:\\n                d[ar]=1\\n        for key in d:\\n            if key ==d[key]:\\n                ans.append(key)\\n        if len(ans)==0:\\n            return -1\\n        return max(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        ans=[]\\n        d={}\\n        for ar in arr:\\n            if ar in d:\\n                d[ar]+=1\\n            else:\\n                d[ar]=1\\n        for key in d:\\n            if key ==d[key]:\\n                ans.append(key)\\n        if len(ans)==0:\\n            return -1\\n        return max(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873173,
                "title": "c-easy-100-faster-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(auto k:arr)m[k]++;\\n        int ans=-1;\\n        for(auto k:m){\\n            if(k.second==k.first){\\n                ans=max(ans,k.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(auto k:arr)m[k]++;\\n        int ans=-1;\\n        for(auto k:m){\\n            if(k.second==k.first){\\n                ans=max(ans,k.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862884,
                "title": "python-easy-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        max_num = -1\\n        data = {}\\n        for i in arr:\\n            if i not in data:\\n                data[i] = 1\\n            else:\\n                data[i] += 1\\n        for key, value in data.items():\\n            if key == value and key > max_num:\\n                max_num = key\\n        return max_num",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "class Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        max_num = -1\\n        data = {}",
                "codeTag": "Java"
            },
            {
                "id": 1831818,
                "title": "1-line-python-solution-10-fast-memory-less-than-99",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return max([a for a in arr if arr.count(a)==a], default=-1)\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return max([a for a in arr if arr.count(a)==a], default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817157,
                "title": "java-simplest-solution",
                "content": "\\n```\\nclass Solution {\\n    \\n    public int findLucky(int[] arr) {\\n\\t\\n        // 1 <= arr[i] <= 500 given\\n        int[] occurance = new int[501];\\n        \\n        for(int val : arr){\\n            occurance[val] += 1;\\n        }\\n        \\n        for(int i = occurance.length -1 ; i > 0 ; i--){\\n            if(i == occurance[i]){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findLucky(int[] arr) {\\n\\t\\n        // 1 <= arr[i] <= 500 given\\n        int[] occurance = new int[501];\\n        \\n        for(int val : arr){\\n            occurance[val] += 1;\\n        }\\n        \\n        for(int i = occurance.length -1 ; i > 0 ; i--){\\n            if(i == occurance[i]){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782369,
                "title": "find-lucy-integer-in-an-array-js-solution",
                "content": "```\\nconst luckyNumCounter = {};\\n\\n  for (let item of arr) {\\n    luckyNumCounter[item] = luckyNumCounter[item] + 1 || 1;\\n  }\\n\\n  let largestLucy = -1;\\n\\n  for (let key in luckyNumCounter) {\\n    const value = luckyNumCounter[key];\\n    const isLuckyNumber = value == key;\\n\\n    if (isLuckyNumber) {\\n      largestLucy = Math.max(isLuckyNumber, value);\\n    }\\n  }\\n\\n  return largestLucy;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst luckyNumCounter = {};\\n\\n  for (let item of arr) {\\n    luckyNumCounter[item] = luckyNumCounter[item] + 1 || 1;\\n  }\\n\\n  let largestLucy = -1;\\n\\n  for (let key in luckyNumCounter) {\\n    const value = luckyNumCounter[key];\\n    const isLuckyNumber = value == key;\\n\\n    if (isLuckyNumber) {\\n      largestLucy = Math.max(isLuckyNumber, value);\\n    }\\n  }\\n\\n  return largestLucy;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704091,
                "title": "1ms-100-fast-and-clean-code-c-maps",
                "content": "If you find it useful then PLEASE UPVOTE !!\\n```\\nint findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int,int> mp;\\n        int ans = -1;\\n        \\n        for(int i=0 ; i<arr.size() ; i++)\\n            mp[arr[i]]++;\\n        \\n        for(auto it:mp){\\n            if(it.first == it.second && it.first > ans)\\n                ans = it.first;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int,int> mp;\\n        int ans = -1;\\n        \\n        for(int i=0 ; i<arr.size() ; i++)\\n            mp[arr[i]]++;\\n        \\n        for(auto it:mp){\\n            if(it.first == it.second && it.first > ans)\\n                ans = it.first;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692252,
                "title": "neat-and-clean-java-code-100",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        int[] newArr = new int[501];\\n        \\n        for(int e : arr){\\n            newArr[e]++;\\n        }\\n        \\n        for(int i = 500 ; i > 0 ; i--){\\n            if(newArr[i] == i){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        \\n        int[] newArr = new int[501];\\n        \\n        for(int e : arr){\\n            newArr[e]++;\\n        }\\n        \\n        for(int i = 500 ; i > 0 ; i--){\\n            if(newArr[i] == i){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665873,
                "title": "simple-c-solution-using-map",
                "content": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n     map<int,int>mp;\\n        int ans= -1;\\n        for(auto i:arr)\\n        {\\n            mp[i]++;\\n            \\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.first == i.second)\\n            {\\n                ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n     map<int,int>mp;\\n        int ans= -1;\\n        for(auto i:arr)\\n        {\\n            mp[i]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1626532,
                "title": "java-solution-with-hashmap-faster-than-69-44",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer , Integer> hm = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            hm.put(arr[i] , hm.getOrDefault(arr[i] , 0) + 1);\\n        }\\n        int max = -1;\\n        for(Integer c : hm.keySet()){\\n            if(c == hm.get(c)){\\n               max = Math.max(max , c);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer , Integer> hm = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            hm.put(arr[i] , hm.getOrDefault(arr[i] , 0) + 1);\\n        }\\n        int max = -1;\\n        for(Integer c : hm.keySet()){\\n            if(c == hm.get(c)){\\n               max = Math.max(max , c);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583827,
                "title": "easy-python-solution",
                "content": "```\\ndef findLucky(self, arr: List[int]) -> int:\\n        arr.sort(reverse=1)\\n        for i in arr:\\n            if arr.count(i)==i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findLucky(self, arr: List[int]) -> int:\\n        arr.sort(reverse=1)\\n        for i in arr:\\n            if arr.count(i)==i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1573801,
                "title": "python3-faster-than-91-99",
                "content": "Got two solution\\n\\nfaster than 91.99% with 72.82% low memory 14.3 Mb\\n\\n```\\ndef luckyNum(numArr):\\n\\thashMap = dict()\\n\\tfor ele in numArr:\\n\\t\\tif ele in hashMap:\\n\\t\\t\\thashMap[ele] += 1\\n\\t\\telse:\\n\\t\\t\\thashMap[ele] = 1\\n\\tmaxNum = -1\\n\\tfor key in sorted(hashMap):\\n\\t\\tif hashMap[key] == key:\\n\\t\\t\\tmaxNum = key\\n\\treturn maxNum\\n```\\nthis one is 75.89% faster with memory 14% low\\n```\\ndef luckyNumber(numArr):\\n\\thashMap = dict()\\n\\tfor ele in numArr:\\n\\t\\tif ele in hashMap:\\n\\t\\t\\thashMap[ele] += 1\\n\\t\\telse:\\n\\t\\t\\thashMap[key] = 1\\n\\tmaxNum = set()\\n\\tfor key in hashMap:\\n\\t\\tif hashMap[key] == key:\\n\\t\\t\\tmaxNum.add(key)\\n\\treturn max(maxNum) if maxNum else -1\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\ndef luckyNum(numArr):\\n\\thashMap = dict()\\n\\tfor ele in numArr:\\n\\t\\tif ele in hashMap:\\n\\t\\t\\thashMap[ele] += 1\\n\\t\\telse:\\n\\t\\t\\thashMap[ele] = 1\\n\\tmaxNum = -1\\n\\tfor key in sorted(hashMap):\\n\\t\\tif hashMap[key] == key:\\n\\t\\t\\tmaxNum = key\\n\\treturn maxNum\\n```\n```\\ndef luckyNumber(numArr):\\n\\thashMap = dict()\\n\\tfor ele in numArr:\\n\\t\\tif ele in hashMap:\\n\\t\\t\\thashMap[ele] += 1\\n\\t\\telse:\\n\\t\\t\\thashMap[key] = 1\\n\\tmaxNum = set()\\n\\tfor key in hashMap:\\n\\t\\tif hashMap[key] == key:\\n\\t\\t\\tmaxNum.add(key)\\n\\treturn max(maxNum) if maxNum else -1\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1561043,
                "title": "100-faster-c-solution",
                "content": "**Using Hashing technique**\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n     int a[501]={0,0};\\n        for(int i=0;i<arr.size();i++){\\n            a[arr[i]]++;\\n        }\\n\\n        for(int j=500;j>=0;j--){\\n            if(a[j]==j && a[j]!=0){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n     int a[501]={0,0};\\n        for(int i=0;i<arr.size();i++){\\n            a[arr[i]]++;\\n        }\\n\\n        for(int j=500;j>=0;j--){\\n            if(a[j]==j && a[j]!=0){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477672,
                "title": "java-99-8-fastest-with-reduce-search-time",
                "content": "class Solution {\\n    public int findLucky(int[] arr) {\\n        int count [] = new int [501];\\n        int maxi = -1;\\n        int mini = 1000;\\n        int res = -1;\\n        \\n        for(int val : arr) {\\n            count[val]++;\\n            if(val < mini) {\\n                mini = val;\\n            }\\n            \\n            if(val > maxi) {\\n                maxi = val;\\n            }\\n        }\\n        \\n        for(int i = mini ; i<=maxi ; i++) {\\n            if(i == count[i]) {\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLucky(int[] arr) {\\n        int count [] = new int [501];\\n        int maxi = -1;\\n        int mini = 1000;\\n        int res = -1;\\n        \\n        for(int val : arr) {\\n            count[val]++;\\n            if(val < mini) {\\n                mini = val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1411511,
                "title": "c-easy-solution",
                "content": "```\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> m;int maxx=INT_MIN,count=0;\\n        for(int i=0;i<arr.size();i++)\\n            m[arr[i]]++;\\n        for(auto i:m)\\n        {\\n            if(i.first==i.second)\\n            {\\n                count++;\\n                maxx=max(i.first,maxx);//for multiple ans \\n            }\\n        }\\n        if(count!=0)\\n        return maxx;\\n        else\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> m;int maxx=INT_MIN,count=0;\\n        for(int i=0;i<arr.size();i++)\\n            m[arr[i]]++;\\n        for(auto i:m)\\n        {\\n            if(i.first==i.second)\\n            {\\n                count++;\\n                maxx=max(i.first,maxx);//for multiple ans \\n            }\\n        }\\n        if(count!=0)\\n        return maxx;\\n        else\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378170,
                "title": "java-straightforward-hashmap",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer,Integer> frequencies=new HashMap<>();\\n        \\n        for(int c : arr)\\n        {\\n            frequencies.put(c,frequencies.getOrDefault(c,0)+1);\\n        }\\n        int max=-1;\\n        for(int c : frequencies.keySet())\\n        {\\n            if(c==frequencies.get(c))\\n                max=Math.max(max,c);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        HashMap<Integer,Integer> frequencies=new HashMap<>();\\n        \\n        for(int c : arr)\\n        {\\n            frequencies.put(c,frequencies.getOrDefault(c,0)+1);\\n        }\\n        int max=-1;\\n        for(int c : frequencies.keySet())\\n        {\\n            if(c==frequencies.get(c))\\n                max=Math.max(max,c);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371328,
                "title": "java-solution-in-3-lines",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] freq = new int[501];\\n        Arrays.stream(arr).forEach(i -> freq[i]++);\\n        return Arrays.stream(arr).filter(n -> n == freq[n]).max().orElse(-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] freq = new int[501];\\n        Arrays.stream(arr).forEach(i -> freq[i]++);\\n        return Arrays.stream(arr).filter(n -> n == freq[n]).max().orElse(-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368243,
                "title": "python-easy-solution-faster-then-95-23",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        l = [-1]\\n        for k,v in Counter(arr).items():\\n            if k==v:\\n                l.append(v)\\n        return max(l) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        l = [-1]\\n        for k,v in Counter(arr).items():\\n            if k==v:\\n                l.append(v)\\n        return max(l) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354790,
                "title": "java-array-counting-1ms-beats-99-16-t-c-o-n-s-c-o-n",
                "content": "\\n    public int findLucky(int[] arr) {\\n        \\n        int len = arr.length;\\n        int[] map = new int[501];\\n        \\n        for(int num : arr)\\n            map[num]++;\\n        \\n        for(int i=500;i>=1;i--){\\n            if(map[i] == i)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int findLucky(int[] arr) {\\n        \\n        int len = arr.length;\\n        int[] map = new int[501];\\n        \\n        for(int num : arr)\\n            map[num]++;\\n        \\n        for(int i=500;i>=1;i--){\\n            if(map[i] == i)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1335088,
                "title": "easy-python-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        cnt=Counter(arr)\\n        l=[]\\n        for key,values in cnt.items():\\n            if key==values:\\n                l.append(key)\\n        if len(l)>0:\\n            return max(l)\\n        else:\\n            return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        cnt=Counter(arr)\\n        l=[]\\n        for key,values in cnt.items():\\n            if key==values:\\n                l.append(key)\\n        if len(l)>0:\\n            return max(l)\\n        else:\\n            return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323534,
                "title": "python-4-liner-99-faster",
                "content": "```\\n       from collections import Counter\\n        arr_dict=Counter(arr)\\n        maxval=-1\\n        a=list(filter(lambda x:arr_dict[x]==x, arr_dict))\\n        return max(a) if a else -1\\n```",
                "solutionTags": [],
                "code": "```\\n       from collections import Counter\\n        arr_dict=Counter(arr)\\n        maxval=-1\\n        a=list(filter(lambda x:arr_dict[x]==x, arr_dict))\\n        return max(a) if a else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1303268,
                "title": "simple-java-hashmap-sol",
                "content": "```\\npublic int findLucky(int[] arr) \\n    {\\n        Map<Integer, Integer> count = new HashMap();\\n        for(int x:arr)\\n            count.put(x,count.getOrDefault(x, 0) + 1);\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(-1);\\n            for (int wd: count.keySet())\\n                if (count.get(wd) == wd)\\n                    ans.add(wd);\\n        Collections.sort(ans);\\n        return ans.get(ans.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findLucky(int[] arr) \\n    {\\n        Map<Integer, Integer> count = new HashMap();\\n        for(int x:arr)\\n            count.put(x,count.getOrDefault(x, 0) + 1);\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(-1);\\n            for (int wd: count.keySet())\\n                if (count.get(wd) == wd)\\n                    ans.add(wd);\\n        Collections.sort(ans);\\n        return ans.get(ans.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291354,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n\\n        int count=-1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]++;\\n        }\\n        for(auto i:m)\\n        {\\n        if(i.first==i.second)\\n        {\\n            count=max(count,i.first);\\n        }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n\\n        int count=-1;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            m[arr[i]]++;\\n        }\\n        for(auto i:m)\\n        {\\n        if(i.first==i.second)\\n        {\\n            count=max(count,i.first);\\n        }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287686,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int ans=-1;\\n        unordered_map<int,int>cnt;\\n        for(auto i:arr){\\n            cnt[i]++;\\n        }\\n        for(auto i:cnt){\\n            if(i.first==i.second){\\n                ans=max(ans,i.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int ans=-1;\\n        unordered_map<int,int>cnt;\\n        for(auto i:arr){\\n            cnt[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1287248,
                "title": "c-two-solution-hasing-map",
                "content": "# HASHING\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        vector<int>hash(510,0); //hashing\\n        vector<int>values; //storing all lucky numbers\\n        \\n        //hashing for the input\\n        for(auto val:arr)\\n        {\\n            hash[val]++;\\n        }\\n        \\n        //checking the required conditon and storing in values\\n        for(int i=1;i<=500;i++)\\n        {\\n            if(i==hash[i])\\n                values.push_back(i);\\n        }\\n        \\n        if(values.size()>0)//if there is any lucky number then find max else -1\\n            return (*max_element(values.begin(),values.end()));\\n        else \\n            return -1;\\n        \\n    }\\n};\\n```\\n\\n# unordered_map\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int,int>m;\\n        int max_val=-1;\\n        \\n        //storing frequency in map\\n        for(auto val:arr)\\n        {\\n            m[val]++;\\n        }\\n        \\n        //checking required condition\\n        for(auto ele:m)\\n        {\\n            if(ele.first==ele.second)\\n            {\\n                max_val=max(ele.first,max_val);//finding max lucky number \\n            }\\n        }\\n        return max_val;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        vector<int>hash(510,0); //hashing\\n        vector<int>values; //storing all lucky numbers\\n        \\n        //hashing for the input\\n        for(auto val:arr)\\n        {\\n            hash[val]++;\\n        }\\n        \\n        //checking the required conditon and storing in values\\n        for(int i=1;i<=500;i++)\\n        {\\n            if(i==hash[i])\\n                values.push_back(i);\\n        }\\n        \\n        if(values.size()>0)//if there is any lucky number then find max else -1\\n            return (*max_element(values.begin(),values.end()));\\n        else \\n            return -1;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        \\n        unordered_map<int,int>m;\\n        int max_val=-1;\\n        \\n        //storing frequency in map\\n        for(auto val:arr)\\n        {\\n            m[val]++;\\n        }\\n        \\n        //checking required condition\\n        for(auto ele:m)\\n        {\\n            if(ele.first==ele.second)\\n            {\\n                max_val=max(ele.first,max_val);//finding max lucky number \\n            }\\n        }\\n        return max_val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273886,
                "title": "php-solution",
                "content": "class Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function findLucky($arr) {\\n        $res=array_count_values($arr);\\n        \\n        foreach($res as $key =>$v)\\n        {\\n            if($key==$v)\\n            {\\n                $match[]=$v;\\n            }\\n            \\n        }\\n        if(!$match)\\n        {\\n            $match[]=-1;\\n        }\\n        return max($match);\\n    }\\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function findLucky($arr) {\\n        $res=array_count_values($arr);\\n        \\n        foreach($res as $key =>$v)\\n        {\\n            if($key==$v)\\n            {\\n                $match[]=$v;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1246325,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int> m;\\n        int a=-1;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]++;\\n        }\\n        for(auto x:m){\\n            if(x.first==x.second){\\n                a=max(a,x.first);\\n            }\\n        }\\n        return a;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        map<int,int> m;\\n        int a=-1;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240905,
                "title": "easy-to-understand-without-using-hashmap",
                "content": "```\\nclass Solution \\n{\\n    public int findLucky(int[] arr) \\n    {\\n        int i , count = 1;\\n        Arrays.sort(arr) ;\\n        for( i = arr.length - 1 ; i >= 0; i -- )\\n        {\\n            if( i == 0 || arr[i] != arr[i-1] )\\n            {\\n                if( arr[i] == count )\\n                {\\n                    return arr[i] ;\\n                }\\n                count = 1 ;\\n            }\\n            else if ( arr[i] == arr[i-1] )\\n            {\\n                count++ ;\\n            }\\n        }\\n        return -1 ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int findLucky(int[] arr) \\n    {\\n        int i , count = 1;\\n        Arrays.sort(arr) ;\\n        for( i = arr.length - 1 ; i >= 0; i -- )\\n        {\\n            if( i == 0 || arr[i] != arr[i-1] )\\n            {\\n                if( arr[i] == count )\\n                {\\n                    return arr[i] ;\\n                }\\n                count = 1 ;\\n            }\\n            else if ( arr[i] == arr[i-1] )\\n            {\\n                count++ ;\\n            }\\n        }\\n        return -1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218387,
                "title": "c-sort-with-explanation-and-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        // Adding one extra digit to check last number\\n        arr.push_back(0);\\n        int n=arr.size();\\n        int count=1;\\n        // If curr number is different from last number, check count==last number\\n        // If true return count else set count == 0\\n        for (int i=1; i<n; i++){\\n            if (arr[i-1]!=arr[i]){\\n                if (count==arr[i-1])\\n                    return count;\\n                count = 0;\\n            }\\n            count++;\\n        }\\n        // If n==1 and arr[0] ==1, return 1 else return -1;\\n        return n==1&&arr[0]==1? 1: -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        // Adding one extra digit to check last number\\n        arr.push_back(0);\\n        int n=arr.size();\\n        int count=1;\\n        // If curr number is different from last number, check count==last number\\n        // If true return count else set count == 0\\n        for (int i=1; i<n; i++){\\n            if (arr[i-1]!=arr[i]){\\n                if (count==arr[i-1])\\n                    return count;\\n                count = 0;\\n            }\\n            count++;\\n        }\\n        // If n==1 and arr[0] ==1, return 1 else return -1;\\n        return n==1&&arr[0]==1? 1: -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208513,
                "title": "full-explanation-java-1ms-99-fast",
                "content": "The idea is to first get frequency of each digit and then check if that frequency is equal to its index.\\n\\nEg- input_arr = [2, 2, 3, 4]\\nWe know frequency of 2 is 2, 3 is 1 and 4 is 1.\\n\\nTo calculate that, we are creating a limit sized array(as we know its constraint based question) and \\nthen use each digit as index ->` freq[num]++; `\\n\\nAfter first loop, our array would be something like this-\\n![image](https://assets.leetcode.com/users/images/86b316ec-e66d-44b0-86cc-3deeeae18b02_1622484394.351241.png)\\n\\nNow its easier for us to use second loop and just check if index is equal to value->`if (freq[i] == i)`\\nWe want to return largest number if multiple lucky numbers are present, \\nhence the `max()` function to keep track of the maximum value.\\n\\n**Space Complexity: O(n)**\\nHere we used fixed size array to speed up the code as we knew the constraints.\\nBut when we don\\'t know what could be the size of input array,\\nwe would use something like HashMap that will grow with respect to the input size.\\nHence, our space complexity will be `O(n)`.\\n\\n**Time Complexity: O(n)**\\nIn first loop, we will touch each element of input array once- `O(n)`\\nIn second loop, it is possible that elements are less than n \\nbut worse case scenario will be when each element is present only once. Hence `O(n)`\\n`Total= O(n) + O(n) = 2O(n)`\\nThen we will drop the constant as its insignificant and  will end up with `O(n)`\\n\\n\\n\\n\\n```\\npublic int findLucky(int[] arr) {\\n\\tint[] freq = new int[501];  \\n\\tint max = -1;\\n\\n\\tfor (int num : arr) {\\n\\t\\tfreq[num]++; \\n\\t}\\n\\n\\tfor (int i = 1; i < 501; i++) {\\n\\t\\tif (freq[i] == i)\\n\\t\\t\\tmax = Math.max(i, max);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findLucky(int[] arr) {\\n\\tint[] freq = new int[501];  \\n\\tint max = -1;\\n\\n\\tfor (int num : arr) {\\n\\t\\tfreq[num]++; \\n\\t}\\n\\n\\tfor (int i = 1; i < 501; i++) {\\n\\t\\tif (freq[i] == i)\\n\\t\\t\\tmax = Math.max(i, max);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201150,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int hash[501]={},res=-1;\\n        for(auto i:arr)hash[i]++;\\n        for(int i=1;i<=500;i++)if(i==hash[i])res=i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        int hash[501]={},res=-1;\\n        for(auto i:arr)hash[i]++;\\n        for(int i=1;i<=500;i++)if(i==hash[i])res=i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195161,
                "title": "java-hashmap",
                "content": "\\tclass Solution {\\n    public int findLucky(int[] arr) {\\n        int res = -1;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:arr) map.put(i,map.getOrDefault(i,0)+1);\\n         for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n             Integer key = entry.getKey();\\n             Integer value = entry.getValue();\\n             if(key==value) res= key;             \\n         }\\n         return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findLucky(int[] arr) {\\n        int res = -1;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:arr) map.put(i,map.getOrDefault(i,0)+1);\\n         for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n             Integer key = entry.getKey();\\n             Integer value = entry.getValue();\\n             if(key==value) res= key;             \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1192880,
                "title": "simple-short-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n\\tdef findLucky(self, arr: List[int]) -> int:\\n\\t\\tlucky = []\\n\\t\\t[lucky.append(i) for i in arr if i == arr.count(i)]\\n\\t\\treturn max(lucky) if len(lucky) > 0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findLucky(self, arr: List[int]) -> int:\\n\\t\\tlucky = []\\n\\t\\t[lucky.append(i) for i in arr if i == arr.count(i)]\\n\\t\\treturn max(lucky) if len(lucky) > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191699,
                "title": "90-faster-code-using-map-keeping-the-count",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> u;\\n        for(int i=0 ; i<arr.size() ; i++)\\n        {\\n            u[arr[i]]++;\\n        }\\n        int lucky_num = -1;\\n        for(auto x: u)\\n        {\\n            if(x.first == x.second)\\n            {\\n                lucky_num = max(lucky_num  , x.first);\\n            }\\n        }\\n        return lucky_num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int,int> u;\\n        for(int i=0 ; i<arr.size() ; i++)\\n        {\\n            u[arr[i]]++;\\n        }\\n        int lucky_num = -1;\\n        for(auto x: u)\\n        {\\n            if(x.first == x.second)\\n            {\\n                lucky_num = max(lucky_num  , x.first);\\n            }\\n        }\\n        return lucky_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189610,
                "title": "simple-java-solution-99-39-faster-99-08-less-memory",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] ct = new int[501]; //Initiate an array from index 0-500 (arr[i] <= 500)\\n        int max = -1;\\n        for (int i = 0; i < arr.length; i++) {\\n            ct[arr[i]]++; // add 1 to the value of index in ct array. E.g if add[i] is 2, add 1 to ct[2]\\n        }\\n        for (int j = 0; j < arr.length; j++) {\\n            if (ct[arr[j]] == arr[j]) { // check if number of occurence of an element is the same as the value of the element\\n                if (arr[j] > max) { // if it is the same, check if it\\'s larger than the current max\\n                    max = arr[j]; // if it is indeed bigger, change max to the newest value\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int[] ct = new int[501]; //Initiate an array from index 0-500 (arr[i] <= 500)\\n        int max = -1;\\n        for (int i = 0; i < arr.length; i++) {\\n            ct[arr[i]]++; // add 1 to the value of index in ct array. E.g if add[i] is 2, add 1 to ct[2]\\n        }\\n        for (int j = 0; j < arr.length; j++) {\\n            if (ct[arr[j]] == arr[j]) { // check if number of occurence of an element is the same as the value of the element\\n                if (arr[j] > max) { // if it is the same, check if it\\'s larger than the current max\\n                    max = arr[j]; // if it is indeed bigger, change max to the newest value\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139094,
                "title": "python-pythonic-w-o-counter",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dct = {}\\n        for i in arr:\\n            dct[i] = dct.get(i, 0) + 1\\n        return max([key for key, value in dct.items() if key == value], default=-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dct = {}\\n        for i in arr:\\n            dct[i] = dct.get(i, 0) + 1\\n        return max([key for key, value in dct.items() if key == value], default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119394,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        \\n        return max([k for k,v in Counter(arr).items() if k == v], default = -1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        \\n        return max([k for k,v in Counter(arr).items() if k == v], default = -1)",
                "codeTag": "Java"
            },
            {
                "id": 1073660,
                "title": "python3-simple-solution-using-counter",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        arr.sort()\\n        c = Counter(arr)\\n        x = [-1]\\n        for i,j in c.items():\\n            if i == j:\\n                x.append(i)\\n        return x[-1]\\n```\\n**If you like the solution, please vote for this.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        arr.sort()\\n        c = Counter(arr)\\n        x = [-1]\\n        for i,j in c.items():\\n            if i == j:\\n                x.append(i)\\n        return x[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067552,
                "title": "java-cache-and-sort-solutions",
                "content": "**Sort**\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        Arrays.sort(arr);\\n\\n        var current = 0;\\n        var count = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] == current) {\\n                count++;\\n            } else if (count > 0 && count == current) {\\n                break;\\n            } else {\\n                current = arr[i];\\n                count = 1;\\n            }\\n        }\\n            \\n        \\n        return count == current ? count : -1;\\n    }\\n}\\n```\\n**Cache**\\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        var res = new int[501];\\n        for (int i = 0; i < arr.length; i++)\\n            res[arr[i]]++;\\n        \\n        for (int i = res.length - 1; i > 0; i--)\\n            if (res[i] == i) return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        Arrays.sort(arr);\\n\\n        var current = 0;\\n        var count = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (arr[i] == current) {\\n                count++;\\n            } else if (count > 0 && count == current) {\\n                break;\\n            } else {\\n                current = arr[i];\\n                count = 1;\\n            }\\n        }\\n            \\n        \\n        return count == current ? count : -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        var res = new int[501];\\n        for (int i = 0; i < arr.length; i++)\\n            res[arr[i]]++;\\n        \\n        for (int i = res.length - 1; i > 0; i--)\\n            if (res[i] == i) return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043592,
                "title": "simple-c-solution-beats-98",
                "content": "\\n\\nint findLucky(int* arr, int arrSize){\\nint a[501]={0};\\n    int min=-1;\\n    for(int i=0;i<arrSize;i++){\\n        a[arr[i]]++;\\n    }\\n    for(int i=1;i<501;i++){\\n        if(a[i]==i){\\n           min=i; \\n        }\\n    }\\n    if(min==-1){\\n        return -1;\\n    }\\n    return min;\\n}",
                "solutionTags": [],
                "code": "\\n\\nint findLucky(int* arr, int arrSize){\\nint a[501]={0};\\n    int min=-1;\\n    for(int i=0;i<arrSize;i++){\\n        a[arr[i]]++;\\n    }\\n    for(int i=1;i<501;i++){\\n        if(a[i]==i){\\n           min=i; \\n        }\\n    }\\n    if(min==-1){\\n        return -1;\\n    }\\n    return min;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 994325,
                "title": "ruby-one-liner",
                "content": "```\\ndef find_lucky(arr)\\n    arr.tally.select { |num, count| num == count }.max { |(key1, _val1), (key2, _val2)| key1 <=> key2 }&.first || -1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef find_lucky(arr)\\n    arr.tally.select { |num, count| num == count }.max { |(key1, _val1), (key2, _val2)| key1 <=> key2 }&.first || -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 985305,
                "title": "java-100-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int freq [] = new int [502];\\n        int i = 0, j = 1;\\n        while(i<arr.length){\\n            freq[arr[i]]++; \\n            i++;\\n        }\\n        \\n        int res = -1;\\n        while(j<freq.length){\\n            if(freq[j] == j && j > res) res = j;\\n            j++;\\n        }\\n        return res;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLucky(int[] arr) {\\n        int freq [] = new int [502];\\n        int i = 0, j = 1;\\n        while(i<arr.length){\\n            freq[arr[i]]++; \\n            i++;\\n        }\\n        \\n        int res = -1;\\n        while(j<freq.length){\\n            if(freq[j] == j && j > res) res = j;\\n            j++;\\n        }\\n        return res;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955951,
                "title": "java-solution-with-explanation",
                "content": "`num` is the number which I am on.\\n\\n`h` is the return value.\\n\\nAnd `counter` is the number of `num`\\'s\\n\\nThis code loops through the array, and then checks whether `arr[i] != num` because if so then the code has to check whether `num == counter` and then it has to make `h == counter`. Also if `arr[i] != num` then the code has to change `num` to `arr[i]`.\\n\\nelse we add to `counter`.\\n\\nAt the end the code has two if\\'s, the first one is there because `h` starts off as `0` and the second one is because if the frequency in the array equal to its value is at the end of the array. An example of this could be `[1, 2, 3, 3, 3]`.\\n\\n\\n```\\npublic int findLucky(int[] arr) {\\n\\tint h = 0;\\n\\tArrays.sort(arr);\\n\\tint num = 0;\\n\\tint counter = 0;\\n\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tif (num != arr[i]){\\n\\t\\t\\tif (num == counter){\\n\\t\\t\\t\\tif (num > h){\\n\\t\\t\\t\\t\\th = counter;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnum = arr[i];\\n\\t\\t\\tcounter = 1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcounter ++;\\n\\t\\t}\\n\\t}\\n\\tif (h == 0){\\n\\t\\th = -1;\\n\\t}\\n\\tif (num == counter){\\n\\t\\tif (num > h){\\n\\t\\t\\th = counter;\\n\\t\\t}\\n\\t}\\n\\treturn h;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLucky(int[] arr) {\\n\\tint h = 0;\\n\\tArrays.sort(arr);\\n\\tint num = 0;\\n\\tint counter = 0;\\n\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tif (num != arr[i]){\\n\\t\\t\\tif (num == counter){\\n\\t\\t\\t\\tif (num > h){\\n\\t\\t\\t\\t\\th = counter;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnum = arr[i];\\n\\t\\t\\tcounter = 1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcounter ++;\\n\\t\\t}\\n\\t}\\n\\tif (h == 0){\\n\\t\\th = -1;\\n\\t}\\n\\tif (num == counter){\\n\\t\\tif (num > h){\\n\\t\\t\\th = counter;\\n\\t\\t}\\n\\t}\\n\\treturn h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941488,
                "title": "c-using-unordered-map",
                "content": "```\\n int findLucky(vector<int>& arr) {\\n        unordered_map<int,int>map;\\n        for(int x:arr)\\n        {\\n            map[x]++;\\n        }\\n        int maxi=-1;\\n        for(auto x:map)\\n        {\\n            if(x.first==x.second&&x.first>maxi)\\n                maxi=x.first;\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int findLucky(vector<int>& arr) {\\n        unordered_map<int,int>map;\\n        for(int x:arr)\\n        {\\n            map[x]++;\\n        }\\n        int maxi=-1;\\n        for(auto x:map)\\n        {\\n            if(x.first==x.second&&x.first>maxi)\\n                maxi=x.first;\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932717,
                "title": "slow-but-it-works-javascript",
                "content": "Probably more verbose than it needs to be too...\\n\\n```\\nvar findLucky = function(arr) {\\n    let foundLucky = 0\\n    for(i = 0; i < arr.length; i++) {\\n        let currentCount = 0\\n        let currentNum = arr[i]\\n        for(j = 0; j < arr.length; j++) {\\n            if(currentNum === arr[j]) {\\n               currentCount++\\n            }\\n        }\\n        if(currentCount === currentNum && currentNum > foundLucky) {\\n            foundLucky = currentNum\\n        }\\n        currentCount = 0\\n    }\\n    return foundLucky > 0 ? foundLucky : -1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findLucky = function(arr) {\\n    let foundLucky = 0\\n    for(i = 0; i < arr.length; i++) {\\n        let currentCount = 0\\n        let currentNum = arr[i]\\n        for(j = 0; j < arr.length; j++) {\\n            if(currentNum === arr[j]) {\\n               currentCount++\\n            }\\n        }\\n        if(currentCount === currentNum && currentNum > foundLucky) {\\n            foundLucky = currentNum\\n        }\\n        currentCount = 0\\n    }\\n    return foundLucky > 0 ? foundLucky : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931140,
                "title": "c-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(const vector<int>& arr) {\\n        vector<int> v(501);\\n        for(int i=0; i<arr.size(); ++i) ++v[arr[i]];\\n        for(int i=v.size()-1; i>-1; --i)\\n            if(i and i==v[i]) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(const vector<int>& arr) {\\n        vector<int> v(501);\\n        for(int i=0; i<arr.size(); ++i) ++v[arr[i]];\\n        for(int i=v.size()-1; i>-1; --i)\\n            if(i and i==v[i]) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913536,
                "title": "fastest-and-easiest-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& v) {\\n      \\n        int ans=-1;\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(count(v.begin(),v.end(),v[i])==v[i])     // code to check if the no. frequency equals the no.\\n              ans=max(ans,v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```                               \\uD83D\\uDE00\\uD83D\\uDE00PLEASE UPVOTE IF MY CODE HELPS YOU \\uD83D\\uDE00\\uD83D\\uDE00",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& v) {\\n      \\n        int ans=-1;\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(count(v.begin(),v.end(),v[i])==v[i])     // code to check if the no. frequency equals the no.\\n              ans=max(ans,v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913042,
                "title": "python-100-memory-100-speed-4-liner",
                "content": "import collections\\n        ctr = collections.Counter(arr)\\n        ctr[-1]= -1\\n        return(max([i for i in ctr if i == ctr[i]]))",
                "solutionTags": [],
                "code": "import collections\\n        ctr = collections.Counter(arr)\\n        ctr[-1]= -1\\n        return(max([i for i in ctr if i == ctr[i]]))",
                "codeTag": "Python3"
            },
            {
                "id": 906855,
                "title": "javascript-faster-than-92",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const obj = {};\\n    \\n    for(let el of arr) {\\n        if (!obj[el]) {\\n            obj[el] = 1;\\n        } else {\\n            obj[el] += 1;\\n        }\\n    }\\n    \\n    let output = -1;\\n    for(const [key, value] of Object.entries(obj)) {\\n        if (key == value && value > output) {\\n            output = value;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar findLucky = function(arr) {\\n    const obj = {};\\n    \\n    for(let el of arr) {\\n        if (!obj[el]) {\\n            obj[el] = 1;\\n        } else {\\n            obj[el] += 1;\\n        }\\n    }\\n    \\n    let output = -1;\\n    for(const [key, value] of Object.entries(obj)) {\\n        if (key == value && value > output) {\\n            output = value;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859417,
                "title": "ruby-create-histogram-select-equal-key-value-pairs-select-max-among-them",
                "content": "##### Leetcode: 1394. Find Lucky Integer in an Array.\\n\\nCreate histogram as an dictionary at keys as values frequency is stored. Select paris where frequency and value are the same, map these paris into one element, return larges one. If there no paris with equal elements, Ruby\\'s max method return nil and in this case -1 will be an answer.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1394. Find Lucky Integer in an Array.\\n# https://leetcode.com/problems/find-lucky-integer-in-an-array/\\n# Runtime: 44 ms, faster than 72.41% of Ruby online submissions for Find Lucky Integer in an Array.\\n# Memory Usage: 10.1 MB, less than 31.03% of Ruby online submissions for Find Lucky Integer in an Array.\\n# @param {Integer[]} arr\\n# @return {Integer}\\ndef find_lucky(arr)\\n    arr.each_with_object(Hash.new){|x,obj| obj[x] ||= 0; obj[x] += 1 }\\n    .to_a.select{|(value,freq)| value == freq}.map(&:last).max || -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1394. Find Lucky Integer in an Array.\\n# https://leetcode.com/problems/find-lucky-integer-in-an-array/\\n# Runtime: 44 ms, faster than 72.41% of Ruby online submissions for Find Lucky Integer in an Array.\\n# Memory Usage: 10.1 MB, less than 31.03% of Ruby online submissions for Find Lucky Integer in an Array.\\n# @param {Integer[]} arr\\n# @return {Integer}\\ndef find_lucky(arr)\\n    arr.each_with_object(Hash.new){|x,obj| obj[x] ||= 0; obj[x] += 1 }\\n    .to_a.select{|(value,freq)| value == freq}.map(&:last).max || -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 832212,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int lucky_num=-1;\\n        for(int i: arr){\\n            mp[i]++;\\n        }\\n        for(int i : arr){\\n            if(i==mp[i]){\\n                lucky_num=max(lucky_num, i);\\n            }\\n        }\\n        return lucky_num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLucky(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        int lucky_num=-1;\\n        for(int i: arr){\\n            mp[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 824972,
                "title": "go-solutions-using-array-or-map-4-ms-3-1-mb",
                "content": "```\\nfunc findLucky(arr []int) int {\\n    frq := make(map[int]int)\\n    for i := 0; i < len(arr); i++ {\\n        frq[arr[i]]++\\n    }\\n    maxLucky := -1\\n    for k, v := range frq  {\\n        if k == v && k > maxLucky  {\\n            maxLucky = k\\n        }\\n    }\\n    return maxLucky\\n}\\n```\\nAs `arr[i]` is small we can use array instead of map. I could potentially rely on the constraint for `arr[i]` and declare frq as `[501]int`, but prefer to finding maximum in `arr` instead:\\n```\\nfunc findLucky(arr []int) int {\\n    var max int\\n    for i := 0; i < len(arr); i++ {\\n        if max < arr[i] {\\n            max = arr[i]\\n        }\\n    }\\n    frq := make([]int, max+1)\\n    for i := 0; i < len(arr); i++ {\\n        frq[arr[i]]++\\n    }\\n    for i := max; i > 0; i--  {\\n        if i == frq[i]  {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findLucky(arr []int) int {\\n    frq := make(map[int]int)\\n    for i := 0; i < len(arr); i++ {\\n        frq[arr[i]]++\\n    }\\n    maxLucky := -1\\n    for k, v := range frq  {\\n        if k == v && k > maxLucky  {\\n            maxLucky = k\\n        }\\n    }\\n    return maxLucky\\n}\\n```\n```\\nfunc findLucky(arr []int) int {\\n    var max int\\n    for i := 0; i < len(arr); i++ {\\n        if max < arr[i] {\\n            max = arr[i]\\n        }\\n    }\\n    frq := make([]int, max+1)\\n    for i := 0; i < len(arr); i++ {\\n        frq[arr[i]]++\\n    }\\n    for i := max; i > 0; i--  {\\n        if i == frq[i]  {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823261,
                "title": "python-solution-60-ms-faster-than-73-31-13-8-mb-less-than-72-01",
                "content": "\\t numb = {}\\n     sums = -1\\n     for num in arr:\\n         if num in numb:\\n             numb[num] +=1\\n         else:\\n             numb[num] = 1\\n     for key, value in numb.items():\\n          if key == value:\\n             sums = max(sums,key)\\n     return sums",
                "solutionTags": [],
                "code": "\\t numb = {}\\n     sums = -1\\n     for num in arr:\\n         if num in numb:\\n             numb[num] +=1\\n         else:\\n             numb[num] = 1\\n     for key, value in numb.items():\\n          if key == value:\\n             sums = max(sums,key)\\n     return sums",
                "codeTag": "Unknown"
            },
            {
                "id": 821623,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return -1 if [x for x in arr if arr.count(x) == x] == []else max([x for x in arr if arr.count(x) == x])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        return -1 if [x for x in arr if arr.count(x) == x] == []else max([x for x in arr if arr.count(x) == x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800666,
                "title": "python3-dictionary",
                "content": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dicts = defaultdict(int)\\n        res = []\\n        for val in arr:\\n            dicts[val] += 1\\n            \\n        for key in dicts.keys():\\n            if dicts[key] == key:\\n                res.append(key)\\n                \\n        \\n        if res == []:\\n            return -1\\n        else:\\n            return max(res)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dicts = defaultdict(int)\\n        res = []\\n        for val in arr:\\n            dicts[val] += 1\\n            \\n        for key in dicts.keys():\\n            if dicts[key] == key:\\n                res.append(key)\\n                \\n        \\n        if res == []:\\n            return -1\\n        else:\\n            return max(res)\\n            \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574860,
                "content": [
                    {
                        "username": "Mady123",
                        "content": "First of all i would say do not go straight for the solution here but look out for the algorithms,i would like to give you some help here.\\n\\n1.  Use another array for the problem of lenght 501(counter) since the constarints are array length is not more than 500 and keep having a track of all elements and their counts in this array and then take another loop and then check if the counter array here contains same value as iterator variable and if yes take it one of the variable(since there is a possibility that we might find greater value than this and in the end return that variable.\\n\\n2. Use HashMap for this,first go on adding all the elements and their values in it and then in the end if you find that the key and value are same store it\\'s value in the variable,return this variable in the end.Here you can use any other DS that you are more used to.\\n\\n3. Sort the array and iterate through it from back and return the first element you find has value same as the number of times it has occured and return the same.\\n4. You can also use Heap here.\\n5. Use Bitwise and store the values in upper part of integer,then return the max one,this is most effective since it has time complexity of O(n) and space of O(1).\\n\\nThat\\'s it,I Hope I was helpful."
                    },
                    {
                        "username": "muneerwani78",
                        "content": "can you explain more about this bitwise approach"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "I solved this problem in javascript using the concept of maps  First stored the value and its occurence and then compare if value is equal to occurance  if yes then that is lucky integer"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used\\n\\n```\\n[2,2,3,4]\\n[1,2,2,3,3,3]\\n[2,2,2,3,3]\\n[1,2,2]\\n[2,1,2,3,4,3,5,4,3]\\n[3,4,3,4,3,4,2,4,2,1]\\n[1,2,2,10,30,11,11,11,11,11,11,11,11,11,11,11]\\n[1,2,2,10,30,11,11,11,11,11,11,11,11,11,11]\\n```"
                    }
                ]
            },
            {
                "id": 1899469,
                "content": [
                    {
                        "username": "Mady123",
                        "content": "First of all i would say do not go straight for the solution here but look out for the algorithms,i would like to give you some help here.\\n\\n1.  Use another array for the problem of lenght 501(counter) since the constarints are array length is not more than 500 and keep having a track of all elements and their counts in this array and then take another loop and then check if the counter array here contains same value as iterator variable and if yes take it one of the variable(since there is a possibility that we might find greater value than this and in the end return that variable.\\n\\n2. Use HashMap for this,first go on adding all the elements and their values in it and then in the end if you find that the key and value are same store it\\'s value in the variable,return this variable in the end.Here you can use any other DS that you are more used to.\\n\\n3. Sort the array and iterate through it from back and return the first element you find has value same as the number of times it has occured and return the same.\\n4. You can also use Heap here.\\n5. Use Bitwise and store the values in upper part of integer,then return the max one,this is most effective since it has time complexity of O(n) and space of O(1).\\n\\nThat\\'s it,I Hope I was helpful."
                    },
                    {
                        "username": "muneerwani78",
                        "content": "can you explain more about this bitwise approach"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "I solved this problem in javascript using the concept of maps  First stored the value and its occurence and then compare if value is equal to occurance  if yes then that is lucky integer"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used\\n\\n```\\n[2,2,3,4]\\n[1,2,2,3,3,3]\\n[2,2,2,3,3]\\n[1,2,2]\\n[2,1,2,3,4,3,5,4,3]\\n[3,4,3,4,3,4,2,4,2,1]\\n[1,2,2,10,30,11,11,11,11,11,11,11,11,11,11,11]\\n[1,2,2,10,30,11,11,11,11,11,11,11,11,11,11]\\n```"
                    }
                ]
            },
            {
                "id": 1883746,
                "content": [
                    {
                        "username": "Mady123",
                        "content": "First of all i would say do not go straight for the solution here but look out for the algorithms,i would like to give you some help here.\\n\\n1.  Use another array for the problem of lenght 501(counter) since the constarints are array length is not more than 500 and keep having a track of all elements and their counts in this array and then take another loop and then check if the counter array here contains same value as iterator variable and if yes take it one of the variable(since there is a possibility that we might find greater value than this and in the end return that variable.\\n\\n2. Use HashMap for this,first go on adding all the elements and their values in it and then in the end if you find that the key and value are same store it\\'s value in the variable,return this variable in the end.Here you can use any other DS that you are more used to.\\n\\n3. Sort the array and iterate through it from back and return the first element you find has value same as the number of times it has occured and return the same.\\n4. You can also use Heap here.\\n5. Use Bitwise and store the values in upper part of integer,then return the max one,this is most effective since it has time complexity of O(n) and space of O(1).\\n\\nThat\\'s it,I Hope I was helpful."
                    },
                    {
                        "username": "muneerwani78",
                        "content": "can you explain more about this bitwise approach"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "I solved this problem in javascript using the concept of maps  First stored the value and its occurence and then compare if value is equal to occurance  if yes then that is lucky integer"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases I used\\n\\n```\\n[2,2,3,4]\\n[1,2,2,3,3,3]\\n[2,2,2,3,3]\\n[1,2,2]\\n[2,1,2,3,4,3,5,4,3]\\n[3,4,3,4,3,4,2,4,2,1]\\n[1,2,2,10,30,11,11,11,11,11,11,11,11,11,11,11]\\n[1,2,2,10,30,11,11,11,11,11,11,11,11,11,11]\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "question_content": "<p>You are given two integers, <code>x</code> and <code>y</code>, which represent your current location on a Cartesian grid: <code>(x, y)</code>. You are also given an array <code>points</code> where each <code>points[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents that a point exists at <code>(a<sub>i</sub>, b<sub>i</sub>)</code>. A point is <strong>valid</strong> if it shares the same x-coordinate or the same y-coordinate as your location.</p>\n\n<p>Return <em>the index <strong>(0-indexed)</strong> of the <strong>valid</strong> point with the smallest <strong>Manhattan distance</strong> from your current location</em>. If there are multiple, return <em>the valid point with the <strong>smallest</strong> index</em>. If there are no valid points, return <code>-1</code>.</p>\n\n<p>The <strong>Manhattan distance</strong> between two points <code>(x<sub>1</sub>, y<sub>1</sub>)</code> and <code>(x<sub>2</sub>, y<sub>2</sub>)</code> is <code>abs(x<sub>1</sub> - x<sub>2</sub>) + abs(y<sub>1</sub> - y<sub>2</sub>)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 3, y = 4, points = [[3,4]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The answer is allowed to be on the same location as your current location.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 3, y = 4, points = [[2,3]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There are no valid points.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>1 &lt;= x, y, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1096346,
                "title": "java-python-3-straight-forward-codes",
                "content": "**Q & A**\\nQ1: Why have you initialized index with `-1` and not `0`?\\n\\nA1: Make the code more general. e.g., If no point has the same `x` or `y` coordinate, then we can still detect it by the return value. Otherwise, if the return value is `0`, we would NOT know whether the point at index `0` is the solution or not.\\n\\n**End of Q & A**\\n\\n----\\n\\nExplanation by **@lionkingeatapple**\\n\\nBecause we want A point that shares the same `x`-coordinate or the same `y`-coordinate as your location, `dx * dy == 0` indicate either `dx` equals zero or `dy` equals zero, so we can make the product of `dx` and `dy` to be zero. `dx` and `dy` means the difference of `x`-coordinate and `y`-coordinate respectively. If the difference is zero, then they must be equal or shares the same `x/y`-coordinate.\\n\\nAlso, credit to **@KellyBundy** for improvement.\\n\\n```java\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int index = -1; \\n        for (int i = 0, smallest = Integer.MAX_VALUE; i < points.length; ++i) {\\n            int dx = x - points[i][0], dy = y - points[i][1];\\n            if (dx * dy == 0 && Math.abs(dy + dx) < smallest) {\\n                smallest = Math.abs(dx + dy);\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n```\\n\\n```python\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        index, smallest = -1, math.inf\\n        for i, (r, c) in enumerate(points):\\n            dx, dy = x - r, y - c\\n            if dx * dy == 0 and abs(dx + dy) < smallest:\\n                smallest = abs(dx + dy)\\n                index = i\\n        return index\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int index = -1; \\n        for (int i = 0, smallest = Integer.MAX_VALUE; i < points.length; ++i) {\\n            int dx = x - points[i][0], dy = y - points[i][1];\\n            if (dx * dy == 0 && Math.abs(dy + dx) < smallest) {\\n                smallest = Math.abs(dx + dy);\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n```\n```python\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        index, smallest = -1, math.inf\\n        for i, (r, c) in enumerate(points):\\n            dx, dy = x - r, y - c\\n            if dx * dy == 0 and abs(dx + dy) < smallest:\\n                smallest = abs(dx + dy)\\n                index = i\\n        return index\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1859878,
                "title": "simple-for-beginners-java-approach",
                "content": "##### Q & A\\n##### Q1: Why have you initialized index with -1 and not 0?\\n##### \\n##### A1: Make the code more general. e.g., If no point has the same x or y coordinate, then we can still detect it by the return value. Otherwise, if the return value is 0, we would NOT know whether the point at index 0 is the solution or not.\\n\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min=Integer.MAX_VALUE, index=-1, i;\\n        \\n        for ( i=0;i<points.length;i++){\\n            if (x==points[i][0] ||  y==points[i][1]){\\n                 int d = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (d<min){\\n                    min=d;\\n                    index=i;\\n                }\\n            }\\n            \\n        }\\n        // if ( min== Integer.MAX_VALUE) return -1; --> no longer needed as index is initialized as -1 in the declartion.\\n        return  index;\\n        \\n    }\\n}\\n```\\n\\nPlease Upvote if it help :) (it boost my confidence!)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min=Integer.MAX_VALUE, index=-1, i;\\n        \\n        for ( i=0;i<points.length;i++){\\n            if (x==points[i][0] ||  y==points[i][1]){\\n                 int d = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (d<min){\\n                    min=d;\\n                    index=i;\\n                }\\n            }\\n            \\n        }\\n        // if ( min== Integer.MAX_VALUE) return -1; --> no longer needed as index is initialized as -1 in the declartion.\\n        return  index;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096269,
                "title": "o-n-simple-solution-w-explanation-c-short-concise",
                "content": "We can simply iterate over all the points in `points` array and if a point is valid (has the same `x` or `y` co-ordinate as our location), find its *manhattan distance* and remember its index if that is the minimum one. Lastly, just return the index.\\n```\\nint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n\\tint n = points.size(), mn = INT_MAX, ans = -1, manhattan;\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tif(points[i][0] == x || points[i][1] == y){\\n\\t\\t\\tmanhattan = abs(x - points[i][0]) + abs(y - points[i][1]);\\n\\t\\t\\tif(manhattan < mn)\\n\\t\\t\\t\\tmn = manhattan, ans = i;            \\n\\t\\t}\\n\\treturn ans;\\n}\\n```\\n**Time Complexity** : **`O(N)`**, where `N` is the numbe of points in the `points` vector.\\n**Space Complexity** : **`O(1)`**, since only constant space is used.",
                "solutionTags": [],
                "code": "```\\nint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n\\tint n = points.size(), mn = INT_MAX, ans = -1, manhattan;\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tif(points[i][0] == x || points[i][1] == y){\\n\\t\\t\\tmanhattan = abs(x - points[i][0]) + abs(y - points[i][1]);\\n\\t\\t\\tif(manhattan < mn)\\n\\t\\t\\t\\tmn = manhattan, ans = i;            \\n\\t\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229047,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        minDist = math.inf\\n        ans = -1\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manDist = abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if manDist<minDist:\\n                    ans = i\\n                    minDist = manDist\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        minDist = math.inf\\n        ans = -1\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manDist = abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if manDist<minDist:\\n                    ans = i\\n                    minDist = manDist\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098080,
                "title": "javascript-100-100-simple",
                "content": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let min = Infinity\\n    let idx = -1\\n    points.forEach(([a,b], i)=>{\\n        if(a===x || b===y){\\n            const dist = Math.abs(x-a) + Math.abs(y-b)\\n            if(dist<min){\\n                idx = i\\n                min = dist\\n            }\\n        }\\n    })\\n    return idx\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let min = Infinity\\n    let idx = -1\\n    points.forEach(([a,b], i)=>{\\n        if(a===x || b===y){\\n            const dist = Math.abs(x-a) + Math.abs(y-b)\\n            if(dist<min){\\n                idx = i\\n                min = dist\\n            }\\n        }\\n    })\\n    return idx\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1097674,
                "title": "c-easy-solution-100-time-100-space",
                "content": "Simple solution in `O(n)` complexity.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int pos = -1;\\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<points.size(); i++){\\n            if(points[i][0] == x or points[i][1] == y){\\n                int dist = abs(x-points[i][0]) + abs(y-points[i][1]);\\n                if(dist < ans){\\n                    pos = i;\\n                    ans = dist;\\n                }\\n            }   \\n        }\\n       return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int pos = -1;\\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<points.size(); i++){\\n            if(points[i][0] == x or points[i][1] == y){\\n                int dist = abs(x-points[i][0]) + abs(y-points[i][1]);\\n                if(dist < ans){\\n                    pos = i;\\n                    ans = dist;\\n                }\\n            }   \\n        }\\n       return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454100,
                "title": "python-beginners-85-fast",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        min_dis= 10000 \\n        ind = -1\\n        for i in range (len (points)):\\n            if points[i][0] == x or points [i][1] == y:\\n                mandist = abs(points[i][0] -x) + abs(points[i][1] - y)\\n                if mandist < min_dis :\\n                    min_dis = mandist\\n                    ind = i\\n        return ind\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        min_dis= 10000 \\n        ind = -1\\n        for i in range (len (points)):\\n            if points[i][0] == x or points [i][1] == y:\\n                mandist = abs(points[i][0] -x) + abs(points[i][1] - y)\\n                if mandist < min_dis :\\n                    min_dis = mandist\\n                    ind = i\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096965,
                "title": "c-linear-solution-explained-100-time-100-space",
                "content": "Pleasant warm up - easy to understand and to execute.\\n\\nTo solve this problem, we will need 2 support variables first:\\n* `res` is where we will store the position of the first best fit we find, initially set to `-1` (which will then be returned when no match has been found);\\n* `bestDist` will store the current closest distance across all the matches we found - initially set to `INT_MAX`.\\n\\nWe will then loop through all the elements in `points` and for each one we will:\\n* assign the 2 values inside `points` as `cx` and `cy`;\\n* check if `x == cx || y == cy` as per requirements and, in case:\\n\\t* compute `currDist` as the Manhattan distance between `{x, y}` and `{cx, cy}`;\\n\\t* check if `currDist < bestDist` and in case update both `bestDist` and `res` accordingly.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        // support variables\\n        int res = -1, bestDist = INT_MAX;\\n        // parsing points\\n        for (int i = 0, cx, cy, currDist, lmt = points.size(); i < lmt; i ++) {\\n            // assigning cx and cy\\n            cx = points[i][0], cy = points[i][1];\\n            // looking for a match\\n            if (x == cx || y == cy) {\\n                // computing currDist and in case updating bestDist and res\\n                currDist = abs(y - cy) + abs(x - cx);\\n                if (currDist < bestDist) {\\n                    bestDist = currDist, res = i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        // support variables\\n        int res = -1, bestDist = INT_MAX;\\n        // parsing points\\n        for (int i = 0, cx, cy, currDist, lmt = points.size(); i < lmt; i ++) {\\n            // assigning cx and cy\\n            cx = points[i][0], cy = points[i][1];\\n            // looking for a match\\n            if (x == cx || y == cy) {\\n                // computing currDist and in case updating bestDist and res\\n                currDist = abs(y - cy) + abs(x - cx);\\n                if (currDist < bestDist) {\\n                    bestDist = currDist, res = i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500068,
                "title": "java-arrays-find-nearest-point-that-has-the-same-x-or-y-coordinate",
                "content": "\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int minManh = Integer.MAX_VALUE;\\n        int indMin = -1;\\n        for (int i = 0; i < points.length; i++)\\n        {\\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\\n            {\\n                minManh = tmpManh;\\n                indMin = i;\\n            }\\n        }\\n        return indMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int minManh = Integer.MAX_VALUE;\\n        int indMin = -1;\\n        for (int i = 0; i < points.length; i++)\\n        {\\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\\n            {\\n                minManh = tmpManh;\\n                indMin = i;\\n            }\\n        }\\n        return indMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956751,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int ans=-1;\\n        int temp=10001;\\n        for(int i=0;i<points.length;i++)\\n        {\\n            if(points[i][0]==x||points[i][1]==y)\\n            {\\n                int val=Math.abs(points[i][0]-x)+Math.abs(points[i][1]-y);\\n                if(val<temp){\\n                    temp=val;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int ans=-1;\\n        int temp=10001;\\n        for(int i=0;i<points.length;i++)\\n        {\\n            if(points[i][0]==x||points[i][1]==y)\\n            {\\n                int val=Math.abs(points[i][0]-x)+Math.abs(points[i][1]-y);\\n                if(val<temp){\\n                    temp=val;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773609,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "`Find Nearest Point That Has the Same X or Y Coordinate`\\n1) Loop through the vector of points.\\n2) If x or y coordinate matches, Calculate and record manhatten distance for every point.\\n3) Compare every time if manhattan distance is lesser than the previous recorded least distance.\\n4) Return the least distance point\\'s index no. \\n\\n# **Pretty ez question ig ! Really good for beginners !  \\uD83D\\uDD25**\\n\\n```\\nTC: O(n)\\nSC: O(1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int manhattan,d=INT_MAX,ans=-1;\\n        for(int i=0;i<points.size();i++){\\n            if(points[i][0]==x || points[i][1]==y){\\n                manhattan=abs(x - points[i][0]) + abs(y - points[i][1]);\\n                if(manhattan<d){\\n                    d=manhattan;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# ***Please upvote if it helps \\uD83D\\uDE4F.***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```\\nTC: O(n)\\nSC: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int manhattan,d=INT_MAX,ans=-1;\\n        for(int i=0;i<points.size();i++){\\n            if(points[i][0]==x || points[i][1]==y){\\n                manhattan=abs(x - points[i][0]) + abs(y - points[i][1]);\\n                if(manhattan<d){\\n                    d=manhattan;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220848,
                "title": "python3-simple-naive-approach",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        result = None\\n        maximumDistance = float(\"inf\")\\n        \\n        for index,point in enumerate(points):\\n            a,b = point\\n            distance = abs(x-a) + abs(y-b)\\n            if distance < maximumDistance and (x == a or y == b):\\n                maximumDistance = distance\\n                result = index\\n        \\n        return result if result != None else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        result = None\\n        maximumDistance = float(\"inf\")\\n        \\n        for index,point in enumerate(points):\\n            a,b = point\\n            distance = abs(x-a) + abs(y-b)\\n            if distance < maximumDistance and (x == a or y == b):\\n                maximumDistance = distance\\n                result = index\\n        \\n        return result if result != None else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852951,
                "title": "super-ugly-python-one-liner-for-those-who-are-into-this-stuff-d",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        return min(map(lambda p:[abs(p[0] - x) + abs(p[1] - y), p[2]], list(filter(lambda p:p[0] == x or p[1] == y, map(lambda l:l[1] + [l[0]], enumerate(points)))) or [[0,0,-1]]))[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        return min(map(lambda p:[abs(p[0] - x) + abs(p[1] - y), p[2]], list(filter(lambda p:p[0] == x or p[1] == y, map(lambda l:l[1] + [l[0]], enumerate(points)))) or [[0,0,-1]]))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732868,
                "title": "java-simple-explained",
                "content": "**T/S:** O(n)/O(1), where n = size(points)\\n```\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n\\tvar nearest = -1;\\n\\n\\tfor (int i = 0, minDistance = Integer.MAX_VALUE; i < points.length; i++)\\n\\t\\tif (x == points[i][0] || y == points[i][1]) { // check valid point\\n\\t\\t\\tvar distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]); // find Manhattan distance\\n\\t\\t\\t\\n\\t\\t\\tif (minDistance > distance) { \\n\\t\\t\\t\\tminDistance = distance; // maintain the nearest valid point\\n\\t\\t\\t\\tnearest = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn nearest;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n\\tvar nearest = -1;\\n\\n\\tfor (int i = 0, minDistance = Integer.MAX_VALUE; i < points.length; i++)\\n\\t\\tif (x == points[i][0] || y == points[i][1]) { // check valid point\\n\\t\\t\\tvar distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]); // find Manhattan distance\\n\\t\\t\\t\\n\\t\\t\\tif (minDistance > distance) { \\n\\t\\t\\t\\tminDistance = distance; // maintain the nearest valid point\\n\\t\\t\\t\\tnearest = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn nearest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099607,
                "title": "java-easy-to-understand-1ms-beats-100-o-points-length",
                "content": "\\n    // O(points.length) O(1)\\n\\tpublic int nearestValidPoint(int x, int y, int[][] points) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, ans = -1, idx = -1;\\n\\t\\tfor (int[] point : points) {\\n\\t\\t\\tidx++;\\n\\t\\t\\tif (point[0] == x || point[1] == y) {\\n\\t\\t\\t\\tint dist = distance(x, y, point[0], point[1]);\\n\\t\\t\\t\\tif (dist < min) {\\n\\t\\t\\t\\t\\tmin = dist;\\n\\t\\t\\t\\t\\tans = idx;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic int distance(int x1, int y1, int x2, int y2) {\\n\\t\\treturn Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(points.length) O(1)\\n\\tpublic int nearestValidPoint(int x, int y, int[][] points) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, ans = -1, idx = -1;\\n\\t\\tfor (int[] point : points) {\\n\\t\\t\\tidx++;\\n\\t\\t\\tif (point[0] == x || point[1] == y) {\\n\\t\\t\\t\\tint dist = distance(x, y, point[0], point[1]);\\n\\t\\t\\t\\tif (dist < min) {\\n\\t\\t\\t\\t\\tmin = dist;\\n\\t\\t\\t\\t\\tans = idx;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic int distance(int x1, int y1, int x2, int y2) {\\n\\t\\treturn Math.abs(x1 - x2) + Math.abs(y1 - y2);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3266036,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array**. \\n\\n*At each iteration* we have to check if **the point is valid**, in this case we have to check if the distance of this point is shorter than the distance that we found in previous iterations.\\n\\n**Note:** The initialization of sIndex and sDistance is higher than the *maximum value allowed by the input conditions*.\\n \\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 78.3%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int sIndex = 100000;\\n        int sDistance = 100000;\\n\\n        for (int i = 0; i < points.length; i++) {\\n            \\n            // Check if is a valid point\\n            if (points[i][0] == x || points[i][1] == y) {\\n\\n                // Check if it is better than the previous best\\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (sDistance > distance) {\\n                    sDistance = distance;\\n                    sIndex = i;\\n                }\\n            }\\n        }\\n\\n        // Check if we have a valid point to return\\n        if (sIndex == 100000)\\n            return -1;\\n        return sIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int sIndex = 100000;\\n        int sDistance = 100000;\\n\\n        for (int i = 0; i < points.length; i++) {\\n            \\n            // Check if is a valid point\\n            if (points[i][0] == x || points[i][1] == y) {\\n\\n                // Check if it is better than the previous best\\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (sDistance > distance) {\\n                    sDistance = distance;\\n                    sIndex = i;\\n                }\\n            }\\n        }\\n\\n        // Check if we have a valid point to return\\n        if (sIndex == 100000)\\n            return -1;\\n        return sIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857595,
                "title": "simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) \\n    {\\n        /*  \\n\\t\\tHere we are just iterating over the given array and if we get any \\n\\t\\tvalid point (i.e. it shares either x-coordinate OR y-coordinate with\\n\\t\\tour obtained points) and if the currDist is more than ManhattanDist\\n\\t\\tthen we update it and over this whole process we maintain a variable \\n\\t\\tfor storing the smallest index.\\n        \\n         TC -> O(N) , N = number of points in points array\\n         SC -> O(1) \\n\\t\\t\\n\\t\\t*/\\n        \\n        \\n        int res = -1;\\n        int n = points.size();\\n        int dist = INT_MAX;\\n        int ManhattanDist;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(points[i][0] == x || points[i][1] == y)\\n            {\\n                ManhattanDist = abs(x-points[i][0]) + abs(y-points[i][1]);\\n                \\n                if(ManhattanDist < dist)\\n                {\\n                    dist = ManhattanDist;\\n                    res = i;\\n                }\\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) \\n    {\\n        /*  \\n\\t\\tHere we are just iterating over the given array and if we get any \\n\\t\\tvalid point (i.e. it shares either x-coordinate OR y-coordinate with\\n\\t\\tour obtained points) and if the currDist is more than ManhattanDist\\n\\t\\tthen we update it and over this whole process we maintain a variable \\n\\t\\tfor storing the smallest index.\\n        \\n         TC -> O(N) , N = number of points in points array\\n         SC -> O(1) \\n\\t\\t\\n\\t\\t*/\\n        \\n        \\n        int res = -1;\\n        int n = points.size();\\n        int dist = INT_MAX;\\n        int ManhattanDist;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(points[i][0] == x || points[i][1] == y)\\n            {\\n                ManhattanDist = abs(x-points[i][0]) + abs(y-points[i][1]);\\n                \\n                if(ManhattanDist < dist)\\n                {\\n                    dist = ManhattanDist;\\n                    res = i;\\n                }\\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627509,
                "title": "easiest-and-fastest-solution",
                "content": "Please Upvote (^_^)\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] point) {\\n        int ans=Integer.MAX_VALUE;\\n        int var=-1;\\n        for(int i=0;i<point.length;i++)\\n        {\\n            \\n            if(point[i][0]==x || point[i][1]==y)\\n            {\\n                int m=Math.abs(x-point[i][0])+Math.abs(y-point[i][1]);\\n                if(m<ans)\\n                {\\n                    ans=m;\\n                    var=i;\\n                }\\n            }\\n        }\\n        return var;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] point) {\\n        int ans=Integer.MAX_VALUE;\\n        int var=-1;\\n        for(int i=0;i<point.length;i++)\\n        {\\n            \\n            if(point[i][0]==x || point[i][1]==y)\\n            {\\n                int m=Math.abs(x-point[i][0])+Math.abs(y-point[i][1]);\\n                if(m<ans)\\n                {\\n                    ans=m;\\n                    var=i;\\n                }\\n            }\\n        }\\n        return var;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180778,
                "title": "javascript-solution-using-a-map-object",
                "content": "Found this solution helpful? Consider showing support by upvoting this post. If there are any questions, kindly leave a comment below. Thank you and happy hacking!\\n```\\nvar nearestValidPoint = function (x, y, points) {\\n    let manhattanIndices = new Map()\\n    let currentMin = Infinity\\n\\n    points.forEach((point, i) => {\\n        if (point[0] === x || point[1] === y) {\\n            manhattanIndices.set(i, Math.abs(x - point[0]) + Math.abs(y - point[1]))\\n            currentMin = Math.min(currentMin, Math.abs(x - point[0]) + Math.abs(y - point[1]))\\n        }\\n    })\\n\\n    for(let [index, distance] of manhattanIndices){\\n        if(distance === currentMin){\\n            return index\\n        }\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nearestValidPoint = function (x, y, points) {\\n    let manhattanIndices = new Map()\\n    let currentMin = Infinity\\n\\n    points.forEach((point, i) => {\\n        if (point[0] === x || point[1] === y) {\\n            manhattanIndices.set(i, Math.abs(x - point[0]) + Math.abs(y - point[1]))\\n            currentMin = Math.min(currentMin, Math.abs(x - point[0]) + Math.abs(y - point[1]))\\n        }\\n    })\\n\\n    for(let [index, distance] of manhattanIndices){\\n        if(distance === currentMin){\\n            return index\\n        }\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028388,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x1, y1, points):\\n        minIdx, minDist = -1, inf\\n        for i,point in enumerate(points):\\n            x2, y2 = point\\n            if x1 == x2 or y1 == y2:\\n                dist = abs(x1-x2) + abs(y1-y2)\\n                if dist < minDist:\\n                    minIdx = i\\n                    minDist = min(dist,minDist)\\n        return minIdx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x1, y1, points):\\n        minIdx, minDist = -1, inf\\n        for i,point in enumerate(points):\\n            x2, y2 = point\\n            if x1 == x2 or y1 == y2:\\n                dist = abs(x1-x2) + abs(y1-y2)\\n                if dist < minDist:\\n                    minIdx = i\\n                    minDist = min(dist,minDist)\\n        return minIdx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097727,
                "title": "ruby-o-n",
                "content": "```\\n# @param {Integer} x\\n# @param {Integer} y\\n# @param {Integer[][]} points\\n# @return {Integer}\\ndef nearest_valid_point(x, y, points)\\n  distances = []\\n  \\n  points.each_with_index do |point, index|\\n    a, b = point\\n    distances << [(x - a).abs + (y - b).abs, index] if a == x || b == y\\n  end\\n  \\n  return -1 if distances.empty?\\n  \\n  distances.sort.first.last\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} x\\n# @param {Integer} y\\n# @param {Integer[][]} points\\n# @return {Integer}\\ndef nearest_valid_point(x, y, points)\\n  distances = []\\n  \\n  points.each_with_index do |point, index|\\n    a, b = point\\n    distances << [(x - a).abs + (y - b).abs, index] if a == x || b == y\\n  end\\n  \\n  return -1 if distances.empty?\\n  \\n  distances.sort.first.last\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2944474,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans = -1, mdis = INT_MAX;\\n        for(int i=0; i<points.size(); i++) {\\n            if(points[i][0] == x or points[i][1] == y) {\\n                int dis = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                if(dis < mdis) mdis = dis, ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans = -1, mdis = INT_MAX;\\n        for(int i=0; i<points.size(); i++) {\\n            if(points[i][0] == x or points[i][1] == y) {\\n                int dis = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                if(dis < mdis) mdis = dis, ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847164,
                "title": "python-solution-easy-to-understand-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\n        minn=float(\\'inf\\')\\n        index=-1\\n        for i , v in enumerate(points):\\n            if v[0]==x or v[1]==y:\\n                man_dis=abs(x - v[0]) + abs(y - v[1])\\n                if(man_dis<minn) :\\n                    minn=man_dis\\n                    index=i\\n        \\n        return index\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\n        minn=float(\\'inf\\')\\n        index=-1\\n        for i , v in enumerate(points):\\n            if v[0]==x or v[1]==y:\\n                man_dis=abs(x - v[0]) + abs(y - v[1])\\n                if(man_dis<minn) :\\n                    minn=man_dis\\n                    index=i\\n        \\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745533,
                "title": "explained-solution-beats-90-in-time-95-in-space-c",
                "content": "We first check whether there are common coordinates between the given (x,y) & elements of the given array. If there is we compare it with the previous **Manhattan distance** & if it is less we update the index to be returned to the current one [remember we are asked for the index of the point with smallest Manhattan distance and not the distance itself].\\n\\nI\\'ve used ternary operators here, which are bascially a concise form of if else statements, it reduces lines of code and makes your work look clean, I recommend you learning it.\\n\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int M=INT_MAX, soln=-1;\\n        for (int i=0; i<points.size(); i++) {\\n            \\n            // let\\'s see if there are any common coordinates or not\\n            if (x==points[i][0] || y==points[i][1]) {\\n\\n                // let\\'s store the Manhattan distance to variable t\\n                int t= abs(y-points[i][1]) + abs(x-points[i][0]);\\n\\n                // M stores the previous Manhattan distance value. If the current distance is less we update the index\\n                // even if the distance is equal, we don\\'t update the index as we\\'re asked for the lowest index\\n                soln=M>t ? i:soln;\\n\\n                // we also update the Manhattan distance, for future calculations\\n                M = M<t ? M:t;\\n            }\\n        }\\n\\n        // we return the index of the point with least Manhattan distance\\n        return soln;\\n    }\\n};\\n```\\n\\n*Hey! If this post clearified your understanding on how to approach the question, please upvote this solution \\uD83D\\uDCA1*",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int M=INT_MAX, soln=-1;\\n        for (int i=0; i<points.size(); i++) {\\n            \\n            // let\\'s see if there are any common coordinates or not\\n            if (x==points[i][0] || y==points[i][1]) {\\n\\n                // let\\'s store the Manhattan distance to variable t\\n                int t= abs(y-points[i][1]) + abs(x-points[i][0]);\\n\\n                // M stores the previous Manhattan distance value. If the current distance is less we update the index\\n                // even if the distance is equal, we don\\'t update the index as we\\'re asked for the lowest index\\n                soln=M>t ? i:soln;\\n\\n                // we also update the Manhattan distance, for future calculations\\n                M = M<t ? M:t;\\n            }\\n        }\\n\\n        // we return the index of the point with least Manhattan distance\\n        return soln;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295534,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int n = points.size();\\n        int temp = INT_MAX;\\n        int distance;\\n        int ans = INT_MIN;\\n        for(int i = 0; i < n; i++) {\\n            if(points[i][0] == x || points[i][1] == y) {\\n                distance = (abs(x-points[i][0]) + abs(y-points[i][1]));\\n                if (temp > distance) {\\n                    temp = distance;\\n                    ans = i;\\n                } \\n            }\\n        }\\n         return ans == INT_MIN ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int n = points.size();\\n        int temp = INT_MAX;\\n        int distance;\\n        int ans = INT_MIN;\\n        for(int i = 0; i < n; i++) {\\n            if(points[i][0] == x || points[i][1] == y) {\\n                distance = (abs(x-points[i][0]) + abs(y-points[i][1]));\\n                if (temp > distance) {\\n                    temp = distance;\\n                    ans = i;\\n                } \\n            }\\n        }\\n         return ans == INT_MIN ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843128,
                "title": "easily-understandable-code",
                "content": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        mdist=float(\\'inf\\')#assigning a large value to the manhattan distance\\n        index=-1#starting with index -1 because if we are not able to find any point then we can return -1 as mentioned in the question\\n        #after that we are going through each point\\n        for i in range(len(points)):\\n            if points[i][0] ==x or points[i][1]==y:#checking the condition to satisfy the manhattan conditions\\n                num=abs(points[i][0]-x)+abs(points[i][1]-y)#calculating the manhattan distance\\n                if num<mdist:\\n                    mdist=num#if we are able to find any distance then updating it\\n                    index=i#we are also storing its index also as we have to return it \\n        return index\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        mdist=float(\\'inf\\')#assigning a large value to the manhattan distance\\n        index=-1#starting with index -1 because if we are not able to find any point then we can return -1 as mentioned in the question\\n        #after that we are going through each point\\n        for i in range(len(points)):\\n            if points[i][0] ==x or points[i][1]==y:#checking the condition to satisfy the manhattan conditions\\n                num=abs(points[i][0]-x)+abs(points[i][1]-y)#calculating the manhattan distance\\n                if num<mdist:\\n                    mdist=num#if we are able to find any distance then updating it\\n                    index=i#we are also storing its index also as we have to return it \\n        return index\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032003,
                "title": "python3-easiest-and-most-understandable-solution",
                "content": "The solution has three parts, \\n1. Checking the validity of the given points.\\n2. Finding the smallest Manhattan distance \\n3. returning the index of the smallest Manhattan distance \\n\\nWe check if there are no valid points and return -1\\n\\n# Code\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid=[]\\n        for i in points:\\n            if i[0]==x or i[1]==y:\\n                valid.append(i)\\n        dist=[]\\n        if len(valid) == 0:\\n            return -1\\n        else :\\n            for i in valid:\\n                dist.append(abs(x - i[0]) + abs(y - i[1]))\\n            if valid[dist.index(min(dist))] in valid:\\n                return points.index(valid[dist.index(min(dist))])\\n\\n\\n\\n\\n          \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid=[]\\n        for i in points:\\n            if i[0]==x or i[1]==y:\\n                valid.append(i)\\n        dist=[]\\n        if len(valid) == 0:\\n            return -1\\n        else :\\n            for i in valid:\\n                dist.append(abs(x - i[0]) + abs(y - i[1]))\\n            if valid[dist.index(min(dist))] in valid:\\n                return points.index(valid[dist.index(min(dist))])\\n\\n\\n\\n\\n          \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692733,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ind = -1;\\n        int dist = INT_MAX; \\n        for(int i =0; i<points.size(); i++){\\n            if(points[i][0] == x || points[i][1] == y){\\n                int temp = abs(x-points[i][0])+abs(y-points[i][1]);\\n                if(dist > temp){\\n                    dist = temp;\\n                    ind = i;\\n                }\\n                \\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ind = -1;\\n        int dist = INT_MAX; \\n        for(int i =0; i<points.size(); i++){\\n            if(points[i][0] == x || points[i][1] == y){\\n                int temp = abs(x-points[i][0])+abs(y-points[i][1]);\\n                if(dist > temp){\\n                    dist = temp;\\n                    ind = i;\\n                }\\n                \\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597073,
                "title": "c-brute-force-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int mi=INT_MAX,res=-1;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int x1=points[i][0],y1=points[i][1];\\n            if(x==x1||y==y1) \\n            {\\n                int dis=abs(x1-x)+abs(y1-y);\\n                if(mi>dis) \\n                {\\n                    mi=dis;\\n                    res=i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you like it, please upvote..",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int mi=INT_MAX,res=-1;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            int x1=points[i][0],y1=points[i][1];\\n            if(x==x1||y==y1) \\n            {\\n                int dis=abs(x1-x)+abs(y1-y);\\n                if(mi>dis) \\n                {\\n                    mi=dis;\\n                    res=i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436516,
                "title": "js-easy-greedy-o-n-solution",
                "content": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let distance = 99999, validIndex = -1;\\n    \\n    for(let i in points) {\\n        const [a, b] = points[i];\\n        if(a != x && b != y) continue;\\n        \\n        let manhattan = Math.abs(x-a) || Math.abs(y-b);\\n        \\n        // It is not necessary to continue if found (x,y) coordinate\\n        if(manhattan === 0) return i;\\n        if(manhattan < distance) [distance, validIndex] = [manhattan, i]\\n    }\\n    \\n    return validIndex;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let distance = 99999, validIndex = -1;\\n    \\n    for(let i in points) {\\n        const [a, b] = points[i];\\n        if(a != x && b != y) continue;\\n        \\n        let manhattan = Math.abs(x-a) || Math.abs(y-b);\\n        \\n        // It is not necessary to continue if found (x,y) coordinate\\n        if(manhattan === 0) return i;\\n        if(manhattan < distance) [distance, validIndex] = [manhattan, i]\\n    }\\n    \\n    return validIndex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423087,
                "title": "java-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n       var nearest = - 1;\\n\\n\\tfor (int i = 0, minDistance = Integer.MAX_VALUE; i < points.length; i ++)\\n\\t\\tif (x == points[i][0] || y == points[i][1]) { // check valid point\\n\\t\\t\\tvar distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]); // find Manhattan distance\\n\\t\\t\\t\\n\\t\\t\\tif (minDistance > distance) { \\n\\t\\t\\t\\tminDistance = distance; // maintain the nearest valid point\\n\\t\\t\\t\\tnearest = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn nearest; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n       var nearest = - 1;\\n\\n\\tfor (int i = 0, minDistance = Integer.MAX_VALUE; i < points.length; i ++)\\n\\t\\tif (x == points[i][0] || y == points[i][1]) { // check valid point\\n\\t\\t\\tvar distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]); // find Manhattan distance\\n\\t\\t\\t\\n\\t\\t\\tif (minDistance > distance) { \\n\\t\\t\\t\\tminDistance = distance; // maintain the nearest valid point\\n\\t\\t\\t\\tnearest = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn nearest; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380441,
                "title": "easy-javascript-solution",
                "content": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let minDist = Infinity;\\n    let res;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        let [currX, currY] = points[i];\\n        \\n        if (currX === x || currY === y) {\\n            let dist = Math.abs(x - currX) + Math.abs(y - currY);\\n            if (dist < minDist) {\\n                minDist = dist;\\n                res = i;\\n            }\\n        }\\n    }\\n    \\n    if (res === 0) return 0;\\n    \\n    return res ? res : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let minDist = Infinity;\\n    let res;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        let [currX, currY] = points[i];\\n        \\n        if (currX === x || currY === y) {\\n            let dist = Math.abs(x - currX) + Math.abs(y - currY);\\n            if (dist < minDist) {\\n                minDist = dist;\\n                res = i;\\n            }\\n        }\\n    }\\n    \\n    if (res === 0) return 0;\\n    \\n    return res ? res : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988349,
                "title": "sss-simple-swift-solution",
                "content": "```\\nfunc nearestValidPoint(_ x: Int, _ y: Int, _ points: [[Int]]) -> Int {\\n\\tvar (result, dMin) = (-1, Int.max)\\n\\n\\tfor (i, point) in points.enumerated() {\\n\\t\\tlet x1 = point[0], y1 = point[1]\\n\\t\\tguard x == x1 || y == y1 else { continue }\\n\\t\\tlet d = abs(x - x1) + abs( y - y1)\\n\\t\\tif d < dMin {\\n\\t\\t\\tdMin = d\\n\\t\\t\\tresult = i\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\nor\\n\\n```\\nfunc nearestValidPoint(_ x: Int, _ y: Int, _ points: [[Int]]) -> Int {\\n    let notFoundIndexValue = -1\\n    var (result, mdMin) = (notFoundIndexValue, 0)\\n\\n    for (i, point) in points.enumerated() {\\n        let (x1, y1) = (point[0], point[1])\\n        guard x == x1 || y == y1 else { continue }\\n        let md = abs(x - x1) + abs(y - y1)\\n        guard result != notFoundIndexValue else {\\n            (result, mdMin) = (i, md)\\n            continue\\n        }\\n        if md < mdMin { (result, mdMin) = (i, md) }\\n    }\\n\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc nearestValidPoint(_ x: Int, _ y: Int, _ points: [[Int]]) -> Int {\\n\\tvar (result, dMin) = (-1, Int.max)\\n\\n\\tfor (i, point) in points.enumerated() {\\n\\t\\tlet x1 = point[0], y1 = point[1]\\n\\t\\tguard x == x1 || y == y1 else { continue }\\n\\t\\tlet d = abs(x - x1) + abs( y - y1)\\n\\t\\tif d < dMin {\\n\\t\\t\\tdMin = d\\n\\t\\t\\tresult = i\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\n```\\nfunc nearestValidPoint(_ x: Int, _ y: Int, _ points: [[Int]]) -> Int {\\n    let notFoundIndexValue = -1\\n    var (result, mdMin) = (notFoundIndexValue, 0)\\n\\n    for (i, point) in points.enumerated() {\\n        let (x1, y1) = (point[0], point[1])\\n        guard x == x1 || y == y1 else { continue }\\n        let md = abs(x - x1) + abs(y - y1)\\n        guard result != notFoundIndexValue else {\\n            (result, mdMin) = (i, md)\\n            continue\\n        }\\n        if md < mdMin { (result, mdMin) = (i, md) }\\n    }\\n\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976169,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        # answer array to insrt the index\\n        answer = -1\\n        # starting point for distance to compare\\n        man_distance = float(\"inf\")\\n        \\n        # allows east insert to answer arrow and increment\\n        count = 0 \\n        \\n        # loop through point\\n        for point in points:\\n            if point[0] == x or point[1] == y:\\n                # compare \\n                current_man_distance = abs(point[0] - x) + abs(point[1] - y)\\n                if current_man_distance < man_distance:\\n                    # update the man_distance\\n                    man_distance = current_man_distance\\n                    answer = count\\n            \\n            # increment count\\n            count = count + 1\\n        \\n        return answer\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        # answer array to insrt the index\\n        answer = -1\\n        # starting point for distance to compare\\n        man_distance = float(\"inf\")\\n        \\n        # allows east insert to answer arrow and increment\\n        count = 0 \\n        \\n        # loop through point\\n        for point in points:\\n            if point[0] == x or point[1] == y:\\n                # compare \\n                current_man_distance = abs(point[0] - x) + abs(point[1] - y)\\n                if current_man_distance < man_distance:\\n                    # update the man_distance\\n                    man_distance = current_man_distance\\n                    answer = count\\n            \\n            # increment count\\n            count = count + 1\\n        \\n        return answer\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1897831,
                "title": "java-faster-than-100-simple-solution",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < points.length; i++) {\\n            int[] point = points[i];\\n            if (point[0] == x) {\\n                int d = Math.abs(y - point[1]);\\n                if (d < min) {\\n                    index = i;\\n                    min = d;\\n                }\\n            } else if (point[1] == y) {\\n                int d = Math.abs(x - point[0]);\\n                if (d < min) {\\n                    index = i;\\n                    min = d;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < points.length; i++) {\\n            int[] point = points[i];\\n            if (point[0] == x) {\\n                int d = Math.abs(y - point[1]);\\n                if (d < min) {\\n                    index = i;\\n                    min = d;\\n                }\\n            } else if (point[1] == y) {\\n                int d = Math.abs(x - point[0]);\\n                if (d < min) {\\n                    index = i;\\n                    min = d;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818402,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        def compute_dist(x1, y1, x2, y2):\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        min_idx, min_dist = -1, float(\\'inf\\')\\n        \\n        for i, (x_hat, y_hat) in enumerate(points):\\n            if x_hat == x or y_hat == y:\\n                curr_dist = compute_dist(x, y, x_hat, y_hat)\\n                if curr_dist < min_dist:\\n                    min_idx = i\\n                    min_dist = curr_dist\\n        return min_idx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        def compute_dist(x1, y1, x2, y2):\\n            return abs(x1-x2) + abs(y1-y2)\\n        \\n        min_idx, min_dist = -1, float(\\'inf\\')\\n        \\n        for i, (x_hat, y_hat) in enumerate(points):\\n            if x_hat == x or y_hat == y:\\n                curr_dist = compute_dist(x, y, x_hat, y_hat)\\n                if curr_dist < min_dist:\\n                    min_idx = i\\n                    min_dist = curr_dist\\n        return min_idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416723,
                "title": "easy-to-understand-javascript-solution-reduce",
                "content": "\\tvar nearestValidPoint = function(x, y, points) {\\n\\t\\tconst valid = points.reduce((acc, [pointX, pointY], index) => {\\n\\t\\t\\tif (x === pointX || y === pointY) {\\n\\t\\t\\t\\tconst distance = Math.abs(x - pointX) + Math.abs(y - pointY);\\n\\n\\t\\t\\t\\tdistance < acc.distance && (acc = { distance, index });\\n\\t\\t\\t}\\n\\t\\t\\treturn acc;\\n\\t\\t}, { distance: Infinity, index: -1 });\\n\\n\\t\\treturn valid.index;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar nearestValidPoint = function(x, y, points) {\\n\\t\\tconst valid = points.reduce((acc, [pointX, pointY], index) => {\\n\\t\\t\\tif (x === pointX || y === pointY) {\\n\\t\\t\\t\\tconst distance = Math.abs(x - pointX) + Math.abs(y - pointY);\\n\\n\\t\\t\\t\\tdistance < acc.distance && (acc = { distance, index });\\n\\t\\t\\t}\\n\\t\\t\\treturn acc;\\n\\t\\t}, { distance: Infinity, index: -1 });\\n\\n\\t\\treturn valid.index;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1096465,
                "title": "python-easy-solution-o-n",
                "content": "```\\ndef nearestValidPoint(self, x, y, p):\\n        ind = -1\\n        mn = 100000000000000\\n        for i in range(len(p)):\\n            if x == p[i][0] or y == p[i][1]:\\n                t = abs(x - p[i][0]) + abs(y - p[i][1])\\n                if t < mn:\\n                    mn, ind = t, i\\n        return ind\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef nearestValidPoint(self, x, y, p):\\n        ind = -1\\n        mn = 100000000000000\\n        for i in range(len(p)):\\n            if x == p[i][0] or y == p[i][1]:\\n                t = abs(x - p[i][0]) + abs(y - p[i][1])\\n                if t < mn:\\n                    mn, ind = t, i\\n        return ind\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1096352,
                "title": "check-all-points-o-n-time-and-o-1-space-javascript-solution",
                "content": "This is staraightforward problem, example implementation in JavaScript:\\n\\n```\\nvar nearestValidPoint = function(x, y, points) {\\n    // keep track of both the shortest distance and its index\\n    let ans = -1, ansDist = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        const [px, py] = points[i];\\n        if (px === x || py === y) {\\n            const dist = Math.abs(x - px) + Math.abs(y - py);\\n            if (dist < ansDist) {\\n                ansDist = dist;\\n                ans = i;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    // keep track of both the shortest distance and its index\\n    let ans = -1, ansDist = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        const [px, py] = points[i];\\n        if (px === x || py === y) {\\n            const dist = Math.abs(x - px) + Math.abs(y - py);\\n            if (dist < ansDist) {\\n                ansDist = dist;\\n                ans = i;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3365272,
                "title": "best-and-easy-solution-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] mat) {\\n        int min =10001;\\n        int pos=-1;\\n\\n        for(int i=0; i<mat.length; i++){\\n            if(mat[i][0]==x || mat[i][1]==y){\\n                int val = Math.abs(mat[i][0]-x)+Math.abs(mat[i][1]-y);\\n                if(val<min){\\n                    min=val;\\n                    pos=i;\\n                }\\n            }\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] mat) {\\n        int min =10001;\\n        int pos=-1;\\n\\n        for(int i=0; i<mat.length; i++){\\n            if(mat[i][0]==x || mat[i][1]==y){\\n                int val = Math.abs(mat[i][0]-x)+Math.abs(mat[i][1]-y);\\n                if(val<min){\\n                    min=val;\\n                    pos=i;\\n                }\\n            }\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927676,
                "title": "easy-c-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int mindis=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<points.size();i++){\\n            if(points[i][0]==x || points[i][1]==y){\\n                int dis=abs(x-points[i][0])+abs(y-points[i][1]);\\n                if(dis<mindis){\\n                    mindis=dis;\\n                    ans=i;\\n                   \\n                }\\n              \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int mindis=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<points.size();i++){\\n            if(points[i][0]==x || points[i][1]==y){\\n                int dis=abs(x-points[i][0])+abs(y-points[i][1]);\\n                if(dis<mindis){\\n                    mindis=dis;\\n                    ans=i;\\n                   \\n                }\\n              \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833699,
                "title": "easy-c-solution",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int val= -1; int v= INT_MAX;\\n        for (int i=0; i<points.size(); i++){\\n            if (x!=points[i][0] && y!= points[i][1])continue;\\n            if (v > (abs(points[i][0]-x)+abs(points[i][1]-y))){\\n                val= i; \\n                v=(abs(points[i][0]-x)+abs(points[i][1]-y));}\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int val= -1; int v= INT_MAX;\\n        for (int i=0; i<points.size(); i++){\\n            if (x!=points[i][0] && y!= points[i][1])continue;\\n            if (v > (abs(points[i][0]-x)+abs(points[i][1]-y))){\\n                val= i; \\n                v=(abs(points[i][0]-x)+abs(points[i][1]-y));}\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769107,
                "title": "java-2-solutions",
                "content": "# Solution 1 | 13 ms\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            if (x == points[i][0] || y == points[i][1]) {\\n                int manh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (min > manh) {\\n                    min = manh;\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n# Solution 2 | 6 ms\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1, minSum = Integer.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            if (points[i][0] == x) {\\n                int manh = Math.abs(y - points[i][1]);\\n                if (minSum > manh) {\\n                    minSum = manh;\\n                    result = i;\\n                }\\n            } else if (points[i][1] == y) {\\n                int manh = Math.abs(x - points[i][0]);\\n                if (minSum > manh) {\\n                    minSum = manh;\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            if (x == points[i][0] || y == points[i][1]) {\\n                int manh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (min > manh) {\\n                    min = manh;\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1, minSum = Integer.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            if (points[i][0] == x) {\\n                int manh = Math.abs(y - points[i][1]);\\n                if (minSum > manh) {\\n                    minSum = manh;\\n                    result = i;\\n                }\\n            } else if (points[i][1] == y) {\\n                int manh = Math.abs(x - points[i][0]);\\n                if (minSum > manh) {\\n                    minSum = manh;\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739709,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n\\n        int min = Integer.MAX_VALUE,index=-1;\\n        for(int i=0;i<points.length;i++){\\n            int dist = Math.abs(points[i][0]-x) + Math.abs(points[i][1]-y);\\n            if((points[i][0] == x || points[i][1] == y) && min > dist){\\n                // if(min > dist){\\n                    min = dist;\\n                    index=i;\\n                // }\\n            }\\n        } \\n        return index;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n\\n        int min = Integer.MAX_VALUE,index=-1;\\n        for(int i=0;i<points.length;i++){\\n            int dist = Math.abs(points[i][0]-x) + Math.abs(points[i][1]-y);\\n            if((points[i][0] == x || points[i][1] == y) && min > dist){\\n                // if(min > dist){\\n                    min = dist;\\n                    index=i;\\n                // }\\n            }\\n        } \\n        return index;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646255,
                "title": "c-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x1, int y1, vector<vector<int>>& arr) {\\n        \\n        int ans_dis=INT_MAX;\\n        int ans_idx=-1;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int x2=arr[i][0];\\n            int y2=arr[i][1];\\n\\n            if(x1==x2 or y1==y2)\\n            {\\t\\n                int dis = abs(x1 - x2) + abs(y1 - y2);\\n\\n                if(dis < ans_dis)\\n                {\\n                   ans_dis = dis;\\n                   ans_idx=i;\\t\\n                }\\t\\n            }\\n            else\\n            continue;\\n        }\\n        return ans_idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x1, int y1, vector<vector<int>>& arr) {\\n        \\n        int ans_dis=INT_MAX;\\n        int ans_idx=-1;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int x2=arr[i][0];\\n            int y2=arr[i][1];\\n\\n            if(x1==x2 or y1==y2)\\n            {\\t\\n                int dis = abs(x1 - x2) + abs(y1 - y2);\\n\\n                if(dis < ans_dis)\\n                {\\n                   ans_dis = dis;\\n                   ans_idx=i;\\t\\n                }\\t\\n            }\\n            else\\n            continue;\\n        }\\n        return ans_idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646230,
                "title": "c-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans=-1;\\n        int dis;\\n        int min_dis=INT_MAX;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x or points[i][1]==y)\\n            {\\n                dis=abs(x-points[i][0])+abs(y-points[i][1]);\\n                if(dis<min_dis)\\n                {\\n                    min_dis=dis;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans=-1;\\n        int dis;\\n        int min_dis=INT_MAX;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x or points[i][1]==y)\\n            {\\n                dis=abs(x-points[i][0])+abs(y-points[i][1]);\\n                if(dis<min_dis)\\n                {\\n                    min_dis=dis;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574759,
                "title": "java-math-array-easy-solution",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE,index=0;\\n        for(int i=0;i<points.length;i++){\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            if(x==x1 || y==y1){\\n                if(Math.abs(x-x1)+Math.abs(y-y1)<min){\\n                    min=Math.abs(x-x1)+Math.abs(y-y1);\\n                    index=i;\\n                }\\n            }\\n        }\\n        if(min==Integer.MAX_VALUE)\\n            return -1;\\n        return index;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE,index=0;\\n        for(int i=0;i<points.length;i++){\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            if(x==x1 || y==y1){\\n                if(Math.abs(x-x1)+Math.abs(y-y1)<min){\\n                    min=Math.abs(x-x1)+Math.abs(y-y1);\\n                    index=i;\\n                }\\n            }\\n        }\\n        if(min==Integer.MAX_VALUE)\\n            return -1;\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455682,
                "title": "java-easy-code-3ms-solution",
                "content": "\\n        int min=Integer.MAX_VALUE;\\n        int index=-1;\\n        int dist=0;\\n        for(int i=0;i<points.length;i++){\\n            if(points[i][0]==x||points[i][1]==y){\\n                dist = Math.abs(points[i][0]-x) + Math.abs(points[i][1]-y);\\n                if(dist<min){\\n                    min=dist;\\n                    index=i;\\n                }\\n            }\\n            \\n        }\\n        return index;\\n",
                "solutionTags": [],
                "code": "\\n        int min=Integer.MAX_VALUE;\\n        int index=-1;\\n        int dist=0;\\n        for(int i=0;i<points.length;i++){\\n            if(points[i][0]==x||points[i][1]==y){\\n                dist = Math.abs(points[i][0]-x) + Math.abs(points[i][1]-y);\\n                if(dist<min){\\n                    min=dist;\\n                    index=i;\\n                }\\n            }\\n            \\n        }\\n        return index;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2429183,
                "title": "java-goto-approach-simple-and-explained",
                "content": "**Algorithm explained**\\nTo keep the runtime low we check for valid points and the closest one in a single run through (loop).\\n\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n\\n        int minDist=Integer.MAX_VALUE;   //the variable to keep track of the minimal distance so far\\n        int currentDist=0;  //the current distance between our point and the current valid point from points[][]\\n\\t\\tint index=-1;   //the index of the future valid point with minimal distance (-1 if there are no valid points)\\n        \\n        for(int i=0; i<points.length; i++){\\n\\t\\t\\tif(points[i][0]==x||points[i][1]==y){    //if either x or y-coordinate are the same the point is valid\\n            \\n         currentDist=Math.abs(x-points[i][0])+Math.abs(y-points[i][1]);   //calculate distance\\n            \\n            if(currentDist<minDist){minDist=currentDist;  index=i;}   //check if its lower than the previous low\\n        }    \\n            \\n        }\\n       //if we ran through the entire we mustve found the right point \\n       return index; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n\\n        int minDist=Integer.MAX_VALUE;   //the variable to keep track of the minimal distance so far\\n        int currentDist=0;  //the current distance between our point and the current valid point from points[][]\\n\\t\\tint index=-1;   //the index of the future valid point with minimal distance (-1 if there are no valid points)\\n        \\n        for(int i=0; i<points.length; i++){\\n\\t\\t\\tif(points[i][0]==x||points[i][1]==y){    //if either x or y-coordinate are the same the point is valid\\n            \\n         currentDist=Math.abs(x-points[i][0])+Math.abs(y-points[i][1]);   //calculate distance\\n            \\n            if(currentDist<minDist){minDist=currentDist;  index=i;}   //check if its lower than the previous low\\n        }    \\n            \\n        }\\n       //if we ran through the entire we mustve found the right point \\n       return index; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356337,
                "title": "python-easy-solution",
                "content": "```\\nind = -1\\ndist = float(\\'inf\\')\\n       \\nfor i, point in enumerate(points):\\n\\tif (x == point[0] or y == point[1]):\\n\\t\\td = abs(x-point[0]) + abs(y-point[1])\\n        if d < dist:\\n\\t\\t\\tdist = d\\n            ind = i\\n                \\n\\t\\tif dist == 0:\\n\\t\\t\\tbreak\\n        \\nreturn ind\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nind = -1\\ndist = float(\\'inf\\')\\n       \\nfor i, point in enumerate(points):\\n\\tif (x == point[0] or y == point[1]):\\n\\t\\td = abs(x-point[0]) + abs(y-point[1])\\n        if d < dist:\\n\\t\\t\\tdist = d\\n            ind = i\\n                \\n\\t\\tif dist == 0:\\n\\t\\t\\tbreak\\n        \\nreturn ind\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2301614,
                "title": "kotlin-fast-and-easy-solution-488ms-faster-than-92-59",
                "content": "```\\nclass Solution {\\n    fun nearestValidPoint(x: Int, y: Int, points: Array<IntArray>): Int {\\n        var min = Int.MAX_VALUE\\n        var index = -1\\n        for (ix in points.indices) {\\n            val i = points[ix]\\n            if (i[0] != x && i[1] != y) continue // the point is not \"valid\"\\n            val dist = Math.abs(i[0] - x) + Math.abs(i[1] - y)\\n            if (dist < min) { // update min and index\\n                min = dist\\n                index = ix\\n            }\\n        }\\n        return index // done\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun nearestValidPoint(x: Int, y: Int, points: Array<IntArray>): Int {\\n        var min = Int.MAX_VALUE\\n        var index = -1\\n        for (ix in points.indices) {\\n            val i = points[ix]\\n            if (i[0] != x && i[1] != y) continue // the point is not \"valid\"\\n            val dist = Math.abs(i[0] - x) + Math.abs(i[1] - y)\\n            if (dist < min) { // update min and index\\n                min = dist\\n                index = ix\\n            }\\n        }\\n        return index // done\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207539,
                "title": "go-one-pass-easy-hehe",
                "content": "```\\nfunc nearestValidPoint(x int, y int, points [][]int) int {\\n    var res int = -1\\n    \\n    smallestDistance := 1 << 63 - 1\\n    \\n    for i := 0; i < len(points); i++ {\\n        if points[i][0] == x || points[i][1] == y {\\n            if distance([]int{x, y}, points[i]) < smallestDistance {\\n                smallestDistance = distance([]int{x, y}, points[i])\\n                res = i\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc distance(a []int, b[]int) int {\\n    return (a[0] - b[0])*(a[0] - b[0]) + (a[1] - b[1])*(a[1] - b[1])\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc nearestValidPoint(x int, y int, points [][]int) int {\\n    var res int = -1\\n    \\n    smallestDistance := 1 << 63 - 1\\n    \\n    for i := 0; i < len(points); i++ {\\n        if points[i][0] == x || points[i][1] == y {\\n            if distance([]int{x, y}, points[i]) < smallestDistance {\\n                smallestDistance = distance([]int{x, y}, points[i])\\n                res = i\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc distance(a []int, b[]int) int {\\n    return (a[0] - b[0])*(a[0] - b[0]) + (a[1] - b[1])*(a[1] - b[1])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2158065,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int smallest  = Integer.MAX_VALUE ;\\n        int k = -1;\\n        for(int i = 0;i<points.length;i++){\\n            if(points[i][0]==x || points[i][1]==y ){\\n                if( Math.abs((points[i][0]-x)) +  Math.abs((points[i][1]-y))<smallest){\\n                    smallest = Math.abs((points[i][0]-x)) + Math.abs((points[i][1]-y));\\n                    k=i;\\n                }\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\\n``` If You Found This Helpful Then Do UpVote Plz```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int smallest  = Integer.MAX_VALUE ;\\n        int k = -1;\\n        for(int i = 0;i<points.length;i++){\\n            if(points[i][0]==x || points[i][1]==y ){\\n                if( Math.abs((points[i][0]-x)) +  Math.abs((points[i][1]-y))<smallest){\\n                    smallest = Math.abs((points[i][0]-x)) + Math.abs((points[i][1]-y));\\n                    k=i;\\n                }\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\n``` If You Found This Helpful Then Do UpVote Plz```",
                "codeTag": "Java"
            },
            {
                "id": 2078814,
                "title": "find-nearest-point-that-same-x-or-y-coordinate-o-n",
                "content": "I know this Looks so long but bare with me You will understand it thoroughly.\\n```\\n\\nclass Solution {\\n    \\nprivate:\\n    int x1=0,y1=0; // To Store give x and y val at start (to decrease manHatDis function memory footprint)\\n                   // So that when calling function multiple time we did n\\'t need to pass x and y val again and again\\npublic:\\n    \\n    int manHatDis(int x2,int y2) // To calculate Manhattan Distance between (x1,y1) (x2,y2)\\n    {\\n        return (abs(x1-x2)+abs(y1-y2));\\n    }\\n    \\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        \\n        x1=x;\\n        y1=y;// [[1,2],[3,1],[2,4],[2,3],[4,4]]\\n        \\n        unordered_map<int,vector<int>> manhat; // To store Distance value as key (ManHattanDistance)\\n                                               // For each Manhattan Dis we store x2,y2,index for which this Manhattan Dis came\\n                                               // Here index is index of point (x2,y2) in Points array\\n                                               // eg: for point [2,4] index= 2 || for point [3,1] index= 1\\n        int index=0;\\n        \\n        for(auto point : points)\\n        {\\n            if(point[0]==x1 || point[1]==y1 ) // if point contain x1 or y1 then only proceed\\n            {\\n                int currDis= manHatDis(point[0],point[1]); // calculate Man Dis for current point\\n            \\n                if( manhat.find(currDis)!=manhat.end()) // if this Man Dis already present then \\n                {\\n                    if(point[0]+point[1] < manhat[currDis][0]+manhat[currDis][1] ) // check if curr point (x+y) < prev store (x+y)\\n                    {\\n                        manhat[currDis][0]= point[0];  // store x2\\n                        manhat[currDis][1]= point[1];  // store y2\\n                        manhat[currDis][2]= index;     // update latest index related to (x2,y2)\\n                    }\\n                }\\n                else // if Man Dis not already present then Add fresh\\n                {\\n                    manhat[currDis].push_back(point[0]); \\n                    manhat[currDis].push_back(point[1]);\\n                    manhat[currDis].push_back(index);\\n                }\\n            }\\n            \\n            index++; \\n            \\n        }\\n        \\n        \\n        int minDis=INT_MAX; // Intialize with MAX\\n        \\n        for(auto currDis: manhat) // To find min of all Man Distances Stored so far\\n        {\\n            if(currDis.first < minDis)\\n                minDis= currDis.first;\\n        }\\n        \\n        return minDis==INT_MAX?-1:manhat[minDis][2]; // if not found return -1 else return found Man Dis index\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\nprivate:\\n    int x1=0,y1=0; // To Store give x and y val at start (to decrease manHatDis function memory footprint)\\n                   // So that when calling function multiple time we did n\\'t need to pass x and y val again and again\\npublic:\\n    \\n    int manHatDis(int x2,int y2) // To calculate Manhattan Distance between (x1,y1) (x2,y2)\\n    {\\n        return (abs(x1-x2)+abs(y1-y2));\\n    }\\n    \\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        \\n        x1=x;\\n        y1=y;// [[1,2],[3,1],[2,4],[2,3],[4,4]]\\n        \\n        unordered_map<int,vector<int>> manhat; // To store Distance value as key (ManHattanDistance)\\n                                               // For each Manhattan Dis we store x2,y2,index for which this Manhattan Dis came\\n                                               // Here index is index of point (x2,y2) in Points array\\n                                               // eg: for point [2,4] index= 2 || for point [3,1] index= 1\\n        int index=0;\\n        \\n        for(auto point : points)\\n        {\\n            if(point[0]==x1 || point[1]==y1 ) // if point contain x1 or y1 then only proceed\\n            {\\n                int currDis= manHatDis(point[0],point[1]); // calculate Man Dis for current point\\n            \\n                if( manhat.find(currDis)!=manhat.end()) // if this Man Dis already present then \\n                {\\n                    if(point[0]+point[1] < manhat[currDis][0]+manhat[currDis][1] ) // check if curr point (x+y) < prev store (x+y)\\n                    {\\n                        manhat[currDis][0]= point[0];  // store x2\\n                        manhat[currDis][1]= point[1];  // store y2\\n                        manhat[currDis][2]= index;     // update latest index related to (x2,y2)\\n                    }\\n                }\\n                else // if Man Dis not already present then Add fresh\\n                {\\n                    manhat[currDis].push_back(point[0]); \\n                    manhat[currDis].push_back(point[1]);\\n                    manhat[currDis].push_back(index);\\n                }\\n            }\\n            \\n            index++; \\n            \\n        }\\n        \\n        \\n        int minDis=INT_MAX; // Intialize with MAX\\n        \\n        for(auto currDis: manhat) // To find min of all Man Distances Stored so far\\n        {\\n            if(currDis.first < minDis)\\n                minDis= currDis.first;\\n        }\\n        \\n        return minDis==INT_MAX?-1:manhat[minDis][2]; // if not found return -1 else return found Man Dis index\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990947,
                "title": "python-pretty-brute-forceish-but-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid_pair = []                                        #Initializing an empty array\\n        distance_holder = (9999,9999)                          #creating default values for distance holder    \\n\\n        \\n        def __calculate_manhattan(x,y,x_point,y_point):        #helper function to calculate manhattan distance\\n            return abs(x-x_point) + abs(y-y_point)\\n            \\n        for idx,pair in enumerate(points):                     #iterate through the points and keep index\\n            x_point,y_point = pair                             #unpack pairs into x/y points\\n            \\n            if x==x_point or y==y_point:                       #checking if x or y equal points\\n                distance = __calculate_manhattan(x,y,x_point,y_point)  #get manhattan distance\\n                if distance <= distance_holder[1]:             #check if distance is less than what\\'s currently in holder\\n                    if distance == distance_holder[1]:         #check if distances are equal to each other\\n                        distance_holder = (min(distance_holder[0],idx),distance)    #if distances are equal only use minimum index\\n                    else:\\n                        distance_holder = (idx,distance)       #update distance holder\\n                valid_pair.append(distance_holder)             #this was a remnant of brainstorming ways to solve problem , would need to refactor logic to remove this    \\n            \\n        if not valid_pair:                                     #checks if any elements are in valid pair\\n            return -1\\n        else:\\n            return distance_holder[0]                #returns index\\n\\t\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid_pair = []                                        #Initializing an empty array\\n        distance_holder = (9999,9999)                          #creating default values for distance holder    \\n\\n        \\n        def __calculate_manhattan(x,y,x_point,y_point):        #helper function to calculate manhattan distance\\n            return abs(x-x_point) + abs(y-y_point)\\n            \\n        for idx,pair in enumerate(points):                     #iterate through the points and keep index\\n            x_point,y_point = pair                             #unpack pairs into x/y points\\n            \\n            if x==x_point or y==y_point:                       #checking if x or y equal points\\n                distance = __calculate_manhattan(x,y,x_point,y_point)  #get manhattan distance\\n                if distance <= distance_holder[1]:             #check if distance is less than what\\'s currently in holder\\n                    if distance == distance_holder[1]:         #check if distances are equal to each other\\n                        distance_holder = (min(distance_holder[0],idx),distance)    #if distances are equal only use minimum index\\n                    else:\\n                        distance_holder = (idx,distance)       #update distance holder\\n                valid_pair.append(distance_holder)             #this was a remnant of brainstorming ways to solve problem , would need to refactor logic to remove this    \\n            \\n        if not valid_pair:                                     #checks if any elements are in valid pair\\n            return -1\\n        else:\\n            return distance_holder[0]                #returns index\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1878534,
                "title": "easy-to-understand-python-3",
                "content": "class Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        min_d=1000000\\n        i=0\\n        ans=-1\\n        for point in points:\\n            if x==point[0] or y == point[1]:\\n                mah = abs(x-point[0]) + abs(y-point[1])\\n                if mah<min_d:\\n                    min_d=mah\\n                    ans=i\\n            i+=1\\n        return ans\\n            \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        min_d=1000000\\n        i=0\\n        ans=-1\\n        for point in points:\\n            if x==point[0] or y == point[1]:\\n                mah = abs(x-point[0]) + abs(y-point[1])\\n                if mah<min_d:\\n                    min_d=mah\\n                    ans=i\\n            i+=1\\n        return ans\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1851667,
                "title": "python3-memory-usage-less-than-94-85",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        ind = -1\\n        man = -1\\n        for i in points:\\n            if i[0] == x or i[1] == y:\\n                if man == -1 or (abs(i[0] - x) + abs(i[1] - y)) < man:\\n                    man = abs(i[0] - x) + abs(i[1] - y)\\n                    ind = points.index(i)\\n        return ind",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        ind = -1\\n        man = -1\\n        for i in points:\\n            if i[0] == x or i[1] == y:\\n                if man == -1 or (abs(i[0] - x) + abs(i[1] - y)) < man:\\n                    man = abs(i[0] - x) + abs(i[1] - y)\\n                    ind = points.index(i)\\n        return ind",
                "codeTag": "Java"
            },
            {
                "id": 1834484,
                "title": "python-easy-and-small-solution",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        li=[i for i in points if i[0]==x or i[1]==y]   #chosse points where x or y is same\\n        if(len(li)==0):  \\n            return -1\\n        ans=0\\n        mn=float(\\'inf\\')     #it is same as in c++ -> int_max\\n        for i in li:\\n            dist=abs(x-i[0])+abs(y-i[1])\\n            if(mn>dist):\\n                ans=i\\n                mn=dist    \\n        return points.index(ans)\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        li=[i for i in points if i[0]==x or i[1]==y]   #chosse points where x or y is same\\n        if(len(li)==0):  \\n            return -1\\n        ans=0\\n        mn=float(\\'inf\\')     #it is same as in c++ -> int_max\\n        for i in li:\\n            dist=abs(x-i[0])+abs(y-i[1])\\n            if(mn>dist):\\n                ans=i\\n                mn=dist    \\n        return points.index(ans)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1822661,
                "title": "python-simple-solution",
                "content": "```\\ndef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        ans = -1\\n        n = len(points)\\n        mini = float(inf)\\n        \\n        for i in range(n):\\n            if points[i][0]==x or points[i][1]==y:\\n                dis = abs(points[i][0]-x) + abs(points[i][1]-y)\\n                \\n                if dis<mini:\\n                    mini = dis\\n                    ans = i\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        ans = -1\\n        n = len(points)\\n        mini = float(inf)\\n        \\n        for i in range(n):\\n            if points[i][0]==x or points[i][1]==y:\\n                dis = abs(points[i][0]-x) + abs(points[i][1]-y)\\n                \\n                if dis<mini:\\n                    mini = dis\\n                    ans = i\\n                    \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1815909,
                "title": "c-o-n-time-complexity-faster-than-96-04",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int minimum_manhattan = INT_MAX;\\n        int index = -1;\\n        for (int i = 0; i < points.size(); i++) {\\n            if(points[i][0] == x || points[i][1] == y) {\\n                int manhattan = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                if (manhattan < minimum_manhattan) {\\n                    minimum_manhattan = manhattan;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int minimum_manhattan = INT_MAX;\\n        int index = -1;\\n        for (int i = 0; i < points.size(); i++) {\\n            if(points[i][0] == x || points[i][1] == y) {\\n                int manhattan = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                if (manhattan < minimum_manhattan) {\\n                    minimum_manhattan = manhattan;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426519,
                "title": "python-o-n-time-o-1-space",
                "content": "```python\\nclass Solution:\\n\\t\"\"\"\\n\\tIn this problem we will simply iterate over all the points and keep track of the point \\n\\twith the lowest Manhattan distance. We only perform this check if either x,y of the point\\n\\tmatches our current x,y from the function.\\n\\t\"\"\"\\n    def getManhattanDistance(self, point1: [int], point2: [int]):\\n        x, y = point1\\n        x2, y2 = point2\\n        return abs(x-x2) + abs(y - y2)\\n\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        min_manhattan_distance = float(\"inf\")\\n        min_manhattan_distance_index = -1\\n        for i in range(len(points)):\\n            point_x, point_y = points[i]\\n            if point_x == x or point_y == y:\\n                current_manhattan_distance = self.getManhattanDistance([x, y], points[i])\\n                if current_manhattan_distance < min_manhattan_distance:\\n                    min_manhattan_distance = current_manhattan_distance\\n                    min_manhattan_distance_index = i\\n        \\n        return min_manhattan_distance_index\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n\\t\"\"\"\\n\\tIn this problem we will simply iterate over all the points and keep track of the point \\n\\twith the lowest Manhattan distance. We only perform this check if either x,y of the point\\n\\tmatches our current x,y from the function.\\n\\t\"\"\"\\n    def getManhattanDistance(self, point1: [int], point2: [int]):\\n        x, y = point1\\n        x2, y2 = point2\\n        return abs(x-x2) + abs(y - y2)\\n\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        min_manhattan_distance = float(\"inf\")\\n        min_manhattan_distance_index = -1\\n        for i in range(len(points)):\\n            point_x, point_y = points[i]\\n            if point_x == x or point_y == y:\\n                current_manhattan_distance = self.getManhattanDistance([x, y], points[i])\\n                if current_manhattan_distance < min_manhattan_distance:\\n                    min_manhattan_distance = current_manhattan_distance\\n                    min_manhattan_distance_index = i\\n        \\n        return min_manhattan_distance_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363286,
                "title": "simple-java-2ms-answer",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1;\\n        int distance = Integer.MAX_VALUE;\\n        for(int i = 0;i<points.length;i++)\\n        { \\n          int x1 = points[i][0];\\n          int y1 = points[i][1];\\n         if(x1 == x || y1 == y)\\n         {  \\n             int temp = Math.abs(x1-x) + Math.abs(y1-y);  \\n            if(distance > temp)\\n           {  \\n              distance = temp;\\n              result = i;\\n           }\\n         }  \\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1;\\n        int distance = Integer.MAX_VALUE;\\n        for(int i = 0;i<points.length;i++)\\n        { \\n          int x1 = points[i][0];\\n          int y1 = points[i][1];\\n         if(x1 == x || y1 == y)\\n         {  \\n             int temp = Math.abs(x1-x) + Math.abs(y1-y);  \\n            if(distance > temp)\\n           {  \\n              distance = temp;\\n              result = i;\\n           }\\n         }  \\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142186,
                "title": "javascript-one-line",
                "content": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar nearestValidPoint = function(x, y, points) {\\n    return points.findIndex(p => p === points.filter(p => p[0] === x || p[1] === y)\\n                            .sort((a,b) => -Math.abs(b[1]-y + b[0]-x) + Math.abs(a[1]-y + a[0]-x))[0])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar nearestValidPoint = function(x, y, points) {\\n    return points.findIndex(p => p === points.filter(p => p[0] === x || p[1] === y)\\n                            .sort((a,b) => -Math.abs(b[1]-y + b[0]-x) + Math.abs(a[1]-y + a[0]-x))[0])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1129621,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        //If the distance is same then sort using index else distance;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1]==b[1] ? a[0]-b[0] : a[1]-b[1]);\\n        \\n        for(int i=0;i<points.length;i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                int[] temp = new int[2];\\n                temp[0] = i;\\n                int distance = Math.abs(points[i][0]-x) + Math.abs(points[i][1]-y);\\n                temp[1] = distance;\\n                pq.add(temp);\\n            }\\n        }\\n        \\n        //NO valid index.\\n        if(pq.isEmpty())\\n            return -1;\\n        else\\n        {\\n            return pq.poll()[0]; //Returns the index of the fisrt element that has the least manhatt distance.\\n        }\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        //If the distance is same then sort using index else distance;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1]==b[1] ? a[0]-b[0] : a[1]-b[1]);\\n        \\n        for(int i=0;i<points.length;i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                int[] temp = new int[2];\\n                temp[0] = i;\\n                int distance = Math.abs(points[i][0]-x) + Math.abs(points[i][1]-y);\\n                temp[1] = distance;\\n                pq.add(temp);\\n            }\\n        }\\n        \\n        //NO valid index.\\n        if(pq.isEmpty())\\n            return -1;\\n        else\\n        {\\n            return pq.poll()[0]; //Returns the index of the fisrt element that has the least manhatt distance.\\n        }\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109908,
                "title": "elegant-python-c",
                "content": "**Python**\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x, y, points):\\n        best  = 100000\\n        where = -1\\n        \\n        for i,ab in enumerate(points):\\n            a,b = ab\\n            if a==x or b==y:\\n                d = abs(x-a) + abs(y-b)\\n                if d<best:\\n                    best  = d\\n                    where = i\\n        return where\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        \\n        int     best   =  100000;\\n        int     where  =  -1;\\n        size_t  L      =  points.size();\\n        int     a,b,d;\\n\\t\\t\\n        for (size_t i = 0; i<L; i++){\\n            a = points[i][0];\\n            b = points[i][1];\\n            if (a==x | b==y){\\n                d = abs(x-a) + abs(y-b);\\n                if (d<best){\\n                    best = d;\\n                    where = i;\\n                }\\n            }\\n        }\\n        return where;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x, y, points):\\n        best  = 100000\\n        where = -1\\n        \\n        for i,ab in enumerate(points):\\n            a,b = ab\\n            if a==x or b==y:\\n                d = abs(x-a) + abs(y-b)\\n                if d<best:\\n                    best  = d\\n                    where = i\\n        return where\\n```\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        \\n        int     best   =  100000;\\n        int     where  =  -1;\\n        size_t  L      =  points.size();\\n        int     a,b,d;\\n\\t\\t\\n        for (size_t i = 0; i<L; i++){\\n            a = points[i][0];\\n            b = points[i][1];\\n            if (a==x | b==y){\\n                d = abs(x-a) + abs(y-b);\\n                if (d<best){\\n                    best = d;\\n                    where = i;\\n                }\\n            }\\n        }\\n        return where;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099461,
                "title": "c",
                "content": "One pass O(N)\\n```\\npublic class Solution\\n{\\n    public int NearestValidPoint(int x, int y, int[][] points)\\n    {\\n        int minIdx = -1;\\n        int minDistance = int.MaxValue;\\n        for (int i = 0; i < points.Length; ++i)\\n        {\\n            var point = points[i];\\n            int distance;\\n            // No need to calculate the sum, since one of the coordinates is the same and the difference is zero\\n            if (point[0] == x)\\n                distance = Math.Abs(point[1] - y);\\n            else if (point[1] == y)\\n                distance = Math.Abs(point[0] - x);\\n            else // point[0] != x && point[1] != y therefore not valid\\n                continue;\\n            if (distance < minDistance)\\n            {\\n                minDistance = distance;\\n                minIdx = i;\\n            }\\n        }\\n        return minIdx;\\n    }\\n}\\n```\\n\\nAnd using Linq just for the heck of it. Yes, it\\'s slower since it involves OrderBy, just as an exercise.\\n```\\npublic class Solution\\n{\\n    public int NearestValidPoint(int x, int y, int[][] points)\\n    {\\n        return points\\n            .Select((point, idx) => (Idx: idx, X: point[0], Y: point[1], Distance: Math.Abs(point[0] - x) + Math.Abs(point[1] - y)))\\n            .Where(point => point.X == x || point.Y == y)\\n            .OrderBy(point => point.Distance)\\n            .ThenBy(point => point.Idx)\\n\\t\\t\\t.Select(point => point.Idx)\\n\\t\\t\\t.DefaultIfEmpty(-1)\\n\\t\\t\\t.First();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int NearestValidPoint(int x, int y, int[][] points)\\n    {\\n        int minIdx = -1;\\n        int minDistance = int.MaxValue;\\n        for (int i = 0; i < points.Length; ++i)\\n        {\\n            var point = points[i];\\n            int distance;\\n            // No need to calculate the sum, since one of the coordinates is the same and the difference is zero\\n            if (point[0] == x)\\n                distance = Math.Abs(point[1] - y);\\n            else if (point[1] == y)\\n                distance = Math.Abs(point[0] - x);\\n            else // point[0] != x && point[1] != y therefore not valid\\n                continue;\\n            if (distance < minDistance)\\n            {\\n                minDistance = distance;\\n                minIdx = i;\\n            }\\n        }\\n        return minIdx;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int NearestValidPoint(int x, int y, int[][] points)\\n    {\\n        return points\\n            .Select((point, idx) => (Idx: idx, X: point[0], Y: point[1], Distance: Math.Abs(point[0] - x) + Math.Abs(point[1] - y)))\\n            .Where(point => point.X == x || point.Y == y)\\n            .OrderBy(point => point.Distance)\\n            .ThenBy(point => point.Idx)\\n\\t\\t\\t.Select(point => point.Idx)\\n\\t\\t\\t.DefaultIfEmpty(-1)\\n\\t\\t\\t.First();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096302,
                "title": "python-easy-to-understand",
                "content": "Iterating through the all points with `enumerate(points)` that returns index (i)  and value (point)\\nIf the current candidate (point) don\\'t have either same X axis or Y axis - skip it and go to the next one. Continue inside the loop only if current point is \"valid\".\\nCalculate smallest distance (dist) by comparing to the maximum possible (20,000 due to constraints of the task)\\nAs soon as we see better then current best - update the best (dist) and remember its index (i).\\nIf we see as good as but **not** better abs(point[0] - x) + abs(point[1] - y) **<** dist - ignore\\n\\nReturn index of first best\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        dist = 20_000\\n        ans = -1\\n        for i, point in enumerate(points):\\n            if point[0] == x or point[1] == y:\\n                if abs(point[0] - x) + abs(point[1] - y) < dist:\\n                    dist = abs(point[0] - x) + abs(point[1] - y)\\n                    ans = i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        dist = 20_000\\n        ans = -1\\n        for i, point in enumerate(points):\\n            if point[0] == x or point[1] == y:\\n                if abs(point[0] - x) + abs(point[1] - y) < dist:\\n                    dist = abs(point[0] - x) + abs(point[1] - y)\\n                    ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671181,
                "title": "easy-c-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans=-1, min=INT_MAX;\\n        for(int i=0; i<points.size(); i++)\\n        {\\n            int a = points[i][0];\\n            int b = points[i][1];\\n            if(a==x || b==y)\\n            {\\n                int val = abs(x-a)+abs(y-b);\\n                if(val<min){\\n                    ans=i;\\n                    min=val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans=-1, min=INT_MAX;\\n        for(int i=0; i<points.size(); i++)\\n        {\\n            int a = points[i][0];\\n            int b = points[i][1];\\n            if(a==x || b==y)\\n            {\\n                int val = abs(x-a)+abs(y-b);\\n                if(val<min){\\n                    ans=i;\\n                    min=val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506725,
                "title": "simple-java-solution-for-beginners-2ms-beats-67-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int manhattanDistance;\\n        int smallestManhattanDistance = Integer.MAX_VALUE;\\n        int smallestManhattanDistanceIndex = -1;\\n        for(int i = 0; i < points.length; i++) {\\n            if(x == points[i][0] || y == points[i][1]) {\\n                manhattanDistance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if(manhattanDistance < smallestManhattanDistance) {\\n                    smallestManhattanDistance = manhattanDistance;\\n                    smallestManhattanDistanceIndex = i;\\n                }\\n            }\\n        }\\n        return smallestManhattanDistanceIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int manhattanDistance;\\n        int smallestManhattanDistance = Integer.MAX_VALUE;\\n        int smallestManhattanDistanceIndex = -1;\\n        for(int i = 0; i < points.length; i++) {\\n            if(x == points[i][0] || y == points[i][1]) {\\n                manhattanDistance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if(manhattanDistance < smallestManhattanDistance) {\\n                    smallestManhattanDistance = manhattanDistance;\\n                    smallestManhattanDistanceIndex = i;\\n                }\\n            }\\n        }\\n        return smallestManhattanDistanceIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466582,
                "title": "find-the-nearest-valid-point-to-a-given-coordinate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the index of the point in the given array that is closest to the given (x, y) coordinate and has either the same x or y coordinate as the given coordinate.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first create an ArrayList to store all the points that have either the same x or y coordinate as the given coordinate. We then iterate through this ArrayList and calculate the distance between each point and the given coordinate. We keep track of the minimum distance found so far and the corresponding point. Finally, we iterate through the input points array to find the index of the minimum distance point and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n), where n is the number of points in the input array.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(k), where k is the number of valid points \\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n         int res = -1;\\n        ArrayList<int[]> arr = new ArrayList<>();\\n        for (int i = 0; i < points.length; i++) {\\n            int xPoint = points[i][0];\\n            int yPoint = points[i][1];\\n            if(xPoint == x || yPoint == y){\\n                arr.add(points[i]);\\n                System.out.println(\"Point added to arr : \" + Arrays.toString(points[i]));\\n            }\\n        }\\n        System.out.println(\"List of valid points : \");\\n        arr.forEach(ints -> {\\n            System.out.print(Arrays.toString(ints) + \" \");\\n        });\\n        System.out.println();\\n        int min = Integer.MAX_VALUE;\\n        int[] minPoint = new int[]{0,0};\\n        if(!arr.isEmpty()) {\\n            for (int i = 0; i < arr.size(); i++) {\\n                int current = Math.abs(x - arr.get(i)[0]) + Math.abs(y - arr.get(i)[1]);\\n                System.out.println(\"Current distance : \" + current);\\n                if (current < min) {\\n                    min = current;\\n                    minPoint = new int[]{arr.get(i)[0], arr.get(i)[1]};\\n                }\\n                System.out.println(\"Min distance : \" + min);\\n                System.out.println(\"Min point : \" + Arrays.toString(minPoint));\\n            }\\n\\n            for (int i = 0; i < points.length; i++) {\\n                if (Arrays.equals(points[i], minPoint)) {\\n                    res = i;\\n                    System.out.println(\"Res value added \" + i);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n         int res = -1;\\n        ArrayList<int[]> arr = new ArrayList<>();\\n        for (int i = 0; i < points.length; i++) {\\n            int xPoint = points[i][0];\\n            int yPoint = points[i][1];\\n            if(xPoint == x || yPoint == y){\\n                arr.add(points[i]);\\n                System.out.println(\"Point added to arr : \" + Arrays.toString(points[i]));\\n            }\\n        }\\n        System.out.println(\"List of valid points : \");\\n        arr.forEach(ints -> {\\n            System.out.print(Arrays.toString(ints) + \" \");\\n        });\\n        System.out.println();\\n        int min = Integer.MAX_VALUE;\\n        int[] minPoint = new int[]{0,0};\\n        if(!arr.isEmpty()) {\\n            for (int i = 0; i < arr.size(); i++) {\\n                int current = Math.abs(x - arr.get(i)[0]) + Math.abs(y - arr.get(i)[1]);\\n                System.out.println(\"Current distance : \" + current);\\n                if (current < min) {\\n                    min = current;\\n                    minPoint = new int[]{arr.get(i)[0], arr.get(i)[1]};\\n                }\\n                System.out.println(\"Min distance : \" + min);\\n                System.out.println(\"Min point : \" + Arrays.toString(minPoint));\\n            }\\n\\n            for (int i = 0; i < points.length; i++) {\\n                if (Arrays.equals(points[i], minPoint)) {\\n                    res = i;\\n                    System.out.println(\"Res value added \" + i);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348007,
                "title": "find-nearest-point-that-has-the-same-x-or-y-coordinate-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int i, ind=-1, distance, min_dis=100000;\\n        for(i=0 ; i<points.size() ; i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                distance = abs(points[i][0]-x) + abs(points[i][1]-y);\\n                if(distance<min_dis)\\n                {\\n                    min_dis = distance;\\n                    ind = i;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int i, ind=-1, distance, min_dis=100000;\\n        for(i=0 ; i<points.size() ; i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                distance = abs(points[i][0]-x) + abs(points[i][1]-y);\\n                if(distance<min_dis)\\n                {\\n                    min_dis = distance;\\n                    ind = i;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315625,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n       int index=-1;\\n        int min_distance=Integer.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n                if(points[i][0]==x || points[i][1]==y){\\n                    int distance=Math.abs(points[i][0]-x)+Math.abs(points[i][1]-y);\\n                    if(distance<min_distance){\\n                        min_distance=distance;\\n                        index=i;\\n                }\\n            }\\n        }\\n\\n        return index; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n       int index=-1;\\n        int min_distance=Integer.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n                if(points[i][0]==x || points[i][1]==y){\\n                    int distance=Math.abs(points[i][0]-x)+Math.abs(points[i][1]-y);\\n                    if(distance<min_distance){\\n                        min_distance=distance;\\n                        index=i;\\n                }\\n            }\\n        }\\n\\n        return index; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304910,
                "title": "one-line-python-very-easy-solution",
                "content": "\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        return min([(abs(p[0]-x)+abs(p[1]-y), i) for i, p in enumerate(points) if p[0]==x or p[1]==y], default=(-1, -1))[1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Python ML"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        return min([(abs(p[0]-x)+abs(p[1]-y), i) for i, p in enumerate(points) if p[0]==x or p[1]==y], default=(-1, -1))[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264081,
                "title": "solved-with-using-boolean-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question it is the main thing is \\nVALID - Points having either x or y or both \\nNOT VALID  - Points dont having x or y\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo will take an boolean array from which we will check its a valid point or not.\\nValid point will be declared as true and non valid as false.\\n\\nThen we will travserse the array and store the minimum value in the variable and return that value;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int nearestValidPoint(int x, int y, int[][] points) {\\n        boolean flag[] = new boolean[points.length];\\n        int min = Integer.MAX_VALUE;\\n        int reqindex = -1;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            if (points[i][0] == x || points[i][1] == y) {\\n                flag[i] = true;\\n            }\\n        }\\n        \\n        for(int i=0; i<flag.length; i++){\\n            if(flag[i]){\\n                int value =    Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if(value < min){\\n                    min = value;\\n                    reqindex = i;\\n                }\\n            }\\n        }\\n        return reqindex;                \\n        }   \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public static int nearestValidPoint(int x, int y, int[][] points) {\\n        boolean flag[] = new boolean[points.length];\\n        int min = Integer.MAX_VALUE;\\n        int reqindex = -1;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            if (points[i][0] == x || points[i][1] == y) {\\n                flag[i] = true;\\n            }\\n        }\\n        \\n        for(int i=0; i<flag.length; i++){\\n            if(flag[i]){\\n                int value =    Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if(value < min){\\n                    min = value;\\n                    reqindex = i;\\n                }\\n            }\\n        }\\n        return reqindex;                \\n        }   \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228519,
                "title": "ruby-o-n-solution",
                "content": "# Code\\n```\\n# @param {Integer} x\\n# @param {Integer} y\\n# @param {Integer[][]} points\\n# @return {Integer}\\ndef nearest_valid_point(x, y, points)\\n  res = -1\\n  min_md = 9999999\\n\\n  points.each_with_index do |point, index|\\n    next unless x == point[0] || y == point[1]\\n    next unless min_md > (x - point[0]).abs + (y - point[1]).abs\\n    min_md = (x - point[0]).abs + (y - point[1]).abs\\n    res = index\\n  end\\n\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} x\\n# @param {Integer} y\\n# @param {Integer[][]} points\\n# @return {Integer}\\ndef nearest_valid_point(x, y, points)\\n  res = -1\\n  min_md = 9999999\\n\\n  points.each_with_index do |point, index|\\n    next unless x == point[0] || y == point[1]\\n    next unless min_md > (x - point[0]).abs + (y - point[1]).abs\\n    min_md = (x - point[0]).abs + (y - point[1]).abs\\n    res = index\\n  end\\n\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3094843,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n    int index = -1; \\n    for (int i = 0, smallest = Integer.MAX_VALUE; i < points.length; ++i) {\\n        int dx = x - points[i][0], dy = y - points[i][1];\\n        if (dx * dy == 0 && Math.abs(dy + dx) < smallest) {\\n            smallest = Math.abs(dx + dy);\\n            index = i;\\n        }\\n    }\\n    return index; \\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar nearestValidPoint = function(x, y, points) {\\n    let index = -1; \\n    for (let i = 0, smallest = Number.MAX_VALUE; i < points.length; ++i) {\\n        let dx = x - points[i][0], dy = y - points[i][1];\\n        if (dx * dy === 0 && Math.abs(dy + dx) < smallest) {\\n            smallest = Math.abs(dx + dy);\\n            index = i;\\n        }\\n    }\\n    return index;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n    int index = -1; \\n    for (int i = 0, smallest = Integer.MAX_VALUE; i < points.length; ++i) {\\n        int dx = x - points[i][0], dy = y - points[i][1];\\n        if (dx * dy == 0 && Math.abs(dy + dx) < smallest) {\\n            smallest = Math.abs(dx + dy);\\n            index = i;\\n        }\\n    }\\n    return index; \\n}\\n```\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar nearestValidPoint = function(x, y, points) {\\n    let index = -1; \\n    for (let i = 0, smallest = Number.MAX_VALUE; i < points.length; ++i) {\\n        let dx = x - points[i][0], dy = y - points[i][1];\\n        if (dx * dy === 0 && Math.abs(dy + dx) < smallest) {\\n            smallest = Math.abs(dx + dy);\\n            index = i;\\n        }\\n    }\\n    return index;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039957,
                "title": "c-beats-99-60-o-n-time-o-1-space-easy-to-understand",
                "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/8db4cddb-7e13-43df-9434-d55e665d7fe0_1673518543.7430418.png)\\n\\n# Approach\\nWe check for each point **the coincidence of at least one of the coordinates**. If there is a match, then we **calculate the distance to the original point**. If **the distance** turned out **to be less than it was**, then we **update it**, and **write the point index into the result**.\\n\\n# Complexity\\n- Time complexity: $ O(n) $\\n- Space complexity: $ O(1) $\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int result = -1, min_distance = INT_MAX;\\n        for (int i = 0; i < points.size(); i++) {\\n            int a = points[i][0], b = points[i][1];\\n            if (x == a || y == b) {\\n                int distance = abs(x - a) + abs(y - b);\\n                if (distance < min_distance) {\\n                    min_distance = distance;\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int result = -1, min_distance = INT_MAX;\\n        for (int i = 0; i < points.size(); i++) {\\n            int a = points[i][0], b = points[i][1];\\n            if (x == a || y == b) {\\n                int distance = abs(x - a) + abs(y - b);\\n                if (distance < min_distance) {\\n                    min_distance = distance;\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933123,
                "title": "beats-97-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction nearestValidPoint(x: number, y: number, points: number[][]): number {\\n\\n    let smallDistance = Number.MAX_SAFE_INTEGER;\\n    let smallIndex = -1;\\n\\n    for(let i=0;i<points.length;i++){\\n        const distance = Math.abs(points[i][0] - x) \\n                       + Math.abs(points[i][1] - y);\\n\\n        if((points[i][0] === x || points[i][1] === y) && distance < smallDistance){\\n            smallDistance = distance;\\n            smallIndex = i;\\n        } \\n    }\\n    return smallIndex;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction nearestValidPoint(x: number, y: number, points: number[][]): number {\\n\\n    let smallDistance = Number.MAX_SAFE_INTEGER;\\n    let smallIndex = -1;\\n\\n    for(let i=0;i<points.length;i++){\\n        const distance = Math.abs(points[i][0] - x) \\n                       + Math.abs(points[i][1] - y);\\n\\n        if((points[i][0] === x || points[i][1] === y) && distance < smallDistance){\\n            smallDistance = distance;\\n            smallIndex = i;\\n        } \\n    }\\n    return smallIndex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2787172,
                "title": "java-faster-than-100-simple-explanation",
                "content": "**Complexity:**\\n*Time complexity: O(n)\\nSpace complexity: O(1)*\\n\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int index = -1;\\n        int closest = Integer.MAX_VALUE;\\n        int[] point;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            \\n            point = points[i];\\n             \\n            if (point[0] == x || point[1] == y) {\\n                \\n                if (point[0] == x && point[1] == y) {\\n                \\n                    return i;\\n                \\n                }\\n                \\n                int dist = Math.abs(point[0] - x) + Math.abs(point[1] - y);\\n                \\n                if (dist < closest) {\\n                    \\n                    closest = dist;\\n                    index = i;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return index;\\n        \\n    }\\n    \\n}\\n```\\n\\n**Explanation:**\\nFor this problem we can think of it in two parts. The first part is finding whether or not one of the `X` or `Y` of any given point matches the `X` and `Y` parameters. The second part is calculating the *Manhattan Distance* of the two points and returning the the first index of the nearest point.\\n\\nWe want to iterate over every point in the `points` array and check if either `X` or `Y` value is matching. If not we will skip to the next item. Next, we can check if the point matches exactly the `X` and `Y` parameters, in which case we can return early. If not, we calculate the Manhattan Distance and check if it is smaller than but NOT EQUAL TO the current closest distance. We then return the index.\\n\\n**If this solution was helpful in any way I would greatly appreciate an upvote. For solutions to other problems, feel free to click on my account as I have many more solutions on many different problems.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int index = -1;\\n        int closest = Integer.MAX_VALUE;\\n        int[] point;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            \\n            point = points[i];\\n             \\n            if (point[0] == x || point[1] == y) {\\n                \\n                if (point[0] == x && point[1] == y) {\\n                \\n                    return i;\\n                \\n                }\\n                \\n                int dist = Math.abs(point[0] - x) + Math.abs(point[1] - y);\\n                \\n                if (dist < closest) {\\n                    \\n                    closest = dist;\\n                    index = i;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return index;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685027,
                "title": "java",
                "content": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int a =0 ,b =0;\\n        var maxdis = Integer.MAX_VALUE;\\n        int ans = -1;\\n        int sum =0;\\n        for(int i=0; i< points.length; i++){\\n            a = points[i][0];\\n            b = points[i][1];\\n            if(x==a || y == b){\\n                sum = Math.abs(x - a) + Math.abs(y-b);\\n                if(sum < maxdis){\\n                    maxdis = sum;\\n                    ans = i;\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int a =0 ,b =0;\\n        var maxdis = Integer.MAX_VALUE;\\n        int ans = -1;\\n        int sum =0;\\n        for(int i=0; i< points.length; i++){\\n            a = points[i][0];\\n            b = points[i][1];\\n            if(x==a || y == b){\\n                sum = Math.abs(x - a) + Math.abs(y-b);\\n                if(sum < maxdis){\\n                    maxdis = sum;\\n                    ans = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2680032,
                "title": "js",
                "content": "```\\nconst nearestValidPoint = (x, y, points) => {\\n    const result = { distance: Infinity, index: -1 }\\n    for (let i = 0; i < points.length; i++) {\\n        if (points[i][0] === x || points[i][1] === y) {\\n            const calc = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1])\\n            if (calc < result.distance) {\\n                result.distance = calc\\n                result.index = i\\n            }\\n        }\\n    }\\n    return result.index\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst nearestValidPoint = (x, y, points) => {\\n    const result = { distance: Infinity, index: -1 }\\n    for (let i = 0; i < points.length; i++) {\\n        if (points[i][0] === x || points[i][1] === y) {\\n            const calc = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1])\\n            if (calc < result.distance) {\\n                result.distance = calc\\n                result.index = i\\n            }\\n        }\\n    }\\n    return result.index\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671245,
                "title": "easy-solution-in-java-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBruteforce\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want A point that shares the same x-coordinate or the same y-coordinate as your location, dx * dy == 0 indicate either dx equals zero or dy equals zero, so we can make the product of dx and dy to be zero. dx and dy means the difference of x-coordinate and y-coordinate respectively. If the difference is zero, then they must be equal or shares the same x/y-coordinate.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = 10000;\\n        int index = -1;\\n        for(int i =0 ; i<points.length; i++){\\n           int dx = x - points[i][0];\\n           int dy = y - points[i][1];\\n           if(dx*dy==0 && Math.abs(dx+dy)<min){\\n               min = Math.abs(dx+dy);\\n               index =i;\\n           }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = 10000;\\n        int index = -1;\\n        for(int i =0 ; i<points.length; i++){\\n           int dx = x - points[i][0];\\n           int dy = y - points[i][1];\\n           if(dx*dy==0 && Math.abs(dx+dy)<min){\\n               min = Math.abs(dx+dy);\\n               index =i;\\n           }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590758,
                "title": "javascript-arrow-function-with-reduce-o-n",
                "content": "```\\nconst nearestValidPoint = (x, y, points, min = Infinity) => \\n    points.reduce((res, [a,b], idx) => {\\n        if(a===x || b===y){\\n            const dist = Math.abs(x-a) + Math.abs(y-b)\\n            if(dist<min){\\n                res = idx;\\n                min = dist;\\n            }\\n        }\\n        return res\\n    }, -1)\\n```\\n\\nOpen for suggestion",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst nearestValidPoint = (x, y, points, min = Infinity) => \\n    points.reduce((res, [a,b], idx) => {\\n        if(a===x || b===y){\\n            const dist = Math.abs(x-a) + Math.abs(y-b)\\n            if(dist<min){\\n                res = idx;\\n                min = dist;\\n            }\\n        }\\n        return res\\n    }, -1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589137,
                "title": "with-explanation-comments-time-342-ms-23-70-space-59-4-mb-73-79",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        \\n        //initialize a position & minimum possible absolute value & calculated distance variables\\n        int minValue=INT_MAX, dis=0, index=-1;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<points.size();i++){\\n            \\n            //check if the x-coordinates are equals or the y ones\\n            if(points[i][0]==x || points[i][1]==y){\\n                //calculate the manhattan distance between the two points\\n                dis=abs(points[i][0]-x)+abs(points[i][1]-y);            \\n                \\n                //check if the current distance is smallest reached one\\n                if(dis<minValue){\\n                    //if no-> save the lowest value\\n                    minValue=dis;\\n                    //also, the current updated index\\n                    index=i;\\n                }\\n            }\\n        }\\n        \\n        //return the index & if there\\'s no one-> return -1 as it initialized before\\n        return index;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        \\n        //initialize a position & minimum possible absolute value & calculated distance variables\\n        int minValue=INT_MAX, dis=0, index=-1;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<points.size();i++){\\n            \\n            //check if the x-coordinates are equals or the y ones\\n            if(points[i][0]==x || points[i][1]==y){\\n                //calculate the manhattan distance between the two points\\n                dis=abs(points[i][0]-x)+abs(points[i][1]-y);            \\n                \\n                //check if the current distance is smallest reached one\\n                if(dis<minValue){\\n                    //if no-> save the lowest value\\n                    minValue=dis;\\n                    //also, the current updated index\\n                    index=i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2581047,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& p) \\n    {\\n        int ans=INT_MAX,res=-1;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(x==p[i][0]||y==p[i][1])\\n            {\\n                if(ans>abs(x-p[i][0])+abs(y-p[i][1]))\\n                {\\n                    res=i;\\n                    ans=abs(x-p[i][0])+abs(y-p[i][1]);\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& p) \\n    {\\n        int ans=INT_MAX,res=-1;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(x==p[i][0]||y==p[i][1])\\n            {\\n                if(ans>abs(x-p[i][0])+abs(y-p[i][1]))\\n                {\\n                    res=i;\\n                    ans=abs(x-p[i][0])+abs(y-p[i][1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2565613,
                "title": "java-solution-1ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n         int [] solution = {0,Integer.MAX_VALUE};\\n        int index = 0;\\n        for(int[] point:points){\\n            if(x == point[0] || y == point[1]){\\n                int sum = Math.abs(x - point[0]) + Math.abs(y - point[1]);\\n                if (sum < solution[1]){\\n                    solution[0] = index;\\n                    solution[1] = sum;\\n                }\\n            }\\n            index++;\\n        }\\n        return  (solution[1] == Integer.MAX_VALUE) ? -1 : solution[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n         int [] solution = {0,Integer.MAX_VALUE};\\n        int index = 0;\\n        for(int[] point:points){\\n            if(x == point[0] || y == point[1]){\\n                int sum = Math.abs(x - point[0]) + Math.abs(y - point[1]);\\n                if (sum < solution[1]){\\n                    solution[0] = index;\\n                    solution[1] = sum;\\n                }\\n            }\\n            index++;\\n        }\\n        return  (solution[1] == Integer.MAX_VALUE) ? -1 : solution[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553088,
                "title": "c-just-check",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint nearestValidPoint(int x, int y, vector<vector<int>>& a) {\\n\\t\\t\\tint mx=INT_MAX,ind=-1;\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tif(x==a[i][0]||y==a[i][1]) {\\n\\t\\t\\t\\t\\tif(mx>abs(x-a[i][0])+abs(y-a[i][1])) {\\n\\t\\t\\t\\t\\t\\tmx=abs(x-a[i][0])+abs(y-a[i][1]);\\n\\t\\t\\t\\t\\t\\tind=i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint nearestValidPoint(int x, int y, vector<vector<int>>& a) {\\n\\t\\t\\tint mx=INT_MAX,ind=-1;\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tif(x==a[i][0]||y==a[i][1]) {\\n\\t\\t\\t\\t\\tif(mx>abs(x-a[i][0])+abs(y-a[i][1])) {\\n\\t\\t\\t\\t\\t\\tmx=abs(x-a[i][0])+abs(y-a[i][1]);\\n\\t\\t\\t\\t\\t\\tind=i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2550668,
                "title": "python-o-n-very-simple",
                "content": "Upvote if you understand !\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\n        cur_dist = float(\\'inf\\')\\n        cur_idx = -1\\n        \\n        for i, point in enumerate(points): \\n            x1 = point[0]\\n            y1 = point[1]\\n            if x == x1 or y == y1:\\n                dist = abs(x1-x)+abs(y1-y)\\n                if dist < cur_dist:\\n                    cur_dist = dist\\n                    cur_idx = i\\n        return cur_idx\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\n        cur_dist = float(\\'inf\\')\\n        cur_idx = -1\\n        \\n        for i, point in enumerate(points): \\n            x1 = point[0]\\n            y1 = point[1]\\n            if x == x1 or y == y1:\\n                dist = abs(x1-x)+abs(y1-y)\\n                if dist < cur_dist:\\n                    cur_dist = dist\\n                    cur_idx = i\\n        return cur_idx\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518846,
                "title": "python-for-beginners-2-solutions",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:   \\n        #Runtime:1167ms\\n        dic={}\\n        iterate=0\\n        for i in points:\\n            if(i[0]==x or i[1]==y):\\n                dic[iterate]=dic.get(iterate,0)+(abs(i[0]-x)+abs(i[1]-y))\\n            iterate+=1    \\n        #print(dic)\\n        if(len(dic)==0):\\n            return -1\\n        for k,v in sorted(dic.items(), key=lambda x:x[1]):\\n            return k\\n```\\n\\nOptimizing above code:.....!\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\t    #Runtime:764ms\\n        mindist=math.inf\\n        ans=-1\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                mandist=abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if(mandist<mindist):\\n                    ans=i\\n                    mindist=mandist\\n        return ans   \\n\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:   \\n        #Runtime:1167ms\\n        dic={}\\n        iterate=0\\n        for i in points:\\n            if(i[0]==x or i[1]==y):\\n                dic[iterate]=dic.get(iterate,0)+(abs(i[0]-x)+abs(i[1]-y))\\n            iterate+=1    \\n        #print(dic)\\n        if(len(dic)==0):\\n            return -1\\n        for k,v in sorted(dic.items(), key=lambda x:x[1]):\\n            return k\\n```\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\t    #Runtime:764ms\\n        mindist=math.inf\\n        ans=-1\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                mandist=abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if(mandist<mindist):\\n                    ans=i\\n                    mindist=mandist\\n        return ans   \\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517687,
                "title": "easy-java-solution-o-n",
                "content": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE, ans =-1;\\n       for(int i=0; i<points.length; i++){\\n           if(Math.abs(points[i][0]-x)==0 || Math.abs(points[i][1]-y)==0){\\n               int distance = Math.abs(points[i][0] -x) + Math.abs(points[i][1] -y);\\n               if(distance<min){\\n                   min = distance;\\n                   ans = i;\\n               }\\n           }\\n       }   \\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE, ans =-1;\\n       for(int i=0; i<points.length; i++){\\n           if(Math.abs(points[i][0]-x)==0 || Math.abs(points[i][1]-y)==0){\\n               int distance = Math.abs(points[i][0] -x) + Math.abs(points[i][1] -y);\\n               if(distance<min){\\n                   min = distance;\\n                   ans = i;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2496397,
                "title": "python-easy-to-understand-84-faster",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        minimum_dis = 10000\\n        index=-1\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                dist= abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if dist<minimum_dis:\\n                    minimum_dis=dist\\n                    index=i\\n        return index\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        minimum_dis = 10000\\n        index=-1\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                dist= abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if dist<minimum_dis:\\n                    minimum_dis=dist\\n                    index=i\\n        return index\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491946,
                "title": "simple-solution-using-map-o-n-solution-c-simple-for-beginners",
                "content": "class Solution {\\npublic:\\n    \\n\\tint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n    \\n\\tint s1 = points.size();\\n    map<int, int> m;\\n\\t\\n    for (int i = 0; i < s1; i++)\\n    {\\n        if (x == points[i][0] || y == points[i][1])\\n            m.insert({ abs(x - points[i][0]) + abs(y - points[i][1]), i });\\n    }\\n    \\n\\tauto it = m.begin();\\n    if (it != m.end())\\n        return it->second;\\n    else\\n        return -1;   \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n    \\n\\tint s1 = points.size();\\n    map<int, int> m;\\n\\t\\n    for (int i = 0; i < s1; i++)\\n    {\\n        if (x == points[i][0] || y == points[i][1])\\n            m.insert({ abs(x - points[i][0]) + abs(y - points[i][1]), i }",
                "codeTag": "Java"
            },
            {
                "id": 2490542,
                "title": "python-for-loop-dictionary-solution-explained",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        i = 0\\n        valid_dict = {}\\n        for ele in points:\\n            if ele[0] == x or ele[1] == y:\\n                valid_dict[i] = abs(x - ele[0]) + abs(y - ele[1])\\n            i = i + 1\\n        if valid_dict:\\n            return min(valid_dict, key=valid_dict.get)\\n        else:\\n            return -1\\n```\\n\\nPurpose of `valid_dict` is to store index (key) of valid points and its distance (value). For example, with `points = [[1,2],[3,1],[2,4],[2,3],[4,4]]`, you will have `valid_dict = {1: 3, 2: 1, 4: 1}`. Next, we use argument `key=valid_dict.get` to sort (ascending order) the `valid_dict`\\'s values: `{2: 1, 4: 1, 1: 3}`. Because there are multiple items are minimal (both key 2 and 4 have minimum distance), the function returns the first one encountered.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        i = 0\\n        valid_dict = {}\\n        for ele in points:\\n            if ele[0] == x or ele[1] == y:\\n                valid_dict[i] = abs(x - ele[0]) + abs(y - ele[1])\\n            i = i + 1\\n        if valid_dict:\\n            return min(valid_dict, key=valid_dict.get)\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444937,
                "title": "java-solution-100-fast-than-other-solutions",
                "content": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE , ans = -1;\\n        for(int i = 0;i<points.length;i++)\\n        {\\n            if(points[i][0] == x || points[i][1] == y)\\n            {\\n                int distance = Math.abs(points[i][0] - x) + Math.abs(points[i][1] - y);\\n                if(distance < min)\\n                {\\n                    min = distance;\\n                    ans = i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = Integer.MAX_VALUE , ans = -1;\\n        for(int i = 0;i<points.length;i++)\\n        {\\n            if(points[i][0] == x || points[i][1] == y)\\n            {\\n                int distance = Math.abs(points[i][0] - x) + Math.abs(points[i][1] - y);\\n                if(distance < min)\\n                {\\n                    min = distance;\\n                    ans = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2427185,
                "title": "javascript-easy-single-for-loop-o-n-solution",
                "content": "```\\nfunction nearestValidPoint(pointX, pointY, points) {\\n    let smallestPointIndex = -1\\n    let smallestPointDistance = Number.MAX_SAFE_INTEGER;\\n\\n    for (let i = 0; i < points.length; i++) {\\n        if(pointX !== points[i][0] && pointY !== points[i][1]) {\\n            continue;\\n        }\\n\\n        const distance = Math.abs(pointX - points[i][0]) + Math.abs(pointY - points[i][1]);\\n        \\n        if(distance >= smallestPointDistance) {\\n            continue;\\n        }\\n\\n        smallestPointIndex = i;\\n        smallestPointDistance = distance;\\n    }\\n\\n    return smallestPointIndex;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nfunction nearestValidPoint(pointX, pointY, points) {\\n    let smallestPointIndex = -1\\n    let smallestPointDistance = Number.MAX_SAFE_INTEGER;\\n\\n    for (let i = 0; i < points.length; i++) {\\n        if(pointX !== points[i][0] && pointY !== points[i][1]) {\\n            continue;\\n        }\\n\\n        const distance = Math.abs(pointX - points[i][0]) + Math.abs(pointY - points[i][1]);\\n        \\n        if(distance >= smallestPointDistance) {\\n            continue;\\n        }\\n\\n        smallestPointIndex = i;\\n        smallestPointDistance = distance;\\n    }\\n\\n    return smallestPointIndex;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2407469,
                "title": "c-solution-very-easy-any-query-comment-down-please-upvote",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int> arr,int x,int y){\\n        if(x==arr[0] || y== arr[1]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    int manhattan(vector<int> arr,int x,int y){\\n        int a=abs(x-arr[0])+abs(y-arr[1]);\\n        return a;\\n    }\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int n=points.size();\\n        int ans=-1;\\n        int min=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(isvalid(points[i],x,y)){\\n                int k=manhattan(points[i],x,y);\\n                if(k<min){\\n                    ans=i;\\n                    min=k;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    bool isvalid(vector<int> arr,int x,int y){\\n        if(x==arr[0] || y== arr[1]){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2407188,
                "title": "c-very-easy-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int maxValidIndex = -1, maxDist = pow(10, 4);\\n        \\n        for(int i = 0; i < points.size(); i++){\\n            if(x == points[i][0] || y == points[i][1]){\\n                if(abs(x - points[i][0]) + abs(y - points[i][1]) < maxDist){\\n                    maxDist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n                    maxValidIndex = i;\\n                }\\n            }\\n        }\\n        \\n        return maxValidIndex;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int maxValidIndex = -1, maxDist = pow(10, 4);\\n        \\n        for(int i = 0; i < points.size(); i++){\\n            if(x == points[i][0] || y == points[i][1]){\\n                if(abs(x - points[i][0]) + abs(y - points[i][1]) < maxDist){\\n                    maxDist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n                    maxValidIndex = i;\\n                }\\n            }\\n        }\\n        \\n        return maxValidIndex;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372967,
                "title": "easy-explanation-with-code",
                "content": "class Solution {\\npublic:\\n\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        //simple approach ..we will iterate and check for valid case and as found we will see for distance if found less index then update the index\\n        int mini=INT_MAX,index=-1;//index as -1 taken if no such case exist we will return it directly otherwise you may can use flag to check \\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(x==points[i][0]||y==points[i][1])//inside this we can use flag to check  our control comes inside it or not and then if flag ==0 ret -1\\n            {\\n                int diff=abs(points[i][0]-x)+abs(points[i][1]-y);\\n                if(diff<mini)\\n                {\\n                    mini=diff;\\n                    index=i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        //simple approach ..we will iterate and check for valid case and as found we will see for distance if found less index then update the index\\n        int mini=INT_MAX,index=-1;//index as -1 taken if no such case exist we will return it directly otherwise you may can use flag to check \\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(x==points[i][0]||y==points[i][1])//inside this we can use flag to check  our control comes inside it or not and then if flag ==0 ret -1\\n            {\\n                int diff=abs(points[i][0]-x)+abs(points[i][1]-y);\\n                if(diff<mini)\\n                {\\n                    mini=diff;\\n                    index=i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2370912,
                "title": "java-simplest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    int index = -1;\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        for (int i=0; i<points.length; i++) {\\n            boolean valid = isValid(x, y, points[i][0], points[i][1]);\\n            if (valid) {\\n                int manDist = findManhattanDistance(x, y, points[i][0], points[i][1]);\\n                if (manDist < min) {\\n                    min = manDist;\\n                    index = i;\\n                }\\n            }\\n        }     \\n        return index;\\n    }   \\n    public int findManhattanDistance(int x, int y, int a, int b) {\\n        int dist = 0;\\n        dist = Math.abs(x-a) + Math.abs(y-b);\\n        return dist; \\n    }  \\n    public boolean isValid(int x, int y, int a, int b) {\\n        boolean ans = false;\\n        if (x == a || y == b) {\\n            ans = true;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    int index = -1;\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        for (int i=0; i<points.length; i++) {\\n            boolean valid = isValid(x, y, points[i][0], points[i][1]);\\n            if (valid) {\\n                int manDist = findManhattanDistance(x, y, points[i][0], points[i][1]);\\n                if (manDist < min) {\\n                    min = manDist;\\n                    index = i;\\n                }\\n            }\\n        }     \\n        return index;\\n    }   \\n    public int findManhattanDistance(int x, int y, int a, int b) {\\n        int dist = 0;\\n        dist = Math.abs(x-a) + Math.abs(y-b);\\n        return dist; \\n    }  \\n    public boolean isValid(int x, int y, int a, int b) {\\n        boolean ans = false;\\n        if (x == a || y == b) {\\n            ans = true;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360084,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& v) {\\n        int c=-1,d=INT_MAX,m=INT_MAX,i=0;\\n        for(auto &a:v){\\n            if(x==a[0]) d=abs(y-a[1]);\\n            if(y==a[1]) d=abs(x-a[0]);\\n            if(d<m){\\n                m=d;\\n                c=i;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& v) {\\n        int c=-1,d=INT_MAX,m=INT_MAX,i=0;\\n        for(auto &a:v){\\n            if(x==a[0]) d=abs(y-a[1]);\\n            if(y==a[1]) d=abs(x-a[0]);\\n            if(d<m){\\n                m=d;\\n                c=i;\\n            }\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356067,
                "title": "java-solution-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n       int cx,cy;\\n        int distance=Integer.MAX_VALUE;\\n        int index=Integer.MAX_VALUE;\\n        for(int i=0;i<points.length;i++){\\n            cx=points[i][0];\\n            cy=points[i][1];\\n            if(cx==x || cy==y){\\n                int dist = Math.abs(cx-x)+Math.abs(y-cy);\\n                if(dist<distance){\\n                   index=i;\\n                }\\n               distance= Math.min(dist,distance);\\n            }\\n        }\\n        if(index==Integer.MAX_VALUE){\\n            return -1;\\n        }\\n            return index;\\n        }\\n}\\n```\\nif solution is helpful please Upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n       int cx,cy;\\n        int distance=Integer.MAX_VALUE;\\n        int index=Integer.MAX_VALUE;\\n        for(int i=0;i<points.length;i++){\\n            cx=points[i][0];\\n            cy=points[i][1];\\n            if(cx==x || cy==y){\\n                int dist = Math.abs(cx-x)+Math.abs(y-cy);\\n                if(dist<distance){\\n                   index=i;\\n                }\\n               distance= Math.min(dist,distance);\\n            }\\n        }\\n        if(index==Integer.MAX_VALUE){\\n            return -1;\\n        }\\n            return index;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341133,
                "title": "c-explained",
                "content": "**Explaination**\\n```\\nx = 3 & y = 4;\\n\\npoints = [\\n[1,2],   i = 0; validIndex = false; \\n[3,1],   i = 1; validIndex = true; (x - 3) + ( y - 1) = 3\\n[2,4], \\t i = 2; validIndex = true; (x - 2) + ( y - 4) = 1;  //ans = first min value;\\n[2,3], \\t i = 3; validIndex = false; \\n[4,4]] \\t i = 4; validIndex = true; (x - 4) + ( y - 4) = 1\\n```\\n\\nComment, if any doubts\\n```\\npublic class Solution {\\n    public int NearestValidPoint(int x, int y, int[][] points) \\n    {\\n        int minDistance = Int32.MaxValue, \\n\\t\\t\\tcurrentDistance = 0, \\n\\t\\t\\tvalidIndex = -1;\\n        \\n        for(int i = 0; i < points.Length; i++) \\n        {\\n            if(points[i][0] == x || points[i][1] == y) \\n            {\\n                currentDistance = Math.Abs((x - points[i][0]) + (y - points[i][1]));\\n               \\n                if(currentDistance < minDistance) \\n                {\\n                    validIndex = i;\\n                    minDistance = currentDistance;\\n                }\\n                    \\n            }\\n        }\\n        \\n        return validIndex;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nx = 3 & y = 4;\\n\\npoints = [\\n[1,2],   i = 0; validIndex = false; \\n[3,1],   i = 1; validIndex = true; (x - 3) + ( y - 1) = 3\\n[2,4], \\t i = 2; validIndex = true; (x - 2) + ( y - 4) = 1;  //ans = first min value;\\n[2,3], \\t i = 3; validIndex = false; \\n[4,4]] \\t i = 4; validIndex = true; (x - 4) + ( y - 4) = 1\\n```\n```\\npublic class Solution {\\n    public int NearestValidPoint(int x, int y, int[][] points) \\n    {\\n        int minDistance = Int32.MaxValue, \\n\\t\\t\\tcurrentDistance = 0, \\n\\t\\t\\tvalidIndex = -1;\\n        \\n        for(int i = 0; i < points.Length; i++) \\n        {\\n            if(points[i][0] == x || points[i][1] == y) \\n            {\\n                currentDistance = Math.Abs((x - points[i][0]) + (y - points[i][1]));\\n               \\n                if(currentDistance < minDistance) \\n                {\\n                    validIndex = i;\\n                    minDistance = currentDistance;\\n                }\\n                    \\n            }\\n        }\\n        \\n        return validIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263674,
                "title": "python-easy-to-read",
                "content": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        min_distance = abs(x-points[0][0]) + abs(y-points[0][1])\\n        idx = -1\\n        current_distance = 0\\n        for count, point in enumerate(points):\\n            if point[0] == x or point[1] == y:\\n                current_distance = abs(x-point[0]) + abs(y-point[1])\\n                if current_distance < min_distance or idx == -1:\\n                    min_distance = current_distance\\n                    idx = count\\n        if idx != -1:\\n            return idx\\n        return idx\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        min_distance = abs(x-points[0][0]) + abs(y-points[0][1])\\n        idx = -1\\n        current_distance = 0\\n        for count, point in enumerate(points):\\n            if point[0] == x or point[1] == y:\\n                current_distance = abs(x-point[0]) + abs(y-point[1])\\n                if current_distance < min_distance or idx == -1:\\n                    min_distance = current_distance\\n                    idx = count\\n        if idx != -1:\\n            return idx\\n        return idx\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236051,
                "title": "python-easy-code-best-runtime-570ms-98-fastest",
                "content": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        min_dist = float(\\'inf\\')                    # more general, than 99999 for example\\n        min_ind = -1\\n        for i in range(len(points)):\\n            xi = points[i][0]\\n            yi = points[i][1]\\n            if (xi == x) or (yi == y):\\n                dist_i = abs(xi - x) + abs(yi - y)\\n                if dist_i < min_dist:\\n                    min_ind = i\\n                    min_dist = dist_i\\n        return min_ind\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        min_dist = float(\\'inf\\')                    # more general, than 99999 for example\\n        min_ind = -1\\n        for i in range(len(points)):\\n            xi = points[i][0]\\n            yi = points[i][1]\\n            if (xi == x) or (yi == y):\\n                dist_i = abs(xi - x) + abs(yi - y)\\n                if dist_i < min_dist:\\n                    min_ind = i\\n                    min_dist = dist_i\\n        return min_ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223736,
                "title": "python-learn-new-method-enumerate",
                "content": "It is a simple question as the question itself contain answer but being pythonist we must do it in our style\\nUsing enumerate() = returns (index,value)\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        minn = 10e5 #inittial min (max value)\\n        result = -1\\n        for index,point in enumerate(points):    # enumerate(points) gives (i,pints[i])\\n            if x == point[0] or y ==point[1]:       #valid point condition check\\n                man_distance=abs(point[0]-x)+abs(point[1]-y)    #manhattan distance for valid points\\n                if minn > man_distance:      #compare distance\\n                    minn = man_distance\\n                    result = index\\n        return result\\n                \\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        minn = 10e5 #inittial min (max value)\\n        result = -1\\n        for index,point in enumerate(points):    # enumerate(points) gives (i,pints[i])\\n            if x == point[0] or y ==point[1]:       #valid point condition check\\n                man_distance=abs(point[0]-x)+abs(point[1]-y)    #manhattan distance for valid points\\n                if minn > man_distance:      #compare distance\\n                    minn = man_distance\\n                    result = index\\n        return result\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218604,
                "title": "python-time-complexity-o-n-memory-complexity-o-1",
                "content": "I think that the explanation in discussion section is good. Sometimes I search for a code in a concrete language. Here is my python code.\\n\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        d = -1\\n        ind = -1\\n        for i, p in enumerate(points):\\n            px, py = p\\n            if px == x or py == y:\\n                curr = abs(x - px) + abs(y - py)\\n                if ind == -1 or curr < d:\\n                    d = curr\\n                    ind = i\\n        return ind\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        d = -1\\n        ind = -1\\n        for i, p in enumerate(points):\\n            px, py = p\\n            if px == x or py == y:\\n                curr = abs(x - px) + abs(y - py)\\n                if ind == -1 or curr < d:\\n                    d = curr\\n                    ind = i\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192230,
                "title": "c-very-easy-solution-using-maps-98-faster",
                "content": "IF YOU LIKE THE CODE, DO UPVOTE\\n```\\nint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        unordered_map<int,vector<int>>mm;\\n        map<int,int>ma;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n                mm[i]=points[i];\\n        }\\n        if(mm.size()==0)\\n            return -1;\\n        for(auto it:mm)\\n        {\\n            int k = abs(it.second[0]-x) + abs(it.second[1]-y);\\n            if(ma[k]==0 || ma[k]>it.first)\\n            ma[k]=it.first;\\n        }\\n        return ma.begin()->second;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "IF YOU LIKE THE CODE, DO UPVOTE\\n```\\nint nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        unordered_map<int,vector<int>>mm;\\n        map<int,int>ma;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n                mm[i]=points[i];\\n        }\\n        if(mm.size()==0)\\n            return -1;\\n        for(auto it:mm)\\n        {\\n            int k = abs(it.second[0]-x) + abs(it.second[1]-y);\\n            if(ma[k]==0 || ma[k]>it.first)\\n            ma[k]=it.first;\\n        }\\n        return ma.begin()->second;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2179937,
                "title": "python-easy-to-understand-step-by-step-solution-walkthrough",
                "content": "**Function Input :**\\n* It takes in the x and y coordinates of the point we want to find the nearest valid point to.\\n*  It also takes in a list of points, which are the points that are valid.\\n\\n**Loop Logic**\\n\\n1. It then iterates through the list of points, and for each point, it checks if the x or y      coordinate is the same as the x or y coordinate of the point we want to find the nearest valid point to.\\n4. If the x or y coordinate is the same, then we know that the point is on the same row or column as the point we want to find the nearest valid point to.\\n5. We then calculate the distance between the point we want to find the nearest valid point to and the point we are currently iterating through.\\n6. If the distance is less than the minimum distance we have seen so far, then we update the minimum distance and the index of the point that gave us the minimum distance.\\n7. We then return the index of the point that gave us the minimum distance.\\n      \\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        min_dist = float(\\'inf\\')\\n        min_idx = -1\\n        for i, (a, b) in enumerate(points):\\n            if a == x or b == y:\\n                dist = abs(x - a) + abs(y - b)\\n                if dist < min_dist:\\n                    min_dist = dist\\n                    min_idx = i\\n        return min_idx\\n    ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        min_dist = float(\\'inf\\')\\n        min_idx = -1\\n        for i, (a, b) in enumerate(points):\\n            if a == x or b == y:\\n                dist = abs(x - a) + abs(y - b)\\n                if dist < min_dist:\\n                    min_dist = dist\\n                    min_idx = i\\n        return min_idx\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2172911,
                "title": "python-simple-python-solution-using-manhattan-distance-formula",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 790 ms, faster than 78.63% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n# Memory Usage: 19.3 MB, less than 39.01% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n\\tclass Solution:\\n\\t\\tdef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\n\\t\\t\\tminmum_index = 1000000000\\n\\n\\t\\t\\tminmum_distance = 100000000\\n\\n\\t\\t\\tfor i in range(len(points)):\\n\\t\\t\\t\\tai , bi = points[i]\\n\\n\\t\\t\\t\\tif ai == x or bi == y:\\n\\n\\t\\t\\t\\t\\tManhattan_Distance = abs(ai - x) + abs(bi - y)\\n\\n\\t\\t\\t\\t\\tif Manhattan_Distance < minmum_distance:\\n\\t\\t\\t\\t\\t\\tminmum_distance = Manhattan_Distance\\n\\t\\t\\t\\t\\t\\tminmum_index = i\\n\\n\\t\\t\\tif minmum_index != 1000000000:\\n\\n\\t\\t\\t\\treturn minmum_index\\n\\n\\t\\t\\treturn -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 790 ms, faster than 78.63% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n# Memory Usage: 19.3 MB, less than 39.01% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n\\tclass Solution:\\n\\t\\tdef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n\\n\\t\\t\\tminmum_index = 1000000000\\n\\n\\t\\t\\tminmum_distance = 100000000\\n\\n\\t\\t\\tfor i in range(len(points)):\\n\\t\\t\\t\\tai , bi = points[i]\\n\\n\\t\\t\\t\\tif ai == x or bi == y:\\n\\n\\t\\t\\t\\t\\tManhattan_Distance = abs(ai - x) + abs(bi - y)\\n\\n\\t\\t\\t\\t\\tif Manhattan_Distance < minmum_distance:\\n\\t\\t\\t\\t\\t\\tminmum_distance = Manhattan_Distance\\n\\t\\t\\t\\t\\t\\tminmum_index = i\\n\\n\\t\\t\\tif minmum_index != 1000000000:\\n\\n\\t\\t\\t\\treturn minmum_index\\n\\n\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 2170128,
                "title": "rust-iterator",
                "content": "```\\nimpl Solution {\\n    pub fn nearest_valid_point(x: i32, y: i32, points: Vec<Vec<i32>>) -> i32 {\\n        points\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, point)| point[0] == x || point[1] == y)\\n            .min_by_key(|(_, point)| (point[0] - x).abs() + (point[1] - y).abs())\\n            .map(|(index, _)| index as i32)\\n            .unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn nearest_valid_point(x: i32, y: i32, points: Vec<Vec<i32>>) -> i32 {\\n        points\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, point)| point[0] == x || point[1] == y)\\n            .min_by_key(|(_, point)| (point[0] - x).abs() + (point[1] - y).abs())\\n            .map(|(index, _)| index as i32)\\n            .unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165071,
                "title": "python-very-simple-solution-one-pass-97",
                "content": "**<<< Please upvote if you like my solution!**\\nI saw many people solving seperately for X and Y, some using dictionary. A simple enumarate can do wonders.\\n\\nmin_ => min manhattan distance till now\\nmin_i => min index\\n\\n``` \\ndef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n\\tmin_ = float(\\'inf\\')\\n\\tmin_i = -1\\n\\n\\tfor i, (x1, y1) in enumerate(points):\\n\\t\\tif x1 != x and y1 != y:\\n\\t\\t\\tcontinue\\n\\t\\t\\t\\n\\t\\t# if same point exists just return \\n\\t\\t# Note: this will be the first occurence\\n\\t\\tif x1 == x and y1 == y:\\n\\t\\t\\treturn i\\n\\n\\t\\tdist = abs(x1 - x) + abs(y1 - y)\\n\\n\\t\\tif dist < min_:\\n\\t\\t\\tmin_ = dist\\n\\t\\t\\tmin_i = i\\n\\n\\treturn min_i\\n```\\n\\nDo comment if you have any doubts.\\nHappy Coding!",
                "solutionTags": [
                    "Python",
                    "Enumeration"
                ],
                "code": "``` \\ndef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n\\tmin_ = float(\\'inf\\')\\n\\tmin_i = -1\\n\\n\\tfor i, (x1, y1) in enumerate(points):\\n\\t\\tif x1 != x and y1 != y:\\n\\t\\t\\tcontinue\\n\\t\\t\\t\\n\\t\\t# if same point exists just return \\n\\t\\t# Note: this will be the first occurence\\n\\t\\tif x1 == x and y1 == y:\\n\\t\\t\\treturn i\\n\\n\\t\\tdist = abs(x1 - x) + abs(y1 - y)\\n\\n\\t\\tif dist < min_:\\n\\t\\t\\tmin_ = dist\\n\\t\\t\\tmin_i = i\\n\\n\\treturn min_i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2164501,
                "title": "javascript-solution",
                "content": "******\\n```\\nvar nearestValidPoint = function(x, y, points) {\\n    let obj = {}\\n    for (let i in points) {\\n        if (points[i][0] == x || points[i][1] == y) {\\n            let sum = (x - points[i][0]) + (y - points[i][1])\\n            obj[i] = Math.abs(sum)\\n        }\\n    } let min = [];\\n    for (let key of Object.keys(obj)) {\\n        if ((obj[key] === Math.min(...Object.values(obj))) && obj[key] > -2) min.push(key)\\n    } if (min.length === 0) return -1;\\n    return min[0];\\n}\\n```\\n******",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nearestValidPoint = function(x, y, points) {\\n    let obj = {}\\n    for (let i in points) {\\n        if (points[i][0] == x || points[i][1] == y) {\\n            let sum = (x - points[i][0]) + (y - points[i][1])\\n            obj[i] = Math.abs(sum)\\n        }\\n    } let min = [];\\n    for (let key of Object.keys(obj)) {\\n        if ((obj[key] === Math.min(...Object.values(obj))) && obj[key] > -2) min.push(key)\\n    } if (min.length === 0) return -1;\\n    return min[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2158120,
                "title": "simple-c-solution",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int minm=INT_MAX, index=-1,diff;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                diff =  abs(x-points[i][0]) + abs(y-points[i][1]);\\n                if(diff<minm)\\n                {\\n                    minm=diff;\\n                    index=i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int minm=INT_MAX, index=-1,diff;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                diff =  abs(x-points[i][0]) + abs(y-points[i][1]);\\n                if(diff<minm)\\n                {\\n                    minm=diff;\\n                    index=i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154800,
                "title": "java-approach-priority-queue",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            return (Math.abs(a[0]-x) + Math.abs(a[1] - y)) - (Math.abs(b[0]-x) + Math.abs(b[1] - y));\\n        });\\n        int result = 0;\\n        for(int[] temp : points){\\n            if(temp[0] == x || temp[1] == y){\\n                pq.add(temp);\\n            }\\n        }\\n        if(pq.size() == 0){\\n            return -1;\\n        }\\n        List<int[]> l = new ArrayList<>();\\n        for(int[] temp : points){\\n            l.add(temp);\\n        }\\n        int[] rss = pq.poll();\\n        for(int i = 0;i<l.size();i++){\\n            if(l.get(i) == rss){\\n                result = i;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            return (Math.abs(a[0]-x) + Math.abs(a[1] - y)) - (Math.abs(b[0]-x) + Math.abs(b[1] - y));\\n        });\\n        int result = 0;\\n        for(int[] temp : points){\\n            if(temp[0] == x || temp[1] == y){\\n                pq.add(temp);\\n            }\\n        }\\n        if(pq.size() == 0){\\n            return -1;\\n        }\\n        List<int[]> l = new ArrayList<>();\\n        for(int[] temp : points){\\n            l.add(temp);\\n        }\\n        int[] rss = pq.poll();\\n        for(int i = 0;i<l.size();i++){\\n            if(l.get(i) == rss){\\n                result = i;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132096,
                "title": "c-3-line-approach-o-n",
                "content": "```\\nclass solution{\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans = INT_MAX, index=-1;\\n        for(int i=0; i<points.size(); i++){\\n            if(points[i][0]==x||points[i][1]==y){\\n                int dist = abs(points[i][0]-x) + abs(points[i][1]-y);\\n                if(ans>dist){\\n                    ans = dist;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass solution{\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans = INT_MAX, index=-1;\\n        for(int i=0; i<points.size(); i++){\\n            if(points[i][0]==x||points[i][1]==y){\\n                int dist = abs(points[i][0]-x) + abs(points[i][1]-y);\\n                if(ans>dist){\\n                    ans = dist;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2131833,
                "title": "python-simple-solution",
                "content": "For every point, we check with X and Y and if its valid point, we calculate the manhattan distance and add it to the dictionary with index in list as key and manhattan distance has value.\\n\\nIf the dictionary is empty, we return -1 else we sort the dictionary based on values and return key of the first element.\\n\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        d=dict()\\n        for point in points:\\n            if x==point[0] or y==point[1]:\\n                value = abs(x-point[0]) + abs(y-point[1])\\n                d[points.index(point)] = value    \\n        if len(d)>0:\\n            return sorted(d.items(), key=lambda x:x[1])[0][0]\\n        else:\\n            return -1\\n        \\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "For every point, we check with X and Y and if its valid point, we calculate the manhattan distance and add it to the dictionary with index in list as key and manhattan distance has value.\\n\\nIf the dictionary is empty, we return -1 else we sort the dictionary based on values and return key of the first element.\\n\\n```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        d=dict()\\n        for point in points:\\n            if x==point[0] or y==point[1]:\\n                value = abs(x-point[0]) + abs(y-point[1])\\n                d[points.index(point)] = value    \\n        if len(d)>0:\\n            return sorted(d.items(), key=lambda x:x[1])[0][0]\\n        else:\\n            return -1\\n        \\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2096304,
                "title": "python-easy-solution",
                "content": "```\\ndef nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\\n    min_distance = 2e5\\n    min_index = -1\\n    for idx, (xi, yi) in enumerate(points):\\n        if xi == x or yi == y:\\n            curr_distance = abs(x - xi) + abs(y - yi)\\n            if curr_distance < min_distance:\\n                min_distance = curr_distance\\n                min_index = idx\\n    return min_index\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\\n    min_distance = 2e5\\n    min_index = -1\\n    for idx, (xi, yi) in enumerate(points):\\n        if xi == x or yi == y:\\n            curr_distance = abs(x - xi) + abs(y - yi)\\n            if curr_distance < min_distance:\\n                min_distance = curr_distance\\n                min_index = idx\\n    return min_index\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2090820,
                "title": "100-java",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int  min = Integer.MAX_VALUE;\\n        int ans=-1;\\n        for(int i = 0; i < points.length; i++){\\n            if(points[i][0] == x || points[i][1] == y){\\n                int distance = Math.abs(x-points[i][0]) + Math.abs(y-points[i][1]);\\n                if(min > distance){\\n                    min = distance;\\n                    ans = i;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int  min = Integer.MAX_VALUE;\\n        int ans=-1;\\n        for(int i = 0; i < points.length; i++){\\n            if(points[i][0] == x || points[i][1] == y){\\n                int distance = Math.abs(x-points[i][0]) + Math.abs(y-points[i][1]);\\n                if(min > distance){\\n                    min = distance;\\n                    ans = i;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086906,
                "title": "easy-python-solution",
                "content": "class Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        #x= 3, y = 4 lst = [[2, 3]]\\n        # iterate every element return smallest index according to manhatten distance\\n        mn_distance = float(\"inf\")\\n        min_idx = -1\\n        for idx, lst in enumerate(points):\\n            if x == lst[0] or y == lst[1]:\\n                mnhatten_dst_current  = abs(x - lst[0]) + abs(y - lst[1])\\n                if mnhatten_dst_current < mn_distance:\\n                    mn_distance = mnhatten_dst_current\\n                    min_idx = idx\\n        return min_idx\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        #x= 3, y = 4 lst = [[2, 3]]\\n        # iterate every element return smallest index according to manhatten distance\\n        mn_distance = float(\"inf\")\\n        min_idx = -1\\n        for idx, lst in enumerate(points):\\n            if x == lst[0] or y == lst[1]:\\n                mnhatten_dst_current  = abs(x - lst[0]) + abs(y - lst[1])\\n                if mnhatten_dst_current < mn_distance:\\n                    mn_distance = mnhatten_dst_current\\n                    min_idx = idx\\n        return min_idx\\n",
                "codeTag": "Java"
            },
            {
                "id": 2062614,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int minDist = Integer.MAX_VALUE;\\n        int minIdx = Integer.MAX_VALUE;\\n        for(int i=0; i<points.length; i++){\\n            int[] point = points[i];\\n            if(point[0] == x || point[1] == y){\\n                int dist = Math.abs(x-point[0]) + Math.abs(y-point[1]);\\n                if(dist<minDist){\\n                    minDist = dist;\\n                    minIdx = i;\\n                }\\n            }\\n        }\\n        if(minIdx != Integer.MAX_VALUE){\\n            return minIdx;\\n        } else{\\n            return -1;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int minDist = Integer.MAX_VALUE;\\n        int minIdx = Integer.MAX_VALUE;\\n        for(int i=0; i<points.length; i++){\\n            int[] point = points[i];\\n            if(point[0] == x || point[1] == y){\\n                int dist = Math.abs(x-point[0]) + Math.abs(y-point[1]);\\n                if(dist<minDist){\\n                    minDist = dist;\\n                    minIdx = i;\\n                }\\n            }\\n        }\\n        if(minIdx != Integer.MAX_VALUE){\\n            return minIdx;\\n        } else{\\n            return -1;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057517,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int distance = Integer.MAX_VALUE, newDistance, index = -1;\\n        for (int i = 0; i < points.length; i++) {\\n            if (x == points[i][0] || y == points[i][1]) {\\n                //valid\\n                newDistance = Math.abs(x-points[i][0]) + Math.abs(y-points[i][1]);\\n                if(newDistance < distance){\\n                    index = i;\\n                    distance = newDistance;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int distance = Integer.MAX_VALUE, newDistance, index = -1;\\n        for (int i = 0; i < points.length; i++) {\\n            if (x == points[i][0] || y == points[i][1]) {\\n                //valid\\n                newDistance = Math.abs(x-points[i][0]) + Math.abs(y-points[i][1]);\\n                if(newDistance < distance){\\n                    index = i;\\n                    distance = newDistance;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047748,
                "title": "python3-list-comprehension",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        valid_point = [\\n            (i, abs(x - point[0]) + abs(y - point[1]))\\n            for i, point in enumerate(points)\\n            if any((x == point[0], y == point[1]))\\n        ]\\n\\n        if not valid_point:\\n            return -1\\n        elif len(valid_point) > 1:\\n            return sorted(valid_point, key=lambda x: (x[1], x[0]))[0][0]\\n        else:\\n            return valid_point[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        \\n        valid_point = [\\n            (i, abs(x - point[0]) + abs(y - point[1]))\\n            for i, point in enumerate(points)\\n            if any((x == point[0], y == point[1]))\\n        ]\\n\\n        if not valid_point:\\n            return -1\\n        elif len(valid_point) > 1:\\n            return sorted(valid_point, key=lambda x: (x[1], x[0]))[0][0]\\n        else:\\n            return valid_point[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047247,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func nearestValidPoint(_ x: Int, _ y: Int, _ points: [[Int]]) -> Int {\\n        var minIndex = -1\\n        var currentMinValue = Int.max\\n        var pointer = 0\\n        for i in points {\\n            if i[0] == x || i[1] == y {\\n                var distance = abs(i[0] - x) + abs(i[1] - y)\\n                minIndex = distance < currentMinValue ? pointer : minIndex\\n                currentMinValue = min(distance, currentMinValue)\\n            }\\n            pointer += 1\\n        }\\n        return minIndex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func nearestValidPoint(_ x: Int, _ y: Int, _ points: [[Int]]) -> Int {\\n        var minIndex = -1\\n        var currentMinValue = Int.max\\n        var pointer = 0\\n        for i in points {\\n            if i[0] == x || i[1] == y {\\n                var distance = abs(i[0] - x) + abs(i[1] - y)\\n                minIndex = distance < currentMinValue ? pointer : minIndex\\n                currentMinValue = min(distance, currentMinValue)\\n            }\\n            pointer += 1\\n        }\\n        return minIndex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036978,
                "title": "java-100-faster-for-beginners",
                "content": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n      \\n      int smallestdist = Integer.MAX_VALUE;\\n      int index = -1;\\n      \\n      \\n        for(int i =0 ;i< points.length ;i++){\\n          if(points[i][0]==x || points[i][1]==y){\\n            int ham = Math.abs(points[i][0]-x)  +  Math.abs(points[i][1]-y)   ;\\n            if(smallestdist>ham){\\n              smallestdist = ham;\\n              index = i;\\n            }\\n          }\\n        }\\n      return index;\\n      \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n      \\n      int smallestdist = Integer.MAX_VALUE;\\n      int index = -1;\\n      \\n      \\n        for(int i =0 ;i< points.length ;i++){\\n          if(points[i][0]==x || points[i][1]==y){\\n            int ham = Math.abs(points[i][0]-x)  +  Math.abs(points[i][1]-y)   ;\\n            if(smallestdist>ham){\\n              smallestdist = ham;\\n              index = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1985792,
                "title": "simple-and-concise-c-solution-with-7-lines",
                "content": "```\\nint nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int index = -1, min = INT_MAX;\\n    for(int i = pointsSize - 1; i >= 0; i--)\\n    {\\n        if(points[i][0] == x || points[i][1] == y)\\n            if(abs(points[i][0] - x) + abs(points[i][1] - y) <= min)\\n            {\\n                min = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                index = i;\\n            }\\n    }\\n    return index;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int index = -1, min = INT_MAX;\\n    for(int i = pointsSize - 1; i >= 0; i--)\\n    {\\n        if(points[i][0] == x || points[i][1] == y)\\n            if(abs(points[i][0] - x) + abs(points[i][1] - y) <= min)\\n            {\\n                min = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                index = i;\\n            }\\n    }\\n    return index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970984,
                "title": "c-simple-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int distance = INT_MAX , minIndex = -1 ;\\n        \\n        for(int i = 0 ; i < points.size() ; ++i ){\\n            if(points[i][0] != x and points[i][1] != y) continue ;\\n            //else valid point , so keep track of distance!\\n            if(distance > abs(x-points[i][0]) + abs(y-points[i][1]) ){\\n                distance = abs(x-points[i][0]) + abs(y-points[i][1]) ;\\n                minIndex = i ;\\n            }\\n        }\\n        return minIndex ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int distance = INT_MAX , minIndex = -1 ;\\n        \\n        for(int i = 0 ; i < points.size() ; ++i ){\\n            if(points[i][0] != x and points[i][1] != y) continue ;\\n            //else valid point , so keep track of distance!\\n            if(distance > abs(x-points[i][0]) + abs(y-points[i][1]) ){\\n                distance = abs(x-points[i][0]) + abs(y-points[i][1]) ;\\n                minIndex = i ;\\n            }\\n        }\\n        return minIndex ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965462,
                "title": "java-2ms-beats-85-optimization-valid-points-will-have-mh-distance-of-just-x-or-y-not-both",
                "content": "```\\n/*\\nRuntime: 2 ms, faster than 84.75% of Java online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\nMemory Usage: 49.6 MB, less than 96.46% of Java online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n*/\\n\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int indexOfClosestValidPoint = -1; // what we\\'ll return\\n        int leastManhattanDistance = Integer.MAX_VALUE;\\n        \\n        for (int index = 0; index < points.length; ++index) {\\n            if (points[index][0] == x) { // if is valid...\\n                int curManhattanDistance = Math.abs(y - points[index][1]); // since x-coordinates match, we just measure y distance\\n                if (curManhattanDistance < leastManhattanDistance) {\\n                    indexOfClosestValidPoint = index;\\n                    leastManhattanDistance = curManhattanDistance;\\n                }\\n            } else if (points[index][1] == y) { // if is valid...\\n                int curManhattanDistance = Math.abs(x - points[index][0]); // since y-coordinates match, we just measure x distance\\n                if (curManhattanDistance < leastManhattanDistance) {\\n                    indexOfClosestValidPoint = index;\\n                    leastManhattanDistance = curManhattanDistance;\\n                }\\n            }\\n        }\\n\\n        return indexOfClosestValidPoint;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 2 ms, faster than 84.75% of Java online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\nMemory Usage: 49.6 MB, less than 96.46% of Java online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n*/\\n\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int indexOfClosestValidPoint = -1; // what we\\'ll return\\n        int leastManhattanDistance = Integer.MAX_VALUE;\\n        \\n        for (int index = 0; index < points.length; ++index) {\\n            if (points[index][0] == x) { // if is valid...\\n                int curManhattanDistance = Math.abs(y - points[index][1]); // since x-coordinates match, we just measure y distance\\n                if (curManhattanDistance < leastManhattanDistance) {\\n                    indexOfClosestValidPoint = index;\\n                    leastManhattanDistance = curManhattanDistance;\\n                }\\n            } else if (points[index][1] == y) { // if is valid...\\n                int curManhattanDistance = Math.abs(x - points[index][0]); // since y-coordinates match, we just measure x distance\\n                if (curManhattanDistance < leastManhattanDistance) {\\n                    indexOfClosestValidPoint = index;\\n                    leastManhattanDistance = curManhattanDistance;\\n                }\\n            }\\n        }\\n\\n        return indexOfClosestValidPoint;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943826,
                "title": "2ms-java-solution",
                "content": "```\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1, min = Integer.MAX_VALUE, i  = 0;\\n        for(int[] point : points)   {\\n            if(x == points[i][0] || y == points[i][1]){\\n            int dis = Math.abs(x-point[0]) + Math.abs(y - point[1]);\\n            if(dis < min){\\n                min = dis;\\n                result = i;\\n            }\\n        }\\n        i++;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n        int result = -1, min = Integer.MAX_VALUE, i  = 0;\\n        for(int[] point : points)   {\\n            if(x == points[i][0] || y == points[i][1]){\\n            int dis = Math.abs(x-point[0]) + Math.abs(y - point[1]);\\n            if(dis < min){\\n                min = dis;\\n                result = i;\\n            }\\n        }\\n        i++;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921541,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int manhattan(vector<int> &p1, vector<int> &p2) {\\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);\\n    }\\n\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans = -1;\\n        int minDist = 1e5;\\n        int n = points.size();\\n        vector<int> curr = {x, y};\\n        for (int i = 0; i < n; i++) {\\n            if (points[i][0] == x || points[i][1] == y) {\\n                int tempDist = manhattan(curr, points[i]);\\n                if (tempDist < minDist) {\\n                    minDist = tempDist;\\n                    ans = i;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int manhattan(vector<int> &p1, vector<int> &p2) {\\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);\\n    }\\n\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int ans = -1;\\n        int minDist = 1e5;\\n        int n = points.size();\\n        vector<int> curr = {x, y};\\n        for (int i = 0; i < n; i++) {\\n            if (points[i][0] == x || points[i][1] == y) {\\n                int tempDist = manhattan(curr, points[i]);\\n                if (tempDist < minDist) {\\n                    minDist = tempDist;\\n                    ans = i;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921379,
                "title": "c-solution-95-03-faster-and-95-23-less-memory",
                "content": "class Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int smallest_dist = 2147483647;\\n        int index = -1;\\n        for(std::vector<vector<int>>::size_type i = 0; i != points.size(); ++i) {\\n            int x_dist = abs(points[i][0] - x);\\n            int y_dist = abs(points[i][1] - y);\\n            if(x_dist == 0 || y_dist == 0) {\\n                int temp = x_dist + y_dist;\\n                if(temp < smallest_dist) {\\n                    smallest_dist = temp;\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int smallest_dist = 2147483647;\\n        int index = -1;\\n        for(std::vector<vector<int>>::size_type i = 0; i != points.size(); ++i) {\\n            int x_dist = abs(points[i][0] - x);\\n            int y_dist = abs(points[i][1] - y);\\n            if(x_dist == 0 || y_dist == 0) {\\n                int temp = x_dist + y_dist;\\n                if(temp < smallest_dist) {\\n                    smallest_dist = temp;\\n                    index = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1917737,
                "title": "java-solution",
                "content": "Please upvote if you find this solution helpful\\nIf you know how to improve my code please write in the comments\\n```\\nclass Solution {\\n     public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = 100000;\\n        int index = -1;\\n        for (int i = 0; i < points.length; i++) {\\n            if ((points[i][0] == x) && Math.abs(points[i][1] - y) < min) {\\n                min = Math.abs(points[i][1] - y);\\n                index = i;\\n            } else if ((points[i][1] == y) &&  Math.abs(points[i][0] - x) < min) {\\n                min = Math.abs(points[i][0] - x);\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int nearestValidPoint(int x, int y, int[][] points) {\\n        int min = 100000;\\n        int index = -1;\\n        for (int i = 0; i < points.length; i++) {\\n            if ((points[i][0] == x) && Math.abs(points[i][1] - y) < min) {\\n                min = Math.abs(points[i][1] - y);\\n                index = i;\\n            } else if ((points[i][1] == y) &&  Math.abs(points[i][0] - x) < min) {\\n                min = Math.abs(points[i][0] - x);\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904225,
                "title": "python-solution-clean-simple",
                "content": "**Solution**\\n\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        m = 10 ** 5\\n        index = -1\\n        \\n        for i, (a, b) in enumerate(points):\\n            if x == a or y == b:\\n                if abs(x - a) +  abs(y - b) < m:\\n                    m = abs(x - a) +  abs(y - b)\\n                    index = i\\n        return index",
                "solutionTags": [],
                "code": "**Solution**\\n\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        m = 10 ** 5\\n        index = -1\\n        \\n        for i, (a, b) in enumerate(points):\\n            if x == a or y == b:\\n                if abs(x - a) +  abs(y - b) < m:\\n                    m = abs(x - a) +  abs(y - b)\\n                    index = i\\n        return index",
                "codeTag": "Python3"
            },
            {
                "id": 1903656,
                "title": "python",
                "content": "```\\ndef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid = [(ind, i) for ind, i in enumerate(points) if i[0] == x or i[1] == y]\\n        if not valid:\\n            return -1\\n        return min(valid, key=lambda k: abs(k[1][0] - x) + abs(k[1][1] - y))[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid = [(ind, i) for ind, i in enumerate(points) if i[0] == x or i[1] == y]\\n        if not valid:\\n            return -1\\n        return min(valid, key=lambda k: abs(k[1][0] - x) + abs(k[1][1] - y))[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1901671,
                "title": "python-heap",
                "content": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: list[list[int]]) -> int:\\n        heap = []\\n        heapify(heap)\\n        for i in range(len(points)):\\n            px, py = points[i]\\n            if px == x:\\n                heappush(heap, (abs(py - y), i))\\n            elif py == y:\\n                heappush(heap, (abs(px - x), i))\\n        return -1 if not heap else heappop(heap)[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: list[list[int]]) -> int:\\n        heap = []\\n        heapify(heap)\\n        for i in range(len(points)):\\n            px, py = points[i]\\n            if px == x:\\n                heappush(heap, (abs(py - y), i))\\n            elif py == y:\\n                heappush(heap, (abs(px - x), i))\\n        return -1 if not heap else heappop(heap)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890755,
                "title": "o-n-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int res = INT_MAX;\\n        int m = points.size();\\n        int temp = -1;\\n        int d;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(points[i][0] == x || points[i][1] == y)\\n            {\\n                d = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                if(d < res)\\n                {\\n                    res = d;\\n                    temp = i;\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int res = INT_MAX;\\n        int m = points.size();\\n        int temp = -1;\\n        int d;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(points[i][0] == x || points[i][1] == y)\\n            {\\n                d = abs(points[i][0] - x) + abs(points[i][1] - y);\\n                if(d < res)\\n                {\\n                    res = d;\\n                    temp = i;\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889374,
                "title": "simple-clean-javascript",
                "content": "```\\nvar nearestValidPoint = function(x, y, points) {\\n \\xA0 \\xA0let min=Infinity;  let indx=-1;\\n    points.forEach(([a,b],i)=>{\\n        if(a===x || b===y){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0let sum=Math.abs(a-x)+Math.abs(b-y);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(sum<min){min=sum;indx=i;}\\n        }\\n \\xA0 \\xA0}); \\n \\xA0 \\xA0return indx; \\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nvar nearestValidPoint = function(x, y, points) {\\n \\xA0 \\xA0let min=Infinity;  let indx=-1;\\n    points.forEach(([a,b],i)=>{\\n        if(a===x || b===y){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0let sum=Math.abs(a-x)+Math.abs(b-y);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(sum<min){min=sum;indx=i;}\\n        }\\n \\xA0 \\xA0}); \\n \\xA0 \\xA0return indx; \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886418,
                "title": "python-o-n-solution",
                "content": "```\\nimport sys #optional to import instead of you can assign huge arbitary value\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        idx = -1 #setting parameters\\n        min_dist = sys.maxsize #assigning max size incase if dist is too huge\\n        for i in range(len(points)):\\n\\t\\t\\t#filtering the points by comapring x and y\\'s value \\n            if points[i][0] == x or points[i][1] == y: \\n\\t\\t\\t\\t#if points contain any of the values subtracting it \\n\\t\\t\\t\\t# and make difference absolute before calculating distance from this point\\n                dist = abs(x - points[i][0]) + abs(y - points[i][1])\\n\\t\\t\\t\\t#if dist is less than min dist swap values of dist and i with idx and min_dist\\n                if dist < min_dist:\\n                    min_dist, idx = dist, i\\n        return idx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport sys #optional to import instead of you can assign huge arbitary value\\nclass Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        idx = -1 #setting parameters\\n        min_dist = sys.maxsize #assigning max size incase if dist is too huge\\n        for i in range(len(points)):\\n\\t\\t\\t#filtering the points by comapring x and y\\'s value \\n            if points[i][0] == x or points[i][1] == y: \\n\\t\\t\\t\\t#if points contain any of the values subtracting it \\n\\t\\t\\t\\t# and make difference absolute before calculating distance from this point\\n                dist = abs(x - points[i][0]) + abs(y - points[i][1])\\n\\t\\t\\t\\t#if dist is less than min dist swap values of dist and i with idx and min_dist\\n                if dist < min_dist:\\n                    min_dist, idx = dist, i\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856241,
                "title": "the-pythonic-way",
                "content": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        filtered_points = list(points.index(i) for i in filter(lambda a: a[0] == x or a[1] == y, points))\\n        \\n        if not filtered_points:\\n            return -1\\n        \\n        else:\\n            \\n            distances =(map(lambda b: abs(x-b[0]) + abs(y-b[1]), filter(lambda a: a[0] == x or a[1] == y, points)))\\n            return min(zip(distances, filtered_points))[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        \"\"\"\\n        :type x: int\\n        :type y: int\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        filtered_points = list(points.index(i) for i in filter(lambda a: a[0] == x or a[1] == y, points))\\n        \\n        if not filtered_points:\\n            return -1\\n        \\n        else:\\n            \\n            distances =(map(lambda b: abs(x-b[0]) + abs(y-b[1]), filter(lambda a: a[0] == x or a[1] == y, points)))\\n            return min(zip(distances, filtered_points))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845412,
                "title": "c-beginner-o-n-basics",
                "content": "```\\nclass Solution{\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>> &points)\\n    {\\n        int answer = -1;\\n        int dist = 999999; // INT_MAX would also work\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            if (x == points[i][0] || y == points[i][1])\\n            {\\n                if (dist > abs(x - points[i][0]) + abs(y - points[i][1]))\\n                {\\n                    dist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n                    answer = i;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n\\n/*\\nExplanation:\\n(i)   we assign a variable answer with value of -1 as it would be return if no distance is found\\n(ii)  we assign distance variable with max value an integer can store so that for the first time it would be greater the distance and line  11 would work and so on\\n(iii) we check id ordinate or co-ordinate matches with on standing array, if so..\\n(iv)  we check distance with dist variable, if dist is less than previously stored we will update the value of dist\\n(v)   we store the index of that array to our answer as we have to return the index of array itself\\n(vi)   repeat until end of array\\n(vii)  in the end we return index as stored in answer\\n\\nTime: O(n)\\nSpace: O(1)\\n*/",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution{\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>> &points)\\n    {\\n        int answer = -1;\\n        int dist = 999999; // INT_MAX would also work\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            if (x == points[i][0] || y == points[i][1])\\n            {\\n                if (dist > abs(x - points[i][0]) + abs(y - points[i][1]))\\n                {\\n                    dist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n                    answer = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1843121,
                "title": "c-3-solutions-linq-no-loop-2-lines-list-methods-no-linq-loop",
                "content": "SOLUTION 1 \\nUsing LINQ\\n```\\npublic int NearestValidPoint(int x, int y, int[][] points)\\n{\\n\\tvar list = points.Select((e) => (e[0] == x || e[1] == y) ? (Math.Abs(e[0] - x) + Math.Abs(e[1] - y)) : int.MaxValue).ToList();\\n\\tint minDist = list.Min();\\n\\treturn list.FindIndex((e) => e == minDist && e != int.MaxValue);\\n}\\n```\\n\\n-----\\n\\nSOLUTION 2\\nUsing List FindIndex Method and looping with for loop to add distances to a list.\\n```\\npublic int NearestValidPoint(int x, int y, int[][] points) {\\n\\tList<int> distances = new List<int>(points.Length);\\n\\tfor (int i = 0; i < points.Length; i++)\\n\\t{\\n\\t\\tif (points[i][0] == x || points[i][1] == y)\\n\\t\\t\\tdistances.Add(Math.Abs(points[i][0] - x) + Math.Abs(points[i][1] - y));\\n\\t\\telse\\n\\t\\t\\tdistances.Add(int.MaxValue);\\n\\t}\\n\\tint minDist = distances.Min();\\n\\treturn distances.FindIndex(e => (e == minDist && e != int.MaxValue));\\n}\\n```\\n\\n----------\\n\\n\\nSOLUTION 2\\nUsing no LINQ and no List FindIndex method\\n```\\npublic int NearestValidPoint(int x, int y, int[][] points) {\\n\\tint lowestInd = -1;\\n\\tint lowest = int.MaxValue;\\n\\n\\tfor (int i = 0; i < points.Length; i++)\\n\\t{\\n\\t\\t// is current point valid?\\n\\t\\tif (points[i][0] == x || points[i][1] == y)\\n\\t\\t{\\n\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tint localM = Math.Abs(x - points[i][0]) + Math.Abs(y - points[i][1]);\\n\\t\\tif (localM < lowest)\\n\\t\\t{\\n\\t\\t\\tlowestInd = i;\\n\\t\\t\\tlowest = localM;\\n\\t\\t}\\n\\t}\\n\\n\\treturn lowestInd;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NearestValidPoint(int x, int y, int[][] points)\\n{\\n\\tvar list = points.Select((e) => (e[0] == x || e[1] == y) ? (Math.Abs(e[0] - x) + Math.Abs(e[1] - y)) : int.MaxValue).ToList();\\n\\tint minDist = list.Min();\\n\\treturn list.FindIndex((e) => e == minDist && e != int.MaxValue);\\n}\\n```\n```\\npublic int NearestValidPoint(int x, int y, int[][] points) {\\n\\tList<int> distances = new List<int>(points.Length);\\n\\tfor (int i = 0; i < points.Length; i++)\\n\\t{\\n\\t\\tif (points[i][0] == x || points[i][1] == y)\\n\\t\\t\\tdistances.Add(Math.Abs(points[i][0] - x) + Math.Abs(points[i][1] - y));\\n\\t\\telse\\n\\t\\t\\tdistances.Add(int.MaxValue);\\n\\t}\\n\\tint minDist = distances.Min();\\n\\treturn distances.FindIndex(e => (e == minDist && e != int.MaxValue));\\n}\\n```\n```\\npublic int NearestValidPoint(int x, int y, int[][] points) {\\n\\tint lowestInd = -1;\\n\\tint lowest = int.MaxValue;\\n\\n\\tfor (int i = 0; i < points.Length; i++)\\n\\t{\\n\\t\\t// is current point valid?\\n\\t\\tif (points[i][0] == x || points[i][1] == y)\\n\\t\\t{\\n\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tint localM = Math.Abs(x - points[i][0]) + Math.Abs(y - points[i][1]);\\n\\t\\tif (localM < lowest)\\n\\t\\t{\\n\\t\\t\\tlowestInd = i;\\n\\t\\t\\tlowest = localM;\\n\\t\\t}\\n\\t}\\n\\n\\treturn lowestInd;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839081,
                "title": "nearest-point-line-by-line-explaination-java-86-16",
                "content": "\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int n = points.length;\\n        ArrayList<Integer> list = new ArrayList<>(); // create a list to store the index of the valid points\\n        for(int i=0;i<n;i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y) // check if the inner array has same x and y value or not\\n                list.add(i); // store the index of array in list \\n        }\\n        int index = -1;  // we don\\'t know the nearest point , so initialiaze with -1.\\n        int min = Integer.MAX_VALUE; // as we don\\'t know the min distance, make it default as maximum\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int dist = Math.abs(points[list.get(i)][0]-x) + Math.abs(points[list.get(i)][1]-y); // apply the formula of manhattan distance to find the distance between two points\\n            if(dist<min)\\n            {\\n                min = dist; // store the minimum distance\\n                index = list.get(i); // store the original array index for the nearest location from your location\\n            }\\n                \\n        }\\n        return index; // return the index of the nearest point\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int n = points.length;\\n        ArrayList<Integer> list = new ArrayList<>(); // create a list to store the index of the valid points\\n        for(int i=0;i<n;i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y) // check if the inner array has same x and y value or not\\n                list.add(i); // store the index of array in list \\n        }\\n        int index = -1;  // we don\\'t know the nearest point , so initialiaze with -1.\\n        int min = Integer.MAX_VALUE; // as we don\\'t know the min distance, make it default as maximum\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int dist = Math.abs(points[list.get(i)][0]-x) + Math.abs(points[list.get(i)][1]-y); // apply the formula of manhattan distance to find the distance between two points\\n            if(dist<min)\\n            {\\n                min = dist; // store the minimum distance\\n                index = list.get(i); // store the original array index for the nearest location from your location\\n            }\\n                \\n        }\\n        return index; // return the index of the nearest point\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836167,
                "title": "c-easy-expaination",
                "content": "class Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) \\n    {\\n        int small=INT_MAX;\\n        int idx=-1;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                int dist=(abs(x-points[i][0])+abs(y-points[i][1]));\\n                if(dist<small)\\n                {\\n                    idx=i;\\n                    small=dist;\\n                }\\n                \\n            }\\n        }\\n        return idx;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) \\n    {\\n        int small=INT_MAX;\\n        int idx=-1;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]==x || points[i][1]==y)\\n            {\\n                int dist=(abs(x-points[i][0])+abs(y-points[i][1]));\\n                if(dist<small)\\n                {\\n                    idx=i;\\n                    small=dist;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1825274,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 798 ms, faster than 74.13% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n# Memory Usage: 19.4 MB, less than 45.41% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\nclass Solution:\\n    def nearestValidPoint(self, x, y, points):\\n        result, minDist = -1, float(\\'inf\\')\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                currDist = abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if currDist<minDist:\\n                    result, minDist = i, currDist\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 798 ms, faster than 74.13% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\n# Memory Usage: 19.4 MB, less than 45.41% of Python3 online submissions for Find Nearest Point That Has the Same X or Y Coordinate.\\nclass Solution:\\n    def nearestValidPoint(self, x, y, points):\\n        result, minDist = -1, float(\\'inf\\')\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                currDist = abs(points[i][0]-x)+abs(points[i][1]-y)\\n                if currDist<minDist:\\n                    result, minDist = i, currDist\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822675,
                "title": "python-comprehension-list",
                "content": "# class Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid = [i for i in points if any([i[0]==x, i[1]==y])]\\n        dist = [abs(i[0]-x)+abs(i[1]-y) for i in valid]\\n        return points.index(valid[dist.index(min(dist))]) if len(valid)>0 else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "# class Solution:\\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\\n        valid = [i for i in points if any([i[0]==x, i[1]==y])]\\n        dist = [abs(i[0]-x)+abs(i[1]-y) for i in valid]\\n        return points.index(valid[dist.index(min(dist))]) if len(valid)>0 else -1",
                "codeTag": "Java"
            },
            {
                "id": 1816757,
                "title": "c-easy-o-n-solution",
                "content": "```\\nclass Solution{\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>> &points)\\n    {\\n        int index = -1;\\n        int dist = INT_MAX;\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            if (x == points[i][0] || y == points[i][1])  //checking valid point or not\\n            {\\n                if (dist > abs(x - points[i][0]) + abs(y - points[i][1])) //finding point with minimum manhattan distance\\n                {\\n                    dist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>> &points)\\n    {\\n        int index = -1;\\n        int dist = INT_MAX;\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            if (x == points[i][0] || y == points[i][1])  //checking valid point or not\\n            {\\n                if (dist > abs(x - points[i][0]) + abs(y - points[i][1])) //finding point with minimum manhattan distance\\n                {\\n                    dist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n                    index = i;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814896,
                "title": "java-easy-and-intuitive-solution",
                "content": "**Code**\\n```java\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n\\tint indx = -1, minDis = Integer.MAX_VALUE;\\n\\t\\n\\tfor(int i = 0; i < points.length; i++) {\\n\\t\\tint[] arr = points[i];\\n\\t\\tif(arr[0] == x || arr[1] == y) {\\n\\t\\t\\tint dis = Math.abs(x - arr[0]) + Math.abs(y - arr[1]);\\n\\t\\t\\tif(dis < minDis) {\\n\\t\\t\\t\\tminDis = dis;\\n\\t\\t\\t\\tindx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn indx;\\n}\\n```\\n\\n**Explanation**\\n- inititalize `indx = -1` and `minDis = Integer.MAX_VALUE`.\\n- iterate over points array and if array is valid follow this:-\\n\\t- calculate distance between two points and if it is minimum, update minDis and indx value.\\n- if not valid move forward.\\n- after iteration return indx.\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int nearestValidPoint(int x, int y, int[][] points) {\\n\\tint indx = -1, minDis = Integer.MAX_VALUE;\\n\\t\\n\\tfor(int i = 0; i < points.length; i++) {\\n\\t\\tint[] arr = points[i];\\n\\t\\tif(arr[0] == x || arr[1] == y) {\\n\\t\\t\\tint dis = Math.abs(x - arr[0]) + Math.abs(y - arr[1]);\\n\\t\\t\\tif(dis < minDis) {\\n\\t\\t\\t\\tminDis = dis;\\n\\t\\t\\t\\tindx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn indx;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803580,
                "title": "rust-two-implementations-with-iterators-with-a-loop",
                "content": "\\n### With iterators\\n\\n```rust\\npub fn nearest_valid_point(x: i32, y: i32, points: Vec<Vec<i32>>) -> i32 {\\n    points\\n        .iter()\\n        .enumerate()\\n        .filter(|&(_idx, p)| p[0] == x || p[1] == y)\\n        .min_by(|&(_, a), &(_, b)| {\\n            let m1 = manhattan((x, y), (a[0], a[1]));\\n            let m2 = manhattan((x, y), (b[0], b[1]));\\n            m1.cmp(&m2)\\n        })\\n        .map(|(idx, _)| idx as i32)\\n        .unwrap_or(-1)\\n}\\n\\nfn manhattan(loc: (i32, i32), point: (i32, i32)) -> i32 {\\n    (loc.0 - point.0).abs() + (loc.1 - point.1).abs()\\n}\\n```\\n\\n### With a loop\\n\\n```rust\\npub fn nearest_valid_point(x: i32, y: i32, points: Vec<Vec<i32>>) -> i32 {\\n    let mut nearest = None;\\n    let mut distance = None;\\n\\n    for (idx, p) in points.into_iter().enumerate() {\\n        if x == p[0] || y == p[1] {\\n            let manhattan = manhattan((x, y), (p[0], p[1]));\\n            if distance.is_none() || Some(manhattan) < distance {\\n                distance = Some(manhattan);\\n                nearest = Some(idx as i32);\\n            }\\n        }\\n    }\\n\\n    nearest.unwrap_or(-1)\\n}\\n\\nfn manhattan(loc: (i32, i32), point: (i32, i32)) -> i32 {\\n    (loc.0 - point.0).abs() + (loc.1 - point.1).abs()\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn nearest_valid_point(x: i32, y: i32, points: Vec<Vec<i32>>) -> i32 {\\n    points\\n        .iter()\\n        .enumerate()\\n        .filter(|&(_idx, p)| p[0] == x || p[1] == y)\\n        .min_by(|&(_, a), &(_, b)| {\\n            let m1 = manhattan((x, y), (a[0], a[1]));\\n            let m2 = manhattan((x, y), (b[0], b[1]));\\n            m1.cmp(&m2)\\n        })\\n        .map(|(idx, _)| idx as i32)\\n        .unwrap_or(-1)\\n}\\n\\nfn manhattan(loc: (i32, i32), point: (i32, i32)) -> i32 {\\n    (loc.0 - point.0).abs() + (loc.1 - point.1).abs()\\n}\\n```\n```rust\\npub fn nearest_valid_point(x: i32, y: i32, points: Vec<Vec<i32>>) -> i32 {\\n    let mut nearest = None;\\n    let mut distance = None;\\n\\n    for (idx, p) in points.into_iter().enumerate() {\\n        if x == p[0] || y == p[1] {\\n            let manhattan = manhattan((x, y), (p[0], p[1]));\\n            if distance.is_none() || Some(manhattan) < distance {\\n                distance = Some(manhattan);\\n                nearest = Some(idx as i32);\\n            }\\n        }\\n    }\\n\\n    nearest.unwrap_or(-1)\\n}\\n\\nfn manhattan(loc: (i32, i32), point: (i32, i32)) -> i32 {\\n    (loc.0 - point.0).abs() + (loc.1 - point.1).abs()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1773088,
                "title": "c-easy-to-understand",
                "content": "**C++ Solutions :**\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& p,int mindi=INT_MAX,int idx=0 ) {\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(p[i][0]==x||p[i][1]==y)\\n            {\\n                int di=abs(x-p[i][0])+abs(y-p[i][1]);\\n                if(di<mindi)\\n                {\\n                    mindi=di;\\n                    idx=i;\\n                }\\n            }\\n        }\\n        return mindi==INT_MAX&&idx==0?-1:idx;\\n    }\\n};\\n```\\n**If you like/help this solutions , please upvoter for my motivations ^</>^**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& p,int mindi=INT_MAX,int idx=0 ) {\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(p[i][0]==x||p[i][1]==y)\\n            {\\n                int di=abs(x-p[i][0])+abs(y-p[i][1]);\\n                if(di<mindi)\\n                {\\n                    mindi=di;\\n                    idx=i;\\n                }\\n            }\\n        }\\n        return mindi==INT_MAX&&idx==0?-1:idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562025,
                "title": "c-simple-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& arr) {\\n        int index=-1;\\n        int res=INT_MAX;\\n     for(int i=0;i<arr.size();i++){\\n           int a=abs(x-arr[i][0])+abs(y-arr[i][1]);\\n           if(res>a&&((arr[i][0]==x)||(arr[i][1]==y))){\\n               res=a;\\n               index=i;\\n           }\\n     }\\n        if(index!=-1)\\n        return index;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& arr) {\\n        int index=-1;\\n        int res=INT_MAX;\\n     for(int i=0;i<arr.size();i++){\\n           int a=abs(x-arr[i][0])+abs(y-arr[i][1]);\\n           if(res>a&&((arr[i][0]==x)||(arr[i][1]==y))){\\n               res=a;\\n               index=i;\\n           }\\n     }\\n        if(index!=-1)\\n        return index;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535000,
                "title": "c-easy-to-understand-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int index=-1,smallest=INT_MAX;\\n    for(int i=0;i<points.size();i++)\\n    {\\n        if(x==points[i][0]||y==points[i][1])\\n        {\\n            int man=abs(x-points[i][0])+abs(y-points[i][1]);\\n            if(smallest>man)\\n            {\\n                smallest=man;\\n                index=i;\\n            }\\n            else if(smallest==man)\\n            {\\n                if(index>i)\\n                index=i;\\n            }\\n        }\\n    }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\\n        int index=-1,smallest=INT_MAX;\\n    for(int i=0;i<points.size();i++)\\n    {\\n        if(x==points[i][0]||y==points[i][1])\\n        {\\n            int man=abs(x-points[i][0])+abs(y-points[i][1]);\\n            if(smallest>man)\\n            {\\n                smallest=man;\\n                index=i;\\n            }\\n            else if(smallest==man)\\n            {\\n                if(index>i)\\n                index=i;\\n            }\\n        }\\n    }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1689044,
                "content": [
                    {
                        "username": "GreenJ84",
                        "content": "x = 1, y = 1\\npoints [[1,2], [3,3], [3,3]]\\n\\nI am getting 1 but Leetcode says it should be 0?\\nBut there is no point that is an exact match? \\n\\nIt is TestCase #44"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Turns out, the question was asking for the index"
                    },
                    {
                        "username": "vvsdnagendraanala_co20b7_30",
                        "content": "i faced the same problem bro , maybe we interpreted the question wrong\\n"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "indexed 0 [1,2] is a valid point as it share same x coordinate (1), no other point have it"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "If this is easy, Then I don\\'t know what are med and hard"
                    },
                    {
                        "username": "hniv",
                        "content": "\"If there are multiple, return the valid point with the smallest index\". At testCase 1, my result is 1 and expected 2 but the valid point(s) with manhattan distances are [3, 1, 1]?? So what's smallest index mean?\n"
                    },
                    {
                        "username": "sachinbore",
                        "content": "we have to return the index w.r.to original array(input array)"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "For test case 1: \\npoints = [[1,2],[3,1],[2,4],[2,3],[4,4]]\\nThe valid point(s) with manhattan distances are [3, 1, 1]\\nThe example expected output of index value of 2 is inaccurate as index of 1 can also be a valid answer. "
                    },
                    {
                        "username": "vin36",
                        "content": "Yep, those are the valid points. But of those, we want to return the valid point with the smallest manhattan distance, which is point 2."
                    },
                    {
                        "username": "Vulture59",
                        "content": "HI, this is my solution that failed at testcase 101:\\nIndex 53 and 73 have the same value of [24,27], giving the smallest manhatten distance of 3 when x,y=27,27\\nHowever, my code kept giving the output of index 73 instead of 53. Is anyone able to spot what is wrong with my code?\\n\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n       \\n        dict1={}\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manhat=int(abs(points[i][0]-x)+abs(points[i][1]-y))\\n                dict1[i]=manhat\\n\\n        if dict1:\\n            minmanhat=min(dict1.values())\\n            for k,v in dict1.items():\\n                if v==minmanhat:\\n                    return(k)    \\n        else:\\n            return(-1)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to finding the valid point with the minimum Manhattan distance is correct. However, your approach to finding the smallest index isn\\'t quite right. When you find a minimum Manhattan distance, you\\'re not guaranteed to get the smallest index for it, because dictionaries in Python do not preserve any particular order of keys.\\n\\nTo ensure you get the smallest index, you should iterate over your `dict1` in ascending order of the keys (which represent indices). Here\\'s how you could modify your code:\\n\\n```python\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        dict1 = {}\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                manhat = abs(points[i][0] - x) + abs(points[i][1] - y)\\n                dict1[i] = manhat\\n\\n        if dict1:\\n            minmanhat = min(dict1.values())\\n            # Sort the keys in ascending order before iterating over them\\n            for k in sorted(dict1.keys()):\\n                if dict1[k] == minmanhat:\\n                    return k\\n        else:\\n            return -1\\n```\\n\\nThis version of the code will return the smallest index among those that have the minimum Manhattan distance."
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "In this question I used the brute force approach in the problem, first i have taken three variables in which one variable for the smallest distance and other for result and another current distance now it.....now check the given points are equal in the wheather x or y if it true now calaculate the current distance using manhattan distance...now check the current dis with the  smallestdistance if it true then change the current distance = smallest distance then change the res values in  as the iteration i value for the point where the index is been located...\\natlast return the result that you obtain....\\n\\n\\nJust tried this by approach in which directly check the 2 columns and n rows...\\nnow just try to solve this question daily basis ///// "
                    }
                ]
            },
            {
                "id": 1838704,
                "content": [
                    {
                        "username": "GreenJ84",
                        "content": "x = 1, y = 1\\npoints [[1,2], [3,3], [3,3]]\\n\\nI am getting 1 but Leetcode says it should be 0?\\nBut there is no point that is an exact match? \\n\\nIt is TestCase #44"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Turns out, the question was asking for the index"
                    },
                    {
                        "username": "vvsdnagendraanala_co20b7_30",
                        "content": "i faced the same problem bro , maybe we interpreted the question wrong\\n"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "indexed 0 [1,2] is a valid point as it share same x coordinate (1), no other point have it"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "If this is easy, Then I don\\'t know what are med and hard"
                    },
                    {
                        "username": "hniv",
                        "content": "\"If there are multiple, return the valid point with the smallest index\". At testCase 1, my result is 1 and expected 2 but the valid point(s) with manhattan distances are [3, 1, 1]?? So what's smallest index mean?\n"
                    },
                    {
                        "username": "sachinbore",
                        "content": "we have to return the index w.r.to original array(input array)"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "For test case 1: \\npoints = [[1,2],[3,1],[2,4],[2,3],[4,4]]\\nThe valid point(s) with manhattan distances are [3, 1, 1]\\nThe example expected output of index value of 2 is inaccurate as index of 1 can also be a valid answer. "
                    },
                    {
                        "username": "vin36",
                        "content": "Yep, those are the valid points. But of those, we want to return the valid point with the smallest manhattan distance, which is point 2."
                    },
                    {
                        "username": "Vulture59",
                        "content": "HI, this is my solution that failed at testcase 101:\\nIndex 53 and 73 have the same value of [24,27], giving the smallest manhatten distance of 3 when x,y=27,27\\nHowever, my code kept giving the output of index 73 instead of 53. Is anyone able to spot what is wrong with my code?\\n\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n       \\n        dict1={}\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manhat=int(abs(points[i][0]-x)+abs(points[i][1]-y))\\n                dict1[i]=manhat\\n\\n        if dict1:\\n            minmanhat=min(dict1.values())\\n            for k,v in dict1.items():\\n                if v==minmanhat:\\n                    return(k)    \\n        else:\\n            return(-1)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to finding the valid point with the minimum Manhattan distance is correct. However, your approach to finding the smallest index isn\\'t quite right. When you find a minimum Manhattan distance, you\\'re not guaranteed to get the smallest index for it, because dictionaries in Python do not preserve any particular order of keys.\\n\\nTo ensure you get the smallest index, you should iterate over your `dict1` in ascending order of the keys (which represent indices). Here\\'s how you could modify your code:\\n\\n```python\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        dict1 = {}\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                manhat = abs(points[i][0] - x) + abs(points[i][1] - y)\\n                dict1[i] = manhat\\n\\n        if dict1:\\n            minmanhat = min(dict1.values())\\n            # Sort the keys in ascending order before iterating over them\\n            for k in sorted(dict1.keys()):\\n                if dict1[k] == minmanhat:\\n                    return k\\n        else:\\n            return -1\\n```\\n\\nThis version of the code will return the smallest index among those that have the minimum Manhattan distance."
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "In this question I used the brute force approach in the problem, first i have taken three variables in which one variable for the smallest distance and other for result and another current distance now it.....now check the given points are equal in the wheather x or y if it true now calaculate the current distance using manhattan distance...now check the current dis with the  smallestdistance if it true then change the current distance = smallest distance then change the res values in  as the iteration i value for the point where the index is been located...\\natlast return the result that you obtain....\\n\\n\\nJust tried this by approach in which directly check the 2 columns and n rows...\\nnow just try to solve this question daily basis ///// "
                    }
                ]
            },
            {
                "id": 1795379,
                "content": [
                    {
                        "username": "GreenJ84",
                        "content": "x = 1, y = 1\\npoints [[1,2], [3,3], [3,3]]\\n\\nI am getting 1 but Leetcode says it should be 0?\\nBut there is no point that is an exact match? \\n\\nIt is TestCase #44"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Turns out, the question was asking for the index"
                    },
                    {
                        "username": "vvsdnagendraanala_co20b7_30",
                        "content": "i faced the same problem bro , maybe we interpreted the question wrong\\n"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "indexed 0 [1,2] is a valid point as it share same x coordinate (1), no other point have it"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "If this is easy, Then I don\\'t know what are med and hard"
                    },
                    {
                        "username": "hniv",
                        "content": "\"If there are multiple, return the valid point with the smallest index\". At testCase 1, my result is 1 and expected 2 but the valid point(s) with manhattan distances are [3, 1, 1]?? So what's smallest index mean?\n"
                    },
                    {
                        "username": "sachinbore",
                        "content": "we have to return the index w.r.to original array(input array)"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "For test case 1: \\npoints = [[1,2],[3,1],[2,4],[2,3],[4,4]]\\nThe valid point(s) with manhattan distances are [3, 1, 1]\\nThe example expected output of index value of 2 is inaccurate as index of 1 can also be a valid answer. "
                    },
                    {
                        "username": "vin36",
                        "content": "Yep, those are the valid points. But of those, we want to return the valid point with the smallest manhattan distance, which is point 2."
                    },
                    {
                        "username": "Vulture59",
                        "content": "HI, this is my solution that failed at testcase 101:\\nIndex 53 and 73 have the same value of [24,27], giving the smallest manhatten distance of 3 when x,y=27,27\\nHowever, my code kept giving the output of index 73 instead of 53. Is anyone able to spot what is wrong with my code?\\n\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n       \\n        dict1={}\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manhat=int(abs(points[i][0]-x)+abs(points[i][1]-y))\\n                dict1[i]=manhat\\n\\n        if dict1:\\n            minmanhat=min(dict1.values())\\n            for k,v in dict1.items():\\n                if v==minmanhat:\\n                    return(k)    \\n        else:\\n            return(-1)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to finding the valid point with the minimum Manhattan distance is correct. However, your approach to finding the smallest index isn\\'t quite right. When you find a minimum Manhattan distance, you\\'re not guaranteed to get the smallest index for it, because dictionaries in Python do not preserve any particular order of keys.\\n\\nTo ensure you get the smallest index, you should iterate over your `dict1` in ascending order of the keys (which represent indices). Here\\'s how you could modify your code:\\n\\n```python\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        dict1 = {}\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                manhat = abs(points[i][0] - x) + abs(points[i][1] - y)\\n                dict1[i] = manhat\\n\\n        if dict1:\\n            minmanhat = min(dict1.values())\\n            # Sort the keys in ascending order before iterating over them\\n            for k in sorted(dict1.keys()):\\n                if dict1[k] == minmanhat:\\n                    return k\\n        else:\\n            return -1\\n```\\n\\nThis version of the code will return the smallest index among those that have the minimum Manhattan distance."
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "In this question I used the brute force approach in the problem, first i have taken three variables in which one variable for the smallest distance and other for result and another current distance now it.....now check the given points are equal in the wheather x or y if it true now calaculate the current distance using manhattan distance...now check the current dis with the  smallestdistance if it true then change the current distance = smallest distance then change the res values in  as the iteration i value for the point where the index is been located...\\natlast return the result that you obtain....\\n\\n\\nJust tried this by approach in which directly check the 2 columns and n rows...\\nnow just try to solve this question daily basis ///// "
                    }
                ]
            },
            {
                "id": 1739719,
                "content": [
                    {
                        "username": "GreenJ84",
                        "content": "x = 1, y = 1\\npoints [[1,2], [3,3], [3,3]]\\n\\nI am getting 1 but Leetcode says it should be 0?\\nBut there is no point that is an exact match? \\n\\nIt is TestCase #44"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Turns out, the question was asking for the index"
                    },
                    {
                        "username": "vvsdnagendraanala_co20b7_30",
                        "content": "i faced the same problem bro , maybe we interpreted the question wrong\\n"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "indexed 0 [1,2] is a valid point as it share same x coordinate (1), no other point have it"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "If this is easy, Then I don\\'t know what are med and hard"
                    },
                    {
                        "username": "hniv",
                        "content": "\"If there are multiple, return the valid point with the smallest index\". At testCase 1, my result is 1 and expected 2 but the valid point(s) with manhattan distances are [3, 1, 1]?? So what's smallest index mean?\n"
                    },
                    {
                        "username": "sachinbore",
                        "content": "we have to return the index w.r.to original array(input array)"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "For test case 1: \\npoints = [[1,2],[3,1],[2,4],[2,3],[4,4]]\\nThe valid point(s) with manhattan distances are [3, 1, 1]\\nThe example expected output of index value of 2 is inaccurate as index of 1 can also be a valid answer. "
                    },
                    {
                        "username": "vin36",
                        "content": "Yep, those are the valid points. But of those, we want to return the valid point with the smallest manhattan distance, which is point 2."
                    },
                    {
                        "username": "Vulture59",
                        "content": "HI, this is my solution that failed at testcase 101:\\nIndex 53 and 73 have the same value of [24,27], giving the smallest manhatten distance of 3 when x,y=27,27\\nHowever, my code kept giving the output of index 73 instead of 53. Is anyone able to spot what is wrong with my code?\\n\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n       \\n        dict1={}\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manhat=int(abs(points[i][0]-x)+abs(points[i][1]-y))\\n                dict1[i]=manhat\\n\\n        if dict1:\\n            minmanhat=min(dict1.values())\\n            for k,v in dict1.items():\\n                if v==minmanhat:\\n                    return(k)    \\n        else:\\n            return(-1)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to finding the valid point with the minimum Manhattan distance is correct. However, your approach to finding the smallest index isn\\'t quite right. When you find a minimum Manhattan distance, you\\'re not guaranteed to get the smallest index for it, because dictionaries in Python do not preserve any particular order of keys.\\n\\nTo ensure you get the smallest index, you should iterate over your `dict1` in ascending order of the keys (which represent indices). Here\\'s how you could modify your code:\\n\\n```python\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        dict1 = {}\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                manhat = abs(points[i][0] - x) + abs(points[i][1] - y)\\n                dict1[i] = manhat\\n\\n        if dict1:\\n            minmanhat = min(dict1.values())\\n            # Sort the keys in ascending order before iterating over them\\n            for k in sorted(dict1.keys()):\\n                if dict1[k] == minmanhat:\\n                    return k\\n        else:\\n            return -1\\n```\\n\\nThis version of the code will return the smallest index among those that have the minimum Manhattan distance."
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "In this question I used the brute force approach in the problem, first i have taken three variables in which one variable for the smallest distance and other for result and another current distance now it.....now check the given points are equal in the wheather x or y if it true now calaculate the current distance using manhattan distance...now check the current dis with the  smallestdistance if it true then change the current distance = smallest distance then change the res values in  as the iteration i value for the point where the index is been located...\\natlast return the result that you obtain....\\n\\n\\nJust tried this by approach in which directly check the 2 columns and n rows...\\nnow just try to solve this question daily basis ///// "
                    }
                ]
            },
            {
                "id": 1849703,
                "content": [
                    {
                        "username": "GreenJ84",
                        "content": "x = 1, y = 1\\npoints [[1,2], [3,3], [3,3]]\\n\\nI am getting 1 but Leetcode says it should be 0?\\nBut there is no point that is an exact match? \\n\\nIt is TestCase #44"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Turns out, the question was asking for the index"
                    },
                    {
                        "username": "vvsdnagendraanala_co20b7_30",
                        "content": "i faced the same problem bro , maybe we interpreted the question wrong\\n"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "indexed 0 [1,2] is a valid point as it share same x coordinate (1), no other point have it"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "If this is easy, Then I don\\'t know what are med and hard"
                    },
                    {
                        "username": "hniv",
                        "content": "\"If there are multiple, return the valid point with the smallest index\". At testCase 1, my result is 1 and expected 2 but the valid point(s) with manhattan distances are [3, 1, 1]?? So what's smallest index mean?\n"
                    },
                    {
                        "username": "sachinbore",
                        "content": "we have to return the index w.r.to original array(input array)"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "For test case 1: \\npoints = [[1,2],[3,1],[2,4],[2,3],[4,4]]\\nThe valid point(s) with manhattan distances are [3, 1, 1]\\nThe example expected output of index value of 2 is inaccurate as index of 1 can also be a valid answer. "
                    },
                    {
                        "username": "vin36",
                        "content": "Yep, those are the valid points. But of those, we want to return the valid point with the smallest manhattan distance, which is point 2."
                    },
                    {
                        "username": "Vulture59",
                        "content": "HI, this is my solution that failed at testcase 101:\\nIndex 53 and 73 have the same value of [24,27], giving the smallest manhatten distance of 3 when x,y=27,27\\nHowever, my code kept giving the output of index 73 instead of 53. Is anyone able to spot what is wrong with my code?\\n\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n       \\n        dict1={}\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manhat=int(abs(points[i][0]-x)+abs(points[i][1]-y))\\n                dict1[i]=manhat\\n\\n        if dict1:\\n            minmanhat=min(dict1.values())\\n            for k,v in dict1.items():\\n                if v==minmanhat:\\n                    return(k)    \\n        else:\\n            return(-1)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to finding the valid point with the minimum Manhattan distance is correct. However, your approach to finding the smallest index isn\\'t quite right. When you find a minimum Manhattan distance, you\\'re not guaranteed to get the smallest index for it, because dictionaries in Python do not preserve any particular order of keys.\\n\\nTo ensure you get the smallest index, you should iterate over your `dict1` in ascending order of the keys (which represent indices). Here\\'s how you could modify your code:\\n\\n```python\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        dict1 = {}\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                manhat = abs(points[i][0] - x) + abs(points[i][1] - y)\\n                dict1[i] = manhat\\n\\n        if dict1:\\n            minmanhat = min(dict1.values())\\n            # Sort the keys in ascending order before iterating over them\\n            for k in sorted(dict1.keys()):\\n                if dict1[k] == minmanhat:\\n                    return k\\n        else:\\n            return -1\\n```\\n\\nThis version of the code will return the smallest index among those that have the minimum Manhattan distance."
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "In this question I used the brute force approach in the problem, first i have taken three variables in which one variable for the smallest distance and other for result and another current distance now it.....now check the given points are equal in the wheather x or y if it true now calaculate the current distance using manhattan distance...now check the current dis with the  smallestdistance if it true then change the current distance = smallest distance then change the res values in  as the iteration i value for the point where the index is been located...\\natlast return the result that you obtain....\\n\\n\\nJust tried this by approach in which directly check the 2 columns and n rows...\\nnow just try to solve this question daily basis ///// "
                    }
                ]
            },
            {
                "id": 1721516,
                "content": [
                    {
                        "username": "GreenJ84",
                        "content": "x = 1, y = 1\\npoints [[1,2], [3,3], [3,3]]\\n\\nI am getting 1 but Leetcode says it should be 0?\\nBut there is no point that is an exact match? \\n\\nIt is TestCase #44"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Turns out, the question was asking for the index"
                    },
                    {
                        "username": "vvsdnagendraanala_co20b7_30",
                        "content": "i faced the same problem bro , maybe we interpreted the question wrong\\n"
                    },
                    {
                        "username": "vaibhbisht95",
                        "content": "indexed 0 [1,2] is a valid point as it share same x coordinate (1), no other point have it"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "If this is easy, Then I don\\'t know what are med and hard"
                    },
                    {
                        "username": "hniv",
                        "content": "\"If there are multiple, return the valid point with the smallest index\". At testCase 1, my result is 1 and expected 2 but the valid point(s) with manhattan distances are [3, 1, 1]?? So what's smallest index mean?\n"
                    },
                    {
                        "username": "sachinbore",
                        "content": "we have to return the index w.r.to original array(input array)"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "For test case 1: \\npoints = [[1,2],[3,1],[2,4],[2,3],[4,4]]\\nThe valid point(s) with manhattan distances are [3, 1, 1]\\nThe example expected output of index value of 2 is inaccurate as index of 1 can also be a valid answer. "
                    },
                    {
                        "username": "vin36",
                        "content": "Yep, those are the valid points. But of those, we want to return the valid point with the smallest manhattan distance, which is point 2."
                    },
                    {
                        "username": "Vulture59",
                        "content": "HI, this is my solution that failed at testcase 101:\\nIndex 53 and 73 have the same value of [24,27], giving the smallest manhatten distance of 3 when x,y=27,27\\nHowever, my code kept giving the output of index 73 instead of 53. Is anyone able to spot what is wrong with my code?\\n\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n       \\n        dict1={}\\n        for i in range(len(points)):\\n            if points[i][0]==x or points[i][1]==y:\\n                manhat=int(abs(points[i][0]-x)+abs(points[i][1]-y))\\n                dict1[i]=manhat\\n\\n        if dict1:\\n            minmanhat=min(dict1.values())\\n            for k,v in dict1.items():\\n                if v==minmanhat:\\n                    return(k)    \\n        else:\\n            return(-1)\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to finding the valid point with the minimum Manhattan distance is correct. However, your approach to finding the smallest index isn\\'t quite right. When you find a minimum Manhattan distance, you\\'re not guaranteed to get the smallest index for it, because dictionaries in Python do not preserve any particular order of keys.\\n\\nTo ensure you get the smallest index, you should iterate over your `dict1` in ascending order of the keys (which represent indices). Here\\'s how you could modify your code:\\n\\n```python\\nclass Solution(object):\\n    def nearestValidPoint(self, x, y, points):\\n        dict1 = {}\\n        for i in range(len(points)):\\n            if points[i][0] == x or points[i][1] == y:\\n                manhat = abs(points[i][0] - x) + abs(points[i][1] - y)\\n                dict1[i] = manhat\\n\\n        if dict1:\\n            minmanhat = min(dict1.values())\\n            # Sort the keys in ascending order before iterating over them\\n            for k in sorted(dict1.keys()):\\n                if dict1[k] == minmanhat:\\n                    return k\\n        else:\\n            return -1\\n```\\n\\nThis version of the code will return the smallest index among those that have the minimum Manhattan distance."
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "In this question I used the brute force approach in the problem, first i have taken three variables in which one variable for the smallest distance and other for result and another current distance now it.....now check the given points are equal in the wheather x or y if it true now calaculate the current distance using manhattan distance...now check the current dis with the  smallestdistance if it true then change the current distance = smallest distance then change the res values in  as the iteration i value for the point where the index is been located...\\natlast return the result that you obtain....\\n\\n\\nJust tried this by approach in which directly check the 2 columns and n rows...\\nnow just try to solve this question daily basis ///// "
                    }
                ]
            }
        ]
    }
]