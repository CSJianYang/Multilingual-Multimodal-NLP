[
    {
        "title": "Design Phone Directory",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565140,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1566087,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572549,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572777,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572074,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571649,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571650,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571651,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571953,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1986263,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1565140,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1566087,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572549,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572777,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572074,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571649,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571650,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571651,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571953,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1986263,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            }
        ]
    },
    {
        "title": "Transform to Chessboard",
        "question_content": "<p>You are given an <code>n x n</code> binary grid <code>board</code>. In each move, you can swap any two rows with each other, or any two columns with each other.</p>\n\n<p>Return <em>the minimum number of moves to transform the board into a <strong>chessboard board</strong></em>. If the task is impossible, return <code>-1</code>.</p>\n\n<p>A <strong>chessboard board</strong> is a board where no <code>0</code>&#39;s and no <code>1</code>&#39;s are 4-directionally adjacent.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg\" style=\"width: 500px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> board = [[0,1],[1,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Also note that the board with 0 in the top left corner, is also a valid chessboard.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> board = [[1,0],[1,0]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> No matter what sequence of moves you make, you cannot end with a valid chessboard.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>board[i][j]</code> is either&nbsp;<code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 114847,
                "title": "c-java-python-solution-with-explanation",
                "content": "# **Intuition**:\\nTwo conditions to help solve this problem:\\n1. In a valid chess board, there are 2 and only 2 kinds of rows and one is inverse to the other.\\nFor example if there is a row 01010011 in the board, any other row must be either 01010011 or 10101100.\\nThe same for columns\\nA corollary is that, any rectangle inside the board with corners top left, top right, bottom left, bottom right must be 4 zeros or 2 ones 2 zeros or 4 zeros.\\n\\n2. Another important property is that every row and column has half ones. Assume the board is ```N * N```:\\nIf ```N = 2*K```, every row and every column has K ones and K zeros.\\nIf ```N = 2*K + 1```, every row and every column has K ones and K + 1 zeros or K + 1 ones and K zeros.\\n<br>\\n\\n# **Explanation**:\\n**Since the swap process does not break this property, for a given board to be valid, this property must hold.\\nThese two conditions are necessary and sufficient condition for a valid chessboard.**\\n\\nOnce we know it is  a valid cheese board, we start to count swaps.\\nBasic on the property above, when we arange the first row, we are actually moving all columns.\\n\\nI try to arrange one row into ```01010``` and ```10101``` and I count the number of swaps.\\n1. In case of N even, I take the minimum swaps, because both are possible.\\n2. In case of N odd, I take the even swaps.\\nBecause when we make a swap, we move 2 columns or 2 rows at the same time.\\nSo col swaps and row swaps should be same here.\\n<br>\\n\\n# **Time Complexity**:\\n`O(N^2)` to check the whole board.\\n\\n<br>\\n\\n**C++**\\n```cpp\\n    int movesToChessboard(vector<vector<int>>& b) {\\n        int N = b.size(), rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if (b[0][0]^b[i][0]^b[0][j]^b[i][j]) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            rowSwap += b[i][0] == i % 2;\\n            colSwap += b[0][i] == i % 2;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2) {\\n            if (colSwap % 2) colSwap = N - colSwap;\\n            if (rowSwap % 2) rowSwap = N - rowSwap;\\n        }\\n        else {\\n            colSwap = min(N - colSwap, colSwap);\\n            rowSwap = min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int movesToChessboard(int[][] b) {\\n        int N = b.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 1) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            if (b[i][0] == i % 2) rowSwap ++;\\n            if (b[0][i] == i % 2) colSwap ++ ;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def movesToChessboard(self, b):\\n        N = len(b)\\n        if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1\\n        if not N / 2 <= sum(b[0]) <= (N + 1) / 2: return -1\\n        if not N / 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) / 2: return -1\\n        col = sum(b[0][i] == i % 2 for i in range(N))\\n        row = sum(b[i][0] == i % 2 for i in range(N))\\n        if N % 2:\\n            if col % 2: col = N - col\\n            if row % 2: row = N - row\\n        else:\\n            col = min(N - col, col)\\n            row = min(N - row, row)\\n        return (col + row) / 2\\n```\\n\\n# **Update**\\n**Q: why just check the first row and col?**\\nA: We have checked that  ```b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 0``` for all `i` and `j`.\\nSo if we well arrange the first row and the first col, all board will be well set up.\\n\\n",
                "solutionTags": [],
                "code": "```N * N```\n```N = 2*K```\n```N = 2*K + 1```\n```01010```\n```10101```\n```cpp\\n    int movesToChessboard(vector<vector<int>>& b) {\\n        int N = b.size(), rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if (b[0][0]^b[i][0]^b[0][j]^b[i][j]) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            rowSwap += b[i][0] == i % 2;\\n            colSwap += b[0][i] == i % 2;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2) {\\n            if (colSwap % 2) colSwap = N - colSwap;\\n            if (rowSwap % 2) rowSwap = N - rowSwap;\\n        }\\n        else {\\n            colSwap = min(N - colSwap, colSwap);\\n            rowSwap = min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\n```java\\n    public int movesToChessboard(int[][] b) {\\n        int N = b.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 1) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            if (b[i][0] == i % 2) rowSwap ++;\\n            if (b[0][i] == i % 2) colSwap ++ ;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\n```py\\n    def movesToChessboard(self, b):\\n        N = len(b)\\n        if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1\\n        if not N / 2 <= sum(b[0]) <= (N + 1) / 2: return -1\\n        if not N / 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) / 2: return -1\\n        col = sum(b[0][i] == i % 2 for i in range(N))\\n        row = sum(b[i][0] == i % 2 for i in range(N))\\n        if N % 2:\\n            if col % 2: col = N - col\\n            if row % 2: row = N - row\\n        else:\\n            col = min(N - col, col)\\n            row = min(N - row, row)\\n        return (col + row) / 2\\n```\n```b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 0```",
                "codeTag": "Python3"
            },
            {
                "id": 440085,
                "title": "python-detailed-explanation",
                "content": "How to check impossible board?\\n1. Each row in the board must either equal to the first row or equal to the reverse of the first row. \\nThe same apply to column, but you don\\'t need to check column, because if all rows complies with this rule, all columns automatically comply with this rule by themselves. Only need to check rows.\\n2. Count of \"1\" in each row must equal to the count of \"0\", or at most differ by 1.\\nSince rule #1 is already passed, you don\\'t need to check every row this time. Checking only the 1st row is enough. But you need to check both 1st row and 1st column in this case. Can\\'t skip column this time\\n\\nWhen both #1 and #2 passed, it means the board can be tranformed to chessboard.\\n\\nHow to count number of swaps to transform?\\nOnly need to count 1st row and 1st column. When the 1st row and 1st column becomes valid, the rest must be valid by themselves according to rule #1.\\n\\nTaking 1st row for example.\\n1. We don\\'t know whether the first cell should be \"0\" or \"1\". Assume it to be \"0\" first, then we know the expected values of all cells in 1st row. \\n2. Count the difference against actual values. The number of swap should be diffCnt/2. If the diffCnt is an odd number, that means the first cell cannot be \"0\", we should choose \"1\" as the first cell. \\n3. If both choosing \"0\" and choosing \"1\" makes even diffCount, then we choose the one with smallest number of swaps.\\n\\nSame applies to column.\\n\\n```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n=len(board)\\n        if n<=1:\\n            return 0\\n        rows=[\\'\\'.join(str(c) for c in r) for r in board]\\n        counter=collections.Counter(rows)\\n        keys=list(counter)\\n        if len(keys)!=2 or abs(counter[keys[0]]-counter[keys[1]])>1 \\\\\\n            or abs(keys[0].count(\\'1\\')-keys[0].count(\\'0\\'))>1 \\\\\\n            or any(a==b for a,b in zip(*keys)):\\n            return -1\\n        rowdiff=sum(board[0][i]!=(i%2) for i in range(n))\\n        coldiff=sum(board[i][0]!=(i%2) for i in range(n))\\n        rowdiff=n-rowdiff if rowdiff%2!=0 or (n%2==0 and (n-rowdiff)<rowdiff) else rowdiff\\n        coldiff=n-coldiff if coldiff%2!=0 or (n%2==0 and (n-coldiff)<coldiff) else coldiff\\n        return (rowdiff+coldiff)//2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n=len(board)\\n        if n<=1:\\n            return 0\\n        rows=[\\'\\'.join(str(c) for c in r) for r in board]\\n        counter=collections.Counter(rows)\\n        keys=list(counter)\\n        if len(keys)!=2 or abs(counter[keys[0]]-counter[keys[1]])>1 \\\\\\n            or abs(keys[0].count(\\'1\\')-keys[0].count(\\'0\\'))>1 \\\\\\n            or any(a==b for a,b in zip(*keys)):\\n            return -1\\n        rowdiff=sum(board[0][i]!=(i%2) for i in range(n))\\n        coldiff=sum(board[i][0]!=(i%2) for i in range(n))\\n        rowdiff=n-rowdiff if rowdiff%2!=0 or (n%2==0 and (n-rowdiff)<rowdiff) else rowdiff\\n        coldiff=n-coldiff if coldiff%2!=0 or (n%2==0 and (n-coldiff)<coldiff) else coldiff\\n        return (rowdiff+coldiff)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487265,
                "title": "c-solution-with-image-explanation",
                "content": "## Logic of how check if it a valid board \\nTo understand if a board can be a chess board (so if it is valid) we can think in opposite way (so from the chess board and get the rules that a chess board **must have.**\\n![image](https://assets.leetcode.com/users/images/5b838b6e-ea82-44a7-8ff1-acd7f23b9718_1632656534.7237418.png)\\nThis is our chess board and let we focus on the first row and ignore others (image that other cell just follow the first row).\\n![image](https://assets.leetcode.com/users/images/68d4a9de-d75d-4df2-be84-c4aebab3f0c7_1632656753.9395897.png)\\nYou can notice that however we move these cells (when we move some cells we move the entire column but for now we don\\'t need to care about them) we will always have 2 cells with value `1` and 2 cells with value `0`, \\n![image](https://assets.leetcode.com/users/images/2f08ec3f-5527-4666-8a78-e496149854b9_1632659688.6498613.png)\\nNow we come back to the entire board and we notice that ***cells below the first row*** (so columns) form 2 particular pattern (one equal to the first column and another one completely opposite than first column). So ,from these points we can get the **rules that a chess board has**:\\n1. **Half of columns have the first pattern and rest have the second pattern**\\n\\t* with an exception which is when the board size is equal to an odd number, with this exception **patter1 - patter2 = 1 or -1** (in this case we have 3 column with the first patter and 2 second patter with the second pattern) \\t![image](https://assets.leetcode.com/users/images/9cbbc655-cb79-413a-bd76-7273745171ad_1632660098.1226494.png)\\n2.  A chess board has only 2 patterns of column \\n\\t* \\t**first** one equal to the first column \\n\\t* \\t**second** one completely opposite to the first column\\n\\n\\t\\nThese rules are the same for rows (just rotate the  board and apply the same concept)\\n\\n##### E.g. of a valid board (board that can be a chess board)\\n![image](https://assets.leetcode.com/users/images/8fa75f0c-1da2-4e35-9e7f-9d4789c13fa1_1632660630.5611103.png)    ![image](https://assets.leetcode.com/users/images/c3d10798-6ce3-4646-939a-45e9f1f4bb90_1632661250.8243213.png)\\nThis is valid because if we look column by column we notice that:\\n*  we have only 2 patters (respect the second rule).\\n* `N. of pattern1 = 2` `N. of patter2 = 3` (the size of the board is an odd number so `pattern1- pattern2 = -1` and this respect the first rule)\\n* When we rotate it and apply the same concept we notice that it is still valid.\\n\\n\\n##### E.g. of a invalid board (board that cannot be a chess board)\\n![image](https://assets.leetcode.com/users/images/68174b13-d9a8-4507-9cb2-aba398fe7d8e_1632661481.7332106.png)\\nThis is invalid because it has 3 pattern (break the first rule)\\n![image](https://assets.leetcode.com/users/images/48f2373b-8262-4eb9-ba72-55f13a06a4b7_1632661519.8630002.png)\\nThis is invalid because `pattern1 = 3` `pattern2=1` (breaks the second rule)\\n![image](https://assets.leetcode.com/users/images/fe37d18a-40b1-4661-b825-f8eff7f341da_1632661668.0624645.png)  ![image](https://assets.leetcode.com/users/images/bcfe9dfc-9f21-46f3-9f17-54a1eff06336_1632661776.4221716.png)\\nThis is invalid because when we rotate it it breaks the first rule\\n\\n## Calculate how many steps we need to do to get the chess board\\n* Scan the board(horizontally and vertically\\n* Image that the board start from 0\\n![image](https://assets.leetcode.com/users/images/cbae526e-fafd-4f42-9c99-b953d3bfa4bc_1632662244.432529.png)\\n* check if first cell is equal to 0 (in this case it isn\\'t so countRow and countCol +1)\\n![image](https://assets.leetcode.com/users/images/cf8d3d29-52ae-4c97-9f55-d1671671bd62_1632662357.1091745.png)\\n* check next ones, now should be `1` (in this case countCor +1 )\\n![image](https://assets.leetcode.com/users/images/9f19e8b2-0f18-4907-ac05-88177f3411f1_1632662457.0507386.png)\\n* Check next ones, now should be `0` (in this case  countRow +1)\\n* and so on,\\n* Do the same thing imaging that the board start from 1 (there is a faster way to find out that which is `countRow2 = n - countRow`  `countCol2 = n - countCol` \\n* if `countRow` or `countRow2` is an odd number choose the another one (it will be even) because if `countRow` or `countRow2` is odd means that it can\\'t be a chess board however you move (because each step you move 2 rows or 2 columns and if `countRow` is odd means that it will be a column that you can\\'t move)\\n* same for `countCol` and `countCol2`\\n* `result = (min(countRow,countRow2) + min(countCol,countCol2) ) /2 ` divided by 2 because each step you move 2 columns/rows\\n\\n```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        \\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n\\t\\t//Secon rule\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n        //count how many columns we have for type1(column equal to the first column) and type2(column that have each cell different than the first column)\\n        int countCol_type1 = 1; //this is equal to 1 because we already count the first column\\n        int countCol_type2 =0;\\n\\n        //count how many rows we have for type1(rows equal to the first row) and type2(rows that have each cell different than the first row)\\n        int countRow_type1 = 1; //this is equal to 1 because we already count the first row\\n        int countRow_type2 = 0;\\n\\n        //check if the board is a valid board (by valid I mean that it can be a chess board. Scroll above to know the how to know if it\\'s valid)\\n        for (int j = 1; j < n; j++) {\\n\\n            //check horizontaly (each columns of the horizontal lane)\\n            if (board[0][j] == board[0][0]) {\\n                countCol_type1++;\\n\\n                //check if all cell of the j column is equal to the first column (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[i][j] != board[i][0])return -1;\\n                }\\n            }\\n            else {\\n                countCol_type2++;\\n\\n                //check if all cell of the j column is different to the first column (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[i][j] == board[i][0])return -1;\\n                }\\n            }\\n\\n            //check vertically (each rows of the vertical lane)\\n            if (board[j][0] == board[0][0]) {\\n                countRow_type1++;\\n\\n                //check if all cell of the j row is equal to the first row (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[j][i] != board[0][i])return -1;\\n                }\\n            }\\n            else {\\n                countRow_type2++;\\n\\n                //check if all cell of the j row is different to the first row (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[j][i] == board[0][i])return -1;\\n                }\\n            }\\n        }\\n\\n\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n\\t\\t//first rule\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n        //we have to make sure that n. of type1 is equal to type2 of only with 1 of difference (when n = odd number)\\n        //if it isn\\'t means that the board is invalid) \\n        if (abs(countCol_type1 - countCol_type2) > 1) return -1;    // if type1 - type2 != -1,0,1 then return -1\\n        if (abs(countRow_type1 - countRow_type2) > 1) return -1;\\n\\t\\t\\n\\t\\t\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n\\t\\t//Calculate how many steps we need to do to get the chess board\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n        int countRow = 0;\\n        int countCol = 0;\\n        //count how many moves need to make the board as a chessboard that start with 0 \\n        for (int j = 0; j < n; j++) {\\n            if (board[0][j] != j % 2)countCol++;\\n            if (board[j][0] != j % 2)countRow++;\\n        }\\n\\n        //count how many moves need to make the board as a chessboard (horizontally) that start with 1 \\n        int countRow2 = n - countRow;\\n        int countCol2 = n - countCol;\\n\\n        int res = 0;\\n        //if countRow2 is an odd number return countRow/2\\n        if (countRow2 % 2)res+= countRow / 2;\\n        //if countRow is an odd number return countRow2/2\\n        else if (countRow % 2)res+= countRow2 / 2;\\n        //if countRow and countRow2 are even numbers return the smaller one\\n        else res += min(countRow, countRow2) / 2;\\n\\n        //if countCol2 is an odd number return countCol/2\\n        if (countCol2 % 2)res += countCol / 2;\\n        //if countCol is an odd number return countCol2/2\\n        else if (countCol % 2)res += countCol2 / 2;\\n        //if countCol and countCol2 are even numbers return the smaller one\\n        else res += min(countCol, countCol2) / 2;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        \\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n\\t\\t//Secon rule\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n        //count how many columns we have for type1(column equal to the first column) and type2(column that have each cell different than the first column)\\n        int countCol_type1 = 1; //this is equal to 1 because we already count the first column\\n        int countCol_type2 =0;\\n\\n        //count how many rows we have for type1(rows equal to the first row) and type2(rows that have each cell different than the first row)\\n        int countRow_type1 = 1; //this is equal to 1 because we already count the first row\\n        int countRow_type2 = 0;\\n\\n        //check if the board is a valid board (by valid I mean that it can be a chess board. Scroll above to know the how to know if it\\'s valid)\\n        for (int j = 1; j < n; j++) {\\n\\n            //check horizontaly (each columns of the horizontal lane)\\n            if (board[0][j] == board[0][0]) {\\n                countCol_type1++;\\n\\n                //check if all cell of the j column is equal to the first column (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[i][j] != board[i][0])return -1;\\n                }\\n            }\\n            else {\\n                countCol_type2++;\\n\\n                //check if all cell of the j column is different to the first column (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[i][j] == board[i][0])return -1;\\n                }\\n            }\\n\\n            //check vertically (each rows of the vertical lane)\\n            if (board[j][0] == board[0][0]) {\\n                countRow_type1++;\\n\\n                //check if all cell of the j row is equal to the first row (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[j][i] != board[0][i])return -1;\\n                }\\n            }\\n            else {\\n                countRow_type2++;\\n\\n                //check if all cell of the j row is different to the first row (if not means that it is a invalid board, so return -1)\\n                for (int i = 1; i < n; i++) {\\n                    if (board[j][i] == board[0][i])return -1;\\n                }\\n            }\\n        }\\n\\n\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n\\t\\t//first rule\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n        //we have to make sure that n. of type1 is equal to type2 of only with 1 of difference (when n = odd number)\\n        //if it isn\\'t means that the board is invalid) \\n        if (abs(countCol_type1 - countCol_type2) > 1) return -1;    // if type1 - type2 != -1,0,1 then return -1\\n        if (abs(countRow_type1 - countRow_type2) > 1) return -1;\\n\\t\\t\\n\\t\\t\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n\\t\\t//Calculate how many steps we need to do to get the chess board\\n\\t\\t//////////////////////////////////////////////////////////////////////////////\\n        int countRow = 0;\\n        int countCol = 0;\\n        //count how many moves need to make the board as a chessboard that start with 0 \\n        for (int j = 0; j < n; j++) {\\n            if (board[0][j] != j % 2)countCol++;\\n            if (board[j][0] != j % 2)countRow++;\\n        }\\n\\n        //count how many moves need to make the board as a chessboard (horizontally) that start with 1 \\n        int countRow2 = n - countRow;\\n        int countCol2 = n - countCol;\\n\\n        int res = 0;\\n        //if countRow2 is an odd number return countRow/2\\n        if (countRow2 % 2)res+= countRow / 2;\\n        //if countRow is an odd number return countRow2/2\\n        else if (countRow % 2)res+= countRow2 / 2;\\n        //if countRow and countRow2 are even numbers return the smaller one\\n        else res += min(countRow, countRow2) / 2;\\n\\n        //if countCol2 is an odd number return countCol/2\\n        if (countCol2 % 2)res += countCol / 2;\\n        //if countCol is an odd number return countCol2/2\\n        else if (countCol % 2)res += countCol2 / 2;\\n        //if countCol and countCol2 are even numbers return the smaller one\\n        else res += min(countCol, countCol2) / 2;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132113,
                "title": "java-clear-code-with-detailed-explanations",
                "content": "Thanks @lee215 for the original post.\\n\\nMy thinking process :\\n* How do we check if it is possible to transform the board into the chessboard?\\n1. Only 2 kinds of rows + one  should be inverse to the other, e.g., one is 0110, another one is 0110 or 1001\\n2. Assume the board N * N,\\nif N is even, rowOneCnt = N / 2, colOneCnt  = N / 2.\\nif N is odd, rowOneCnt = N / 2, colOneCnt = N / 2 + 1 or rowOneCnt = N / 2 + 1, colOneCnt = N / 2\\n* How do we count the swaps if it is possible to transform the board into the chessboard?\\nWe count colToMove and rowToMove, (colToMove + rowToMove) / 2 will be the number of swaps in total for **each swap will move either two columns or two rows**.\\n* How do we count colToMove and rowToMove?\\n1. if elements on top edge or left edge == i % 2, they need to be changed\\n2. we can change either colToMove or N - colToMove, similarly, either rowToMove or N - rowToMove\\nif N is even, choose the smaller one\\nif N is odd, we must choose the even one between ToMove or N - ToMove, for **each swap will move either two columns or two rows** \\n\\nThe complete code is as below :\\n```\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, colToMove = 0, rowToMove = 0, rowOneCnt = 0, colOneCnt = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < N; i++) {\\n            rowOneCnt += board[0][i];\\n            colOneCnt += board[i][0];\\n            if (board[i][0] == i % 2) {\\n                rowToMove++;\\n            }\\n            if (board[0][i] == i % 2) {\\n                colToMove++;\\n            }\\n        }\\n        if (rowOneCnt < N / 2 || rowOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (colOneCnt < N / 2 || colOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (N % 2 == 1) {\\n            // we cannot make it when ..ToMove is odd\\n            if (colToMove % 2 == 1) {\\n                colToMove = N - colToMove;\\n            }\\n            if (rowToMove % 2 == 1) {\\n                rowToMove = N - rowToMove;\\n            }\\n        } else {\\n            colToMove = Math.min(colToMove, N - colToMove);\\n            rowToMove = Math.min(rowToMove, N - rowToMove);\\n        }\\n        return (colToMove + rowToMove) / 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, colToMove = 0, rowToMove = 0, rowOneCnt = 0, colOneCnt = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < N; i++) {\\n            rowOneCnt += board[0][i];\\n            colOneCnt += board[i][0];\\n            if (board[i][0] == i % 2) {\\n                rowToMove++;\\n            }\\n            if (board[0][i] == i % 2) {\\n                colToMove++;\\n            }\\n        }\\n        if (rowOneCnt < N / 2 || rowOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (colOneCnt < N / 2 || colOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (N % 2 == 1) {\\n            // we cannot make it when ..ToMove is odd\\n            if (colToMove % 2 == 1) {\\n                colToMove = N - colToMove;\\n            }\\n            if (rowToMove % 2 == 1) {\\n                rowToMove = N - rowToMove;\\n            }\\n        } else {\\n            colToMove = Math.min(colToMove, N - colToMove);\\n            rowToMove = Math.min(rowToMove, N - rowToMove);\\n        }\\n        return (colToMove + rowToMove) / 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486782,
                "title": "python-math-solution-explained",
                "content": "We can find some invariants of our board:\\n\\n1. There will be `2` unique types of row and if `n` is even, there should be `n/2` of each type; if `n` is odd, there should be `(n+1)//2` and `(n-1)//2`.\\n2. The same is for columns.\\n3. Number of `1` in all board should be `n*n//2` if `n` is even and `(n*n +- 1)//2` if n is odd. \\n\\nIt can be shown, that these two conditions are sufficient and enough. Then for the first row, if `n` is odd, we have one option: `10101...01` we need to transform to, if `n` is even, there are two options: `1010...10` and `0101...01` we need to check. The same is for columns.\\n\\nLine `x1 = sum(i == j for i, j in zip(Cnt_r[0][0], patt1))` will check how many not equal elements we have between our pattern and one of our two types of columns, similar logic is for `patt2`. Then we have two options: try to make it `patt1` or `patt2`. Sometimes it is not possble to converge to one of them: in fact we can converge only if number of not equal elements is `even`, because on each step we can reduct number of not-equal elements by `2`. Imagine example `1000001111` which we try to make equal to `1010101010`. Then we enough to make only `2` steps to transform one to another!\\n\\n#### Complexity\\nFinal time complexity is `O(n^2)`, space is also `O(n^2)`, because I keep transposed grid and count rows and columns.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        patt1 = ([0, 1]*(n//2+1))[:n]\\n        patt2 = ([1, 0]*(n//2+1))[:n]\\n        \\n        board_t = map(list, zip(*board))\\n        Cnt_r = list(Counter(tuple(row) for row in board).items())\\n        Cnt_c = list(Counter(tuple(row) for row in board_t).items())\\n        if len(Cnt_r) != 2 or len(Cnt_c) != 2: return -1\\n        if abs(sum(map(sum, board)) * 2 - n*n) > 1: return -1\\n        if abs(Cnt_r[0][1] - Cnt_r[1][1]) > 1: return -1\\n        if abs(Cnt_c[0][1] - Cnt_c[1][1]) > 1: return -1\\n        \\n        x1 = sum(i != j for i,j in zip(Cnt_r[0][0], patt1))\\n        y1 = sum(i != j for i,j in zip(Cnt_c[0][0], patt1))\\n        \\n        x2 = sum(i != j for i,j in zip(Cnt_r[0][0], patt2))\\n        y2 = sum(i != j for i,j in zip(Cnt_c[0][0], patt2))\\n        \\n        cands_x = [x for x in [x1, x2] if x % 2 == 0]\\n        cands_y = [y for y in [y1, y2] if y % 2 == 0]\\n        \\n        return min(cands_x)//2 + min(cands_y)//2\\n```\\n\\n#### Remark\\nWe can also notice, that all feasible boards will have the following property:\\n1. If `n` is even, first column and row should have `n//2` ones, if `n` is odd, both of them should have `(n+1)//2` or `(n-1)//2` ones.\\n2. For each rectangle with sides parallel to grid, it has even number of zeroes: it means that all elements uniquely defined by first column and first row.",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        patt1 = ([0, 1]*(n//2+1))[:n]\\n        patt2 = ([1, 0]*(n//2+1))[:n]\\n        \\n        board_t = map(list, zip(*board))\\n        Cnt_r = list(Counter(tuple(row) for row in board).items())\\n        Cnt_c = list(Counter(tuple(row) for row in board_t).items())\\n        if len(Cnt_r) != 2 or len(Cnt_c) != 2: return -1\\n        if abs(sum(map(sum, board)) * 2 - n*n) > 1: return -1\\n        if abs(Cnt_r[0][1] - Cnt_r[1][1]) > 1: return -1\\n        if abs(Cnt_c[0][1] - Cnt_c[1][1]) > 1: return -1\\n        \\n        x1 = sum(i != j for i,j in zip(Cnt_r[0][0], patt1))\\n        y1 = sum(i != j for i,j in zip(Cnt_c[0][0], patt1))\\n        \\n        x2 = sum(i != j for i,j in zip(Cnt_r[0][0], patt2))\\n        y2 = sum(i != j for i,j in zip(Cnt_c[0][0], patt2))\\n        \\n        cands_x = [x for x in [x1, x2] if x % 2 == 0]\\n        cands_y = [y for y in [y1, y2] if y % 2 == 0]\\n        \\n        return min(cands_x)//2 + min(cands_y)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234984,
                "title": "c-solution-with-very-detailed-comments-especially-the-swap-counting-part",
                "content": "Inspired by [this](https://leetcode.com/problems/transform-to-chessboard/discuss/114847/Easy-and-Concise-Solution-with-Explanation-C%2B%2BJavaPython) and [this](https://leetcode.com/problems/transform-to-chessboard/discuss/132113/Java-Clear-Code-with-Detailed-Explanations) posts, but use a different approach to count swap number, IMHO, which is more intuitive.\\n``` C++\\n    int movesToChessboard(vector<vector<int>>& board) {\\n       /**** An Important Fact ****\\n        Take any 2 rows r1 and r2, then take 2 items in the same column c from the 2 rows, e.g. b[r1][c], b[r2][c], \\n        no matter how the rows or columns swap, the relationship between the 2 items never changes:\\n        if they are the same, they will always be the same, if they are inverted, they will always be inverted.\\n        Hence for a chess board, any two rows (or two columns) are either the same, or inverted.\\n        ***************************/\\n        // Hence we have:\\n        // Rule 1. If the board can be transformed to a chess board, for any two rows in the board, the cells between them must be either all the same, \\n        // or all inverted, if some items are inverted and some items are the same, they can\\'t form a chess board by swapping.\\n        // On the other hand:\\n        // Rule 2. The difference of two types of rows/columns cannot > 1, otherwise there must be >= 2 same type of rows/columns arranged together.\\n\\t\\t\\n        // Now, validate our board by these 2 rules.\\n        int n = board.size();\\n        int row_counter = 0, col_counter = 0;\\n        for(int r = 0; r < n; r++){\\n            row_counter += board[r][0] ? 1 : -1;\\n            for(int c = 0; c < n; c++){\\n                if(r == 0) col_counter += board[r][c] ? 1 : -1;\\n                // Check rule 1.\\n                // The relationship of items in current column between current row and first row should be consistent with the relationship of first items between current row and first row (i.e. the 2 pair of items should be either both the same or both inverted). Hence we compare the first cell of current row and first cell of first row, \\nthen compare the current cell with the cell in the cell in the same column in first row, the result should be the same.\\n                // Since XOR operator is associative and commutative, we don\\'t have to verify columns again (i.e. (board[0][c] ^ board[0][0]) ^ (board[r][c] ^ board[r][0]) )\\n                if((board[r][0] ^ board[0][0]) ^ (board[r][c] ^ board[0][c])) return -1; \\n            }\\n        }\\n        \\n        // Check rule 2.\\n        if(abs(row_counter) > 1 || abs(col_counter) > 1) return -1;\\n        \\n        // Count possible swap count, we only need care about the swap count of odd positions, since when we swap, we always swap an odd position with an even position.\\n        int row_swap_count = 0, col_swap_count = 0, row_0_count = 0, col_0_count = 0;\\n        // When n is odd, we need fit the item whose count is larger into even positions because even position is more than odd position.\\n        // E.g. \\n        // 0,1,0,1,1, then 0s must stay on odd positions so that 1s stay on even positions: 1,0,1,0,1.\\n        // 1,0,1,0,0, then 1s must stay on odd positions so that 0s stay on even positions: 0,1,0,1,0.\\n        for(int i = 0; i < n; i++){\\n            if(i & 1){ // When i is odd\\n                // Assume 0 is less and should stay on odd position, so we swap 1 away from odd position.\\n                row_swap_count += board[i][0];\\n                col_swap_count += board[0][i];\\n            }\\n            // Count 0.\\n            row_0_count += board[i][0] == 0, col_0_count += board[0][i] == 0;            \\n        }\\n        \\n        int odd_position_count = n/2; // Odd position count is always less than or equal with even position count.\\n        if(n & 1){ // When n is odd.\\n            // Count of 0 == odd_position_count means 0 is less, so we\\'re right on swapping 1 away, the current swap count is correct. \\n\\t\\t\\t// Otherwise we should keep 1 on the odd position and swap 0 away, so the swap count becomes odd_position_count - row_swap_count.\\n            row_swap_count = row_0_count == odd_position_count ? row_swap_count : (odd_position_count - row_swap_count);\\n            col_swap_count = col_0_count == odd_position_count ? col_swap_count : (odd_position_count - col_swap_count);\\n        }\\n        else{\\n            // If n is even, odd position\\'s count is the same with even position\\'s count, choose whichever swap count is smaller.\\n            row_swap_count = min(row_swap_count, odd_position_count - row_swap_count);\\n            col_swap_count = min(col_swap_count, odd_position_count - col_swap_count);            \\n        }\\n        \\n        return row_swap_count + col_swap_count;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` C++\\n    int movesToChessboard(vector<vector<int>>& board) {\\n       /**** An Important Fact ****\\n        Take any 2 rows r1 and r2, then take 2 items in the same column c from the 2 rows, e.g. b[r1][c], b[r2][c], \\n        no matter how the rows or columns swap, the relationship between the 2 items never changes:\\n        if they are the same, they will always be the same, if they are inverted, they will always be inverted.\\n        Hence for a chess board, any two rows (or two columns) are either the same, or inverted.\\n        ***************************/\\n        // Hence we have:\\n        // Rule 1. If the board can be transformed to a chess board, for any two rows in the board, the cells between them must be either all the same, \\n        // or all inverted, if some items are inverted and some items are the same, they can\\'t form a chess board by swapping.\\n        // On the other hand:\\n        // Rule 2. The difference of two types of rows/columns cannot > 1, otherwise there must be >= 2 same type of rows/columns arranged together.\\n\\t\\t\\n        // Now, validate our board by these 2 rules.\\n        int n = board.size();\\n        int row_counter = 0, col_counter = 0;\\n        for(int r = 0; r < n; r++){\\n            row_counter += board[r][0] ? 1 : -1;\\n            for(int c = 0; c < n; c++){\\n                if(r == 0) col_counter += board[r][c] ? 1 : -1;\\n                // Check rule 1.\\n                // The relationship of items in current column between current row and first row should be consistent with the relationship of first items between current row and first row (i.e. the 2 pair of items should be either both the same or both inverted). Hence we compare the first cell of current row and first cell of first row, \\nthen compare the current cell with the cell in the cell in the same column in first row, the result should be the same.\\n                // Since XOR operator is associative and commutative, we don\\'t have to verify columns again (i.e. (board[0][c] ^ board[0][0]) ^ (board[r][c] ^ board[r][0]) )\\n                if((board[r][0] ^ board[0][0]) ^ (board[r][c] ^ board[0][c])) return -1; \\n            }\\n        }\\n        \\n        // Check rule 2.\\n        if(abs(row_counter) > 1 || abs(col_counter) > 1) return -1;\\n        \\n        // Count possible swap count, we only need care about the swap count of odd positions, since when we swap, we always swap an odd position with an even position.\\n        int row_swap_count = 0, col_swap_count = 0, row_0_count = 0, col_0_count = 0;\\n        // When n is odd, we need fit the item whose count is larger into even positions because even position is more than odd position.\\n        // E.g. \\n        // 0,1,0,1,1, then 0s must stay on odd positions so that 1s stay on even positions: 1,0,1,0,1.\\n        // 1,0,1,0,0, then 1s must stay on odd positions so that 0s stay on even positions: 0,1,0,1,0.\\n        for(int i = 0; i < n; i++){\\n            if(i & 1){ // When i is odd\\n                // Assume 0 is less and should stay on odd position, so we swap 1 away from odd position.\\n                row_swap_count += board[i][0];\\n                col_swap_count += board[0][i];\\n            }\\n            // Count 0.\\n            row_0_count += board[i][0] == 0, col_0_count += board[0][i] == 0;            \\n        }\\n        \\n        int odd_position_count = n/2; // Odd position count is always less than or equal with even position count.\\n        if(n & 1){ // When n is odd.\\n            // Count of 0 == odd_position_count means 0 is less, so we\\'re right on swapping 1 away, the current swap count is correct. \\n\\t\\t\\t// Otherwise we should keep 1 on the odd position and swap 0 away, so the swap count becomes odd_position_count - row_swap_count.\\n            row_swap_count = row_0_count == odd_position_count ? row_swap_count : (odd_position_count - row_swap_count);\\n            col_swap_count = col_0_count == odd_position_count ? col_swap_count : (odd_position_count - col_swap_count);\\n        }\\n        else{\\n            // If n is even, odd position\\'s count is the same with even position\\'s count, choose whichever swap count is smaller.\\n            row_swap_count = min(row_swap_count, odd_position_count - row_swap_count);\\n            col_swap_count = min(col_swap_count, odd_position_count - col_swap_count);            \\n        }\\n        \\n        return row_swap_count + col_swap_count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169380,
                "title": "short-python-solution-beat-100-with-line-by-line-explanation",
                "content": "Beat 100%\\n(Inspired by Maozi Chen\\'s observations; he/she is a genius!)\\nMy understanding:\\nKey observation: A solvable board iff it satisfies the following requirements:\\n    1) Each row/column either the same as the first row/column or exactly cell-by-cell reversed color of the first row/column.\\n        Example1: If the first row is: 011010, then the other rows must be either 011010 (same) or 100101(inverted).\\n        Example2: If the first column is: 101, then the other columns must be either 101 or 010.\\n    2) Let\\'s make two definitions:\\n        Positive: A row/col is positive if it\\'s same as the first row/col.\\n        Negative: A row/col is negative if it\\'s the invertion of the first row/col.\\n        If N is Even: there must be equal numbers of positive rows/cols and negative rows/cols\\n        If N is Odd: they must differ by 1. Examples: len(pos_rows) = len(neg_rows) + 1\\nThese two observations can be proven by drawing a generic final chessboard, then prove by contradiction or enumeration.\\n\\nNow as long as it satisfies the requirements, we can definitely reach \\'chessboard\\', what left is to calculate the min steps needed.\\nI use P to represent a positive row/col, and N to represent a negative row/col. There are only two possible results:\\nPattern A: P N P N P ... or Pattern B: N P N P N ...\\nFor a given problem, its rows are in the format X X X X X ...\\nWe check if pattern A and/or pattern B are possible, if both are possible then we use the min steps.\\nHow to check if a pattern is possible for the given problem?\\n    For a given problem and a pattern, we compare them digit by digit, each time they differ we increment errors/mismatches: errs+=1\\n    If the final errs is odd, then this pattern is impossible. In other words, there must be even number of errors/mismatches.\\n        Example: n=5, problem = N N P P N, \\n                      Pattern = P N P N P (pattern A)\\n                      Errors =  E _ _ E E  errs = 3\\n                So pattern A is impossible.\\n        Example: n=5, problem = N N P P N, \\n                      Pattern = N P N P N (pattern B)\\n                      Errors =  _ E E _ _  errs = 2\\n                So pattern B is possible.\\n        Example: n=3, problem = N N N, you can prove that neither of the patterns are possible. But this example should\\'ve exited at requirement 2)\\n\\nSo the algorithm is as following:\\n    Line <1> and <2>: save positive and negative rows/cols. \\n    Line <3>: The function core will be called once for rows once for columns.\\n    Lines < A>: the default pattern used is pattern A (lines < A>), then the errs of matching pattern B can be calculated: N-errs\\n    Line < 4>: we keep tracking the count of positive rows/cols.\\n    Line <5>: checks requirement 1)\\n    Line <6>: checks requirement 2) using the count at line <4>\\n    Lines < B>: check if pattern A or pattern B is possible.\\n```\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        N = len(board)\\n        rp, cp = board[0], [x[0] for x in board]    #<1>\\n        rn, cn = [(x+1)%2 for x in rp], [(x+1)%2 for x in cp]   #<2>\\n        \\n        def core(is_row): # <3>\\n            count = errs = 0\\n            for i in range(N):\\n                if is_row: line, pos, neg = board[i], rp, rn\\n                else: line, pos, neg = [x[i] for x in board], cp, cn\\n                \\n                if line == pos:\\n                    count+=1 # <4>\\n                    if i%2==1: errs+=1  # <A>\\n                elif line == neg:\\n                    if i%2==0: errs+=1  # <A>\\n                else: return -1 # <5>\\n            if count > math.ceil(N/2) or count < math.floor(N/2): return -1 # <6>\\n            cand1 = math.inf if errs%2==1 else errs//2  # <B>\\n            cand2 = math.inf if (N-errs)%2==1 else (N-errs)//2  # <B>\\n            return min(cand1, cand2)# if min(cand1, cand2) != math.inf else -1\\n                    \\n        row_ans = core(True)\\n        if row_ans == -1: return -1\\n        col_ans = core(False)\\n        if col_ans == -1: return -1\\n        return row_ans + col_ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        N = len(board)\\n        rp, cp = board[0], [x[0] for x in board]    #<1>\\n        rn, cn = [(x+1)%2 for x in rp], [(x+1)%2 for x in cp]   #<2>\\n        \\n        def core(is_row): # <3>\\n            count = errs = 0\\n            for i in range(N):\\n                if is_row: line, pos, neg = board[i], rp, rn\\n                else: line, pos, neg = [x[i] for x in board], cp, cn\\n                \\n                if line == pos:\\n                    count+=1 # <4>\\n                    if i%2==1: errs+=1  # <A>\\n                elif line == neg:\\n                    if i%2==0: errs+=1  # <A>\\n                else: return -1 # <5>\\n            if count > math.ceil(N/2) or count < math.floor(N/2): return -1 # <6>\\n            cand1 = math.inf if errs%2==1 else errs//2  # <B>\\n            cand2 = math.inf if (N-errs)%2==1 else (N-errs)//2  # <B>\\n            return min(cand1, cand2)# if min(cand1, cand2) != math.inf else -1\\n                    \\n        row_ans = core(True)\\n        if row_ans == -1: return -1\\n        col_ans = core(False)\\n        if col_ans == -1: return -1\\n        return row_ans + col_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114844,
                "title": "short-c-solution-no-swaps-9ms-o-n-2-time-o-1-space",
                "content": "The algorithm is based on counting. A solvable board has each row/column either the same as the first row/column or exactly cell-by-cell reversed color of the first row/column.\\n\\nIn the loop we count for **rs** and **cs**, the number of rows/columns being the same as the first row/column, and **rm** and **cm**, the number of misplaced rows/columns in the view of the first row/column. If any row/column is found to be neither the same nor reversed color then returns -1 immediately.\\n\\nThen, for even number **n** there are two final forms of the first row/column. We compute the minimum swaps of the two cases. For odd number **n** there is only one final form of the board so we compute the swaps based on the fact that whether the first row/column is in the less or the greater half.\\n```\\nint movesToChessboard(vector<vector<int>>& b) {\\n    int n = b.size();\\n    int rs = 0, cs = 0, rm = 0, cm = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        bool rf = b[0][0] == b[i][0], cf = b[0][0] == b[0][i];\\n        rs += rf, cs += cf;\\n        rm += rf ^ !(i & 1), cm += cf ^ !(i & 1);\\n        for (int j = 0; j < n; j++)\\n            if ((b[0][j] == b[i][j]) ^ rf || (b[j][0] == b[j][i]) ^ cf)\\n                return -1;\\n    }\\n\\n    if (n % 2 == 0) {\\n        if (rs == n / 2 && cs == n / 2)\\n            return min(rm, n - rm) / 2 + min(cm, n - cm) / 2;\\n        return -1;\\n    }\\n\\n    int res = 0;\\n    if (rs == n / 2)\\n        res += (n - rm) / 2;\\n    else if (rs == n / 2 + 1)\\n        res += rm / 2;\\n    else\\n        return -1;\\n\\n    if (cs == n / 2)\\n        res += (n - cm) / 2;\\n    else if (cs == n / 2 + 1)\\n        res += cm / 2;\\n    else\\n        return -1;\\n\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint movesToChessboard(vector<vector<int>>& b) {\\n    int n = b.size();\\n    int rs = 0, cs = 0, rm = 0, cm = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        bool rf = b[0][0] == b[i][0], cf = b[0][0] == b[0][i];\\n        rs += rf, cs += cf;\\n        rm += rf ^ !(i & 1), cm += cf ^ !(i & 1);\\n        for (int j = 0; j < n; j++)\\n            if ((b[0][j] == b[i][j]) ^ rf || (b[j][0] == b[j][i]) ^ cf)\\n                return -1;\\n    }\\n\\n    if (n % 2 == 0) {\\n        if (rs == n / 2 && cs == n / 2)\\n            return min(rm, n - rm) / 2 + min(cm, n - cm) / 2;\\n        return -1;\\n    }\\n\\n    int res = 0;\\n    if (rs == n / 2)\\n        res += (n - rm) / 2;\\n    else if (rs == n / 2 + 1)\\n        res += rm / 2;\\n    else\\n        return -1;\\n\\n    if (cs == n / 2)\\n        res += (n - cm) / 2;\\n    else if (cs == n / 2 + 1)\\n        res += cm / 2;\\n    else\\n        return -1;\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305763,
                "title": "python3-alternating-numbers",
                "content": "\\n```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        \\n        def fn(vals): \\n            \"\"\"Return min moves to transform to chessboard.\"\"\"\\n            total = odd = 0 \\n            for i, x in enumerate(vals): \\n                if vals[0] == x: \\n                    total += 1\\n                    if i&1: odd += 1\\n                elif vals[0] ^ x != (1 << n) - 1: return inf\\n            ans = inf \\n            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)\\n            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)\\n            return ans \\n        \\n        rows, cols = [0]*n, [0]*n\\n        for i in range(n): \\n            for j in range(n): \\n                if board[i][j]: \\n                    rows[i] ^= 1 << j \\n                    cols[j] ^= 1 << i\\n        ans = fn(rows) + fn(cols)\\n        return ans if ans < inf else -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        \\n        def fn(vals): \\n            \"\"\"Return min moves to transform to chessboard.\"\"\"\\n            total = odd = 0 \\n            for i, x in enumerate(vals): \\n                if vals[0] == x: \\n                    total += 1\\n                    if i&1: odd += 1\\n                elif vals[0] ^ x != (1 << n) - 1: return inf\\n            ans = inf \\n            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)\\n            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)\\n            return ans \\n        \\n        rows, cols = [0]*n, [0]*n\\n        for i in range(n): \\n            for j in range(n): \\n                if board[i][j]: \\n                    rows[i] ^= 1 << j \\n                    cols[j] ^= 1 << i\\n        ans = fn(rows) + fn(cols)\\n        return ans if ans < inf else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488171,
                "title": "explaining-transform-to-chessboard-c",
                "content": "**The key idea is:**\\nIf the grid has a solution, we can arrive at the solution by looking only at the first row and the first column. This happens because each solution step moves the entire row or entire column.\\n\\n**How to know if the table has a solution?**\\nThe dimensions are dependent, so we need to check that when correcting the first row or first column, the values in the middle of the table are resolved too.\\n\\nThe code below shows how we analyze this:\\n```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\nThis code compares whether the middle value has the same parity with the edge values.\\n\\n[![Image from Gyazo](https://i.gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e.png)](https://gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e)\\n\\n- if the blue cells have different values, the green cells must also have different values.\\n- if blue cells have equal values, green cells must also have equal values.\\n\\nIf neither of the above two conditions are true, we have a table that is impossible to solve. \\nThis looks like magic right? Let\\'s look at the solved table:\\n<p>\\n<img src=\"https://i.gyazo.com/f3e3ee7360a38024e12ef928fef72cc9.png\" width=\"30%\">\\n</p>\\n\\nBetween two adjacent lines, one is the conjugate of the other and the same applies for columns. When we swap a row or a column from an solved table, we have two scenarios:\\n\\n1. Swap identical row or collumn\\n2. Swap conjugated row or collumn\\n\\nNo matter how many operations you do, we will always fall into these two scenarios. In summary, the code above checks if the current table has this property.\\n\\nBefore calculating the number of steps to reach the solution. We need to do one more validation, this one is much simpler.\\n\\nThis validation consists of counting the number of 1s and 0s in the first row and in the first column:\\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\\n\\n- If the difference between zeros and ones is greater than 1, it\\'s impossible solve this table.\\n\\n\\nNow to calculate the minimum number of steps, we need to solve the first column and the first row individually and sum each result.\\n\\n**Solving to first row and column**\\n\\nTo solve this, we have two scenarios:\\n1. N even\\n2. N odd\\n\\nWhen N is even, we have two solutions:\\n\\n- **[0,1,...,0,1]** (starting with 0)\\n- **[1,0,...,1,0]** (starting with 1)\\n\\n\\nWe know that each swap can fix two elements as we can see in the example below:\\n\\n- **[0,0,1,1]**  --> **[0,1,0,1]**  (swap second with third item)\\n\\nSo, the number of moviments needed to transform a row or a collumn to any two possible solution is:\\n\\n- number of wrong elements divided by 2\\n\\nAs one solution is the inverse of the other, we can say that:\\n\\n- **solution_start_one** = N - **solution_start_zero**\\n\\nTherefore, when N is even, the answer will be the smallest value between the two possible solutions.\\n\\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\\n\\nWhen N is odd, we have only one solution:\\n\\n- **[1,0,..,0,1]** (when the row or column has more ones)\\n- **[0,1,..,1,0]** (when the row or column has more zeros)\\n\\nIf we have more zeros, we only use the value to solution that begin with zero. So with odd N we need analyze the number of zeros and use the correct solution to each case.\\n\\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\\n\\nThe code for this question is quite simple, but the idea behind it is quite complex. I really enjoyed the insights that this problem required.\\n\\nThe final code is:\\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```\\nI am sorry for my english. I\\'m just a young brazilian boy trying to help this community.",
                "solutionTags": [],
                "code": "```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487111,
                "title": "javascript-easy-to-read-solution",
                "content": "```\\n/**\\n * @param {number[][]} board\\n * @return {number}\\n */\\nvar movesToChessboard = function(board) {\\n    const boardSize = board.length;\\n    const boardSizeIsEven = boardSize % 2 === 0;\\n       \\n    if(!canBeTransformed(board)) return -1;\\n    \\n    // to convert to 010101\\n    let rowSwap = 0;\\n    let colSwap = 0;\\n    \\n    // to convert to 101010\\n    let rowSwap2 = 0;\\n    let colSwap2 = 0;\\n    \\n    for(let i=0; i<boardSize; i++) {\\n        if(board[i][0] === i % 2) {\\n            rowSwap++;\\n        } else {\\n            rowSwap2++;\\n        }\\n        if(board[0][i] === i % 2) {\\n            colSwap++;\\n        } else {\\n            colSwap2++;\\n        }\\n    }\\n   \\n    // no need to swap anything\\n    if((rowSwap + colSwap) === 0 || (rowSwap2 + colSwap2) === 0) return 0; \\n    \\n    if(boardSizeIsEven) {\\n        rowSwap = Math.min(rowSwap, rowSwap2);\\n        colSwap = Math.min(colSwap, colSwap2);\\n    } else {\\n        rowSwap = rowSwap % 2 === 0  ? rowSwap : rowSwap2;\\n        colSwap = colSwap % 2 === 0 ? colSwap : colSwap2;\\n    }\\n   \\n    return (rowSwap + colSwap) / 2;\\n    \\n    function canBeTransformed(board) {\\n        // number of 0 and 1 should be equal\\n        let sum = board[0].reduce((a,b) => a+b);\\n        if(boardSizeIsEven && sum != boardSize/2) return false;\\n        if(!boardSizeIsEven && sum > ((boardSize + 1)/2)) return false;\\n        \\n        let first = board[0].join(\\'\\');\\n        let opposite = board[0].map((item) => item === 1 ? 0 : 1).join(\\'\\');\\n        // each row should be equal to first or opposite\\n        let counter = [0,0];\\n        for(let i=0; i<boardSize; i++) {\\n            let str = board[i].join(\\'\\');\\n            if(str == first) {\\n                counter[0]++;\\n            } else if(str == opposite) {\\n                counter[1]++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        // for even board, two types of rows should be equal\\n        if(boardSizeIsEven) {\\n            return counter[0] == counter[1];\\n        }\\n        return Math.abs(counter[0] - counter[1]) === 1\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} board\\n * @return {number}\\n */\\nvar movesToChessboard = function(board) {\\n    const boardSize = board.length;\\n    const boardSizeIsEven = boardSize % 2 === 0;\\n       \\n    if(!canBeTransformed(board)) return -1;\\n    \\n    // to convert to 010101\\n    let rowSwap = 0;\\n    let colSwap = 0;\\n    \\n    // to convert to 101010\\n    let rowSwap2 = 0;\\n    let colSwap2 = 0;\\n    \\n    for(let i=0; i<boardSize; i++) {\\n        if(board[i][0] === i % 2) {\\n            rowSwap++;\\n        } else {\\n            rowSwap2++;\\n        }\\n        if(board[0][i] === i % 2) {\\n            colSwap++;\\n        } else {\\n            colSwap2++;\\n        }\\n    }\\n   \\n    // no need to swap anything\\n    if((rowSwap + colSwap) === 0 || (rowSwap2 + colSwap2) === 0) return 0; \\n    \\n    if(boardSizeIsEven) {\\n        rowSwap = Math.min(rowSwap, rowSwap2);\\n        colSwap = Math.min(colSwap, colSwap2);\\n    } else {\\n        rowSwap = rowSwap % 2 === 0  ? rowSwap : rowSwap2;\\n        colSwap = colSwap % 2 === 0 ? colSwap : colSwap2;\\n    }\\n   \\n    return (rowSwap + colSwap) / 2;\\n    \\n    function canBeTransformed(board) {\\n        // number of 0 and 1 should be equal\\n        let sum = board[0].reduce((a,b) => a+b);\\n        if(boardSizeIsEven && sum != boardSize/2) return false;\\n        if(!boardSizeIsEven && sum > ((boardSize + 1)/2)) return false;\\n        \\n        let first = board[0].join(\\'\\');\\n        let opposite = board[0].map((item) => item === 1 ? 0 : 1).join(\\'\\');\\n        // each row should be equal to first or opposite\\n        let counter = [0,0];\\n        for(let i=0; i<boardSize; i++) {\\n            let str = board[i].join(\\'\\');\\n            if(str == first) {\\n                counter[0]++;\\n            } else if(str == opposite) {\\n                counter[1]++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        // for even board, two types of rows should be equal\\n        if(boardSizeIsEven) {\\n            return counter[0] == counter[1];\\n        }\\n        return Math.abs(counter[0] - counter[1]) === 1\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170386,
                "title": "javascript-solution",
                "content": "My code is ugly but at least it passed all the test cases.\\nThe main idea is the following:\\n\\n1. rows and columns can be fixed **independantly**, because they don\\'t affect eachother.\\n2. If the size is odd, first position and last position in the row and column is **decided**. If one has three, zero has two in the first row, first column and last column must have one. It is same as the column calculation.\\n3. If the size is even, check which one has more correct position and try to fix the wrong position to minimize the move.\\n4. If you see the code below, column fix logic and row fix logic is **identical** except the posion in the board\\n\\n\\n```\\n/**\\n * @param {number[][]} board\\n * @return {number}\\n */\\n var movesToChessboard = function(board) {\\n    let cnt = 0;\\n    let one = 0;\\n    let zero = 0;\\n    for (let r of board) {\\n        for (let c of r) {\\n            if (c === 0) {\\n                zero++;\\n            } else {\\n                one++;\\n            }\\n        }\\n    }\\n\\t\\n\\t// start column fix\\n    let missedOne = [];\\n    let missedZero = [];\\n    let cur = 0;\\n    if (one !== zero) {\\n        cur = one > zero ? 1 : 0;\\n    } else {\\n        let zeroCorrect = 0;\\n        let oneCorrect = 0;\\n        for (let i = 0; i < board.length; i += 2) {\\n            if (board[0][i] == 0) {\\n                zeroCorrect++;\\n            } else {\\n                oneCorrect++;\\n            }\\n        }\\n        cur = oneCorrect > zeroCorrect ? 1 : 0;\\n    }\\n        \\n    let r = 0;\\n    if (one != zero) {\\n        while (r < board.length) {\\n            o = 0;\\n            z = 0;\\n            for(let c = 0; c < board.length; c++) {\\n                o = board[r][c] === 1 ? o + 1 : o;\\n                z = board[r][c] === 0 ? z + 1 : z;\\n            }\\n            if (cur === 1 && o > z || cur == 0 && z > o) break;\\n            r++;\\n        }\\n    }\\n    for(let c = 0; c < board.length; c++) {\\n        if (board[r][c] !== cur) {\\n            if (cur === 1) {\\n                missedOne.push(c);\\n            } else {\\n                missedZero.push(c);\\n            }\\n        }\\n        cur = cur === 1 ? 0 : 1;\\n    }\\n    if (missedOne.length != missedZero.length) {\\n        return -1;\\n    }\\n    for (let i = 0; i < missedZero.length; i++) {\\n        for (let rr = 0; rr < board.length; rr++) {\\n            [board[rr][missedZero[i]], board[rr][missedOne[i]]] = [board[rr][missedOne[i]], board[rr][missedZero[i]]];\\n        }\\n        cnt++;\\n    }\\n\\n    // start row fix\\n    missedOne = [];\\n    missedZero = [];\\n    cur = 0;\\n    if (one !== zero) {\\n        cur = one > zero ? 1 : 0;\\n    } else {\\n        let zeroCorrect = 0;\\n        let oneCorrect = 0;\\n        for (let i = 0; i < board.length; i += 2) {\\n            if (board[i][0] == 0) {\\n                zeroCorrect++;\\n            } else {\\n                oneCorrect++;\\n            }\\n        }\\n        cur = oneCorrect > zeroCorrect ? 1 : 0;\\n    }\\n        \\n    let c = 0;\\n    if (one != zero) {\\n        while (c < board.length) {\\n            o = 0;\\n            z = 0;\\n            for(let r = 0; r < board.length; r++) {\\n                o = board[r][c] === 1 ? o + 1 : o;\\n                z = board[r][c] === 0 ? z + 1 : z;\\n            }\\n            if (cur === 1 && o > z || cur == 0 && z > o) break;\\n            c++;\\n        }\\n    }\\n    for(let r = 0; r < board.length; r++) {\\n        if (board[r][c] !== cur) {\\n            if (cur === 1) {\\n                missedOne.push(r);\\n            } else {\\n                missedZero.push(r);\\n            }\\n        }\\n        cur = cur === 1 ? 0 : 1;\\n    }\\n    if (missedOne.length != missedZero.length) {\\n        return -1;\\n    }\\n    for (let i = 0; i < missedZero.length; i++) {\\n        [board[missedOne[i]], board[missedZero[i]]] = [board[missedZero[i]], board[missedOne[i]]];\\n        cnt++;\\n    }\\n\\n    for (let r = 1; r < board.length; r++) {\\n        for (let c = 1; c < board.length; c++) {\\n            if (board[r][c] == board[r][c-1] || board[r-1][c] == board[r][c]) {\\n                return -1;\\n            }\\n        }\\n    }\\n    \\n    return cnt;\\n};",
                "solutionTags": [],
                "code": "My code is ugly but at least it passed all the test cases.\\nThe main idea is the following:\\n\\n1. rows and columns can be fixed **independantly**, because they don\\'t affect eachother.\\n2. If the size is odd, first position and last position in the row and column is **decided**. If one has three, zero has two in the first row, first column and last column must have one. It is same as the column calculation.\\n3. If the size is even, check which one has more correct position and try to fix the wrong position to minimize the move.\\n4. If you see the code below, column fix logic and row fix logic is **identical** except the posion in the board\\n\\n\\n```\\n/**\\n * @param {number[][]} board\\n * @return {number}\\n */\\n var movesToChessboard = function(board) {\\n    let cnt = 0;\\n    let one = 0;\\n    let zero = 0;\\n    for (let r of board) {\\n        for (let c of r) {\\n            if (c === 0) {\\n                zero++;\\n            } else {\\n                one++;\\n            }\\n        }\\n    }\\n\\t\\n\\t// start column fix\\n    let missedOne = [];\\n    let missedZero = [];\\n    let cur = 0;\\n    if (one !== zero) {\\n        cur = one > zero ? 1 : 0;\\n    } else {\\n        let zeroCorrect = 0;\\n        let oneCorrect = 0;\\n        for (let i = 0; i < board.length; i += 2) {\\n            if (board[0][i] == 0) {\\n                zeroCorrect++;\\n            } else {\\n                oneCorrect++;\\n            }\\n        }\\n        cur = oneCorrect > zeroCorrect ? 1 : 0;\\n    }\\n        \\n    let r = 0;\\n    if (one != zero) {\\n        while (r < board.length) {\\n            o = 0;\\n            z = 0;\\n            for(let c = 0; c < board.length; c++) {\\n                o = board[r][c] === 1 ? o + 1 : o;\\n                z = board[r][c] === 0 ? z + 1 : z;\\n            }\\n            if (cur === 1 && o > z || cur == 0 && z > o) break;\\n            r++;\\n        }\\n    }\\n    for(let c = 0; c < board.length; c++) {\\n        if (board[r][c] !== cur) {\\n            if (cur === 1) {\\n                missedOne.push(c);\\n            } else {\\n                missedZero.push(c);\\n            }\\n        }\\n        cur = cur === 1 ? 0 : 1;\\n    }\\n    if (missedOne.length != missedZero.length) {\\n        return -1;\\n    }\\n    for (let i = 0; i < missedZero.length; i++) {\\n        for (let rr = 0; rr < board.length; rr++) {\\n            [board[rr][missedZero[i]], board[rr][missedOne[i]]] = [board[rr][missedOne[i]], board[rr][missedZero[i]]];\\n        }\\n        cnt++;\\n    }\\n\\n    // start row fix\\n    missedOne = [];\\n    missedZero = [];\\n    cur = 0;\\n    if (one !== zero) {\\n        cur = one > zero ? 1 : 0;\\n    } else {\\n        let zeroCorrect = 0;\\n        let oneCorrect = 0;\\n        for (let i = 0; i < board.length; i += 2) {\\n            if (board[i][0] == 0) {\\n                zeroCorrect++;\\n            } else {\\n                oneCorrect++;\\n            }\\n        }\\n        cur = oneCorrect > zeroCorrect ? 1 : 0;\\n    }\\n        \\n    let c = 0;\\n    if (one != zero) {\\n        while (c < board.length) {\\n            o = 0;\\n            z = 0;\\n            for(let r = 0; r < board.length; r++) {\\n                o = board[r][c] === 1 ? o + 1 : o;\\n                z = board[r][c] === 0 ? z + 1 : z;\\n            }\\n            if (cur === 1 && o > z || cur == 0 && z > o) break;\\n            c++;\\n        }\\n    }\\n    for(let r = 0; r < board.length; r++) {\\n        if (board[r][c] !== cur) {\\n            if (cur === 1) {\\n                missedOne.push(r);\\n            } else {\\n                missedZero.push(r);\\n            }\\n        }\\n        cur = cur === 1 ? 0 : 1;\\n    }\\n    if (missedOne.length != missedZero.length) {\\n        return -1;\\n    }\\n    for (let i = 0; i < missedZero.length; i++) {\\n        [board[missedOne[i]], board[missedZero[i]]] = [board[missedZero[i]], board[missedOne[i]]];\\n        cnt++;\\n    }\\n\\n    for (let r = 1; r < board.length; r++) {\\n        for (let c = 1; c < board.length; c++) {\\n            if (board[r][c] == board[r][c-1] || board[r-1][c] == board[r][c]) {\\n                return -1;\\n            }\\n        }\\n    }\\n    \\n    return cnt;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1488779,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) \\n    {\\n        int n = board.size();\\n        int cnt1 = 1, cnt2 = 0;\\n        for (int i = 1; i < n; ++i) \\n        {\\n            if (board[0][0] == board[i][0]) \\n            {\\n                ++cnt1;\\n                for (int j = 0; j < n; ++j) \\n                {\\n                  if (board[0][j] != board[i][j]) \\n                  {\\n                      return -1;\\n                  }  \\n                }\\n            } \\n            else \\n            {\\n                ++cnt2;\\n                for (int j = 0; j < n; ++j) \\n                {\\n                    if (board[0][j] == board[i][j]) \\n                    {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        if (abs(cnt1 - cnt2) > 1) \\n        {\\n            return -1;\\n        }\\n        cnt1 = 1, cnt2 = 0;\\n        for (int j = 1; j < n; ++j) \\n        {\\n            if (board[0][0] == board[0][j]) \\n            {\\n                ++cnt1;\\n                for (int i = 0; i < n; ++i) \\n                {\\n                    if (board[i][0] != board[i][j]) \\n                    {\\n                        return -1;\\n                    }\\n                }\\n            } \\n            else \\n            {\\n                ++cnt2;\\n                for (int i = 0; i < n; ++i) \\n                {                      \\n                    if (board[i][0] == board[i][j]) \\n                    {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        if (abs(cnt1 - cnt2) > 1) \\n        {\\n            return -1;\\n        }\\n        int swapRow = 0, swapCol = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (board[i][0] != i % 2) \\n            {\\n                ++swapRow;\\n            }\\n        }\\n        for (int j = 0; j < n; ++j) \\n        {\\n            if (board[0][j] != j % 2) \\n            {\\n                ++swapCol;\\n            }\\n        }\\n        int ans = 0;\\n        if (n & 1) \\n        {\\n            if (swapRow & 1) \\n            {\\n                swapRow = n - swapRow;\\n            }\\n            if (swapCol & 1) \\n            {\\n                swapCol = n - swapCol;\\n            }\\n            ans += swapRow / 2;\\n            ans += swapCol / 2;\\n        } \\n        else \\n        {\\n            ans += min(swapRow, n - swapRow) / 2;\\n            ans += min(swapCol, n - swapCol) / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) \\n    {\\n        int n = board.size();\\n        int cnt1 = 1, cnt2 = 0;\\n        for (int i = 1; i < n; ++i) \\n        {\\n            if (board[0][0] == board[i][0]) \\n            {\\n                ++cnt1;\\n                for (int j = 0; j < n; ++j) \\n                {\\n                  if (board[0][j] != board[i][j]) \\n                  {\\n                      return -1;\\n                  }  \\n                }\\n            } \\n            else \\n            {\\n                ++cnt2;\\n                for (int j = 0; j < n; ++j) \\n                {\\n                    if (board[0][j] == board[i][j]) \\n                    {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        if (abs(cnt1 - cnt2) > 1) \\n        {\\n            return -1;\\n        }\\n        cnt1 = 1, cnt2 = 0;\\n        for (int j = 1; j < n; ++j) \\n        {\\n            if (board[0][0] == board[0][j]) \\n            {\\n                ++cnt1;\\n                for (int i = 0; i < n; ++i) \\n                {\\n                    if (board[i][0] != board[i][j]) \\n                    {\\n                        return -1;\\n                    }\\n                }\\n            } \\n            else \\n            {\\n                ++cnt2;\\n                for (int i = 0; i < n; ++i) \\n                {                      \\n                    if (board[i][0] == board[i][j]) \\n                    {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        if (abs(cnt1 - cnt2) > 1) \\n        {\\n            return -1;\\n        }\\n        int swapRow = 0, swapCol = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (board[i][0] != i % 2) \\n            {\\n                ++swapRow;\\n            }\\n        }\\n        for (int j = 0; j < n; ++j) \\n        {\\n            if (board[0][j] != j % 2) \\n            {\\n                ++swapCol;\\n            }\\n        }\\n        int ans = 0;\\n        if (n & 1) \\n        {\\n            if (swapRow & 1) \\n            {\\n                swapRow = n - swapRow;\\n            }\\n            if (swapCol & 1) \\n            {\\n                swapCol = n - swapCol;\\n            }\\n            ans += swapRow / 2;\\n            ans += swapCol / 2;\\n        } \\n        else \\n        {\\n            ans += min(swapRow, n - swapRow) / 2;\\n            ans += min(swapCol, n - swapCol) / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443751,
                "title": "javascript-check-number-of-1s-and-0s",
                "content": "```\\nvar movesToChessboard = function(board) {\\n    const n = board.length;\\n\\n    for (let i = 0; i < n; i++)\\n        for (let j = 0; j < n; j++)\\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) \\n                return -1;\\n\\n    let rowSwaps = 0, colSwaps = 0, rowSum = 0, colSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        rowSum += board[0][i] ? 1 : -1\\n        colSum += board[i][0] ? 1 : -1;\\n        rowSwaps += board[0][i] === i % 2;\\n        colSwaps += board[i][0] === i % 2;\\n    }\\n    \\n    if (Math.abs(rowSum) > 1 || Math.abs(colSum) > 1)\\n        return -1;\\n\\n    if (n % 2) {\\n        if (rowSwaps % 2) rowSwaps = n - rowSwaps;\\n        if (colSwaps % 2) colSwaps = n - colSwaps;\\n    } else {\\n        colSwaps = Math.min(colSwaps, n - colSwaps);\\n        rowSwaps = Math.min(rowSwaps, n - rowSwaps);\\n    }\\n\\n    return (colSwaps + rowSwaps) / 2;\\n};",
                "solutionTags": [],
                "code": "```\\nvar movesToChessboard = function(board) {\\n    const n = board.length;\\n\\n    for (let i = 0; i < n; i++)\\n        for (let j = 0; j < n; j++)\\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) \\n                return -1;\\n\\n    let rowSwaps = 0, colSwaps = 0, rowSum = 0, colSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        rowSum += board[0][i] ? 1 : -1\\n        colSum += board[i][0] ? 1 : -1;\\n        rowSwaps += board[0][i] === i % 2;\\n        colSwaps += board[i][0] === i % 2;\\n    }\\n    \\n    if (Math.abs(rowSum) > 1 || Math.abs(colSum) > 1)\\n        return -1;\\n\\n    if (n % 2) {\\n        if (rowSwaps % 2) rowSwaps = n - rowSwaps;\\n        if (colSwaps % 2) colSwaps = n - colSwaps;\\n    } else {\\n        colSwaps = Math.min(colSwaps, n - colSwaps);\\n        rowSwaps = Math.min(rowSwaps, n - rowSwaps);\\n    }\\n\\n    return (colSwaps + rowSwaps) / 2;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1570037,
                "title": "python-bipartite-graph",
                "content": "Consider bipartite graph of rows and columns. If row and column intersection has `1`, then connect with an edge corresponding vertices in the graph. Swaping rows or columns correspond to swapping vertices in the graph. At the end we want to have chessboard construction, which implies that we have connected component of odd rows connected to all odd columns or to all even columns. And all even rows connected to other half of columns. So we will get two complete subgraphs which do not intersect with each other in our initial bipartite graph, and it is very intuitive that this is actually necessary and sufficient condition. So after understanding whether you have two such complete subgraphs, it is easy to compute number of swaps required to move all rows and columns inside the same subgraph to odd or even indexes. Done.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        gr = defaultdict(set)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if board[i][j]:\\n                    gr[i].add(j + 2 * n)\\n                    gr[j + 2 * n].add(i)\\n\\n        def assign(base = 0):\\n            len_base, deg = len(gr[base]), n // 2\\n            if n % 2 == 0 and len_base != deg: return -1\\n            if n % 2 == 1 and not (0 <= len_base - deg <= 1): return -1\\n\\n            first = {base}\\n            second = set()\\n\\n            for j in range(base, base + n):\\n                intersection = gr[base] & gr[j]\\n                if len(intersection) == 0 and len(gr[j]) == n - len_base:\\n                    second.add(j)\\n                elif len(intersection) == len_base and len(gr[j]) == len_base:\\n                    first.add(j)\\n                else:\\n                    return -1\\n\\n            v1, v2 = sum(f % 2 for f in first), sum((f + 1) % 2 for f in first)\\n\\n            if n % 2 == 1:\\n                return v2 if len(first) == deg else v1\\n\\n            return min(v1, v2)\\n\\n        v1, v2 = assign(), assign(2 * n)\\n        if v1 == -1 or v2 == -1: return -1\\n        return v1 + v2\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        gr = defaultdict(set)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if board[i][j]:\\n                    gr[i].add(j + 2 * n)\\n                    gr[j + 2 * n].add(i)\\n\\n        def assign(base = 0):\\n            len_base, deg = len(gr[base]), n // 2\\n            if n % 2 == 0 and len_base != deg: return -1\\n            if n % 2 == 1 and not (0 <= len_base - deg <= 1): return -1\\n\\n            first = {base}\\n            second = set()\\n\\n            for j in range(base, base + n):\\n                intersection = gr[base] & gr[j]\\n                if len(intersection) == 0 and len(gr[j]) == n - len_base:\\n                    second.add(j)\\n                elif len(intersection) == len_base and len(gr[j]) == len_base:\\n                    first.add(j)\\n                else:\\n                    return -1\\n\\n            v1, v2 = sum(f % 2 for f in first), sum((f + 1) % 2 for f in first)\\n\\n            if n % 2 == 1:\\n                return v2 if len(first) == deg else v1\\n\\n            return min(v1, v2)\\n\\n        v1, v2 = assign(), assign(2 * n)\\n        if v1 == -1 or v2 == -1: return -1\\n        return v1 + v2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522961,
                "title": "c-solution-with-proof",
                "content": "**The key idea is:**\\nIf the grid has a solution, we can arrive at the solution by looking only at the first row and the first column. This happens because each solution step moves the entire row or entire column.\\n\\n**How to know if the table has a solution?**\\nThe dimensions are dependent, so we need to check that when correcting the first row or first column, the values in the middle of the table are resolved too.\\n\\nThe code below shows how we analyze this:\\n```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\nThis code compares whether the middle value has the same parity with the edge values.\\n\\n[![Image from Gyazo](https://i.gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e.png)](https://gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e)\\n\\n- if the blue cells have different values, the green cells must also have different values.\\n- if blue cells have equal values, green cells must also have equal values.\\n\\nIf neither of the above two conditions are true, we have a table that is impossible to solve. \\nThis looks like magic right? Let\\'s look at the solved table:\\n<p>\\n<img src=\"https://i.gyazo.com/f3e3ee7360a38024e12ef928fef72cc9.png\" width=\"30%\">\\n</p>\\n\\nBetween two adjacent lines, one is the conjugate of the other and the same applies for columns. When we swap a row or a column from an solved table, we have two scenarios:\\n\\n1. Swap identical row or collumn\\n2. Swap conjugated row or collumn\\n\\nNo matter how many operations you do, we will always fall into these two scenarios. In summary, the code above checks if the current table has this property.\\n\\nBefore calculating the number of steps to reach the solution. We need to do one more validation, this one is much simpler.\\n\\nThis validation consists of counting the number of 1s and 0s in the first row and in the first column:\\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\\n\\n- If the difference between zeros and ones is greater than 1, it\\'s impossible solve this table.\\n\\n\\nNow to calculate the minimum number of steps, we need to solve the first column and the first row individually and sum each result.\\n\\n**Solving to first row and column**\\n\\nTo solve this, we have two scenarios:\\n1. N even\\n2. N odd\\n\\nWhen N is even, we have two solutions:\\n\\n- **[0,1,...,0,1]** (starting with 0)\\n- **[1,0,...,1,0]** (starting with 1)\\n\\n\\nWe know that each swap can fix two elements as we can see in the example below:\\n\\n- **[0,0,1,1]**  --> **[0,1,0,1]**  (swap second with third item)\\n\\nSo, the number of moviments needed to transform a row or a collumn to any two possible solution is:\\n\\n- number of wrong elements divided by 2\\n\\nAs one solution is the inverse of the other, we can say that:\\n\\n- **solution_start_one** = N - **solution_start_zero**\\n\\nTherefore, when N is even, the answer will be the smallest value between the two possible solutions.\\n\\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\\n\\nWhen N is odd, we have only one solution:\\n\\n- **[1,0,..,0,1]** (when the row or column has more ones)\\n- **[0,1,..,1,0]** (when the row or column has more zeros)\\n\\nIf we have more zeros, we only use the value to solution that begin with zero. So with odd N we need analyze the number of zeros and use the correct solution to each case.\\n\\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\\n\\nThe code for this question is quite simple, but the idea behind it is quite complex. I really enjoyed the insights that this problem required.\\n\\nThe final code is:\\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```\\nI am sorry for my english. I\\'m just a young brazilian boy trying to help this community.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487043,
                "title": "using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        set<int> s;\\n        int n = board.size();\\n        \\n        for(auto& row : board) {\\n            int code = 0;\\n            for(int& num : row) {\\n                code = code*2 + num;\\n            }\\n            s.insert(code);\\n        }\\n        \\n        int r = check(s, n);\\n        if(r == -1) return -1;\\n        \\n        s.clear();\\n        for(int i = 0; i < n; i++) {\\n            int code = 0;\\n            for(int j = 0; j < n; j++) {\\n                code = code*2 + board[j][i];\\n            }\\n            s.insert(code);\\n        }\\n        \\n        int c = check(s, n);\\n        if(c == -1) return -1;\\n        \\n        return r+c;\\n    }\\n    \\nprivate:\\n    int check(set<int>& s, int n){\\n        if(s.size() != 2) return -1;\\n        int k1 = *s.begin();\\n        \\n        int one  = __builtin_popcount(k1);//count set bits\\n        if(one != n/2 && one != (n+1)/2) return -1;\\n        \\n        int none = (1 << n) -1;\\n        int k2 = *(++s.begin());\\n        k2 = k1^k2;\\n        if(k2 != none) return -1;\\n        one <<= 1;\\n        \\n        int c = INT_MAX; //count of swap\\n        \\n        if(one >= n)//if count of one in k1 is greater than equal to n/2. eg n = 5 and one = 3.\\n            c = min(c, __builtin_popcount(k1^(0x55555555 & none))/2);\\n        \\n        if(one <= n)//if count of one in k1 is equal to n/2. eg n = 5 and one = 2.\\n            c = min(c, __builtin_popcount(k1^(0xAAAAAAAA & none))/2);\\n        \\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        set<int> s;\\n        int n = board.size();\\n        \\n        for(auto& row : board) {\\n            int code = 0;\\n            for(int& num : row) {\\n                code = code*2 + num;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487014,
                "title": "c-added-explanation-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    enum{COL,ROW};\\n    int addedXOR(vector<vector<int>>& board,int orientation,int index)\\n    {\\n        int res=0;\\n        if(orientation==COL)\\n            for(int i=0;i<board.size();i++)\\n              res+=board[i][index]^board[i][index+1];\\n        else if(orientation==ROW)\\n            for(int i=0;i<board.size();i++)\\n                res+=board[index][i]^board[index+1][i];\\n        return res;\\n    }\\n    \\n    \\n    int movesToChessboard(vector<vector<int>>& board) \\n    {\\n        int totalMoves;\\n        int RequiredConfig1[board.size()],RequiredConfig2[board.size()];\\n        //generate 2 possible config of size N(ex:N=5 RequiredConfig1=01010 RequiredConfig2=10101)\\n        RequiredConfig1[0]=0;RequiredConfig2[0]=1;\\n        for(int i=1;i<board.size();i++)\\n        {\\n             RequiredConfig1[i]= RequiredConfig1[i-1]^1;\\n             RequiredConfig2[i]= RequiredConfig2[i-1]^1;\\n        }\\n        //check if valid(ADAJCENT ROWS AND COLUMNS SHOULD BE ALL SAME OR ALL DIFFERENT)\\n        for(int i=0;i<board.size()-1;i++)\\n        {\\n            int res=addedXOR(board,COL,i);\\n            if(res!=0&&res!=board.size())\\n                return -1;\\n            \\n            res=addedXOR(board,ROW,i);\\n            if(res!=0&&res!=board.size())\\n                return -1;           \\n        }\\n        //get for 1st row and 1stcolumn(no of 1s,total diffs with 1st and 2nd RequiredConfig)\\n        int sumConfig1=0,sumConfig2=0,diff1=0,diff2=0,diff3=0,diff4=0;\\n        for(int i=0;i<board.size();i++)\\n        {\\n           sumConfig1+=board[0][i];\\n           diff1+=RequiredConfig1[i]^board[0][i];\\n           diff2+=RequiredConfig2[i]^board[0][i];\\n           sumConfig2+=board[i][0]; \\n           diff3+=RequiredConfig1[i]^board[i][0];\\n           diff4+=RequiredConfig2[i]^board[i][0];  \\n        }\\n        //handle saperately for even size and odd size\\n        if(!(board.size()%2))//even size\\n        {\\n            //calc no of required column swaps\\n            if(sumConfig1!=board.size()/2)//no of 1s should be exactly half of size\\n                return -1;\\n            totalMoves=min(diff1,diff2)/2;//half of min of total diffs from either Requiredconfig\\n\\t\\t\\t\\n            //calc no of required row swaps (similar to column swaps)\\n            if(sumConfig2!=board.size()/2)\\n                return -1;\\n            totalMoves+=min(diff3,diff4)/2; \\n        }\\n        else //odd size\\n        { \\n             //calc no of required column swaps\\n            //no of 1s should be exactly half of size or 1 greater\\n            if(sumConfig1!=board.size()/2&&sumConfig1!=board.size()/2+1)\\n                return -1;\\n            //if(no of 0s greater thann no of 1s) required swaps =half of diffs from RequiredConfig1\\n            if(sumConfig1==board.size()/2)\\n              totalMoves=diff1/2;\\n            else               //else half of diffs from RequiredConfig2\\n              totalMoves=diff2/2;\\n\\t\\t\\t  \\n             //calc no of required row swaps (similar to row swaps)\\n            if(sumConfig2!=board.size()/2&&sumConfig2!=board.size()/2+1)\\n                return -1;\\n            if(sumConfig2==board.size()/2)\\n              totalMoves+=diff3/2;\\n            else\\n              totalMoves+=diff4/2;\\n        }\\n        return totalMoves; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    enum{COL,ROW};\\n    int addedXOR(vector<vector<int>>& board,int orientation,int index)\\n    {\\n        int res=0;\\n        if(orientation==COL)\\n            for(int i=0;i<board.size();i++)\\n              res+=board[i][index]^board[i][index+1];\\n        else if(orientation==ROW)\\n            for(int i=0;i<board.size();i++)\\n                res+=board[index][i]^board[index+1][i];\\n        return res;\\n    }\\n    \\n    \\n    int movesToChessboard(vector<vector<int>>& board) \\n    {\\n        int totalMoves;\\n        int RequiredConfig1[board.size()],RequiredConfig2[board.size()];\\n        //generate 2 possible config of size N(ex:N=5 RequiredConfig1=01010 RequiredConfig2=10101)\\n        RequiredConfig1[0]=0;RequiredConfig2[0]=1;\\n        for(int i=1;i<board.size();i++)\\n        {\\n             RequiredConfig1[i]= RequiredConfig1[i-1]^1;\\n             RequiredConfig2[i]= RequiredConfig2[i-1]^1;\\n        }\\n        //check if valid(ADAJCENT ROWS AND COLUMNS SHOULD BE ALL SAME OR ALL DIFFERENT)\\n        for(int i=0;i<board.size()-1;i++)\\n        {\\n            int res=addedXOR(board,COL,i);\\n            if(res!=0&&res!=board.size())\\n                return -1;\\n            \\n            res=addedXOR(board,ROW,i);\\n            if(res!=0&&res!=board.size())\\n                return -1;           \\n        }\\n        //get for 1st row and 1stcolumn(no of 1s,total diffs with 1st and 2nd RequiredConfig)\\n        int sumConfig1=0,sumConfig2=0,diff1=0,diff2=0,diff3=0,diff4=0;\\n        for(int i=0;i<board.size();i++)\\n        {\\n           sumConfig1+=board[0][i];\\n           diff1+=RequiredConfig1[i]^board[0][i];\\n           diff2+=RequiredConfig2[i]^board[0][i];\\n           sumConfig2+=board[i][0]; \\n           diff3+=RequiredConfig1[i]^board[i][0];\\n           diff4+=RequiredConfig2[i]^board[i][0];  \\n        }\\n        //handle saperately for even size and odd size\\n        if(!(board.size()%2))//even size\\n        {\\n            //calc no of required column swaps\\n            if(sumConfig1!=board.size()/2)//no of 1s should be exactly half of size\\n                return -1;\\n            totalMoves=min(diff1,diff2)/2;//half of min of total diffs from either Requiredconfig\\n\\t\\t\\t\\n            //calc no of required row swaps (similar to column swaps)\\n            if(sumConfig2!=board.size()/2)\\n                return -1;\\n            totalMoves+=min(diff3,diff4)/2; \\n        }\\n        else //odd size\\n        { \\n             //calc no of required column swaps\\n            //no of 1s should be exactly half of size or 1 greater\\n            if(sumConfig1!=board.size()/2&&sumConfig1!=board.size()/2+1)\\n                return -1;\\n            //if(no of 0s greater thann no of 1s) required swaps =half of diffs from RequiredConfig1\\n            if(sumConfig1==board.size()/2)\\n              totalMoves=diff1/2;\\n            else               //else half of diffs from RequiredConfig2\\n              totalMoves=diff2/2;\\n\\t\\t\\t  \\n             //calc no of required row swaps (similar to row swaps)\\n            if(sumConfig2!=board.size()/2&&sumConfig2!=board.size()/2+1)\\n                return -1;\\n            if(sumConfig2==board.size()/2)\\n              totalMoves+=diff3/2;\\n            else\\n              totalMoves+=diff4/2;\\n        }\\n        return totalMoves; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675694,
                "title": "java-xor-check",
                "content": "Ref:https://leetcode.com/problems/transform-to-chessboard/discuss/114847/C%2B%2BJavaPython-Solution-with-Explanation\\n```\\npublic int movesToChessboard(int[][] bd) {\\n        int n = bd.length, rs = 0, cs = 0, ro = 0, co = 0;;\\n        for (int i = 0; i < n; i++) {\\n            co += bd[0][i];\\n            ro += bd[i][0];\\n            if (bd[0][i] != i % 2) cs++;\\n            if (bd[i][0] != i % 2) rs++;\\n            for (int j = 0; j < n; j++) {\\n                if ((bd[0][0] ^ bd[i][0] ^ bd[0][j] ^ bd[i][j]) > 0) return -1; //must be 4 zeros or 2 ones 2 zeros or 4 ones.\\n            }\\n        }\\n        if (co != n / 2 && co != (n + 1) / 2 ) return - 1;\\n        if (ro != n / 2 && ro != (n + 1) / 2 ) return - 1;\\n        if (n % 2 == 1) {\\n            if (rs % 2 == 1) rs = n - rs;\\n            if (cs % 2 == 1) cs = n - cs;\\n        } else {\\n            rs = Math.min(rs, n - rs);\\n            cs = Math.min(cs, n - cs);\\n        }\\n        return (rs + cs) / 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int movesToChessboard(int[][] bd) {\\n        int n = bd.length, rs = 0, cs = 0, ro = 0, co = 0;;\\n        for (int i = 0; i < n; i++) {\\n            co += bd[0][i];\\n            ro += bd[i][0];\\n            if (bd[0][i] != i % 2) cs++;\\n            if (bd[i][0] != i % 2) rs++;\\n            for (int j = 0; j < n; j++) {\\n                if ((bd[0][0] ^ bd[i][0] ^ bd[0][j] ^ bd[i][j]) > 0) return -1; //must be 4 zeros or 2 ones 2 zeros or 4 ones.\\n            }\\n        }\\n        if (co != n / 2 && co != (n + 1) / 2 ) return - 1;\\n        if (ro != n / 2 && ro != (n + 1) / 2 ) return - 1;\\n        if (n % 2 == 1) {\\n            if (rs % 2 == 1) rs = n - rs;\\n            if (cs % 2 == 1) cs = n - cs;\\n        } else {\\n            rs = Math.min(rs, n - rs);\\n            cs = Math.min(cs, n - cs);\\n        }\\n        return (rs + cs) / 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488268,
                "title": "python3-four-rounds-of-check-before-counting-min-number-of-swaps",
                "content": "```\\nclass Solution:\\n    def build_pat(self, lst: List[int]) -> int:\\n        \"\"\"Build a pattern out of a given list of 1s and 0s\"\"\"\\n        n = len(lst)\\n        pat = 0\\n        for i in range(n):\\n            pat |= (lst[i] << (n - i - 1))\\n        return pat\\n\\n    def count_swap(self, pat: int, val1: int, val2: int) -> int:\\n        \"\"\"Count the min number of swaps to go from pat to either val1 or val2.\\n\\n        Note that the number of 1s in the result of XOR must be even for swap\\n        to be possible\\n\\n        :param pat: The current pattern.\\n        :param val1: One of the valid final pattern on the chessboard.\\n        :param val2: The other valid final pattern on the chessboard.\\n        \"\"\"\\n        swap1 = bin(pat ^ val1).count(\\'1\\')\\n        swap2 = bin(pat ^ val2).count(\\'1\\')\\n        return min(\\n            swap1 if swap1 % 2 == 0 else math.inf,\\n            swap2 if swap2 % 2 == 0 else math.inf,\\n        ) // 2\\n\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        \"\"\"LeetCode 782\\n\\n        This problem is not difficult in terms of using some smart algorithm.\\n        But it is complex because there are a lot of tricks to go through to\\n        help one realize that this problem does not require smart algorithm.\\n\\n        First, we identify that to make a chessboard possible, each row must\\n        have equal number of 1s and 0s or the number of one value only one larger.\\n        If this requirement is not satisfied, we can return -1 immediately.\\n\\n        Second, among all the rows, there must only be two patterns. This is\\n        because in the final chessboard, there are only two patterns for all the\\n        rows. Since swapping columns do not add or minus row patterns, we must\\n        start with two row patterns.\\n\\n        Third, the two row patterns must complement each other. Otherwise, there\\n        must exist some swap on one row that will have no effect on the other\\n        row. e.g. pat1 = 0110, pat2 = 0010. Swapping the first two element of\\n        pat1 will not change pat2, which means we cannot make both patterns\\n        correct at the same time. This requirement can translate to pat1 ^ pat2\\n        == (1 << n) - 1\\n\\n        Fourth, the number of each row pattern must be equal or differ only by\\n        one.\\n\\n        Interestingly, once the rows satisfy the above-mentioned four requirements\\n        the cols automatically also become valid. Then, we just need to find\\n        the min number of moves to swap the rows and the cols. Add them together,\\n        and we have the result. To find the min number of swaps, we create masks\\n        for the two valid final state val1, val2. We only need to check for one\\n        of the row and col pattern. We use XOR and then count the number of 1s\\n        in the result. The number of 1s indicate the number of mismatches\\n        between the current pattern and the valid pattern. Also, the number of\\n        1s must be even, because each pair of 1s indicate a swap. Odd number of\\n        1s doesn\\'t work.\\n\\n        O(N^2) time complexity. 76 ms, 88% ranking.\\n        \"\"\"\\n        n = len(board)\\n        counter = Counter()\\n        mask = (1 << n) - 1\\n        for row in board:\\n            one_count = row.count(1)\\n            if abs(one_count - (n - one_count)) > 1:\\n                return -1\\n            counter[self.build_pat(row)] += 1\\n        if len(counter) != 2:\\n            return -1\\n        pat1, pat2 = counter.keys()\\n        if pat1 ^ pat2 != mask:\\n            return -1\\n        if abs(counter[pat1] - counter[pat2]) > 1:\\n            return -1\\n        # At this point, we are certain that the chessboard can be created.\\n        \\n        # Obtain the two valid states for each row and col\\n        val1 = 0\\n        for i in range(n - 1, -1, -2):\\n            val1 |= (1 << i)\\n        val2 = val1 ^ mask\\n        return self.count_swap(pat1, val1, val2) + self.count_swap(\\n            self.build_pat([board[i][0] for i in range(n)]),\\n            val1,\\n            val2,\\n        )\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def build_pat(self, lst: List[int]) -> int:\\n        \"\"\"Build a pattern out of a given list of 1s and 0s\"\"\"\\n        n = len(lst)\\n        pat = 0\\n        for i in range(n):\\n            pat |= (lst[i] << (n - i - 1))\\n        return pat\\n\\n    def count_swap(self, pat: int, val1: int, val2: int) -> int:\\n        \"\"\"Count the min number of swaps to go from pat to either val1 or val2.\\n\\n        Note that the number of 1s in the result of XOR must be even for swap\\n        to be possible\\n\\n        :param pat: The current pattern.\\n        :param val1: One of the valid final pattern on the chessboard.\\n        :param val2: The other valid final pattern on the chessboard.\\n        \"\"\"\\n        swap1 = bin(pat ^ val1).count(\\'1\\')\\n        swap2 = bin(pat ^ val2).count(\\'1\\')\\n        return min(\\n            swap1 if swap1 % 2 == 0 else math.inf,\\n            swap2 if swap2 % 2 == 0 else math.inf,\\n        ) // 2\\n\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        \"\"\"LeetCode 782\\n\\n        This problem is not difficult in terms of using some smart algorithm.\\n        But it is complex because there are a lot of tricks to go through to\\n        help one realize that this problem does not require smart algorithm.\\n\\n        First, we identify that to make a chessboard possible, each row must\\n        have equal number of 1s and 0s or the number of one value only one larger.\\n        If this requirement is not satisfied, we can return -1 immediately.\\n\\n        Second, among all the rows, there must only be two patterns. This is\\n        because in the final chessboard, there are only two patterns for all the\\n        rows. Since swapping columns do not add or minus row patterns, we must\\n        start with two row patterns.\\n\\n        Third, the two row patterns must complement each other. Otherwise, there\\n        must exist some swap on one row that will have no effect on the other\\n        row. e.g. pat1 = 0110, pat2 = 0010. Swapping the first two element of\\n        pat1 will not change pat2, which means we cannot make both patterns\\n        correct at the same time. This requirement can translate to pat1 ^ pat2\\n        == (1 << n) - 1\\n\\n        Fourth, the number of each row pattern must be equal or differ only by\\n        one.\\n\\n        Interestingly, once the rows satisfy the above-mentioned four requirements\\n        the cols automatically also become valid. Then, we just need to find\\n        the min number of moves to swap the rows and the cols. Add them together,\\n        and we have the result. To find the min number of swaps, we create masks\\n        for the two valid final state val1, val2. We only need to check for one\\n        of the row and col pattern. We use XOR and then count the number of 1s\\n        in the result. The number of 1s indicate the number of mismatches\\n        between the current pattern and the valid pattern. Also, the number of\\n        1s must be even, because each pair of 1s indicate a swap. Odd number of\\n        1s doesn\\'t work.\\n\\n        O(N^2) time complexity. 76 ms, 88% ranking.\\n        \"\"\"\\n        n = len(board)\\n        counter = Counter()\\n        mask = (1 << n) - 1\\n        for row in board:\\n            one_count = row.count(1)\\n            if abs(one_count - (n - one_count)) > 1:\\n                return -1\\n            counter[self.build_pat(row)] += 1\\n        if len(counter) != 2:\\n            return -1\\n        pat1, pat2 = counter.keys()\\n        if pat1 ^ pat2 != mask:\\n            return -1\\n        if abs(counter[pat1] - counter[pat2]) > 1:\\n            return -1\\n        # At this point, we are certain that the chessboard can be created.\\n        \\n        # Obtain the two valid states for each row and col\\n        val1 = 0\\n        for i in range(n - 1, -1, -2):\\n            val1 |= (1 << i)\\n        val2 = val1 ^ mask\\n        return self.count_swap(pat1, val1, val2) + self.count_swap(\\n            self.build_pat([board[i][0] for i in range(n)]),\\n            val1,\\n            val2,\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487488,
                "title": "c-every-step-explained",
                "content": "This isn\\'t easy to get for me and I hope my code and comment is clear. I think this is a better code readability practice that algo practice.\\nPlease let me know the confusing parts :P\\n```\\nclass Solution {\\npublic:\\n    // Both the column and row swap satisfies the following\\n    // property:\\n    // All the numbers in a row will always be in the same row\\n    // however swapped. The reasoning is simple: row swap will \\n    // keep the positions of the numbers in the same row unchanged\\n    // and column swap will move the number in a same row within\\n    // the row.\\n    // Similarly all the numbers in a same column will always be \\n    // in the same column, however swapped.\\n    // Let\\'s call it \"group-invariant property\" which is vital for\\n    // an efficient solution.\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        // If a board is transformable, there can only be two kind\\n        // of rows: 1. the number order in the row are extactly same\\n        // as in the first row; 2. the number in the row are exactly\\n        // complimentary of the nubmer in the first row at the same\\n        // position. Similar rules also apply to columns. This will\\n        // be notd as the \"complimentary\" property.\\n        // This can be proved by contradictory. Assume there are two\\n        // rows, r1 and r2, in the board where exits two positions p1\\n        // and p2. The numbers in r1 and r2 at position p1 are 1 and 0\\n        // correspondingly and the numbers at position p2 are both 1.\\n        // If the board is transformable, numbers at p2 needs to be\\n        // swapped without affecting the nubmers at p1. And it is not \\n\\t\\t// possible for the elements to move out from r1 or r2 due to \\n\\t\\t// the \"group-invariant property\". Since there are\\n        // only two operations column swap and row swap, they can be\\n        // tried exhaustively. Row swap won\\'t change relative positions\\n        // within two rows so it won\\'t work. Column swap will move numbers\\n        // at p1 togather, so it also cannot be done. If one want to \\n        // swap numbers at position p1 without affecting number at p2,\\n        // similary reasoning can be applied. Thus complimentary property\\n        // is proved.\\n        for (int i = 0; i < n; ++i) {\\n            // If ith row and first row are exactly the same, \\n            // rowComplimentary will be 0, otherwise 1.\\n            int rowComplimentary = board[i][0] ^ board[0][0];\\n            // If ith column and first column are exactly the same, \\n            // colComplimentary will be 0, otherwise 1.\\n            int colComplimentary = board[0][i] ^ board[0][0];\\n            for (int j = 0; j < n; ++j) {\\n                // Check the complimentary property on ith rows.\\n                if ((board[i][j] ^ board[0][j]) != rowComplimentary) {\\n                    return -1;\\n                }\\n                // Check the complimentary property on ith columns.\\n                if ((board[j][i] ^ board[j][0]) != colComplimentary) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // There are two properties\\n        // that will be helpful here:\\n        //     1. row and column are moved independently so the moves need \\n        //        to be added.\\n        //     2. If there are n rows/columns that are mis-placed, each swap\\n        //        can put two of them back to right place, thus the move number\\n        //        will be mis-placed numbers divided by 2.\\n        //     3. Assume all 0s should be put on even position and all 1s\\n        //        should be put on odd positions, the acutual misplaced number\\n        //        will be the smaller one between misplaced-number and\\n        //        N - misplaced-number.\\n        // This section be combined into the first for loop where the complimentary\\n        // property is verified.\\n        int misplacedRowCount = 0;\\n        int misplacedColCount = 0;\\n        int rowComplimentartyCount = 0;\\n        int colComplimentartyCount = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // Count misplaced digit for first row.\\n            int complimentaryRow = board[0][i] ^ board[0][0];\\n            rowComplimentartyCount += complimentaryRow;\\n            misplacedRowCount += complimentaryRow ^ !(i & 1);\\n            // Count misplaced digit for first column.\\n            int complimentaryCol = board[i][0] ^ board[0][0];\\n            colComplimentartyCount += complimentaryCol;\\n            misplacedColCount += complimentaryCol ^ !(i & 1);\\n        }\\n\\n        // When n is even, the move complimentary counts needs to be n/2 and the\\n        // move is easy to count.\\n        if (n % 2 == 0) {\\n            if (rowComplimentartyCount != n/2 || colComplimentartyCount != n/2) {\\n                return -1;\\n            }\\n            return (min(misplacedRowCount, n - misplacedRowCount) / 2 +\\n                    min(misplacedColCount, n - misplacedColCount) / 2);\\n        }\\n        // cout << n << endl << rowComplimentartyCount << \" \" << colComplimentartyCount << \"\\\\n\"\\n             // << misplacedRowCount << \" \" << misplacedColCount << endl << endl;\\n        int move = 0;\\n        if (rowComplimentartyCount == n/2) {\\n            move += (n - misplacedRowCount) / 2;\\n        } else if (rowComplimentartyCount == n/2 + 1) {\\n            move += misplacedRowCount / 2;\\n        } else {\\n            return -1;\\n        }\\n        // cout << \"row \" << move;\\n        if (colComplimentartyCount == n/2) {\\n            move += (n - misplacedColCount) / 2;\\n        } else if (colComplimentartyCount == n/2 + 1) {\\n            move += misplacedColCount / 2;\\n        } else {\\n            return -1;\\n        }\\n        // cout << \". col \" << move << endl;\\n        return move;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // Both the column and row swap satisfies the following\\n    // property:\\n    // All the numbers in a row will always be in the same row\\n    // however swapped. The reasoning is simple: row swap will \\n    // keep the positions of the numbers in the same row unchanged\\n    // and column swap will move the number in a same row within\\n    // the row.\\n    // Similarly all the numbers in a same column will always be \\n    // in the same column, however swapped.\\n    // Let\\'s call it \"group-invariant property\" which is vital for\\n    // an efficient solution.\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        // If a board is transformable, there can only be two kind\\n        // of rows: 1. the number order in the row are extactly same\\n        // as in the first row; 2. the number in the row are exactly\\n        // complimentary of the nubmer in the first row at the same\\n        // position. Similar rules also apply to columns. This will\\n        // be notd as the \"complimentary\" property.\\n        // This can be proved by contradictory. Assume there are two\\n        // rows, r1 and r2, in the board where exits two positions p1\\n        // and p2. The numbers in r1 and r2 at position p1 are 1 and 0\\n        // correspondingly and the numbers at position p2 are both 1.\\n        // If the board is transformable, numbers at p2 needs to be\\n        // swapped without affecting the nubmers at p1. And it is not \\n\\t\\t// possible for the elements to move out from r1 or r2 due to \\n\\t\\t// the \"group-invariant property\". Since there are\\n        // only two operations column swap and row swap, they can be\\n        // tried exhaustively. Row swap won\\'t change relative positions\\n        // within two rows so it won\\'t work. Column swap will move numbers\\n        // at p1 togather, so it also cannot be done. If one want to \\n        // swap numbers at position p1 without affecting number at p2,\\n        // similary reasoning can be applied. Thus complimentary property\\n        // is proved.\\n        for (int i = 0; i < n; ++i) {\\n            // If ith row and first row are exactly the same, \\n            // rowComplimentary will be 0, otherwise 1.\\n            int rowComplimentary = board[i][0] ^ board[0][0];\\n            // If ith column and first column are exactly the same, \\n            // colComplimentary will be 0, otherwise 1.\\n            int colComplimentary = board[0][i] ^ board[0][0];\\n            for (int j = 0; j < n; ++j) {\\n                // Check the complimentary property on ith rows.\\n                if ((board[i][j] ^ board[0][j]) != rowComplimentary) {\\n                    return -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1487010,
                "title": "c-o-n-n-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\t\\tvector<vector<int>> arr;\\n\\n\\t\\tint getRow(vector<int> &v,int x) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tif(v[i]!=x) ans++;\\n\\t\\t\\t\\tx^=1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint calc(vector<vector<int>> &v) {\\n\\t\\t\\tint ans1=0, x=0;\\n\\t\\t\\tfor(int i=0;i<n;i++) if(v[0][i]) x++;\\n\\t\\t\\tif(n%2) {\\n\\t\\t\\t\\tif(x>n/2) x=1; else x=0;\\n\\t\\t\\t\\tans1= getRow(v[0],x);\\n\\t\\t\\t}else ans1= min(getRow(v[0],0),getRow(v[0],1));\\n\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tbool b0= arr[i]==v[0];\\n\\t\\t\\t\\tbool b1= arr[i]==v[1];\\n\\t\\t\\t\\tif(!b0 && !b1) return -1;\\n\\n\\t\\t\\t\\tif(i%2 && b0) ans++;\\n\\t\\t\\t\\telse if(i%2==0 && b1) ans++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(ans%2) return -1;\\n\\t\\t\\treturn ans/2+ans1/2;\\n\\n\\t\\t}\\n\\n\\t\\tint chk() {\\n\\t\\t\\tint c0=0,c1=0;\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tif(arr[0][i]) c1++;\\n\\t\\t\\t\\telse c0++;\\n\\t\\t\\t}\\n\\t\\t\\tif(n%2==0) {\\n\\t\\t\\t\\tif(c0!=c1) return -1;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tif(abs(c0-c1)!=1) return -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<int>> v;\\n\\t\\t\\tvector<int> temp=arr[0];\\n\\t\\t\\tfor(int &i: temp) i^=1;\\n\\t\\t\\tv.push_back(arr[0]);\\n\\t\\t\\tv.push_back(temp);\\n\\t\\t\\tint x= calc(v);\\n\\t\\t\\tswap(v[0],v[1]);\\n\\t\\t\\tint y= calc(v);\\n\\n\\t\\t\\tif(x==-1 && y==-1) return -1;\\n\\t\\t\\tif(x==-1) return y;\\n\\t\\t\\tif(y==-1) return x;\\n\\t\\t\\treturn min(x,y);\\n\\n\\t\\t}\\n\\n\\t\\tint movesToChessboard(vector<vector<int>>& arr) {\\n\\t\\t\\tn= arr.size();\\n\\t\\t\\tthis->arr= arr;\\n\\t\\t\\treturn chk();\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\t\\tvector<vector<int>> arr;\\n\\n\\t\\tint getRow(vector<int> &v,int x) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tif(v[i]!=x) ans++;\\n\\t\\t\\t\\tx^=1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1486892,
                "title": "transform-to-chessboard-c-java-python",
                "content": "**Intuition**:\\nTwo conditions to help solve this problem:\\n\\n1. In a valid chess board, there are 2 and only 2 kinds of rows and one is inverse to the other.\\nFor example if there is a row 01010011 in the board, any other row must be either 01010011 or 10101100.\\nThe same for columns\\nA corollary is that, any rectangle inside the board with corners top left, top right, bottom left, bottom right must be 4 zeros or 2 ones 2 zeros or 4 zeros.\\n\\n2. Another important property is that every row and column has half ones. Assume the board is N * N:\\nIf N = 2*K, every row and every column has K ones and K zeros.\\nIf N = 2*K + 1, every row and every column has K ones and K + 1 zeros or K + 1 ones and K zeros.\\n\\n\\n**Explanation**:\\nSince the swap process does not break this property, for a given board to be valid, this property must hold.\\nThese two conditions are necessary and sufficient condition for a valid chessboard.\\n\\nOnce we know it is a valid cheese board, we start to count swaps.\\nBasic on the property above, when we arange the first row, we are actually moving all columns.\\n\\nI try to arrange one row into 01010 and 10101 and I count the number of swaps.\\n\\nIn case of N even, I take the minimum swaps, because both are possible.\\nIn case of N odd, I take the even swaps.\\nBecause when we make a swap, we move 2 columns or 2 rows at the same time.\\nSo col swaps and row swaps should be same here.\\n\\nC++\\n```    \\nint movesToChessboard(vector<vector<int>>& b) {\\n        int N = b.size(), rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if (b[0][0]^b[i][0]^b[0][j]^b[i][j]) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            rowSwap += b[i][0] == i % 2;\\n            colSwap += b[0][i] == i % 2;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2) {\\n            if (colSwap % 2) colSwap = N - colSwap;\\n            if (rowSwap % 2) rowSwap = N - rowSwap;\\n        }\\n        else {\\n            colSwap = min(N - colSwap, colSwap);\\n            rowSwap = min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\\n\\t\\n\\tJava \\n```\\n\\t    public int movesToChessboard(int[][] b) {\\n        int N = b.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 1) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            if (b[i][0] == i % 2) rowSwap ++;\\n            if (b[0][i] == i % 2) colSwap ++ ;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\\n\\tPython:\\n```\\n\\t    def movesToChessboard(self, b):\\n        N = len(b)\\n        if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1\\n        if not N / 2 <= sum(b[0]) <= (N + 1) / 2: return -1\\n        if not N / 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) / 2: return -1\\n        col = sum(b[0][i] == i % 2 for i in range(N))\\n        row = sum(b[i][0] == i % 2 for i in range(N))\\n        if N % 2:\\n            if col % 2: col = N - col\\n            if row % 2: row = N - row\\n        else:\\n            col = min(N - col, col)\\n            row = min(N - row, row)\\n        return (col + row) / 2\\n```",
                "solutionTags": [],
                "code": "```    \\nint movesToChessboard(vector<vector<int>>& b) {\\n        int N = b.size(), rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if (b[0][0]^b[i][0]^b[0][j]^b[i][j]) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            rowSwap += b[i][0] == i % 2;\\n            colSwap += b[0][i] == i % 2;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2) {\\n            if (colSwap % 2) colSwap = N - colSwap;\\n            if (rowSwap % 2) rowSwap = N - rowSwap;\\n        }\\n        else {\\n            colSwap = min(N - colSwap, colSwap);\\n            rowSwap = min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\n```\\n\\t    public int movesToChessboard(int[][] b) {\\n        int N = b.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 1) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            if (b[i][0] == i % 2) rowSwap ++;\\n            if (b[0][i] == i % 2) colSwap ++ ;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\n```\\n\\t    def movesToChessboard(self, b):\\n        N = len(b)\\n        if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1\\n        if not N / 2 <= sum(b[0]) <= (N + 1) / 2: return -1\\n        if not N / 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) / 2: return -1\\n        col = sum(b[0][i] == i % 2 for i in range(N))\\n        row = sum(b[i][0] == i % 2 for i in range(N))\\n        if N % 2:\\n            if col % 2: col = N - col\\n            if row % 2: row = N - row\\n        else:\\n            col = min(N - col, col)\\n            row = min(N - row, row)\\n        return (col + row) / 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1486873,
                "title": "c-first-check-if-we-can-transform-then-count-the-miss-match-row-and-col",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        \\n        int cnt1 = 1, cnt2 = 0;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            \\n            if (board[0][0] == board[i][0]) {\\n                ++cnt1;\\n                \\n                for (int j = 0; j < n; ++j) {\\n                  if (board[0][j] != board[i][j]) {\\n                        return -1;\\n                    }  \\n                }\\n            } else {\\n                ++cnt2;\\n                \\n                for (int j = 0; j < n; ++j) {\\n                    if (board[0][j] == board[i][j]) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (abs(cnt1 - cnt2) > 1) {\\n            return -1;\\n        }\\n        \\n        cnt1 = 1, cnt2 = 0;\\n        for (int j = 1; j < n; ++j) {\\n            \\n            if (board[0][0] == board[0][j]) {\\n                ++cnt1;\\n                \\n                for (int i = 0; i < n; ++i) {\\n                    if (board[i][0] != board[i][j]) {\\n                        return -1;\\n                    }\\n                }\\n            } else {\\n                ++cnt2;\\n                \\n                for (int i = 0; i < n; ++i) {                      \\n                    if (board[i][0] == board[i][j]) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (abs(cnt1 - cnt2) > 1) {\\n            return -1;\\n        }\\n        \\n        int swapRow = 0, swapCol = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (board[i][0] != i % 2) {\\n                ++swapRow;\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            if (board[0][j] != j % 2) {\\n                ++swapCol;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        if (n & 1) {\\n            if (swapRow & 1) {\\n                swapRow = n - swapRow;\\n            }\\n            \\n            if (swapCol & 1) {\\n                swapCol = n - swapCol;\\n            }\\n            \\n            ans += swapRow / 2;\\n            ans += swapCol / 2;\\n        } else {\\n            ans += min(swapRow, n - swapRow) / 2;\\n            ans += min(swapCol, n - swapCol) / 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        \\n        int cnt1 = 1, cnt2 = 0;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            \\n            if (board[0][0] == board[i][0]) {\\n                ++cnt1;\\n                \\n                for (int j = 0; j < n; ++j) {\\n                  if (board[0][j] != board[i][j]) {\\n                        return -1;\\n                    }  \\n                }\\n            } else {\\n                ++cnt2;\\n                \\n                for (int j = 0; j < n; ++j) {\\n                    if (board[0][j] == board[i][j]) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (abs(cnt1 - cnt2) > 1) {\\n            return -1;\\n        }\\n        \\n        cnt1 = 1, cnt2 = 0;\\n        for (int j = 1; j < n; ++j) {\\n            \\n            if (board[0][0] == board[0][j]) {\\n                ++cnt1;\\n                \\n                for (int i = 0; i < n; ++i) {\\n                    if (board[i][0] != board[i][j]) {\\n                        return -1;\\n                    }\\n                }\\n            } else {\\n                ++cnt2;\\n                \\n                for (int i = 0; i < n; ++i) {                      \\n                    if (board[i][0] == board[i][j]) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (abs(cnt1 - cnt2) > 1) {\\n            return -1;\\n        }\\n        \\n        int swapRow = 0, swapCol = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (board[i][0] != i % 2) {\\n                ++swapRow;\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            if (board[0][j] != j % 2) {\\n                ++swapCol;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        if (n & 1) {\\n            if (swapRow & 1) {\\n                swapRow = n - swapRow;\\n            }\\n            \\n            if (swapCol & 1) {\\n                swapCol = n - swapCol;\\n            }\\n            \\n            ans += swapRow / 2;\\n            ans += swapCol / 2;\\n        } else {\\n            ans += min(swapRow, n - swapRow) / 2;\\n            ans += min(swapCol, n - swapCol) / 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366011,
                "title": "c-solution-with-comments",
                "content": "```\\nint isRawSame(const vector<vector<int>> &vec, const int &a, const int &b){\\n    for (int col=0; col<vec[a].size(); ++col) {\\n        if (vec[a][col] != vec[b][col]) {return false;}\\n    }\\n    return true;\\n}\\n\\n// Find the min number of swaping of vec to fit ans1 {0, 1, 0, 1, .....} or ans2 {1, 0, 1, 0, .....}.\\nint minSwap(const vector<int> &vec){\\n    int ans1 = 0;\\n    int ans2 = 0;\\n    for (int i=0; i<vec.size(); ++i) {\\n        if (vec[i] != i % 2) {++ans1;} // {0, 1, 0, 1, .....}\\n        if (vec[i] != (i + 1) % 2) {++ans2;} // {1, 0, 1, 0, .....}\\n    }\\n    \\n    // If ans1 and ans2 are valid, they must be EVEN.\\n    if (ans1 % 2 != 0) {\\n        return ans2 / 2;\\n    }else if (ans2 % 2 != 0) {\\n        return ans1 / 2;\\n    }else{\\n        return min(ans1 / 2, ans2 / 2);\\n    }\\n    \\n}\\n\\n// The size of difference of vec is smaller 1, the vec is valid.\\n// The value of vec must be 0 or 1\\nint isValid(const vector<int> &vec){\\n    int c1 = 0;\\n    int c2 = 0;\\n    for (const auto &v : vec) {\\n        v == 0 ? ++c1 : ++c2;\\n    }\\n    return abs(c1 - c2) <= 1;\\n}\\n\\nint findRawDiff(const vector<vector<int>> &board, vector<int> &diffRaw, vector<int> &raw){\\n    diffRaw.push_back(0);\\n    for (int i=1; i<board.size(); ++i) {\\n        int d = 0;\\n        \\n        for (d=0; d<diffRaw.size(); ++d) {\\n            if ( isRawSame(board, i, diffRaw[d]) ){break;}\\n        }\\n        \\n        // If d > 1, d is not valid.\\n        if (d > 1) {\\n            return -1;\\n        }else if (d == diffRaw.size()) {\\n            diffRaw.push_back(i);\\n        }\\n        \\n        raw[i] = d;\\n    }\\n    \\n    return 1;\\n}\\n\\nint movesToChessboard(vector<vector<int>>& board) {\\n    const int size = static_cast<int>(board.size());\\n    \\n    // 1. Check if the raw and col of board is same and record corresponding index to diff.\\n    vector<int> raw(size, 0);\\n    vector<int> col(size, 0);\\n    vector<int> diffRaw;\\n    vector<int> diffCol;\\n    \\n    // 1.1 Find the difference of raw\\n    if (findRawDiff(board, diffRaw, raw) == -1) {return -1;}\\n    \\n    // 1.2 Transpose (raw <-> col)\\n    vector<vector<int>> tBoard(size, vector<int>(size));\\n    for (int i = 0; i < board.size(); ++i) {\\n        for (int j = 0; j < board.size(); ++j) {\\n            tBoard[j][i] =  board[i][j];\\n        }\\n    }\\n    \\n    // 1.3 Find the difference of col\\n    if (findRawDiff(tBoard, diffCol, col) == -1) {return -1;}\\n    \\n    // 1.4 If the size of the difference type is 2 or the size of difference of raws / cols is smaller than 1, the vector is valid.\\n    if (diffRaw.size() != 2 || diffCol.size() != 2 || !isValid(raw) || !isValid(col)) {return -1;}\\n    \\n    // 2. Return min number of swapping\\n    return minSwap(raw) + minSwap(col);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint isRawSame(const vector<vector<int>> &vec, const int &a, const int &b){\\n    for (int col=0; col<vec[a].size(); ++col) {\\n        if (vec[a][col] != vec[b][col]) {return false;}\\n    }\\n    return true;\\n}\\n\\n// Find the min number of swaping of vec to fit ans1 {0, 1, 0, 1, .....} or ans2 {1, 0, 1, 0, .....}.\\nint minSwap(const vector<int> &vec){\\n    int ans1 = 0;\\n    int ans2 = 0;\\n    for (int i=0; i<vec.size(); ++i) {\\n        if (vec[i] != i % 2) {++ans1;} // {0, 1, 0, 1, .....}\\n        if (vec[i] != (i + 1) % 2) {++ans2;} // {1, 0, 1, 0, .....}\\n    }\\n    \\n    // If ans1 and ans2 are valid, they must be EVEN.\\n    if (ans1 % 2 != 0) {\\n        return ans2 / 2;\\n    }else if (ans2 % 2 != 0) {\\n        return ans1 / 2;\\n    }else{\\n        return min(ans1 / 2, ans2 / 2);\\n    }\\n    \\n}\\n\\n// The size of difference of vec is smaller 1, the vec is valid.\\n// The value of vec must be 0 or 1\\nint isValid(const vector<int> &vec){\\n    int c1 = 0;\\n    int c2 = 0;\\n    for (const auto &v : vec) {\\n        v == 0 ? ++c1 : ++c2;\\n    }\\n    return abs(c1 - c2) <= 1;\\n}\\n\\nint findRawDiff(const vector<vector<int>> &board, vector<int> &diffRaw, vector<int> &raw){\\n    diffRaw.push_back(0);\\n    for (int i=1; i<board.size(); ++i) {\\n        int d = 0;\\n        \\n        for (d=0; d<diffRaw.size(); ++d) {\\n            if ( isRawSame(board, i, diffRaw[d]) ){break;}\\n        }\\n        \\n        // If d > 1, d is not valid.\\n        if (d > 1) {\\n            return -1;\\n        }else if (d == diffRaw.size()) {\\n            diffRaw.push_back(i);\\n        }\\n        \\n        raw[i] = d;\\n    }\\n    \\n    return 1;\\n}\\n\\nint movesToChessboard(vector<vector<int>>& board) {\\n    const int size = static_cast<int>(board.size());\\n    \\n    // 1. Check if the raw and col of board is same and record corresponding index to diff.\\n    vector<int> raw(size, 0);\\n    vector<int> col(size, 0);\\n    vector<int> diffRaw;\\n    vector<int> diffCol;\\n    \\n    // 1.1 Find the difference of raw\\n    if (findRawDiff(board, diffRaw, raw) == -1) {return -1;}\\n    \\n    // 1.2 Transpose (raw <-> col)\\n    vector<vector<int>> tBoard(size, vector<int>(size));\\n    for (int i = 0; i < board.size(); ++i) {\\n        for (int j = 0; j < board.size(); ++j) {\\n            tBoard[j][i] =  board[i][j];\\n        }\\n    }\\n    \\n    // 1.3 Find the difference of col\\n    if (findRawDiff(tBoard, diffCol, col) == -1) {return -1;}\\n    \\n    // 1.4 If the size of the difference type is 2 or the size of difference of raws / cols is smaller than 1, the vector is valid.\\n    if (diffRaw.size() != 2 || diffCol.size() != 2 || !isValid(raw) || !isValid(col)) {return -1;}\\n    \\n    // 2. Return min number of swapping\\n    return minSwap(raw) + minSwap(col);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992335,
                "title": "compress-rows-columns",
                "content": "Since bounds are small, the rows/columns can be compressed into vectors.\\n\\nEach of the two vectors should contain exactly two type of values, \\none with cardinality n/2, the other with n-n/2. And each value has\\nn/2 or n-n/2 bit set.\\n\\nThe rows and columns can be manipulated independently: a swap in a row\\ndoesn\\'t affect the column order (the column values are affected, but the\\npattern/ordering and the cardinality stays the same).\\nSo we can check the vectors individually for mismatches against the expected ordering.\\n\\n```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int n = board.length, ans = 0;\\n        var pats = new long[2][n];\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                pats[0][i] = pats[0][i]*2+board[i][j];\\n                pats[1][j] = pats[1][j]*2+board[i][j];\\n            }\\n        }\\n        for(var pat : pats){\\n            var tiles = new Long[]{-1L,-1L};\\n            long cntMax = 0;\\n            for(long v : pat){\\n                if (tiles[1] == -1 || tiles[1] == v){\\n                    ++cntMax;\\n                    tiles[1] = v;\\n                } else {\\n                    if (!(tiles[0] == -1 || tiles[0] == v)) return -1;\\n                    tiles[0] = v;\\n                }\\n            }\\n            if (cntMax < n-cntMax) {\\n                Collections.swap(Arrays.asList(tiles),0,1);\\n                cntMax = n-cntMax;\\n            }\\n            if (cntMax != n-n/2) return -1;\\n            int mism = 0;\\n            for(int a = 1, i = 0; i < n; ++i, a^=1){\\n                mism += tiles[a] == pat[i] ? 0 : 1;\\n            }\\n            ans += (n%2 == 1 ? mism : Math.min((n-mism),mism))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int n = board.length, ans = 0;\\n        var pats = new long[2][n];\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                pats[0][i] = pats[0][i]*2+board[i][j];\\n                pats[1][j] = pats[1][j]*2+board[i][j];\\n            }\\n        }\\n        for(var pat : pats){\\n            var tiles = new Long[]{-1L,-1L};\\n            long cntMax = 0;\\n            for(long v : pat){\\n                if (tiles[1] == -1 || tiles[1] == v){\\n                    ++cntMax;\\n                    tiles[1] = v;\\n                } else {\\n                    if (!(tiles[0] == -1 || tiles[0] == v)) return -1;\\n                    tiles[0] = v;\\n                }\\n            }\\n            if (cntMax < n-cntMax) {\\n                Collections.swap(Arrays.asList(tiles),0,1);\\n                cntMax = n-cntMax;\\n            }\\n            if (cntMax != n-n/2) return -1;\\n            int mism = 0;\\n            for(int a = 1, i = 0; i < n; ++i, a^=1){\\n                mism += tiles[a] == pat[i] ? 0 : 1;\\n            }\\n            ans += (n%2 == 1 ? mism : Math.min((n-mism),mism))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562868,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private int Helper(int[] rows, int[] rowPatterns, int[] columnPatterns, int n, int m)\\n        {\\n            int rowSwaps = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (rows[i] != rowPatterns[i & 1])\\n                {\\n                    rowSwaps++;\\n                }\\n            }\\n\\n            if ((rowSwaps & 1) == 1)\\n            {\\n                return int.MaxValue;\\n            }\\n\\n            int colSwaps = 0;\\n            for (int j = 0; j < m; j++)\\n            {\\n                var bit = (rowPatterns[0] & (1 << j)) >> j;\\n                if (bit != columnPatterns[j & 1])\\n                {\\n                    colSwaps++;\\n                }\\n            }\\n\\n            if ((colSwaps & 1) == 1)\\n            {\\n                return int.MaxValue;\\n            }\\n\\n            rowSwaps /= 2;\\n            colSwaps /= 2;\\n\\n            return rowSwaps + colSwaps;\\n        }\\n\\n        public int MovesToChessboard(int[][] board)\\n        {\\n            int n = board.Length;\\n            int m = board[0].Length;\\n\\n            int[] rows = new int[n];\\n            IDictionary<int, int> row2Count = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int row = 0;\\n                for (int j = 0; j < m; j++)\\n                {\\n                    row |= (board[i][j] << j);\\n                }\\n\\n                if (!row2Count.ContainsKey(row))\\n                {\\n                    row2Count[row] = 0;\\n                }\\n\\n                row2Count[row]++;\\n                rows[i] = row;\\n            }\\n\\n            if (row2Count.Count != 2)\\n            {\\n                return -1;\\n            }\\n\\n            int[] rowPatterns = new int[2];\\n            rowPatterns[0] = row2Count.First().Key;\\n            rowPatterns[1] = rowPatterns[0];\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                rowPatterns[1] ^= (1 << j);\\n            }\\n\\n            if (!row2Count.ContainsKey(rowPatterns[1]))\\n            {\\n                return -1;\\n            }\\n\\n            if ((n & 1) == 1 && Math.Abs(row2Count[rowPatterns[0]] - row2Count[rowPatterns[1]]) != 1)\\n            {\\n                return -1;\\n            }\\n\\n            if ((n & 1) == 0 && row2Count[rowPatterns[0]] != row2Count[rowPatterns[1]])\\n            {\\n                return -1;\\n            }\\n            \\n            int[] bitsCount = new int[2];\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                var bit = (rowPatterns[0] & (1 << j)) >> j;\\n                bitsCount[bit]++;\\n            }\\n\\n            if ((m & 1) == 1 && Math.Abs(bitsCount[0] - bitsCount[1]) != 1)\\n            {\\n                return -1;\\n            }\\n\\n            if ((m & 1) == 0 && bitsCount[0] != bitsCount[1])\\n            {\\n                return -1;\\n            }\\n\\n\\n            int res = int.MaxValue;\\n\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] {0, 1}, n, m));\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 1, 0 }, n, m));\\n\\n            var tmp = rowPatterns[0];\\n            rowPatterns[0] = rowPatterns[1];\\n            rowPatterns[1] = tmp;\\n\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 0, 1 }, n, m));\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 1, 0 }, n, m));\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private int Helper(int[] rows, int[] rowPatterns, int[] columnPatterns, int n, int m)\\n        {\\n            int rowSwaps = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (rows[i] != rowPatterns[i & 1])\\n                {\\n                    rowSwaps++;\\n                }\\n            }\\n\\n            if ((rowSwaps & 1) == 1)\\n            {\\n                return int.MaxValue;\\n            }\\n\\n            int colSwaps = 0;\\n            for (int j = 0; j < m; j++)\\n            {\\n                var bit = (rowPatterns[0] & (1 << j)) >> j;\\n                if (bit != columnPatterns[j & 1])\\n                {\\n                    colSwaps++;\\n                }\\n            }\\n\\n            if ((colSwaps & 1) == 1)\\n            {\\n                return int.MaxValue;\\n            }\\n\\n            rowSwaps /= 2;\\n            colSwaps /= 2;\\n\\n            return rowSwaps + colSwaps;\\n        }\\n\\n        public int MovesToChessboard(int[][] board)\\n        {\\n            int n = board.Length;\\n            int m = board[0].Length;\\n\\n            int[] rows = new int[n];\\n            IDictionary<int, int> row2Count = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                int row = 0;\\n                for (int j = 0; j < m; j++)\\n                {\\n                    row |= (board[i][j] << j);\\n                }\\n\\n                if (!row2Count.ContainsKey(row))\\n                {\\n                    row2Count[row] = 0;\\n                }\\n\\n                row2Count[row]++;\\n                rows[i] = row;\\n            }\\n\\n            if (row2Count.Count != 2)\\n            {\\n                return -1;\\n            }\\n\\n            int[] rowPatterns = new int[2];\\n            rowPatterns[0] = row2Count.First().Key;\\n            rowPatterns[1] = rowPatterns[0];\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                rowPatterns[1] ^= (1 << j);\\n            }\\n\\n            if (!row2Count.ContainsKey(rowPatterns[1]))\\n            {\\n                return -1;\\n            }\\n\\n            if ((n & 1) == 1 && Math.Abs(row2Count[rowPatterns[0]] - row2Count[rowPatterns[1]]) != 1)\\n            {\\n                return -1;\\n            }\\n\\n            if ((n & 1) == 0 && row2Count[rowPatterns[0]] != row2Count[rowPatterns[1]])\\n            {\\n                return -1;\\n            }\\n            \\n            int[] bitsCount = new int[2];\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                var bit = (rowPatterns[0] & (1 << j)) >> j;\\n                bitsCount[bit]++;\\n            }\\n\\n            if ((m & 1) == 1 && Math.Abs(bitsCount[0] - bitsCount[1]) != 1)\\n            {\\n                return -1;\\n            }\\n\\n            if ((m & 1) == 0 && bitsCount[0] != bitsCount[1])\\n            {\\n                return -1;\\n            }\\n\\n\\n            int res = int.MaxValue;\\n\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] {0, 1}, n, m));\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 1, 0 }, n, m));\\n\\n            var tmp = rowPatterns[0];\\n            rowPatterns[0] = rowPatterns[1];\\n            rowPatterns[1] = tmp;\\n\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 0, 1 }, n, m));\\n            res = Math.Min(res, Helper(rows, rowPatterns, new[] { 1, 0 }, n, m));\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115613,
                "title": "c-o-n-2-time-solution-with-explantion",
                "content": "Two rows are either the same or have opposite contents. This is equivalent to each 2x2 square has xor sum equal to zero. Then we need to move rows so that two rows that are the same either occupie all even positions or all odd positions. Do the same for columns.\n```\nclass Solution {\npublic:\n    int cal(vector<int> &v) {\n        int n = v.size();\n        int odd = 0, even = 0;\n        for (int i = 0; i < v.size(); ++i) if (v[i]) {\n            if (i & 1) ++odd;\n            else ++even;\n        }\n        if (abs(odd*2 + even*2 - n) > 1) return -n;\n        if (n & 1) {\n            if (odd + even > n/2) return odd;\n            return even;\n        }\n        return min(odd,even);\n    }\n    \n    int movesToChessboard(vector<vector<int>>& b) {\n        int n = b.size();\n        for (int i = 1; i < n; ++i) {\n            for (int j = 1; j < n; ++j)\n                if (b[i][j] ^ b[i-1][j] ^ b[i][j-1] ^ b[i-1][j-1]) return -1;\n        }\n        vector<int> c;\n        for (int i = 0; i < n;++i) c.push_back(b[i][0]);\n        return max(cal(b[0]) + cal(c),-1);\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int cal(vector<int> &v) {\n        int n = v.size();\n        int odd = 0, even = 0;\n        for (int i = 0; i < v.size(); ++i) if (v[i]) {\n            if (i & 1) ++odd;\n            else ++even;\n        }\n        if (abs(odd*2 + even*2 - n) > 1) return -n;\n        if (n & 1) {\n            if (odd + even > n/2) return odd;\n            return even;\n        }\n        return min(odd,even);\n    }\n    \n    int movesToChessboard(vector<vector<int>>& b) {\n        int n = b.size();\n        for (int i = 1; i < n; ++i) {\n            for (int j = 1; j < n; ++j)\n                if (b[i][j] ^ b[i-1][j] ^ b[i][j-1] ^ b[i-1][j-1]) return -1;\n        }\n        vector<int> c;\n        for (int i = 0; i < n;++i) c.push_back(b[i][0]);\n        return max(cal(b[0]) + cal(c),-1);\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 114850,
                "title": "java-a-lot-of-bit-operations",
                "content": "    int n = 0, mask = 0, p0 = 0xAAAAAAAA, p1 = 0x55555555;\\n    public int movesToChessboard(int[][] board) {\\n        n = board.length; // the size\\n        mask = (1 << n) - 1; // the mask, for example: 11111 for n = 5\\n        p0 &= mask; // the chessboard line ending with 0, for example: 01010 for n = 5\\n        p1 &= mask; // the chessboard line ending with 1, for example: 10101 for n = 5\\n        \\n        int[] rows = new int[n], cols = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++)\\n                if (board[i][j] == 1) {\\n                    rows[i] |= 1 << j;\\n                    cols[j] |= 1 << i;\\n                }\\n        }\\n        int m1 = minSwap(rows), m2 = minSwap(cols);\\n        return m1 == -1 || m2 == -1 ? -1 : m1 + m2;\\n    }\\n    \\n    private int minSwap(int[] nums) {\\n        int first = nums[0];\\n        for(int x : nums)\\n            if (x != first && (x + first) != mask)\\n                return -1;\\n        \\n        int m = Integer.bitCount(first);\\n        if ((n % 2) == 0) {\\n            if (m == n/2)\\n                return Math.min(Integer.bitCount(first ^ p0), Integer.bitCount(first ^ p1)) / 2;\\n        } else {\\n            if (m == n/2)\\n                return Integer.bitCount(first ^ p0) / 2;\\n            else if (m == n/2 + 1)\\n                return Integer.bitCount(first ^ p1) / 2;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "    int n = 0, mask = 0, p0 = 0xAAAAAAAA, p1 = 0x55555555;\\n    public int movesToChessboard(int[][] board) {\\n        n = board.length; // the size\\n        mask = (1 << n) - 1; // the mask, for example: 11111 for n = 5\\n        p0 &= mask; // the chessboard line ending with 0, for example: 01010 for n = 5\\n        p1 &= mask; // the chessboard line ending with 1, for example: 10101 for n = 5\\n        \\n        int[] rows = new int[n], cols = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++)\\n                if (board[i][j] == 1) {\\n                    rows[i] |= 1 << j;\\n                    cols[j] |= 1 << i;\\n                }\\n        }\\n        int m1 = minSwap(rows), m2 = minSwap(cols);\\n        return m1 == -1 || m2 == -1 ? -1 : m1 + m2;\\n    }\\n    \\n    private int minSwap(int[] nums) {\\n        int first = nums[0];\\n        for(int x : nums)\\n            if (x != first && (x + first) != mask)\\n                return -1;\\n        \\n        int m = Integer.bitCount(first);\\n        if ((n % 2) == 0) {\\n            if (m == n/2)\\n                return Math.min(Integer.bitCount(first ^ p0), Integer.bitCount(first ^ p1)) / 2;\\n        } else {\\n            if (m == n/2)\\n                return Integer.bitCount(first ^ p0) / 2;\\n            else if (m == n/2 + 1)\\n                return Integer.bitCount(first ^ p1) / 2;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 114841,
                "title": "c-swapping-rows-and-cols-while-fixing-the-color-of-first-element",
                "content": "We see that we can swap column and rows independently. So we can make sure first row and first column are in the correct order and then just ```verify``` whether the rest of the board is valid. While doing this we can count minimum possible swaps in rows and cols to achieve this state.\\nThe only thing that can vary is the definition of ```black``` which can either be ```0``` or ```1```.\\n\\n```\\nvoid swap_cols(vector<vector<int>> &board, int c1, int c2){\\n        int n = board.size();\\n        for(int i=0;i<n;i++){\\n            swap(board[i][c1], board[i][c2]);\\n        }\\n    }\\n    \\n    void swap_rows(vector<vector<int>> &board, int r1, int r2){\\n        int n = board.size();\\n        for(int i=0;i<n;i++){\\n            swap(board[r1][i], board[r2][i]);\\n        }\\n    }\\n    \\n    bool verify(vector<vector<int>> &board){\\n        int n = board.size();\\n        int b = board[0][0];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if((i+j)%2 == 0 && board[i][j] != b) return false;\\n                if((i+j)%2 != 0 && board[i][j] == b) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int can_cols_swap(vector<vector<int>> board, int black){\\n        int n = board.size();\\n        vector<int> blks, whites;\\n        int moves = 0;\\n        for(int i=0;i<n;i++){\\n            if(board[0][i] == black && i%2 != 0) blks.push_back(i);\\n            if(board[0][i] != black && i%2 == 0) whites.push_back(i);\\n        }\\n\\n        if(blks.size() == whites.size()){\\n            moves += blks.size();\\n\\n            for(int i=0;i<blks.size();i++){\\n                swap_cols(board, blks[i], whites[i]);\\n            }\\n            if(!verify(board)) moves = INT_MAX;\\n        }else moves = INT_MAX;\\n        \\n        return moves;\\n    }\\n    \\n    int can_rows_swap(vector<vector<int>> board, int black){\\n        int moves = 0, n=board.size();\\n        vector<int> blks, whites;\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==black && i%2 != 0) blks.push_back(i);\\n            if(board[i][0] != black && i%2 == 0) whites.push_back(i);\\n        }\\n        \\n        if(blks.size() == whites.size()){\\n            moves += blks.size();\\n\\n            for(int i=0;i<blks.size();i++){\\n                swap_rows(board, blks[i], whites[i]);\\n            }\\n\\n            int col_moves = min(can_cols_swap(board, 0), can_cols_swap(board, 1));\\n            if(col_moves == INT_MAX) moves = INT_MAX;\\n            else moves += col_moves;\\n        }else moves = INT_MAX;\\n        \\n        return moves;\\n    }\\n    \\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int ans = min(can_rows_swap(board, 0), can_rows_swap(board, 1));\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```verify```\n```black```\n```0```\n```1```\n```\\nvoid swap_cols(vector<vector<int>> &board, int c1, int c2){\\n        int n = board.size();\\n        for(int i=0;i<n;i++){\\n            swap(board[i][c1], board[i][c2]);\\n        }\\n    }\\n    \\n    void swap_rows(vector<vector<int>> &board, int r1, int r2){\\n        int n = board.size();\\n        for(int i=0;i<n;i++){\\n            swap(board[r1][i], board[r2][i]);\\n        }\\n    }\\n    \\n    bool verify(vector<vector<int>> &board){\\n        int n = board.size();\\n        int b = board[0][0];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if((i+j)%2 == 0 && board[i][j] != b) return false;\\n                if((i+j)%2 != 0 && board[i][j] == b) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int can_cols_swap(vector<vector<int>> board, int black){\\n        int n = board.size();\\n        vector<int> blks, whites;\\n        int moves = 0;\\n        for(int i=0;i<n;i++){\\n            if(board[0][i] == black && i%2 != 0) blks.push_back(i);\\n            if(board[0][i] != black && i%2 == 0) whites.push_back(i);\\n        }\\n\\n        if(blks.size() == whites.size()){\\n            moves += blks.size();\\n\\n            for(int i=0;i<blks.size();i++){\\n                swap_cols(board, blks[i], whites[i]);\\n            }\\n            if(!verify(board)) moves = INT_MAX;\\n        }else moves = INT_MAX;\\n        \\n        return moves;\\n    }\\n    \\n    int can_rows_swap(vector<vector<int>> board, int black){\\n        int moves = 0, n=board.size();\\n        vector<int> blks, whites;\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==black && i%2 != 0) blks.push_back(i);\\n            if(board[i][0] != black && i%2 == 0) whites.push_back(i);\\n        }\\n        \\n        if(blks.size() == whites.size()){\\n            moves += blks.size();\\n\\n            for(int i=0;i<blks.size();i++){\\n                swap_rows(board, blks[i], whites[i]);\\n            }\\n\\n            int col_moves = min(can_cols_swap(board, 0), can_cols_swap(board, 1));\\n            if(col_moves == INT_MAX) moves = INT_MAX;\\n            else moves += col_moves;\\n        }else moves = INT_MAX;\\n        \\n        return moves;\\n    }\\n    \\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int ans = min(can_rows_swap(board, 0), can_rows_swap(board, 1));\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465684,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n         int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int row_counter = 0, col_counter = 0;\\n        for(int r = 0; r < n; r++){\\n            row_counter += board[r][0] ? 1 : -1;\\n            for(int c = 0; c < n; c++){\\n                if(r == 0) col_counter += board[r][c] ? 1 : -1;\\n                if((board[r][0] ^ board[0][0]) ^ (board[r][c] ^ board[0][c])) return -1; \\n            }\\n        }\\n        if(abs(row_counter) > 1 || abs(col_counter) > 1) return -1;\\n        int row_swap_count = 0, col_swap_count = 0, row_0_count = 0, col_0_count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i & 1){\\n                row_swap_count += board[i][0];\\n                col_swap_count += board[0][i];\\n            }\\n            row_0_count += board[i][0] == 0, col_0_count += board[0][i] == 0;            \\n        }\\n        int odd_position_count = n/2; \\n        if(n & 1){ \\n            row_swap_count = row_0_count == odd_position_count ? row_swap_count : (odd_position_count - row_swap_count);\\n            col_swap_count = col_0_count == odd_position_count ? col_swap_count : (odd_position_count - col_swap_count);\\n        }\\n        else{\\n            row_swap_count = min(row_swap_count, odd_position_count - row_swap_count);\\n            col_swap_count = min(col_swap_count, odd_position_count - col_swap_count);            \\n        }\\n        return row_swap_count + col_swap_count;\\n    } \\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def check_even(self, count) : \\n        if len(count) != 2 or sorted(count.values()) != self.balanced : \\n            return -1 \\n        return 1\\n\\n    def all_opposite(self, line1, line2) : \\n        if not all (line1_value ^ line2_value for line1_value, line2_value in zip(line1, line2)) : \\n            return -1 \\n        return 1 \\n    \\n    def set_sums_of_lists_of_values(self) : \\n        self.sums_of_lists_of_values = [sum(list_of_values) for list_of_values in self.lists_of_values]\\n\\n    def update_number_of_swaps(self) : \\n        self.number_of_swaps += min(self.sums_of_lists_of_values) // 2\\n\\n    def set_lists_of_values(self, line1) : \\n        self.lists_of_values = []\\n        for start in self.starts : \\n            new_list = []\\n            for index, value in enumerate(line1, start) : \\n                new_list.append((index-value) % 2)\\n            self.lists_of_values.append(new_list)\\n\\n    def set_starting_values(self, line1) : \\n        self.starts = [+(line1.count(1) * 2 > self.n)] if self.n & 1 else [0, 1]\\n\\n    def process_line(self, line1) : \\n        self.set_starting_values(line1)\\n        self.set_lists_of_values(line1) \\n        self.set_sums_of_lists_of_values()\\n        self.update_number_of_swaps()\\n\\n    def process_board(self, board) : \\n        for count in (collections.Counter(map(tuple, board)), collections.Counter(zip(*board))) :  \\n            if self.check_even(count) == -1 : \\n                return -1 \\n            line1, line2 = count\\n            if self.all_opposite(line1, line2) == -1 : \\n                return -1 \\n            self.process_line(line1)\\n        return self.number_of_swaps\\n\\n    def set_up_for_processing_board(self, n) : \\n        self.n = n \\n        self.number_of_swaps = 0\\n        self.balanced = [n//2, (n+1)//2]\\n            \\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        self.set_up_for_processing_board(len(board))\\n        return self.process_board(board)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int r = 0; r < N; ++r)\\n            for (int c = 0; c < N; ++c) {\\n                if ((board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1)\\n                    return -1;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += board[0][i];\\n            colSum += board[i][0];\\n            rowSwap += board[i][0] == i % 2 ? 1 : 0;\\n            colSwap += board[0][i] == i % 2 ? 1 : 0;\\n        }\\n        if (N / 2 > rowSum || rowSum > (N + 1) / 2) return -1;\\n        if (N / 2 > colSum || colSum > (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n         int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int row_counter = 0, col_counter = 0;\\n        for(int r = 0; r < n; r++){\\n            row_counter += board[r][0] ? 1 : -1;\\n            for(int c = 0; c < n; c++){\\n                if(r == 0) col_counter += board[r][c] ? 1 : -1;\\n                if((board[r][0] ^ board[0][0]) ^ (board[r][c] ^ board[0][c])) return -1; \\n            }\\n        }\\n        if(abs(row_counter) > 1 || abs(col_counter) > 1) return -1;\\n        int row_swap_count = 0, col_swap_count = 0, row_0_count = 0, col_0_count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i & 1){\\n                row_swap_count += board[i][0];\\n                col_swap_count += board[0][i];\\n            }\\n            row_0_count += board[i][0] == 0, col_0_count += board[0][i] == 0;            \\n        }\\n        int odd_position_count = n/2; \\n        if(n & 1){ \\n            row_swap_count = row_0_count == odd_position_count ? row_swap_count : (odd_position_count - row_swap_count);\\n            col_swap_count = col_0_count == odd_position_count ? col_swap_count : (odd_position_count - col_swap_count);\\n        }\\n        else{\\n            row_swap_count = min(row_swap_count, odd_position_count - row_swap_count);\\n            col_swap_count = min(col_swap_count, odd_position_count - col_swap_count);            \\n        }\\n        return row_swap_count + col_swap_count;\\n    } \\n};\\n```\n```Python3 []\\nclass Solution:\\n    def check_even(self, count) : \\n        if len(count) != 2 or sorted(count.values()) != self.balanced : \\n            return -1 \\n        return 1\\n\\n    def all_opposite(self, line1, line2) : \\n        if not all (line1_value ^ line2_value for line1_value, line2_value in zip(line1, line2)) : \\n            return -1 \\n        return 1 \\n    \\n    def set_sums_of_lists_of_values(self) : \\n        self.sums_of_lists_of_values = [sum(list_of_values) for list_of_values in self.lists_of_values]\\n\\n    def update_number_of_swaps(self) : \\n        self.number_of_swaps += min(self.sums_of_lists_of_values) // 2\\n\\n    def set_lists_of_values(self, line1) : \\n        self.lists_of_values = []\\n        for start in self.starts : \\n            new_list = []\\n            for index, value in enumerate(line1, start) : \\n                new_list.append((index-value) % 2)\\n            self.lists_of_values.append(new_list)\\n\\n    def set_starting_values(self, line1) : \\n        self.starts = [+(line1.count(1) * 2 > self.n)] if self.n & 1 else [0, 1]\\n\\n    def process_line(self, line1) : \\n        self.set_starting_values(line1)\\n        self.set_lists_of_values(line1) \\n        self.set_sums_of_lists_of_values()\\n        self.update_number_of_swaps()\\n\\n    def process_board(self, board) : \\n        for count in (collections.Counter(map(tuple, board)), collections.Counter(zip(*board))) :  \\n            if self.check_even(count) == -1 : \\n                return -1 \\n            line1, line2 = count\\n            if self.all_opposite(line1, line2) == -1 : \\n                return -1 \\n            self.process_line(line1)\\n        return self.number_of_swaps\\n\\n    def set_up_for_processing_board(self, n) : \\n        self.n = n \\n        self.number_of_swaps = 0\\n        self.balanced = [n//2, (n+1)//2]\\n            \\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        self.set_up_for_processing_board(len(board))\\n        return self.process_board(board)\\n```\n```Java []\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int r = 0; r < N; ++r)\\n            for (int c = 0; c < N; ++c) {\\n                if ((board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1)\\n                    return -1;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += board[0][i];\\n            colSum += board[i][0];\\n            rowSwap += board[i][0] == i % 2 ? 1 : 0;\\n            colSwap += board[0][i] == i % 2 ? 1 : 0;\\n        }\\n        if (N / 2 > rowSum || rowSum > (N + 1) / 2) return -1;\\n        if (N / 2 > colSum || colSum > (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488687,
                "title": "java-easy-concise",
                "content": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, colToMove = 0, rowToMove = 0, rowOneCnt = 0, colOneCnt = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < N; i++) {\\n            rowOneCnt += board[0][i];\\n            colOneCnt += board[i][0];\\n            if (board[i][0] == i % 2) {\\n                rowToMove++;\\n            }\\n            if (board[0][i] == i % 2) {\\n                colToMove++;\\n            }\\n        }\\n        if (rowOneCnt < N / 2 || rowOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (colOneCnt < N / 2 || colOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (N % 2 == 1) {\\n            // we cannot make it when ..ToMove is odd\\n            if (colToMove % 2 == 1) {\\n                colToMove = N - colToMove;\\n            }\\n            if (rowToMove % 2 == 1) {\\n                rowToMove = N - rowToMove;\\n            }\\n        } else {\\n            colToMove = Math.min(colToMove, N - colToMove);\\n            rowToMove = Math.min(rowToMove, N - rowToMove);\\n        }\\n        return (colToMove + rowToMove) / 2;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, colToMove = 0, rowToMove = 0, rowOneCnt = 0, colOneCnt = 0;\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < N; i++) {\\n            rowOneCnt += board[0][i];\\n            colOneCnt += board[i][0];\\n            if (board[i][0] == i % 2) {\\n                rowToMove++;\\n            }\\n            if (board[0][i] == i % 2) {\\n                colToMove++;\\n            }\\n        }\\n        if (rowOneCnt < N / 2 || rowOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (colOneCnt < N / 2 || colOneCnt > (N + 1) / 2) {\\n            return -1;\\n        }\\n        if (N % 2 == 1) {\\n            // we cannot make it when ..ToMove is odd\\n            if (colToMove % 2 == 1) {\\n                colToMove = N - colToMove;\\n            }\\n            if (rowToMove % 2 == 1) {\\n                rowToMove = N - rowToMove;\\n            }\\n        } else {\\n            colToMove = Math.min(colToMove, N - colToMove);\\n            rowToMove = Math.min(rowToMove, N - rowToMove);\\n        }\\n        return (colToMove + rowToMove) / 2;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487863,
                "title": "transform-to-chessboard-js-just-check-bro-beat-100",
                "content": "The key here is realizing that since you cannot move individual cells, but only rows and columns, what started off in a column/row will always remain there. \\nE.g. in the first example case, you can view it as:\\n * col 0 and col 1 swap places\\n * row 1 and row 2 swap places\\nAnd you can see none of the zeros and ones actually left their original column/row. \\nMoreover, the actions of swapping rows/columns can be done independent of each other.\\n\\nThe algorithm for swapping into a chessboard is therefore the following:\\n* swap the rows until the first column is in either \"0101\" or \"1010\" configuration.\\n* swap the columns until the first row is in either \"0101\" or \"1010\" configuration.\\n* done.\\n\\nBut this is based on the assumption that a chessboard can be formed.\\n\\nHow can we be sure a chessboard can never be formed?\\nSince anytime you move a column to attempt to align a certain row into the correct configuration, you are changing the configuration of all other rows. Therefore all the rows must be either the same, or the opposite of one another.\\nThen it follows that the number of opposite rows must be the same as the number of same rows if the board size is even, or 1 off if the board size is odd.\\n\\nAdd this all together, what we are doing is:\\n * check if a chessboard can be formed\\n * for row get number of moves to get into \"0101\" or \"1010\" configuration\\n * for col get number of moves to get into \"0101\" or \"1010\" configuration\\n * combination of lowest number of moves (must each be even) is optimal.\\n * return the combination/2 to get number of swaps.\\n```\\n/**\\n * @param {number[][]} board\\n * @return {number}\\n */\\nvar movesToChessboard = function(board) {\\n    const boardSz = board.length;\\n    const evenBoard = boardSz%2===0;\\n    \\n    const possible=()=>{\\n        //number of 0 and 1 must be equal in the case of even size board\\n        //or have a difference of 1 in the case of odd size board\\n        let numOne = 0, numZero = 0;\\n\\n        //each subsequent row must be either equal to first or opposite of first\\n        let same = \"\", oppo = \"\";\\n        board[0].forEach(item=>{\\n            if (item === 1) {\\n                numOne++;\\n                same+=\"1\";\\n                oppo+=\"0\";\\n            }\\n            else {\\n                numZero++;\\n                same+=\"0\";\\n                oppo+=\"1\";\\n            }\\n        });\\n        \\n        //checking for zeros and ones in first row\\n        if (evenBoard)\\n            if (numOne != numZero)\\n                return false;\\n        else if (!evenBoard)\\n            if (Math.abs(numOne-numZero) != 1)\\n                return false;\\n        \\n        let sameRow = 0, oppoRow = 0;\\n        \\n        for (const row of board) {\\n            const joinedRow = row.join(\"\");\\n            if (joinedRow === same){\\n                sameRow++;\\n            }\\n            else if (joinedRow === oppo){\\n                oppoRow++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        if (evenBoard)\\n            return sameRow === oppoRow;\\n        \\n        return Math.abs(sameRow-oppoRow) === 1;\\n        \\n    };\\n    \\n    if (!possible()){\\n        return -1;\\n    }\\n    \\n    //convert to 0101\\n    let rowMove1 = 0;\\n    let colMove1 = 0;\\n    \\n     //convert to 1010\\n    let rowMove2 = 0;\\n    let colMove2 = 0;\\n    \\n    for(let i=0; i<boardSz; i++) {\\n        //checking rows\\n        //1010\\n        if(board[i][0] === i % 2) {\\n            rowMove1++;\\n        //0101\\n        } else {\\n            rowMove2++;\\n        }\\n        \\n        //checking cols\\n        //1010\\n        if(board[0][i] === i % 2) {\\n            colMove1++;\\n        //0101\\n        } else {\\n            colMove2++;\\n        }\\n    }\\n   \\n    if(rowMove1 + colMove1 === 0 || rowMove2 + colMove2 === 0) \\n        return 0; \\n    \\n    //if the board size is even, number of optimal moves is the minimum\\n\\t//no need to check if even since by default it will be\\n    if(evenBoard) {\\n        rowMove1 = Math.min(rowMove1, rowMove2);\\n        colMove1 = Math.min(colMove1, colMove2);\\n    //number of optimal moves must be even (each swap is two moves)\\n    } else {\\n        rowMove1 = rowMove1 % 2 === 0 ? rowMove1 : rowMove2;\\n        colMove1 = colMove1 % 2 === 0 ? colMove1 : colMove2;\\n    }\\n   \\n    return (rowMove1 + colMove1) / 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} board\\n * @return {number}\\n */\\nvar movesToChessboard = function(board) {\\n    const boardSz = board.length;\\n    const evenBoard = boardSz%2===0;\\n    \\n    const possible=()=>{\\n        //number of 0 and 1 must be equal in the case of even size board\\n        //or have a difference of 1 in the case of odd size board\\n        let numOne = 0, numZero = 0;\\n\\n        //each subsequent row must be either equal to first or opposite of first\\n        let same = \"\", oppo = \"\";\\n        board[0].forEach(item=>{\\n            if (item === 1) {\\n                numOne++;\\n                same+=\"1\";\\n                oppo+=\"0\";\\n            }\\n            else {\\n                numZero++;\\n                same+=\"0\";\\n                oppo+=\"1\";\\n            }\\n        });\\n        \\n        //checking for zeros and ones in first row\\n        if (evenBoard)\\n            if (numOne != numZero)\\n                return false;\\n        else if (!evenBoard)\\n            if (Math.abs(numOne-numZero) != 1)\\n                return false;\\n        \\n        let sameRow = 0, oppoRow = 0;\\n        \\n        for (const row of board) {\\n            const joinedRow = row.join(\"\");\\n            if (joinedRow === same){\\n                sameRow++;\\n            }\\n            else if (joinedRow === oppo){\\n                oppoRow++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        if (evenBoard)\\n            return sameRow === oppoRow;\\n        \\n        return Math.abs(sameRow-oppoRow) === 1;\\n        \\n    };\\n    \\n    if (!possible()){\\n        return -1;\\n    }\\n    \\n    //convert to 0101\\n    let rowMove1 = 0;\\n    let colMove1 = 0;\\n    \\n     //convert to 1010\\n    let rowMove2 = 0;\\n    let colMove2 = 0;\\n    \\n    for(let i=0; i<boardSz; i++) {\\n        //checking rows\\n        //1010\\n        if(board[i][0] === i % 2) {\\n            rowMove1++;\\n        //0101\\n        } else {\\n            rowMove2++;\\n        }\\n        \\n        //checking cols\\n        //1010\\n        if(board[0][i] === i % 2) {\\n            colMove1++;\\n        //0101\\n        } else {\\n            colMove2++;\\n        }\\n    }\\n   \\n    if(rowMove1 + colMove1 === 0 || rowMove2 + colMove2 === 0) \\n        return 0; \\n    \\n    //if the board size is even, number of optimal moves is the minimum\\n\\t//no need to check if even since by default it will be\\n    if(evenBoard) {\\n        rowMove1 = Math.min(rowMove1, rowMove2);\\n        colMove1 = Math.min(colMove1, colMove2);\\n    //number of optimal moves must be even (each swap is two moves)\\n    } else {\\n        rowMove1 = rowMove1 % 2 === 0 ? rowMove1 : rowMove2;\\n        colMove1 = colMove1 % 2 === 0 ? colMove1 : colMove2;\\n    }\\n   \\n    return (rowMove1 + colMove1) / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487132,
                "title": "java-counting-repeating-parts",
                "content": "It is somewhat differrent from the other solutions here. We can count repeating parts in rows and columns, like this `0111001`: countOnes=3, countZeros=2 (so, min=2, max=3). And we expect that `min` and `max` repeating parts are constant between the rows and the columns.\\n\\nAfter we proved that board is correct, we simple count incorrect positions in the first row and the first column. \\n\\n```java\\nclass Solution {\\n    int n;\\n    int[][] board;\\n    int countInRow(int r,int what){\\n        int count=0;\\n        for(int i =0;i<n;i++)if(board[r][i]==what)count++;\\n\\n        return count;\\n    }\\n    int countInCol(int c,int what){\\n        int count=0;\\n        for(int i =0;i<n;i++)if(board[i][c]==what)count++;\\n\\n        return count;\\n    }\\n\\n    public int movesToChessboard(int[][] board) {\\n        n = board.length;\\n        this.board = board;\\n\\n        int sameMinRowF = -1;\\n        int sameMaxRowF = -1;\\n        int sameMinColF = -1;\\n        int sameMaxColF = -1;\\n        for (int i = 0; i < n; i++) {\\n            int newCountOnesRow = countInRow(i, 1);\\n            int newCountZerosRow = countInRow(i, 0);\\n            if(Math.abs(newCountOnesRow-newCountZerosRow)>1)return -1;\\n            int newCountZerosCol = countInCol(i, 0);\\n            int newCountOnesCol = countInCol(i, 1);\\n            if(Math.abs(newCountZerosCol-newCountOnesCol)>1)return -1;\\n            int[]row=board[i];\\n            int same0Row = countSameInRow(row, 0);\\n            int same1Row = countSameInRow(row, 1);\\n            int sameMinRow = Math.min(same0Row,same1Row);\\n            int sameMaxRow = Math.max(same0Row, same1Row);\\n            if(sameMinRowF==-1)sameMinRowF = sameMinRow;\\n            if(sameMaxRowF==-1)sameMaxRowF=sameMaxRow;\\n            if(sameMinRowF!=sameMinRow)return -1;\\n            if(sameMaxRowF!=sameMaxRow)return -1;\\n\\n            int same0Col=countSameInCol(i, 0); \\n            int same1Col=countSameInCol(i, 1); \\n            int sameMinCol = Math.min(same0Col,same1Col);\\n            int sameMaxCol = Math.max(same0Col, same1Col);\\n            if(sameMinColF==-1)sameMinColF = sameMinCol;\\n            if(sameMaxColF==-1)sameMaxColF=sameMaxCol;\\n            if(sameMinColF!=sameMinCol)return -1;\\n            if(sameMaxColF!=sameMaxCol)return -1;\\n        }\\n        int count=0;\\n        boolean isEven =n%2==0;\\n        if(isEven){\\n            //101010 nz=3,no=3\\n            //010101\\n            int nz = countInRow(0,0);\\n            int no = countInRow(0,1);\\n            if(nz!=no)throw new Error(\"can\\'t\");\\n            nz = countInCol(0,0);\\n            no = countInCol(0,1);\\n            if(nz!=no)throw new Error(\"can\\'t\");\\n            //00111100\\n            //1001\\n            //0110\\n            int c1=0;int c0=0;\\n            for(int i=0;i<n;i+=2){if(board[0][i]!=1)c1++;if(board[0][i]!=0)c0++;}\\n            count+=Math.min(c1,c0);\\n            c1=0;c0=0;\\n            for(int i=0;i<n;i+=2){if(board[i][0]!=1)c1++;if(board[i][0]!=0)c0++;}\\n            count+=Math.min(c1,c0);\\n        }else{\\n            //1010101 nz=3, no=4\\n            //0101010 nz=4, no=3\\n\\n            //1100100100111\\n            int nz = countInRow(0,0);\\n            int no = countInRow(0,1);\\n            if(nz==no+1){\\n                //0101010\\n                for(int i =1;i<n;i+=2)if(board[0][i]!=1)count++;\\n            }else if(no==nz+1){\\n                //101\\n                for(int i =1;i<n;i+=2)if(board[0][i]!=0)count++;\\n\\n            }else throw new Error(\"can\\'t\");\\n            nz = countInCol(0,0);\\n            no = countInCol(0,1);\\n            if(nz==no+1){\\n                //0101010\\n                for(int i =1;i<n;i+=2)if(board[i][0]!=1)count++;\\n            }else if(no==nz+1){\\n                //101\\n                for(int i =1;i<n;i+=2)if(board[i][0]!=0)count++;\\n\\n            }else throw new Error(\"can\\'t\");\\n\\n        }\\n            \\n        return count;\\n    }\\n    int countSameInRow(int[]row, int what){\\n        int count=0;\\n        int prev=row[0];\\n        int len=1;\\n        for(int i =1;i<n;i++){\\n            int curr=row[i];\\n            if(curr==what&&curr==prev){\\n                len++;\\n            }else{\\n                count+=len-1;\\n                len=1;\\n            }\\n            prev=curr;\\n        }\\n        count+=len-1;\\n        return count;\\n    }\\n    int countSameInCol(int c, int what){ \\n        int count=0;\\n        int prev=board[0][c];\\n        int len=1;\\n        for(int i =1;i<n;i++){\\n            int curr=board[i][c];\\n            if(curr==what&&curr==prev){\\n                len++;\\n            }else{\\n                count+=len-1;\\n                len=1;\\n            }\\n            prev=curr;\\n        }\\n        count+=len-1;\\n        return count; \\n    }  \\n}   \\n```\\nI think this problem is a one big `corner-case`.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    int n;\\n    int[][] board;\\n    int countInRow(int r,int what){\\n        int count=0;\\n        for(int i =0;i<n;i++)if(board[r][i]==what)count++;\\n\\n        return count;\\n    }\\n    int countInCol(int c,int what){\\n        int count=0;\\n        for(int i =0;i<n;i++)if(board[i][c]==what)count++;\\n\\n        return count;\\n    }\\n\\n    public int movesToChessboard(int[][] board) {\\n        n = board.length;\\n        this.board = board;\\n\\n        int sameMinRowF = -1;\\n        int sameMaxRowF = -1;\\n        int sameMinColF = -1;\\n        int sameMaxColF = -1;\\n        for (int i = 0; i < n; i++) {\\n            int newCountOnesRow = countInRow(i, 1);\\n            int newCountZerosRow = countInRow(i, 0);\\n            if(Math.abs(newCountOnesRow-newCountZerosRow)>1)return -1;\\n            int newCountZerosCol = countInCol(i, 0);\\n            int newCountOnesCol = countInCol(i, 1);\\n            if(Math.abs(newCountZerosCol-newCountOnesCol)>1)return -1;\\n            int[]row=board[i];\\n            int same0Row = countSameInRow(row, 0);\\n            int same1Row = countSameInRow(row, 1);\\n            int sameMinRow = Math.min(same0Row,same1Row);\\n            int sameMaxRow = Math.max(same0Row, same1Row);\\n            if(sameMinRowF==-1)sameMinRowF = sameMinRow;\\n            if(sameMaxRowF==-1)sameMaxRowF=sameMaxRow;\\n            if(sameMinRowF!=sameMinRow)return -1;\\n            if(sameMaxRowF!=sameMaxRow)return -1;\\n\\n            int same0Col=countSameInCol(i, 0); \\n            int same1Col=countSameInCol(i, 1); \\n            int sameMinCol = Math.min(same0Col,same1Col);\\n            int sameMaxCol = Math.max(same0Col, same1Col);\\n            if(sameMinColF==-1)sameMinColF = sameMinCol;\\n            if(sameMaxColF==-1)sameMaxColF=sameMaxCol;\\n            if(sameMinColF!=sameMinCol)return -1;\\n            if(sameMaxColF!=sameMaxCol)return -1;\\n        }\\n        int count=0;\\n        boolean isEven =n%2==0;\\n        if(isEven){\\n            //101010 nz=3,no=3\\n            //010101\\n            int nz = countInRow(0,0);\\n            int no = countInRow(0,1);\\n            if(nz!=no)throw new Error(\"can\\'t\");\\n            nz = countInCol(0,0);\\n            no = countInCol(0,1);\\n            if(nz!=no)throw new Error(\"can\\'t\");\\n            //00111100\\n            //1001\\n            //0110\\n            int c1=0;int c0=0;\\n            for(int i=0;i<n;i+=2){if(board[0][i]!=1)c1++;if(board[0][i]!=0)c0++;}\\n            count+=Math.min(c1,c0);\\n            c1=0;c0=0;\\n            for(int i=0;i<n;i+=2){if(board[i][0]!=1)c1++;if(board[i][0]!=0)c0++;}\\n            count+=Math.min(c1,c0);\\n        }else{\\n            //1010101 nz=3, no=4\\n            //0101010 nz=4, no=3\\n\\n            //1100100100111\\n            int nz = countInRow(0,0);\\n            int no = countInRow(0,1);\\n            if(nz==no+1){\\n                //0101010\\n                for(int i =1;i<n;i+=2)if(board[0][i]!=1)count++;\\n            }else if(no==nz+1){\\n                //101\\n                for(int i =1;i<n;i+=2)if(board[0][i]!=0)count++;\\n\\n            }else throw new Error(\"can\\'t\");\\n            nz = countInCol(0,0);\\n            no = countInCol(0,1);\\n            if(nz==no+1){\\n                //0101010\\n                for(int i =1;i<n;i+=2)if(board[i][0]!=1)count++;\\n            }else if(no==nz+1){\\n                //101\\n                for(int i =1;i<n;i+=2)if(board[i][0]!=0)count++;\\n\\n            }else throw new Error(\"can\\'t\");\\n\\n        }\\n            \\n        return count;\\n    }\\n    int countSameInRow(int[]row, int what){\\n        int count=0;\\n        int prev=row[0];\\n        int len=1;\\n        for(int i =1;i<n;i++){\\n            int curr=row[i];\\n            if(curr==what&&curr==prev){\\n                len++;\\n            }else{\\n                count+=len-1;\\n                len=1;\\n            }\\n            prev=curr;\\n        }\\n        count+=len-1;\\n        return count;\\n    }\\n    int countSameInCol(int c, int what){ \\n        int count=0;\\n        int prev=board[0][c];\\n        int len=1;\\n        for(int i =1;i<n;i++){\\n            int curr=board[i][c];\\n            if(curr==what&&curr==prev){\\n                len++;\\n            }else{\\n                count+=len-1;\\n                len=1;\\n            }\\n            prev=curr;\\n        }\\n        count+=len-1;\\n        return count; \\n    }  \\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486893,
                "title": "simple-c-solution",
                "content": "```\\nnt movesToChessboard(int** board, int boardSize, int* boardColSize){\\n    int rowSum = 0, colSum = 0, row = 0, col = 0;\\n    for (int i = 0; i < boardSize; ++i) \\n        for (int j = 0; j < boardSize; ++j)\\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) return -1;\\n    for (int i = 0; i < boardSize; ++i) \\n    {\\n        rowSum += board[0][i];\\n        colSum += board[i][0];\\n        if((i % 2) == board[i][0]) row++;\\n        if((i % 2) == board[0][i]) col++;\\n    }\\n    if (boardSize / 2 > rowSum || rowSum > (boardSize + 1) / 2) return -1;\\n    if (boardSize / 2 > colSum || colSum > (boardSize + 1) / 2) return -1;\\n    if (boardSize % 2)\\n    {\\n        if (row % 2) row = boardSize - row;\\n        if (col % 2) col = boardSize - col;\\n    }\\n    else \\n    {\\n        row = boardSize - row < row ? boardSize - row : row;\\n        col = boardSize - col < col ? boardSize - col : col;\\n    }\\n    return (row + col) / 2;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnt movesToChessboard(int** board, int boardSize, int* boardColSize){\\n    int rowSum = 0, colSum = 0, row = 0, col = 0;\\n    for (int i = 0; i < boardSize; ++i) \\n        for (int j = 0; j < boardSize; ++j)\\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) return -1;\\n    for (int i = 0; i < boardSize; ++i) \\n    {\\n        rowSum += board[0][i];\\n        colSum += board[i][0];\\n        if((i % 2) == board[i][0]) row++;\\n        if((i % 2) == board[0][i]) col++;\\n    }\\n    if (boardSize / 2 > rowSum || rowSum > (boardSize + 1) / 2) return -1;\\n    if (boardSize / 2 > colSum || colSum > (boardSize + 1) / 2) return -1;\\n    if (boardSize % 2)\\n    {\\n        if (row % 2) row = boardSize - row;\\n        if (col % 2) col = boardSize - col;\\n    }\\n    else \\n    {\\n        row = boardSize - row < row ? boardSize - row : row;\\n        col = boardSize - col < col ? boardSize - col : col;\\n    }\\n    return (row + col) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486729,
                "title": "c-little-longer",
                "content": "```\\nint movesToChessboard(vector<vector<int>>& b) {\\n        int N = b.size(), rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if (b[0][0]^b[i][0]^b[0][j]^b[i][j]) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            rowSwap += b[i][0] == i % 2;\\n            colSwap += b[0][i] == i % 2;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2) {\\n            if (colSwap % 2) colSwap = N - colSwap;\\n            if (rowSwap % 2) rowSwap = N - rowSwap;\\n        }\\n        else {\\n            colSwap = min(N - colSwap, colSwap);\\n            rowSwap = min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint movesToChessboard(vector<vector<int>>& b) {\\n        int N = b.size(), rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\\n                if (b[0][0]^b[i][0]^b[0][j]^b[i][j]) return -1;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += b[0][i];\\n            colSum += b[i][0];\\n            rowSwap += b[i][0] == i % 2;\\n            colSwap += b[0][i] == i % 2;\\n        }\\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\\n        if (N % 2) {\\n            if (colSwap % 2) colSwap = N - colSwap;\\n            if (rowSwap % 2) rowSwap = N - rowSwap;\\n        }\\n        else {\\n            colSwap = min(N - colSwap, colSwap);\\n            rowSwap = min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305774,
                "title": "c-782-transform-to-chessboard",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = size(board); \\n        \\n        auto fn = [&](vector<int>& vals) {\\n            int total = 0, odd = 0; \\n            for (int i = 0; i < size(vals); ++i) {\\n                if (vals[0] == vals[i]) {\\n                    ++total; \\n                    if (i&1) ++odd; \\n                } else if ((vals[0] ^ vals[i]) != (1 << n) - 1) return 100; \\n            }\\n            int ans = 100; \\n            if (size(vals) <= 2*total && 2*total <= size(vals)+1) ans = min(ans, odd); \\n            if (size(vals)-1 <= 2*total && 2*total <= size(vals)) ans = min(ans, total - odd); \\n            return ans; \\n        }; \\n        \\n        vector<int> rows(n), cols(n); \\n        for (int i = 0; i < n; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (board[i][j]) {\\n                    rows[i] ^= 1 << j; \\n                    cols[j] ^= 1 << i; \\n                }\\n        int ans = fn(rows) + fn(cols); \\n        return ans < 100 ? ans : -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = size(board); \\n        \\n        auto fn = [&](vector<int>& vals) {\\n            int total = 0, odd = 0; \\n            for (int i = 0; i < size(vals); ++i) {\\n                if (vals[0] == vals[i]) {\\n                    ++total; \\n                    if (i&1) ++odd; \\n                } else if ((vals[0] ^ vals[i]) != (1 << n) - 1) return 100; \\n            }\\n            int ans = 100; \\n            if (size(vals) <= 2*total && 2*total <= size(vals)+1) ans = min(ans, odd); \\n            if (size(vals)-1 <= 2*total && 2*total <= size(vals)) ans = min(ans, total - odd); \\n            return ans; \\n        }; \\n        \\n        vector<int> rows(n), cols(n); \\n        for (int i = 0; i < n; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (board[i][j]) {\\n                    rows[i] ^= 1 << j; \\n                    cols[j] ^= 1 << i; \\n                }\\n        int ans = fn(rows) + fn(cols); \\n        return ans < 100 ? ans : -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250693,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n=len(board)\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                if(board[0][0] ^ board[0][j] ^ board[i][0] ^ board[i][j]!=0):\\n                    return -1\\n        rowSum=0\\n        colSum= 0\\n        rowSwap=0\\n        colSwap= 0\\n        for i in range(0,n):\\n            rowSum= rowSum + board[i][0]\\n            colSum = colSum +board[0][i]\\n            rowSwap += board[i][0] == i % 2\\n            colSwap += board[0][i] == i % 2\\n        if(rowSum != n//2 and  rowSum != (n + 1)//2):\\n            return -1\\n        if(colSum != n//2 and colSum != (n + 1)//2):\\n            return -1\\n        if(n % 2 == 1):\\n            if(colSwap % 2):\\n                colSwap = n - colSwap\\n            if(rowSwap % 2):\\n                rowSwap = n - rowSwap\\n        else:\\n            colSwap = min(colSwap, n - colSwap)\\n            rowSwap = min(rowSwap, n - rowSwap)\\n        return (rowSwap + colSwap)//2;\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n=len(board)\\n        for i in range(0,n):\\n            for j in range(0,n):\\n                if(board[0][0] ^ board[0][j] ^ board[i][0] ^ board[i][j]!=0):\\n                    return -1\\n        rowSum=0\\n        colSum= 0\\n        rowSwap=0\\n        colSwap= 0\\n        for i in range(0,n):\\n            rowSum= rowSum + board[i][0]\\n            colSum = colSum +board[0][i]\\n            rowSwap += board[i][0] == i % 2\\n            colSwap += board[0][i] == i % 2\\n        if(rowSum != n//2 and  rowSum != (n + 1)//2):\\n            return -1\\n        if(colSum != n//2 and colSum != (n + 1)//2):\\n            return -1\\n        if(n % 2 == 1):\\n            if(colSwap % 2):\\n                colSwap = n - colSwap\\n            if(rowSwap % 2):\\n                rowSwap = n - rowSwap\\n        else:\\n            colSwap = min(colSwap, n - colSwap)\\n            rowSwap = min(rowSwap, n - rowSwap)\\n        return (rowSwap + colSwap)//2;\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171251,
                "title": "c-easy-to-understand-solution",
                "content": "This solution is based on an observation by mzchen: After the moving, all rows with even numbers are the same and so are the rows with odd numbers. \\nFor calculating the moves on rows, we use a mapping table to record the index of the rows:\\n1) return -1 if the mapping size is not two.\\n2) return -1 if the counts of the two rows are not balanced, or the counts differ by more than one.\\n3) Pick the row with potential more appearances to calculate the answer\\n\\nRotate the matrix to use the same row count function to calculate the moves on columns.\\n~~~\\nclass Solution {\\n    int rowCount(vector<vector<int>> &board) {\\n        map<vector<int>, vector<int>> mp;\\n        for (int i = 0; i < board.size(); ++i) {\\n            mp[board[i]].push_back(i);\\n        }\\n        // after the moving, all even numbered rows are the same\\n        // so ar the odd numbered rows\\n        if (mp.size() != 2) return -1;\\n        \\n        // their numbers shoud not differ by more than one\\n        auto it = mp.begin();\\n        int count1 = it->second.size();\\n        ++it;\\n        int count2 = it->second.size();\\n        if (abs(count1 - count2) > 1) return -1;\\n        \\n        // look at the row with potential more appearances \\n        it = mp.begin();\\n        if (count2 > count1) ++it;\\n        int even = 0, odd = 0;\\n        for (int &i : it->second) {\\n            if (i % 2 == 0) ++even;\\n            else ++odd;\\n        }\\n        if (board.size() % 2 == 0) return min(even, odd); \\n        else return odd;\\n    }\\npublic:\\n    int movesToChessboard(vector<vector<int>> &board) {\\n        int n = board.size(), ret1 = rowCount(board);\\n        if (ret1 == -1) return -1;\\n        \\n        vector<vector<int>> a(n, vector<int>(n));\\n        for (int i = 0; i < board.size(); ++i) {\\n            for (int j = 0; j < board.size(); ++j) {\\n                a[j][i] =  board[i][j];\\n            }\\n        }\\n        int ret2 = rowCount(a);\\n        if (ret2 == -1) return -1;\\n        return ret1 + ret2;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    int rowCount(vector<vector<int>> &board) {\\n        map<vector<int>, vector<int>> mp;\\n        for (int i = 0; i < board.size(); ++i) {\\n            mp[board[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1067911,
                "title": "c-bit-operations-and-explanation-in-comments",
                "content": "```\\nbool debug = false;\\n\\n/*\\ntest cases\\n[[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\\n[[0, 1], [1, 0]]\\n[[1, 0], [1, 0]]\\n[[0,1,0],[1,0,1],[0,1,0]]\\n[[0,1,0],[1,0,1],[1,0,1]]\\n[[1,1,0],[0,0,1],[0,0,1]]\\n*/\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        /*\\n        [Lemma#1] ActionSequences \"swapRows(ri, rj) -> swapCols(ci, cj)\" and \"swapRows(ci, cj) -> swapCols(ri, rj)\" have the SAME result on a \"01-board\". Draw the 4 intersections (ri, ci), (ri, cj), (rj, ci), (rj, cj) and follow their moves to see why. Moreover, an ActionSequence of \"swapRows\" and \"swapCols\" can arbitrarily permute the actions to get the same result on a \"01-board\".\\n        \\n        [Lemma#2] If transformed from a ChessBoard, there\\'d be EXACTLY 2 types of rows in the input.\\n        */\\n        int N = board.size();\\n        int valsForLeadingDigits[2];\\n        valsForLeadingDigits[0] = 0; // a row or col \"0,1,0,1,0,1,...\"\\n        for (int i = 1; i < N; ++i) {\\n            valsForLeadingDigits[0] *= 2;\\n            valsForLeadingDigits[0] += (i & 1) ? 1 : 0;\\n        }\\n        \\n        valsForLeadingDigits[1] = 1; // a row or col \"1,0,1,0,1,0,...\"\\n        for (int i = 1; i < N; ++i) {\\n            valsForLeadingDigits[1] *= 2;\\n            valsForLeadingDigits[1] += (i & 1) ? 0 : 1;\\n        }\\n        \\n        map<int, int> rowRepVals; // row representatives\\n        for (int y = 0; y < N; ++y) {\\n            int rowVal = 0;\\n            vector<int> row;\\n            for (int x = 0; x < N; ++x) {\\n                rowVal *= 2;\\n                rowVal += board[y][x];\\n            }\\n            if (rowRepVals.size() == 2 && !rowRepVals.count(rowVal)) return -1;\\n            ++rowRepVals[rowVal];\\n        }\\n        \\n        map<int, int> colRepVals; // col representatives\\n        for (int x = 0; x < N; ++x) {\\n            int colVal = 0;\\n            vector<int> col;\\n            for (int y = 0; y < N; ++y) {\\n                colVal *= 2;\\n                colVal += board[y][x];\\n            }\\n            if (colRepVals.size() == 2 && !colRepVals.count(colVal)) return -1;\\n            ++colRepVals[colVal];\\n        }\\n        \\n        if (colRepVals.size() != 2 || rowRepVals.size() != 2) return -1;\\n        \\n        vector<int> rowRepValsList = {rowRepVals.begin()->first, rowRepVals.rbegin()->first};\\n        vector<int> colRepValsList = {colRepVals.begin()->first, colRepVals.rbegin()->first};\\n        \\n        int ans = INT_MAX;\\n        // Note that to transform a \"01-row\" into another \"01-row\" with the same 0\\'s count & 1\\'s count by \"swapping any pair of digits\", we just have to count how many of the digits are different and take the half.\\n\\n        if (N%2 == 0) {\\n            int halfN = N/2;\\n            if (colRepVals.begin()->second != colRepVals.rbegin()->second) return -1;\\n            if (rowRepVals.begin()->second != rowRepVals.rbegin()->second) return -1;\\n            if (__builtin_popcount(colRepValsList[0]) != halfN || __builtin_popcount(colRepValsList[1]) != halfN) return -1;\\n            if (__builtin_popcount(rowRepValsList[0]) != halfN || __builtin_popcount(rowRepValsList[1]) != halfN) return -1;\\n            \\n            // Traverse the matching options, \\n            for (int a = 0; a < 2; ++a) {\\n                for (int b = 0; b < 2; ++b) {\\n                    int rowCost = (__builtin_popcount(rowRepValsList[0]^valsForLeadingDigits[a]))/2; \\n                    int colCost = (__builtin_popcount(colRepValsList[0]^valsForLeadingDigits[b]))/2; \\n                    ans = min(ans, rowCost+colCost);\\n                }\\n            }\\n        } else {\\n            int majorityEle = -1;\\n            int majorityEleTotCount = (N*N+1)/2;\\n            int minorityEleTotCount = (N*N-1)/2;\\n            int oneTotCount = 0;\\n            for (auto &it : rowRepVals) oneTotCount += it.second*__builtin_popcount(it.first);\\n            \\n            if (oneTotCount == majorityEleTotCount) {\\n                majorityEle = 1;\\n            } else if (oneTotCount == minorityEleTotCount) {\\n                majorityEle = 0;\\n            } else {\\n                return -1;\\n            }\\n                        \\n            int localMajorityCount = (N+1)/2, localMinorityCount = (N-1)/2;\\n            int rowCost = INT_MAX, colCost = INT_MAX;\\n            if (__builtin_popcount(rowRepValsList[0]) == (1 == majorityEle ? localMajorityCount : localMinorityCount)) {\\n                if (debug) printf(\"rowRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", rowRepValsList[0], localMajorityCount, majorityEle);\\n                rowCost = (__builtin_popcount(rowRepValsList[0]^valsForLeadingDigits[majorityEle]))/2;\\n            } else {\\n                if (debug) printf(\"rowRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", rowRepValsList[1], localMajorityCount, majorityEle);\\n                rowCost = (__builtin_popcount(rowRepValsList[1]^valsForLeadingDigits[majorityEle]))/2;\\n            }\\n\\n            if (__builtin_popcount(colRepValsList[0]) == (1 == majorityEle ? localMajorityCount : localMinorityCount)) {\\n                if (debug) printf(\"colRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", colRepValsList[0], localMajorityCount, majorityEle);\\n                colCost = (__builtin_popcount(colRepValsList[0]^valsForLeadingDigits[majorityEle]))/2;\\n            } else {\\n                if (debug) printf(\"colRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", colRepValsList[1], localMajorityCount, majorityEle);\\n                colCost = (__builtin_popcount(colRepValsList[1]^valsForLeadingDigits[majorityEle]))/2;\\n            }\\n            \\n            if (debug) printf(\"N:%d is even, majorityEle is %d, rowCost:%d, colCost:%d\\\\n\", N, majorityEle, rowCost, colCost);\\n            \\n            ans = min(ans, rowCost+colCost);\\n        }\\n        \\n        return (INT_MAX == ans ? -1 : ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool debug = false;\\n\\n/*\\ntest cases\\n[[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\\n[[0, 1], [1, 0]]\\n[[1, 0], [1, 0]]\\n[[0,1,0],[1,0,1],[0,1,0]]\\n[[0,1,0],[1,0,1],[1,0,1]]\\n[[1,1,0],[0,0,1],[0,0,1]]\\n*/\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        /*\\n        [Lemma#1] ActionSequences \"swapRows(ri, rj) -> swapCols(ci, cj)\" and \"swapRows(ci, cj) -> swapCols(ri, rj)\" have the SAME result on a \"01-board\". Draw the 4 intersections (ri, ci), (ri, cj), (rj, ci), (rj, cj) and follow their moves to see why. Moreover, an ActionSequence of \"swapRows\" and \"swapCols\" can arbitrarily permute the actions to get the same result on a \"01-board\".\\n        \\n        [Lemma#2] If transformed from a ChessBoard, there\\'d be EXACTLY 2 types of rows in the input.\\n        */\\n        int N = board.size();\\n        int valsForLeadingDigits[2];\\n        valsForLeadingDigits[0] = 0; // a row or col \"0,1,0,1,0,1,...\"\\n        for (int i = 1; i < N; ++i) {\\n            valsForLeadingDigits[0] *= 2;\\n            valsForLeadingDigits[0] += (i & 1) ? 1 : 0;\\n        }\\n        \\n        valsForLeadingDigits[1] = 1; // a row or col \"1,0,1,0,1,0,...\"\\n        for (int i = 1; i < N; ++i) {\\n            valsForLeadingDigits[1] *= 2;\\n            valsForLeadingDigits[1] += (i & 1) ? 0 : 1;\\n        }\\n        \\n        map<int, int> rowRepVals; // row representatives\\n        for (int y = 0; y < N; ++y) {\\n            int rowVal = 0;\\n            vector<int> row;\\n            for (int x = 0; x < N; ++x) {\\n                rowVal *= 2;\\n                rowVal += board[y][x];\\n            }\\n            if (rowRepVals.size() == 2 && !rowRepVals.count(rowVal)) return -1;\\n            ++rowRepVals[rowVal];\\n        }\\n        \\n        map<int, int> colRepVals; // col representatives\\n        for (int x = 0; x < N; ++x) {\\n            int colVal = 0;\\n            vector<int> col;\\n            for (int y = 0; y < N; ++y) {\\n                colVal *= 2;\\n                colVal += board[y][x];\\n            }\\n            if (colRepVals.size() == 2 && !colRepVals.count(colVal)) return -1;\\n            ++colRepVals[colVal];\\n        }\\n        \\n        if (colRepVals.size() != 2 || rowRepVals.size() != 2) return -1;\\n        \\n        vector<int> rowRepValsList = {rowRepVals.begin()->first, rowRepVals.rbegin()->first};\\n        vector<int> colRepValsList = {colRepVals.begin()->first, colRepVals.rbegin()->first};\\n        \\n        int ans = INT_MAX;\\n        // Note that to transform a \"01-row\" into another \"01-row\" with the same 0\\'s count & 1\\'s count by \"swapping any pair of digits\", we just have to count how many of the digits are different and take the half.\\n\\n        if (N%2 == 0) {\\n            int halfN = N/2;\\n            if (colRepVals.begin()->second != colRepVals.rbegin()->second) return -1;\\n            if (rowRepVals.begin()->second != rowRepVals.rbegin()->second) return -1;\\n            if (__builtin_popcount(colRepValsList[0]) != halfN || __builtin_popcount(colRepValsList[1]) != halfN) return -1;\\n            if (__builtin_popcount(rowRepValsList[0]) != halfN || __builtin_popcount(rowRepValsList[1]) != halfN) return -1;\\n            \\n            // Traverse the matching options, \\n            for (int a = 0; a < 2; ++a) {\\n                for (int b = 0; b < 2; ++b) {\\n                    int rowCost = (__builtin_popcount(rowRepValsList[0]^valsForLeadingDigits[a]))/2; \\n                    int colCost = (__builtin_popcount(colRepValsList[0]^valsForLeadingDigits[b]))/2; \\n                    ans = min(ans, rowCost+colCost);\\n                }\\n            }\\n        } else {\\n            int majorityEle = -1;\\n            int majorityEleTotCount = (N*N+1)/2;\\n            int minorityEleTotCount = (N*N-1)/2;\\n            int oneTotCount = 0;\\n            for (auto &it : rowRepVals) oneTotCount += it.second*__builtin_popcount(it.first);\\n            \\n            if (oneTotCount == majorityEleTotCount) {\\n                majorityEle = 1;\\n            } else if (oneTotCount == minorityEleTotCount) {\\n                majorityEle = 0;\\n            } else {\\n                return -1;\\n            }\\n                        \\n            int localMajorityCount = (N+1)/2, localMinorityCount = (N-1)/2;\\n            int rowCost = INT_MAX, colCost = INT_MAX;\\n            if (__builtin_popcount(rowRepValsList[0]) == (1 == majorityEle ? localMajorityCount : localMinorityCount)) {\\n                if (debug) printf(\"rowRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", rowRepValsList[0], localMajorityCount, majorityEle);\\n                rowCost = (__builtin_popcount(rowRepValsList[0]^valsForLeadingDigits[majorityEle]))/2;\\n            } else {\\n                if (debug) printf(\"rowRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", rowRepValsList[1], localMajorityCount, majorityEle);\\n                rowCost = (__builtin_popcount(rowRepValsList[1]^valsForLeadingDigits[majorityEle]))/2;\\n            }\\n\\n            if (__builtin_popcount(colRepValsList[0]) == (1 == majorityEle ? localMajorityCount : localMinorityCount)) {\\n                if (debug) printf(\"colRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", colRepValsList[0], localMajorityCount, majorityEle);\\n                colCost = (__builtin_popcount(colRepValsList[0]^valsForLeadingDigits[majorityEle]))/2;\\n            } else {\\n                if (debug) printf(\"colRepVal:%d holds localMajorityCount:%d of the majorityEle:%d\\\\n\", colRepValsList[1], localMajorityCount, majorityEle);\\n                colCost = (__builtin_popcount(colRepValsList[1]^valsForLeadingDigits[majorityEle]))/2;\\n            }\\n            \\n            if (debug) printf(\"N:%d is even, majorityEle is %d, rowCost:%d, colCost:%d\\\\n\", N, majorityEle, rowCost, colCost);\\n            \\n            ans = min(ans, rowCost+colCost);\\n        }\\n        \\n        return (INT_MAX == ans ? -1 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014134,
                "title": "c-straightly-and-ugly-code-but-ac-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int res = min(helper(board, 0), helper(board, 1));\\n        return res == INT_MAX ? -1 : res;\\n    }\\n    int helper(vector<vector<int>> board, int begin) {\\n        int res1 = movesToChessboardForRow(board, begin);\\n        vector<vector<int>> b1 = board;\\n        int res2 = movesToChessboardForCol(board, 0);\\n        int res3 = movesToChessboardForCol(b1, 1);\\n        res1 = res1 == INT_MAX || (res2 == INT_MAX && res3 == INT_MAX) ? INT_MAX : res1 + min(res2, res3);\\n        return res1;\\n    }\\n    int check(vector<vector<int>>& board) {\\n        for(int i = 1; i < board.size(); i++)\\n            if(board[i][0] == board[i - 1][0])\\n                return INT_MAX;\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 1; j < board.size(); j++) {\\n                if(board[i][j] == board[i][j - 1])\\n                    return INT_MAX;\\n            }\\n        }\\n        return 1;\\n    }\\n    int movesToChessboardForRow(vector<vector<int>>& board, int begin) {\\n        int n = board.size(), res = 0;\\n        for(int i = begin; i < n; i++) {\\n            if((i & 1) && board[i][0] != board[0][0]) continue;\\n            if(i > 0 && !(i & 1) && board[i][0] == board[0][0]) continue;\\n            int j = i + 1;\\n            while(j < n && board[j][0] == board[i][0]) j += 2;\\n            if(j >= n) return INT_MAX;\\n            res++;\\n            swapRow(board, i, j);\\n        }\\n        return res;\\n    }\\n    int movesToChessboardForCol(vector<vector<int>>& board, int begin) {\\n        int n = board.size(), res = 0;\\n        for(int i = begin; i < n; i++) {\\n            if((i & 1) && board[0][i] != board[0][0]) continue;\\n            if(i > 0 && !(i & 1) && board[0][i] == board[0][0]) continue;\\n            int j = i + 1;\\n            while(j < n && board[0][j] == board[0][i]) j += 2;\\n            if(j >= n) return INT_MAX;\\n            res++;\\n            swapCol(board, i, j);\\n        }\\n        return check(board) == INT_MAX ? INT_MAX : res;\\n    }\\n    void swapRow(vector<vector<int>>& board, int i, int j) {\\n        for(int col = 0; col < board.size(); col++)\\n            swap(board[i][col], board[j][col]);\\n    }\\n    void swapCol(vector<vector<int>>& board, int i, int j) {\\n        for(int row = 0; row < board.size(); row++)\\n            swap(board[row][i], board[row][j]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int res = min(helper(board, 0), helper(board, 1));\\n        return res == INT_MAX ? -1 : res;\\n    }\\n    int helper(vector<vector<int>> board, int begin) {\\n        int res1 = movesToChessboardForRow(board, begin);\\n        vector<vector<int>> b1 = board;\\n        int res2 = movesToChessboardForCol(board, 0);\\n        int res3 = movesToChessboardForCol(b1, 1);\\n        res1 = res1 == INT_MAX || (res2 == INT_MAX && res3 == INT_MAX) ? INT_MAX : res1 + min(res2, res3);\\n        return res1;\\n    }\\n    int check(vector<vector<int>>& board) {\\n        for(int i = 1; i < board.size(); i++)\\n            if(board[i][0] == board[i - 1][0])\\n                return INT_MAX;\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 1; j < board.size(); j++) {\\n                if(board[i][j] == board[i][j - 1])\\n                    return INT_MAX;\\n            }\\n        }\\n        return 1;\\n    }\\n    int movesToChessboardForRow(vector<vector<int>>& board, int begin) {\\n        int n = board.size(), res = 0;\\n        for(int i = begin; i < n; i++) {\\n            if((i & 1) && board[i][0] != board[0][0]) continue;\\n            if(i > 0 && !(i & 1) && board[i][0] == board[0][0]) continue;\\n            int j = i + 1;\\n            while(j < n && board[j][0] == board[i][0]) j += 2;\\n            if(j >= n) return INT_MAX;\\n            res++;\\n            swapRow(board, i, j);\\n        }\\n        return res;\\n    }\\n    int movesToChessboardForCol(vector<vector<int>>& board, int begin) {\\n        int n = board.size(), res = 0;\\n        for(int i = begin; i < n; i++) {\\n            if((i & 1) && board[0][i] != board[0][0]) continue;\\n            if(i > 0 && !(i & 1) && board[0][i] == board[0][0]) continue;\\n            int j = i + 1;\\n            while(j < n && board[0][j] == board[0][i]) j += 2;\\n            if(j >= n) return INT_MAX;\\n            res++;\\n            swapCol(board, i, j);\\n        }\\n        return check(board) == INT_MAX ? INT_MAX : res;\\n    }\\n    void swapRow(vector<vector<int>>& board, int i, int j) {\\n        for(int col = 0; col < board.size(); col++)\\n            swap(board[i][col], board[j][col]);\\n    }\\n    void swapCol(vector<vector<int>>& board, int i, int j) {\\n        for(int row = 0; row < board.size(); row++)\\n            swap(board[row][i], board[row][j]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506784,
                "title": "java-brute-force-code-is-very-tedious-and-long",
                "content": "```\\nclass Solution {\\n    int n;\\n    public int movesToChessboard(int[][] board) {\\n        n=board.length;int ans=-1;\\n        if(n%2==0){\\n            StringBuilder s2=new StringBuilder();\\n            String s1=coltos(board,0);\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==\\'0\\'){\\n                    s2.append(\"1\");\\n                }else{\\n                    s2.append(\"0\");\\n                }\\n            }\\n            int copy1[][]=copy(board);\\n            int copy2[][]=copy(board);\\n            ans=Math.min(evencase(copy1,s1),evencase(copy2,s2.toString()));\\n        }else{\\n            ans=oddcase(board);\\n        }\\n        return ans;\\n    }\\n    public int evencase(int board[][],String start){\\n        int res=0;\\n        int copyboard[][]=copy(board);\\n        String s=start;\\n        for(int c=0;c<n;c++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=c;i<n;i++){\\n                String cur=coltos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==c){\\n                       found=true;\\n                       s=next.toString();\\n                       break; \\n                    }\\n                    if((i-c)%2==0)continue;\\n                    found=true;\\n                    res++;\\n                    s=next.toString();\\n                    swapcol(board,c,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap col\\n\\n        int copy1[][]=copy(board);\\n        int copy2[][]=copy(board);\\n        s=rowtos(board,0);\\n        StringBuilder s2=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                s2.append(\"1\");\\n            }else{\\n                s2.append(\"0\");\\n            }\\n        }\\n        int val1=subeven(copy1,s);\\n        int val2=subeven(copy2,s2.toString());\\n        if(val1==-1&&val2==-1)return -1;\\n        res+=Math.min(val1,val2);\\n        return res;\\n    }\\n    \\n    \\n    public int subeven(int board[][],String start){\\n        String s=start;\\n        int res=0;\\n        for(int r=0;r<n;r++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=r;i<n;i++){\\n                String cur=rowtos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==r){\\n                         found=true;\\n                        s=next.toString();\\n                        break;\\n                    }\\n                    if((i-r)%2==0)continue;\\n                     found=true;\\n                    res++;\\n                    s=next.toString();\\n                    swaprow(board,r,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap row\\n        return res;\\n    }\\n    \\n    \\n    public int oddcase(int board[][]){\\n        int res=0;int target=n/2+1;\\n        StringBuilder str=new StringBuilder();\\n        String s=\"\";\\n        for(int r=0;r<n;r++){\\n            int counter=0;\\n            for(int c=0;c<n;c++){\\n                if(board[r][c]==1)counter++;\\n            }\\n            if(counter==target){\\n                str.append(\"0\"); //diao guo lai\\n            }else{\\n                str.append(\"1\");\\n            }\\n        }\\n        s=str.toString();\\n        \\n        for(int c=0;c<n;c++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=c;i<n;i++){\\n                String cur=coltos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==c){\\n                        found=true;\\n                       s=next.toString();\\n                       break; \\n                    }\\n                    if((i-c)%2==0)continue;\\n                    found=true;\\n                    res++;\\n                    s=next.toString();\\n                    swapcol(board,c,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap col\\n        \\n        str=new StringBuilder();\\n        \\n        for(int c=0;c<n;c++){\\n            int counter=0;\\n            for(int r=0;r<n;r++){\\n                if(board[r][c]==1)counter++;\\n            }\\n            if(counter==target){\\n                str.append(\"0\"); //diao guo lai\\n            }else{\\n                str.append(\"1\");\\n            }\\n        }\\n        s=str.toString();\\n        \\n        for(int r=0;r<n;r++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=r;i<n;i++){\\n                String cur=rowtos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==r){\\n                        found=true;\\n                        s=next.toString();\\n                        break;\\n                    }\\n                    if((i-r)%2==0)continue;\\n                    res++;found=true;\\n                    s=next.toString();\\n                    swaprow(board,r,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap row\\n        \\n        return res;\\n    }\\n\\n    public String rowtos(int board[][], int row){\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<board.length;i++){\\n            str.append(\"\"+board[row][i]);\\n        }\\n        return str.toString();\\n    }\\n    \\n    public int[][] copy(int board[][]){\\n        int res[][]=new int[n][n];\\n        for(int r=0;r<n;r++){\\n            for(int c=0;c<n;c++){\\n                res[r][c]=board[r][c];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String coltos(int board[][], int col){\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<board.length;i++){\\n            str.append(\"\"+board[i][col]);\\n        }\\n        return str.toString();\\n    }\\n    \\n    public void swaprow(int array[][], int rowA, int rowB) {\\n        int tmpRow[] = array[rowA];\\n        array[rowA] = array[rowB];\\n        array[rowB] = tmpRow;\\n    }\\n    \\n    public void swapcol(int board[][], int colA, int colB){\\n        List<Integer>list=new ArrayList<>(); \\n        for(int r=0;r<board.length;r++){\\n            list.add(board[r][colA]);\\n            board[r][colA]=board[r][colB];\\n        }\\n        for(int i=0;i<list.size();i++){\\n            board[i][colB]=list.get(i);\\n        }\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    public int movesToChessboard(int[][] board) {\\n        n=board.length;int ans=-1;\\n        if(n%2==0){\\n            StringBuilder s2=new StringBuilder();\\n            String s1=coltos(board,0);\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==\\'0\\'){\\n                    s2.append(\"1\");\\n                }else{\\n                    s2.append(\"0\");\\n                }\\n            }\\n            int copy1[][]=copy(board);\\n            int copy2[][]=copy(board);\\n            ans=Math.min(evencase(copy1,s1),evencase(copy2,s2.toString()));\\n        }else{\\n            ans=oddcase(board);\\n        }\\n        return ans;\\n    }\\n    public int evencase(int board[][],String start){\\n        int res=0;\\n        int copyboard[][]=copy(board);\\n        String s=start;\\n        for(int c=0;c<n;c++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=c;i<n;i++){\\n                String cur=coltos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==c){\\n                       found=true;\\n                       s=next.toString();\\n                       break; \\n                    }\\n                    if((i-c)%2==0)continue;\\n                    found=true;\\n                    res++;\\n                    s=next.toString();\\n                    swapcol(board,c,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap col\\n\\n        int copy1[][]=copy(board);\\n        int copy2[][]=copy(board);\\n        s=rowtos(board,0);\\n        StringBuilder s2=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                s2.append(\"1\");\\n            }else{\\n                s2.append(\"0\");\\n            }\\n        }\\n        int val1=subeven(copy1,s);\\n        int val2=subeven(copy2,s2.toString());\\n        if(val1==-1&&val2==-1)return -1;\\n        res+=Math.min(val1,val2);\\n        return res;\\n    }\\n    \\n    \\n    public int subeven(int board[][],String start){\\n        String s=start;\\n        int res=0;\\n        for(int r=0;r<n;r++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=r;i<n;i++){\\n                String cur=rowtos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==r){\\n                         found=true;\\n                        s=next.toString();\\n                        break;\\n                    }\\n                    if((i-r)%2==0)continue;\\n                     found=true;\\n                    res++;\\n                    s=next.toString();\\n                    swaprow(board,r,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap row\\n        return res;\\n    }\\n    \\n    \\n    public int oddcase(int board[][]){\\n        int res=0;int target=n/2+1;\\n        StringBuilder str=new StringBuilder();\\n        String s=\"\";\\n        for(int r=0;r<n;r++){\\n            int counter=0;\\n            for(int c=0;c<n;c++){\\n                if(board[r][c]==1)counter++;\\n            }\\n            if(counter==target){\\n                str.append(\"0\"); //diao guo lai\\n            }else{\\n                str.append(\"1\");\\n            }\\n        }\\n        s=str.toString();\\n        \\n        for(int c=0;c<n;c++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=c;i<n;i++){\\n                String cur=coltos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==c){\\n                        found=true;\\n                       s=next.toString();\\n                       break; \\n                    }\\n                    if((i-c)%2==0)continue;\\n                    found=true;\\n                    res++;\\n                    s=next.toString();\\n                    swapcol(board,c,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap col\\n        \\n        str=new StringBuilder();\\n        \\n        for(int c=0;c<n;c++){\\n            int counter=0;\\n            for(int r=0;r<n;r++){\\n                if(board[r][c]==1)counter++;\\n            }\\n            if(counter==target){\\n                str.append(\"0\"); //diao guo lai\\n            }else{\\n                str.append(\"1\");\\n            }\\n        }\\n        s=str.toString();\\n        \\n        for(int r=0;r<n;r++){\\n            StringBuilder next=new StringBuilder();\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==\\'0\\'){\\n                    next.append(\"1\");\\n                }else{\\n                    next.append(\"0\");\\n                }\\n            }\\n            boolean found=false;\\n            for(int i=r;i<n;i++){\\n                String cur=rowtos(board,i);\\n                if(cur.equals(next.toString())){\\n                    if(i==r){\\n                        found=true;\\n                        s=next.toString();\\n                        break;\\n                    }\\n                    if((i-r)%2==0)continue;\\n                    res++;found=true;\\n                    s=next.toString();\\n                    swaprow(board,r,i);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                return -1;\\n            }\\n        }//swap row\\n        \\n        return res;\\n    }\\n\\n    public String rowtos(int board[][], int row){\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<board.length;i++){\\n            str.append(\"\"+board[row][i]);\\n        }\\n        return str.toString();\\n    }\\n    \\n    public int[][] copy(int board[][]){\\n        int res[][]=new int[n][n];\\n        for(int r=0;r<n;r++){\\n            for(int c=0;c<n;c++){\\n                res[r][c]=board[r][c];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String coltos(int board[][], int col){\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<board.length;i++){\\n            str.append(\"\"+board[i][col]);\\n        }\\n        return str.toString();\\n    }\\n    \\n    public void swaprow(int array[][], int rowA, int rowB) {\\n        int tmpRow[] = array[rowA];\\n        array[rowA] = array[rowB];\\n        array[rowB] = tmpRow;\\n    }\\n    \\n    public void swapcol(int board[][], int colA, int colB){\\n        List<Integer>list=new ArrayList<>(); \\n        for(int r=0;r<board.length;r++){\\n            list.add(board[r][colA]);\\n            board[r][colA]=board[r][colB];\\n        }\\n        for(int i=0;i<list.size();i++){\\n            board[i][colB]=list.get(i);\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313234,
                "title": "java-1-ms-faster-than-100-00-43-6-mb-less-than-88-89",
                "content": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) {\\n            return -1;\\n        }\\n        int N = board.length;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if ((board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        int rowSum = 0;\\n        int colSum = 0;\\n        int rowSwap = 0;\\n        int colSwap = 0;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += board[0][i];\\n            colSum += board[i][0];\\n            if (board[i][0] == i % 2) {\\n                ++rowSwap;\\n            }\\n            if (board[0][i] == i % 2) {\\n                ++colSwap;\\n            }\\n        }\\n        if (N / 2 > rowSum || N / 2 > (N - rowSum) || \\n            N / 2 > colSum || N / 2 > (N - colSum)) {\\n            return -1;\\n        }\\n        if (N % 2 == 0) {\\n            rowSwap = Math.min(rowSwap, N - rowSwap);\\n            colSwap = Math.min(colSwap, N - colSwap);\\n        } else {\\n            if (colSwap % 2 == 1) {\\n                colSwap = N - colSwap;\\n            }\\n            if (rowSwap % 2 == 1) {\\n                rowSwap = N - rowSwap;\\n            }\\n        }\\n        return (rowSwap + colSwap) / 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        if (board == null || board.length == 0 || board[0].length == 0) {\\n            return -1;\\n        }\\n        int N = board.length;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if ((board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        int rowSum = 0;\\n        int colSum = 0;\\n        int rowSwap = 0;\\n        int colSwap = 0;\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += board[0][i];\\n            colSum += board[i][0];\\n            if (board[i][0] == i % 2) {\\n                ++rowSwap;\\n            }\\n            if (board[0][i] == i % 2) {\\n                ++colSwap;\\n            }\\n        }\\n        if (N / 2 > rowSum || N / 2 > (N - rowSum) || \\n            N / 2 > colSum || N / 2 > (N - colSum)) {\\n            return -1;\\n        }\\n        if (N % 2 == 0) {\\n            rowSwap = Math.min(rowSwap, N - rowSwap);\\n            colSwap = Math.min(colSwap, N - colSwap);\\n        } else {\\n            if (colSwap % 2 == 1) {\\n                colSwap = N - colSwap;\\n            }\\n            if (rowSwap % 2 == 1) {\\n                rowSwap = N - rowSwap;\\n            }\\n        }\\n        return (rowSwap + colSwap) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114963,
                "title": "9ms-short-c-solution-easy-to-understand",
                "content": "```\nclass Solution {\npublic:\n    int movesToChessboard(vector<vector<int>>& board) {\n        int N=board.size(),row_bal=0,col_bal=0,c=0,d=0;\n        for(int i=0;i<N;++i){\n            row_bal+=board[0][i]?1:-1;\n            col_bal+=board[i][0]?1:-1;\n            if(i&1){\n                c+=board[0][i];\n                d+=board[i][0];\n            }\n        }\n        if(row_bal>1||row_bal<-1||col_bal>1||col_bal<-1)     return -1;\n        for(int i=1;i<N;++i)\n            for(int j=1;j<N;++j)\n                if(board[i][j]^board[i][0]^board[0][j]^board[0][0])      return -1;\n        \n        if(!row_bal)      return min(N/2-c,c) + min(N/2-d,d);\n        else        return (row_bal>0?c:N/2-c) + (col_bal>0?d:N/2-d);\n    }\n};\n\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int movesToChessboard(vector<vector<int>>& board) {\n        int N=board.size(),row_bal=0,col_bal=0,c=0,d=0;\n        for(int i=0;i<N;++i){\n            row_bal+=board[0][i]?1:-1;\n            col_bal+=board[i][0]?1:-1;\n            if(i&1){\n                c+=board[0][i];\n                d+=board[i][0];\n            }\n        }\n        if(row_bal>1||row_bal<-1||col_bal>1||col_bal<-1)     return -1;\n        for(int i=1;i<N;++i)\n            for(int j=1;j<N;++j)\n                if(board[i][j]^board[i][0]^board[0][j]^board[0][0])      return -1;\n        \n        if(!row_bal)      return min(N/2-c,c) + min(N/2-d,d);\n        else        return (row_bal>0?c:N/2-c) + (col_bal>0?d:N/2-d);\n    }\n};\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682515,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def movesToChessboard(board: Array[Array[Int]]): Int = {\\n      val n = board.length\\n      var rowSum = 0\\n      var colSum = 0\\n      var rowSwap = 0\\n      var colSwap = 0\\n      for (r <- 0 until n; c <- 0 until n)\\n        if ((board(0)(0) ^ board(r)(0) ^ board(0)(c) ^ board(r)(c)) == 1)\\n          return -1\\n      for (i <- 0 until n) {\\n        rowSum += board(0)(i)\\n        colSum += board(i)(0)\\n        rowSwap += (if (board(i)(0) == i % 2) 1 else 0)\\n        colSwap += (if (board(0)(i) == i % 2) 1 else 0)\\n      }\\n      if (n / 2 > rowSum || rowSum > (n + 1) / 2 || n / 2 > colSum || colSum > (n + 1) / 2) -1\\n      else {\\n        if (n % 2 == 1) {\\n          if (colSwap % 2 == 1) colSwap = n - colSwap\\n          if (rowSwap % 2 == 1) rowSwap = n - rowSwap\\n        } else {\\n          colSwap = math.min(n - colSwap, colSwap)\\n          rowSwap = math.min(n - rowSwap, rowSwap)\\n        }\\n        (colSwap + rowSwap) / 2\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def movesToChessboard(board: Array[Array[Int]]): Int = {\\n      val n = board.length\\n      var rowSum = 0\\n      var colSum = 0\\n      var rowSwap = 0\\n      var colSwap = 0\\n      for (r <- 0 until n; c <- 0 until n)\\n        if ((board(0)(0) ^ board(r)(0) ^ board(0)(c) ^ board(r)(c)) == 1)\\n          return -1\\n      for (i <- 0 until n) {\\n        rowSum += board(0)(i)\\n        colSum += board(i)(0)\\n        rowSwap += (if (board(i)(0) == i % 2) 1 else 0)\\n        colSwap += (if (board(0)(i) == i % 2) 1 else 0)\\n      }\\n      if (n / 2 > rowSum || rowSum > (n + 1) / 2 || n / 2 > colSum || colSum > (n + 1) / 2) -1\\n      else {\\n        if (n % 2 == 1) {\\n          if (colSwap % 2 == 1) colSwap = n - colSwap\\n          if (rowSwap % 2 == 1) rowSwap = n - rowSwap\\n        } else {\\n          colSwap = math.min(n - colSwap, colSwap)\\n          rowSwap = math.min(n - rowSwap, rowSwap)\\n        }\\n        (colSwap + rowSwap) / 2\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3616635,
                "title": "swift-solution-with-explanations-and-dry-run",
                "content": "# Approach\\nThe `movesToChessboard` function takes a 2D array (`board`) representing the chessboard configuration as input and returns an integer representing the minimum number of moves required. The code uses a dry run of the algorithm to explain the steps.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. Initialize variables `rowSum`, `colSum`, `rowSwap`, and `colSwap` to keep track of row and column sums, as well as the number of row and column swaps.\\n\\n2. Iterate over each element of the chessboard using nested loops.\\n\\n3. Check if the current element\\'s XOR operation with the top-left element (`board[0][0]`), top element (`board[r][0]`), and left element (`board[0][c]`) is equal to 1. If true, it means there is an invalid configuration, and the function returns -1.\\n\\n4. Calculate the sum of the first row (`rowSum`) and the sum of the first column (`colSum`).\\n\\n5. Determine the number of row swaps (`rowSwap`) and column swaps (`colSwap`) needed. For each row and column, if the current element matches the expected pattern (`i % 2`), increment the respective swap counter.\\n\\n6. Check if the rowSum is within the valid range (`N / 2` to `(N + 1) / 2`). If not, return -1.\\n\\n7. Check if the colSum is within the valid range (`N / 2` to `(N + 1) / 2`). If not, return -1.\\n\\n8. If the size of the chessboard (`N`) is odd, adjust the rowSwap and colSwap counts to minimize the number of swaps.\\n\\n9. If the size of the chessboard is even, take the minimum value between the current swap count and the complement of the swap count (N - swapCount) for both rowSwap and colSwap.\\n\\n10. Calculate the total number of swaps needed by adding rowSwap and colSwap and dividing it by 2.\\n\\n11. Return the minimum number of swaps as the result.\\n\\n\\n# Dry Run\\n```\\nlet board: [[Int]] = [\\n    [0, 1, 1, 0],\\n    [1, 0, 0, 1],\\n    [1, 0, 0, 1],\\n    [0, 1, 1, 0]\\n]\\n\\nlet solution = Solution()\\nlet minMoves = solution.movesToChessboard(board)\\nprint(minMoves)\\n```\\n\\nLet\\'s perform a sample check on the given code with a sample chessboard configuration.\\n\\nIn this example, we have a 4x4 chessboard represented by the `board` array. The elements of the array are either 0 or 1, indicating different pieces on the chessboard.\\n\\nThe provided code will be executed to find the minimum number of moves required to transform this chessboard configuration.\\n\\nStep-by-step execution:\\n1. The code initializes variables `rowSum`, `colSum`, `rowSwap`, and `colSwap` to 0.\\n2. The first nested loop iterates over each element of the chessboard.\\n3. The XOR operation is performed to check the validity of the configuration. In this case, all XOR operations evaluate to 0, indicating a valid configuration.\\n4. The code calculates the row and column sums (`rowSum` and `colSum`) and the number of row and column swaps (`rowSwap` and `colSwap`).\\n   - `rowSum` = 4, `colSum` = 2, `rowSwap` = 2, `colSwap` = 2\\n5. Since the rowSum and colSum are within the valid range, no further checks are required.\\n6. The code checks if the size of the chessboard is odd or even. In this case, it is even.\\n7. The number of swaps needed is calculated by taking the minimum value between the current swap count and its complement for both rowSwap and colSwap. In this case, `rowSwap` and `colSwap` remain unchanged.\\n8. The total number of swaps needed is calculated by adding rowSwap and colSwap and dividing by 2. In this case, it is 2.\\n9. The result, `minMoves`, is set to 2.\\n10. The result, 2, is printed to the console.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    func movesToChessboard(_ board: [[Int]]) -> Int\\n    {\\n        let N = board.count\\n        var rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0\\n        for r in 0..<N\\n        {\\n            for c in 0..<N\\n            {\\n                if (board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1\\n                {\\n                    return -1\\n                }\\n            }\\n        }\\n        for i in 0..<N\\n        {\\n            rowSum += board[0][i]\\n            colSum += board[i][0]\\n            rowSwap += board[i][0] == i % 2 ? 1 : 0\\n            colSwap += board[0][i] == i % 2 ? 1 : 0\\n        }\\n        if N / 2 > rowSum || rowSum > (N + 1) / 2\\n        {\\n            return -1\\n        }\\n        if N / 2 > colSum || colSum > (N + 1) / 2\\n        {\\n            return -1\\n        }\\n        if N % 2 == 1\\n        {\\n            if colSwap % 2 == 1\\n            {\\n                colSwap = N - colSwap\\n            }\\n            if rowSwap % 2 == 1\\n            {\\n                rowSwap = N - rowSwap\\n            }\\n        }\\n        else\\n        {\\n            colSwap = min(N - colSwap, colSwap)\\n            rowSwap = min(N - rowSwap, rowSwap)\\n        }\\n        return (colSwap + rowSwap) / 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nlet board: [[Int]] = [\\n    [0, 1, 1, 0],\\n    [1, 0, 0, 1],\\n    [1, 0, 0, 1],\\n    [0, 1, 1, 0]\\n]\\n\\nlet solution = Solution()\\nlet minMoves = solution.movesToChessboard(board)\\nprint(minMoves)\\n```\n```\\nclass Solution\\n{\\n    func movesToChessboard(_ board: [[Int]]) -> Int\\n    {\\n        let N = board.count\\n        var rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0\\n        for r in 0..<N\\n        {\\n            for c in 0..<N\\n            {\\n                if (board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1\\n                {\\n                    return -1\\n                }\\n            }\\n        }\\n        for i in 0..<N\\n        {\\n            rowSum += board[0][i]\\n            colSum += board[i][0]\\n            rowSwap += board[i][0] == i % 2 ? 1 : 0\\n            colSwap += board[0][i] == i % 2 ? 1 : 0\\n        }\\n        if N / 2 > rowSum || rowSum > (N + 1) / 2\\n        {\\n            return -1\\n        }\\n        if N / 2 > colSum || colSum > (N + 1) / 2\\n        {\\n            return -1\\n        }\\n        if N % 2 == 1\\n        {\\n            if colSwap % 2 == 1\\n            {\\n                colSwap = N - colSwap\\n            }\\n            if rowSwap % 2 == 1\\n            {\\n                rowSwap = N - rowSwap\\n            }\\n        }\\n        else\\n        {\\n            colSwap = min(N - colSwap, colSwap)\\n            rowSwap = min(N - rowSwap, rowSwap)\\n        }\\n        return (colSwap + rowSwap) / 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395038,
                "title": "time-o-n2-o-n2-space-o-1-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def movesToChessboard(self, board: List[List[int]]) -> int:\\n    n = len(board)\\n\\n    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j] for i in range(n) for j in range(n)):\\n      return -1\\n\\n    rowSum = sum(board[0])\\n    colSum = sum(board[i][0] for i in range(n))\\n\\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\\n      return -1\\n    if colSum != n // 2 and colSum != (n + 1) // 2:\\n      return -1\\n\\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\\n\\n    if n & 1:\\n      if rowSwaps & 1:\\n        rowSwaps = n - rowSwaps\\n      if colSwaps & 1:\\n        colSwaps = n - colSwaps\\n    else:\\n      rowSwaps = min(rowSwaps, n - rowSwaps)\\n      colSwaps = min(colSwaps, n - colSwaps)\\n\\n    return (rowSwaps + colSwaps) // 2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def movesToChessboard(self, board: List[List[int]]) -> int:\\n    n = len(board)\\n\\n    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j] for i in range(n) for j in range(n)):\\n      return -1\\n\\n    rowSum = sum(board[0])\\n    colSum = sum(board[i][0] for i in range(n))\\n\\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\\n      return -1\\n    if colSum != n // 2 and colSum != (n + 1) // 2:\\n      return -1\\n\\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\\n\\n    if n & 1:\\n      if rowSwaps & 1:\\n        rowSwaps = n - rowSwaps\\n      if colSwaps & 1:\\n        colSwaps = n - colSwaps\\n    else:\\n      rowSwaps = min(rowSwaps, n - rowSwaps)\\n      colSwaps = min(colSwaps, n - colSwaps)\\n\\n    return (rowSwaps + colSwaps) // 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376093,
                "title": "solid-principles-dimension-independence-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur main insight into the problem is that there must be a balance of either exactly the same or alternating by 1 number of chess piece locations in two rows based on the idea that we have two rows next to each other (think of a 2 by 2 grid as the easiest case, then a 3 x 3, and so on), which you can convince yourself of by building up by 2 x 2 to 3 x 3 to 4 x 4 to 5 x 5 chess grids. \\n\\nThis implies two stopping early conditions we can exploit. These are that there are more than two types of lines based on the frequencies of values between the two rows, or if there are not a balanced valuation of frequencies for the two rows. If we encounter any case with this, we will never be able to swap our chess board (until someone out there decides to invent a fiendish version where we can swap items on one row with items far away on another! That\\'d be horrid!). Similarly, if in our our processing of the two rows, we find that there are not exactly xor sequences when placed on top of each other and doing an xor summation, then we also know that this is not possible for our consideration at all. \\n\\nOnce we have these two cases, we need to figure out what to do in the meantime if we find two rows that are compatabile at some point. \\n\\nTo do so, we will need to determine what the line can start with. \\nIn the case of an even number of items, we obviously need to only start with 0 and 1. But on the case of an odd length row (5 x 5 grid for example) we will need to start with some amalgatation of the count of line1\\'s 1s being 2 times greater than our length of n. This will place us as either 0 and 1 or 1 and 0 depending on the row indice we currently occupy. \\n\\nOnce we know what we can start with, we want the sum of the lists of values that we currently have, namely the value of index - value mod 2 for each index in our row and value in our row depending on if we start with index 0 or index 1. \\n\\nThese then are summed up as two separate valuations in our list of sums of lists of values\\n\\nWe take the minimal account of these by half, and that is our update to our number of swaps. We can do this by half, since we will be swapping two items positions in a maximally advantageous way, and we only need to get the minimal number in order, since once they are in order the maximal are as well. \\n\\nTo process our board then, we need to first set up a bit. We will need of course a size of the board dimensions, n, a number of swaps holder, 0, and a way to know if wwe are balanced, a list of [n//2 and (n+1)//2] \\n\\nWhen we process we then want to take the counter of the map of the tuples of the board with the counter of the zipped board columns \\nThis necessarily gives us row and column independent comparisons\\nIn such a case, \\n- For count in our independent spaces \\n    - if our count is not even (2 types of lines and sorted version of the line values are the balanced ones) we can return -1 \\n    - if our two lines do not form up an alternating pair (xor of one and the others values all the way across) we can return -1 \\n    - otherwise, we need to process a line, including updating our number of swaps accordingly \\nWhen done, if we never returned, we now return our number of swaps \\n\\nTo calculate our moves to chessboard then, we simply call set up for processing board, passing the length of the board and then return the value of the call to process board passing the board.   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAn object oriented approach using solid design principles was the focus of this work. The goal was to limit responsibility of each function to a singular purpose within the problem space. \\n\\n# Complexity\\n- Time complexity: O(N * N) \\n    - We end up exploring the entire board, so it is the size of the board as the limit on time  \\n\\n- Space complexity: O(N) \\n    - Count ends up storing N items for line1 and N items for line2, so total is 2N which reduces to N  \\n\\n# Code\\n```\\nclass Solution:\\n    # check if there are two types of lines or that the sorted values are not the balanced form \\n    # on fail, return -1 \\n    # on pass, return 1 \\n    def check_even(self, count) : \\n        if len(count) != 2 or sorted(count.values()) != self.balanced : \\n            return -1 \\n        return 1\\n\\n    # check if all are alternating row by row \\n    # if so, alternate is good, if not, not possible, return -1 \\n    def all_opposite(self, line1, line2) : \\n        if not all (line1_value ^ line2_value for line1_value, line2_value in zip(line1, line2)) : \\n            return -1 \\n        return 1 \\n    \\n    # set your sums of lists of values based on your current lists of values \\n    def set_sums_of_lists_of_values(self) : \\n        self.sums_of_lists_of_values = [sum(list_of_values) for list_of_values in self.lists_of_values]\\n\\n    # update your number of swaps using your current sums of lists of values \\n    def update_number_of_swaps(self) : \\n        self.number_of_swaps += min(self.sums_of_lists_of_values) // 2\\n\\n    def set_lists_of_values(self, line1) : \\n        self.lists_of_values = []\\n        for start in self.starts : \\n            new_list = []\\n            for index, value in enumerate(line1, start) : \\n                new_list.append((index-value) % 2)\\n            self.lists_of_values.append(new_list)\\n\\n    def set_starting_values(self, line1) : \\n        self.starts = [+(line1.count(1) * 2 > self.n)] if self.n & 1 else [0, 1]\\n\\n    def process_line(self, line1) : \\n        # starts is the starting value of line 1 \\n        # starts gets added to an empty list the value of \\n        # the number of 1s found multipled by 2 is greater than n if n is odd \\n        # this is to deal with the one off 1 factor on odd boards alternating \\n        # otherwise, it gets only 0 and 1 \\n        self.set_starting_values(line1)\\n        # use starts and line1 to build the list \\n        self.set_lists_of_values(line1) \\n        # use the lists of values to build the sums of lists of values \\n        self.set_sums_of_lists_of_values()\\n        # use those to update the number of swaps \\n        self.update_number_of_swaps()\\n\\n    def process_board(self, board) : \\n        # get the count as the pair of tuples of the board as frequencies with the zip of the rows \\n        for count in (collections.Counter(map(tuple, board)), collections.Counter(zip(*board))) :  \\n            # if there are more than 2 kinds of lines or they are not balanced \\n            if self.check_even(count) == -1 : \\n                return -1 \\n            line1, line2 = count\\n            # if the values of the two lines when zipped are not always alternating, also false\\n            # this can be checked with exclusive or of the values in line1 and line 2 as l1v and l2v\\n            if self.all_opposite(line1, line2) == -1 : \\n                return -1 \\n            # pass the line which is the first item in count \\n            self.process_line(line1)\\n        # if you haven\\'t returned yet, return now \\n        return self.number_of_swaps\\n\\n    def set_up_for_processing_board(self, n) : \\n        # n by n board \\n        self.n = n \\n        # number of swaps needed \\n        self.number_of_swaps = 0\\n        # balanced form for chess board \\n        self.balanced = [n//2, (n+1)//2]\\n            \\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        # set up for processing \\n        self.set_up_for_processing_board(len(board))\\n        # then process it \\n        return self.process_board(board)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # check if there are two types of lines or that the sorted values are not the balanced form \\n    # on fail, return -1 \\n    # on pass, return 1 \\n    def check_even(self, count) : \\n        if len(count) != 2 or sorted(count.values()) != self.balanced : \\n            return -1 \\n        return 1\\n\\n    # check if all are alternating row by row \\n    # if so, alternate is good, if not, not possible, return -1 \\n    def all_opposite(self, line1, line2) : \\n        if not all (line1_value ^ line2_value for line1_value, line2_value in zip(line1, line2)) : \\n            return -1 \\n        return 1 \\n    \\n    # set your sums of lists of values based on your current lists of values \\n    def set_sums_of_lists_of_values(self) : \\n        self.sums_of_lists_of_values = [sum(list_of_values) for list_of_values in self.lists_of_values]\\n\\n    # update your number of swaps using your current sums of lists of values \\n    def update_number_of_swaps(self) : \\n        self.number_of_swaps += min(self.sums_of_lists_of_values) // 2\\n\\n    def set_lists_of_values(self, line1) : \\n        self.lists_of_values = []\\n        for start in self.starts : \\n            new_list = []\\n            for index, value in enumerate(line1, start) : \\n                new_list.append((index-value) % 2)\\n            self.lists_of_values.append(new_list)\\n\\n    def set_starting_values(self, line1) : \\n        self.starts = [+(line1.count(1) * 2 > self.n)] if self.n & 1 else [0, 1]\\n\\n    def process_line(self, line1) : \\n        # starts is the starting value of line 1 \\n        # starts gets added to an empty list the value of \\n        # the number of 1s found multipled by 2 is greater than n if n is odd \\n        # this is to deal with the one off 1 factor on odd boards alternating \\n        # otherwise, it gets only 0 and 1 \\n        self.set_starting_values(line1)\\n        # use starts and line1 to build the list \\n        self.set_lists_of_values(line1) \\n        # use the lists of values to build the sums of lists of values \\n        self.set_sums_of_lists_of_values()\\n        # use those to update the number of swaps \\n        self.update_number_of_swaps()\\n\\n    def process_board(self, board) : \\n        # get the count as the pair of tuples of the board as frequencies with the zip of the rows \\n        for count in (collections.Counter(map(tuple, board)), collections.Counter(zip(*board))) :  \\n            # if there are more than 2 kinds of lines or they are not balanced \\n            if self.check_even(count) == -1 : \\n                return -1 \\n            line1, line2 = count\\n            # if the values of the two lines when zipped are not always alternating, also false\\n            # this can be checked with exclusive or of the values in line1 and line 2 as l1v and l2v\\n            if self.all_opposite(line1, line2) == -1 : \\n                return -1 \\n            # pass the line which is the first item in count \\n            self.process_line(line1)\\n        # if you haven\\'t returned yet, return now \\n        return self.number_of_swaps\\n\\n    def set_up_for_processing_board(self, n) : \\n        # n by n board \\n        self.n = n \\n        # number of swaps needed \\n        self.number_of_swaps = 0\\n        # balanced form for chess board \\n        self.balanced = [n//2, (n+1)//2]\\n            \\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        # set up for processing \\n        self.set_up_for_processing_board(len(board))\\n        # then process it \\n        return self.process_board(board)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217079,
                "title": "c-clean-and-simple-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int s, int h, int n) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) ans += (((s>>i&1)==h) != (i%2==0));        \\n        return ans / 2;\\n    }\\n    \\n    \\n    int movesToChessboard(vector<vector<int>>& arr) {     int n = arr.size();\\n        int row[110] = {0};\\n        int col[110] = {0};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                row[i] |= (arr[i][j]==arr[i][0])<<j;    // get row mode\\n                col[j] |= (arr[i][j]==arr[0][j])<<i;\\n            }\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (row[i]!=row[0]) return -1;              // all the rows have the same row mode\\n            if (col[i]!=col[0]) return -1;      \\n        }\\n                                                     \\n        int a = __builtin_popcount(row[0]), b = n-a;\\n        int c = __builtin_popcount(col[0]), d = n-c;\\n        if (abs(a-b) > 1 || abs(c-d) > 1) return -1;        \\n                  \\n        // rows and columns do not affect each other\\n        int u = min(a>=b?solve(row[0],1,n):INT_MAX,b>=a?solve(row[0],0,n):INT_MAX);\\n        int v = min(c>=d?solve(col[0],1,n):INT_MAX,d>=c?solve(col[0],0,n):INT_MAX);\\n        return u + v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int s, int h, int n) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) ans += (((s>>i&1)==h) != (i%2==0));        \\n        return ans / 2;\\n    }\\n    \\n    \\n    int movesToChessboard(vector<vector<int>>& arr) {     int n = arr.size();\\n        int row[110] = {0};\\n        int col[110] = {0};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                row[i] |= (arr[i][j]==arr[i][0])<<j;    // get row mode\\n                col[j] |= (arr[i][j]==arr[0][j])<<i;\\n            }\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (row[i]!=row[0]) return -1;              // all the rows have the same row mode\\n            if (col[i]!=col[0]) return -1;      \\n        }\\n                                                     \\n        int a = __builtin_popcount(row[0]), b = n-a;\\n        int c = __builtin_popcount(col[0]), d = n-c;\\n        if (abs(a-b) > 1 || abs(c-d) > 1) return -1;        \\n                  \\n        // rows and columns do not affect each other\\n        int u = min(a>=b?solve(row[0],1,n):INT_MAX,b>=a?solve(row[0],0,n):INT_MAX);\\n        int v = min(c>=d?solve(col[0],1,n):INT_MAX,d>=c?solve(col[0],0,n):INT_MAX);\\n        return u + v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102973,
                "title": "java-working-wit-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the minimum number of swaps required to transform the given board into a \"chessboard\". A chessboard is defined as having alternating 1s and 0s row-wise and column-wise. For example: \\n\\n```\\n[0, 1, 0, 1]\\n[1, 0, 1, 0]\\n[0, 1, 0, 1]\\n[1, 0, 1, 0]\\n```\\n\\nTo achieve this, we can take the following steps: \\n1. First, check if it\\'s even possible to transform the board into a chessboard. If not, return -1. \\n2. Check if the number of 1s and 0s on each row and column are within valid range (i.e. if they\\'re both either greater than \"N/2\" or less than \"(N+1)/2\"). If not, then return -1. \\n3. Then we can count the number of row and column swaps required, and return the sum/2 of both these values, as each swap fixes 2 cells (1 row and 1 column). \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm we can use is as follows: \\n1. Iterate through the board and check if it is possible to transform it into a chessboard, as defined above. \\n2. Iterate again, this time counting the number of 1s and 0s in each row and column. \\n3. Calculate the row and column swaps needed and return the sum/2 of both these values. \\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere N is the number of cells in each row or column of the board \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int r = 0; r < N; ++r)\\n            for (int c = 0; c < N; ++c) {\\n                if ((board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1)\\n                    return -1;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += board[0][i];\\n            colSum += board[i][0];\\n            rowSwap += board[i][0] == i % 2 ? 1 : 0;\\n            colSwap += board[0][i] == i % 2 ? 1 : 0;\\n        }\\n        if (N / 2 > rowSum || rowSum > (N + 1) / 2) return -1;\\n        if (N / 2 > colSum || colSum > (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[0, 1, 0, 1]\\n[1, 0, 1, 0]\\n[0, 1, 0, 1]\\n[1, 0, 1, 0]\\n```\n```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int N = board.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\\n        for (int r = 0; r < N; ++r)\\n            for (int c = 0; c < N; ++c) {\\n                if ((board[0][0] ^ board[r][0] ^ board[0][c] ^ board[r][c]) == 1)\\n                    return -1;\\n            }\\n        for (int i = 0; i < N; ++i) {\\n            rowSum += board[0][i];\\n            colSum += board[i][0];\\n            rowSwap += board[i][0] == i % 2 ? 1 : 0;\\n            colSwap += board[0][i] == i % 2 ? 1 : 0;\\n        }\\n        if (N / 2 > rowSum || rowSum > (N + 1) / 2) return -1;\\n        if (N / 2 > colSum || colSum > (N + 1) / 2) return -1;\\n        if (N % 2 == 1) {\\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\\n        } else {\\n            colSwap = Math.min(N - colSwap, colSwap);\\n            rowSwap = Math.min(N - rowSwap, rowSwap);\\n        }\\n        return (colSwap + rowSwap) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917784,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {\\n        let n = board.len();\\n        let mut row = 0;\\n        let mut col = 0;\\n        let mut row_diff = 0;\\n        let mut col_diff = 0;\\n        for i in 0..n {\\n            for j in 0..n {\\n                if board[0][0] ^ board[0][j] ^ board[i][0] ^ board[i][j] == 1 {\\n                    return -1;\\n                }\\n            }\\n        }\\n        for i in 0..n {\\n            row += board[0][i];\\n            col += board[i][0];\\n            if board[i][0] == i as i32 % 2 {\\n                row_diff += 1;\\n            }\\n            if board[0][i] == i as i32 % 2 {\\n                col_diff += 1;\\n            }\\n        }\\n        if row < n as i32 / 2 || row > (n as i32 + 1) / 2 {\\n            return -1;\\n        }\\n        if col < n as i32 / 2 || col > (n as i32 + 1) / 2 {\\n            return -1;\\n        }\\n        if n % 2 == 1 {\\n            if row_diff % 2 == 1 {\\n                row_diff = n - row_diff;\\n            }\\n            if col_diff % 2 == 1 {\\n                col_diff = n - col_diff;\\n            }\\n        } else {\\n            row_diff = std::cmp::min(row_diff, n - row_diff);\\n            col_diff = std::cmp::min(col_diff, n - col_diff);\\n        }\\n        ((row_diff + col_diff) / 2) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {\\n        let n = board.len();\\n        let mut row = 0;\\n        let mut col = 0;\\n        let mut row_diff = 0;\\n        let mut col_diff = 0;\\n        for i in 0..n {\\n            for j in 0..n {\\n                if board[0][0] ^ board[0][j] ^ board[i][0] ^ board[i][j] == 1 {\\n                    return -1;\\n                }\\n            }\\n        }\\n        for i in 0..n {\\n            row += board[0][i];\\n            col += board[i][0];\\n            if board[i][0] == i as i32 % 2 {\\n                row_diff += 1;\\n            }\\n            if board[0][i] == i as i32 % 2 {\\n                col_diff += 1;\\n            }\\n        }\\n        if row < n as i32 / 2 || row > (n as i32 + 1) / 2 {\\n            return -1;\\n        }\\n        if col < n as i32 / 2 || col > (n as i32 + 1) / 2 {\\n            return -1;\\n        }\\n        if n % 2 == 1 {\\n            if row_diff % 2 == 1 {\\n                row_diff = n - row_diff;\\n            }\\n            if col_diff % 2 == 1 {\\n                col_diff = n - col_diff;\\n            }\\n        } else {\\n            row_diff = std::cmp::min(row_diff, n - row_diff);\\n            col_diff = std::cmp::min(col_diff, n - col_diff);\\n        }\\n        ((row_diff + col_diff) / 2) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563498,
                "title": "python3",
                "content": "class Solution:\\n\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        res = 0\\n        rowCnt = Counter(map(tuple,board))\\n        colCnt = Counter(zip(*board))\\n        \\n        for count in (rowCnt,colCnt):\\n            if len(count)!=2:\\n                return -1\\n            \\n            if sorted(count.values())!=[n//2,(n+1)//2]:\\n                return -1\\n            \\n            for key in count:\\n                cnt = Counter(key)\\n                if sorted(cnt.values())!=[n//2,(n+1)//2]:\\n                    return -1\\n                \\n            line1,line2 = count\\n            if not all(x^y for x,y in zip(line1,line2)):\\n                return -1\\n            \\n            if n%2:\\n                expect = 1 if line1.count(1)>line1.count(0) else 0\\n                moves = 0\\n                for x in line1:\\n                    moves+=x^expect\\n                    expect^=1\\n                res+=moves//2\\n            else:\\n                moves = float(\\'inf\\')\\n                for expect in (0,1):\\n                    currMove = 0\\n                    for x in line1:\\n                        currMove+=x^expect\\n                        expect^=1\\n                    moves = min(moves,currMove)\\n                res+=moves//2\\n                \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        res = 0\\n        rowCnt = Counter(map(tuple,board))\\n        colCnt = Counter(zip(*board))\\n        \\n        for count in (rowCnt,colCnt):\\n            if len(count)!=2:\\n                return -1\\n            \\n            if sorted(count.values())!=[n//2,(n+1)//2]:\\n                return -1\\n            \\n            for key in count:\\n                cnt = Counter(key)\\n                if sorted(cnt.values())!=[n//2,(n+1)//2]:\\n                    return -1\\n                \\n            line1,line2 = count\\n            if not all(x^y for x,y in zip(line1,line2)):\\n                return -1\\n            \\n            if n%2:\\n                expect = 1 if line1.count(1)>line1.count(0) else 0\\n                moves = 0\\n                for x in line1:\\n                    moves+=x^expect\\n                    expect^=1\\n                res+=moves//2\\n            else:\\n                moves = float(\\'inf\\')\\n                for expect in (0,1):\\n                    currMove = 0\\n                    for x in line1:\\n                        currMove+=x^expect\\n                        expect^=1\\n                    moves = min(moves,currMove)\\n                res+=moves//2\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1961122,
                "title": "python-o-n-solution-o-n-2-check-for-possibility-with-comments-no-graphs",
                "content": "\\n\\tdef movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        \\n        # check that there are half zeroes and half ones in the first row and column\\n        ones = sum(board[0])\\n        if ones != n//2 and ones != (n+1)//2:\\n            return -1\\n        ones = sum(board[i][0] for i in range(n))\\n        if ones != n//2 and ones != (n+1)//2:\\n            return -1\\n        \\n        # check that all the rows are either exactly the same as first or exactly inverted\\n        inv = 0\\n        for i in range(1,n):                \\n            if all(board[i][j] == board[0][j] for j in range(n)):\\n                pass\\n            elif all(board[i][j] != board[0][j] for j in range(n)):\\n                inv += 1\\n            else:\\n                return -1\\n                \\n        # the number of inversions should be half of n\\n        if inv != n//2 and inv != (n+1)//2:\\n            return -1\\n        \\n        # same for columns\\n        inv = 0\\n        for j in range(1,n):                \\n            if all(board[i][j] == board[i][0] for i in range(n)):\\n                pass\\n            elif all(board[i][j] != board[i][0] for i in range(n)):\\n                inv += 1\\n            else:\\n                return -1\\n            \\n        if inv != n//2 and inv != (n+1)//2:\\n            return -1\\n            \\n        # now we know the transformation is possible\\n        # count the difference from \"01010...\" in the first row and column\\n        diff_h = sum(1 for j in range(n) if board[0][j] == j%2)\\n        diff_v = sum(1 for i in range(n) if board[i][0] == i%2)\\n        if n%2:\\n            #for odd n: the right order is when diff is even\\n            return (diff_h if diff_h%2==0 else n-diff_h)//2 + \\\\\\n                   (diff_v if diff_v%2==0 else n-diff_v)//2\\n        else:\\n            #for even n: any order is fine\\n            return min(diff_h,n-diff_h)//2 + \\\\\\n                   min(diff_v,n-diff_v)//2\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\tdef movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        \\n        # check that there are half zeroes and half ones in the first row and column\\n        ones = sum(board[0])\\n        if ones != n//2 and ones != (n+1)//2:\\n            return -1\\n        ones = sum(board[i][0] for i in range(n))\\n        if ones != n//2 and ones != (n+1)//2:\\n            return -1\\n        \\n        # check that all the rows are either exactly the same as first or exactly inverted\\n        inv = 0\\n        for i in range(1,n):                \\n            if all(board[i][j] == board[0][j] for j in range(n)):\\n                pass\\n            elif all(board[i][j] != board[0][j] for j in range(n)):\\n                inv += 1\\n            else:\\n                return -1\\n                \\n        # the number of inversions should be half of n\\n        if inv != n//2 and inv != (n+1)//2:\\n            return -1\\n        \\n        # same for columns\\n        inv = 0\\n        for j in range(1,n):                \\n            if all(board[i][j] == board[i][0] for i in range(n)):\\n                pass\\n            elif all(board[i][j] != board[i][0] for i in range(n)):\\n                inv += 1\\n            else:\\n                return -1\\n            \\n        if inv != n//2 and inv != (n+1)//2:\\n            return -1\\n            \\n        # now we know the transformation is possible\\n        # count the difference from \"01010...\" in the first row and column\\n        diff_h = sum(1 for j in range(n) if board[0][j] == j%2)\\n        diff_v = sum(1 for i in range(n) if board[i][0] == i%2)\\n        if n%2:\\n            #for odd n: the right order is when diff is even\\n            return (diff_h if diff_h%2==0 else n-diff_h)//2 + \\\\\\n                   (diff_v if diff_v%2==0 else n-diff_v)//2\\n        else:\\n            #for even n: any order is fine\\n            return min(diff_h,n-diff_h)//2 + \\\\\\n                   min(diff_v,n-diff_v)//2\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1933646,
                "title": "c-o-n-2-reduce-2d-problem-to-2-1d-problems",
                "content": "Rows and columns are orthogonal. You can make columns alternating and then make rows alternating or vice versa.\\nThere can only be two unique rows and columns in a solvable board. Then this problem is reduced to 1d problems. Given a sequeune of the type of row/column, find steps required to make all it an alternating sequence.\\n```\\nclass Solution {\\n    const int inf = 1e9;\\n    void transpose(vector<vector<int>>& board) {\\n        const int n = board.size();\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < i; j++)\\n                swap(board[i][j], board[j][i]);\\n    }\\n    \\n    bool isSame(vector<int> &r1, vector<int>& r2) {\\n        const int n = r1.size();\\n        for (int i = 0; i < n; i++)\\n            if (r1[i] != r2[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool isOpposite(vector<int> &r1, vector<int>& r2) {\\n        const int n = r1.size();\\n        for (int i = 0; i < n; i++)\\n            if (r1[i] == r2[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    int getSteps(vector<vector<int>> &&confusionMatrix) {\\n        int steps = inf;\\n        \\n        if (confusionMatrix[0][1] == confusionMatrix[1][0])\\n            steps = confusionMatrix[0][1];\\n        \\n        if (confusionMatrix[0][0] == confusionMatrix[1][1])\\n            steps = min(steps, confusionMatrix[0][0]);\\n        \\n        return steps;\\n    }\\n    \\n    vector<vector<int>> getConfusionMatrix(vector<int>& rowType) {\\n        const int n = rowType.size();\\n        vector<vector<int>> confusionMatrix(2, vector<int>(2, 0));\\n        for (int i = 0; i < n; i++)\\n            confusionMatrix[rowType[i]][i & 1]++;\\n        return confusionMatrix;\\n    }\\n    \\n    int solve1d(vector<int> &arr) {\\n        return getSteps(getConfusionMatrix(arr));\\n    }\\n    \\n    int makeColumnsAlternating(vector<vector<int>>& board) {\\n        const int n = board.size();\\n        vector<int> rowType(n, 0);\\n        for (int i = 1; i < n; i++)\\n            if (isOpposite(board[0], board[i]))\\n                rowType[i] = 1;\\n            else if (!isSame(board[0], board[i]))\\n                return inf;\\n        return solve1d(rowType);\\n    }\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int steps = makeColumnsAlternating(board);\\n        transpose(board);\\n        steps += makeColumnsAlternating(board);\\n        if (steps >= inf)\\n            return -1;\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    const int inf = 1e9;\\n    void transpose(vector<vector<int>>& board) {\\n        const int n = board.size();\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < i; j++)\\n                swap(board[i][j], board[j][i]);\\n    }\\n    \\n    bool isSame(vector<int> &r1, vector<int>& r2) {\\n        const int n = r1.size();\\n        for (int i = 0; i < n; i++)\\n            if (r1[i] != r2[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool isOpposite(vector<int> &r1, vector<int>& r2) {\\n        const int n = r1.size();\\n        for (int i = 0; i < n; i++)\\n            if (r1[i] == r2[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    int getSteps(vector<vector<int>> &&confusionMatrix) {\\n        int steps = inf;\\n        \\n        if (confusionMatrix[0][1] == confusionMatrix[1][0])\\n            steps = confusionMatrix[0][1];\\n        \\n        if (confusionMatrix[0][0] == confusionMatrix[1][1])\\n            steps = min(steps, confusionMatrix[0][0]);\\n        \\n        return steps;\\n    }\\n    \\n    vector<vector<int>> getConfusionMatrix(vector<int>& rowType) {\\n        const int n = rowType.size();\\n        vector<vector<int>> confusionMatrix(2, vector<int>(2, 0));\\n        for (int i = 0; i < n; i++)\\n            confusionMatrix[rowType[i]][i & 1]++;\\n        return confusionMatrix;\\n    }\\n    \\n    int solve1d(vector<int> &arr) {\\n        return getSteps(getConfusionMatrix(arr));\\n    }\\n    \\n    int makeColumnsAlternating(vector<vector<int>>& board) {\\n        const int n = board.size();\\n        vector<int> rowType(n, 0);\\n        for (int i = 1; i < n; i++)\\n            if (isOpposite(board[0], board[i]))\\n                rowType[i] = 1;\\n            else if (!isSame(board[0], board[i]))\\n                return inf;\\n        return solve1d(rowType);\\n    }\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int steps = makeColumnsAlternating(board);\\n        transpose(board);\\n        steps += makeColumnsAlternating(board);\\n        if (steps >= inf)\\n            return -1;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603382,
                "title": "java-bfs-dfs-but-tle",
                "content": "\\nHope anyone can improve my solution.\\n\\n...\\npublic int movesToChessboard(int[][] board) {\\n        if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) return -1;\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        HashSet<String> visited = new HashSet<>(); // hashvalue, the board status\\n        visited.add(getHash(board));\\n        Queue<int[][]> q = new LinkedList<>();\\n        q.offer(board);\\n        int res = 0;\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[][] cur = q.poll();\\n                if (isValid(cur)) {\\n                    return res;\\n                }\\n                // changes rows\\n                for (int i = 0; i < row; i++) {\\n                    for (int j  = i + 1; j < row; j++) {\\n                        int[][] newBoard = getNewRow(cur, i, j);\\n                        if (!visited.contains(getHash(newBoard))) {\\n                            q.offer(newBoard);\\n                            visited.add(getHash(newBoard));\\n                        }\\n                    }\\n                }\\n                // changes cols\\n                for (int i = 0; i < col; i++) {\\n                    for (int j  = i + 1; j < col; j++) {\\n                        int[][] newBoard = getNewCol(cur, i, j);\\n                        if (!visited.contains(getHash(newBoard))) {\\n                            q.offer(newBoard);\\n                            visited.add(getHash(newBoard));\\n                        }\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n     private int[][] getNewCol(int[][] board, int i, int j) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        int[][] newBoard = new int[row][col];\\n        for (int ii = 0; ii < row; ii++) {\\n            for (int jj = 0; jj < col; jj++) {\\n                newBoard[ii][jj] = board[ii][jj];\\n            }\\n        }\\n        \\n        for (int t = 0; t < row; t++) {\\n            int cur = newBoard[t][i];\\n            newBoard[t][i] = newBoard[t][j];\\n            newBoard[t][j] = cur;\\n        }\\n        return newBoard;\\n    }\\n    \\n    private int[][] getNewRow(int[][] board, int i, int j) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        int[][] newBoard = new int[row][col];\\n        for (int ii = 0; ii < row; ii++) {\\n            for (int jj = 0; jj < col; jj++) {\\n                newBoard[ii][jj] = board[ii][jj];\\n            }\\n        }\\n        \\n        for (int t = 0; t < col; t++) {\\n            int cur = newBoard[i][t];\\n            newBoard[i][t] = newBoard[j][t];\\n            newBoard[j][t] = cur;\\n        }\\n        return newBoard;\\n    }\\n    \\n    private boolean isValid(int[][] cur) {\\n        int[][] visited = new int[cur.length][cur[0].length];\\n        if (cur[0][0] == 1) {\\n            if (dfs(cur, 0, 0, 0, visited)) return true;\\n        } else {\\n            if (dfs(cur, 0, 0, 1, visited)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(int[][] cur, int i, int j, int value, int[][] visited) {\\n        if (i < 0 || j < 0 || i >= cur.length || j >= cur[0].length) return true;\\n        if (cur[i][j] == value) return false;\\n        if (visited[i][j] == 1) return true;\\n        \\n        int curVal = cur[i][j];\\n        visited[i][j] = 1;\\n        if (dfs(cur, i + 1, j, curVal, visited) && dfs(cur, i - 1, j, curVal, visited) &&\\n            dfs(cur, i, j + 1, curVal, visited) && dfs(cur, i, j - 1, curVal, visited)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    private String getHash(int[][] board) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                sb.append(board[i][j]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n\\t...",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\nHope anyone can improve my solution.\\n\\n...\\npublic int movesToChessboard(int[][] board) {\\n        if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) return -1;\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        HashSet<String> visited = new HashSet<>(); // hashvalue, the board status\\n        visited.add(getHash(board));\\n        Queue<int[][]> q = new LinkedList<>();\\n        q.offer(board);\\n        int res = 0;\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[][] cur = q.poll();\\n                if (isValid(cur)) {\\n                    return res;\\n                }\\n                // changes rows\\n                for (int i = 0; i < row; i++) {\\n                    for (int j  = i + 1; j < row; j++) {\\n                        int[][] newBoard = getNewRow(cur, i, j);\\n                        if (!visited.contains(getHash(newBoard))) {\\n                            q.offer(newBoard);\\n                            visited.add(getHash(newBoard));\\n                        }\\n                    }\\n                }\\n                // changes cols\\n                for (int i = 0; i < col; i++) {\\n                    for (int j  = i + 1; j < col; j++) {\\n                        int[][] newBoard = getNewCol(cur, i, j);\\n                        if (!visited.contains(getHash(newBoard))) {\\n                            q.offer(newBoard);\\n                            visited.add(getHash(newBoard));\\n                        }\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n     private int[][] getNewCol(int[][] board, int i, int j) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        int[][] newBoard = new int[row][col];\\n        for (int ii = 0; ii < row; ii++) {\\n            for (int jj = 0; jj < col; jj++) {\\n                newBoard[ii][jj] = board[ii][jj];\\n            }\\n        }\\n        \\n        for (int t = 0; t < row; t++) {\\n            int cur = newBoard[t][i];\\n            newBoard[t][i] = newBoard[t][j];\\n            newBoard[t][j] = cur;\\n        }\\n        return newBoard;\\n    }\\n    \\n    private int[][] getNewRow(int[][] board, int i, int j) {\\n        int row = board.length;\\n        int col = board[0].length;\\n        int[][] newBoard = new int[row][col];\\n        for (int ii = 0; ii < row; ii++) {\\n            for (int jj = 0; jj < col; jj++) {\\n                newBoard[ii][jj] = board[ii][jj];\\n            }\\n        }\\n        \\n        for (int t = 0; t < col; t++) {\\n            int cur = newBoard[i][t];\\n            newBoard[i][t] = newBoard[j][t];\\n            newBoard[j][t] = cur;\\n        }\\n        return newBoard;\\n    }\\n    \\n    private boolean isValid(int[][] cur) {\\n        int[][] visited = new int[cur.length][cur[0].length];\\n        if (cur[0][0] == 1) {\\n            if (dfs(cur, 0, 0, 0, visited)) return true;\\n        } else {\\n            if (dfs(cur, 0, 0, 1, visited)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(int[][] cur, int i, int j, int value, int[][] visited) {\\n        if (i < 0 || j < 0 || i >= cur.length || j >= cur[0].length) return true;\\n        if (cur[i][j] == value) return false;\\n        if (visited[i][j] == 1) return true;\\n        \\n        int curVal = cur[i][j];\\n        visited[i][j] = 1;\\n        if (dfs(cur, i + 1, j, curVal, visited) && dfs(cur, i - 1, j, curVal, visited) &&\\n            dfs(cur, i, j + 1, curVal, visited) && dfs(cur, i, j - 1, curVal, visited)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    private String getHash(int[][] board) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                sb.append(board[i][j]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n\\t...",
                "codeTag": "Unknown"
            },
            {
                "id": 1493909,
                "title": "java-exclude-impossible-cases-then-calculate-diff-row-col",
                "content": "![image](https://assets.leetcode.com/users/images/124fae9f-d31a-4775-b694-da2f690526bc_1632939415.3491814.png)\\n```java\\n    public int movesToChessboard(int[][] board) {\\n        // count how many ones in the first row and first col\\n        int rowOneCount = 0;\\n        int colOneCount = 0;\\n        for (int[] ints : board) {\\n            if (ints[0] == 1) {\\n                ++rowOneCount;\\n            }\\n        }\\n        for (int i : board[0]) {\\n            if (i == 1) {\\n                ++colOneCount;\\n            }\\n        }\\n        final int half = board.length >> 1;\\n\\n        if (board.length % 2 == 0) {\\n            // if N is even, count of one must equal to half of N\\n            if (half != rowOneCount || half != colOneCount) {\\n                return -1;\\n            }\\n        } else {\\n            // if N is odd, count of one could be half or half+1\\n            if ((half != rowOneCount) && (half + 1 != rowOneCount)) {\\n                return -1;\\n            }\\n            if ((half != colOneCount) && (half + 1 != colOneCount)) {\\n                return -1;\\n            }\\n        }\\n        // if two adjacent row/col are same at the first row/col, they must be all 1 or all 0\\n        for (int i = 1; i < board.length; i++) {\\n            final boolean rowSame = board[i][0] == board[i - 1][0];\\n            final boolean colSame = board[0][i] == board[0][i - 1];\\n            for (int j = 1; j < board.length; j++) {\\n                if (rowSame && board[i - 1][j] != board[i][j]) {\\n                    return -1;\\n                }\\n                if (!rowSame && board[i - 1][j] == board[i][j]) {\\n                    return -1;\\n                }\\n                if (colSame && board[j][i - 1] != board[j][i]) {\\n                    return -1;\\n                }\\n                if (!colSame && board[j][i - 1] == board[j][i]) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        if (board.length % 2 == 0) {\\n            // if N is even, suppose the first element is 0, calculate diff of row/col\\n            int rowDiff = 0;\\n            int colDiff = 0;\\n            for (int i = 0; i < board.length; i++) {\\n                if (board[i][0] != row) {\\n                    rowDiff++;\\n                }\\n                if (board[0][i] != col) {\\n                    colDiff++;\\n                }\\n                row = 1 - row;\\n                col = 1 - col;\\n            }\\n            // (N - diff) suppose the first element is 1\\n            // swap two different row/cols only need 1 transform, so diff / 2\\n            return Math.min(rowDiff, board.length - rowDiff) / 2 + Math.min(colDiff, board.length - colDiff) / 2;\\n        } else {\\n            // if N is odd, determine the first element based on the count of one\\n            row = rowOneCount == half + 1 ? 1 : 0;\\n            col = colOneCount == half + 1 ? 1 : 0;\\n            int diff = 0;\\n            for (int i = 0; i < board.length; i++) {\\n                if (board[i][0] != row) {\\n                    diff++;\\n                }\\n                if (board[0][i] != col) {\\n                    diff++;\\n                }\\n                row = 1 - row;\\n                col = 1 - col;\\n            }\\n            // since the first element is fixed, return diff / 2\\n            return diff >> 1;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public int movesToChessboard(int[][] board) {\\n        // count how many ones in the first row and first col\\n        int rowOneCount = 0;\\n        int colOneCount = 0;\\n        for (int[] ints : board) {\\n            if (ints[0] == 1) {\\n                ++rowOneCount;\\n            }\\n        }\\n        for (int i : board[0]) {\\n            if (i == 1) {\\n                ++colOneCount;\\n            }\\n        }\\n        final int half = board.length >> 1;\\n\\n        if (board.length % 2 == 0) {\\n            // if N is even, count of one must equal to half of N\\n            if (half != rowOneCount || half != colOneCount) {\\n                return -1;\\n            }\\n        } else {\\n            // if N is odd, count of one could be half or half+1\\n            if ((half != rowOneCount) && (half + 1 != rowOneCount)) {\\n                return -1;\\n            }\\n            if ((half != colOneCount) && (half + 1 != colOneCount)) {\\n                return -1;\\n            }\\n        }\\n        // if two adjacent row/col are same at the first row/col, they must be all 1 or all 0\\n        for (int i = 1; i < board.length; i++) {\\n            final boolean rowSame = board[i][0] == board[i - 1][0];\\n            final boolean colSame = board[0][i] == board[0][i - 1];\\n            for (int j = 1; j < board.length; j++) {\\n                if (rowSame && board[i - 1][j] != board[i][j]) {\\n                    return -1;\\n                }\\n                if (!rowSame && board[i - 1][j] == board[i][j]) {\\n                    return -1;\\n                }\\n                if (colSame && board[j][i - 1] != board[j][i]) {\\n                    return -1;\\n                }\\n                if (!colSame && board[j][i - 1] == board[j][i]) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        if (board.length % 2 == 0) {\\n            // if N is even, suppose the first element is 0, calculate diff of row/col\\n            int rowDiff = 0;\\n            int colDiff = 0;\\n            for (int i = 0; i < board.length; i++) {\\n                if (board[i][0] != row) {\\n                    rowDiff++;\\n                }\\n                if (board[0][i] != col) {\\n                    colDiff++;\\n                }\\n                row = 1 - row;\\n                col = 1 - col;\\n            }\\n            // (N - diff) suppose the first element is 1\\n            // swap two different row/cols only need 1 transform, so diff / 2\\n            return Math.min(rowDiff, board.length - rowDiff) / 2 + Math.min(colDiff, board.length - colDiff) / 2;\\n        } else {\\n            // if N is odd, determine the first element based on the count of one\\n            row = rowOneCount == half + 1 ? 1 : 0;\\n            col = colOneCount == half + 1 ? 1 : 0;\\n            int diff = 0;\\n            for (int i = 0; i < board.length; i++) {\\n                if (board[i][0] != row) {\\n                    diff++;\\n                }\\n                if (board[0][i] != col) {\\n                    diff++;\\n                }\\n                row = 1 - row;\\n                col = 1 - col;\\n            }\\n            // since the first element is fixed, return diff / 2\\n            return diff >> 1;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492259,
                "title": "java-beats-98-long-but-simple",
                "content": "Consider we\\'re given the initial board\\n\\n1 1 0 0\\n0 0 1 1\\n1 1 0 0\\n0 0 1 1\\n\\nThis algorithm begins by creating two lists: \\n\\nAdjustedRows = [1, 2, 1, 2]\\nAdjustedCols = [1, 1, 2, 2]\\n\\nIt then processes these lists to determine the number of swaps necessary to get into chessboard formation. Chessboard formation for the Adjusted arrays just corresponds to both being [1, 2, 1, 2].\\n\\nTo see how many swaps are necessary, it compares every other index of AdjustedRows and AdjustedCols to the solution board. Any entries that are different than the solution mean that a swap for that position is required.\\n\\n```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int[] boardValue = {-1, 1};\\n        int size = board.length;\\n        \\n        short[] adjustedRows = new short[size], adjustedCols = new short[size];\\n        int[] uniqueRows = new int[2], uniqueCols = new int[2];\\n        \\n        int rowCount = 0, colCount = 0;\\n        \\n        // Iterate over col and row.\\n        int colDifferential, rowDifferential, colCurrent, rowCurrent;\\n        for(int i = 0; i < size; i++){\\n            colDifferential = 0;\\n            rowDifferential = 0;\\n            \\n            colCurrent = 0;\\n            rowCurrent = 0;\\n            \\n            // Collect column, row into ints\\n            for(int j = 0; j < size; j++){\\n                int colEntry = board[j][i];\\n                int rowEntry = board[i][j];\\n\\n                colCurrent = colCurrent << 1;\\n                rowCurrent = rowCurrent << 1;\\n                \\n                colCurrent |= colEntry;\\n                rowCurrent |= rowEntry;\\n                \\n                colDifferential += boardValue[colEntry];\\n                rowDifferential += boardValue[rowEntry];\\n            }\\n            \\n            // Count row\\n            if(uniqueRows[0] == rowCurrent || uniqueRows[0] == 0){\\n                uniqueRows[0] = rowCurrent;\\n                rowCount += 1;\\n                adjustedRows[i] = 1;\\n            } else if(uniqueRows[1] == rowCurrent || uniqueRows[1] == 0){\\n                uniqueRows[1] = rowCurrent;\\n                rowCount -= 1;\\n                adjustedRows[i] = 2;\\n            } else {\\n                // This is a third unique row, which is impossible to solve.\\n                return -1;\\n            }\\n            \\n            // Count col\\n            if(uniqueCols[0] == colCurrent || uniqueCols[0] == 0){\\n                uniqueCols[0] = colCurrent;\\n                colCount += 1;\\n                adjustedCols[i] = 1;\\n            } else if(uniqueCols[1] == colCurrent || uniqueCols[1] == 0){\\n                uniqueCols[1] = colCurrent;\\n                colCount -= 1;\\n                adjustedCols[i] = 2;\\n            } else {\\n                // This is a third unique col, which is impossible to solve.\\n                return -1;\\n            }\\n            \\n            // If this row had too many of a single digit, it\\'s impossible to solve.\\n            if(Math.abs(rowDifferential) > 1 || Math.abs(colDifferential) > 1){\\n                return -1;\\n            }\\n        }\\n        \\n        // We didn\\'t get enough unique rows.\\n        if(uniqueRows[1] == 0){\\n            return -1;\\n        }\\n        \\n        // We got too many of one type of row\\n        if(Math.abs(rowCount) > 1){\\n            return -1;\\n        }\\n        \\n        // If we had two types of rows in the same quantity, then try starting with both rows and \\n        // just consider the one that took less swaps to create a chessboard.\\n        boolean tryBothRows = rowCount == 0;\\n        int mostCommonRow = (rowCount >= 1) ? 1 : 2;\\n        \\n        int minRowSwaps = size;\\n        if(tryBothRows){\\n            for(short row : new short[]{1, 2}){\\n                int candidateSwaps = 0;\\n                for(int i = 0; i < size; i += 2){\\n                    if(adjustedRows[i] != row){\\n                        candidateSwaps += 1;\\n                    }\\n                }\\n                \\n                minRowSwaps = Math.min(minRowSwaps, candidateSwaps);\\n            }\\n        } else {\\n            // Otherwise, just start with the more common row.\\n            minRowSwaps = 0;\\n            for(int i = 0; i < size; i += 2){\\n                if(adjustedRows[i] != mostCommonRow){\\n                    minRowSwaps += 1;\\n                }\\n            }\\n        }\\n        \\n        \\n        boolean tryBothCols = colCount == 0;\\n        int mostCommonCol = (colCount >= 1) ? 1 : 2;\\n        \\n        int minColSwaps = size;\\n        if(tryBothCols){\\n            for(short col : new short[]{1, 2}){\\n                int candidateSwaps = 0;\\n                for(int i = 0; i < size; i += 2){\\n                    if(adjustedCols[i] != col){\\n                        candidateSwaps += 1;\\n                    }\\n                }\\n                \\n                minColSwaps = Math.min(minColSwaps, candidateSwaps);\\n            }\\n        } else {\\n            minColSwaps = 0;\\n            for(int i = 0; i < size; i += 2){\\n                if(adjustedCols[i] != mostCommonCol){\\n                    minColSwaps += 1;\\n                }\\n            }\\n        }\\n        \\n        return minRowSwaps + minColSwaps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        int[] boardValue = {-1, 1};\\n        int size = board.length;\\n        \\n        short[] adjustedRows = new short[size], adjustedCols = new short[size];\\n        int[] uniqueRows = new int[2], uniqueCols = new int[2];\\n        \\n        int rowCount = 0, colCount = 0;\\n        \\n        // Iterate over col and row.\\n        int colDifferential, rowDifferential, colCurrent, rowCurrent;\\n        for(int i = 0; i < size; i++){\\n            colDifferential = 0;\\n            rowDifferential = 0;\\n            \\n            colCurrent = 0;\\n            rowCurrent = 0;\\n            \\n            // Collect column, row into ints\\n            for(int j = 0; j < size; j++){\\n                int colEntry = board[j][i];\\n                int rowEntry = board[i][j];\\n\\n                colCurrent = colCurrent << 1;\\n                rowCurrent = rowCurrent << 1;\\n                \\n                colCurrent |= colEntry;\\n                rowCurrent |= rowEntry;\\n                \\n                colDifferential += boardValue[colEntry];\\n                rowDifferential += boardValue[rowEntry];\\n            }\\n            \\n            // Count row\\n            if(uniqueRows[0] == rowCurrent || uniqueRows[0] == 0){\\n                uniqueRows[0] = rowCurrent;\\n                rowCount += 1;\\n                adjustedRows[i] = 1;\\n            } else if(uniqueRows[1] == rowCurrent || uniqueRows[1] == 0){\\n                uniqueRows[1] = rowCurrent;\\n                rowCount -= 1;\\n                adjustedRows[i] = 2;\\n            } else {\\n                // This is a third unique row, which is impossible to solve.\\n                return -1;\\n            }\\n            \\n            // Count col\\n            if(uniqueCols[0] == colCurrent || uniqueCols[0] == 0){\\n                uniqueCols[0] = colCurrent;\\n                colCount += 1;\\n                adjustedCols[i] = 1;\\n            } else if(uniqueCols[1] == colCurrent || uniqueCols[1] == 0){\\n                uniqueCols[1] = colCurrent;\\n                colCount -= 1;\\n                adjustedCols[i] = 2;\\n            } else {\\n                // This is a third unique col, which is impossible to solve.\\n                return -1;\\n            }\\n            \\n            // If this row had too many of a single digit, it\\'s impossible to solve.\\n            if(Math.abs(rowDifferential) > 1 || Math.abs(colDifferential) > 1){\\n                return -1;\\n            }\\n        }\\n        \\n        // We didn\\'t get enough unique rows.\\n        if(uniqueRows[1] == 0){\\n            return -1;\\n        }\\n        \\n        // We got too many of one type of row\\n        if(Math.abs(rowCount) > 1){\\n            return -1;\\n        }\\n        \\n        // If we had two types of rows in the same quantity, then try starting with both rows and \\n        // just consider the one that took less swaps to create a chessboard.\\n        boolean tryBothRows = rowCount == 0;\\n        int mostCommonRow = (rowCount >= 1) ? 1 : 2;\\n        \\n        int minRowSwaps = size;\\n        if(tryBothRows){\\n            for(short row : new short[]{1, 2}){\\n                int candidateSwaps = 0;\\n                for(int i = 0; i < size; i += 2){\\n                    if(adjustedRows[i] != row){\\n                        candidateSwaps += 1;\\n                    }\\n                }\\n                \\n                minRowSwaps = Math.min(minRowSwaps, candidateSwaps);\\n            }\\n        } else {\\n            // Otherwise, just start with the more common row.\\n            minRowSwaps = 0;\\n            for(int i = 0; i < size; i += 2){\\n                if(adjustedRows[i] != mostCommonRow){\\n                    minRowSwaps += 1;\\n                }\\n            }\\n        }\\n        \\n        \\n        boolean tryBothCols = colCount == 0;\\n        int mostCommonCol = (colCount >= 1) ? 1 : 2;\\n        \\n        int minColSwaps = size;\\n        if(tryBothCols){\\n            for(short col : new short[]{1, 2}){\\n                int candidateSwaps = 0;\\n                for(int i = 0; i < size; i += 2){\\n                    if(adjustedCols[i] != col){\\n                        candidateSwaps += 1;\\n                    }\\n                }\\n                \\n                minColSwaps = Math.min(minColSwaps, candidateSwaps);\\n            }\\n        } else {\\n            minColSwaps = 0;\\n            for(int i = 0; i < size; i += 2){\\n                if(adjustedCols[i] != mostCommonCol){\\n                    minColSwaps += 1;\\n                }\\n            }\\n        }\\n        \\n        return minRowSwaps + minColSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488526,
                "title": "remember-it-is-a-1d-problem-c",
                "content": "You just need to do two things:\\n1. Make sure it\\'s doable.\\n2. find the minimum step to flip first row/column.\\n\\nWe can transpose the matrix, so do row equals do column.\\n```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int row = row_min_step(board);\\n        if(row == -1) return -1;\\n        transpose(board);\\n        int col = row_min_step(board);\\n        if(col == -1) return -1;\\n        return row + col;\\n    }\\nprivate:\\n    int row_min_step(vector<vector<int>>& board) {\\n        int n = board.size();\\n        vector<int> row(board[0]);\\n\\t\\t// below to make sure it\\'s doable.\\n        bool twoRow = false;\\n        for(int i = 0; i < n; i++) {\\n            bool op = false;\\n            for(int j = 0; j < n; j++) {\\n                if(op && board[i][j] == row[j]){\\n                    return -1;\\n                }\\n                if(!op && board[i][j] != row[j]){\\n                    twoRow = true;\\n                    if(j == 0){\\n                        op = !op;\\n                    } else {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        if(!twoRow) return -1;\\n\\t\\t\\n        return min_step_1D(row);\\n    }\\n    int min_step_1D(vector<int>& row){\\n        int n = row.size();\\n        int sum = 0;\\n        for(int i : row) sum+=i;\\n        if(abs(sum * 2 - n) > 1) return -1;\\n        bool zero = true;\\n        int diff = 0;\\n        for(int i = 0; i < n; i++){\\n            if(row[i] != (zero?0:1)) diff++;\\n            zero = !zero;\\n        }\\n        if(diff%2 != 0) return (n - diff) / 2;\\n        if((n - diff) % 2 != 0) return diff / 2;\\n        return min(diff, n - diff) / 2;\\n    }\\n    void transpose(vector<vector<int>>& board) {\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = i; j < board.size(); j++){\\n                int tmp = board[i][j];\\n                board[i][j] = board[j][i];\\n                board[j][i] = tmp;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int row = row_min_step(board);\\n        if(row == -1) return -1;\\n        transpose(board);\\n        int col = row_min_step(board);\\n        if(col == -1) return -1;\\n        return row + col;\\n    }\\nprivate:\\n    int row_min_step(vector<vector<int>>& board) {\\n        int n = board.size();\\n        vector<int> row(board[0]);\\n\\t\\t// below to make sure it\\'s doable.\\n        bool twoRow = false;\\n        for(int i = 0; i < n; i++) {\\n            bool op = false;\\n            for(int j = 0; j < n; j++) {\\n                if(op && board[i][j] == row[j]){\\n                    return -1;\\n                }\\n                if(!op && board[i][j] != row[j]){\\n                    twoRow = true;\\n                    if(j == 0){\\n                        op = !op;\\n                    } else {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        if(!twoRow) return -1;\\n\\t\\t\\n        return min_step_1D(row);\\n    }\\n    int min_step_1D(vector<int>& row){\\n        int n = row.size();\\n        int sum = 0;\\n        for(int i : row) sum+=i;\\n        if(abs(sum * 2 - n) > 1) return -1;\\n        bool zero = true;\\n        int diff = 0;\\n        for(int i = 0; i < n; i++){\\n            if(row[i] != (zero?0:1)) diff++;\\n            zero = !zero;\\n        }\\n        if(diff%2 != 0) return (n - diff) / 2;\\n        if((n - diff) % 2 != 0) return diff / 2;\\n        return min(diff, n - diff) / 2;\\n    }\\n    void transpose(vector<vector<int>>& board) {\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = i; j < board.size(); j++){\\n                int tmp = board[i][j];\\n                board[i][j] = board[j][i];\\n                board[j][i] = tmp;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488175,
                "title": "c-100-100",
                "content": "```\\npublic int MovesToChessboard(int[][] board) {\\n\\tif (IsBadChessboard(board)) return -1;\\n\\tif (IsBadChessboard2(board)) return -1;\\n\\tvar shiftsHor = 0;\\n\\tfor (int i = 0; i < board.Length; i++)\\n\\t{\\n\\t\\tvar shiftsHor2 = GetShiftsHor(i, board);\\n\\t\\tif (shiftsHor < shiftsHor2) shiftsHor = shiftsHor2;\\n\\t}\\n\\tvar shiftsVer = 0;\\n\\tfor (int i = 0; i < board[0].Length; i++)\\n\\t{\\n\\t\\tvar shiftsVer2 = GetShiftsVer(i, board);\\n\\t\\tif (shiftsVer < shiftsVer2) shiftsVer = shiftsVer2;\\n\\t}\\n\\tvar rs = shiftsHor / 2 + shiftsVer / 2;\\n\\treturn rs;\\n}\\nprivate int GetShiftsVer(int col, int[][] board)\\n{\\n\\tif (board.Length % 2 == 0)\\n\\t{\\n\\t\\tvar errors0 = 0;\\n\\t\\tvar errors1 = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][col] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][col] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar rs = Math.Min(errors0, errors1);\\n\\t\\treturn rs;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tvar countOne = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tcountOne += board[i][col];\\n\\t\\t}\\n\\t\\tvar onesIsMore = countOne == (board.Length + 1) / 2;\\n\\t\\tvar errors = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn errors;\\n\\t}\\n}\\nprivate int GetShiftsHor(int row, int[][] board)\\n{\\n\\tif (board[row].Length % 2 == 0)\\n\\t{\\n\\t\\tvar errors0 = 0;\\n\\t\\tvar errors1 = 0;\\n\\t\\tfor (int i = 0; i < board[row].Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[row][i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[row][i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar rs = Math.Min(errors0, errors1);\\n\\t\\treturn rs;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tvar countOne = board[row].Sum();\\n\\t\\tvar onesIsMore = countOne == (board[row].Length + 1) / 2;\\n\\t\\tvar errors = 0;\\n\\t\\tfor (int i = 0; i < board[row].Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn errors;\\n\\t}\\n}\\nprivate bool IsBadChessboard2(int[][] board)\\n{\\n\\tvar rows = new[] { -1, -1 };\\n\\tfor (int i = 0; i < board.Length; i++)\\n\\t{\\n\\t\\tif (board[i][0] == 0)\\n\\t\\t{\\n\\t\\t\\tif (rows[0] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[0] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[rows[0]][j] != board[i][j]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (rows[1] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[1] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[rows[1]][j] != board[i][j]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar cols = new[] { -1, -1 };\\n\\tfor (int i = 0; i < board[0].Length; i++)\\n\\t{\\n\\t\\tif (board[0][i] == 0)\\n\\t\\t{\\n\\t\\t\\tif (cols[0] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcols[0] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board.Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[j][cols[0]] != board[j][i]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (cols[1] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcols[1] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board.Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[j][cols[1]] != board[j][i]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\nprivate bool IsBadChessboard(int[][] board)\\n{\\n\\tif (board.Length % 2 == 0)\\n\\t{\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0) countZero++;\\n\\t\\t\\t}\\n\\t\\t\\tif (countZero != board[i].Length / 2) return true;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < board[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0) countZero++;\\n\\t\\t\\t}\\n\\t\\t\\tif (countZero != board.Length / 2) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tvar diff = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tvar countOne = 0;\\n\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountZero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.Abs(countZero - countOne) != 1) return true;\\n\\t\\t\\tif (countZero > countOne)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (Math.Abs(diff) != 1) return true;\\n\\t\\tdiff = 0;\\n\\t\\tfor (int j = 0; j < board[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tvar countOne = 0;\\n\\t\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountZero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.Abs(countZero - countOne) != 1) return true;\\n\\t\\t\\tif (countZero > countOne)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (Math.Abs(diff) != 1) return true;\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MovesToChessboard(int[][] board) {\\n\\tif (IsBadChessboard(board)) return -1;\\n\\tif (IsBadChessboard2(board)) return -1;\\n\\tvar shiftsHor = 0;\\n\\tfor (int i = 0; i < board.Length; i++)\\n\\t{\\n\\t\\tvar shiftsHor2 = GetShiftsHor(i, board);\\n\\t\\tif (shiftsHor < shiftsHor2) shiftsHor = shiftsHor2;\\n\\t}\\n\\tvar shiftsVer = 0;\\n\\tfor (int i = 0; i < board[0].Length; i++)\\n\\t{\\n\\t\\tvar shiftsVer2 = GetShiftsVer(i, board);\\n\\t\\tif (shiftsVer < shiftsVer2) shiftsVer = shiftsVer2;\\n\\t}\\n\\tvar rs = shiftsHor / 2 + shiftsVer / 2;\\n\\treturn rs;\\n}\\nprivate int GetShiftsVer(int col, int[][] board)\\n{\\n\\tif (board.Length % 2 == 0)\\n\\t{\\n\\t\\tvar errors0 = 0;\\n\\t\\tvar errors1 = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][col] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][col] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar rs = Math.Min(errors0, errors1);\\n\\t\\treturn rs;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tvar countOne = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tcountOne += board[i][col];\\n\\t\\t}\\n\\t\\tvar onesIsMore = countOne == (board.Length + 1) / 2;\\n\\t\\tvar errors = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[i][col] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn errors;\\n\\t}\\n}\\nprivate int GetShiftsHor(int row, int[][] board)\\n{\\n\\tif (board[row].Length % 2 == 0)\\n\\t{\\n\\t\\tvar errors0 = 0;\\n\\t\\tvar errors1 = 0;\\n\\t\\tfor (int i = 0; i < board[row].Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[row][i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[row][i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors0++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\terrors1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar rs = Math.Min(errors0, errors1);\\n\\t\\treturn rs;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tvar countOne = board[row].Sum();\\n\\t\\tvar onesIsMore = countOne == (board[row].Length + 1) / 2;\\n\\t\\tvar errors = 0;\\n\\t\\tfor (int i = 0; i < board[row].Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!onesIsMore)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 0) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[row][i] == 1) errors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn errors;\\n\\t}\\n}\\nprivate bool IsBadChessboard2(int[][] board)\\n{\\n\\tvar rows = new[] { -1, -1 };\\n\\tfor (int i = 0; i < board.Length; i++)\\n\\t{\\n\\t\\tif (board[i][0] == 0)\\n\\t\\t{\\n\\t\\t\\tif (rows[0] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[0] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[rows[0]][j] != board[i][j]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (rows[1] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[1] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[rows[1]][j] != board[i][j]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar cols = new[] { -1, -1 };\\n\\tfor (int i = 0; i < board[0].Length; i++)\\n\\t{\\n\\t\\tif (board[0][i] == 0)\\n\\t\\t{\\n\\t\\t\\tif (cols[0] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcols[0] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board.Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[j][cols[0]] != board[j][i]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif (cols[1] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcols[1] = i;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < board.Length; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (board[j][cols[1]] != board[j][i]) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\nprivate bool IsBadChessboard(int[][] board)\\n{\\n\\tif (board.Length % 2 == 0)\\n\\t{\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0) countZero++;\\n\\t\\t\\t}\\n\\t\\t\\tif (countZero != board[i].Length / 2) return true;\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < board[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0) countZero++;\\n\\t\\t\\t}\\n\\t\\t\\tif (countZero != board.Length / 2) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tvar diff = 0;\\n\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tvar countOne = 0;\\n\\t\\t\\tfor (int j = 0; j < board[i].Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountZero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.Abs(countZero - countOne) != 1) return true;\\n\\t\\t\\tif (countZero > countOne)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (Math.Abs(diff) != 1) return true;\\n\\t\\tdiff = 0;\\n\\t\\tfor (int j = 0; j < board[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tvar countZero = 0;\\n\\t\\t\\tvar countOne = 0;\\n\\t\\t\\tfor (int i = 0; i < board.Length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountZero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcountOne++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (Math.Abs(countZero - countOne) != 1) return true;\\n\\t\\t\\tif (countZero > countOne)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (Math.Abs(diff) != 1) return true;\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488144,
                "title": "python-short-invariants-tracked",
                "content": "The invariants to check in this problem are:\\n1. There should be only 2 unique rows\\n2. They sum in every column must be 1\\n3. Number od 1s and 0s in every row shouldn\\'t be less then n//2\\n4a. For odd n: if 3 above statements are true - there is only one posible solution ruled by most frequent row\\n4b. For even n: there exist 2 possibilities: either some of 2 rows can start from 1 or 0. For every of those possibility we find min among being on even or odd position in board.\\n\\n\\n\\n```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        c = defaultdict(Counter)\\n        for i in range(n):\\n            c[tuple(board[i])][i%2] += 1 # count even and odd positions for every unique row\\n            c[tuple(board[i])][1-(i%2)] += 0 # activate other\\n            if board[i].count(0) < n//2 or board[i].count(1) < n//2: return -1\\n        if len(c) != 2: return -1 # there should be only 2 unique rows\\n        if min(sum(cntr.values()) for cntr in c.values()) < n//2: return -1 \\n        for a, b in zip(*c.keys()):\\n            if a+b != 1: return -1\\n        rows = list(c.keys())\\n        if n % 2 == 1:\\n            frequent = 0 if sum(c[rows[1]].values()) == n//2 else 1\\n            pivot = 0 if rows[frequent].count(1) == n//2 else 1\\n            return c[rows[frequent]][1] + rows[frequent][::2].count(1-pivot)\\n        # pivot is either 0 and it is in [0s row or in 1st row] or it is 1 in [0s row or 1st row]\\n        variants = [rows[i][0::2].count(j)+min(c[rows[i]].values()) for i in range(2) for j in range(2)]\\n\\n        return min(variants)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToChessboard(self, board: List[List[int]]) -> int:\\n        n = len(board)\\n        c = defaultdict(Counter)\\n        for i in range(n):\\n            c[tuple(board[i])][i%2] += 1 # count even and odd positions for every unique row\\n            c[tuple(board[i])][1-(i%2)] += 0 # activate other\\n            if board[i].count(0) < n//2 or board[i].count(1) < n//2: return -1\\n        if len(c) != 2: return -1 # there should be only 2 unique rows\\n        if min(sum(cntr.values()) for cntr in c.values()) < n//2: return -1 \\n        for a, b in zip(*c.keys()):\\n            if a+b != 1: return -1\\n        rows = list(c.keys())\\n        if n % 2 == 1:\\n            frequent = 0 if sum(c[rows[1]].values()) == n//2 else 1\\n            pivot = 0 if rows[frequent].count(1) == n//2 else 1\\n            return c[rows[frequent]][1] + rows[frequent][::2].count(1-pivot)\\n        # pivot is either 0 and it is in [0s row or in 1st row] or it is 1 in [0s row or 1st row]\\n        variants = [rows[i][0::2].count(j)+min(c[rows[i]].values()) for i in range(2) for j in range(2)]\\n\\n        return min(variants)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488016,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/transform-to-chessboard/discuss/114847/C%2B%2BJavaPython-Solution-with-Explanation) solution\\n```\\nfunc movesToChessboard(board [][]int) int {\\n\\tn := len(board)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) == 1 {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\trowSum, colSum, rowMisplaced, colMisplaced := 0, 0, 0, 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowSum += board[0][i]\\n\\t\\tcolSum += board[i][0]\\n\\t\\tif board[i][0] == i%2 {\\n\\t\\t\\trowMisplaced++\\n\\t\\t}\\n\\t\\tif board[0][i] == i%2 {\\n\\t\\t\\tcolMisplaced++\\n\\t\\t}\\n\\t}\\n\\n\\tif rowSum != n/2 && rowSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\tif colSum != n/2 && colSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tif n%2 == 1 {\\n\\t\\tif colMisplaced%2 == 1 {\\n\\t\\t\\tcolMisplaced = n - colMisplaced\\n\\t\\t}\\n\\t\\tif rowMisplaced%2 == 1 {\\n\\t\\t\\trowMisplaced = n - rowMisplaced\\n\\t\\t}\\n\\t} else {\\n\\t\\tcolMisplaced = min(n-colMisplaced, colMisplaced)\\n\\t\\trowMisplaced = min(n-rowMisplaced, rowMisplaced)\\n\\t}\\n\\n\\treturn (colMisplaced + rowMisplaced) / 2\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc movesToChessboard(board [][]int) int {\\n\\tn := len(board)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) == 1 {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\trowSum, colSum, rowMisplaced, colMisplaced := 0, 0, 0, 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowSum += board[0][i]\\n\\t\\tcolSum += board[i][0]\\n\\t\\tif board[i][0] == i%2 {\\n\\t\\t\\trowMisplaced++\\n\\t\\t}\\n\\t\\tif board[0][i] == i%2 {\\n\\t\\t\\tcolMisplaced++\\n\\t\\t}\\n\\t}\\n\\n\\tif rowSum != n/2 && rowSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\tif colSum != n/2 && colSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tif n%2 == 1 {\\n\\t\\tif colMisplaced%2 == 1 {\\n\\t\\t\\tcolMisplaced = n - colMisplaced\\n\\t\\t}\\n\\t\\tif rowMisplaced%2 == 1 {\\n\\t\\t\\trowMisplaced = n - rowMisplaced\\n\\t\\t}\\n\\t} else {\\n\\t\\tcolMisplaced = min(n-colMisplaced, colMisplaced)\\n\\t\\trowMisplaced = min(n-rowMisplaced, rowMisplaced)\\n\\t}\\n\\n\\treturn (colMisplaced + rowMisplaced) / 2\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487960,
                "title": "python-dimension-independence-2-building-block-for-row-and-column",
                "content": "Approach 1[1]: Dimension independence + 2-building block for row and column\\nTime/Space Complexity: O(N)\\n\\n```\\nclass Solution(object):\\n    def movesToChessboard(self, board):\\n        N = len(board)\\n        ans = 0\\n        # For each count of lines from {rows, columns}...\\n        for count in (collections.Counter(map(tuple, board)),  # get row\\n                      collections.Counter(zip(*board))): #get column\\n\\n            # If there are more than 2 kinds of lines,\\n            # or if the number of kinds is not appropriate ...\\n            if len(count) != 2 or sorted(count.values()) != [N/2, (N+1)/2]:\\n                return -1\\n\\n            # If the lines are not opposite each other, impossible\\n            line1, line2 = count\\n            if not all(x ^ y for x, y in zip(line1, line2)):\\n                return -1\\n\\n            # starts = what could be the starting value of line1\\n            # If N is odd, then we have to start with the more\\n            # frequent element\\n            starts = [int(line1.count(1) * 2 > N)] if N%2 else [0, 1]\\n\\n            # To transform line1 into the ideal line [i%2 for i ...],\\n            # we take the number of differences and divide by two\\n            ans += min(sum((x-i) % 2 for i, x in enumerate(line1, start))\\n                       for start in starts) / 2            \\n\\n        return ans\\n```\\n\\nReference:\\n[1] https://leetcode.com/problems/transform-to-chessboard/solution/",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution(object):\\n    def movesToChessboard(self, board):\\n        N = len(board)\\n        ans = 0\\n        # For each count of lines from {rows, columns}...\\n        for count in (collections.Counter(map(tuple, board)),  # get row\\n                      collections.Counter(zip(*board))): #get column\\n\\n            # If there are more than 2 kinds of lines,\\n            # or if the number of kinds is not appropriate ...\\n            if len(count) != 2 or sorted(count.values()) != [N/2, (N+1)/2]:\\n                return -1\\n\\n            # If the lines are not opposite each other, impossible\\n            line1, line2 = count\\n            if not all(x ^ y for x, y in zip(line1, line2)):\\n                return -1\\n\\n            # starts = what could be the starting value of line1\\n            # If N is odd, then we have to start with the more\\n            # frequent element\\n            starts = [int(line1.count(1) * 2 > N)] if N%2 else [0, 1]\\n\\n            # To transform line1 into the ideal line [i%2 for i ...],\\n            # we take the number of differences and divide by two\\n            ans += min(sum((x-i) % 2 for i, x in enumerate(line1, start))\\n                       for start in starts) / 2            \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487839,
                "title": "rust-bit-based-solution-for-fun",
                "content": "I had a lot of fun with this one. Part of this relies on  the fact that `n <= 30`. This means that the rows and columns will fit into an `i32`.\\n\\nThe hardest part in my opinion is figuring out whether a given board is solvable. Going to leave out how I prove this but a solvable board has the following properties:\\n\\n- You can have a maximum of 2 values in the rows and a maximum on 2 values columns, let\\'s call this value `a` and `b`\\n\\t- `count(a)` and `count(b)` cannot differ by more than one\\n\\t- `a & b == 0`\\n\\t- `a | b == (1 << n)-1`\\n\\t- The bit count of `a` and the bitcount of `b` cannot differ by more than one\\n\\nOnce this is determined we can now find how many swaps we need.  rows and columns can be operated on independently. For every swap that we do we can put 2 \\nvalues in the correct position. For a chess board either 1010.... or 0101... are valid. For an odd `n`, only one of these configurations is valid.  We can used a test_mask to see how far we are\\noff from a valid configuration. This mask is basically 01010 or 10101 repeating. This is `0x2AAAAAAA` and `0x55555555`.  If we XOR this value with the numbers we obtained, the count of the set bits\\nis equal to this number of rows or columns that are out of place. Since a swap fixes 2 of these value so we can divide the result by 2. If the result is odd though that is an invalid configuration.\\n\\n\\n```rust\\nimpl Solution {\\n    fn get_number(arr: &Vec<i32>) -> Option<i32> {\\n        let mask = (1 << arr.len()) -1;\\n        let test:i32 = 0x2AAAAAAA & mask;\\n        \\n        arr.iter().fold(Some((-1, -1, 0i32, 0i32)), |s, &n| {\\n            match s {\\n                Some((-1, -1, c, d)) => Some((n, -1, c + 1, d)),\\n                Some((f, b, c, d)) if f == n => Some((f, b, c + 1, d)),\\n                Some((f, -1, c, d)) => Some((f, n, c, d + 1)),\\n                Some((f, b, c, d)) if b == n => Some((f, b, c, d + 1)),\\n                Some(_) => None,\\n                None => None\\n            }\\n        }).filter(|(a, b, _, _)| \\n            a & b == 0 && (a|b) == mask && \\n            (a.count_ones() as i32 - b.count_ones() as i32).abs() <= 1\\n        ).filter(|(_, _, c1, c2)|\\n            (c1 - c2).abs() <= 1\\n        ).map(|(a, b, _,_)| {\\n            vec![a^test, a^test^mask].into_iter()\\n                .map(|v|v.count_ones() as i32)\\n                .map(|v| (v>>1) | (v&1)<<6)\\n                .min().unwrap()\\n        })\\n    }\\n    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {\\n        let n = board.len();\\n        let transform = |v: i32, i:i32| (v<<1)|i;\\n        let rows = board.iter().map(|row| row.iter().copied().fold(0, transform)).collect::<Vec<_>>();\\n        let cols = (0..n).map(|i| board.iter().map(|r|r[i]).fold(0, transform)).collect::<Vec<_>>();\\n\\n        match (Self::get_number(&rows), Self::get_number(&cols)) {\\n            (Some(r), Some(c)) => (r + c),\\n            _ => -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```rust\\nimpl Solution {\\n    fn get_number(arr: &Vec<i32>) -> Option<i32> {\\n        let mask = (1 << arr.len()) -1;\\n        let test:i32 = 0x2AAAAAAA & mask;\\n        \\n        arr.iter().fold(Some((-1, -1, 0i32, 0i32)), |s, &n| {\\n            match s {\\n                Some((-1, -1, c, d)) => Some((n, -1, c + 1, d)),\\n                Some((f, b, c, d)) if f == n => Some((f, b, c + 1, d)),\\n                Some((f, -1, c, d)) => Some((f, n, c, d + 1)),\\n                Some((f, b, c, d)) if b == n => Some((f, b, c, d + 1)),\\n                Some(_) => None,\\n                None => None\\n            }\\n        }).filter(|(a, b, _, _)| \\n            a & b == 0 && (a|b) == mask && \\n            (a.count_ones() as i32 - b.count_ones() as i32).abs() <= 1\\n        ).filter(|(_, _, c1, c2)|\\n            (c1 - c2).abs() <= 1\\n        ).map(|(a, b, _,_)| {\\n            vec![a^test, a^test^mask].into_iter()\\n                .map(|v|v.count_ones() as i32)\\n                .map(|v| (v>>1) | (v&1)<<6)\\n                .min().unwrap()\\n        })\\n    }\\n    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {\\n        let n = board.len();\\n        let transform = |v: i32, i:i32| (v<<1)|i;\\n        let rows = board.iter().map(|row| row.iter().copied().fold(0, transform)).collect::<Vec<_>>();\\n        let cols = (0..n).map(|i| board.iter().map(|r|r[i]).fold(0, transform)).collect::<Vec<_>>();\\n\\n        match (Self::get_number(&rows), Self::get_number(&cols)) {\\n            (Some(r), Some(c)) => (r + c),\\n            _ => -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487725,
                "title": "go-solution-beats-100",
                "content": "```\\nfunc movesToChessboard(board [][]int) int {\\n\\tn, rowSum, colSum, rowSwap, colSwap := len(board), 0, 0, 0, 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif board[0][0]^board[i][0]^board[0][j]^board[i][j] == 1 {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowSum += board[0][i]\\n\\t\\tcolSum += board[i][0]\\n\\t\\tif board[i][0] == i%2 {\\n\\t\\t\\trowSwap++\\n\\t\\t}\\n\\t\\tif board[0][i] == i%2 {\\n\\t\\t\\tcolSwap++\\n\\t\\t}\\n\\t}\\n\\n\\tif rowSum != n/2 && rowSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\tif colSum != n/2 && colSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\tif n%2 == 1 {\\n\\t\\tif colSwap%2 == 1 {\\n\\t\\t\\tcolSwap = n - colSwap\\n\\t\\t}\\n\\t\\tif rowSwap%2 == 1 {\\n\\t\\t\\trowSwap = n - rowSwap\\n\\t\\t}\\n\\t} else {\\n\\t\\tcolSwap = min(n-colSwap, colSwap)\\n\\t\\trowSwap = min(n-rowSwap, rowSwap)\\n\\t}\\n\\treturn (colSwap + rowSwap) / 2\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc movesToChessboard(board [][]int) int {\\n\\tn, rowSum, colSum, rowSwap, colSwap := len(board), 0, 0, 0, 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif board[0][0]^board[i][0]^board[0][j]^board[i][j] == 1 {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowSum += board[0][i]\\n\\t\\tcolSum += board[i][0]\\n\\t\\tif board[i][0] == i%2 {\\n\\t\\t\\trowSwap++\\n\\t\\t}\\n\\t\\tif board[0][i] == i%2 {\\n\\t\\t\\tcolSwap++\\n\\t\\t}\\n\\t}\\n\\n\\tif rowSum != n/2 && rowSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\tif colSum != n/2 && colSum != (n+1)/2 {\\n\\t\\treturn -1\\n\\t}\\n\\tif n%2 == 1 {\\n\\t\\tif colSwap%2 == 1 {\\n\\t\\t\\tcolSwap = n - colSwap\\n\\t\\t}\\n\\t\\tif rowSwap%2 == 1 {\\n\\t\\t\\trowSwap = n - rowSwap\\n\\t\\t}\\n\\t} else {\\n\\t\\tcolSwap = min(n-colSwap, colSwap)\\n\\t\\trowSwap = min(n-rowSwap, rowSwap)\\n\\t}\\n\\treturn (colSwap + rowSwap) / 2\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487700,
                "title": "java-95-92-validate-then-calculate-with-explanation",
                "content": "There are 3 necessary conditions that need to be validated.  Taken together, they are sufficient to confirm that the grid is solvable.\\n1. In the first row, the number of ones and zeroes must be the same, or different by one.\\n2. In the first column, the number of ones and zeroes must be the same, or different by one.\\n3. Every row after the first must be either identical to the first row, or binary opposite.  By \"binary opposite\", I mean that every digit is different (e.g. for [1,0,1,1,0], the binary opposite is [0,1,0,0,1]).\\n\\nTo understand #3, consider two rows in the grid.  If they are identical before swapping two columns, they will be identical to one another afterward.  The same is true when considering two columns and swapping two rows.  Therefore, the rows must start as identical, or binary opposite, when given in the grid.  Otherwise, there is no solution.\\n\\nOnce we have validated the above conditions, if the number of rows/columns is even, the answer is simple to calculate.  Add the number of column swaps (to move zeroes to even columns or odd columns in the first row, whichever is less) to the number of row swaps (to move all zeroes in even rows or odd rows in the first column, whichever is less).\\n\\nIf there is an odd number of rows in the grid, we have to be more careful.  There are an odd number of grid entries, meaning one value is more common than the other.  That is the value that must go in the even rows and columns.  Also, this algorithm starts with row swaps, to make the first column alternate zeroes and ones.  If those row swaps change the first row, it must recalculate the zero counts for the first row so that the column swaps are calculated correctly.\\n\\nTC: O(n^2) to visit every cell, to validate condition #3 above\\nSC: O(1)\\n\\n```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        final int n = board.length;\\n\\n        // Count zeroes in the first row, and in even columns in the first row.\\n        // Also count zeroes in the first column, and in even rows in the first column.\\n        int zeroesRow1 = 0;\\n        int zeroesCol1 = 0;\\n        int zeroesEvenCols = 0;\\n        int zeroesEvenRows = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (board[i][0] == 0) {\\n                zeroesCol1++;\\n                if (i % 2 == 0) zeroesEvenRows++;\\n            }\\n            if (board[0][i] == 0) {\\n                zeroesRow1++;\\n                if (i % 2 == 0) zeroesEvenCols++;\\n            }\\n        }\\n\\n        // Validate that the board is solvable.\\n        // Half of the rows and columns (to within 1) must be zeroes.\\n        if (Math.abs(n - 2 * zeroesRow1) > 1) return -1;\\n        if (Math.abs(n - 2 * zeroesCol1) > 1) return -1;\\n\\n        // All rows must be either identical or binary opposite to the first row.\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < n; j++)\\n                if ((board[0][0] == board[i][0]) ^ (board[0][j] == board[i][j])) return -1;\\n\\n        // Now we know that the problem is solvable.\\n        // If there are an even number of rows, the answer is easy to calculate.\\n        if (n % 2 == 0)\\n            return Math.min(zeroesEvenRows, n/2 - zeroesEvenRows)\\n                 + Math.min(zeroesEvenCols, n/2 - zeroesEvenCols);\\n        \\n        // Odd number of rows.  Calculate the total number of zeroes in the grid.\\n        int totalZeroes;\\n        if (board[0][0] == 0) totalZeroes = zeroesRow1 * zeroesCol1 + (n - zeroesRow1) * (n - zeroesCol1);\\n        else totalZeroes = zeroesRow1 * (n - zeroesCol1) + (n - zeroesRow1) * zeroesCol1;\\n \\n        // Goal for row-swapping is to get the rows alternating by first column value.\\n        // If the first row changes as the result of swapping, recalculate zeroes in the first row.\\n        int rowSwaps;\\n        if (zeroesCol1 * 2 > n) {\\n            // More zeroes than ones in the first column.  Move zeroes from odd rows to even.\\n            rowSwaps = (n + 1)/2 - zeroesEvenRows;\\n            if (board[0][0] == 1) {\\n                zeroesRow1 = n - zeroesRow1;\\n                zeroesEvenCols = (n + 1)/2 - zeroesEvenCols;\\n            }\\n        } else {\\n            // More ones than zeroes in the first column.  Move zeroes from even rows to odd.\\n            rowSwaps = zeroesEvenRows;\\n            if (board[0][0] == 0) {\\n                zeroesRow1 = n - zeroesRow1;\\n                zeroesEvenCols = (n + 1)/2 - zeroesEvenCols;\\n            }\\n        }\\n        \\n        // Goal for column-swapping is to get the more common number in the first column,\\n        // and alternate columns by first row value.\\n        return rowSwaps + (totalZeroes * 2 > n * n ? (n + 1)/2 - zeroesEvenCols : zeroesEvenCols);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToChessboard(int[][] board) {\\n        final int n = board.length;\\n\\n        // Count zeroes in the first row, and in even columns in the first row.\\n        // Also count zeroes in the first column, and in even rows in the first column.\\n        int zeroesRow1 = 0;\\n        int zeroesCol1 = 0;\\n        int zeroesEvenCols = 0;\\n        int zeroesEvenRows = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (board[i][0] == 0) {\\n                zeroesCol1++;\\n                if (i % 2 == 0) zeroesEvenRows++;\\n            }\\n            if (board[0][i] == 0) {\\n                zeroesRow1++;\\n                if (i % 2 == 0) zeroesEvenCols++;\\n            }\\n        }\\n\\n        // Validate that the board is solvable.\\n        // Half of the rows and columns (to within 1) must be zeroes.\\n        if (Math.abs(n - 2 * zeroesRow1) > 1) return -1;\\n        if (Math.abs(n - 2 * zeroesCol1) > 1) return -1;\\n\\n        // All rows must be either identical or binary opposite to the first row.\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < n; j++)\\n                if ((board[0][0] == board[i][0]) ^ (board[0][j] == board[i][j])) return -1;\\n\\n        // Now we know that the problem is solvable.\\n        // If there are an even number of rows, the answer is easy to calculate.\\n        if (n % 2 == 0)\\n            return Math.min(zeroesEvenRows, n/2 - zeroesEvenRows)\\n                 + Math.min(zeroesEvenCols, n/2 - zeroesEvenCols);\\n        \\n        // Odd number of rows.  Calculate the total number of zeroes in the grid.\\n        int totalZeroes;\\n        if (board[0][0] == 0) totalZeroes = zeroesRow1 * zeroesCol1 + (n - zeroesRow1) * (n - zeroesCol1);\\n        else totalZeroes = zeroesRow1 * (n - zeroesCol1) + (n - zeroesRow1) * zeroesCol1;\\n \\n        // Goal for row-swapping is to get the rows alternating by first column value.\\n        // If the first row changes as the result of swapping, recalculate zeroes in the first row.\\n        int rowSwaps;\\n        if (zeroesCol1 * 2 > n) {\\n            // More zeroes than ones in the first column.  Move zeroes from odd rows to even.\\n            rowSwaps = (n + 1)/2 - zeroesEvenRows;\\n            if (board[0][0] == 1) {\\n                zeroesRow1 = n - zeroesRow1;\\n                zeroesEvenCols = (n + 1)/2 - zeroesEvenCols;\\n            }\\n        } else {\\n            // More ones than zeroes in the first column.  Move zeroes from even rows to odd.\\n            rowSwaps = zeroesEvenRows;\\n            if (board[0][0] == 0) {\\n                zeroesRow1 = n - zeroesRow1;\\n                zeroesEvenCols = (n + 1)/2 - zeroesEvenCols;\\n            }\\n        }\\n        \\n        // Goal for column-swapping is to get the more common number in the first column,\\n        // and alternate columns by first row value.\\n        return rowSwaps + (totalZeroes * 2 > n * n ? (n + 1)/2 - zeroesEvenCols : zeroesEvenCols);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487692,
                "title": "c-check-bitmask-signature-of-rows-and-columns",
                "content": "```\\nclass Solution {\\n    using sig_t = std::bitset<30>;\\npublic:    \\n    int movesToChessboard(std::vector<std::vector<int>> &board) {\\n        const int num_rows = board.size(), num_cols = board[0].size();\\n        if (num_rows != num_cols) {\\n            return -1;\\n        }\\n\\n        const auto get_signature = \\n            [&](std::unordered_map<sig_t, int> &sig_to_cnts) -> std::optional<sig_t> {\\n            std::vector<std::pair<sig_t, int>> items;                    \\n            if (sig_to_cnts.size() != 2) {\\n                return std::nullopt;\\n            }                  \\n            for (auto &&kv : sig_to_cnts) {\\n                items.emplace_back(kv);\\n            }\\n            const int lhs = items[0].second;\\n            const int rhs = items[1].second;\\n            if (std::abs(lhs - rhs) > 1) {\\n                return std::nullopt;\\n            }\\n            return items[0].first;\\n        };\\n        \\n        sig_t row_sig;\\n        {\\n            std::unordered_map<sig_t, int> sig_to_cnts;\\n            for (int row = 0; row < num_rows; ++row) {\\n                sig_t sig;\\n                for (int col = 0; col < num_cols; ++col) {\\n                    sig[col] = (board[row][col] == 1);\\n                }\\n                ++sig_to_cnts[sig];\\n            }\\n            if (auto res = get_signature(sig_to_cnts)) {\\n                row_sig = *res;\\n            } else {\\n                return -1;\\n            }\\n        }    \\n        \\n        sig_t col_sig;\\n        {\\n            std::unordered_map<sig_t, int> sig_to_cnts;\\n            for (int col = 0; col < num_cols; ++col) {\\n                sig_t sig;\\n                for (int row = 0; row < num_rows; ++row) {\\n                    sig[row] = (board[row][col] == 1);\\n                }\\n                ++sig_to_cnts[sig];            \\n            }\\n            if (auto res = get_signature(sig_to_cnts)) {\\n                col_sig = *res;\\n            } else {\\n                return -1;\\n            }\\n        }               \\n        \\n        const auto diff_signature = [&](const sig_t &ref, const sig_t &tgt) -> int {\\n            int diff_cnts = 0;\\n            for (int i = 0; i < num_cols; ++i) {\\n                if (ref[i] != tgt[i]) {\\n                    ++diff_cnts;\\n                }\\n            }\\n            return diff_cnts;\\n        };\\n                                            \\n        sig_t ref01, ref10;\\n        for (int i = 0; i < num_cols; ++i) {\\n            ref01[i] = (i % 2 == 1);\\n            ref10[i] = (i % 2 == 0);\\n        }                                \\n        const auto get_min_ops = [&](const sig_t &tgt) -> int {\\n            int lhs_diff = INT_MAX;\\n            if (ref01.count() == tgt.count()) {\\n                lhs_diff = diff_signature(ref01, tgt);\\n            }\\n            int rhs_diff = INT_MAX;\\n            if (ref10.count() == tgt.count()) {\\n                rhs_diff = diff_signature(ref10, tgt);\\n            }\\n            return std::min(lhs_diff, rhs_diff) / 2;\\n        };\\n                        \\n        return get_min_ops(row_sig) + get_min_ops(col_sig);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using sig_t = std::bitset<30>;\\npublic:    \\n    int movesToChessboard(std::vector<std::vector<int>> &board) {\\n        const int num_rows = board.size(), num_cols = board[0].size();\\n        if (num_rows != num_cols) {\\n            return -1;\\n        }\\n\\n        const auto get_signature = \\n            [&](std::unordered_map<sig_t, int> &sig_to_cnts) -> std::optional<sig_t> {\\n            std::vector<std::pair<sig_t, int>> items;                    \\n            if (sig_to_cnts.size() != 2) {\\n                return std::nullopt;\\n            }                  \\n            for (auto &&kv : sig_to_cnts) {\\n                items.emplace_back(kv);\\n            }\\n            const int lhs = items[0].second;\\n            const int rhs = items[1].second;\\n            if (std::abs(lhs - rhs) > 1) {\\n                return std::nullopt;\\n            }\\n            return items[0].first;\\n        };\\n        \\n        sig_t row_sig;\\n        {\\n            std::unordered_map<sig_t, int> sig_to_cnts;\\n            for (int row = 0; row < num_rows; ++row) {\\n                sig_t sig;\\n                for (int col = 0; col < num_cols; ++col) {\\n                    sig[col] = (board[row][col] == 1);\\n                }\\n                ++sig_to_cnts[sig];\\n            }\\n            if (auto res = get_signature(sig_to_cnts)) {\\n                row_sig = *res;\\n            } else {\\n                return -1;\\n            }\\n        }    \\n        \\n        sig_t col_sig;\\n        {\\n            std::unordered_map<sig_t, int> sig_to_cnts;\\n            for (int col = 0; col < num_cols; ++col) {\\n                sig_t sig;\\n                for (int row = 0; row < num_rows; ++row) {\\n                    sig[row] = (board[row][col] == 1);\\n                }\\n                ++sig_to_cnts[sig];            \\n            }\\n            if (auto res = get_signature(sig_to_cnts)) {\\n                col_sig = *res;\\n            } else {\\n                return -1;\\n            }\\n        }               \\n        \\n        const auto diff_signature = [&](const sig_t &ref, const sig_t &tgt) -> int {\\n            int diff_cnts = 0;\\n            for (int i = 0; i < num_cols; ++i) {\\n                if (ref[i] != tgt[i]) {\\n                    ++diff_cnts;\\n                }\\n            }\\n            return diff_cnts;\\n        };\\n                                            \\n        sig_t ref01, ref10;\\n        for (int i = 0; i < num_cols; ++i) {\\n            ref01[i] = (i % 2 == 1);\\n            ref10[i] = (i % 2 == 0);\\n        }                                \\n        const auto get_min_ops = [&](const sig_t &tgt) -> int {\\n            int lhs_diff = INT_MAX;\\n            if (ref01.count() == tgt.count()) {\\n                lhs_diff = diff_signature(ref01, tgt);\\n            }\\n            int rhs_diff = INT_MAX;\\n            if (ref10.count() == tgt.count()) {\\n                rhs_diff = diff_signature(ref10, tgt);\\n            }\\n            return std::min(lhs_diff, rhs_diff) / 2;\\n        };\\n                        \\n        return get_min_ops(row_sig) + get_min_ops(col_sig);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487642,
                "title": "python-solutions",
                "content": "```\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        patt1 = ([0, 1]*(n//2+1))[:n]\\n        patt2 = ([1, 0]*(n//2+1))[:n]\\n        \\n        board_t = map(list, zip(*board))\\n        Cnt_r = list(Counter(tuple(row) for row in board).items())\\n        Cnt_c = list(Counter(tuple(row) for row in board_t).items())\\n        if len(Cnt_r) != 2 or len(Cnt_c) != 2: return -1\\n        if abs(Cnt_r[0][1] - Cnt_r[1][1]) > 1: return -1\\n        if abs(Cnt_c[0][1] - Cnt_c[1][1]) > 1: return -1\\n        \\n        x1 = sum(i != j for i,j in zip(Cnt_r[0][0], patt1))\\n        y1 = sum(i != j for i,j in zip(Cnt_c[0][0], patt1))\\n        \\n        x2 = sum(i != j for i,j in zip(Cnt_r[0][0], patt2))\\n        y2 = sum(i != j for i,j in zip(Cnt_c[0][0], patt2))\\n        \\n        cands_x = [x for x in [x1, x2] if x % 2 == 0]\\n        cands_y = [y for y in [y1, y2] if y % 2 == 0]\\n        \\n        return min(cands_x)//2 + min(cands_y)//2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToChessboard(self, board):\\n        n = len(board)\\n        patt1 = ([0, 1]*(n//2+1))[:n]\\n        patt2 = ([1, 0]*(n//2+1))[:n]\\n        \\n        board_t = map(list, zip(*board))\\n        Cnt_r = list(Counter(tuple(row) for row in board).items())\\n        Cnt_c = list(Counter(tuple(row) for row in board_t).items())\\n        if len(Cnt_r) != 2 or len(Cnt_c) != 2: return -1\\n        if abs(Cnt_r[0][1] - Cnt_r[1][1]) > 1: return -1\\n        if abs(Cnt_c[0][1] - Cnt_c[1][1]) > 1: return -1\\n        \\n        x1 = sum(i != j for i,j in zip(Cnt_r[0][0], patt1))\\n        y1 = sum(i != j for i,j in zip(Cnt_c[0][0], patt1))\\n        \\n        x2 = sum(i != j for i,j in zip(Cnt_r[0][0], patt2))\\n        y2 = sum(i != j for i,j in zip(Cnt_c[0][0], patt2))\\n        \\n        cands_x = [x for x in [x1, x2] if x % 2 == 0]\\n        cands_y = [y for y in [y1, y2] if y % 2 == 0]\\n        \\n        return min(cands_x)//2 + min(cands_y)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487590,
                "title": "rust-translated",
                "content": "```rust\\nimpl Solution {\\n    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {\\n        let n = board.len();\\n        for i in 1..n {\\n            if (1..n as i32).contains(&(0..n).map(|j| board[i][j] ^ board[0][j]).sum::<i32>()) {\\n                return -1;\\n            }\\n            if (1..n as i32).contains(&(0..n).map(|j| board[j][i] ^ board[j][0]).sum::<i32>()) {\\n                return -1;\\n            }\\n        }\\n        if ((0..n).map(|i| board[0][i]).sum::<i32>() * 2 - n as i32).abs() > 1 {\\n            return -1;\\n        }\\n        if ((0..n).map(|i| board[i][0]).sum::<i32>() * 2 - n as i32).abs() > 1 {\\n            return -1;\\n        }\\n        let mut rowdiff = (0..n).filter(|&i| board[0][i] == i as i32 % 2).count();\\n        if rowdiff % 2 != 0 || (n % 2 == 0 && rowdiff * 2 > n) {\\n            rowdiff = n - rowdiff;\\n        }\\n        let mut coldiff = (0..n).filter(|&i| board[i][0] == i as i32 % 2).count();\\n        if coldiff % 2 != 0 || (n % 2 == 0 && coldiff * 2 > n) {\\n            coldiff = n - coldiff;\\n        }\\n        (rowdiff + coldiff) as i32 / 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {\\n        let n = board.len();\\n        for i in 1..n {\\n            if (1..n as i32).contains(&(0..n).map(|j| board[i][j] ^ board[0][j]).sum::<i32>()) {\\n                return -1;\\n            }\\n            if (1..n as i32).contains(&(0..n).map(|j| board[j][i] ^ board[j][0]).sum::<i32>()) {\\n                return -1;\\n            }\\n        }\\n        if ((0..n).map(|i| board[0][i]).sum::<i32>() * 2 - n as i32).abs() > 1 {\\n            return -1;\\n        }\\n        if ((0..n).map(|i| board[i][0]).sum::<i32>() * 2 - n as i32).abs() > 1 {\\n            return -1;\\n        }\\n        let mut rowdiff = (0..n).filter(|&i| board[0][i] == i as i32 % 2).count();\\n        if rowdiff % 2 != 0 || (n % 2 == 0 && rowdiff * 2 > n) {\\n            rowdiff = n - rowdiff;\\n        }\\n        let mut coldiff = (0..n).filter(|&i| board[i][0] == i as i32 % 2).count();\\n        if coldiff % 2 != 0 || (n % 2 == 0 && coldiff * 2 > n) {\\n            coldiff = n - coldiff;\\n        }\\n        (rowdiff + coldiff) as i32 / 2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487545,
                "title": "super-helpful-explanation",
                "content": "Inspired by  [this](https://leetcode.com/problems/transform-to-chessboard/discuss/114847/Easy-and-Concise-Solution-with-Explanation-C%2B%2BJavaPython) and  [this](https://leetcode.com/problems/transform-to-chessboard/discuss/132113/Java-Clear-Code-with-Detailed-Explanations) posts, but use a different approach to count swap number, IMHO, which is more intuitive.\\n```\\n    int movesToChessboard(vector<vector<int>>& board) {\\n       /**** An Important Fact ****\\n        Take any 2 rows r1 and r2, then take 2 items in the same column c from the 2 rows, e.g. b[r1][c], b[r2][c], \\n        no matter how the rows or columns swap, the relationship between the 2 items never changes:\\n        if they are the same, they will always be the same, if they are inverted, they will always be inverted.\\n        Hence for a chess board, any two rows (or two columns) are either the same, or inverted.\\n        ***************************/\\n        // Hence we have:\\n        // Rule 1. If the board can be transformed to a chess board, for any two rows in the board, the cells between them must be either all the same, \\n        // or all inverted, if some items are inverted and some items are the same, they can\\'t form a chess board by swapping.\\n        // On the other hand:\\n        // Rule 2. The difference of two types of rows/columns cannot > 1, otherwise there must be >= 2 same type of rows/columns arranged together.\\n\\t\\t\\n        // Now, validate our board by these 2 rules.\\n        int n = board.size();\\n        int row_counter = 0, col_counter = 0;\\n        for(int r = 0; r < n; r++){\\n            row_counter += board[r][0] ? 1 : -1;\\n            for(int c = 0; c < n; c++){\\n                if(r == 0) col_counter += board[r][c] ? 1 : -1;\\n                // Check rule 1.\\n                // The relationship of items in current column between current row and first row should be consistent with the relationship of first items between current row and first row (i.e. the 2 pair of items should be either both the same or both inverted). Hence we compare the first cell of current row and first cell of first row, \\nthen compare the current cell with the cell in the cell in the same column in first row, the result should be the same.\\n                // Since XOR operator is associative and commutative, we don\\'t have to verify columns again (i.e. (board[0][c] ^ board[0][0]) ^ (board[r][c] ^ board[r][0]) )\\n                if((board[r][0] ^ board[0][0]) ^ (board[r][c] ^ board[0][c])) return -1; \\n            }\\n        }\\n        \\n        // Check rule 2.\\n        if(abs(row_counter) > 1 || abs(col_counter) > 1) return -1;\\n        \\n        // Count possible swap count, we only need care about the swap count of odd positions, since when we swap, we always swap an odd position with an even position.\\n        int row_swap_count = 0, col_swap_count = 0, row_0_count = 0, col_0_count = 0;\\n        // When n is odd, we need fit the item whose count is larger into even positions because even position is more than odd position.\\n        // E.g. \\n        // 0,1,0,1,1, then 0s must stay on odd positions so that 1s stay on even positions: 1,0,1,0,1.\\n        // 1,0,1,0,0, then 1s must stay on odd positions so that 0s stay on even positions: 0,1,0,1,0.\\n        for(int i = 0; i < n; i++){\\n            if(i & 1){ // When i is odd\\n                // Assume 0 is less and should stay on odd position, so we swap 1 away from odd position.\\n                row_swap_count += board[i][0];\\n                col_swap_count += board[0][i];\\n            }\\n            // Count 0.\\n            row_0_count += board[i][0] == 0, col_0_count += board[0][i] == 0;            \\n        }\\n        \\n        int odd_position_count = n/2; // Odd position count is always less than or equal with even position count.\\n        if(n & 1){ // When n is odd.\\n            // Count of 0 == odd_position_count means 0 is less, so we\\'re right on swapping 1 away, the current swap count is correct. \\n\\t\\t\\t// Otherwise we should keep 1 on the odd position and swap 0 away, so the swap count becomes odd_position_count - row_swap_count.\\n            row_swap_count = row_0_count == odd_position_count ? row_swap_count : (odd_position_count - row_swap_count);\\n            col_swap_count = col_0_count == odd_position_count ? col_swap_count : (odd_position_count - col_swap_count);\\n        }\\n        else{\\n            // If n is even, odd position\\'s count is the same with even position\\'s count, choose whichever swap count is smaller.\\n            row_swap_count = min(row_swap_count, odd_position_count - row_swap_count);\\n            col_swap_count = min(col_swap_count, odd_position_count - col_swap_count);            \\n        }\\n        \\n        return row_swap_count + col_swap_count;\\n    }",
                "solutionTags": [],
                "code": "Inspired by  [this](https://leetcode.com/problems/transform-to-chessboard/discuss/114847/Easy-and-Concise-Solution-with-Explanation-C%2B%2BJavaPython) and  [this](https://leetcode.com/problems/transform-to-chessboard/discuss/132113/Java-Clear-Code-with-Detailed-Explanations) posts, but use a different approach to count swap number, IMHO, which is more intuitive.\\n```\\n    int movesToChessboard(vector<vector<int>>& board) {\\n       /**** An Important Fact ****\\n        Take any 2 rows r1 and r2, then take 2 items in the same column c from the 2 rows, e.g. b[r1][c], b[r2][c], \\n        no matter how the rows or columns swap, the relationship between the 2 items never changes:\\n        if they are the same, they will always be the same, if they are inverted, they will always be inverted.\\n        Hence for a chess board, any two rows (or two columns) are either the same, or inverted.\\n        ***************************/\\n        // Hence we have:\\n        // Rule 1. If the board can be transformed to a chess board, for any two rows in the board, the cells between them must be either all the same, \\n        // or all inverted, if some items are inverted and some items are the same, they can\\'t form a chess board by swapping.\\n        // On the other hand:\\n        // Rule 2. The difference of two types of rows/columns cannot > 1, otherwise there must be >= 2 same type of rows/columns arranged together.\\n\\t\\t\\n        // Now, validate our board by these 2 rules.\\n        int n = board.size();\\n        int row_counter = 0, col_counter = 0;\\n        for(int r = 0; r < n; r++){\\n            row_counter += board[r][0] ? 1 : -1;\\n            for(int c = 0; c < n; c++){\\n                if(r == 0) col_counter += board[r][c] ? 1 : -1;\\n                // Check rule 1.\\n                // The relationship of items in current column between current row and first row should be consistent with the relationship of first items between current row and first row (i.e. the 2 pair of items should be either both the same or both inverted). Hence we compare the first cell of current row and first cell of first row, \\nthen compare the current cell with the cell in the cell in the same column in first row, the result should be the same.\\n                // Since XOR operator is associative and commutative, we don\\'t have to verify columns again (i.e. (board[0][c] ^ board[0][0]) ^ (board[r][c] ^ board[r][0]) )\\n                if((board[r][0] ^ board[0][0]) ^ (board[r][c] ^ board[0][c])) return -1; \\n            }\\n        }\\n        \\n        // Check rule 2.\\n        if(abs(row_counter) > 1 || abs(col_counter) > 1) return -1;\\n        \\n        // Count possible swap count, we only need care about the swap count of odd positions, since when we swap, we always swap an odd position with an even position.\\n        int row_swap_count = 0, col_swap_count = 0, row_0_count = 0, col_0_count = 0;\\n        // When n is odd, we need fit the item whose count is larger into even positions because even position is more than odd position.\\n        // E.g. \\n        // 0,1,0,1,1, then 0s must stay on odd positions so that 1s stay on even positions: 1,0,1,0,1.\\n        // 1,0,1,0,0, then 1s must stay on odd positions so that 0s stay on even positions: 0,1,0,1,0.\\n        for(int i = 0; i < n; i++){\\n            if(i & 1){ // When i is odd\\n                // Assume 0 is less and should stay on odd position, so we swap 1 away from odd position.\\n                row_swap_count += board[i][0];\\n                col_swap_count += board[0][i];\\n            }\\n            // Count 0.\\n            row_0_count += board[i][0] == 0, col_0_count += board[0][i] == 0;            \\n        }\\n        \\n        int odd_position_count = n/2; // Odd position count is always less than or equal with even position count.\\n        if(n & 1){ // When n is odd.\\n            // Count of 0 == odd_position_count means 0 is less, so we\\'re right on swapping 1 away, the current swap count is correct. \\n\\t\\t\\t// Otherwise we should keep 1 on the odd position and swap 0 away, so the swap count becomes odd_position_count - row_swap_count.\\n            row_swap_count = row_0_count == odd_position_count ? row_swap_count : (odd_position_count - row_swap_count);\\n            col_swap_count = col_0_count == odd_position_count ? col_swap_count : (odd_position_count - col_swap_count);\\n        }\\n        else{\\n            // If n is even, odd position\\'s count is the same with even position\\'s count, choose whichever swap count is smaller.\\n            row_swap_count = min(row_swap_count, odd_position_count - row_swap_count);\\n            col_swap_count = min(col_swap_count, odd_position_count - col_swap_count);            \\n        }\\n        \\n        return row_swap_count + col_swap_count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1487531,
                "title": "my-c-solution",
                "content": "```\\nint movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int maxR = 0, maxC = 0, ones = 0, zeros = 0;\\n        for (int i = 0; i < n; i++) {\\n            int rzero = 0, rone = 0, czero = 0, cone = 0;\\n            maxR = max(maxR, helper(-1, i, board, rzero, rone, n));\\n            if (maxR == INT_MAX) return -1;\\n            maxC = max(maxC, helper(i, -1, board, czero, cone, n));\\n            if (maxC == INT_MAX) return -1;\\n            ones = ones + rone + cone;\\n            zeros = zeros + rzero + czero;\\n        }\\n        if (ones - zeros > 2 || zeros - ones > 2) return -1;\\n        return maxR + maxC;\\n    }\\n    \\n    int helper(int r, int c, vector<vector<int>>& board, int& zero, int& one, int n) {\\n        zero = 0, one = 0;\\n        int oneodd = 0, oneeven = 0;\\n        int result = 0;\\n        for (int i = 0; i < n; i ++) {\\n            int b = r == -1 ? board[i][c] : board[r][i];\\n            if (b == 0) {\\n                zero++;\\n            }\\n            else {\\n                one++;\\n                if (i % 2 == 0) oneeven++;\\n                else oneodd++;\\n            }\\n        }\\n        if (one - zero > 1 || zero - one > 1) return INT_MAX;\\n        if (one > zero) result = oneodd;\\n        else if (one < zero) result = oneeven;\\n        else result = min(oneodd, oneeven);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\nint movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        int maxR = 0, maxC = 0, ones = 0, zeros = 0;\\n        for (int i = 0; i < n; i++) {\\n            int rzero = 0, rone = 0, czero = 0, cone = 0;\\n            maxR = max(maxR, helper(-1, i, board, rzero, rone, n));\\n            if (maxR == INT_MAX) return -1;\\n            maxC = max(maxC, helper(i, -1, board, czero, cone, n));\\n            if (maxC == INT_MAX) return -1;\\n            ones = ones + rone + cone;\\n            zeros = zeros + rzero + czero;\\n        }\\n        if (ones - zeros > 2 || zeros - ones > 2) return -1;\\n        return maxR + maxC;\\n    }\\n    \\n    int helper(int r, int c, vector<vector<int>>& board, int& zero, int& one, int n) {\\n        zero = 0, one = 0;\\n        int oneodd = 0, oneeven = 0;\\n        int result = 0;\\n        for (int i = 0; i < n; i ++) {\\n            int b = r == -1 ? board[i][c] : board[r][i];\\n            if (b == 0) {\\n                zero++;\\n            }\\n            else {\\n                one++;\\n                if (i % 2 == 0) oneeven++;\\n                else oneodd++;\\n            }\\n        }\\n        if (one - zero > 1 || zero - one > 1) return INT_MAX;\\n        if (one > zero) result = oneodd;\\n        else if (one < zero) result = oneeven;\\n        else result = min(oneodd, oneeven);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1487503,
                "title": "refer-this-post",
                "content": "https://leetcode.com/problems/transform-to-chessboard/discuss/114847/C%2B%2BJavaPython-Solution-with-Explanation\\n\\nAlso follow the comments for your learning.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1487482,
                "title": "python-straightforward-approach",
                "content": "```\\nfrom operator import xor\\nclass Solution(object):\\n    def movesToChessboard(self, board):\\n        \"\"\"\\n        :type board: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m,n=len(board),len(board[0])\\n\\n        # check single row\\n        def valid_s(r):\\n            n=len(r)\\n            rowSum=sum(r)\\n            if n%2: # odd number\\n                if rowSum not in [n/2,n/2+1]: return False\\n            else: # even number\\n                if rowSum!=n/2: return False\\n            return True\\n\\n        # compare each adjacent row\\n        def valid(r1,r2):\\n            if r1==r2 or all(map(xor,r1,r2)): return True\\n            return False\\n\\n        # check rows\\n        if not valid_s(board[0]): return -1\\n        for i in xrange(m-1):\\n            if not valid(board[i],board[i+1]):\\n                return -1\\n\\n        # check columns\\n        boardT=map(list,zip(*board)) # transform for simplicity\\n        if not valid_s(boardT[0]): return -1\\n        for i in xrange(n-1):\\n            if not valid(boardT[i],boardT[i+1]):\\n                return -1\\n\\n        # calculate swap\\n        def cal(r):\\n            n=len(r)\\n            rowsum=sum(r)\\n            if n%2: # odd number\\n                if rowsum>n/2: # 1 dominates\\n                    r1=[1,0]*(n/2)+[1]\\n                else: # 0 dominates\\n                    r1=[0,1]*(n/2)+[0]\\n                return sum(map(xor,r,r1))/2\\n            else: # even number\\n                r1=[1,0]*(n/2)\\n                r2=[0,1]*(n/2)\\n                swap1=sum(map(xor,r,r1))\\n                swap2=sum(map(xor,r,r2))\\n                return min(swap1,swap2)/2\\n\\n        return cal(board[0])+cal(boardT[0])",
                "solutionTags": [],
                "code": "```\\nfrom operator import xor\\nclass Solution(object):\\n    def movesToChessboard(self, board):\\n        \"\"\"\\n        :type board: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m,n=len(board),len(board[0])\\n\\n        # check single row\\n        def valid_s(r):\\n            n=len(r)\\n            rowSum=sum(r)\\n            if n%2: # odd number\\n                if rowSum not in [n/2,n/2+1]: return False\\n            else: # even number\\n                if rowSum!=n/2: return False\\n            return True\\n\\n        # compare each adjacent row\\n        def valid(r1,r2):\\n            if r1==r2 or all(map(xor,r1,r2)): return True\\n            return False\\n\\n        # check rows\\n        if not valid_s(board[0]): return -1\\n        for i in xrange(m-1):\\n            if not valid(board[i],board[i+1]):\\n                return -1\\n\\n        # check columns\\n        boardT=map(list,zip(*board)) # transform for simplicity\\n        if not valid_s(boardT[0]): return -1\\n        for i in xrange(n-1):\\n            if not valid(boardT[i],boardT[i+1]):\\n                return -1\\n\\n        # calculate swap\\n        def cal(r):\\n            n=len(r)\\n            rowsum=sum(r)\\n            if n%2: # odd number\\n                if rowsum>n/2: # 1 dominates\\n                    r1=[1,0]*(n/2)+[1]\\n                else: # 0 dominates\\n                    r1=[0,1]*(n/2)+[0]\\n                return sum(map(xor,r,r1))/2\\n            else: # even number\\n                r1=[1,0]*(n/2)\\n                r2=[0,1]*(n/2)\\n                swap1=sum(map(xor,r,r1))\\n                swap2=sum(map(xor,r,r2))\\n                return min(swap1,swap2)/2\\n\\n        return cal(board[0])+cal(boardT[0])",
                "codeTag": "Java"
            },
            {
                "id": 1487478,
                "title": "easy-explanation",
                "content": "The algorithm is based on counting. A solvable board has each row/column either the same as the first row/column or exactly cell-by-cell reversed color of the first row/column.\\n\\nIn the loop we count for rs and cs, the number of rows/columns being the same as the first row/column, and rm and cm, the number of misplaced rows/columns in the view of the first row/column. If any row/column is found to be neither the same nor reversed color then returns -1 immediately.\\n\\nThen, for even number n there are two final forms of the first row/column. We compute the minimum swaps of the two cases. For odd number n there is only one final form of the board so we compute the swaps based on the fact that whether the first row/column is in the less or the greater half.\\n```\\nint movesToChessboard(vector<vector<int>>& b) {\\n    int n = b.size();\\n    int rs = 0, cs = 0, rm = 0, cm = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        bool rf = b[0][0] == b[i][0], cf = b[0][0] == b[0][i];\\n        rs += rf, cs += cf;\\n        rm += rf ^ !(i & 1), cm += cf ^ !(i & 1);\\n        for (int j = 0; j < n; j++)\\n            if ((b[0][j] == b[i][j]) ^ rf || (b[j][0] == b[j][i]) ^ cf)\\n                return -1;\\n    }\\n\\n    if (n % 2 == 0) {\\n        if (rs == n / 2 && cs == n / 2)\\n            return min(rm, n - rm) / 2 + min(cm, n - cm) / 2;\\n        return -1;\\n    }\\n\\n    int res = 0;\\n    if (rs == n / 2)\\n        res += (n - rm) / 2;\\n    else if (rs == n / 2 + 1)\\n        res += rm / 2;\\n    else\\n        return -1;\\n\\n    if (cs == n / 2)\\n        res += (n - cm) / 2;\\n    else if (cs == n / 2 + 1)\\n        res += cm / 2;\\n    else\\n        return -1;\\n\\n    return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "The algorithm is based on counting. A solvable board has each row/column either the same as the first row/column or exactly cell-by-cell reversed color of the first row/column.\\n\\nIn the loop we count for rs and cs, the number of rows/columns being the same as the first row/column, and rm and cm, the number of misplaced rows/columns in the view of the first row/column. If any row/column is found to be neither the same nor reversed color then returns -1 immediately.\\n\\nThen, for even number n there are two final forms of the first row/column. We compute the minimum swaps of the two cases. For odd number n there is only one final form of the board so we compute the swaps based on the fact that whether the first row/column is in the less or the greater half.\\n```\\nint movesToChessboard(vector<vector<int>>& b) {\\n    int n = b.size();\\n    int rs = 0, cs = 0, rm = 0, cm = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        bool rf = b[0][0] == b[i][0], cf = b[0][0] == b[0][i];\\n        rs += rf, cs += cf;\\n        rm += rf ^ !(i & 1), cm += cf ^ !(i & 1);\\n        for (int j = 0; j < n; j++)\\n            if ((b[0][j] == b[i][j]) ^ rf || (b[j][0] == b[j][i]) ^ cf)\\n                return -1;\\n    }\\n\\n    if (n % 2 == 0) {\\n        if (rs == n / 2 && cs == n / 2)\\n            return min(rm, n - rm) / 2 + min(cm, n - cm) / 2;\\n        return -1;\\n    }\\n\\n    int res = 0;\\n    if (rs == n / 2)\\n        res += (n - rm) / 2;\\n    else if (rs == n / 2 + 1)\\n        res += rm / 2;\\n    else\\n        return -1;\\n\\n    if (cs == n / 2)\\n        res += (n - cm) / 2;\\n    else if (cs == n / 2 + 1)\\n        res += cm / 2;\\n    else\\n        return -1;\\n\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1487433,
                "title": "python3",
                "content": "![image](https://assets.leetcode.com/users/images/dd2a3966-be6c-485c-8303-54fa1233d588_1632668777.2564044.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/dd2a3966-be6c-485c-8303-54fa1233d588_1632668777.2564044.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 996468,
                "title": "o-n-2-c-code-with-proof-of-mzchen-s-observation-in-comments",
                "content": "This isn\\'t easy to get for me and I hope my code and comment is clear. I think this is a better code readability practice that algo practice.\\nPlease let me know the confusing parts :P\\n```\\nclass Solution {\\npublic:\\n    // Both the column and row swap satisfies the following\\n    // property:\\n    // All the numbers in a row will always be in the same row\\n    // however swapped. The reasoning is simple: row swap will \\n    // keep the positions of the numbers in the same row unchanged\\n    // and column swap will move the number in a same row within\\n    // the row.\\n    // Similarly all the numbers in a same column will always be \\n    // in the same column, however swapped.\\n    // Let\\'s call it \"group-invariant property\" which is vital for\\n    // an efficient solution.\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        // If a board is transformable, there can only be two kind\\n        // of rows: 1. the number order in the row are extactly same\\n        // as in the first row; 2. the number in the row are exactly\\n        // complimentary of the nubmer in the first row at the same\\n        // position. Similar rules also apply to columns. This will\\n        // be notd as the \"complimentary\" property.\\n        // This can be proved by contradictory. Assume there are two\\n        // rows, r1 and r2, in the board where exits two positions p1\\n        // and p2. The numbers in r1 and r2 at position p1 are 1 and 0\\n        // correspondingly and the numbers at position p2 are both 1.\\n        // If the board is transformable, numbers at p2 needs to be\\n        // swapped without affecting the nubmers at p1. And it is not \\n\\t\\t// possible for the elements to move out from r1 or r2 due to \\n\\t\\t// the \"group-invariant property\". Since there are\\n        // only two operations column swap and row swap, they can be\\n        // tried exhaustively. Row swap won\\'t change relative positions\\n        // within two rows so it won\\'t work. Column swap will move numbers\\n        // at p1 togather, so it also cannot be done. If one want to \\n        // swap numbers at position p1 without affecting number at p2,\\n        // similary reasoning can be applied. Thus complimentary property\\n        // is proved.\\n        for (int i = 0; i < n; ++i) {\\n            // If ith row and first row are exactly the same, \\n            // rowComplimentary will be 0, otherwise 1.\\n            int rowComplimentary = board[i][0] ^ board[0][0];\\n            // If ith column and first column are exactly the same, \\n            // colComplimentary will be 0, otherwise 1.\\n            int colComplimentary = board[0][i] ^ board[0][0];\\n            for (int j = 0; j < n; ++j) {\\n                // Check the complimentary property on ith rows.\\n                if ((board[i][j] ^ board[0][j]) != rowComplimentary) {\\n                    return -1;\\n                }\\n                // Check the complimentary property on ith columns.\\n                if ((board[j][i] ^ board[j][0]) != colComplimentary) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // There are two properties\\n        // that will be helpful here:\\n        //     1. row and column are moved independently so the moves need \\n        //        to be added.\\n        //     2. If there are n rows/columns that are mis-placed, each swap\\n        //        can put two of them back to right place, thus the move number\\n        //        will be mis-placed numbers divided by 2.\\n        //     3. Assume all 0s should be put on even position and all 1s\\n        //        should be put on odd positions, the acutual misplaced number\\n        //        will be the smaller one between misplaced-number and\\n        //        N - misplaced-number.\\n        // This section be combined into the first for loop where the complimentary\\n        // property is verified.\\n        int misplacedRowCount = 0;\\n        int misplacedColCount = 0;\\n        int rowComplimentartyCount = 0;\\n        int colComplimentartyCount = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // Count misplaced digit for first row.\\n            int complimentaryRow = board[0][i] ^ board[0][0];\\n            rowComplimentartyCount += complimentaryRow;\\n            misplacedRowCount += complimentaryRow ^ !(i & 1);\\n            // Count misplaced digit for first column.\\n            int complimentaryCol = board[i][0] ^ board[0][0];\\n            colComplimentartyCount += complimentaryCol;\\n            misplacedColCount += complimentaryCol ^ !(i & 1);\\n        }\\n\\n        // When n is even, the move complimentary counts needs to be n/2 and the\\n        // move is easy to count.\\n        if (n % 2 == 0) {\\n            if (rowComplimentartyCount != n/2 || colComplimentartyCount != n/2) {\\n                return -1;\\n            }\\n            return (min(misplacedRowCount, n - misplacedRowCount) / 2 +\\n                    min(misplacedColCount, n - misplacedColCount) / 2);\\n        }\\n        // cout << n << endl << rowComplimentartyCount << \" \" << colComplimentartyCount << \"\\\\n\"\\n             // << misplacedRowCount << \" \" << misplacedColCount << endl << endl;\\n        int move = 0;\\n        if (rowComplimentartyCount == n/2) {\\n            move += (n - misplacedRowCount) / 2;\\n        } else if (rowComplimentartyCount == n/2 + 1) {\\n            move += misplacedRowCount / 2;\\n        } else {\\n            return -1;\\n        }\\n        // cout << \"row \" << move;\\n        if (colComplimentartyCount == n/2) {\\n            move += (n - misplacedColCount) / 2;\\n        } else if (colComplimentartyCount == n/2 + 1) {\\n            move += misplacedColCount / 2;\\n        } else {\\n            return -1;\\n        }\\n        // cout << \". col \" << move << endl;\\n        return move;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Both the column and row swap satisfies the following\\n    // property:\\n    // All the numbers in a row will always be in the same row\\n    // however swapped. The reasoning is simple: row swap will \\n    // keep the positions of the numbers in the same row unchanged\\n    // and column swap will move the number in a same row within\\n    // the row.\\n    // Similarly all the numbers in a same column will always be \\n    // in the same column, however swapped.\\n    // Let\\'s call it \"group-invariant property\" which is vital for\\n    // an efficient solution.\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int n = board.size();\\n        // If a board is transformable, there can only be two kind\\n        // of rows: 1. the number order in the row are extactly same\\n        // as in the first row; 2. the number in the row are exactly\\n        // complimentary of the nubmer in the first row at the same\\n        // position. Similar rules also apply to columns. This will\\n        // be notd as the \"complimentary\" property.\\n        // This can be proved by contradictory. Assume there are two\\n        // rows, r1 and r2, in the board where exits two positions p1\\n        // and p2. The numbers in r1 and r2 at position p1 are 1 and 0\\n        // correspondingly and the numbers at position p2 are both 1.\\n        // If the board is transformable, numbers at p2 needs to be\\n        // swapped without affecting the nubmers at p1. And it is not \\n\\t\\t// possible for the elements to move out from r1 or r2 due to \\n\\t\\t// the \"group-invariant property\". Since there are\\n        // only two operations column swap and row swap, they can be\\n        // tried exhaustively. Row swap won\\'t change relative positions\\n        // within two rows so it won\\'t work. Column swap will move numbers\\n        // at p1 togather, so it also cannot be done. If one want to \\n        // swap numbers at position p1 without affecting number at p2,\\n        // similary reasoning can be applied. Thus complimentary property\\n        // is proved.\\n        for (int i = 0; i < n; ++i) {\\n            // If ith row and first row are exactly the same, \\n            // rowComplimentary will be 0, otherwise 1.\\n            int rowComplimentary = board[i][0] ^ board[0][0];\\n            // If ith column and first column are exactly the same, \\n            // colComplimentary will be 0, otherwise 1.\\n            int colComplimentary = board[0][i] ^ board[0][0];\\n            for (int j = 0; j < n; ++j) {\\n                // Check the complimentary property on ith rows.\\n                if ((board[i][j] ^ board[0][j]) != rowComplimentary) {\\n                    return -1;\\n                }\\n                // Check the complimentary property on ith columns.\\n                if ((board[j][i] ^ board[j][0]) != colComplimentary) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // There are two properties\\n        // that will be helpful here:\\n        //     1. row and column are moved independently so the moves need \\n        //        to be added.\\n        //     2. If there are n rows/columns that are mis-placed, each swap\\n        //        can put two of them back to right place, thus the move number\\n        //        will be mis-placed numbers divided by 2.\\n        //     3. Assume all 0s should be put on even position and all 1s\\n        //        should be put on odd positions, the acutual misplaced number\\n        //        will be the smaller one between misplaced-number and\\n        //        N - misplaced-number.\\n        // This section be combined into the first for loop where the complimentary\\n        // property is verified.\\n        int misplacedRowCount = 0;\\n        int misplacedColCount = 0;\\n        int rowComplimentartyCount = 0;\\n        int colComplimentartyCount = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // Count misplaced digit for first row.\\n            int complimentaryRow = board[0][i] ^ board[0][0];\\n            rowComplimentartyCount += complimentaryRow;\\n            misplacedRowCount += complimentaryRow ^ !(i & 1);\\n            // Count misplaced digit for first column.\\n            int complimentaryCol = board[i][0] ^ board[0][0];\\n            colComplimentartyCount += complimentaryCol;\\n            misplacedColCount += complimentaryCol ^ !(i & 1);\\n        }\\n\\n        // When n is even, the move complimentary counts needs to be n/2 and the\\n        // move is easy to count.\\n        if (n % 2 == 0) {\\n            if (rowComplimentartyCount != n/2 || colComplimentartyCount != n/2) {\\n                return -1;\\n            }\\n            return (min(misplacedRowCount, n - misplacedRowCount) / 2 +\\n                    min(misplacedColCount, n - misplacedColCount) / 2);\\n        }\\n        // cout << n << endl << rowComplimentartyCount << \" \" << colComplimentartyCount << \"\\\\n\"\\n             // << misplacedRowCount << \" \" << misplacedColCount << endl << endl;\\n        int move = 0;\\n        if (rowComplimentartyCount == n/2) {\\n            move += (n - misplacedRowCount) / 2;\\n        } else if (rowComplimentartyCount == n/2 + 1) {\\n            move += misplacedRowCount / 2;\\n        } else {\\n            return -1;\\n        }\\n        // cout << \"row \" << move;\\n        if (colComplimentartyCount == n/2) {\\n            move += (n - misplacedColCount) / 2;\\n        } else if (colComplimentartyCount == n/2 + 1) {\\n            move += misplacedColCount / 2;\\n        } else {\\n            return -1;\\n        }\\n        // cout << \". col \" << move << endl;\\n        return move;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1565208,
                "content": [
                    {
                        "username": "hiiwave",
                        "content": "An observation is that, in a valid ChessBoard, *any rectangle* inside the board with corner `NW, NE, SW, SE` (NW here means north-west) must satisfy `(NW xor NE) == (SW xor SE)`, where `xor` is [exclusive or](https://en.wikipedia.org/wiki/Exclusive_or). Here we call it **validness property**.\\n\\nSince the swap process does not break this property, for a given board to be valid, this property must hold. A corollary is that **given a row, any other row must be identical to it or be its inverse**. For example if there is a row `01010011` in the board, any other row must be either `01010011` or `10101100`.\\n\\nWith this observation, we **only need to consider the first column when we're swapping rows** to match the ChessBoard condition. That is, it suffies to find the minimum *row swap* to make the first column be `010101...^T` or `101010...^T`. (here `^T` means transpose.)\\n\\nSimilarly, it suffies to consider the first row when swapping columns.\\n\\nNow the problem becomes solvable, with the following steps:\\n1. Check if the given board satisfy the validness property defined above.\\n2. Find minimum row swap to make the first column valid. If not possible, return -1.\\n3. Find minimum column swap to make the first row valid. If not possible, return -1.\\n4. Return the sum of step 2 and 3."
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "[@c4pt41n-V0Yag3R](/c4pt41n-V0Yag3R) This property is a necessary but not a sufficient condition. Steps 2 and 3 provide sufficient conditions."
                    },
                    {
                        "username": "c4pt41n-V0Yag3R",
                        "content": "[[1 0] [1 0]] satisfies your validness property, but is not a valid board?"
                    },
                    {
                        "username": "3rdTime",
                        "content": "a board where no 0s and no 1s are 4-directionally adjacent?\\n\\nWhat does it mean?\\n\\nIs \\n0 1 0 0 1\\n1 0 1 1 0\\n0 1 0 0 1\\na valid solution?\\n\\nIs \\n0 1 0 0 0\\n1 0 1 1 1\\n0 1 0 0 0\\na valid solution?"
                    },
                    {
                        "username": "aaaayux313",
                        "content": "what does 4-directionally adjacent mean?"
                    }
                ]
            },
            {
                "id": 1566816,
                "content": [
                    {
                        "username": "hiiwave",
                        "content": "An observation is that, in a valid ChessBoard, *any rectangle* inside the board with corner `NW, NE, SW, SE` (NW here means north-west) must satisfy `(NW xor NE) == (SW xor SE)`, where `xor` is [exclusive or](https://en.wikipedia.org/wiki/Exclusive_or). Here we call it **validness property**.\\n\\nSince the swap process does not break this property, for a given board to be valid, this property must hold. A corollary is that **given a row, any other row must be identical to it or be its inverse**. For example if there is a row `01010011` in the board, any other row must be either `01010011` or `10101100`.\\n\\nWith this observation, we **only need to consider the first column when we're swapping rows** to match the ChessBoard condition. That is, it suffies to find the minimum *row swap* to make the first column be `010101...^T` or `101010...^T`. (here `^T` means transpose.)\\n\\nSimilarly, it suffies to consider the first row when swapping columns.\\n\\nNow the problem becomes solvable, with the following steps:\\n1. Check if the given board satisfy the validness property defined above.\\n2. Find minimum row swap to make the first column valid. If not possible, return -1.\\n3. Find minimum column swap to make the first row valid. If not possible, return -1.\\n4. Return the sum of step 2 and 3."
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "[@c4pt41n-V0Yag3R](/c4pt41n-V0Yag3R) This property is a necessary but not a sufficient condition. Steps 2 and 3 provide sufficient conditions."
                    },
                    {
                        "username": "c4pt41n-V0Yag3R",
                        "content": "[[1 0] [1 0]] satisfies your validness property, but is not a valid board?"
                    },
                    {
                        "username": "3rdTime",
                        "content": "a board where no 0s and no 1s are 4-directionally adjacent?\\n\\nWhat does it mean?\\n\\nIs \\n0 1 0 0 1\\n1 0 1 1 0\\n0 1 0 0 1\\na valid solution?\\n\\nIs \\n0 1 0 0 0\\n1 0 1 1 1\\n0 1 0 0 0\\na valid solution?"
                    },
                    {
                        "username": "aaaayux313",
                        "content": "what does 4-directionally adjacent mean?"
                    }
                ]
            },
            {
                "id": 1752194,
                "content": [
                    {
                        "username": "hiiwave",
                        "content": "An observation is that, in a valid ChessBoard, *any rectangle* inside the board with corner `NW, NE, SW, SE` (NW here means north-west) must satisfy `(NW xor NE) == (SW xor SE)`, where `xor` is [exclusive or](https://en.wikipedia.org/wiki/Exclusive_or). Here we call it **validness property**.\\n\\nSince the swap process does not break this property, for a given board to be valid, this property must hold. A corollary is that **given a row, any other row must be identical to it or be its inverse**. For example if there is a row `01010011` in the board, any other row must be either `01010011` or `10101100`.\\n\\nWith this observation, we **only need to consider the first column when we're swapping rows** to match the ChessBoard condition. That is, it suffies to find the minimum *row swap* to make the first column be `010101...^T` or `101010...^T`. (here `^T` means transpose.)\\n\\nSimilarly, it suffies to consider the first row when swapping columns.\\n\\nNow the problem becomes solvable, with the following steps:\\n1. Check if the given board satisfy the validness property defined above.\\n2. Find minimum row swap to make the first column valid. If not possible, return -1.\\n3. Find minimum column swap to make the first row valid. If not possible, return -1.\\n4. Return the sum of step 2 and 3."
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "[@c4pt41n-V0Yag3R](/c4pt41n-V0Yag3R) This property is a necessary but not a sufficient condition. Steps 2 and 3 provide sufficient conditions."
                    },
                    {
                        "username": "c4pt41n-V0Yag3R",
                        "content": "[[1 0] [1 0]] satisfies your validness property, but is not a valid board?"
                    },
                    {
                        "username": "3rdTime",
                        "content": "a board where no 0s and no 1s are 4-directionally adjacent?\\n\\nWhat does it mean?\\n\\nIs \\n0 1 0 0 1\\n1 0 1 1 0\\n0 1 0 0 1\\na valid solution?\\n\\nIs \\n0 1 0 0 0\\n1 0 1 1 1\\n0 1 0 0 0\\na valid solution?"
                    },
                    {
                        "username": "aaaayux313",
                        "content": "what does 4-directionally adjacent mean?"
                    }
                ]
            }
        ]
    }
]