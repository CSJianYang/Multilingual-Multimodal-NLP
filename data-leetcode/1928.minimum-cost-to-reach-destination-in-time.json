[
    {
        "title": "Number of Equivalent Domino Pairs",
        "question_content": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\n&nbsp;\nExample 1:\n\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1\n\nExample 2:\n\nInput: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= dominoes.length <= 4 * 104\n\tdominoes[i].length == 2\n\t1 <= dominoes[i][j] <= 9",
        "solutions": [
            {
                "id": 340022,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Intuition**\\nJust count the number of different dominoes.\\n<br>\\n\\n# **Explanation**\\nYou need to distinguish the different dominoes and count the same.\\n\\nI did it in this way:\\n`f(domino) = min(d[0], d[1]) * 10 + max(d[0], d[1])`\\nFor each domino `d`, calculate `min(d[0], d[1]) * 10 + max(d[0], d[1])`\\nThis will put the smaller number on the left and bigger one on the right (in decimal).\\nSo same number same domino, different number different domino.\\n\\nTake the example from the problem:\\n`dominoes = [[1,2],[2,1],[3,4],[5,6]]`\\nnow we transform it into `[12,12,34,56]`.\\n\\n@sendAsync also suggest other intersting ways to do that:\\n1. Use the product of primes\\n`primes = [2,3,5,7,11,13,17,19,23,29]`\\n`f(domino) = primes[d[0]] * primes[d[1]]`\\n(though primes[0] is not used)\\n\\n2. Use the bit manipulation.\\n`primes = [2,3,5,7,11,13,17,19,23,29]`\\n`f(domino) = 1 << d[0]| 1 << d[1];`\\n\\nPersonaly I like the second more.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n# Solution 1\\n\\nWe sum up the pair in the end after the loop,\\nusing the guass formula `sum = v * (v + 1) / 2`,\\nwhere `v` is the number of count.\\n\\n**Java:**\\n```java\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int res = 0;\\n        for (int[] d : dominoes) {\\n            int k = Math.min(d[0], d[1]) * 10 + Math.max(d[0], d[1]);\\n            count.put(k, count.getOrDefault(k, 0) + 1);\\n        }\\n        for (int v : count.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numEquivDominoPairs(self, A):\\n        return sum(v * (v - 1) / 2 for v in collections.Counter(tuple(sorted(x)) for x in A).values())\\n```\\n<br>\\n\\n# Solution 2\\n\\nWe sum up the pairs right away during the loop.\\n`count[domino]` is the number of same dominoes that we have seen.\\n\\n**C++:**\\n```cpp\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> count;\\n        int res = 0;\\n        for (auto& d : dominoes) {\\n            res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int res = 0;\\n        for (int[] d : dominoes) {\\n            int k = Math.min(d[0], d[1]) * 10 + Math.max(d[0], d[1]);\\n            count.put(k, count.getOrDefault(k, 0) + 1);\\n        }\\n        for (int v : count.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numEquivDominoPairs(self, A):\\n        return sum(v * (v - 1) / 2 for v in collections.Counter(tuple(sorted(x)) for x in A).values())\\n```\n```cpp\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> count;\\n        int res = 0;\\n        for (auto& d : dominoes) {\\n            res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 339969,
                "title": "java-python-3-o-n-code-with-brief-explanation-and-analysis",
                "content": "**Explanation of `cnt += pairs`** credit to **@wunanpty**\\nI want to explain why here we accumulate count like: cnt += pairs;\\nfor example our map is\\n\\nmap: <23, 1> <24, 1>\\ncurrent key = 23, so pair = 1, count += 1 -> count = 1 (which means we have 2 dominoes has same key, 2 dominoes is 1 pair)\\nmap become: <23, 2><24, 1>\\n\\ncurrent key = 23, so pair = 2, count += 2 -> count = 3 (which means we have 3 dominoes has same key, 3 dominoes is 3 pair -> (a, b)(a,c)(b,c))\\nmap become :<23, 3><24, 1>\\n\\ncurrent key = 23, so pair = 3, count += 3 -> count = 6 (4 dominoes has same key, 4 dominoes is 6 pair ->(a,b)(a,c)(a,d)(b,c)(b,d)(c,d))\\nmap become :<23, 4><24, 1>\\n\\n**End**\\n\\n**Q & A:**\\n**Q:** \\n1. Why do we use this for min * 10 + max, encoding?  how to decide on encoding?  \\n2. what if the maximum is infinite?\\n\\n**A:**\\n1. We do NOT have to use `10`, as long as the number `m` > `max(dominoes)`, there will be no collision; In addition, the corresponding decoding is `encoded / m`, `encoded % m`;\\n2. .If the size of the number is limited, we can convert it to a String. \\n\\n**End of Q & A**\\n\\n----\\n1. Encode each domino as min * 10 + max, where min and max are the smaller and bigger values of each domino, respectively;\\n2. Use a HashMap to store the number of dominoes with same encoding, and for each encoding (key), count the newly found pairs;\\n\\n**Java:**\\n```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int cnt = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] a : dominoes) {\\n            int max = Math.max(a[0], a[1]), min = Math.min(a[0], a[1]);\\n            int key = min * 10 + max;\\n            int pairs = map.getOrDefault(key, 0); // the number of dominoes already in the map is the number of the newly found pairs.\\n            cnt += pairs;\\n            map.put(key, 1 + pairs);\\n                               \\n        }\\n        return cnt;\\n    }\\n```\\n\\n----\\n**Python 3:**\\n\\n```\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = {}\\n        cnt = 0\\n        for a, b in dominoes:\\n            key = min(a, b) * 10 + max(a, b) \\n            if key in d:\\n                cnt += d[key] # the number of dominoes already in the map is the number of the newly found pairs.\\n                d[key] += 1\\n            else:\\n                d[key] = 1   \\n        return cnt\\n```\\nor \\n```python\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d, ans = defaultdict(int), 0\\n        for a, b in dominoes:\\n            key = min(a, b), max(a, b)\\n            ans += d[key]\\n            d[key] += 1\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nSince `1 <= dominoes[i][j] <= 9`, there are at most `9 * (9 + 1) / 2 = 45` encodings.\\nTime: O(n), space: O(45), where n = dominoes.length.",
                "solutionTags": [],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int cnt = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] a : dominoes) {\\n            int max = Math.max(a[0], a[1]), min = Math.min(a[0], a[1]);\\n            int key = min * 10 + max;\\n            int pairs = map.getOrDefault(key, 0); // the number of dominoes already in the map is the number of the newly found pairs.\\n            cnt += pairs;\\n            map.put(key, 1 + pairs);\\n                               \\n        }\\n        return cnt;\\n    }\\n```\n```\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = {}\\n        cnt = 0\\n        for a, b in dominoes:\\n            key = min(a, b) * 10 + max(a, b) \\n            if key in d:\\n                cnt += d[key] # the number of dominoes already in the map is the number of the newly found pairs.\\n                d[key] += 1\\n            else:\\n                d[key] = 1   \\n        return cnt\\n```\n```python\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d, ans = defaultdict(int), 0\\n        for a, b in dominoes:\\n            key = min(a, b), max(a, b)\\n            ans += d[key]\\n            d[key] += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 549709,
                "title": "easy-without-hashmap-java-solution-runtime-0ms",
                "content": "__Idea__ \\n```\\nThe main idea is to store each domino pair as a number for example..\\n[1,2] it will be stored as 12 and for domino [2,1] it is same as the above domino \\naccording to the question so this will also be stored as number 12. \\n\\nMaximum range for each number is 9 so the array which will store the frequency of each number will be of size100.\\nAt the end, In the freq array we will have freq of each type of domino and now we need to do nCr of those values.\\nSee the example to support this above line..,\\n[[1,2], [2,1], [1,2], [5,6], [6,5], [1,2]] \\nHere [1,2] this type of domino are 4 and [5,6] this type of domino are 2. \\nThe ans will be 4C2 + 2C2. so 4! \\xF7 (2! * 2!) + 2! \\xF7 (2! * 1!). \\n```\\n\\n\\nTo shorten the Formula see the below picture...,!\\n![image](https://assets.leetcode.com/users/frankenstein32/image_1585029327.png)\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] freq = new int[100];\\n        for(int[] d : dominoes){\\n            int x = Math.min(d[0],d[1]);\\n            int y = Math.max(d[1],d[0]);\\n            freq[x*10 + y]++;\\n        }\\n        int res = 0;\\n        for(int i = 0;i < 100;i++){\\n            if(freq[i] > 0){\\n                res += ((freq[i] * (freq[i] - 1)) / 2);\\n            }       \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThe main idea is to store each domino pair as a number for example..\\n[1,2] it will be stored as 12 and for domino [2,1] it is same as the above domino \\naccording to the question so this will also be stored as number 12. \\n\\nMaximum range for each number is 9 so the array which will store the frequency of each number will be of size100.\\nAt the end, In the freq array we will have freq of each type of domino and now we need to do nCr of those values.\\nSee the example to support this above line..,\\n[[1,2], [2,1], [1,2], [5,6], [6,5], [1,2]] \\nHere [1,2] this type of domino are 4 and [5,6] this type of domino are 2. \\nThe ans will be 4C2 + 2C2. so 4! \\xF7 (2! * 2!) + 2! \\xF7 (2! * 1!). \\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] freq = new int[100];\\n        for(int[] d : dominoes){\\n            int x = Math.min(d[0],d[1]);\\n            int y = Math.max(d[1],d[0]);\\n            freq[x*10 + y]++;\\n        }\\n        int res = 0;\\n        for(int i = 0;i < 100;i++){\\n            if(freq[i] > 0){\\n                res += ((freq[i] * (freq[i] - 1)) / 2);\\n            }       \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348400,
                "title": "python3-dictionary-count",
                "content": "* Use a dictionary to count how many times an intrinsic domino appeared. Here we define intrinsic domino as a sorted domino. By sort the list, we can easily identify the intrinsic domino.  Use the intrinsic domino as key, the intrinsic domino frequency as value, store the information we need in a dictionary.\\n```\\nExample:\\nindex     0     1      2     3\\ninput = [[1,2],[2,1],[1,2],[1,2]]\\nd = { [1,2] : 4}\\nThe number of equivalent domino pairs of the input will be 4 * 3 / 2 = 6\\n          index               index\\npair  1 :   0    [1,2]   and     1        [2,1]\\npair  2 :   0    [1,2]   and     2        [1,2]\\npair  3 :   0    [1,2]   and     3        [1,2]\\npair  4 :   1    [2,1]   and     0        [1,2]\\npair  5 :   1    [2,1]   and     2        [1,2]\\npair  6 :   1    [2,1]   and     3        [1,2]\\npair  7 :   2    [1,2]   and     0        [1,2]\\npair  8 :   2    [1,2]   and     1        [1,2]\\npair  9 :   2    [1,2]   and     3        [1,2]\\npair 10 :   3    [1,2]   and     0        [1,2]\\npair 11 :   3    [1,2]   and     1        [1,2]\\npair 12 :   3    [1,2]   and     2        [1,2]\\n\\napparently, \\npair 1 (index 0, 1) and pair 4  (index 1,0)  are considered the same pair. \\npair 2 (index 0, 2) and pair 7  (index 2,0)  are considered the same pair. \\npair 3 (index 0, 3) and pair 10 (index 3,0)  are considered the same pair. \\npair 5 (index 1, 2) and pair 8 (index 2,1)  are considered the same pair. \\npair 6 (index 1, 3) and pair 11 (index 3,1)  are considered the same pair. \\npair 9 (index 2, 3) and pair 12 (index 3,2)  are considered the same pair. \\n\\n\\n                    \\n```\\n* Calculate how many pairs of Equivalent domino:\\nFor each domino, the number of pairs = n*(n-1)//2, \\nwhere n is the domino frequency.\\nExplanation:\\n\\tFor the first domino in the pair, we have n options, \\n\\tFor the second domino in the pair, we have (n - 1) options. \\n\\tSince the order of domino in the pair doesn\\'t matter, which means\\n```\\nPair 1 : [1,2],[2,1]\\nPair 2 : [2,1],[1,2]\\nare considered the same pair.\\n```\\nWe need to divide by 2 to eliminate the duplicate.\\n```\\nimport collections\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # step 1: count the dominoes\\n        d = {}\\n        for domi in dominoes:\\n            p = tuple(sorted(domi))\\n            if p in d:\\n                d[p] += 1\\n            else:\\n                d[p] = 1\\n        # step 2: caculate the pairs. for each pair, number of pairs = n*(n-1)//2\\n        c = 0\\n        for n in d.values():\\n            s = n*(n-1)//2\\n            c += s\\n        return c\\n```\\n**Complexity Analysis**\\n* Time complexity: O(n)\\nDictionary takes O(1) to store. \\nTo generate the dictionary takes n*O(1) and calculate pairs takes O(n), the total time complexity is O(n), where n is the length of the input list.\\n* Space complexity: O(n)\\nAt worst case (every item in the input list appeared once), the algorithm needs a dictionary which it\\'s size equals the length of the list, where n is the length of the input list.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nExample:\\nindex     0     1      2     3\\ninput = [[1,2],[2,1],[1,2],[1,2]]\\nd = { [1,2] : 4}\\nThe number of equivalent domino pairs of the input will be 4 * 3 / 2 = 6\\n          index               index\\npair  1 :   0    [1,2]   and     1        [2,1]\\npair  2 :   0    [1,2]   and     2        [1,2]\\npair  3 :   0    [1,2]   and     3        [1,2]\\npair  4 :   1    [2,1]   and     0        [1,2]\\npair  5 :   1    [2,1]   and     2        [1,2]\\npair  6 :   1    [2,1]   and     3        [1,2]\\npair  7 :   2    [1,2]   and     0        [1,2]\\npair  8 :   2    [1,2]   and     1        [1,2]\\npair  9 :   2    [1,2]   and     3        [1,2]\\npair 10 :   3    [1,2]   and     0        [1,2]\\npair 11 :   3    [1,2]   and     1        [1,2]\\npair 12 :   3    [1,2]   and     2        [1,2]\\n\\napparently, \\npair 1 (index 0, 1) and pair 4  (index 1,0)  are considered the same pair. \\npair 2 (index 0, 2) and pair 7  (index 2,0)  are considered the same pair. \\npair 3 (index 0, 3) and pair 10 (index 3,0)  are considered the same pair. \\npair 5 (index 1, 2) and pair 8 (index 2,1)  are considered the same pair. \\npair 6 (index 1, 3) and pair 11 (index 3,1)  are considered the same pair. \\npair 9 (index 2, 3) and pair 12 (index 3,2)  are considered the same pair. \\n\\n\\n                    \\n```\n```\\nPair 1 : [1,2],[2,1]\\nPair 2 : [2,1],[1,2]\\nare considered the same pair.\\n```\n```\\nimport collections\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # step 1: count the dominoes\\n        d = {}\\n        for domi in dominoes:\\n            p = tuple(sorted(domi))\\n            if p in d:\\n                d[p] += 1\\n            else:\\n                d[p] = 1\\n        # step 2: caculate the pairs. for each pair, number of pairs = n*(n-1)//2\\n        c = 0\\n        for n in d.values():\\n            s = n*(n-1)//2\\n            c += s\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340458,
                "title": "java-one-pass-o-1-space-beats-100",
                "content": "We can save number of times we\\'ve seen each domino pair in the array of 9x9 < 100 elements. We are looping over the dominoes array and check every pair. Increment element [i,j] of our array. To take into account cases 1,2 and 2,1 we flip the pair so the upper number is always smaller. \\nThe catch is - for every next same pair we check array, if it\\'s > 1 we increment the result, but each time increment will be the number saved in array. So for case like this:\\n1,2 1,2 3,4 1,2 correct answer is 3 - index 0 matches 1 and 3, index 1 matches 3, there are no matches for index 2 and 3.\\n\\narray of results at [1,2] and num will be:\\n1. res[1,2] = 0 - initial\\n2. res[1,2] = 1, num=0 when index = 0\\n3. res[1,2] = 2, num = 1 when index = 1\\n4. res[3,4] = 1, num = 1 when index = 2\\n5. res[1,2] = 3, num = 3 when index = 3\\n\\nWe can use flat array, just compute the index by doing up*10 + down. This is 99 index max, means 100 elements.\\n\\nThis is O(n) time complexity - one scan of the inout array, O(1) space - we\\'ll need count array of the same size independently of number of dominoes.\\n\\nUPD: Make code compact by refactoring some part, thanks to @ysboss\\n\\n```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        //we need to acceess indexes from 0 to 99. max number of dominoes is 9\\n        int[] counts = new int[100];\\n        int res = 0;\\n        //check every pair of dominoes\\n        for (int[] d : dominoes) {\\n            //get upper and down number, make upper always smaller\\n            int up = d[0] < d[1] ? d[0] : d[1]; \\n\\t\\t\\tint down = d[0] < d[1] ? d[1] : d[0];\\n            //increment number of times we\\'ve seen exactly this pair\\n            //if more than once increment result, every next same pair will contribute on 1 more than a previous one\\n            res+=counts[up * 10 + down]++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        //we need to acceess indexes from 0 to 99. max number of dominoes is 9\\n        int[] counts = new int[100];\\n        int res = 0;\\n        //check every pair of dominoes\\n        for (int[] d : dominoes) {\\n            //get upper and down number, make upper always smaller\\n            int up = d[0] < d[1] ? d[0] : d[1]; \\n\\t\\t\\tint down = d[0] < d[1] ? d[1] : d[0];\\n            //increment number of times we\\'ve seen exactly this pair\\n            //if more than once increment result, every next same pair will contribute on 1 more than a previous one\\n            res+=counts[up * 10 + down]++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767338,
                "title": "c-2-approaches-easy-to-understand",
                "content": "# TIME LIMIT EXCEEDED\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int result = 0;\\n        for(int i = 0; i<d.size();i++){\\n            for(int j = i+1;j<d.size();j++){\\n                if((d[i][0] == d[j][0] && d[i][1] == d[j][1]) || (d[i][0] == d[j][1] && d[i][1] == d[j][0])){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Runtime: 104 ms, faster than 80.73% of C++ online submissions for Number of Equivalent Domino Pairs.\\nMemory Usage: 22 MB, less than 96.88% of C++ online submissions for Number of Equivalent Domino Pairs.***\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            seen[make_pair(v[0],v[1])]++;\\n        }\\n        for(auto& [key, value] : seen){\\n            result += value*(value-1)/2;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Runtime: 100 ms, faster than 88.74% of C++ online submissions for Number of Equivalent Domino Pairs.\\nMemory Usage: 22.1 MB, less than 90.63% of C++ online submissions for Number of Equivalent Domino Pairs.***\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            result += seen[make_pair(v[0],v[1])]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int result = 0;\\n        for(int i = 0; i<d.size();i++){\\n            for(int j = i+1;j<d.size();j++){\\n                if((d[i][0] == d[j][0] && d[i][1] == d[j][1]) || (d[i][0] == d[j][1] && d[i][1] == d[j][0])){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            seen[make_pair(v[0],v[1])]++;\\n        }\\n        for(auto& [key, value] : seen){\\n            result += value*(value-1)/2;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            result += seen[make_pair(v[0],v[1])]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506930,
                "title": "c-o-n-domino-id-and-map",
                "content": "##### Algorithm:\\nFor each domino I create an identifying number:\\n* if `d` is current domino, than identifier is: (d[1] << 4) + d[0]\\n* And reverse identifier, if we flip domino: (d[0] << 4) + d[1]\\n\\nCause **one side** of domino has **max value** of `9` (`1001` in binary), it can only take 4 bits. Total lenght of an identifier is `8` bits.\\n\\nFor `d=[9,5]` identifiers gonna look like:\\n![image](https://assets.leetcode.com/users/andnik/image_1582091923.png)\\n\\n##### Code:\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> dict;\\n        int count = 0;\\n        for (vector<int> d: dominoes) {\\n            int a = (d[0] << 4) | d[1], b = (d[1] << 4) | d[0];\\n            count += (a == b ? 0 : dict[b]) + dict[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> dict;\\n        int count = 0;\\n        for (vector<int> d: dominoes) {\\n            int a = (d[0] << 4) | d[1], b = (d[1] << 4) | d[0];\\n            count += (a == b ? 0 : dict[b]) + dict[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359439,
                "title": "java-simple-solution-8ms-beats-80-runtime-and-100-memory",
                "content": "Represents each domino as 2-digit number, when the first number is always the smallest.\\nFor example [2,3] or [3,2] domino will be represented as 23 number:\\n\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            \\n            int num = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\\n            int currCount = counts.getOrDefault(num, 0);\\n            res += currCount;\\n            counts.put(num, currCount + 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            \\n            int num = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\\n            int currCount = counts.getOrDefault(num, 0);\\n            res += currCount;\\n            counts.put(num, currCount + 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342042,
                "title": "javascript-o-n-simple-solution-using-map",
                "content": "Permutation:\\na -> 0\\naa -> 1 (0 + 1) pairs\\naaa -> 3 (1 + 2) paris\\naaaa -> 6 (3 + 3) pairs\\naaaaa -> 10 (6 + 4) pairs\\n.....\\n\\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for (let [a , b] of dominoes) {\\n        let key = a < b ? `${a}${b}` : `${b}${a}`;\\n\\n        if (map.has(key)) {\\n            let currentIndex = map.get(key) + 1;\\n            map.set(key, currentIndex);\\n            count += currentIndex;\\n        } else {\\n            map.set(key, 0);\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for (let [a , b] of dominoes) {\\n        let key = a < b ? `${a}${b}` : `${b}${a}`;\\n\\n        if (map.has(key)) {\\n            let currentIndex = map.get(key) + 1;\\n            map.set(key, currentIndex);\\n            count += currentIndex;\\n        } else {\\n            map.set(key, 0);\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817564,
                "title": "java-clean-and-beats-99-o-n-time-o-1-space-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] dominoMap = new int[100];\\n        int matches = 0;\\n        for (int[] domino : dominoes) {\\n            int n1 = domino[0], n2 = domino[1];\\n            int hash = Math.max(n1,n2) * 10 + Math.min(n1,n2);\\n            matches += dominoMap[hash]++;\\n        }\\n        return matches;\\n    }\\n}\\n```\\n\\nThe basic strategy is to keep track of matching dominos in the map using a key that will be the same if the numbers are the same, no matter the order. Since the return needs to be the number of pairs, you can derive that using a summation. Therefore, when a match is found the total matches for that domino is added each time.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] dominoMap = new int[100];\\n        int matches = 0;\\n        for (int[] domino : dominoes) {\\n            int n1 = domino[0], n2 = domino[1];\\n            int hash = Math.max(n1,n2) * 10 + Math.min(n1,n2);\\n            matches += dominoMap[hash]++;\\n        }\\n        return matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553484,
                "title": "python-99-48-one-liner-explained",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum( [ (v-1)*v//2 for v in collections.Counter([ 10*min(i)+max(i) for i in dominoes ]).values() ]) \\n```\\n\\nThis is how it works step by step. \\n\\nFirst we need to find a a way to assign a unique id to a domino regardless if it\\'s [x:y] or [y:x]. Since domino value is `1<x<9`, we can simply convert it into a 2 digit number like this `[ 10*min(i)+max(i) for i in dominoes ]` . Another approach would to use tuples like `[ tuple(sorted(i)) for i in dominoes ]`. \\n\\nOnce we converted the original list of dominoes into a list of dominoes disregarding orientation, the next step is to calculate counts using `collection.Counter()`. It will produce a dictionary with values like `\\'domino1\\':count1, \\'domino2\\':count2, ...`\\n\\nSince we just need the number of pairs, we can ignore the exact keys and just look at the values (the counts). Calculating pairs is a bit tricky, it\\'s basically n*(n-1)//2 for each domino.\\n\\nFinally we calculate the total count by using `sum()`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum( [ (v-1)*v//2 for v in collections.Counter([ 10*min(i)+max(i) for i in dominoes ]).values() ]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871033,
                "title": "python-dictionary-solution-with-explanation-252ms",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        #Keep track of the dominoes with a dictionary\\n\\t\\t#counter[ DOMINO ] = COUNT\\n        counter = defaultdict( int );\\n        \\n        #Total will be the total number of pairs\\n        total = 0;\\n        \\n        #Go through all of the dominoes\\n        for i in range( len ( dominoes ) ):\\n            #Check the pair at the index\\n            pair = dominoes[ i ];\\n            \\n            #Pull the two values\\n            first = pair[ 0 ];\\n            second = pair[ 1 ];\\n            \\n            #Sort them by value\\n\\t\\t\\t#This way, the reversed matches will go into the same count\\n            smaller = min ( first, second );\\n            bigger = max( first, second );\\n            \\n            #Reassemble into tuple\\n\\t\\t\\t#This will act as our key for each domino\\n            pair_sorted = ( smaller, bigger );\\n            \\n            #If the current domino is already in our counter\\n            #Add to the total the previous matches\\n            \\n            #That is\\n            #If we have already added matching dominoes\\n            #Our current one will match with all the previous\\n            if pair_sorted in counter:\\n                total += counter[ pair_sorted ];\\n            \\n            #Lastly, we increment the count of the current\\n            counter [ pair_sorted ] += 1;\\n            \\n            \\n        return total;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        #Keep track of the dominoes with a dictionary\\n\\t\\t#counter[ DOMINO ] = COUNT\\n        counter = defaultdict( int );\\n        \\n        #Total will be the total number of pairs\\n        total = 0;\\n        \\n        #Go through all of the dominoes\\n        for i in range( len ( dominoes ) ):\\n            #Check the pair at the index\\n            pair = dominoes[ i ];\\n            \\n            #Pull the two values\\n            first = pair[ 0 ];\\n            second = pair[ 1 ];\\n            \\n            #Sort them by value\\n\\t\\t\\t#This way, the reversed matches will go into the same count\\n            smaller = min ( first, second );\\n            bigger = max( first, second );\\n            \\n            #Reassemble into tuple\\n\\t\\t\\t#This will act as our key for each domino\\n            pair_sorted = ( smaller, bigger );\\n            \\n            #If the current domino is already in our counter\\n            #Add to the total the previous matches\\n            \\n            #That is\\n            #If we have already added matching dominoes\\n            #Our current one will match with all the previous\\n            if pair_sorted in counter:\\n                total += counter[ pair_sorted ];\\n            \\n            #Lastly, we increment the count of the current\\n            counter [ pair_sorted ] += 1;\\n            \\n            \\n        return total;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405437,
                "title": "python3-concise-and-efficient",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        m = collections.defaultdict(int)\\n        ans = 0\\n        for a, b in dominoes:\\n            if a > b: a, b = b, a\\n            v = 10*a + b\\n            if v in m:\\n                ans += m[v]\\n            m[v] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        m = collections.defaultdict(int)\\n        ans = 0\\n        for a, b in dominoes:\\n            if a > b: a, b = b, a\\n            v = 10*a + b\\n            if v in m:\\n                ans += m[v]\\n            m[v] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339957,
                "title": "6-lines-c-with-explanation-0-n-runtime",
                "content": "Key ideas:\\n1. Iterate through dominoes and build a Dictionary (HashMap in Java).\\n2. Form a key from domino values in the same (i.e accending) order so dominoes \\'1:2\\' and \\'2:1\\' will have the same key.\\n3. Count occurences of the key and count number of pairs at the same time.\\n\\nMy initial approach to counting pairs was to count occurences first and then have another iteration through dictionary to calculate pairs.\\nNumber of pairs for N number of occurences is (N-1) + (N-2) + ... + 1 or N*(N-1)/2. \\nThen I realised that pairs can be counted at the same time as occurences, i.e. 1 + 2 + ... + (N-2) + (N-1). \\nSo I started occurences from 0 and count pairs at the same time hence the line: count += ++dictionary[key].\\n\\n```\\npublic int NumEquivDominoPairs(int[][] dominoes)\\n{\\n    var count = 0;\\n    var dictionary = new Dictionary<string, int>();\\n    foreach (var d in dominoes) \\n    {\\n        var key = d[0] < d[1] ? string.Format(\"{0}{1}\", d[0], d[1]) : string.Format(\"{0}{1}\", d[1], d[0]); \\n        if (dictionary.ContainsKey(key)) count += ++dictionary[key]; else dictionary.Add(key, 0);\\n    }\\n    return count;\\n}",
                "solutionTags": [],
                "code": "Key ideas:\\n1. Iterate through dominoes and build a Dictionary (HashMap in Java).\\n2. Form a key from domino values in the same (i.e accending) order so dominoes \\'1:2\\' and \\'2:1\\' will have the same key.\\n3. Count occurences of the key and count number of pairs at the same time.\\n\\nMy initial approach to counting pairs was to count occurences first and then have another iteration through dictionary to calculate pairs.\\nNumber of pairs for N number of occurences is (N-1) + (N-2) + ... + 1 or N*(N-1)/2. \\nThen I realised that pairs can be counted at the same time as occurences, i.e. 1 + 2 + ... + (N-2) + (N-1). \\nSo I started occurences from 0 and count pairs at the same time hence the line: count += ++dictionary[key].\\n\\n```\\npublic int NumEquivDominoPairs(int[][] dominoes)\\n{\\n    var count = 0;\\n    var dictionary = new Dictionary<string, int>();\\n    foreach (var d in dominoes) \\n    {\\n        var key = d[0] < d[1] ? string.Format(\"{0}{1}\", d[0], d[1]) : string.Format(\"{0}{1}\", d[1], d[0]); \\n        if (dictionary.ContainsKey(key)) count += ++dictionary[key]; else dictionary.Add(key, 0);\\n    }\\n    return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 607490,
                "title": "c-solution-with-map",
                "content": "```\\nWe store the pair into hashmap and increment it wheever we encounter this.\\nHow do we store the pair?\\nLet the pair be {a,b} where a store the minimum of the 2 and b stores the maximum of the two.\\n\\nOnce we iterate through the map we our count value will not store n or n-1 nut will store this\\nif n=it->second-1\\ncount+=(n)*(n+1)/2 why?\\nbecause dominoes matching occurs for every domino after it so for example\\n\\n[1,2][1,2][1,2][1,2][2,1][2,1]\\n\\nhere map[{1,2}] = 6\\nbut for the first 1,2 5 are matched with it\\nfor second 1,2 4 are matched with it\\nThus n,n-1,n-2,,,,1 = n*(n+1)/2 (Sum of natural numbers upto n)\\n\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> map;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            int a=min(dominoes[i][0],dominoes[i][1]),b=max(dominoes[i][0],dominoes[i][1]);\\n            map[{a,b}]++;\\n        }\\n        int count=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            if(it->second>1)\\n            {\\n                int n=it->second-1;\\n                count+=(n)*(n+1)/2;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe store the pair into hashmap and increment it wheever we encounter this.\\nHow do we store the pair?\\nLet the pair be {a,b} where a store the minimum of the 2 and b stores the maximum of the two.\\n\\nOnce we iterate through the map we our count value will not store n or n-1 nut will store this\\nif n=it->second-1\\ncount+=(n)*(n+1)/2 why?\\nbecause dominoes matching occurs for every domino after it so for example\\n\\n[1,2][1,2][1,2][1,2][2,1][2,1]\\n\\nhere map[{1,2}] = 6\\nbut for the first 1,2 5 are matched with it\\nfor second 1,2 4 are matched with it\\nThus n,n-1,n-2,,,,1 = n*(n+1)/2 (Sum of natural numbers upto n)\\n\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> map;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            int a=min(dominoes[i][0],dominoes[i][1]),b=max(dominoes[i][0],dominoes[i][1]);\\n            map[{a,b}]++;\\n        }\\n        int count=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            if(it->second>1)\\n            {\\n                int n=it->second-1;\\n                count+=(n)*(n+1)/2;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519357,
                "title": "intuitive-python-solution-with-comments",
                "content": "`dic` keeps track of how many number of _sorted_ pair that we have seen before. For a given domino pair, if we have seen `x` times before that means we can make `x` number of new pairs. We need to sort the domino pair so that we get a consistent key since we don\\'t want to differentiate let say `[1, 2]` & `[2, 1]`.\\n\\n```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for dom in dominoes:\\n            # sort so that we get a consistent key\\n            sdom = tuple(sorted(dom))\\n            \\n            # if we haven\\'t seen it before that means there\\n            # is no pair. if we have seen x number before\\n            # that means we can make x pairs\\n            if sdom in dic:\\n                res += dic[sdom]\\n                \\n            # record that we have seen it\\n            dic[sdom] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for dom in dominoes:\\n            # sort so that we get a consistent key\\n            sdom = tuple(sorted(dom))\\n            \\n            # if we haven\\'t seen it before that means there\\n            # is no pair. if we have seen x number before\\n            # that means we can make x pairs\\n            if sdom in dic:\\n                res += dic[sdom]\\n                \\n            # record that we have seen it\\n            dic[sdom] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087193,
                "title": "java-solution-with-explanation",
                "content": "**Simple String key**\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            String val = item[0] < item[1] ? item[0] + \":\" + item[1] : item[1] + \":\" + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```\\n**for better runtime we make the key as integer**\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            int val = item[0] < item[1] ? item[0] *10 + item[1] : item[1] *10 + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            String val = item[0] < item[1] ? item[0] + \":\" + item[1] : item[1] + \":\" + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            int val = item[0] < item[1] ? item[0] *10 + item[1] : item[1] *10 + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920471,
                "title": "simple-concise-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        map<vector<int>,int> m;\\n        for(auto i:dominoes)\\n        {\\n            sort(i.begin(),i.end());\\n            if(m.find(i)!=m.end()) ans+=m[i]++;\\n            else m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        map<vector<int>,int> m;\\n        for(auto i:dominoes)\\n        {\\n            sort(i.begin(),i.end());\\n            if(m.find(i)!=m.end()) ans+=m[i]++;\\n            else m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491615,
                "title": "java-t-96-56-s-100-array-to-the-rescue",
                "content": "```\\n\\tpublic int numEquivDominoPairs(int[][] d) {\\n        int pairs = 0; // number of pairs\\n        int[][] count = new int[10][10]; // in this scenario better than hashmap\\n        \\n        for(int i=0;i<d.length;i++){\\n            int m = d[i][0];\\n            int n = d[i][1];\\n            \\n            if(m > n){ // if m is bigger than n just swap them to align with similar dominoes\\n                n = d[i][0];\\n                m = d[i][1];\\n            }\\n            \\n            pairs += count[m][n]; // equivalent to doing \\'n(n+1)/2\\' one time for each unique domino \\n            \\n            count[m][n]++; // increase the occurence count\\n        }\\n        \\n        return pairs;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numEquivDominoPairs(int[][] d) {\\n        int pairs = 0; // number of pairs\\n        int[][] count = new int[10][10]; // in this scenario better than hashmap\\n        \\n        for(int i=0;i<d.length;i++){\\n            int m = d[i][0];\\n            int n = d[i][1];\\n            \\n            if(m > n){ // if m is bigger than n just swap them to align with similar dominoes\\n                n = d[i][0];\\n                m = d[i][1];\\n            }\\n            \\n            pairs += count[m][n]; // equivalent to doing \\'n(n+1)/2\\' one time for each unique domino \\n            \\n            count[m][n]++; // increase the occurence count\\n        }\\n        \\n        return pairs;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340012,
                "title": "c-no-sort",
                "content": "No customized sort.\\n\\nSince it\\'s hard (for me) to sort by first element in ascending order then second in ascending order, use a map to count ```freq```. Map will sort in the aforementioned fashion for you.\\n\\nNotice ```freq[make_pair(d[0], d[1])]``` is first added to ```res``` in each round, then self-increment. \\nThis ensures adding ```1, 2, 3...``` respectively in each round.\\n\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> freq;\\n        int res = 0;\\n\\n        for (vector<int> d : dominoes) {\\n            if (d[0] > d[1]) { \\n\\t        // swap elements\\n                d[0] = d[0] + d[1];\\n                d[1] = d[0] - d[1];\\n                d[0] = d[0] - d[1];\\n            }\\n\\n            res += freq[make_pair(d[0], d[1])]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```freq```\n```freq[make_pair(d[0], d[1])]```\n```res```\n```1, 2, 3...```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> freq;\\n        int res = 0;\\n\\n        for (vector<int> d : dominoes) {\\n            if (d[0] > d[1]) { \\n\\t        // swap elements\\n                d[0] = d[0] + d[1];\\n                d[1] = d[0] - d[1];\\n                d[0] = d[0] - d[1];\\n            }\\n\\n            res += freq[make_pair(d[0], d[1])]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309741,
                "title": "python-simple-hashmap",
                "content": "\\n    def numEquivDominoPairs(self, dominoes):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i, j in dominoes:\\n            min_val = min(i, j)\\n            max_val = max(i, j)\\n            dict1[(min_val, max_val)] += 1\\n            \\n        for i in dict1:\\n            total += dict1[i]*(dict1[i]-1)//2\\n            \\n        return total",
                "solutionTags": [],
                "code": "\\n    def numEquivDominoPairs(self, dominoes):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i, j in dominoes:\\n            min_val = min(i, j)\\n            max_val = max(i, j)\\n            dict1[(min_val, max_val)] += 1\\n            \\n        for i in dict1:\\n            total += dict1[i]*(dict1[i]-1)//2\\n            \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 1176876,
                "title": "java-by-using-only-array-faster-than-82-89-memory-used-less-than-76-11-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int cn =0;\\n        \\n        int[][] n = new int[10][10];\\n        \\n      \\n        \\n        for(int i = 0 ; i< dominoes.length ; i++){\\n            \\n            if(dominoes[i][0] < dominoes[i][1]){\\n                int t= dominoes[i][0];\\n                dominoes[i][0] = dominoes[i][1];\\n                dominoes[i][1] = t ;\\n            }\\n            \\n            cn = cn +   n[dominoes[i][0]][dominoes[i][1]];\\n            n[dominoes[i][0]][dominoes[i][1]] ++;\\n            \\n        }\\n        \\n       \\n            \\n        return cn;\\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int cn =0;\\n        \\n        int[][] n = new int[10][10];\\n        \\n      \\n        \\n        for(int i = 0 ; i< dominoes.length ; i++){\\n            \\n            if(dominoes[i][0] < dominoes[i][1]){\\n                int t= dominoes[i][0];\\n                dominoes[i][0] = dominoes[i][1];\\n                dominoes[i][1] = t ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1174121,
                "title": "java-array-hashing-beats-99-10-2ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(dominoes.length) O(1)\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\n\\t\\tint len = dominoes.length, count = 0;\\n\\t\\tint[] map = new int[91];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint[] domino = dominoes[i];\\n\\t\\t\\tint hash1 = 9 * domino[0] + domino[1], hash2 = 9 * domino[1] + domino[0];\\n\\t\\t\\tcount += map[hash1];\\n\\t\\t\\tcount += (hash1 != hash2) ? map[hash2] : 0;\\n\\t\\t\\tmap[hash1]++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(dominoes.length) O(1)\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\n\\t\\tint len = dominoes.length, count = 0;\\n\\t\\tint[] map = new int[91];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint[] domino = dominoes[i];\\n\\t\\t\\tint hash1 = 9 * domino[0] + domino[1], hash2 = 9 * domino[1] + domino[0];\\n\\t\\t\\tcount += map[hash1];\\n\\t\\t\\tcount += (hash1 != hash2) ? map[hash2] : 0;\\n\\t\\t\\tmap[hash1]++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 982936,
                "title": "python-o-n-beats-97-37-dictionary-combinatorial-number",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        num_dic = collections.defaultdict(int)\\n        n = len(dominoes)\\n        for i in range(n):\\n\\t\\t# make dominoe like [1, 2] and [2, 1] become the same\\n            a, b = sorted(dominoes[i])\\n            num_dic[(a, b)] += 1\\n        pairs = 0\\n        for k, v in num_dic.items():\\n\\t\\t# number of equivalents in dictionary\\n            if v >= 2:\\n\\t\\t\\t# formula of comtinational number, C(2, n) = n(n-1)/2. For example, item a, b, c could form three combinations of two: (a, b), (a, c), (b, c)\\n                pairs += (v * (v-1))//2\\n        return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        num_dic = collections.defaultdict(int)\\n        n = len(dominoes)\\n        for i in range(n):\\n\\t\\t# make dominoe like [1, 2] and [2, 1] become the same\\n            a, b = sorted(dominoes[i])\\n            num_dic[(a, b)] += 1\\n        pairs = 0\\n        for k, v in num_dic.items():\\n\\t\\t# number of equivalents in dictionary\\n            if v >= 2:\\n\\t\\t\\t# formula of comtinational number, C(2, n) = n(n-1)/2. For example, item a, b, c could form three combinations of two: (a, b), (a, c), (b, c)\\n                pairs += (v * (v-1))//2\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819546,
                "title": "javascript-solution-with-object",
                "content": "```\\nvar sum = 0;\\n  var obj = {};\\n  dominoes.map((x) => {\\n    var cha = x.sort((a, b) => a - b).join(\"\");\\n    if (obj.hasOwnProperty(cha)) {\\n      sum += obj[cha];\\n      obj[cha]++;\\n    } else {\\n      obj[cha] = 1;\\n    }\\n  });\\n  return sum;\\n  \\n  ES6:\\n  var numEquivDominoPairs = function (dominoes) {\\n    const dic = {};\\n    let pairs = 0;\\n    dominoes.map((domi) => {\\n        domi.sort((a, b) => a - b);\\n        dic[domi] ? ((pairs += dic[domi]), dic[domi]++) : (dic[domi] = 1);\\n    });\\n    return pairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sum = 0;\\n  var obj = {};\\n  dominoes.map((x) => {\\n    var cha = x.sort((a, b) => a - b).join(\"\");\\n    if (obj.hasOwnProperty(cha)) {\\n      sum += obj[cha];\\n      obj[cha]++;\\n    } else {\\n      obj[cha] = 1;\\n    }\\n  });\\n  return sum;\\n  \\n  ES6:\\n  var numEquivDominoPairs = function (dominoes) {\\n    const dic = {};\\n    let pairs = 0;\\n    dominoes.map((domi) => {\\n        domi.sort((a, b) => a - b);\\n        dic[domi] ? ((pairs += dic[domi]), dic[domi]++) : (dic[domi] = 1);\\n    });\\n    return pairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597640,
                "title": "python-3-use-dictionary",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        mydic={}\\n        for ele in dominoes:\\n            if ele[0]<=ele[1]:\\n                a=tuple(ele)\\n            else:\\n                a=tuple(ele[::-1])\\n            if a in mydic:\\n                mydic[a]+=1\\n            else:\\n                mydic[a]=1\\n        count=0\\n        for k, v in mydic.items():\\n            if v>1:\\n                count+=v*(v-1)//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        mydic={}\\n        for ele in dominoes:\\n            if ele[0]<=ele[1]:\\n                a=tuple(ele)\\n            else:\\n                a=tuple(ele[::-1])\\n            if a in mydic:\\n                mydic[a]+=1\\n            else:\\n                mydic[a]=1\\n        count=0\\n        for k, v in mydic.items():\\n            if v>1:\\n                count+=v*(v-1)//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510614,
                "title": "simple-java-with-hasmap",
                "content": "```\\nclass Solution {\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> dic = new HashMap<>();\\n        int res = 0;\\n        for(int[] domino : dominoes) {\\n            int val = domino[0] < domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n            int count = dic.getOrDefault(val,0);\\n            dic.put(val, count + 1);\\n            res = res + count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> dic = new HashMap<>();\\n        int res = 0;\\n        for(int[] domino : dominoes) {\\n            int val = domino[0] < domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n            int count = dic.getOrDefault(val,0);\\n            dic.put(val, count + 1);\\n            res = res + count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360111,
                "title": "linear-time-linear-space",
                "content": "```\\n\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<String, Integer> domGroup = new HashMap<>();\\n        int totalPairs = 0; // Solution\\n        \\n        for (int[] dominoe: dominoes){\\n            int smallest = dominoe[0] < dominoe[1] ? dominoe[0] : dominoe[1];\\n            int largest = dominoe[1] > dominoe[0] ? dominoe[1] : dominoe[0];\\n            String key = smallest + \"#\" + largest;\\n            domGroup.put(key, domGroup.getOrDefault(key, 0) + 1);\\n        }\\n        \\n        for (String key: domGroup.keySet()){\\n            int count = domGroup.get(key);\\n            totalPairs += (count*(count-1)) / 2;\\n        }\\n        \\n        return totalPairs;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<String, Integer> domGroup = new HashMap<>();\\n        int totalPairs = 0; // Solution\\n        \\n        for (int[] dominoe: dominoes){\\n            int smallest = dominoe[0] < dominoe[1] ? dominoe[0] : dominoe[1];\\n            int largest = dominoe[1] > dominoe[0] ? dominoe[1] : dominoe[0];\\n            String key = smallest + \"#\" + largest;\\n            domGroup.put(key, domGroup.getOrDefault(key, 0) + 1);\\n        }\\n        \\n        for (String key: domGroup.keySet()){\\n            int count = domGroup.get(key);\\n            totalPairs += (count*(count-1)) / 2;\\n        }\\n        \\n        return totalPairs;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483730,
                "title": "java-2-approaches-counting-with-array-counting-with-hashmap",
                "content": "### Counting With Array\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }\\n\\n        return pairsCount;\\n    }\\n}\\n```\\n### Counting With HashMap\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int pairsCountSum = 0;\\n        Map<Integer, Integer> pairsCount = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n\\n            int num = up * 10 + down;\\n            if (!pairsCount.containsKey(num)) {\\n                pairsCount.put(num, 1);\\n            } else {\\n                pairsCountSum += pairsCount.get(num);\\n                pairsCount.put(num, pairsCount.get(num) + 1);\\n            }\\n        }\\n\\n        return pairsCountSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }\\n\\n        return pairsCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int pairsCountSum = 0;\\n        Map<Integer, Integer> pairsCount = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n\\n            int num = up * 10 + down;\\n            if (!pairsCount.containsKey(num)) {\\n                pairsCount.put(num, 1);\\n            } else {\\n                pairsCountSum += pairsCount.get(num);\\n                pairsCount.put(num, pairsCount.get(num) + 1);\\n            }\\n        }\\n\\n        return pairsCountSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598466,
                "title": "hashmap-c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto &x : dominoes) {\\n            int key = 0;\\n            key = key | (1 << x[0]);\\n            key = key | (1 << x[1]);\\n            if(mp.count(key))\\n                ans += mp[key];\\n            mp[key]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto &x : dominoes) {\\n            int key = 0;\\n            key = key | (1 << x[0]);\\n            key = key | (1 << x[1]);\\n            if(mp.count(key))\\n                ans += mp[key];\\n            mp[key]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561757,
                "title": "java-solution-using-hashmap",
                "content": "Step 1 : swap the dominoes[i]->(a,b) according to which one is smaller\\nStep 2 : Creating hashMap with key as a*10+b and value as the number of occurences of (a,b)\\nStep 3 : Counting the values of hashmap which are greater than 1\\nStep 4 : By combination theorem nCr = n!/(n-r)!*r! \\n            here we have to find out the number of pairs we get so n is the value of key and r is 2 as we are            considering pairs\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]>dominoes[i][1])\\n            {\\n                int tmp=dominoes[i][1];\\n                dominoes[i][1]=dominoes[i][0];\\n                dominoes[i][0]=tmp;\\n            }\\n        }\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(hm.get(dominoes[i][0]*10+dominoes[i][1])==null)\\n            {\\n                hm.put(dominoes[i][0]*10+dominoes[i][1],1);\\n            }\\n            else hm.put(dominoes[i][0]*10+dominoes[i][1],hm.get(dominoes[i][0]*10+dominoes[i][1])+1);\\n            \\n        }\\n        System.out.println(hm);\\n        for(Map.Entry<Integer,Integer>e:hm.entrySet())\\n        {\\n            int k=e.getValue();\\n            if(k>1)c+=((k*(k-1))/2);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]>dominoes[i][1])\\n            {\\n                int tmp=dominoes[i][1];\\n                dominoes[i][1]=dominoes[i][0];\\n                dominoes[i][0]=tmp;\\n            }\\n        }\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(hm.get(dominoes[i][0]*10+dominoes[i][1])==null)\\n            {\\n                hm.put(dominoes[i][0]*10+dominoes[i][1],1);\\n            }\\n            else hm.put(dominoes[i][0]*10+dominoes[i][1],hm.get(dominoes[i][0]*10+dominoes[i][1])+1);\\n            \\n        }\\n        System.out.println(hm);\\n        for(Map.Entry<Integer,Integer>e:hm.entrySet())\\n        {\\n            int k=e.getValue();\\n            if(k>1)c+=((k*(k-1))/2);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459029,
                "title": "go-without-hashmap-o-n",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    res, cache := 0, make([][]int, 10)\\n    \\n    for i := 0; i < 10; i++ {\\n        cache[i] = make([]int, 10)\\n    }\\n    \\n    for i := 0; i < len(dominoes); i++ {\\n        begin, end := dominoes[i][0], dominoes[i][1]\\n        \\n        res += cache[begin][end]\\n        \\n        if begin != end {\\n            res += cache[end][begin]\\n        }\\n        \\n        \\n        cache[begin][end]++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    res, cache := 0, make([][]int, 10)\\n    \\n    for i := 0; i < 10; i++ {\\n        cache[i] = make([]int, 10)\\n    }\\n    \\n    for i := 0; i < len(dominoes); i++ {\\n        begin, end := dominoes[i][0], dominoes[i][1]\\n        \\n        res += cache[begin][end]\\n        \\n        if begin != end {\\n            res += cache[end][begin]\\n        }\\n        \\n        \\n        cache[begin][end]++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330705,
                "title": "simple-c-nlog-n-soln-and-o-1-space",
                "content": "```\\nint numEquivDominoPairs(vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++){\\n            if(d[i][0]>d[i][1]) swap(d[i][0],d[i][1]);\\n        }\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(int i=0;i<d.size();){\\n            int j=i+1;\\n            while(j<d.size()&&d[j]==d[i]) j++;\\n            if(j==i+1){\\n                i=j;\\n                continue;\\n            }\\n            ans+=(j-i)*(j-i-1)/2;\\n            i=j;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint numEquivDominoPairs(vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++){\\n            if(d[i][0]>d[i][1]) swap(d[i][0],d[i][1]);\\n        }\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(int i=0;i<d.size();){\\n            int j=i+1;\\n            while(j<d.size()&&d[j]==d[i]) j++;\\n            if(j==i+1){\\n                i=j;\\n                continue;\\n            }\\n            ans+=(j-i)*(j-i-1)/2;\\n            i=j;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1643791,
                "title": "java-2ms-100-one-pass-dp-w-arrhash-just-5-lines-thinking-process",
                "content": "Because there are a lot of reoccuring identical domino, 1 scan to hash and another scan over the hash array / map is the first that came to mind. However, we can improve upon this with the principle of Dynamic Programming, with every new identical domino found, there are **\"1 + valid count that ends with previous identical domino\"** We can then count as we loop through the array for the first time, meaing <ins>*1 for loop should suffice*</ins>.\\n\\nWith that in mind, then, we have to come up with a way to group all the identical dominos together. One quick observation is that **those with identical max and min number in the domino are identical, regardless of how the min and max are arranged**, and then next observation is that the number can only go up to 9 at most according to the problem constraint. Hence, we duduce that the HashID of each domino is then <ins>`10 * max + min`</ins>. And this number can only go up to 99 at most. Domino with the same HashID are identical as laid out by this problem. We will utilize an array with size 100 to handle the counting aspect of it. \\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] count = new int[100];\\n        int ans = 0;\\n        for (int[] d : dominoes)\\n            if (++count[hash(d)] > 1) //increment count and if it is >= 2, then\\n                ans += count[hash(d)] - 1; //we add to the ans (remember to -1 because single 1 domino isn\\'t a pair)\\n        return ans;\\n    }\\n\\n    private static int hash(int[] d){ //domino with the same id are the same.\\n        return 10 * Math.max(d[0], d[1]) + Math.min(d[0], d[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] count = new int[100];\\n        int ans = 0;\\n        for (int[] d : dominoes)\\n            if (++count[hash(d)] > 1) //increment count and if it is >= 2, then\\n                ans += count[hash(d)] - 1; //we add to the ans (remember to -1 because single 1 domino isn\\'t a pair)\\n        return ans;\\n    }\\n\\n    private static int hash(int[] d){ //domino with the same id are the same.\\n        return 10 * Math.max(d[0], d[1]) + Math.min(d[0], d[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607621,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int count=0;\\n        map<vector<int>,int>m;\\n        for(int i=0;i<dominoes.size();i++) {\\n            vector<int>aux=dominoes[i];\\n            // sort the pair and store in the hashmap\\n            if(aux[0]>aux[1]) {\\n                swap(aux[0],aux[1]);\\n            }\\n            m[aux]++;\\n        }\\n        for(auto it:m) {\\n            if(it.second>1) {\\n                // so if for any domino we\\'ve \\'n\\' instances then we can make nC2 equivalent pair from them..\\n                int n=it.second;\\n                count+=((n*(n-1))/2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int count=0;\\n        map<vector<int>,int>m;\\n        for(int i=0;i<dominoes.size();i++) {\\n            vector<int>aux=dominoes[i];\\n            // sort the pair and store in the hashmap\\n            if(aux[0]>aux[1]) {\\n                swap(aux[0],aux[1]);\\n            }\\n            m[aux]++;\\n        }\\n        for(auto it:m) {\\n            if(it.second>1) {\\n                // so if for any domino we\\'ve \\'n\\' instances then we can make nC2 equivalent pair from them..\\n                int n=it.second;\\n                count+=((n*(n-1))/2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564329,
                "title": "c-easy-solution-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes)\\n    {\\n        map<pair<int, int>, int> mp;\\n        int ans = 0;\\n        for (const auto &i : dominoes)\\n        {\\n            //checking in map and updating \\'ans\\' variable\\n            if (i[0] < i[1])  ans += mp[{i[0], i[1]}];\\n            else  ans += mp[{i[1], i[0]}];\\n            \\n            //updation of map based on small value first and large value second\\n            if (i[0] < i[1])  ++mp[{i[0], i[1]}];\\n            else  ++mp[{i[1], i[0]}];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes)\\n    {\\n        map<pair<int, int>, int> mp;\\n        int ans = 0;\\n        for (const auto &i : dominoes)\\n        {\\n            //checking in map and updating \\'ans\\' variable\\n            if (i[0] < i[1])  ans += mp[{i[0], i[1]}];\\n            else  ans += mp[{i[1], i[0]}];\\n            \\n            //updation of map based on small value first and large value second\\n            if (i[0] < i[1])  ++mp[{i[0], i[1]}];\\n            else  ++mp[{i[1], i[0]}];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514590,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum(v*(v-1)//2 for v in collections.Counter([min(a,b)*10+max(a,b) for a,b in dominoes]).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum(v*(v-1)//2 for v in collections.Counter([min(a,b)*10+max(a,b) for a,b in dominoes]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452251,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int>m;\\n        int ret=0;\\n        for(auto i:dominoes) {\\n            if(i[0]>i[1]) {\\n                m[{i[1],i[0]}]++;\\n            }\\n            else m[{i[0],i[1]}]++;\\n        }\\n        for(auto i:m) {\\n            ret+=i.second*(i.second-1)/2;\\n        }\\n        return ret;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int>m;\\n        int ret=0;\\n        for(auto i:dominoes) {\\n            if(i[0]>i[1]) {\\n                m[{i[1],i[0]}]++;\\n            }\\n            else m[{i[0],i[1]}]++;\\n        }\\n        for(auto i:m) {\\n            ret+=i.second*(i.second-1)/2;\\n        }\\n        return ret;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405532,
                "title": "c-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        \\n        for(auto &vec : dominoes) {\\n            if(vec[0] > vec[1])\\n                swap(vec[0], vec[1]); //so that we get {2, 1} and {1, 2} counted together\\n            mp[{vec[0], vec[1]}]++;\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto &it : mp) {\\n            int val = it.second;\\n            count += val*(val-1)/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        \\n        for(auto &vec : dominoes) {\\n            if(vec[0] > vec[1])\\n                swap(vec[0], vec[1]); //so that we get {2, 1} and {1, 2} counted together\\n            mp[{vec[0], vec[1]}]++;\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto &it : mp) {\\n            int val = it.second;\\n            count += val*(val-1)/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318549,
                "title": "java-approach-using-10x10-grid-o-n-time-o-1-space",
                "content": "[https://github.com/2018hsridhar/Leetcode_Solutions/blob/master/leetcode_1128.java](http://)\\n```\\n/*\\n1128. Number of Equivalent Domino Pairs\\nURL = https://leetcode.com/problems/number-of-equivalent-domino-pairs/\\n\\nThought process : \\n1. Summation of dominoe values - [1,12] here : but can have multiple sums too, so take note of that\\n-> Gets problematic with middle summations though\\n\\n\\n2. Let us generation sums maps\\n\\n2 => [1,1]\\n3 => [1,2], [2,1] \\n4 => [1,3], [3,1], [2,2]\\n5 => [1,4],[4,1],[2,3],[4,3]\\n6 => [1,5],[5,1],[2,4][4,2],[3,3] \\n\\nIdea #2 : sort and compare to previous elements ( after a global sort operation )?\\n\\nA lot of dominos are possible here\\nDomino values are reasonable too : [1,9] only\\n\\nComputational complexity :\\n\\nPairwise comparisons : O(N^2) due to N(N-1)/2 unique number of domino pairings here\\nSpace Complexity, with pairwise comparison approach = O(1) though ... may run into a RLE error\\n\\nEdge case testing  :\\n\\nUse an matrix instead of a hashmap approach, and add indices as we go? Is a 9x9 only!\\n\\n\\n*/\\n\\nclass Solution\\n{\\n    public int numEquivDominoPairs(int[][] dominoes) \\n    {\\n        int numPairs = 0;\\n        int[][] matrix = new int[10][10];\\n        for(int i = 0; i < matrix.length; ++i)\\n            for(int j = 0; j < matrix[0].length; ++j)\\n                matrix[i][j] = 0;\\n        \\n        for(int i = 0; i < dominoes.length; ++i)\\n        {\\n            int[] domino = dominoes[i];\\n            int x = domino[0];\\n            int y = domino[1];\\n            ++matrix[x][y];\\n        }\\n        \\n        // Iterate over upper triangle only\\n        for(int i = 0; i < 10; ++i)\\n        {\\n            for(int j = i; j < 10; ++j)\\n            {\\n                int dominoCount = matrix[i][j];\\n                if(i != j)\\n                    dominoCount += matrix[j][i];\\n                numPairs += (dominoCount*(dominoCount - 1) / 2); // n choose 2 type of thing now!\\n            }\\n        }\\n        return numPairs;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution\\n{\\n    public int numEquivDominoPairs(int[][] dominoes) \\n    {\\n        int numPairs = 0;\\n        int[][] matrix = new int[10][10];\\n        for(int i = 0; i < matrix.length; ++i)\\n            for(int j = 0; j < matrix[0].length; ++j)\\n                matrix[i][j] = 0;\\n        \\n        for(int i = 0; i < dominoes.length; ++i)\\n        {\\n            int[] domino = dominoes[i];\\n            int x = domino[0];\\n            int y = domino[1];\\n            ++matrix[x][y];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1211473,
                "title": "c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tmap< pair<int,int>,int>mp;\\n\\t\\t\\tfor(auto  &p:dominoes){\\n\\t\\t\\t\\tint x=p[0];\\n\\t\\t\\t\\tint y=p[1];\\n\\t\\t\\t\\tif(x>y)swap(x,y);\\n\\t\\t\\t\\tmp[{x,y}]++;\\n\\t\\t\\t}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(auto &p :mp){\\n\\t\\t\\t\\tif(p.second>=2){\\n\\t\\t\\t\\t\\tint n=p.second;\\n\\t\\t\\t\\t\\tcnt+= (n*(n-1))/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tmap< pair<int,int>,int>mp;\\n\\t\\t\\tfor(auto  &p:dominoes){\\n\\t\\t\\t\\tint x=p[0];\\n\\t\\t\\t\\tint y=p[1];\\n\\t\\t\\t\\tif(x>y)swap(x,y);\\n\\t\\t\\t\\tmp[{x,y}",
                "codeTag": "Java"
            },
            {
                "id": 1147918,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] arr) {\\n        Map<List<Integer>,Integer> map = new HashMap<>();\\n        int ans =0;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> list = new LinkedList<>();\\n            if(arr[i][0] > arr[i][1])\\n            {\\n                list.add(arr[i][0]);\\n                list.add(arr[i][1]);\\n            }\\n            else {\\n                list.add(arr[i][1]);\\n                list.add(arr[i][0]);\\n            }\\n            if(map.containsKey(list)){\\n                map.replace(list,1+map.get(list));\\n                ans += map.get(list);\\n            }\\n            else map.put(list,0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if you find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] arr) {\\n        Map<List<Integer>,Integer> map = new HashMap<>();\\n        int ans =0;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> list = new LinkedList<>();\\n            if(arr[i][0] > arr[i][1])\\n            {\\n                list.add(arr[i][0]);\\n                list.add(arr[i][1]);\\n            }\\n            else {\\n                list.add(arr[i][1]);\\n                list.add(arr[i][0]);\\n            }\\n            if(map.containsKey(list)){\\n                map.replace(list,1+map.get(list));\\n                ans += map.get(list);\\n            }\\n            else map.put(list,0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029486,
                "title": "python-solution",
                "content": "\\th, result = {}, 0\\n\\tfor domino in dominoes:\\n\\t\\ts = tuple(sorted(domino))\\n\\t\\th[s] = h.get(s, 0) + 1\\n\\tfor val in h.values():\\n\\t\\tif val > 1:\\n\\t\\t\\tresult += val * (val - 1) / 2\\n\\treturn result",
                "solutionTags": [],
                "code": "\\th, result = {}, 0\\n\\tfor domino in dominoes:\\n\\t\\ts = tuple(sorted(domino))\\n\\t\\th[s] = h.get(s, 0) + 1\\n\\tfor val in h.values():\\n\\t\\tif val > 1:\\n\\t\\t\\tresult += val * (val - 1) / 2\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 839014,
                "title": "rust-cleaner-rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count = HashMap::new();\\n        for d in dominoes {\\n            let d = (d[0].min(d[1]), d[0].max(d[1]));\\n            *count.entry(d).or_insert(0) += 1;\\n        }\\n        count.values().map(|c| (c * (c - 1)) / 2).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count = HashMap::new();\\n        for d in dominoes {\\n            let d = (d[0].min(d[1]), d[0].max(d[1]));\\n            *count.entry(d).or_insert(0) += 1;\\n        }\\n        count.values().map(|c| (c * (c - 1)) / 2).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589387,
                "title": "c-faster-than-100-less-than-100-mem-o-n",
                "content": "```\\npublic int NumEquivDominoPairs(int[][] dominoes) {\\n     Dictionary<int, int> numbers = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < dominoes.Length; i++)\\n            {\\n                int key = 0;\\n\\n                if (dominoes[i][0] <= dominoes[i][1])\\n                {\\n                    key = dominoes[i][0] * 10 + dominoes[i][1];\\n                }\\n                else\\n                {\\n                    key = dominoes[i][1] * 10 + dominoes[i][0];\\n                }\\n\\n                if (numbers.TryGetValue(key, out var s))\\n                {\\n                    numbers[key] += 1;\\n                }\\n                else numbers.Add(key, 1);\\n            }\\n            return numbers.Values.Sum(e => e*(e - 1)/2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumEquivDominoPairs(int[][] dominoes) {\\n     Dictionary<int, int> numbers = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < dominoes.Length; i++)\\n            {\\n                int key = 0;\\n\\n                if (dominoes[i][0] <= dominoes[i][1])\\n                {\\n                    key = dominoes[i][0] * 10 + dominoes[i][1];\\n                }\\n                else\\n                {\\n                    key = dominoes[i][1] * 10 + dominoes[i][0];\\n                }\\n\\n                if (numbers.TryGetValue(key, out var s))\\n                {\\n                    numbers[key] += 1;\\n                }\\n                else numbers.Add(key, 1);\\n            }\\n            return numbers.Values.Sum(e => e*(e - 1)/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487328,
                "title": "python-frozenset-1-liner",
                "content": "As the order of a domino\\'s numbers doesn\\'t matter, we should regard dominos as sets. To use a `Counter`, we need them hashable, so we use `frozenset`.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, D):\\n        return sum(d*(d-1)/2 for d in Counter(map(frozenset, D)).values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, D):\\n        return sum(d*(d-1)/2 for d in Counter(map(frozenset, D)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484568,
                "title": "java-solution",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        int count = 0;\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int[] dominoe : dominoes){\\n            int small = Math.min(dominoe[0], dominoe[1]);\\n            int large = Math.max(dominoe[0], dominoe[1]);\\n            String key = small + \"$\" + large;\\n            count += map.getOrDefault(key,0);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        int count = 0;\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int[] dominoe : dominoes){\\n            int small = Math.min(dominoe[0], dominoe[1]);\\n            int large = Math.max(dominoe[0], dominoe[1]);\\n            String key = small + \"$\" + large;\\n            count += map.getOrDefault(key,0);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417112,
                "title": "python-3-two-solutions-one-pass-99-38-two-pass-98-03",
                "content": "Method 1 (one pass) (beating 99.38%)\\n1) loop through `dominoes`\\n2) at each domino pair, add the number of equivalent domino pairs observed so far to answer and add count of equivalent domino pairs by 1;\\n3) return the anser.\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            if x > y: x, y = y, x\\n            key = 10*x + y\\n            ans += freq[key]\\n            freq[key] += 1\\n        return ans \\n```\\nMethod 2 (two pass) (beating 98.03%)\\n1) pass-1, count occurrence of each equivalent domino pair;\\n2) pass-2, loop through the counts and compute 1 + ... + v-1 using formula;\\n3) return the sum \\n4) \\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for x, y in dominoes:\\n            if x > y: x, y = y, x\\n            freq[10*x + y] += 1\\n        return sum(v*(v-1)//2 for v in freq.values())\\n```\\n\\nA two-line version of method 2 is below. \\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        count = Counter((lambda x,y: 10*x+y)(*sorted(d)) for d in dominoes)\\n        return sum(v*(v-1)//2 for v in count.values())\\n```\\n\\nEdited on 4/20/2021 \\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            ans += freq[x, y]\\n            if x != y: ans += freq[y, x]\\n            freq[x, y] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            if x > y: x, y = y, x\\n            key = 10*x + y\\n            ans += freq[key]\\n            freq[key] += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for x, y in dominoes:\\n            if x > y: x, y = y, x\\n            freq[10*x + y] += 1\\n        return sum(v*(v-1)//2 for v in freq.values())\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        count = Counter((lambda x,y: 10*x+y)(*sorted(d)) for d in dominoes)\\n        return sum(v*(v-1)//2 for v in count.values())\\n```\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            ans += freq[x, y]\\n            if x != y: ans += freq[y, x]\\n            freq[x, y] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 389413,
                "title": "simple-c-solution",
                "content": "```\\nint cmpfunc (const void * a, const void * b)\\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\nint numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int cnt=1,total=0;\\n    int *arr=malloc(sizeof(int)*dominoesSize);\\n    for(int i=0;i<dominoesSize;i++)\\n    {\\n        if(dominoes[i][0]<dominoes[i][1])\\n            arr[i]=dominoes[i][0]*10+dominoes[i][1];\\n        else\\n            arr[i]=dominoes[i][1]*10+dominoes[i][0];\\n    }\\n    qsort(arr, dominoesSize, sizeof(int), cmpfunc);\\n    for(int i=0;i<dominoesSize-1;i++)\\n    {\\n        while(i+1<dominoesSize&&arr[i]==arr[i+1])\\n        {\\n            //printf(\"%d \",arr[i]);\\n            cnt++;\\n            i++;\\n        }\\n        total+=cnt*(cnt-1)/2;\\n        cnt=1;\\n    }\\n    return total;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint cmpfunc (const void * a, const void * b)\\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\nint numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int cnt=1,total=0;\\n    int *arr=malloc(sizeof(int)*dominoesSize);\\n    for(int i=0;i<dominoesSize;i++)\\n    {\\n        if(dominoes[i][0]<dominoes[i][1])\\n            arr[i]=dominoes[i][0]*10+dominoes[i][1];\\n        else\\n            arr[i]=dominoes[i][1]*10+dominoes[i][0];\\n    }\\n    qsort(arr, dominoesSize, sizeof(int), cmpfunc);\\n    for(int i=0;i<dominoesSize-1;i++)\\n    {\\n        while(i+1<dominoesSize&&arr[i]==arr[i+1])\\n        {\\n            //printf(\"%d \",arr[i]);\\n            cnt++;\\n            i++;\\n        }\\n        total+=cnt*(cnt-1)/2;\\n        cnt=1;\\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375987,
                "title": "c-easy-solution-map-free-counting-combination-problem-beats-95-92-100",
                "content": "At first, count all the dominoes and initialize the 9x9 matrix, which had already been initialized with zeros, with the counted values.\\nIt is possible because of the second constraint that tells us the range of the values [1-9].\\nFor example, a domino numbered [1, 1] increases the value of matrix[0][0].\\n\\nNext, think about the possible cases.\\n(1) i == j (diagonal)\\n\\t- consider only 1 sub-case\\n(2) i != j\\n\\t- consider 3 sub-cases\\n\\nFinally, let\\'s count the number of answers.\\ncase (1):\\n\\nIf we have 6 for the matrix[0][0], the problem could be counted as drawing two balls from the pocket which has 6 balls numbered as index of [0][0] numbered domino.\\nIn this sense, 6C2 = 6 * 5 / 2 * 1 = 15 (answers) can be computed. (because swap doesn\\'t have any meanings, so the two conditions, (a==c and b==d), or (a==d and b==c), are counted as one..)\\n\\ncase(2):\\n\\nsub-case #1: matrix[i][j]\\nSAME AS case(1)\\n\\nsub-case #2: matrix[j][i]\\nSAME AS case(1)\\n\\nsub-case #3: matrix[i][j] and matrix[j][j] (*remind (a==c and b==d), or (a==d and b==c))\\n\\nIn this case, the problem could be counted as drawing two balls from two pockets which has matrix[i][j], matrix[j][i] balls each.\\n\\nSUM UP ALL THE ANSWERS FROM case(1) and case (2), then you can get the final result.\\n\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int mat[9][9] = {0,};\\n        int result = 0;\\n        \\n        // init matrix\\n        for(unsigned int i = 0; i < dominoes.size(); i++){\\n            mat[dominoes[i][0] - 1][dominoes[i][1] - 1]++;\\n        }\\n        \\n        // search till diagonal element\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j <= i; j++){\\n\\t\\t\\t\\t// diagonal element case\\n                if(i==j){\\n                    if(mat[i][j] > 1)\\n                       result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// only from [i, j] cases \\n                    if(mat[i][j] > 1)\\n                        result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                    // only from [j, i] cases\\n                    if(mat[j][i] > 1)    \\n                        result += (mat[j][i] * (mat[j][i] - 1)) / 2; // combination\\n                    // from both\\n                    result += (mat[i][j] * mat[j][i]); // permutation\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nTHANK YOU.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int mat[9][9] = {0,};\\n        int result = 0;\\n        \\n        // init matrix\\n        for(unsigned int i = 0; i < dominoes.size(); i++){\\n            mat[dominoes[i][0] - 1][dominoes[i][1] - 1]++;\\n        }\\n        \\n        // search till diagonal element\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j <= i; j++){\\n\\t\\t\\t\\t// diagonal element case\\n                if(i==j){\\n                    if(mat[i][j] > 1)\\n                       result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// only from [i, j] cases \\n                    if(mat[i][j] > 1)\\n                        result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                    // only from [j, i] cases\\n                    if(mat[j][i] > 1)    \\n                        result += (mat[j][i] * (mat[j][i] - 1)) / 2; // combination\\n                    // from both\\n                    result += (mat[i][j] * mat[j][i]); // permutation\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354445,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        if not dominoes:\\n            return 0\\n        res = 0\\n        help_map = {}\\n        for x, y in dominoes:\\n            if x > y:\\n                x, y = y, x\\n            temp = (x, y)\\n            if temp in help_map:\\n                res += help_map[temp]\\n                help_map[temp] += 1\\n            else:\\n                help_map[temp] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        if not dominoes:\\n            return 0\\n        res = 0\\n        help_map = {}\\n        for x, y in dominoes:\\n            if x > y:\\n                x, y = y, x\\n            temp = (x, y)\\n            if temp in help_map:\\n                res += help_map[temp]\\n                help_map[temp] += 1\\n            else:\\n                help_map[temp] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340894,
                "title": "js-o-n-time-and-o-1-space",
                "content": "```\\nconst numEquivDominoPairs = dominoes => {\\n    let occur = Array.from(Array(10), () => Array(10).fill(0));\\n    \\n    for (let [a, b] of dominoes) {\\n        let min = Math.min(a, b);\\n        let max = Math.max(a, b);\\n        \\n        occur[min][max] += 1;\\n    }\\n    \\n    let cnt = 0;\\n    for (let i = 0; i <= 9; i++) {\\n        for (let j = 0; j <= 9; j++) {\\n            let o = Math.max(0, occur[i][j] - 1);        \\n            cnt += (o * (o + 1)) / 2;\\n        }\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numEquivDominoPairs = dominoes => {\\n    let occur = Array.from(Array(10), () => Array(10).fill(0));\\n    \\n    for (let [a, b] of dominoes) {\\n        let min = Math.min(a, b);\\n        let max = Math.max(a, b);\\n        \\n        occur[min][max] += 1;\\n    }\\n    \\n    let cnt = 0;\\n    for (let i = 0; i <= 9; i++) {\\n        for (let j = 0; j <= 9; j++) {\\n            let o = Math.max(0, occur[i][j] - 1);        \\n            cnt += (o * (o + 1)) / 2;\\n        }\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340372,
                "title": "javascript-solution-with-explanation",
                "content": "2 steps:\\n1. create a hashmap to record how many times each domino appears\\n2. if n dominos (n>1), how many combinations can they make? use `n*(n-1)/2)`\\n\\n```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = {};\\n    dominoes.forEach(p => {\\n        const [s,b] = p.sort();\\n        const n = s*10 + b;\\n        if(!map[n]) map[n] = 0;\\n        map[n]++;\\n    });\\n    \\n    return Object.values(map).reduce((res, ct) => res += ct>1 ? ct*(ct-1)/2 : 0, 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = {};\\n    dominoes.forEach(p => {\\n        const [s,b] = p.sort();\\n        const n = s*10 + b;\\n        if(!map[n]) map[n] = 0;\\n        map[n]++;\\n    });\\n    \\n    return Object.values(map).reduce((res, ct) => res += ct>1 ? ct*(ct-1)/2 : 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340322,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            StringBuilder sb = new StringBuilder();\\n            if (domino[0] < domino[1]) {\\n                sb.append(domino[0] + \",\" + domino[1]);\\n            } else {\\n                sb.append(domino[1] + \",\" + domino[0]);\\n            }\\n            if (map.containsKey(sb.toString())) res += map.get(sb.toString());\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            StringBuilder sb = new StringBuilder();\\n            if (domino[0] < domino[1]) {\\n                sb.append(domino[0] + \",\" + domino[1]);\\n            } else {\\n                sb.append(domino[1] + \",\" + domino[0]);\\n            }\\n            if (map.containsKey(sb.toString())) res += map.get(sb.toString());\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340009,
                "title": "java-simple-with-combination",
                "content": "1) To make unique key and avoid dublication with keys \\nhave done this\\n`(Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]))`\\n2) To get all Combination of Domino \\n` n!(r!(n\\u2212r)!)`\\nsince our r =2 always\\n`n*(n-1)/2`\\n\\n\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n\\t\\tfor(int[] d : dominoes){\\n\\t\\t\\tlong key = (Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]));\\n\\t\\t\\tif(!map.containsKey(key)){\\n\\t\\t\\t\\tmap.put(key, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(key, map.get(key) + 1);\\n\\t\\t}\\n\\t\\tint ret = 0;\\n\\t\\tfor(int v : map.values()){\\n\\t\\t\\tret += v*(v-1)/2;\\n\\t\\t}\\n\\t\\treturn ret;",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "1) To make unique key and avoid dublication with keys \\nhave done this\\n`(Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]))`\\n2) To get all Combination of Domino \\n` n!(r!(n\\u2212r)!)`\\nsince our r =2 always\\n`n*(n-1)/2`\\n\\n\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n\\t\\tfor(int[] d : dominoes){\\n\\t\\t\\tlong key = (Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]));\\n\\t\\t\\tif(!map.containsKey(key)){\\n\\t\\t\\t\\tmap.put(key, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(key, map.get(key) + 1);\\n\\t\\t}\\n\\t\\tint ret = 0;\\n\\t\\tfor(int v : map.values()){\\n\\t\\t\\tret += v*(v-1)/2;\\n\\t\\t}\\n\\t\\treturn ret;",
                "codeTag": "Unknown"
            },
            {
                "id": 3959061,
                "title": "2328-ms-in-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863991,
                "title": "java-solution-without-using-hashing-direct-solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n       for(int i=0;i<dominoes.length-1;i++){\\n           int one=dominoes[i][0];\\n           int second=dominoes[i][1];\\n           for(int j=i+1;j<dominoes.length;j++){\\n               int check1=dominoes[j][0];\\n               int check2=dominoes[j][1];\\n               if(one==check1){\\n                   if(second==check2){\\n                       count+=1;\\n                   }\\n               }\\n               else if(one==check2){\\n                   if(second==check1){\\n                       count+=1;\\n                   }\\n               }\\n           }\\n       }\\nreturn count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n       for(int i=0;i<dominoes.length-1;i++){\\n           int one=dominoes[i][0];\\n           int second=dominoes[i][1];\\n           for(int j=i+1;j<dominoes.length;j++){\\n               int check1=dominoes[j][0];\\n               int check2=dominoes[j][1];\\n               if(one==check1){\\n                   if(second==check2){\\n                       count+=1;\\n                   }\\n               }\\n               else if(one==check2){\\n                   if(second==check1){\\n                       count+=1;\\n                   }\\n               }\\n           }\\n       }\\nreturn count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788589,
                "title": "easy-c-solution-hash-table-approach-with-explanation-beats-90-in-both",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        for (auto& d : dominoes) {\\n            if (d[0] > d[1]) \\n                swap(d[0], d[1]); // We swap the numbers so that [1,2] and [2,1] can be counted together as [1,2]\\n            mp[{d[0], d[1]}]++;\\n        }\\n        int ans = 0;\\n        for (auto& m : mp)\\n            ans += m.second * (m.second - 1) / 2; // Formula for sum of first n-1 numbers\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        for (auto& d : dominoes) {\\n            if (d[0] > d[1]) \\n                swap(d[0], d[1]); // We swap the numbers so that [1,2] and [2,1] can be counted together as [1,2]\\n            mp[{d[0], d[1]}]++;\\n        }\\n        int ans = 0;\\n        for (auto& m : mp)\\n            ans += m.second * (m.second - 1) / 2; // Formula for sum of first n-1 numbers\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621111,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096524,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641954,
                "title": "js-very-easy-solution-o-n-with-hashmap",
                "content": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2499940,
                "title": "c-solution-using-map",
                "content": "\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int , int> , int > m;\\n        int cnt = 0;\\n        for(vector v : dominoes){\\n            int a = v[0] ,b = v[1];\\n            if(a > b) swap(a , b);\\n            if(m[{a , b}]) cnt += m[{a , b}];\\n            m[{a , b}]++;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int , int> , int > m;\\n        int cnt = 0;\\n        for(vector v : dominoes){\\n            int a = v[0] ,b = v[1];\\n            if(a > b) swap(a , b);\\n            if(m[{a , b}]) cnt += m[{a , b}];\\n            m[{a , b}]++;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191418,
                "title": "easy-to-uderstand-brute-force-c",
                "content": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0;\\n       for(int i=0;i<dominoes.size();i++)\\n           sort(dominoes[i].begin(),dominoes[i].end());\\n        map<vector<int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n            m[dominoes[i]]++;\\n        for(auto x:m)\\n            result+=x.second*(x.second-1)/2;\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0;\\n       for(int i=0;i<dominoes.size();i++)\\n           sort(dominoes[i].begin(),dominoes[i].end());\\n        map<vector<int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n            m[dominoes[i]]++;\\n        for(auto x:m)\\n            result+=x.second*(x.second-1)/2;\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2176290,
                "title": "o-n-time-o-1-space-python-easy",
                "content": "since l is 9*9 array only 81 bit space used\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        l=[[0]*9 for _ in range(10)]\\n        c=0\\n        for i in dominoes:\\n            if(i[0]<i[1]):\\n                c+=l[i[0]-1][i[1]-1]\\n                l[i[0]-1][i[1]-1]+=1\\n            else:\\n                c+=l[i[1]-1][i[0]-1]\\n                l[i[1]-1][i[0]-1]+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        l=[[0]*9 for _ in range(10)]\\n        c=0\\n        for i in dominoes:\\n            if(i[0]<i[1]):\\n                c+=l[i[0]-1][i[1]-1]\\n                l[i[0]-1][i[1]-1]+=1\\n            else:\\n                c+=l[i[1]-1][i[0]-1]\\n                l[i[1]-1][i[0]-1]+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158866,
                "title": "simple-python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            #Just to make everything equal and comparable\\n            if(tuple(i) in d.keys()):   #In python, lists are unhashable so converted the list into tuples\\n                d[tuple(i)]+=1\\n            else:\\n                d[tuple(i)]=1\\n        count=0\\n        for x,y in d.items():\\n            if(y>1):\\n\\t\\t\\t\\tcount+=y*(y-1)//2        #To check the number of pairs, if 2 elements pairs is 1,if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\\n        return count\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            #Just to make everything equal and comparable\\n            if(tuple(i) in d.keys()):   #In python, lists are unhashable so converted the list into tuples\\n                d[tuple(i)]+=1\\n            else:\\n                d[tuple(i)]=1\\n        count=0\\n        for x,y in d.items():\\n            if(y>1):\\n\\t\\t\\t\\tcount+=y*(y-1)//2        #To check the number of pairs, if 2 elements pairs is 1,if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\\n        return count\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136036,
                "title": "c-solution-based-on-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> records;\\n        for (int i = 0; i < dominoes.size(); i++){\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            if (records.count({a, b}) == 0){\\n                records.insert({{a, b}, 1});\\n            }\\n            else{\\n                records[{a, b}]++;\\n            }\\n        }\\n        int result = 0;\\n        for (auto it=records.begin(); it!=records.end(); it++){\\n            // it->second\\n            int n = it->second;\\n            result += (n - 1) * n / 2;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> records;\\n        for (int i = 0; i < dominoes.size(); i++){\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            if (records.count({a, b}) == 0){\\n                records.insert({{a, b}, 1});\\n            }\\n            else{\\n                records[{a, b}]++;\\n            }\\n        }\\n        int result = 0;\\n        for (auto it=records.begin(); it!=records.end(); it++){\\n            // it->second\\n            int n = it->second;\\n            result += (n - 1) * n / 2;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081480,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] mat = new int[9][9];\\n        \\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]!=dominoes[i][1])\\n            {\\n            mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            mat[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n            }\\n            else\\n            {\\n                mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=i;j<9;j++)\\n            {\\n                c+=sum(mat[i][j]-1);\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    private int sum(int n)\\n    {\\n       return (n*(n+1))/2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] mat = new int[9][9];\\n        \\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]!=dominoes[i][1])\\n            {\\n            mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            mat[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2013314,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bef0b639-52a1-49f5-9ba5-72db5f7e41c7_1651830320.6071334.png)\\n\\n\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        d = collections.Counter(map(frozenset, dominoes))\\n        return sum(math.comb(v, 2) for v in d.values())",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bef0b639-52a1-49f5-9ba5-72db5f7e41c7_1651830320.6071334.png)\\n\\n\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        d = collections.Counter(map(frozenset, dominoes))\\n        return sum(math.comb(v, 2) for v in d.values())",
                "codeTag": "Python3"
            },
            {
                "id": 2001242,
                "title": "java-5-lines-of-code-faster-than-99-19",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tint[] counts = new int[100];\\n\\tint ans = 0;\\n\\tfor (int[] d : dominoes)\\n\\t\\tans += counts[Math.min(d[0], d[1])*10 + Math.max(d[0], d[1])]++;\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tint[] counts = new int[100];\\n\\tint ans = 0;\\n\\tfor (int[] d : dominoes)\\n\\t\\tans += counts[Math.min(d[0], d[1])*10 + Math.max(d[0], d[1])]++;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937753,
                "title": "c",
                "content": "```\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        List<string> temp = new List<string>();\\n\\n        for(int i=0; i< dominoes.Length; i++)\\n        {\\n            Array.Sort(dominoes[i]);\\n            temp.Add(string.Join(\"\", dominoes[i]));\\n        }\\n\\n        return temp.GroupBy(x => x).Where(x => x.Count() != 1).Select( x=>x.Count() * (x.Count() - 1) / 2 ).Sum();\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        List<string> temp = new List<string>();\\n\\n        for(int i=0; i< dominoes.Length; i++)\\n        {\\n            Array.Sort(dominoes[i]);\\n            temp.Add(string.Join(\"\", dominoes[i]));\\n        }\\n\\n        return temp.GroupBy(x => x).Where(x => x.Count() != 1).Select( x=>x.Count() * (x.Count() - 1) / 2 ).Sum();\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1901650,
                "title": "java-2ms-math-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Brute force cannot be used because of the set size.\\n        2. Traverse the dominos and group & count them by min-max value.\\n           As pieces can be from 1 to 9, means their groups will be from 11 to 99.\\n            eg: [1,2] will be the same as [2,1]. Their value is 10 * (min(1,2)) + max(1,2)\\n                => 10 * 1 + 2 = 12.\\n            so pieces[12]++;\\n        3. After finishing traversing, iterate over the counted pieces and if the count is\\n          > 1, calculate the combinations of X by 2.\\n        4. The formula is n!/ (k! * (n-k)!)\\n           As n! can be very large, use the short version of it; (n * (n-1)) / 2. EG n= 40\\n           Eg:  40!         simplify this(divide by 38!) 39 * 40\\n              --------                                  ---------   \\n               2! * (38!)                                   2\\n        5. Return the total result      \\n    */\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] pieces = new int[100];\\n        for (int[] domino : dominoes) {\\n            pieces[10 * Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1])]++;\\n        }\\n        int pairs = 0;\\n        for (int i = 11; i <= 99; i++) {\\n            if (pieces[i] > 1) {\\n                pairs += getCombinations(pieces[i]);\\n            }\\n        }\\n        \\n        return pairs;    \\n    }\\n    \\n    private int getCombinations(int n) {\\n        return (n * (n-1)) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Brute force cannot be used because of the set size.\\n        2. Traverse the dominos and group & count them by min-max value.\\n           As pieces can be from 1 to 9, means their groups will be from 11 to 99.\\n            eg: [1,2] will be the same as [2,1]. Their value is 10 * (min(1,2)) + max(1,2)\\n                => 10 * 1 + 2 = 12.\\n            so pieces[12]++;\\n        3. After finishing traversing, iterate over the counted pieces and if the count is\\n          > 1, calculate the combinations of X by 2.\\n        4. The formula is n!/ (k! * (n-k)!)\\n           As n! can be very large, use the short version of it; (n * (n-1)) / 2. EG n= 40\\n           Eg:  40!         simplify this(divide by 38!) 39 * 40\\n              --------                                  ---------   \\n               2! * (38!)                                   2\\n        5. Return the total result      \\n    */\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] pieces = new int[100];\\n        for (int[] domino : dominoes) {\\n            pieces[10 * Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1])]++;\\n        }\\n        int pairs = 0;\\n        for (int i = 11; i <= 99; i++) {\\n            if (pieces[i] > 1) {\\n                pairs += getCombinations(pieces[i]);\\n            }\\n        }\\n        \\n        return pairs;    \\n    }\\n    \\n    private int getCombinations(int n) {\\n        return (n * (n-1)) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881671,
                "title": "c-java-dictionary-hashmap-solution",
                "content": "**Implementation**\\n* C#\\n```\\npublic class Solution {\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        if(dominoes == null || dominoes.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int res = 0;\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n\\n        foreach(var pair in dominoes)\\n        {\\n            string key = Math.Min(pair[0], pair[1]) + \"-\" + Math.Max(pair[0], pair[1]);  \\n            int cnt = dic.GetValueOrDefault(key,0);\\n            res += cnt;\\n            dic[key] = cnt + 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n* Java\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<String,Integer> map = new HashMap<String,Integer>();\\n        \\n        int res = 0; \\n        for(var pair : dominoes)\\n        {\\n            String key = Math.min(pair[0], pair[1]) + \"-\" + Math.max(pair[0], pair[1]);  \\n            int cnt = map.getOrDefault(key, 0);\\n            res += cnt;\\n            map.put(key, cnt + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        if(dominoes == null || dominoes.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int res = 0;\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n\\n        foreach(var pair in dominoes)\\n        {\\n            string key = Math.Min(pair[0], pair[1]) + \"-\" + Math.Max(pair[0], pair[1]);  \\n            int cnt = dic.GetValueOrDefault(key,0);\\n            res += cnt;\\n            dic[key] = cnt + 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<String,Integer> map = new HashMap<String,Integer>();\\n        \\n        int res = 0; \\n        for(var pair : dominoes)\\n        {\\n            String key = Math.min(pair[0], pair[1]) + \"-\" + Math.max(pair[0], pair[1]);  \\n            int cnt = map.getOrDefault(key, 0);\\n            res += cnt;\\n            map.put(key, cnt + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833075,
                "title": "faster-than-89-memory-usage-less-than-90-c-solution",
                "content": "```\\n int numEquivDominoPairs(vector<vector<int>>& d) {\\n        map<pair<int,int>,int> m;\\n        map<pair<int,int>,int>::iterator itr;\\n        int c=0;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            pair<int,int> p;\\n           p.first=min(d[i][0],d[i][1]);\\n            p.second=max(d[i][1],d[i][0]);\\n            m[p]++;\\n                \\n        }\\n        for(itr=m.begin();itr!=m.end();itr++)\\n        {\\n            int n=itr->second*(itr->second-1);\\n            n=n/2;\\n            c+=n;\\n        }\\n        return c;\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int numEquivDominoPairs(vector<vector<int>>& d) {\\n        map<pair<int,int>,int> m;\\n        map<pair<int,int>,int>::iterator itr;\\n        int c=0;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            pair<int,int> p;\\n           p.first=min(d[i][0],d[i][1]);\\n            p.second=max(d[i][1],d[i][0]);\\n            m[p]++;\\n                \\n        }\\n        for(itr=m.begin();itr!=m.end();itr++)\\n        {\\n            int n=itr->second*(itr->second-1);\\n            n=n/2;\\n            c+=n;\\n        }\\n        return c;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811069,
                "title": "3-lines-python-solution-75-faster-memory-less-than-60",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counter = defaultdict(int)\\n        for domino in dominoes: counter[tuple(sorted(domino))] +=1\\n        return sum([n*(n-1)//2 for n in counter.values()])\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counter = defaultdict(int)\\n        for domino in dominoes: counter[tuple(sorted(domino))] +=1\\n        return sum([n*(n-1)//2 for n in counter.values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759360,
                "title": "java-3-liner-hashing-explained",
                "content": "**Idea:** Sort the dominoes and count the number of pairs using nC2 formula = n(n - 1) / 2\\n>**T/S:** O(n)/O(n), where n = size(dominoes)\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tfor (var domino : dominoes)\\n\\t\\tdominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t  (k, v) -> v == null ? 1 : v + 1);\\n\\tvar pairs = 0;\\n\\tfor (var count : dominoToCount.values())\\n\\t\\tpairs += count * (count - 1) / 2;\\n\\treturn pairs;\\n}\\n```\\n**Version 2:** 3 liner stream version\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tArrays.stream(dominoes)\\n\\t\\t  .forEach(domino -> dominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (k, v) -> v == null ? 1 : v + 1));\\n\\treturn dominoToCount.values()\\n\\t\\t\\t\\t\\t\\t.stream()\\n\\t\\t\\t\\t\\t\\t.mapToInt(v -> v * (v - 1) / 2)\\n\\t\\t\\t\\t\\t\\t.sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tfor (var domino : dominoes)\\n\\t\\tdominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t  (k, v) -> v == null ? 1 : v + 1);\\n\\tvar pairs = 0;\\n\\tfor (var count : dominoToCount.values())\\n\\t\\tpairs += count * (count - 1) / 2;\\n\\treturn pairs;\\n}\\n```\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tArrays.stream(dominoes)\\n\\t\\t  .forEach(domino -> dominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (k, v) -> v == null ? 1 : v + 1));\\n\\treturn dominoToCount.values()\\n\\t\\t\\t\\t\\t\\t.stream()\\n\\t\\t\\t\\t\\t\\t.mapToInt(v -> v * (v - 1) / 2)\\n\\t\\t\\t\\t\\t\\t.sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1722329,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<vector<int>,int> freq;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> ele=d[i];\\n            if(ele[0]<ele[1])\\n            {\\n                swap(ele[0],ele[1]);\\n            }\\n            freq[ele]++;\\n        }\\n        int ans=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second>1)\\n            {\\n                int x=pr.second;\\n                ans+=(x*(x-1)/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<vector<int>,int> freq;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> ele=d[i];\\n            if(ele[0]<ele[1])\\n            {\\n                swap(ele[0],ele[1]);\\n            }\\n            freq[ele]++;\\n        }\\n        int ans=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second>1)\\n            {\\n                int x=pr.second;\\n                ans+=(x*(x-1)/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578746,
                "title": "c-90-time-91-space-map-sum-of-natural-numbers",
                "content": "```\\nint sum(int n){\\n\\treturn (n * (n+1)) / 2;\\n}\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& arr) {\\n        map<pair<int,int>,int>m;\\n        int summation=0;\\n        for(int i=0;i<arr.size();i++){\\n         \\n            int a=min(arr[i][0],arr[i][1]);\\n            int b=max(arr[i][0],arr[i][1]);\\n           m[{a,b}]++;  \\n        }\\n        for(auto i:m){\\n            summation+=sum(i.second-1);\\n        }\\n        return summation;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint sum(int n){\\n\\treturn (n * (n+1)) / 2;\\n}\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& arr) {\\n        map<pair<int,int>,int>m;\\n        int summation=0;\\n        for(int i=0;i<arr.size();i++){\\n         \\n            int a=min(arr[i][0],arr[i][1]);\\n            int b=max(arr[i][0],arr[i][1]);\\n           m[{a,b}]++;  \\n        }\\n        for(auto i:m){\\n            summation+=sum(i.second-1);\\n        }\\n        return summation;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532449,
                "title": "java-explained-2-solutions-o-n-hashmap-explained",
                "content": "Solution 1 : TLE\\n// TC: O(m * m), where m is dominoes.length\\n```\\n class Solution {\\n     public int numEquivDominoPairs(int[][] dominoes) {\\n         int res = 0;\\n        \\n         for(int i = 0; i < dominoes.length - 1; i++) {\\n             for(int j = i + 1; j < dominoes.length; j++) {\\n                 int[] dominoe1 = dominoes[i];\\n                 int[] dominoe2 = dominoes[j];\\n                \\n                 if(dominoe1[0] == dominoe2[0] && dominoe1[1] == dominoe2[1] || dominoe1[0] == dominoe2[1] && dominoe1[1] == dominoe2[0]) {\\n                     res++;\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\\n\\nSolution 2: \\n// TC: O(m), where m is dominoes.length\\n// SC: O(100), since max value can be 9, so max number that can be formed is 99\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // this contains the number formed from each elements of a dominoe and its freq (num formed meaning, if domino[i] = [1,2], then we form number 12 ( min(donimoe[0], dominoe[1]) * 10 + max(donimoe[0], dominoe[1])) ) \\n                                                    // we are forming a number like this because we are interested in dominoes where either a == c && b == d OR a == d && b == c (so [1,2] & [2,1] will both form 12 as a number and then freq would be 2 for 12)\\n        \\n        for(int[] dominoe : dominoes) { // read all dominoe from dominoes and form the number out of its values and place in map and find freq of such numbers formed\\n            int number = Math.min(dominoe[0], dominoe[1]) * 10 + Math.max(dominoe[0], dominoe[1]);\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        \\n        for(int value : map.values()) {\\n            res += value * (value - 1)/2; // n(n-1)/2 find the total combinations from N elements\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n     public int numEquivDominoPairs(int[][] dominoes) {\\n         int res = 0;\\n        \\n         for(int i = 0; i < dominoes.length - 1; i++) {\\n             for(int j = i + 1; j < dominoes.length; j++) {\\n                 int[] dominoe1 = dominoes[i];\\n                 int[] dominoe2 = dominoes[j];\\n                \\n                 if(dominoe1[0] == dominoe2[0] && dominoe1[1] == dominoe2[1] || dominoe1[0] == dominoe2[1] && dominoe1[1] == dominoe2[0]) {\\n                     res++;\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // this contains the number formed from each elements of a dominoe and its freq (num formed meaning, if domino[i] = [1,2], then we form number 12 ( min(donimoe[0], dominoe[1]) * 10 + max(donimoe[0], dominoe[1])) ) \\n                                                    // we are forming a number like this because we are interested in dominoes where either a == c && b == d OR a == d && b == c (so [1,2] & [2,1] will both form 12 as a number and then freq would be 2 for 12)\\n        \\n        for(int[] dominoe : dominoes) { // read all dominoe from dominoes and form the number out of its values and place in map and find freq of such numbers formed\\n            int number = Math.min(dominoe[0], dominoe[1]) * 10 + Math.max(dominoe[0], dominoe[1]);\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        \\n        for(int value : map.values()) {\\n            res += value * (value - 1)/2; // n(n-1)/2 find the total combinations from N elements\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517620,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut table = [[0; 9]; 9];\\n        let combinations = |n: i32| -> i32 { (n - 1) * n / 2 };\\n\\n        // construct an upper triangular matrix\\n        dominoes.iter().for_each(|d| {\\n            let (row, col) = match (d[0] - 1, d[1] - 1) {\\n                (a, b) if a < b => (a, b),\\n                (a, b) => (b, a),\\n            };\\n            table[row as usize][col as usize] += 1;\\n        });\\n\\n        // check the elements above the main diagonal of the matrix\\n        for (start_col, row) in table.iter().enumerate() {\\n            for &num in row[start_col..].iter().filter(|&&num| num > 1) {\\n                res += combinations(num);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Combinatorics"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut table = [[0; 9]; 9];\\n        let combinations = |n: i32| -> i32 { (n - 1) * n / 2 };\\n\\n        // construct an upper triangular matrix\\n        dominoes.iter().for_each(|d| {\\n            let (row, col) = match (d[0] - 1, d[1] - 1) {\\n                (a, b) if a < b => (a, b),\\n                (a, b) => (b, a),\\n            };\\n            table[row as usize][col as usize] += 1;\\n        });\\n\\n        // check the elements above the main diagonal of the matrix\\n        for (start_col, row) in table.iter().enumerate() {\\n            for &num in row[start_col..].iter().filter(|&&num| num > 1) {\\n                res += combinations(num);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439836,
                "title": "python3-nice-hack-to-use-dictionary-faster-than-94",
                "content": "![image](https://assets.leetcode.com/users/images/1095d3ee-7b9e-4bc0-b904-5647a5754eec_1630555519.8157907.png)\\n\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        d, c = dict(), 0\\n        for i in dominoes:\\n            if i[0] > i[1]:\\n                i[0], i[1] = i[1], i[0]\\n\\n            if (i[0], i[1]) not in d:\\n                d[(i[0], i[1])] = 1\\n            else:\\n                d[(i[0], i[1])] += 1\\n\\n        for j in d:\\n            if d[j] > 1:\\n                c += d[j] * (d[j] - 1) // 2\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        d, c = dict(), 0\\n        for i in dominoes:\\n            if i[0] > i[1]:\\n                i[0], i[1] = i[1], i[0]\\n\\n            if (i[0], i[1]) not in d:\\n                d[(i[0], i[1])] = 1\\n            else:\\n                d[(i[0], i[1])] += 1\\n\\n        for j in d:\\n            if d[j] > 1:\\n                c += d[j] * (d[j] - 1) // 2\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408737,
                "title": "python-beats-97-simple",
                "content": "Just count how many pairs, then and add them. During counting, make sure swap the smaller one as first.\\n\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        pairs = defaultdict(int)\\n        for i, j in dominoes:\\n            s = (i, j) if i <= j else (j, i)\\n            pairs[s] += 1\\n        \\n        ans = 0\\n        for pair in pairs:\\n            if pairs[pair] > 1:\\n                ans += (pairs[pair] * (pairs[pair] - 1)) // 2\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        pairs = defaultdict(int)\\n        for i, j in dominoes:\\n            s = (i, j) if i <= j else (j, i)\\n            pairs[s] += 1\\n        \\n        ans = 0\\n        for pair in pairs:\\n            if pairs[pair] > 1:\\n                ans += (pairs[pair] * (pairs[pair] - 1)) // 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386655,
                "title": "faster-than-97-python",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        t = [tuple(sorted(x)) for x in dominoes ]\\n        dic = dict(collections.Counter(t))\\n        count = 0\\n        for key in dic :\\n            count += (dic[key]-1)*(dic[key])//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        t = [tuple(sorted(x)) for x in dominoes ]\\n        dic = dict(collections.Counter(t))\\n        count = 0\\n        for key in dic :\\n            count += (dic[key]-1)*(dic[key])//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383642,
                "title": "java-solution-beats-97-runtime",
                "content": "We use the fact that the dominoes have values in the set [1,9] and create a 2-dimensional array to store all dominoes that we find (making sure that we add values both directions - *corner case*: indices need to be different so that we don\\'t count a domino twice). For example, a domino (1,2) we will increase the values in our matrix at indexes (1,2) and (2,1). \\n\\nAfter passing through all dominoes, we use all values above the first diagonal and calculate a Gauss sum for each element. For example, if the value in the matrix is 5, that means that we found 5 identical dominoes, and that makes the a total of (4 * 5 / 2 = 10) identical pairs.  \\n\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\t// I used len 10 so that I don\\'t have to use mat[pair[0]-1,pair[1]-1]\\n        int len = 10;\\n        int[][] mat = new int[len][len];\\n        int count = 0;\\n        for (int[] pair: dominoes) {\\n            mat[pair[0]][pair[1]]++;\\n            if (pair[0] != pair[1])\\n                mat[pair[1]][pair[0]]++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i; j < len; j++) {\\n                int current = mat[i][j];\\n                count += (current * (current - 1)) / 2;\\n            }\\n        } \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\t// I used len 10 so that I don\\'t have to use mat[pair[0]-1,pair[1]-1]\\n        int len = 10;\\n        int[][] mat = new int[len][len];\\n        int count = 0;\\n        for (int[] pair: dominoes) {\\n            mat[pair[0]][pair[1]]++;\\n            if (pair[0] != pair[1])\\n                mat[pair[1]][pair[0]]++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i; j < len; j++) {\\n                int current = mat[i][j];\\n                count += (current * (current - 1)) / 2;\\n            }\\n        } \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355610,
                "title": "go",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    dict := make(map[[2]int]int)\\n    for _, v := range dominoes {\\n        if v[0] <= v[1] {\\n            dict[[2]int{v[0], v[1]}]++\\n        } else {\\n            dict[[2]int{v[1], v[0]}]++\\n        }\\n    }\\n    res := 0\\n    for _, v := range dict {\\n        res += v * (v - 1) / 2\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    dict := make(map[[2]int]int)\\n    for _, v := range dominoes {\\n        if v[0] <= v[1] {\\n            dict[[2]int{v[0], v[1]}]++\\n        } else {\\n            dict[[2]int{v[1], v[0]}]++\\n        }\\n    }\\n    res := 0\\n    for _, v := range dict {\\n        res += v * (v - 1) / 2\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301280,
                "title": "java-solution-bitwise",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tMap<Integer, Integer> m = new HashMap<>();\\n\\tint n = dominoes.length;\\n\\tint c = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint mask = 0;\\n\\t\\tmask |= 1 << dominoes[i][0];\\n\\t\\tmask |= 1 << dominoes[i][1];\\n\\t\\tif (!m.containsKey(mask)) {\\n\\t\\t\\tm.put(mask, 1);\\n\\t\\t} else {\\n\\t\\t\\tc += m.get(mask);\\n\\t\\t\\tm.put(mask, m.get(mask) + 1);\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tMap<Integer, Integer> m = new HashMap<>();\\n\\tint n = dominoes.length;\\n\\tint c = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint mask = 0;\\n\\t\\tmask |= 1 << dominoes[i][0];\\n\\t\\tmask |= 1 << dominoes[i][1];\\n\\t\\tif (!m.containsKey(mask)) {\\n\\t\\t\\tm.put(mask, 1);\\n\\t\\t} else {\\n\\t\\t\\tc += m.get(mask);\\n\\t\\t\\tm.put(mask, m.get(mask) + 1);\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266661,
                "title": "using-hashmaps-and-swapping-c",
                "content": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> mp;\\n        for(int i = 0; i<dominoes.size(); i++){\\n            if(dominoes[i][0]>dominoes[i][1]){\\n                swap(dominoes[i][0],dominoes[i][1]);\\n            }\\n        }\\n        for(int i = 0; i<dominoes.size(); i++){\\n            mp[{dominoes[i][0],dominoes[i][1]}]++;\\n        }\\n        int answer = 0;\\n        \\n        for(auto i:mp){\\n            int n = i.second;\\n            answer+= (n*(n-1))/2;\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\nFor any doubts, i will respond in comment section",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> mp;\\n        for(int i = 0; i<dominoes.size(); i++){\\n            if(dominoes[i][0]>dominoes[i][1]){\\n                swap(dominoes[i][0],dominoes[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1215378,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes   )\\n    {\\n       vector<vector<int> >vec(10,vector<int>(10,0));\\n       int ans=0;\\n       for(int i=0;i<dominoes.size();i++)\\n       {\\n           if(dominoes[i][0]<dominoes[i][1])\\n           {\\n               ans+=vec[dominoes[i][0]][dominoes[i][1]]++;\\n           }\\n           else\\n           {\\n                ans+=vec[dominoes[i][1]][dominoes[i][0]]++;\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes   )\\n    {\\n       vector<vector<int> >vec(10,vector<int>(10,0));\\n       int ans=0;\\n       for(int i=0;i<dominoes.size();i++)\\n       {\\n           if(dominoes[i][0]<dominoes[i][1])\\n           {\\n               ans+=vec[dominoes[i][0]][dominoes[i][1]]++;\\n           }\\n           else\\n           {\\n                ans+=vec[dominoes[i][1]][dominoes[i][0]]++;\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190899,
                "title": "a-very-simple-code-using-find-function-in-map-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tint n=dominoes.size();\\n\\t\\t\\tmap<pair<int,int>,int>mp;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint first=min(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tint second=max(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tif(mp.find({first,second})!=mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount+=mp[{first,second}];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmp[{first,second}]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tint n=dominoes.size();\\n\\t\\t\\tmap<pair<int,int>,int>mp;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint first=min(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tint second=max(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tif(mp.find({first,second}",
                "codeTag": "Java"
            },
            {
                "id": 1177977,
                "title": "c-99-faster-easy-simple",
                "content": "```class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        vector < int > arr(100,0);\\n        for(int i=0 ; i < dominoes.size();i++)\\n            arr[min(dominoes[i][0]*10+dominoes[i][1],dominoes[i][1]*10+dominoes[i][0])]++;\\n        int ans=0;\\n        for(int  i = 11 ; i < 100 ; i++)\\n        {\\n            if(arr[i]>1)\\n                ans=ans+arr[i]*(arr[i]-1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        vector < int > arr(100,0);\\n        for(int i=0 ; i < dominoes.size();i++)\\n            arr[min(dominoes[i][0]*10+dominoes[i][1],dominoes[i][1]*10+dominoes[i][0])]++;\\n        int ans=0;\\n        for(int  i = 11 ; i < 100 ; i++)\\n        {\\n            if(arr[i]>1)\\n                ans=ans+arr[i]*(arr[i]-1)/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1131593,
                "title": "optimized-and-very-easy-c-implementation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int c,ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            mat[mn][mx]++;\\n        }\\n        \\n        for(int i=1;i<10;i++){\\n            for(int j=i;j<10;j++){\\n                c = mat[i][j];\\n                ans+= c*(c-1)/2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n};\\n\\n\\nMore Optimized:\\n```\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            ans += mat[mn][mx]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int c,ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            mat[mn][mx]++;\\n        }\\n        \\n        for(int i=1;i<10;i++){\\n            for(int j=i;j<10;j++){\\n                c = mat[i][j];\\n                ans+= c*(c-1)/2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            ans += mat[mn][mx]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067503,
                "title": "python3-228ms-beating-93-70",
                "content": "I\\'m pretty sure this is optimal; I had three successive runs with difference of 4ms that made a big difference to the runtime percentile ranking:\\n\\n* 236 ms, faster than 78.18% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n* 232 ms, faster than 87.12% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n* 228 ms, faster than 93.70% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n\\nSo, I feel like I\\'m fighting leetcode noise, rather than the problem, now. \\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = collections.Counter(tuple(sorted(domino)) for domino in dominoes)\\n        return sum(c * (c-1) // 2 for c in counts.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = collections.Counter(tuple(sorted(domino)) for domino in dominoes)\\n        return sum(c * (c-1) // 2 for c in counts.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062742,
                "title": "python3-easy-o-n",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for p in dominoes:\\n            t = (min(p[0], p[1]), max(p[0], p[1]))\\n            if t in d:\\n                d[t] += 1\\n            else:\\n                d[t] = 1\\n        ans = 0\\n        for t in d:\\n            if d[t] > 1:\\n                ans += d[t]*(d[t]-1)//2\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for p in dominoes:\\n            t = (min(p[0], p[1]), max(p[0], p[1]))\\n            if t in d:\\n                d[t] += 1\\n            else:\\n                d[t] = 1\\n        ans = 0\\n        for t in d:\\n            if d[t] > 1:\\n                ans += d[t]*(d[t]-1)//2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052313,
                "title": "golang-brute-force-solution",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tcounter := 0\\n\\tfor i := 0; i < len(dominoes); i++ {\\n\\t\\tfor j := i + 1; j < len(dominoes); j++ {\\n\\t\\t\\tif (dominoes[i][0] == dominoes[j][0] && dominoes[i][1] == dominoes[j][1]) || \\n\\t\\t\\t\\t(dominoes[i][1] == dominoes[j][0] && dominoes[i][0] == dominoes[j][1]) {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tcounter := 0\\n\\tfor i := 0; i < len(dominoes); i++ {\\n\\t\\tfor j := i + 1; j < len(dominoes); j++ {\\n\\t\\t\\tif (dominoes[i][0] == dominoes[j][0] && dominoes[i][1] == dominoes[j][1]) || \\n\\t\\t\\t\\t(dominoes[i][1] == dominoes[j][0] && dominoes[i][0] == dominoes[j][1]) {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035877,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        for(int i = 0; i < dominoes.size(); i++)\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n        sort(dominoes.begin(), dominoes.end());\\n        dominoes.push_back({0,0});\\n        int res = 0;\\n        int cnt = 1;\\n        vector<int> curr = dominoes[0];\\n        for(int i = 1; i < dominoes.size(); i++)\\n        {\\n            if(dominoes[i] == curr)\\n                cnt++;\\n            else\\n            {\\n                res += cnt * (cnt - 1);\\n                curr = dominoes[i];\\n                cnt = 1;\\n            }\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        for(int i = 0; i < dominoes.size(); i++)\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n        sort(dominoes.begin(), dominoes.end());\\n        dominoes.push_back({0,0});\\n        int res = 0;\\n        int cnt = 1;\\n        vector<int> curr = dominoes[0];\\n        for(int i = 1; i < dominoes.size(); i++)\\n        {\\n            if(dominoes[i] == curr)\\n                cnt++;\\n            else\\n            {\\n                res += cnt * (cnt - 1);\\n                curr = dominoes[i];\\n                cnt = 1;\\n            }\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996225,
                "title": "java-beats-98-5-simple-20-lines-using-arrays-only",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        if (dominoes.length < 2) return 0;\\n        \\n        int[][] res = new int[10][10];\\n        \\n        int tCount=0,x,y,x1,y1;\\n            \\n        for (int i=0;i<dominoes.length;i++) {\\n            x = dominoes[i][0];\\n            y = dominoes[i][1];\\n            \\n            x1 = Math.min(x, y);\\n            y1 = Math.max(x, y);\\n            \\n            res[x1][y1] += 1;\\n        }\\n        \\n        for (int i=0;i<10;i++) {\\n            for (int j=0;j<10;j++) {\\n                int val = res[i][j];\\n                if (val > 0) {\\n                    tCount += val*(val-1)/2;\\n                }\\n            }\\n        }\\n        \\n        return tCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        if (dominoes.length < 2) return 0;\\n        \\n        int[][] res = new int[10][10];\\n        \\n        int tCount=0,x,y,x1,y1;\\n            \\n        for (int i=0;i<dominoes.length;i++) {\\n            x = dominoes[i][0];\\n            y = dominoes[i][1];\\n            \\n            x1 = Math.min(x, y);\\n            y1 = Math.max(x, y);\\n            \\n            res[x1][y1] += 1;\\n        }\\n        \\n        for (int i=0;i<10;i++) {\\n            for (int j=0;j<10;j++) {\\n                int val = res[i][j];\\n                if (val > 0) {\\n                    tCount += val*(val-1)/2;\\n                }\\n            }\\n        }\\n        \\n        return tCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977090,
                "title": "java-using-encoding",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes)\\n    {\\n        int arr[] = new int[100];\\n        int s=0;\\n        for(int[] a:dominoes)\\n        {\\n            arr[Math.min(a[0],a[1])*10+Math.max(a[0],a[1])]++;\\n        }\\n        for(int i:arr)\\n        {\\n            s+=(i*(i-1))/2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes)\\n    {\\n        int arr[] = new int[100];\\n        int s=0;\\n        for(int[] a:dominoes)\\n        {\\n            arr[Math.min(a[0],a[1])*10+Math.max(a[0],a[1])]++;\\n        }\\n        for(int i:arr)\\n        {\\n            s+=(i*(i-1))/2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948244,
                "title": "hashmap-javascript",
                "content": "```\\nconst numEquivDominoPairs = dominoes => {\\n  const seen = new Map();\\n  let count = 0;\\n  \\n  dominoes.forEach(domino => {\\n    domino.sort((a,b) => a-b);\\n    const str = domino.join(\\'\\')\\n    if(seen.get(str)){\\n      count += seen.get(str);\\n      seen.set(str, seen.get(str)+1)\\n    }\\n    else\\n      seen.set(str,1)\\n  })\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numEquivDominoPairs = dominoes => {\\n  const seen = new Map();\\n  let count = 0;\\n  \\n  dominoes.forEach(domino => {\\n    domino.sort((a,b) => a-b);\\n    const str = domino.join(\\'\\')\\n    if(seen.get(str)){\\n      count += seen.get(str);\\n      seen.set(str, seen.get(str)+1)\\n    }\\n    else\\n      seen.set(str,1)\\n  })\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946335,
                "title": "java-by-custom-range-class-you-will-learn-something-new-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    \\n    class Range {\\n        int a;\\n        int b;\\n        \\n        Range(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            if(this == o) return true;\\n            \\n            if(o == null || this.getClass() != o.getClass()) return false;\\n            \\n            Range r = (Range)o;\\n            \\n            if(r.a != this.a) return false;\\n            \\n            return r.b == this.b;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return (a * 31 + b);\\n        }\\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Range, Integer> hm = new HashMap<>();\\n        int cnt = 0;\\n        for(int i = 0; i < dominoes.length; i += 1) {\\n            int first = dominoes[i][0], second = dominoes[i][1];\\n            Range r = new Range(Math.min(first, second), Math.max(first, second));\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        /*\\n            If we know that a pair -> (a, b) comes how many times\\n            then it would becomes easy to find out how many \\n            distinct pairs can be made by suing frequency of pair (a, b).\\n            \\n            Num(dis_pairs) = freq * (freq - 1) / 2;\\n            \\n        */\\n        for(int freq : hm.values()) {\\n            cnt += (freq * (freq - 1) / 2);\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Range {\\n        int a;\\n        int b;\\n        \\n        Range(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            if(this == o) return true;\\n            \\n            if(o == null || this.getClass() != o.getClass()) return false;\\n            \\n            Range r = (Range)o;\\n            \\n            if(r.a != this.a) return false;\\n            \\n            return r.b == this.b;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return (a * 31 + b);\\n        }\\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Range, Integer> hm = new HashMap<>();\\n        int cnt = 0;\\n        for(int i = 0; i < dominoes.length; i += 1) {\\n            int first = dominoes[i][0], second = dominoes[i][1];\\n            Range r = new Range(Math.min(first, second), Math.max(first, second));\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        /*\\n            If we know that a pair -> (a, b) comes how many times\\n            then it would becomes easy to find out how many \\n            distinct pairs can be made by suing frequency of pair (a, b).\\n            \\n            Num(dis_pairs) = freq * (freq - 1) / 2;\\n            \\n        */\\n        for(int freq : hm.values()) {\\n            cnt += (freq * (freq - 1) / 2);\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944279,
                "title": "java-solution",
                "content": "```\\n    private int uniqueKey(int a, int b) {\\n        return a < b ? a * 10 + b : b * 10 + a;            \\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] countByKey = new int[1000];\\n        int result = 0;\\n        for(int[] domino: dominoes) {\\n            int key = uniqueKey(domino[0], domino[1]);\\n            result += countByKey[key]++;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int uniqueKey(int a, int b) {\\n        return a < b ? a * 10 + b : b * 10 + a;            \\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] countByKey = new int[1000];\\n        int result = 0;\\n        for(int[] domino: dominoes) {\\n            int key = uniqueKey(domino[0], domino[1]);\\n            result += countByKey[key]++;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906956,
                "title": "c-hash-table",
                "content": "```\\npublic int NumEquivDominoPairs2(int[][] dominoes)\\n{\\n\\tint[] arr = new int[100];\\n\\tforeach (var d in dominoes)\\n\\t{\\n\\t\\tint t = d[0] * 10 + d[1];\\n\\t\\tif (d[0] > d[1])\\n\\t\\t\\tt = d[1] * 10 + d[0];\\n\\t\\tarr[t]++;\\n\\t}\\n\\n\\tint res = 0;\\n\\tforeach (var a in arr)\\n\\t\\tres += a * (a - 1) / 2;\\n\\n\\treturn res;\\n}\\n```\\n`C#`",
                "solutionTags": [],
                "code": "```\\npublic int NumEquivDominoPairs2(int[][] dominoes)\\n{\\n\\tint[] arr = new int[100];\\n\\tforeach (var d in dominoes)\\n\\t{\\n\\t\\tint t = d[0] * 10 + d[1];\\n\\t\\tif (d[0] > d[1])\\n\\t\\t\\tt = d[1] * 10 + d[0];\\n\\t\\tarr[t]++;\\n\\t}\\n\\n\\tint res = 0;\\n\\tforeach (var a in arr)\\n\\t\\tres += a * (a - 1) / 2;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881192,
                "title": "java-1ms-solution-beats-100-time-o-n-space-o-1-short-code-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int ans = 0;\\n        int[] bucket = new int[100];\\n        for (int[] domino : dominoes)\\n            bucket[domino[0] * 10 + domino[1]]++;\\n        int ten = 0, one = 0;\\n        for (int i = 11; i < 100; i++) {\\n            int k = bucket[i]; // for 11,22,33...99, add k*(k-1)/2\\n            ten = i / 10;\\n            one = i % 10;\\n            if (one > ten)\\n                k += bucket[one * 10 + ten]; // for bucket[12], k= bucket[12]+bucket[21], then add k*(k-1)/2\\n            else if (one < ten) // for bucket[21], ignore since already counted in bucket[12]\\n                continue;\\n            ans += k * (k - 1) / 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int ans = 0;\\n        int[] bucket = new int[100];\\n        for (int[] domino : dominoes)\\n            bucket[domino[0] * 10 + domino[1]]++;\\n        int ten = 0, one = 0;\\n        for (int i = 11; i < 100; i++) {\\n            int k = bucket[i]; // for 11,22,33...99, add k*(k-1)/2\\n            ten = i / 10;\\n            one = i % 10;\\n            if (one > ten)\\n                k += bucket[one * 10 + ten]; // for bucket[12], k= bucket[12]+bucket[21], then add k*(k-1)/2\\n            else if (one < ten) // for bucket[21], ignore since already counted in bucket[12]\\n                continue;\\n            ans += k * (k - 1) / 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867272,
                "title": "python3-no-dict-math-solution-100-220ms-100-22mb",
                "content": "**Fast Dictionary-Free Solution**\\n\\nWe keep track of how many times we encounter a domino (up to equivalence) by using an array to count the number of occurences and use an encoding for efficiency. As we count, we `pop` from `dominoes` to conserve space. Once we\\'ve counted everything, we use the well-known combinatorial fact that the number of unordered pairs that can be made from `n` objects is `n choose 2 =  n*(n-1)/2`. \\n\\n```python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\tcnt = [0]*73  # (Explanation for 73 in discussion below)\\n\\twhile dominoes: \\n\\t\\td = dominoes.pop()\\n\\t\\tcnt[9*max(d) - 8*min(d) - 1] += 1\\n\\treturn sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nHere we encode the domino  `d=[a,b]` as `E(a,b) = 9*max(a,b) - 8*min(a,b) - 1`.  This encoding is always symmetric and is collision-free whenever  `1 <= a,b <= 9` (which is the case for our dominoes). To see why this claim is true, first note that since `|a-b| = max(a,b) - min(a,b) ` we have\\n\\n```\\n9*|a-b| + min(a,b) - 1\\n= 9*(max(a,b)-min(a,b)) + min(a,b) - 1\\n= 9*max(a,b) - 8*min(a,b) - 1\\n= E(a,b)\\n```\\n\\nThis alternate expression  of `E(a,b)` makes it easier to see why there are no collisions. A quick mental check confirms that `min(a,b)-1` can only be 0,1,2,3,4,5,6,7,8. These are the possible remainders mod 9, thus \\n\\n``` python 3\\nE(a,b) % 9  = min(a,b) -1  # remainder of division by 9\\nE(a,b) // 9 = |a-b|  # division by 9 rounded down (quotient)\\n```\\n\\nSince `max(a,b) = min(a,b) + |a-b|` this let\\'s us undo the encoding as follows:\\n\\n``` python 3\\nmin(a,b) = 1 + E(a,b) % 9 \\nmax(a,b) = 1 + E(a,b) % 9 +  E(a,b)//9\\n```\\n\\nThus, given the encoding `E(a,b)`, we can recover `d=[a,b]` (up to equivalence) since we know the `min` and `max` elements. This means there are no collisions.\\n\\nFinally, it is worth noting that that the the smallest encoding is `0=E(1,1)` and the largest encoding is `72=E(1,9)`. Thus the minimum size for a contiguous array that can hold these values is one of size `73`. \\n\\n---\\n---\\n**Alternate (but less efficient) Encoding**\\nInstead of the above encoding, we could have tried something like  `F(a,b) = 10*max(a,b) + min(a,b)`. This is also collision free since we can take remainders and quotients like before to obtain the `max` and `min`. However, the smallest encoding is `11=F(1,1)` and the largest is `99=F(9,9)`. Thus we need at least `89` slots in the counting array to accomodate this encoding. \\n\\n--- \\n---\\n**Just for Fun: Minimizing Array Size**\\n\\nBasic combinatorics tells us that it should be possible to make the counting array even smaller since we know that there are exactly `9 choose 2 + 9= 9*8/2 + 9 = 45` possible dominos (up to equivalence). By making the encoding more complicated we can reflect this fact. However we will lose some performance due to the more complicated logic, so this is mostly just an interesting exercise. Not really useful for interviews.\\n\\nFirst, let\\'s determine where the `0`\\'s are in the array `cnt`. Then we can shift the nonzero entries around to fill up that empty space. We can write some quick code to generate all pairs and then place a `1` at the encoded index if that position is used and `0` if not. This allows us to see which indices are utilized and which aren\\'t. Printing these values shows us an interesting pattern. \\n\\n``` python 3\\n# Reading left-to-right, top-to-bottom, first index is 0, last index is 72\\n1, 1, 1, 1, 1, 1, 1, 1, 1, \\n1, 1, 1, 1, 1, 1, 1, 1, 0, \\n1, 1, 1, 1, 1, 1, 1, 0, 0, \\n1, 1, 1, 1, 1, 1, 0, 0, 0, \\n1, 1, 1, 1, 1, 0, 0, 0, 0, \\n1, 1, 1, 1, 0, 0, 0, 0, 0, \\n1, 1, 1, 0, 0, 0, 0, 0, 0,\\n1, 1, 0, 0, 0, 0, 0, 0, 0,\\n1\\n```\\n\\nOne approach to fix this is to shift all indices up by `1` then apply `% 73` to wrap things back around, and then reduce the array size to omit the trailing zeroes. Then we can shift by `2` and apply `% 66` and remove trailing zeros. Then shift by `3`, apply `% 60`, then truncate. Etc. This yields the following code:\\n\\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\t# Minimizing array size (Cyclic Shifting + Truncation via Modular Arithmetic)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d)\\n            d = d % 73 + 2\\n            d = d % 66 + 3\\n            d = d % 60 + 4\\n            d = d % 55 + 5\\n            d = d % 51 + 6\\n            d = d % 48 + 7\\n            d = d % 46\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nAnother approach is to manually move the value at `72` to `17`. Then move `63, 64` to `25, 26`. Then move `54,55,56` to `33,34,35`. Then finally move `45,46,47,48` to `41,42,43,44`. We code this in order that moves the most things first.\\n\\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # Minimizing array size (Manually moving the encoding to correct spot)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d) - 1\\n            if 44 < d < 49: d -= 4\\n            elif 53 < d < 57: d -= 21\\n            elif 62 < d < 65: d -= 38\\n            elif d == 72: d = 17\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nOn a final note, I find these two above approaches kinda messy. I think it would be very cool to see if there is a way to do the symmetric collision-free encoding with the minimum array size of `45` in a clean way. Please let me know in comments if you come up with one!\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\tcnt = [0]*73  # (Explanation for 73 in discussion below)\\n\\twhile dominoes: \\n\\t\\td = dominoes.pop()\\n\\t\\tcnt[9*max(d) - 8*min(d) - 1] += 1\\n\\treturn sum([n*(n-1)//2 for n in cnt])\\n```\n```\\n9*|a-b| + min(a,b) - 1\\n= 9*(max(a,b)-min(a,b)) + min(a,b) - 1\\n= 9*max(a,b) - 8*min(a,b) - 1\\n= E(a,b)\\n```\n``` python 3\\nE(a,b) % 9  = min(a,b) -1  # remainder of division by 9\\nE(a,b) // 9 = |a-b|  # division by 9 rounded down (quotient)\\n```\n``` python 3\\nmin(a,b) = 1 + E(a,b) % 9 \\nmax(a,b) = 1 + E(a,b) % 9 +  E(a,b)//9\\n```\n``` python 3\\n# Reading left-to-right, top-to-bottom, first index is 0, last index is 72\\n1, 1, 1, 1, 1, 1, 1, 1, 1, \\n1, 1, 1, 1, 1, 1, 1, 1, 0, \\n1, 1, 1, 1, 1, 1, 1, 0, 0, \\n1, 1, 1, 1, 1, 1, 0, 0, 0, \\n1, 1, 1, 1, 1, 0, 0, 0, 0, \\n1, 1, 1, 1, 0, 0, 0, 0, 0, \\n1, 1, 1, 0, 0, 0, 0, 0, 0,\\n1, 1, 0, 0, 0, 0, 0, 0, 0,\\n1\\n```\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\t# Minimizing array size (Cyclic Shifting + Truncation via Modular Arithmetic)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d)\\n            d = d % 73 + 2\\n            d = d % 66 + 3\\n            d = d % 60 + 4\\n            d = d % 55 + 5\\n            d = d % 51 + 6\\n            d = d % 48 + 7\\n            d = d % 46\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # Minimizing array size (Manually moving the encoding to correct spot)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d) - 1\\n            if 44 < d < 49: d -= 4\\n            elif 53 < d < 57: d -= 21\\n            elif 62 < d < 65: d -= 38\\n            elif d == 72: d = 17\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 863934,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes) {\\n        map<pair<int, int>, int> dp;\\n        for (int i = 0; i < dominoes.size(); ++i) {\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            pair<int, int> tmp(min(a, b), max(a, b));\\n            dp[tmp]++;\\n        }\\n        int ans = 0;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            ans += ((it->second) * (it->second - 1) / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes) {\\n        map<pair<int, int>, int> dp;\\n        for (int i = 0; i < dominoes.size(); ++i) {\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            pair<int, int> tmp(min(a, b), max(a, b));\\n            dp[tmp]++;\\n        }\\n        int ans = 0;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            ans += ((it->second) * (it->second - 1) / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861706,
                "title": "o-n-c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n  int cal(int n){\\n        return ((n*(n-1))/2);\\n    }\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n       map<pair<int, int>, int> s;  \\n        int cnt=0;\\n        for(int i=0;i<dominoes.size();i++)\\n            if(s.find({dominoes[i][0],dominoes[i][1]})!=s.end() )\\n            {\\n                s[{dominoes[i][0],dominoes[i][1]}]++;\\n                int n=s[{dominoes[i][0],dominoes[i][1]}];\\n                cnt=cnt-cal(n-1)+cal(n);\\n            }\\n            else if( s.find({dominoes[i][1],dominoes[i][0]})!=s.end()){\\n                  s[{dominoes[i][1],dominoes[i][0]}]++;\\n                int n= s[{dominoes[i][1],dominoes[i][0]}];\\n                 cnt=cnt-cal(n-1)+cal(n);\\n                \\n            }\\n            else\\n                  s[{dominoes[i][0],dominoes[i][1]}]++;\\n          return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int cal(int n){\\n        return ((n*(n-1))/2);\\n    }\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n       map<pair<int, int>, int> s;  \\n        int cnt=0;\\n        for(int i=0;i<dominoes.size();i++)\\n            if(s.find({dominoes[i][0],dominoes[i][1]})!=s.end() )\\n            {\\n                s[{dominoes[i][0],dominoes[i][1]}]++;\\n                int n=s[{dominoes[i][0],dominoes[i][1]}];\\n                cnt=cnt-cal(n-1)+cal(n);\\n            }\\n            else if( s.find({dominoes[i][1],dominoes[i][0]})!=s.end()){\\n                  s[{dominoes[i][1],dominoes[i][0]}]++;\\n                int n= s[{dominoes[i][1],dominoes[i][0]}];\\n                 cnt=cnt-cal(n-1)+cal(n);\\n                \\n            }\\n            else\\n                  s[{dominoes[i][0],dominoes[i][1]}]++;\\n          return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832888,
                "title": "python-3-use-dict",
                "content": "When the length of array is around 50k, it means we don\\'t get Memory Limit Exceeded, and can sacrefice space for speed (since it more often happens TLE for slow speed).\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for dom in dominoes:\\n            a, b = dom[0], dom[1]\\n            if a > b:\\n                a, b = b, a\\n            d[(a, b)] = d.get((a,b), 0) + 1\\n        \\n        res = 0\\n        for v in d.values():\\n            res += (v-1) * v / 2\\n                    \\n        return int(res)",
                "solutionTags": [],
                "code": "When the length of array is around 50k, it means we don\\'t get Memory Limit Exceeded, and can sacrefice space for speed (since it more often happens TLE for slow speed).\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for dom in dominoes:\\n            a, b = dom[0], dom[1]\\n            if a > b:\\n                a, b = b, a\\n            d[(a, b)] = d.get((a,b), 0) + 1\\n        \\n        res = 0\\n        for v in d.values():\\n            res += (v-1) * v / 2\\n                    \\n        return int(res)",
                "codeTag": "Java"
            },
            {
                "id": 822802,
                "title": "a-neat-math-based-solution-in-python",
                "content": "Convert the pairs into tuple keys in a dict. \\nif the count is more than 1, then its the number of occurrences\\nto find the number of pairs possible .. we just nC2 and add it our output.\\nIt took me 45 min to get to this solution.\\n\\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        hdict = {}\\n        output = 0\\n                \\n        for val in dominoes:            \\n            s_val = tuple(sorted(val))\\n            if s_val in hdict:\\n                hdict[s_val] += 1\\n            else:\\n                hdict[s_val] = 1\\n        \\n        for k, v in hdict.items():\\n            \\n            if v > 1:\\n                output += comb(v, 2)\\n        \\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        hdict = {}\\n        output = 0\\n                \\n        for val in dominoes:            \\n            s_val = tuple(sorted(val))\\n            if s_val in hdict:\\n                hdict[s_val] += 1\\n            else:\\n                hdict[s_val] = 1\\n        \\n        for k, v in hdict.items():\\n            \\n            if v > 1:\\n                output += comb(v, 2)\\n        \\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809986,
                "title": "python-3-dictionary-explanation",
                "content": "* For this question we want to keep a record of all the previous dominoes we\\'ve seen, and how many times we\\'ve seen them.\\n* We also want to consider equivalent dominoes under the same \\'count\\'\\n\\t* For example, the dominoes `(1, 2)` and `(2, 1)` should be considered as \\'seen\\' twice, since they are equivalent once rotated.\\n\\t* So the dictionary `dominoToCount` counts up how many matching dominoes we have seen.\\n* In order to pair up matching dominoes, we need some way of mapping dominoes like `(1, 2)` and `(2, 1)` into the same key.\\n\\t* For this we can use the `getKey` function that ensures that both map to the same value, we do this by using the smaller number as the first in the tuple.\\n\\t* So both `(1, 2)` and `(2, 1)` will be mapped to `(1, 2)`.\\n* As we iterate through `dominoes` we add to the running total `equivalentPairs` how many existing equivalent dominoes there are.\\n```\\nfrom typing import Tuple\\n\\nclass Solution:\\n    \\n    def getKey(self, a: int, b: int) -> Tuple[int, int]:\\n        return (a, b) if a < b else (b, a)\\n    \\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        equivalentPairs = 0\\n        dominoes = [tuple(domino) for domino in dominoes]\\n        dominoToCount = {}\\n        \\n        for a, b in dominoes:\\n            key = self.getKey(a, b)\\n            \\n            if key in dominoToCount:\\n                equivalentPairs += dominoToCount[key]\\n                dominoToCount[key] = dominoToCount[key] + 1\\n            else:\\n                dominoToCount[key] = 1\\n                \\n        return equivalentPairs\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import Tuple\\n\\nclass Solution:\\n    \\n    def getKey(self, a: int, b: int) -> Tuple[int, int]:\\n        return (a, b) if a < b else (b, a)\\n    \\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        equivalentPairs = 0\\n        dominoes = [tuple(domino) for domino in dominoes]\\n        dominoToCount = {}\\n        \\n        for a, b in dominoes:\\n            key = self.getKey(a, b)\\n            \\n            if key in dominoToCount:\\n                equivalentPairs += dominoToCount[key]\\n                dominoToCount[key] = dominoToCount[key] + 1\\n            else:\\n                dominoToCount[key] = 1\\n                \\n        return equivalentPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801653,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int A[9][9];\\n    \\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        memset(A,0,sizeof A);\\n        for(int i = 0;i<dominoes.size();i++){\\n            if(dominoes[i][0]!=dominoes[i][1]){\\n            A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            A[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n                }\\n            else{\\n                A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }    \\n        \\n        int sum =0;\\n\\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                    sum+=((A[i][j])*(A[i][j]-1))/2;\\n            }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int A[9][9];\\n    \\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        memset(A,0,sizeof A);\\n        for(int i = 0;i<dominoes.size();i++){\\n            if(dominoes[i][0]!=dominoes[i][1]){\\n            A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            A[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n                }\\n            else{\\n                A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }    \\n        \\n        int sum =0;\\n\\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                    sum+=((A[i][j])*(A[i][j]-1))/2;\\n            }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727438,
                "title": "c-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& domino) {\\n        int ans=0;\\n        map<pair<int,int>, int> cnt;\\n        for(auto v : domino) {\\n            sort(v.begin(),v.end());\\n            auto p=make_pair(v[0],v[1]);\\n            cnt[p]++;\\n            if(cnt[p]==2) ans++;\\n            else if(cnt[p]>2) ans+=cnt[p]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& domino) {\\n        int ans=0;\\n        map<pair<int,int>, int> cnt;\\n        for(auto v : domino) {\\n            sort(v.begin(),v.end());\\n            auto p=make_pair(v[0],v[1]);\\n            cnt[p]++;\\n            if(cnt[p]==2) ans++;\\n            else if(cnt[p]>2) ans+=cnt[p]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678287,
                "title": "java-o-n-solution-with-o-1-space",
                "content": "It can be solved with HashMap. Iterate over array, sort domino pair, add count of such pairs in map to the answer and increase this counter.\\nI am using array `used` instead of map, because number of possible values is small. It increases performance a little bit\\n\\n```\\nclass Solution {\\n    private static final int MAXIMUM_DOMINO_VALUE = 9;\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int answer = 0;\\n        int[] used = new int[MAXIMUM_DOMINO_VALUE * MAXIMUM_DOMINO_VALUE];\\n        \\n        for (int[] domino : dominoes) {\\n            int smallerSide = (Math.min(domino[0], domino[1]) - 1) * MAXIMUM_DOMINO_VALUE;\\n            int biggerSide = (Math.max(domino[0], domino[1]) - 1);\\n            \\n            answer += used[smallerSide + biggerSide];\\n            used[smallerSide + biggerSide]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MAXIMUM_DOMINO_VALUE = 9;\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int answer = 0;\\n        int[] used = new int[MAXIMUM_DOMINO_VALUE * MAXIMUM_DOMINO_VALUE];\\n        \\n        for (int[] domino : dominoes) {\\n            int smallerSide = (Math.min(domino[0], domino[1]) - 1) * MAXIMUM_DOMINO_VALUE;\\n            int biggerSide = (Math.max(domino[0], domino[1]) - 1);\\n            \\n            answer += used[smallerSide + biggerSide];\\n            used[smallerSide + biggerSide]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660959,
                "title": "c-simple-3-line-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`.\\n\\n```\\nclass Solution {\\npublic:\\n    static int numEquivDominoPairs(const vector<vector<int>>& dominoes) {\\n        int m[100]{0}, count{0};\\n        for(const auto &d: dominoes) count += m[min(d[0], d[1]) + 10*max(d[0], d[1])]++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int numEquivDominoPairs(const vector<vector<int>>& dominoes) {\\n        int m[100]{0}, count{0};\\n        for(const auto &d: dominoes) count += m[min(d[0], d[1]) + 10*max(d[0], d[1])]++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657664,
                "title": "java-solutions-o-n-time-o-n-space",
                "content": "Basically we need a way to serialize each domino (that is we need a way to check that [1,2] = [2, 1]). In my case I chose to get a number representation, so domino [1,2] and [2,1] would both have a number representation of 12. Then we keep track of frequency of the same dominoes using a hashmap. I just want to point out that the brute force solution would be simply using 2 for loops.\\n\\nUnfortunatley this is just one of those questions where you either know how to solve it, or you don\\'t. I found it very hard to logic my way through.\\n\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            Integer numRepresentation = getNumRepresentation(domino);\\n            if (map.containsKey(numRepresentation)) {\\n                int oldCount = map.get(numRepresentation);\\n                map.put(numRepresentation, oldCount + 1);\\n            }\\n            else map.put(numRepresentation, 0);\\n            count += map.get(numRepresentation);            \\n        }\\n        \\n        return count;\\n    }\\n    \\n    private Integer getNumRepresentation(int[] domino) {\\n        boolean isFirstNumSmaller = domino[0] < domino[1];\\n        return (isFirstNumberSmaller) domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            Integer numRepresentation = getNumRepresentation(domino);\\n            if (map.containsKey(numRepresentation)) {\\n                int oldCount = map.get(numRepresentation);\\n                map.put(numRepresentation, oldCount + 1);\\n            }\\n            else map.put(numRepresentation, 0);\\n            count += map.get(numRepresentation);            \\n        }\\n        \\n        return count;\\n    }\\n    \\n    private Integer getNumRepresentation(int[] domino) {\\n        boolean isFirstNumSmaller = domino[0] < domino[1];\\n        return (isFirstNumberSmaller) domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654656,
                "title": "java-6ms-beats-80-18-superb-oop-plus-override-hashcode-and-equals",
                "content": "```\\nclass Solution {\\n  \\n  public int numEquivDominoPairs(int[][] dominoes) {\\n    \\n    /*\\n    Runtime: 6 ms, faster than 80.81% of Java online submissions for Number of Equivalent Domino Pairs.\\n    Memory Usage: 48.3 MB, less than 100.00% of Java online submissions for Number of Equivalent Domino Pairs.\\n    */\\n    \\n    Map<Domino, Integer> dominoFT = new HashMap<Domino, Integer>();// FT = frequency table\\n    \\n    // populate HashMap with dominoes\\n    for (int[] d : dominoes) {\\n      dominoFT.merge(new Domino(d[0], d[1]), 1, Integer::sum);// nice little merge/sum trick useful for frequency counting...\\n    }\\n    \\n    int quantityOfPairs = 0;\\n    \\n    for (int i : dominoFT.values()) {// all we need are the values, so no need for entrySet() or keySet()\\n      if (i > 1) {\\n        // LeetCode\\'s test cases require:\\n        // 2 matching dominoes counts as 1 pair, BUT!...\\n        // 3 matching dominoes counts as 3 pairs (i.e., it wants handshake formula)\\n        quantityOfPairs += handshakeNumber(i);   \\n      }\\n    }\\n    \\n    return quantityOfPairs;\\n  }\\n  \\n  private int handshakeNumber(int n) {\\n    --n;\\n    return n * (n + 1) / 2;\\n  }\\n  \\n  private class Domino {\\n    \\n    // fields\\n    int smallSpots;\\n    int bigSpots;\\n    \\n    // constructor\\n    Domino (int a, int b) {\\n      if (a < b) {\\n        smallSpots = a;\\n        bigSpots = b;\\n      } else {\\n        smallSpots = b;\\n        bigSpots = a;\\n      }\\n    }\\n    \\n    // methods\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n      return this.hashCode() == obj.hashCode();\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n      return this.smallSpots * 10 + bigSpots;\\n    }\\n    \\n  }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n  public int numEquivDominoPairs(int[][] dominoes) {\\n    \\n    /*\\n    Runtime: 6 ms, faster than 80.81% of Java online submissions for Number of Equivalent Domino Pairs.\\n    Memory Usage: 48.3 MB, less than 100.00% of Java online submissions for Number of Equivalent Domino Pairs.\\n    */\\n    \\n    Map<Domino, Integer> dominoFT = new HashMap<Domino, Integer>();// FT = frequency table\\n    \\n    // populate HashMap with dominoes\\n    for (int[] d : dominoes) {\\n      dominoFT.merge(new Domino(d[0], d[1]), 1, Integer::sum);// nice little merge/sum trick useful for frequency counting...\\n    }\\n    \\n    int quantityOfPairs = 0;\\n    \\n    for (int i : dominoFT.values()) {// all we need are the values, so no need for entrySet() or keySet()\\n      if (i > 1) {\\n        // LeetCode\\'s test cases require:\\n        // 2 matching dominoes counts as 1 pair, BUT!...\\n        // 3 matching dominoes counts as 3 pairs (i.e., it wants handshake formula)\\n        quantityOfPairs += handshakeNumber(i);   \\n      }\\n    }\\n    \\n    return quantityOfPairs;\\n  }\\n  \\n  private int handshakeNumber(int n) {\\n    --n;\\n    return n * (n + 1) / 2;\\n  }\\n  \\n  private class Domino {\\n    \\n    // fields\\n    int smallSpots;\\n    int bigSpots;\\n    \\n    // constructor\\n    Domino (int a, int b) {\\n      if (a < b) {\\n        smallSpots = a;\\n        bigSpots = b;\\n      } else {\\n        smallSpots = b;\\n        bigSpots = a;\\n      }\\n    }\\n    \\n    // methods\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n      return this.hashCode() == obj.hashCode();\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n      return this.smallSpots * 10 + bigSpots;\\n    }\\n    \\n  }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646462,
                "title": "javascript-easy-and-readable-solution-using-map-and-math",
                "content": "This solution optimizes for readability and simplicity. We count how many dominos have the same number pairs and then sum up the different combinations of each set.\\n\\nThe math:\\nFor `n` items, the number of different ways to choose `r` items is given by the `nCr` formula\\n```\\nnumCombinations = n! / ((n-r)! * r!)\\n```\\n\\nGiven 2 dominos, the is only 1 way to choose 2 dominos. Given 3 domins, there are 2. For 4, there are 3.\\n\\nWe can further simplify this equation because we know `r = 2`\\n```\\nn! / ((n-2)! * 2!)\\n```\\nThen rewrite `n!` to be `n*(n-1)*(n-2)!`\\n```\\n(n*(n-1)*(n-2)!) / ((n-2)! * 2!)\\n```\\nSimplify\\n```\\nn*(n-1) / 2\\n```\\n\\nSolution:\\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    const counts = {};\\n    \\n    dominoes.forEach(d => {\\n\\t    // this converts all dominos with the same number pair to the same string\\n\\t\\t// [1,2] and [2,1] will get sorted to [1,2]\\n\\t\\t// toString method converts it to a string \"1,2\" so it can be used as keys\\n        const dStr = d.sort().toString();\\n\\t\\t\\n        if (!counts.hasOwnProperty(dStr)) {\\n            counts[dStr] = 0;\\n        }\\n        counts[dStr]++;\\n    })\\n    \\n\\t// sum all counts together while calculating combinations of domino pairs\\n    return Object.values(counts).reduce((sum, count) => {\\n        return sum + (count*(count-1))/2;\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "```\\nnumCombinations = n! / ((n-r)! * r!)\\n```\n```\\nn! / ((n-2)! * 2!)\\n```\n```\\n(n*(n-1)*(n-2)!) / ((n-2)! * 2!)\\n```\n```\\nn*(n-1) / 2\\n```\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    const counts = {};\\n    \\n    dominoes.forEach(d => {\\n\\t    // this converts all dominos with the same number pair to the same string\\n\\t\\t// [1,2] and [2,1] will get sorted to [1,2]\\n\\t\\t// toString method converts it to a string \"1,2\" so it can be used as keys\\n        const dStr = d.sort().toString();\\n\\t\\t\\n        if (!counts.hasOwnProperty(dStr)) {\\n            counts[dStr] = 0;\\n        }\\n        counts[dStr]++;\\n    })\\n    \\n\\t// sum all counts together while calculating combinations of domino pairs\\n    return Object.values(counts).reduce((sum, count) => {\\n        return sum + (count*(count-1))/2;\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640290,
                "title": "simple-java-using-hashmap",
                "content": "Intuition\\n1. Traverse loop while traversing store each pair in hashmap.\\n2. If the number already exists increment its count in hashmap.\\n3. At the end traverse hasmap and get the result for each pair by calculating its permutations as n pemute= n*(n-1)/2 .\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<Integer,Integer> hsmap=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            int a=Math.min(dominoes[i][0],dominoes[i][1]);\\n            int b=Math.max(dominoes[i][0],dominoes[i][1]);\\n            int key1=a*10+ b;\\n            hsmap.put(key1,hsmap.getOrDefault(key1,0)+1);\\n        }\\n        int count=0;\\n        for(Integer i:hsmap.values())\\n        {\\n            count+=(i*(i-1))/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<Integer,Integer> hsmap=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            int a=Math.min(dominoes[i][0],dominoes[i][1]);\\n            int b=Math.max(dominoes[i][0],dominoes[i][1]);\\n            int key1=a*10+ b;\\n            hsmap.put(key1,hsmap.getOrDefault(key1,0)+1);\\n        }\\n        int count=0;\\n        for(Integer i:hsmap.values())\\n        {\\n            count+=(i*(i-1))/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625460,
                "title": "c-solution-std-unordered-map",
                "content": "With numbers of pairs calculation on-the-fly\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n        {\\n            auto it = m.emplace(key_t{x[0], x[1]}, 0).first;\\n            count += it->second;\\n            ++(it->second);\\n        }\\n        return count;\\n    }\\n};\\n```\\nOr with std::accumulate upon collecting information about pairs\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n            ++m[{x[0], x[1]}];\\n        return std::accumulate(m.cbegin(), m.cend(), 0, [](auto sum, auto const &p){ return sum + p.second * (p.second - 1) / 2; });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n        {\\n            auto it = m.emplace(key_t{x[0], x[1]}, 0).first;\\n            count += it->second;\\n            ++(it->second);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n            ++m[{x[0], x[1]}];\\n        return std::accumulate(m.cbegin(), m.cend(), 0, [](auto sum, auto const &p){ return sum + p.second * (p.second - 1) / 2; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620700,
                "title": "c-calculate-in-1-iteration-using-map",
                "content": "use a map to store a pair as key and it\\'s count so far as value. for counting pairs we just have to just count the same domino processed so far.\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        int s=dominoes.size();\\n        if(s==1)\\n            return ans;\\n        map<pair<int,int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n        int a=min(dominoes[i][0],dominoes[i][1]);\\n        int b=max(dominoes[i][0],dominoes[i][1]);\\n        m[{a,b}]++;\\n        ans+=m[{a,b}]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        int s=dominoes.size();\\n        if(s==1)\\n            return ans;\\n        map<pair<int,int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n        int a=min(dominoes[i][0],dominoes[i][1]);\\n        int b=max(dominoes[i][0],dominoes[i][1]);\\n        m[{a,b}]++;\\n        ans+=m[{a,b}]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617208,
                "title": "python-rust-time-o-n-space-o-n",
                "content": "- **Python**\\n```python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        seen, count = {}, 0\\n        \\n        for d in dominoes:\\n            key = tuple(sorted(d))\\n            if key in seen:\\n                count += seen[key]\\n                seen[key] += 1\\n            else:\\n                seen[key] = 1\\n                \\n        return count\\n```\\n\\n- **Rust**\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut seen: HashMap<(i32,i32), i32> = HashMap::new();\\n        \\n        for d in dominoes.iter() {\\n            let mut t = d.clone();\\n            t.sort();\\n            let key = (t[0], t[1]);\\n            \\n            if seen.contains_key(&key) {\\n                let val = *seen.get(&key).unwrap();\\n                count += val;\\n                seen.insert(key, val + 1);\\n            } else {\\n                seen.insert(key, 1);\\n            }  \\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        seen, count = {}, 0\\n        \\n        for d in dominoes:\\n            key = tuple(sorted(d))\\n            if key in seen:\\n                count += seen[key]\\n                seen[key] += 1\\n            else:\\n                seen[key] = 1\\n                \\n        return count\\n```\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut seen: HashMap<(i32,i32), i32> = HashMap::new();\\n        \\n        for d in dominoes.iter() {\\n            let mut t = d.clone();\\n            t.sort();\\n            let key = (t[0], t[1]);\\n            \\n            if seen.contains_key(&key) {\\n                let val = *seen.get(&key).unwrap();\\n                count += val;\\n                seen.insert(key, val + 1);\\n            } else {\\n                seen.insert(key, 1);\\n            }  \\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595995,
                "title": "swift",
                "content": "```\\nfunc numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var map = [[Int]: Int]()\\n        for domin in dominoes {\\n            var cur = domin\\n            if cur[0] > cur[1] {\\n                cur = [cur[1], cur[0]]\\n            }\\n            map[cur, default: 0] += 1\\n        }\\n        var res = 0\\n        for value in map.values {\\n            if value > 1 {\\n                res += value * (value - 1) / 2\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var map = [[Int]: Int]()\\n        for domin in dominoes {\\n            var cur = domin\\n            if cur[0] > cur[1] {\\n                cur = [cur[1], cur[0]]\\n            }\\n            map[cur, default: 0] += 1\\n        }\\n        var res = 0\\n        for value in map.values {\\n            if value > 1 {\\n                res += value * (value - 1) / 2\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568802,
                "title": "javascript-solution-o-n",
                "content": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    const map = new Map()\\n    let count = 0\\n    \\n    for (const [a, b] of dominoes) {\\n        const min = Math.min(a, b)\\n        const max = Math.max(a, b)\\n        const key = min + \"#\" + max\\n        if (!map.has(key)) map.set(key, 0)\\n        count += map.get(key)\\n        map.set(key, map.get(key) + 1)\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    const map = new Map()\\n    let count = 0\\n    \\n    for (const [a, b] of dominoes) {\\n        const min = Math.min(a, b)\\n        const max = Math.max(a, b)\\n        const key = min + \"#\" + max\\n        if (!map.has(key)) map.set(key, 0)\\n        count += map.get(key)\\n        map.set(key, map.get(key) + 1)\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553652,
                "title": "rust-4ms",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn num_equiv_domino_pairs(mut dominoes: Vec<Vec<i32>>) -> i32 {\\n    let mut map: HashMap<i32, i32> = HashMap::new();\\n    for d in &mut dominoes {\\n      d.sort();\\n      *map.entry(d[0] * 10 + d[1]).or_default() += 1;\\n    }\\n    map.values().fold(0, |s, &v| s + v * (v - 1) / 2)\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn num_equiv_domino_pairs(mut dominoes: Vec<Vec<i32>>) -> i32 {\\n    let mut map: HashMap<i32, i32> = HashMap::new();\\n    for d in &mut dominoes {\\n      d.sort();\\n      *map.entry(d[0] * 10 + d[1]).or_default() += 1;\\n    }\\n    map.values().fold(0, |s, &v| s + v * (v - 1) / 2)\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550585,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:                \\n        return sum((v-1)*v//2 for v in collections.Counter([tuple(sorted(x)) for x in dominoes]).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:                \\n        return sum((v-1)*v//2 for v in collections.Counter([tuple(sorted(x)) for x in dominoes]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538380,
                "title": "java-rewrite-hashcode-and-equals-method",
                "content": "This is not a concise method but a way to use hashCode and equals to solve the problem. The reason is that hashCode of int[] cannot be used to compare int[]. \\n\\n```\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            int result = 10;\\n            result = x * result + y;\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o == this) return true;\\n            if (!(o instanceof Point)) {\\n                return false;\\n            }\\n            Point p = (Point) o;\\n            return p.x == x && p.y == y;\\n        }\\n    }\\n\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        if (dominoes == null || dominoes.length == 0) {\\n            return 0;\\n        }\\n        Map<Point, Integer> hm = new HashMap<>();\\n        int res = 0;\\n        for (int[] key : dominoes) {\\n            Point point = new Point(key[0], key[1]);\\n            Point rPoint = new Point(key[1], key[0]);\\n            if (hm.containsKey(point)) {\\n                hm.put(point, hm.get(point) + 1);\\n            } else if(hm.containsKey(rPoint)) {\\n                hm.put(rPoint, hm.get(rPoint) + 1);\\n            } else {\\n                hm.put(point, 1);\\n            }\\n        }\\n        for (int v : hm.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            int result = 10;\\n            result = x * result + y;\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o == this) return true;\\n            if (!(o instanceof Point)) {\\n                return false;\\n            }\\n            Point p = (Point) o;\\n            return p.x == x && p.y == y;\\n        }\\n    }\\n\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        if (dominoes == null || dominoes.length == 0) {\\n            return 0;\\n        }\\n        Map<Point, Integer> hm = new HashMap<>();\\n        int res = 0;\\n        for (int[] key : dominoes) {\\n            Point point = new Point(key[0], key[1]);\\n            Point rPoint = new Point(key[1], key[0]);\\n            if (hm.containsKey(point)) {\\n                hm.put(point, hm.get(point) + 1);\\n            } else if(hm.containsKey(rPoint)) {\\n                hm.put(rPoint, hm.get(rPoint) + 1);\\n            } else {\\n                hm.put(point, 1);\\n            }\\n        }\\n        for (int v : hm.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522533,
                "title": "kotlin-solution-in-3-lines",
                "content": "I would be submitting two versions of the code that could be simple and small which would result in the solution.\\nSolution1:\\n```\\ndominoes.groupBy { it.min() to it.max() }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```\\nSolution2:\\n```\\ndominoes.groupBy { maxOf(it[0], it[1]) * 10 + minOf(it[0], it[1]) }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```",
                "solutionTags": [],
                "code": "```\\ndominoes.groupBy { it.min() to it.max() }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```\n```\\ndominoes.groupBy { maxOf(it[0], it[1]) * 10 + minOf(it[0], it[1]) }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501941,
                "title": "very-slow-but-work-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dom) {\\n  let count = 0;\\n  \\n  for (let i = 0; i < dom.length; i++) {\\n    for (let j = i + 1; j < dom.length; j++) {\\n      if (dom[i][0] === dom[j][0] && dom[i][1] === dom[j][1] ||\\n          dom[i][0] === dom[j][1] && dom[i][1] === dom[j][0]) count++;\\n    }\\n  }\\n  \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dom) {\\n  let count = 0;\\n  \\n  for (let i = 0; i < dom.length; i++) {\\n    for (let j = i + 1; j < dom.length; j++) {\\n      if (dom[i][0] === dom[j][0] && dom[i][1] === dom[j][1] ||\\n          dom[i][0] === dom[j][1] && dom[i][1] === dom[j][0]) count++;\\n    }\\n  }\\n  \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476594,
                "title": "python-double-100",
                "content": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dic = [0]*100\\n        for i, j in dominoes:\\n            if i > j:\\n                i, j = j, i\\n            dic[i*10+j] += 1 \\n        res = 0\\n        for i in range(11,100):\\n            if dic[i] > 1:\\n                res += (dic[i]-1)*dic[i]/2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dic = [0]*100\\n        for i, j in dominoes:\\n            if i > j:\\n                i, j = j, i\\n            dic[i*10+j] += 1 \\n        res = 0\\n        for i in range(11,100):\\n            if dic[i] > 1:\\n                res += (dic[i]-1)*dic[i]/2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466249,
                "title": "swift-code-o-n-space-and-time-complexity-solution",
                "content": "```\\nclass Solution {\\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var dict = [String: Int](), count = 0\\n        for pairs in dominoes{\\n            let minimum: Int = min(pairs[0], pairs[1])\\n            let maximum: Int = max(pairs[0], pairs[1])\\n            let number = String(\"\\\\(minimum)\\\\(maximum)\")\\n            if let occurance = dict[number]{\\n                dict[number] = occurance + 1\\n                count += dict[number]!\\n            }else{\\n                dict[number] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var dict = [String: Int](), count = 0\\n        for pairs in dominoes{\\n            let minimum: Int = min(pairs[0], pairs[1])\\n            let maximum: Int = max(pairs[0], pairs[1])\\n            let number = String(\"\\\\(minimum)\\\\(maximum)\")\\n            if let occurance = dict[number]{\\n                dict[number] = occurance + 1\\n                count += dict[number]!\\n            }else{\\n                dict[number] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462146,
                "title": "go-98-solution",
                "content": "```go\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tmagic := map[[2]int]int{}\\n\\tfor i := range dominoes {\\n\\t\\tsort.Ints(dominoes[i])\\n\\t\\tmagic[[2]int{dominoes[i][0], dominoes[i][1]}]++\\n\\t}\\n\\n\\tdominoPairCount := 0\\n\\tfor _, v := range magic {\\n\\t\\tdominoPairCount += helper(v)\\n\\t}\\n\\treturn dominoPairCount\\n}\\n\\nfunc helper(n int) int  {\\n\\tif n < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\tn *= n-1\\n\\treturn n / 2\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tmagic := map[[2]int]int{}\\n\\tfor i := range dominoes {\\n\\t\\tsort.Ints(dominoes[i])\\n\\t\\tmagic[[2]int{dominoes[i][0], dominoes[i][1]}]++\\n\\t}\\n\\n\\tdominoPairCount := 0\\n\\tfor _, v := range magic {\\n\\t\\tdominoPairCount += helper(v)\\n\\t}\\n\\treturn dominoPairCount\\n}\\n\\nfunc helper(n int) int  {\\n\\tif n < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\tn *= n-1\\n\\treturn n / 2\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454287,
                "title": "python3-two-methods-using-hash-table-and-itertools-combinations",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tht = {}\\n\\t\\tfor dom in dominoes:\\n\\t\\t\\tht[tuple(sorted(dom))] = ht.get(tuple(sorted(dom)),0) + 1\\n\\t\\tcount = 0\\n\\t\\tfor pair in ht:\\n\\t\\t\\tcount += ht[pair]*(ht[pair]-1)//2\\n\\t\\treturn count\\n\\nclass Solution1:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tif len(dominoes) <= 1:\\n\\t\\t\\treturn 0\\n\\n\\t\\tcombs = [x for x in itertools.combinations(dominoes,2)]\\n\\t\\tcount = 0\\n\\t\\tfor item in combs:\\n\\t\\t\\tif min(item[0]) == min(item[1]) and max(item[0]) == max(item[1]):\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tht = {}\\n\\t\\tfor dom in dominoes:\\n\\t\\t\\tht[tuple(sorted(dom))] = ht.get(tuple(sorted(dom)),0) + 1\\n\\t\\tcount = 0\\n\\t\\tfor pair in ht:\\n\\t\\t\\tcount += ht[pair]*(ht[pair]-1)//2\\n\\t\\treturn count\\n\\nclass Solution1:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tif len(dominoes) <= 1:\\n\\t\\t\\treturn 0\\n\\n\\t\\tcombs = [x for x in itertools.combinations(dominoes,2)]\\n\\t\\tcount = 0\\n\\t\\tfor item in combs:\\n\\t\\t\\tif min(item[0]) == min(item[1]) and max(item[0]) == max(item[1]):\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450685,
                "title": "bruteforce-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int numEquivDominoPairs(int[][] d) {\\n\\t\\t\\tint[] visit= new int[d.length];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<d.length;i++){\\n\\t\\t\\t\\tans=fn(d,i,visit,ans);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tpublic int fn(int[][] d, int x,int[] visit, int ans){\\n\\t\\t\\tint count=0;\\n\\t\\t\\tif(visit[x]==0){   \\n\\t\\t\\t\\tvisit[x]=1;\\n\\t\\t\\t\\tfor(int i=0;i<d.length; i++){\\n\\t\\t\\t\\t\\tif(visit[i]==0){\\n\\t\\t\\t\\t\\t\\tif(d[x][0]==d[i][0]&&d[x][1]==d[i][1]){\\n\\t\\t\\t\\t\\t\\t\\tvisit[i]=1;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}else if(d[x][1]==d[i][0]&&d[x][0]==d[i][1]){\\n\\t\\t\\t\\t\\t\\t\\t visit[i]=1;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tans=ans+((count)*(count+1))/2;\\n\\t\\t\\t}  \\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int numEquivDominoPairs(int[][] d) {\\n\\t\\t\\tint[] visit= new int[d.length];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<d.length;i++){\\n\\t\\t\\t\\tans=fn(d,i,visit,ans);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 444487,
                "title": "python-hashmap-100-100",
                "content": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        maps = {}\\n        count = 0\\n        for i in dominoes:\\n            if (i[0],i[1]) not in maps and  (i[1],i[0]) not in maps:\\n                maps[(i[0],i[1])] = 1\\n            else:\\n                if (i[0],i[1]) in maps:\\n                    maps[(i[0],i[1])] += 1\\n                else:\\n                    maps[(i[1],i[0])] += 1\\n        count = 0\\n        for i in maps:\\n            if maps[i] >= 2:\\n                count += maps[i] * (maps[i]-1)//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        maps = {}\\n        count = 0\\n        for i in dominoes:\\n            if (i[0],i[1]) not in maps and  (i[1],i[0]) not in maps:\\n                maps[(i[0],i[1])] = 1\\n            else:\\n                if (i[0],i[1]) in maps:\\n                    maps[(i[0],i[1])] += 1\\n                else:\\n                    maps[(i[1],i[0])] += 1\\n        count = 0\\n        for i in maps:\\n            if maps[i] >= 2:\\n                count += maps[i] * (maps[i]-1)//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427312,
                "title": "hashmap-easy-to-uderstand-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        map<pair<int,int>,int> mp;\\n        int cnt=0;\\n        for(auto& x:dominoes)\\n        {\\n            int a=min(x[0],x[1]);\\n            int b=max(x[0],x[1]);\\n            cnt+=mp[{a,b}]++;\\n        }\\n        \\n       \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        map<pair<int,int>,int> mp;\\n        int cnt=0;\\n        for(auto& x:dominoes)\\n        {\\n            int a=min(x[0],x[1]);\\n            int b=max(x[0],x[1]);\\n            cnt+=mp[{a,b}]++;\\n        }\\n        \\n       \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407991,
                "title": "java-o-n-method-using-hashmap",
                "content": "```\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\tMap<String, Integer> dominoToFrequency = new HashMap<>();\\n\\t\\tint count = 0;\\n\\t\\tfor(int[] domino : dominoes) {\\n\\t\\t\\tString key = \"\" + Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1]);\\n\\t\\t\\tdominoToFrequency.put(key, dominoToFrequency.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(Map.Entry<String, Integer> domino : dominoToFrequency.entrySet()) {\\n\\t\\t\\tint n = domino.getValue();\\n\\t\\t\\tif(n >= 2) {\\n\\t\\t\\t\\tcount += n*(n-1)/2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\tMap<String, Integer> dominoToFrequency = new HashMap<>();\\n\\t\\tint count = 0;\\n\\t\\tfor(int[] domino : dominoes) {\\n\\t\\t\\tString key = \"\" + Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1]);\\n\\t\\t\\tdominoToFrequency.put(key, dominoToFrequency.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(Map.Entry<String, Integer> domino : dominoToFrequency.entrySet()) {\\n\\t\\t\\tint n = domino.getValue();\\n\\t\\t\\tif(n >= 2) {\\n\\t\\t\\t\\tcount += n*(n-1)/2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407141,
                "title": "easy-java-o-n",
                "content": "```\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] count  =  new int[10][10];\\n        int ans = 0;\\n        for (int[] dominoe : dominoes) {\\n            ans += count[dominoe[0]][dominoe[1]];\\n            if(dominoe[0] != dominoe[1]) {\\n                ans += count[dominoe[1]][dominoe[0]];\\n            }\\n            count[dominoe[0]][dominoe[1]]++;\\n   \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] count  =  new int[10][10];\\n        int ans = 0;\\n        for (int[] dominoe : dominoes) {\\n            ans += count[dominoe[0]][dominoe[1]];\\n            if(dominoe[0] != dominoe[1]) {\\n                ans += count[dominoe[1]][dominoe[0]];\\n            }\\n            count[dominoe[0]][dominoe[1]]++;\\n   \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391994,
                "title": "python-easy-understading",
                "content": "```\\ndic = {}\\nfor dominoe in dominoes:\\n\\ttmp = max(dominoe)*10 + min(dominoe)\\n\\tif tmp in dic: dic[tmp] += 1\\n\\telse: dic[tmp] = 0\\n\\nres = 0\\nfor ele in dic:\\n\\tres += dic[ele]*(dic[ele]+1)//2\\n\\nreturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndic = {}\\nfor dominoe in dominoes:\\n\\ttmp = max(dominoe)*10 + min(dominoe)\\n\\tif tmp in dic: dic[tmp] += 1\\n\\telse: dic[tmp] = 0\\n\\nres = 0\\nfor ele in dic:\\n\\tres += dic[ele]*(dic[ele]+1)//2\\n\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378223,
                "title": "java-o-n-time-o-n-space",
                "content": "Approach 1: For each domino, look for all domions to the right, and count all such pairs. Time: O(n^2), Space: O(1)  \\n\\nApproach 2: Sort the dominoes so that all equivalent dominos come together. For this make one pass to fix all such dominos where domino[0] > domino[1]. So each domino will have domino[0] <= domino[1]. After sorting count the equal domino pairs. Time: O(nlogn), Space: O(1) \\n\\nApproach 3: Use hashing. Time: O(n), Space: O(1)\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();  \\n        int count = 0; \\n        for(int[] d : dominoes) {\\n            int key = Math.min(d[0],d[1])*10 + Math.max(d[0],d[1]); \\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        for(int v : map.values()) count += v*(v-1)/2; \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();  \\n        int count = 0; \\n        for(int[] d : dominoes) {\\n            int key = Math.min(d[0],d[1])*10 + Math.max(d[0],d[1]); \\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        for(int v : map.values()) count += v*(v-1)/2; \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378146,
                "title": "python-o-n-with-frozenset",
                "content": "A lot of other solutions encode an entry with something like `min(a, b) + 10 * max(a, b)`. My first thought was to use a `Set`. However, `Set` in Python is not hashable. I ended up using a `frozenset` and a `dictionary`.\\n\\nEnjoy!\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dominoes_count = 0\\n        sets = {}\\n        for pair in dominoes:\\n            this_set = frozenset(pair)\\n            if this_set in sets:\\n                dominoes_count += sets[this_set]\\n                sets[this_set] += 1\\n            else:\\n                sets[this_set] = 1\\n        return dominoes_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dominoes_count = 0\\n        sets = {}\\n        for pair in dominoes:\\n            this_set = frozenset(pair)\\n            if this_set in sets:\\n                dominoes_count += sets[this_set]\\n                sets[this_set] += 1\\n            else:\\n                sets[this_set] = 1\\n        return dominoes_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377910,
                "title": "python-o-n-time-o-n-memory-2-pass-solution",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dict = {}\\n        res = 0\\n        for domino in dominoes:\\n            if domino[0] > domino[1]:\\n                val = tuple([domino[1], domino[0]])\\n            else:\\n                val = tuple(domino)\\n            freq = dict.get(val, 0) + 1\\n            dict[val] = freq\\n        for key in dict:\\n            res += dict[key]*(dict[key] - 1)//2\\n        return res\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 372149,
                "title": "easy-c-solution-using-maps-beats-88-100",
                "content": "Runtime: 40 ms\\nMemory Usage: 20.9 MB\\n\\n```\\nint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        \\n        int n = dominoes.size();\\n        map<pair<int,int>, int> mp;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int minVal = min(dominoes[i][0], dominoes[i][1]);\\n            int maxVal = max(dominoes[i][0], dominoes[i][1]);\\n            \\n            pair<int, int> newEntry{minVal, maxVal};\\n            \\n            if(mp.find(newEntry) != mp.end())\\n            {\\n                count += mp[newEntry];\\n                mp[newEntry]++;\\n            }\\n            else\\n                mp.insert({newEntry, 1});\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Runtime: 40 ms\\nMemory Usage: 20.9 MB\\n\\n```\\nint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        \\n        int n = dominoes.size();\\n        map<pair<int,int>, int> mp;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int minVal = min(dominoes[i][0], dominoes[i][1]);\\n            int maxVal = max(dominoes[i][0], dominoes[i][1]);\\n            \\n            pair<int, int> newEntry{minVal, maxVal};\\n            \\n            if(mp.find(newEntry) != mp.end())\\n            {\\n                count += mp[newEntry];\\n                mp[newEntry]++;\\n            }\\n            else\\n                mp.insert({newEntry, 1});\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 367870,
                "title": "python",
                "content": "```\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n      a = set()\\n      dic = {}\\n      for dom in dominoes:\\n          temp = sorted(dom)\\n          if (temp[0], temp[1]) in dic:\\n              dic[(temp[0], temp[1])] +=  1\\n          else:\\n              dic[(temp[0], temp[1])] =  1\\n       \\n      res = 0\\n      for key, values in dic.items():\\n          if values > 1:\\n              values = values - 1\\n              while values > 0:\\n                  res += values \\n                  values -= 1\\n      return res\\n\\t \\n```",
                "solutionTags": [],
                "code": "```\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n      a = set()\\n      dic = {}\\n      for dom in dominoes:\\n          temp = sorted(dom)\\n          if (temp[0], temp[1]) in dic:\\n              dic[(temp[0], temp[1])] +=  1\\n          else:\\n              dic[(temp[0], temp[1])] =  1\\n       \\n      res = 0\\n      for key, values in dic.items():\\n          if values > 1:\\n              values = values - 1\\n              while values > 0:\\n                  res += values \\n                  values -= 1\\n      return res\\n\\t \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 356136,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] d) {\\n        \\n        Map<Integer, Integer> map = new HashMap();\\n        for (int[] x : d)\\n        {\\n            Arrays.sort(x);\\n            int sig = x[0] * 10 + x[1];\\n            map.put(sig, map.getOrDefault(sig, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for (int c : map.values())\\n        {\\n            if (c >= 2)\\n            {\\n                count += c * (c - 1) / 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] d) {\\n        \\n        Map<Integer, Integer> map = new HashMap();\\n        for (int[] x : d)\\n        {\\n            Arrays.sort(x);\\n            int sig = x[0] * 10 + x[1];\\n            map.put(sig, map.getOrDefault(sig, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for (int c : map.values())\\n        {\\n            if (c >= 2)\\n            {\\n                count += c * (c - 1) / 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354782,
                "title": "go-hashing-o-n-beats-100-space",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    hash, pairs := make(map[string]int), 0\\n    for _, d := range dominoes {\\n        // generate key and reverse key\\n        key, revKey := fmt.Sprintf(\"%v:%v\",d[0],d[1]), fmt.Sprintf(\"%v:%v\",d[1],d[0])\\n        // look for previous pair\\n        if occurs, exists := hash[key]; exists {\\n            pairs += occurs\\n        }\\n        // count occurance\\n        hash[key]++\\n        if d[0] != d[1] {   // prevent [1,1] from double counting\\n            hash[revKey]++\\n        }\\n        \\n    }\\n    return pairs\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    hash, pairs := make(map[string]int), 0\\n    for _, d := range dominoes {\\n        // generate key and reverse key\\n        key, revKey := fmt.Sprintf(\"%v:%v\",d[0],d[1]), fmt.Sprintf(\"%v:%v\",d[1],d[0])\\n        // look for previous pair\\n        if occurs, exists := hash[key]; exists {\\n            pairs += occurs\\n        }\\n        // count occurance\\n        hash[key]++\\n        if d[0] != d[1] {   // prevent [1,1] from double counting\\n            hash[revKey]++\\n        }\\n        \\n    }\\n    return pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354732,
                "title": "easy-understand-c-solution",
                "content": "For each pair, make sure v[0] > v[1] and use v[0] * 10 + v[1] to represent it. \\n\\nLoop the vector and use hashmap to store each kind of equivalent pair numbers. \\n\\nWe can count the answer while looping, If preiously the number of [1, 0] is n for example, if a new [1,0] equivalent piar is find, then the ans will increased by n\\n\\n```\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> m;\\n        int rv = 0;\\n        for (auto &v : dominoes) {\\n            if (v[0] < v[1]) {\\n                swap(v[0], v[1]);\\n            }\\n            int i = v[0] * 10 + v[1];\\n            rv += m[i];\\n            ++m[i];\\n        }\\n        return rv;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> m;\\n        int rv = 0;\\n        for (auto &v : dominoes) {\\n            if (v[0] < v[1]) {\\n                swap(v[0], v[1]);\\n            }\\n            int i = v[0] * 10 + v[1];\\n            rv += m[i];\\n            ++m[i];\\n        }\\n        return rv;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347629,
                "title": "java-o-n-time-o-n-space-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String,Integer> map = new HashMap();\\n        int ans=0;\\n        for(int[] each: dominoes){\\n            String x = each[0]<each[1] ? each[0]+\",\"+each[1] : each[1]+\",\"+each[0];\\n           if(!map.containsKey(x)){\\n                map.put(x,0);\\n           }\\n           int count=map.get(x);\\n            map.put(x,count+1);\\n          }\\n          for(Map.Entry<String,Integer> curr:map.entrySet()){\\n                int cuCo=curr.getValue();\\n                ans+= (cuCo*(cuCo-1))/2;\\n            }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String,Integer> map = new HashMap();\\n        int ans=0;\\n        for(int[] each: dominoes){\\n            String x = each[0]<each[1] ? each[0]+\",\"+each[1] : each[1]+\",\"+each[0];\\n           if(!map.containsKey(x)){\\n                map.put(x,0);\\n           }\\n           int count=map.get(x);\\n            map.put(x,count+1);\\n          }\\n          for(Map.Entry<String,Integer> curr:map.entrySet()){\\n                int cuCo=curr.getValue();\\n                ans+= (cuCo*(cuCo-1))/2;\\n            }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340718,
                "title": "java-super-simple-and-clean-9-line-o-n-solution-beats-100-time-and-100-space",
                "content": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++) {\\n            int tmp=10*Math.min(dominoes[i][0], dominoes[i][1])+Math.max(dominoes[i][0], dominoes[i][1]);\\n            if(map.containsKey(tmp)) map.put(tmp, map.get(tmp)+1);\\n            else map.put(tmp, 1);\\n        }\\n        int res=0;\\n        for(int i : map.values()) res+=i*(i-1)/2;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++) {\\n            int tmp=10*Math.min(dominoes[i][0], dominoes[i][1])+Math.max(dominoes[i][0], dominoes[i][1]);\\n            if(map.containsKey(tmp)) map.put(tmp, map.get(tmp)+1);\\n            else map.put(tmp, 1);\\n        }\\n        int res=0;\\n        for(int i : map.values()) res+=i*(i-1)/2;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 340324,
                "title": "c-solution-o-n",
                "content": "```\\npublic class Solution \\n{\\n    public int NumEquivDominoPairs(int[][] dominoes) \\n    {\\n        var dict = new Dictionary<string, int>();\\n        int sum = 0;\\n        foreach(var d in dominoes)\\n        {\\n            var key = d[0] < d[1] ? d[0] + \":\" + d[1] : d[1] + \":\" + d[0];\\n            if(!dict.ContainsKey(key)) dict[key] = 1;\\n            else sum += dict[key]++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NumEquivDominoPairs(int[][] dominoes) \\n    {\\n        var dict = new Dictionary<string, int>();\\n        int sum = 0;\\n        foreach(var d in dominoes)\\n        {\\n            var key = d[0] < d[1] ? d[0] + \":\" + d[1] : d[1] + \":\" + d[0];\\n            if(!dict.ContainsKey(key)) dict[key] = 1;\\n            else sum += dict[key]++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340252,
                "title": "the-description-is-wrong-isn-t-it",
                "content": "Initially I write my code according to my comprehension about the description, the test result confuses me. Then I read you guys\\' post, I think the description doesn\\'t match what this problem really want us to do.\\n\\n**Let\\'s look at the description:**\\n###### Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.\\n###### \\n###### Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\\n\\nFristly, it demands that a qualified pair (i, j) should satisfy 0<= i < j < length, notice that it\\'s strictly smaller, shouldn\\'t include i <= j.\\nSecondly, for a qualified pair (i,j), it asks us to make sure that dominoes[i] is supposed to be equivalent to dominoes[j]. a.k.a. the i th element of the input dominoes should be identical or can be rotated to j th element. \\n\\n(I assume that sequence starts from 1 instead of 0 given the example test case.) Look at the example test case:\\n###### Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]\\n###### Output: 1\\nAs far as I understand, the logic goes this way:\\n###### 1. The 1st element [1,2] satisfy 0<=i<j<length, and the ith element [1,2] is equivalent to the jth element [2,1], so the answer=0+1=1;\\n###### 2. The 2nd element [2,1] doesn\\'t satisfy 0<=i<j<length, we skip it;\\n###### 3. The 3rd element [3,4] satisfy 0<=i<j<length, but the ith element [3,4] is not equivaleng to the jth element [5,6], the answer remains 1;\\n###### 4. The 4th element doesn\\'t satisfy 0<=i<j<length cuz length=4, we skip it.\\nSo the result is 1.\\n\\nThus here\\'s what I submit in the first place:\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0, length=dominoes.size();\\n        for (auto domino : dominoes) {\\n            int first=domino[0]-1, second=domino[1]-1;\\n            if (first<second&&second<length) {\\n                if ((dominoes[first][0]==dominoes[second][0]&&\\n                        dominoes[first][1]==dominoes[second][1])\\n                    ||\\n                    (dominoes[first][0]==dominoes[second][1]&&\\n                        dominoes[first][1]==dominoes[second][0]))\\n                    ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\nBut it didn\\'t pass. Take this failed test case for example:\\n###### Input:\\n###### [[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\n###### Output:\\n###### 0\\n###### Expected:\\n###### 4\\nonly the 4th and 5th elements (i.e. [1,2]) satisfy 0<=i<j<length, let alone neither of them satisfy **dominoes[i] equals to dominoes[j]**.\\nI take a look at other users\\' post, then I figure out that correct answer\\'s logic is completely different from what the description asks for. For instance, from the most voted  post, he encodes each group of equivalent pairs with a 2-digit number and store the count appearance frequency of them in a hash map. I didn\\'t mean that this idea isn\\'t perspicacious, but that solution doesn\\'t filter out domino pair that doesn\\'t satisfy **0<=i<j<length**, it doesn\\'t has anything to do with whether the ith element is equal to the jth element either. What the judge system want us to write is simply not what the description told us, and I\\'m confused why I didn\\'t see anyone point this out.\\nIt might be possible that I misunderstood the description as well, I made the same mistake before. Although this is just a simple problem, the cognitive difference makes me uncomfortable. If there\\'s a clear vulnerability in my reading comprehension about the description, welcome to correct me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0, length=dominoes.size();\\n        for (auto domino : dominoes) {\\n            int first=domino[0]-1, second=domino[1]-1;\\n            if (first<second&&second<length) {\\n                if ((dominoes[first][0]==dominoes[second][0]&&\\n                        dominoes[first][1]==dominoes[second][1])\\n                    ||\\n                    (dominoes[first][0]==dominoes[second][1]&&\\n                        dominoes[first][1]==dominoes[second][0]))\\n                    ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340096,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        res = 0\\n        for i, j in dominoes:\\n            mi, ma = (i, j) if i <=j else (j, i)\\n            key = \\'%d_%d\\' % (mi, ma)\\n            if key not in d:\\n                d[key] = 0\\n            \\n            res += d[key]\\n            \\n            d[key] += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        res = 0\\n        for i, j in dominoes:\\n            mi, ma = (i, j) if i <=j else (j, i)\\n            key = \\'%d_%d\\' % (mi, ma)\\n            if key not in d:\\n                d[key] = 0\\n            \\n            res += d[key]\\n            \\n            d[key] += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340015,
                "title": "can-any-one-explain-the-problem",
                "content": "Consider below two scenarios:\\n\\n[[1,2],[2,1],[3,4],[5,6]]\\n[1,2] appears twice - expected result = 1\\nIt is repeated once\\n\\n[[1,2],[1,2],[1,1],[1,2],[2,2]]\\n[1,2] appears thrice - expected result = 3\\n\\nIn first case [[1,2] , [1,2]]  = count = 1\\nThen in second case [[1,2] ,[1,2] , [1,2]] count = 2\\nTotal count = 3\\n\\nI still can\\'t get significance of counting like this - it could have straightforward if result of first scenario= 2 & second = 3. Can any one explain more on this?\\n\\nAfter finishing the contest, Based on this, I got following solution (C#):\\n``` csharp\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        Dictionary<(int, int), int> frequency = new Dictionary<(int, int), int>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < dominoes.Length; i++)\\n        {\\n           int d1 = dominoes[i][0];\\n           int d2 = dominoes[i][1];\\n            \\n           if(d1 > d2)\\n           {\\n               int t = d2;\\n               d2 = d1;\\n               d1 = t;\\n           }\\n               \\n           if(frequency.ContainsKey((d1, d2)))\\n           {              \\n               count += frequency[(d1,d2)]++;\\n           }\\n           else\\n           {\\n               frequency[(d1,d2)] = 1;\\n           }           \\n        }        \\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` csharp\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        Dictionary<(int, int), int> frequency = new Dictionary<(int, int), int>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < dominoes.Length; i++)\\n        {\\n           int d1 = dominoes[i][0];\\n           int d2 = dominoes[i][1];\\n            \\n           if(d1 > d2)\\n           {\\n               int t = d2;\\n               d2 = d1;\\n               d1 = t;\\n           }\\n               \\n           if(frequency.ContainsKey((d1, d2)))\\n           {              \\n               count += frequency[(d1,d2)]++;\\n           }\\n           else\\n           {\\n               frequency[(d1,d2)] = 1;\\n           }           \\n        }        \\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340010,
                "title": "java-o-n-solution-with-constant-space",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t    // Construct an array to contain the number of occurrences of all possible ways of number combinations\\n        int[] ref = new int[45];\\n        int res = 0;\\n\\t\\t// Iterate through the dominoes and increment the number of occurrences accordingly\\n        for (int i = 0; i < dominoes.length; i++) {\\n            int[] thisArr = dominoes[i];\\n            int small = Math.min(thisArr[0], thisArr[1]);\\n            int big = Math.max(thisArr[0], thisArr[1]);\\n            ref[10 * (small - 1) + big - small * (small + 1) / 2] += 1;\\n        }\\n       // Number of pairs of dominoes by permutation\\n        for (int i = 0; i < ref.length; i++) {\\n            if (ref[i] > 1) {\\n                res += ref[i] * (ref[i] - 1) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t    // Construct an array to contain the number of occurrences of all possible ways of number combinations\\n        int[] ref = new int[45];\\n        int res = 0;\\n\\t\\t// Iterate through the dominoes and increment the number of occurrences accordingly\\n        for (int i = 0; i < dominoes.length; i++) {\\n            int[] thisArr = dominoes[i];\\n            int small = Math.min(thisArr[0], thisArr[1]);\\n            int big = Math.max(thisArr[0], thisArr[1]);\\n            ref[10 * (small - 1) + big - small * (small + 1) / 2] += 1;\\n        }\\n       // Number of pairs of dominoes by permutation\\n        for (int i = 0; i < ref.length; i++) {\\n            if (ref[i] > 1) {\\n                res += ref[i] * (ref[i] - 1) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566999,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1655925,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1733401,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1678200,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 2029928,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 2013665,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1944528,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1912272,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1715633,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Servers That Handled Most Number of Requests",
        "question_content": "<p>You have <code>k</code> servers numbered from <code>0</code> to <code>k-1</code> that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but <strong>cannot handle more than one request at a time</strong>. The requests are assigned to servers according to a specific algorithm:</p>\n\n<ul>\n\t<li>The <code>i<sup>th</sup></code> (0-indexed) request arrives.</li>\n\t<li>If all servers are busy, the request is dropped (not handled at all).</li>\n\t<li>If the <code>(i % k)<sup>th</sup></code> server is available, assign the request to that server.</li>\n\t<li>Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the <code>i<sup>th</sup></code> server is busy, try to assign the request to the <code>(i+1)<sup>th</sup></code> server, then the <code>(i+2)<sup>th</sup></code> server, and so on.</li>\n</ul>\n\n<p>You are given a <strong>strictly increasing</strong> array <code>arrival</code> of positive integers, where <code>arrival[i]</code> represents the arrival time of the <code>i<sup>th</sup></code> request, and another array <code>load</code>, where <code>load[i]</code> represents the load of the <code>i<sup>th</sup></code> request (the time it takes to complete). Your goal is to find the <strong>busiest server(s)</strong>. A server is considered <strong>busiest</strong> if it handled the most number of requests successfully among all the servers.</p>\n\n<p>Return <em>a list containing the IDs (0-indexed) of the <strong>busiest server(s)</strong></em>. You may return the IDs in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/08/load-1.png\" style=\"width: 389px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>Output:</strong> [1] \n<strong>Explanation:</strong> \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it&#39;s assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>Output:</strong> [0,1,2]\n<strong>Explanation:</strong> Each server handles a single request, so they are all considered the busiest.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code> is <strong>strictly increasing</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 876793,
                "title": "java-o-nlogn-use-both-treeset-and-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counter = new int[k];\\n        // use a tree to track available servers\\n        TreeSet<Integer> available = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            available.add(num);\\n        }\\n        // use a PQ to maintain the availability at current arrival time\\n        Queue<int[]> busyServers = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        \\n        for (int idx = 0; idx < arrival.length; idx++) {\\n            int curTime = arrival[idx];\\n            int endTime = curTime + load[idx];\\n            while (!busyServers.isEmpty() && busyServers.peek()[0] <= curTime) {\\n                int freedServer = busyServers.poll()[1];\\n                available.add(freedServer);\\n            }\\n            if (available.size() == 0) continue; // all busy\\n            Integer assignNum = available.ceiling(idx % k);\\n            if (assignNum == null) {\\n                assignNum = available.first();\\n            }\\n            counter[assignNum]++;\\n            available.remove(assignNum);\\n            busyServers.offer(new int[] {endTime, assignNum});\\n        }\\n        \\n        return findMaxesInCounter(counter);\\n    }\\n    \\n    \\n    \\n    private List<Integer> findMaxesInCounter(int[] counter) {\\n        int max = 0;\\n        for (int i = 0; i < counter.length; i++) {\\n            max = Math.max(max, counter[i]);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] == max) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counter = new int[k];\\n        // use a tree to track available servers\\n        TreeSet<Integer> available = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            available.add(num);\\n        }\\n        // use a PQ to maintain the availability at current arrival time\\n        Queue<int[]> busyServers = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        \\n        for (int idx = 0; idx < arrival.length; idx++) {\\n            int curTime = arrival[idx];\\n            int endTime = curTime + load[idx];\\n            while (!busyServers.isEmpty() && busyServers.peek()[0] <= curTime) {\\n                int freedServer = busyServers.poll()[1];\\n                available.add(freedServer);\\n            }\\n            if (available.size() == 0) continue; // all busy\\n            Integer assignNum = available.ceiling(idx % k);\\n            if (assignNum == null) {\\n                assignNum = available.first();\\n            }\\n            counter[assignNum]++;\\n            available.remove(assignNum);\\n            busyServers.offer(new int[] {endTime, assignNum});\\n        }\\n        \\n        return findMaxesInCounter(counter);\\n    }\\n    \\n    \\n    \\n    private List<Integer> findMaxesInCounter(int[] counter) {\\n        int max = 0;\\n        for (int i = 0; i < counter.length; i++) {\\n            max = Math.max(max, counter[i]);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] == max) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876883,
                "title": "python-using-only-heaps",
                "content": "Solution using three heaps. First heap is used to quickly free up the nodes. Then we split the servers to those that come after the `server_id` which is current server and those that come before, for loopback.\\n```\\ndef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\tbusy_jobs = []  # heap (job_end_time, node) to free up the nodes quickly\\n\\tafter = [] # heap (nodes) free after current server\\n\\tbefore = list(range(k))  # heap (nodes) to use for loopback\\n\\trequests_handled = [0] * k\\n\\n\\tfor i, (arrvl, ld) in enumerate(zip(arrival, load)):\\n\\t\\tserver_id = i % k\\n\\t\\tif server_id == 0:  # loopback\\n\\t\\t\\tafter = before\\n\\t\\t\\tbefore = []\\n\\n\\t\\twhile busy_jobs and busy_jobs[0][0] <= arrvl:\\n\\t\\t\\tfreed_node = heapq.heappop(busy_jobs)[1]\\n\\t\\t\\tif freed_node < server_id: heapq.heappush(before, freed_node)\\n\\t\\t\\telse: heapq.heappush(after, freed_node)\\n\\n\\t\\tuse_queue = after if after else before\\n\\t\\tif not use_queue: continue  # request dropped\\n\\t\\tusing_node = heapq.heappop(use_queue)\\n\\t\\trequests_handled[using_node] += 1\\n\\t\\theapq.heappush(busy_jobs, (arrvl + ld, using_node))\\n\\n\\tmaxreqs = max(requests_handled)\\n\\treturn [i for i, handled in enumerate(requests_handled) if handled == maxreqs]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\tbusy_jobs = []  # heap (job_end_time, node) to free up the nodes quickly\\n\\tafter = [] # heap (nodes) free after current server\\n\\tbefore = list(range(k))  # heap (nodes) to use for loopback\\n\\trequests_handled = [0] * k\\n\\n\\tfor i, (arrvl, ld) in enumerate(zip(arrival, load)):\\n\\t\\tserver_id = i % k\\n\\t\\tif server_id == 0:  # loopback\\n\\t\\t\\tafter = before\\n\\t\\t\\tbefore = []\\n\\n\\t\\twhile busy_jobs and busy_jobs[0][0] <= arrvl:\\n\\t\\t\\tfreed_node = heapq.heappop(busy_jobs)[1]\\n\\t\\t\\tif freed_node < server_id: heapq.heappush(before, freed_node)\\n\\t\\t\\telse: heapq.heappush(after, freed_node)\\n\\n\\t\\tuse_queue = after if after else before\\n\\t\\tif not use_queue: continue  # request dropped\\n\\t\\tusing_node = heapq.heappop(use_queue)\\n\\t\\trequests_handled[using_node] += 1\\n\\t\\theapq.heappush(busy_jobs, (arrvl + ld, using_node))\\n\\n\\tmaxreqs = max(requests_handled)\\n\\treturn [i for i, handled in enumerate(requests_handled) if handled == maxreqs]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 963917,
                "title": "python-two-priorityqueue-back-and-forth-o-n-log-k",
                "content": "Idea is simple:\\n\\nUse a priority queue `available` to keep track of the available servers. When a server get a job, remove it from `available` and put it in another PriorityQueue `busy` whose priority is given by the done time. \\n\\nOn the arrival each job, check if any of the jobs in `busy` are done. If so, put them back in `available` with the **appropriate index**. So when the `i`-th job comes in, `min(available)` is at least `i`, at most `i+k-1`.\\n\\nNote that the length of `available` and `busy` are at most `k`. So the heaps are not too big and the complexity is O(n log k) -- every job goes in the priority queue `busy` once, goes out at most once, and when it goes out it go into `available` once.\\n\\nShort annotated version:\\n```\\nclass Solution:\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap\\n        busy = [] \\n        res = [0] * k\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap\\n        busy = [] \\n        res = [0] * k\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876804,
                "title": "c-circular-array-ordered-set-priority-queue-o-n-log-k-log-n-o-k",
                "content": "## **APPROACH**\\n> Do what it says\\n\\n## **TECHNIQUE**\\n> We use the popular technique for circular arrays making it a linear array (by copying itself) \\n\\nnew_servers = `0` to `2*k - 1`\\nwhere `i` and `i + k`th servers are the same\\nSo whenever we change the state of server we do it for both `i` and `i + k`\\n\\n**FOR NEXT FREE SERVER** after `i % k` \\nor \\nsmallest free server greater than `i` (circularly), we can do `free_servers.lower_bound(i%k) % k` \\nlast `%k` because `x = i_th` or `x = (i + k)_th` server map to the same `(x % k)_th server`\\n\\nFor freeing the servers you can use a `min_heap`\\n\\n## **TIME COMPLEXITY**\\n`O(N * (log K + log N))`\\n\\n## **SPACE COMPLEXITY**\\n`O(K + N)`\\n\\n**Note** There are better and cleaner solutions than this, you can still learn about the circular array technique which can be used on some other problems :)\\n\\n### **The Technique**\\nCircular array `[1, 2, 3, ... K]`\\nLinear array `[1, 2, 3, ... K, 1, 2, 3 ... K-1]`\\nfor this array each subarray of length K is a rotation of the circular array\\n\\n## **CODE CPP**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {\\n        set<int> free;\\n        int n = arr.size();\\n        for (int i = 0; i < 2*k - 1; i ++)\\n            free.insert(i);\\n        vector<int> cnt(k, 0);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        for (int i = 0; i < n; i ++)\\n        {\\n            int at = arr[i];\\n            int load = lo[i];\\n            while (!pq.empty() and pq.top().first <= at)\\n            {\\n                auto tt = pq.top();\\n                int server = tt.second;\\n                pq.pop();\\n                free.insert(server);\\n                free.insert(server + k);\\n            }\\n            if (!free.empty()) {\\n                int server = (*free.lower_bound(i % k)) % k;\\n                free.erase(server % k);\\n                free.erase(server % k + k);\\n\\n                cnt[server] ++;\\n                pq.push({at + load, server});\\n            }\\n        }\\n        int mv = -1;\\n        vector<int> res;\\n        for (int i = 0; i < k; i ++)\\n        {\\n            if (cnt[i] > mv)\\n            {\\n                mv = cnt[i];\\n                res = {i};\\n            }\\n            else if (cnt[i] == mv)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {\\n        set<int> free;\\n        int n = arr.size();\\n        for (int i = 0; i < 2*k - 1; i ++)\\n            free.insert(i);\\n        vector<int> cnt(k, 0);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        for (int i = 0; i < n; i ++)\\n        {\\n            int at = arr[i];\\n            int load = lo[i];\\n            while (!pq.empty() and pq.top().first <= at)\\n            {\\n                auto tt = pq.top();\\n                int server = tt.second;\\n                pq.pop();\\n                free.insert(server);\\n                free.insert(server + k);\\n            }\\n            if (!free.empty()) {\\n                int server = (*free.lower_bound(i % k)) % k;\\n                free.erase(server % k);\\n                free.erase(server % k + k);\\n\\n                cnt[server] ++;\\n                pq.push({at + load, server});\\n            }\\n        }\\n        int mv = -1;\\n        vector<int> res;\\n        for (int i = 0; i < k; i ++)\\n        {\\n            if (cnt[i] > mv)\\n            {\\n                mv = cnt[i];\\n                res = {i};\\n            }\\n            else if (cnt[i] == mv)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876998,
                "title": "c-map",
                "content": "#### Intuition\\nWe need to avoid scanning through `k` servers for every request. So, instead looping through requests, we will loop through servers and take all requests that are available (not picked up by previous servers) and can be handled.\\n\\n#### Solution\\nFor each server, we track when it becomes available (`avail`), and also the count `cnt` of executed requests. We will use that count in the end to determine the busiest server.\\n\\nFor a current server `i % k`, we add request `i` to the list of available requests. If we can process that request, we remove it from the queue. If not - that request will become available for the next server to pick up. We will pick an earlier request first - to ensure that a request is processed by the first available server.\\n\\nHere, we are using ordered map to \\'queue\\' available requests, so it\\'s efficient to find requests that the current server can process. We can further optimize by removing \\'dropped\\' requests.\\n\\n**C++**\\n```cpp\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> cnt(k), avail(k), res;\\n    map<int, int> m;\\n    for (int i = 0, last_i = 0; ; ++i) {\\n        if (i < arrival.size())\\n            m[arrival[i]] = load[i];\\n        else if (i - last_i > k)\\n            break;\\n        auto it = m.lower_bound(avail[i % k]);\\n        while (it != end(m)) {\\n            last_i = i;\\n            ++cnt[i % k];\\n            avail[i % k] = it->first + it->second;\\n            m.erase(it);\\n            it = m.lower_bound(avail[i % k]);\\n        }\\n    }\\n    int max_req = *max_element(begin(cnt), end(cnt));\\n    for (int i = 0; i < k; ++i)\\n        if(cnt[i] == max_req)\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> cnt(k), avail(k), res;\\n    map<int, int> m;\\n    for (int i = 0, last_i = 0; ; ++i) {\\n        if (i < arrival.size())\\n            m[arrival[i]] = load[i];\\n        else if (i - last_i > k)\\n            break;\\n        auto it = m.lower_bound(avail[i % k]);\\n        while (it != end(m)) {\\n            last_i = i;\\n            ++cnt[i % k];\\n            avail[i % k] = it->first + it->second;\\n            m.erase(it);\\n            it = m.lower_bound(avail[i % k]);\\n        }\\n    }\\n    int max_req = *max_element(begin(cnt), end(cnt));\\n    for (int i = 0; i < k; ++i)\\n        if(cnt[i] == max_req)\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876803,
                "title": "python-folks-heavily-commented-you-might-learn-something-new-here-about-sortedcontainers",
                "content": "DataStructures Used : Priority Queue, SortedList\\nDocumentation of sorted list: \\nhttp://www.grantjenks.com/docs/sortedcontainers/sortedlist.html\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getNextServer(self, index , sortedAvailableServers):\\n        nextIndexToRightOfServer = sortedAvailableServers.bisect_left(index)\\n        # Since We need to find next server availble greater than this index\\n        if nextIndexToRightOfServer != len(sortedAvailableServers):\\n            return sortedAvailableServers[nextIndexToRightOfServer]\\n        # No server greater than index found , means move in cycle and find the lowest avaiable server now\\n        lowestIdServerAvailable = sortedAvailableServers.bisect_left(0)\\n        return sortedAvailableServers[lowestIdServerAvailable]\\n                \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        heap = [] \\n        # This heap will be use to make servers as free , the first server to become free will be top element of heap\\n        \\n        sortedAvailableServers = SortedList([i for i in range(k)])      \\n        # This sorted available server list will be used to assign the load to new server , more comment in function \\n        \\n        count = collections.defaultdict(int)\\n        # This count dictionary will be used to record the count of request each server has handled, will be used in calculating result\\n        \\n        for i in range(len(arrival)):\\n            arrivalTime,loadTime = arrival[i], load[i]\\n            # ArrivalTime and loadTime , SimpleStuff\\n            \\n            # Check if any server has become free now, since top of heap will contain the first server which will get free\\n            # we just compare top server free time with currentTime and mark the server as free if possible\\n            while len(heap) > 0 and heap[0][0] <= arrivalTime:\\n                _,serverId = heapq.heappop(heap)\\n                # after marker this server free add it to list of free Servers\\n                sortedAvailableServers.add(serverId)\\n\\n            #Check for any server Available\\n            if len(sortedAvailableServers) == 0:\\n                # Drop this Request because no server available\\n                continue\\n            \\n            # Get the assigned serverId for this Request\\n            assignedServer = self.getNextServer(i%k,sortedAvailableServers)\\n            \\n            count[assignedServer] += 1 # increase requestcount of this server by 1\\n            sortedAvailableServers.remove(assignedServer) # remove this server from list of free server\\n            heapq.heappush(heap,(arrivalTime+loadTime,assignedServer)) # insert this server in heap with free time as arrivalTime+loadTime\\n        \\n        # get the max request servered by any server\\n        maxRequestServedCount = max(count.values())\\n        result = []\\n        \\n        #iterate and pick all servers which servered maxRequest\\n        for serverId in count:\\n            if count[serverId] == maxRequestServedCount:\\n                result.append(serverId)\\n\\n        return result\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getNextServer(self, index , sortedAvailableServers):\\n        nextIndexToRightOfServer = sortedAvailableServers.bisect_left(index)\\n        # Since We need to find next server availble greater than this index\\n        if nextIndexToRightOfServer != len(sortedAvailableServers):\\n            return sortedAvailableServers[nextIndexToRightOfServer]\\n        # No server greater than index found , means move in cycle and find the lowest avaiable server now\\n        lowestIdServerAvailable = sortedAvailableServers.bisect_left(0)\\n        return sortedAvailableServers[lowestIdServerAvailable]\\n                \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        heap = [] \\n        # This heap will be use to make servers as free , the first server to become free will be top element of heap\\n        \\n        sortedAvailableServers = SortedList([i for i in range(k)])      \\n        # This sorted available server list will be used to assign the load to new server , more comment in function \\n        \\n        count = collections.defaultdict(int)\\n        # This count dictionary will be used to record the count of request each server has handled, will be used in calculating result\\n        \\n        for i in range(len(arrival)):\\n            arrivalTime,loadTime = arrival[i], load[i]\\n            # ArrivalTime and loadTime , SimpleStuff\\n            \\n            # Check if any server has become free now, since top of heap will contain the first server which will get free\\n            # we just compare top server free time with currentTime and mark the server as free if possible\\n            while len(heap) > 0 and heap[0][0] <= arrivalTime:\\n                _,serverId = heapq.heappop(heap)\\n                # after marker this server free add it to list of free Servers\\n                sortedAvailableServers.add(serverId)\\n\\n            #Check for any server Available\\n            if len(sortedAvailableServers) == 0:\\n                # Drop this Request because no server available\\n                continue\\n            \\n            # Get the assigned serverId for this Request\\n            assignedServer = self.getNextServer(i%k,sortedAvailableServers)\\n            \\n            count[assignedServer] += 1 # increase requestcount of this server by 1\\n            sortedAvailableServers.remove(assignedServer) # remove this server from list of free server\\n            heapq.heappush(heap,(arrivalTime+loadTime,assignedServer)) # insert this server in heap with free time as arrivalTime+loadTime\\n        \\n        # get the max request servered by any server\\n        maxRequestServedCount = max(count.values())\\n        result = []\\n        \\n        #iterate and pick all servers which servered maxRequest\\n        for serverId in count:\\n            if count[serverId] == maxRequestServedCount:\\n                result.append(serverId)\\n\\n        return result\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877051,
                "title": "c-pq-set-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> result;\\n        unordered_map<int, int> serverReqCount;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        set<int> availableServers;\\n        \\n        //Assign the first k request to each server, add in PQ\\n        for(int i = 0; i < k && i < arrival.size(); i++)\\n        {\\n            pq.push({arrival[i] + load[i], i});\\n            serverReqCount[i]++;\\n        }\\n        \\n        for(int i = k; i < arrival.size(); i++)\\n        {\\n            if(availableServers.size() || (pq.size() && arrival[i] >= pq.top().first))\\n            {\\n                //Check if any other server got free.\\n                while(pq.size() && arrival[i] >= pq.top().first)\\n                {\\n                    //Add in to available list.\\n                    availableServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                \\n                //Find the first server in order.\\n                auto server = lower_bound(availableServers.begin(), availableServers.end(), i%k);\\n                \\n                //Roll over if no server found.\\n                if(server == availableServers.end())\\n                    server = availableServers.begin();\\n                \\n                //Update the ds.\\n                serverReqCount[*server]++;\\n                pq.push({arrival[i]+load[i], *server});                    \\n                \\n                //Remove from available list.\\n                availableServers.erase(server);                    \\n            }\\n        }\\n        \\n        \\n        //Get the max\\n        int maxr = INT_MIN;\\n        for(auto& sc: serverReqCount)\\n            maxr = max(maxr, sc.second);\\n        \\n        \\n        //There can be multiple servers with same req count.\\n        for(auto& sc: serverReqCount)\\n        {\\n            if(sc.second == maxr)\\n                result.push_back(sc.first);\\n        }\\n            \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> result;\\n        unordered_map<int, int> serverReqCount;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        set<int> availableServers;\\n        \\n        //Assign the first k request to each server, add in PQ\\n        for(int i = 0; i < k && i < arrival.size(); i++)\\n        {\\n            pq.push({arrival[i] + load[i], i});\\n            serverReqCount[i]++;\\n        }\\n        \\n        for(int i = k; i < arrival.size(); i++)\\n        {\\n            if(availableServers.size() || (pq.size() && arrival[i] >= pq.top().first))\\n            {\\n                //Check if any other server got free.\\n                while(pq.size() && arrival[i] >= pq.top().first)\\n                {\\n                    //Add in to available list.\\n                    availableServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                \\n                //Find the first server in order.\\n                auto server = lower_bound(availableServers.begin(), availableServers.end(), i%k);\\n                \\n                //Roll over if no server found.\\n                if(server == availableServers.end())\\n                    server = availableServers.begin();\\n                \\n                //Update the ds.\\n                serverReqCount[*server]++;\\n                pq.push({arrival[i]+load[i], *server});                    \\n                \\n                //Remove from available list.\\n                availableServers.erase(server);                    \\n            }\\n        }\\n        \\n        \\n        //Get the max\\n        int maxr = INT_MIN;\\n        for(auto& sc: serverReqCount)\\n            maxr = max(maxr, sc.second);\\n        \\n        \\n        //There can be multiple servers with same req count.\\n        for(auto& sc: serverReqCount)\\n        {\\n            if(sc.second == maxr)\\n                result.push_back(sc.first);\\n        }\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089184,
                "title": "python3-summarizing-3-approaches",
                "content": "**Approach 1** - heap only \\nI was completely amazed to learn this solution from @warmr0bot in this [post](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps). Here, the trick is to relocate a freed server to a later place by circularly adjusting its index. In this way, when we are looking server `ii` at position `i` where `ii < i`, we will free `ii` to a place `ii + x*k` where `x` is enough so that `ii+x*k` bearly passes `i`. Mathematically, `i + (ii-i)%k` does the trick. \\n\\nImplementation \\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        busy = [] # min-heap\\n        free = list(range(k)) # min-heap \\n        freq = [0]*k\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                heappush(free, i + (ii - i) % k) # circularly relocate it\\n            if free: \\n                ii = heappop(free) % k \\n                freq[ii] += 1\\n                heappush(busy, (ta+tl, ii))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\\n\\n**Approach 2** - Fenwick tree\\nThis is my original approach, but it is really slow (8000+ms). Here, we use a Fenwick tree to label free servers and use binary search to locate the left-most free servers past a give index `i`. \\n\\n```\\nclass Fenwick: \\n\\tdef __init__(self, n: int):\\n\\t\\tself.nums = [0]*(n+1)\\n\\n\\tdef sum(self, k: int) -> int: \\n\\t\\t\"\"\"Return the sum of nums[:k].\"\"\"\\n\\t\\tans = 0\\n\\t\\twhile k:\\n\\t\\t\\tans += self.nums[k]\\n\\t\\t\\tk -= k & -k # unset last set bit \\n\\t\\treturn ans\\n\\n\\tdef add(self, k: int, x: int) -> None: \\n\\t\\tk += 1\\n\\t\\twhile k < len(self.nums): \\n\\t\\t\\tself.nums[k] += x\\n\\t\\t\\tk += k & -k \\n    \\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k # counter \\n        pq = [] # min-heap \\n        \\n        fw = Fenwick(k) # count of available servers \\n        for i in range(k): fw.add(i, 1) \\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            i %= k \\n            while pq and pq[0][0] <= ta: \\n                _, ii = heappop(pq) # release servers \\n                fw.add(ii, 1)\\n            \\n            if fw.sum(k):\\n                if fw.sum(k) - fw.sum(i): lo, hi, x = i, k, fw.sum(i)\\n                else: lo, hi, x = 0, i, 0\\n                \\n                while lo < hi: \\n                    mid = lo + hi >> 1\\n                    if fw.sum(mid) - x: hi = mid\\n                    else: lo = mid + 1\\n                fw.add(lo-1, -1)\\n                freq[lo-1] += 1\\n                heappush(pq, (ta+tl, lo-1))\\n                \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\\n\\n**Approach 3** - SortedList\\n`SortedList` is an interesting data structure of `sortedcontainers` which is an external library and doesn\\'t come with Python by default. I believe the underlying data structure is a balanced bst. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        busy = [] # min-heap\\n        free = list(range(k)) # min-heap \\n        freq = [0]*k\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                heappush(free, i + (ii - i) % k) # circularly relocate it\\n            if free: \\n                ii = heappop(free) % k \\n                freq[ii] += 1\\n                heappush(busy, (ta+tl, ii))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\n```\\nclass Fenwick: \\n\\tdef __init__(self, n: int):\\n\\t\\tself.nums = [0]*(n+1)\\n\\n\\tdef sum(self, k: int) -> int: \\n\\t\\t\"\"\"Return the sum of nums[:k].\"\"\"\\n\\t\\tans = 0\\n\\t\\twhile k:\\n\\t\\t\\tans += self.nums[k]\\n\\t\\t\\tk -= k & -k # unset last set bit \\n\\t\\treturn ans\\n\\n\\tdef add(self, k: int, x: int) -> None: \\n\\t\\tk += 1\\n\\t\\twhile k < len(self.nums): \\n\\t\\t\\tself.nums[k] += x\\n\\t\\t\\tk += k & -k \\n    \\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k # counter \\n        pq = [] # min-heap \\n        \\n        fw = Fenwick(k) # count of available servers \\n        for i in range(k): fw.add(i, 1) \\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            i %= k \\n            while pq and pq[0][0] <= ta: \\n                _, ii = heappop(pq) # release servers \\n                fw.add(ii, 1)\\n            \\n            if fw.sum(k):\\n                if fw.sum(k) - fw.sum(i): lo, hi, x = i, k, fw.sum(i)\\n                else: lo, hi, x = 0, i, 0\\n                \\n                while lo < hi: \\n                    mid = lo + hi >> 1\\n                    if fw.sum(mid) - x: hi = mid\\n                    else: lo = mid + 1\\n                fw.add(lo-1, -1)\\n                freq[lo-1] += 1\\n                heappush(pq, (ta+tl, lo-1))\\n                \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876831,
                "title": "c-set-priority-queue-binary-search-o-nlogk-with-detailed-explanation",
                "content": "**Brute Force:**\\nFor each request i we traverse all servers starting from i%k and check which is the next available server and schedule the task. This will take O(k) time to know which server should schedule the current job.\\n\\n**Time Complexity: O(n * k)**\\n\\n**Optimized Solution:**\\nInstead of doing a linear search on servers for every job, it would be a good idea to use binary search instead. This will bring down the complexity for finding the next server where the job could be scheduled from O(k) to O(logk) time. \\n\\nTo keep the list of available servers sorted we\\'ll use stl sets, lower_bound function for binay search and priority_queue to reclaim servers that are available again.\\n\\nThus, we can solve this problem using sets, priority_queue and lower_bound function in nlogk time.\\n\\n**Time Complexity: O(nlogk)\\nSpace Complexity: O(k)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n     vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\t\\t // stores the number of processes scheduled on each server\\n        vector<int> servers(k,0);\\n\\t\\t\\n\\t\\t// max number of processes scheduled\\n        int max_val = 0;\\n\\t\\t\\n\\t\\t// for priority queue to reclaim servers that are idle now\\n        auto comp = [](pair<int,int>&a, pair<int,int>&b){\\n            return a.first > b.first;\\n        };\\n\\t\\t\\n\\t\\t// priority queue stores {time when server will become free, server id}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comp)> pq(comp);\\n\\t\\t\\n\\t\\t// set of available servers\\n        set<int> available;\\n\\t\\t\\n        for(int i=0;i<k;i++)\\n            available.insert(i);\\n\\t\\t\\t\\n        for(int i=0;i<arrival.size();i++){\\n            \\n\\t\\t\\t// if the time surpasses curr time reclaim server \\n            while(!pq.empty() && pq.top().first<=arrival[i]){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n           \\n\\t\\t   // if no server is available drop the request and continue\\n            if(available.empty())\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t// get the next available server\\n            auto itr = available.lower_bound(i%k);\\n\\t\\t\\t\\n\\t\\t\\t// wrap around\\n            if(itr==available.end()){\\n                itr = available.begin();\\n            }\\n           \\n\\t\\t    // schedule the process\\n            servers[*itr]++;\\n            \\n            pq.push({arrival[i]+load[i],*itr});\\n            int val = *itr;\\n\\t\\t\\t\\n\\t\\t\\t// mark server as known available\\n            available.erase(val);\\n           \\n            max_val = max(max_val,servers[val]);\\n\\n        }\\n     \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// get all busiest servers\\n        for(int i=0;i<servers.size();i++){\\n            if(servers[i] == max_val)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\t\\t // stores the number of processes scheduled on each server\\n        vector<int> servers(k,0);\\n\\t\\t\\n\\t\\t// max number of processes scheduled\\n        int max_val = 0;\\n\\t\\t\\n\\t\\t// for priority queue to reclaim servers that are idle now\\n        auto comp = [](pair<int,int>&a, pair<int,int>&b){\\n            return a.first > b.first;\\n        };\\n\\t\\t\\n\\t\\t// priority queue stores {time when server will become free, server id}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comp)> pq(comp);\\n\\t\\t\\n\\t\\t// set of available servers\\n        set<int> available;\\n\\t\\t\\n        for(int i=0;i<k;i++)\\n            available.insert(i);\\n\\t\\t\\t\\n        for(int i=0;i<arrival.size();i++){\\n            \\n\\t\\t\\t// if the time surpasses curr time reclaim server \\n            while(!pq.empty() && pq.top().first<=arrival[i]){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n           \\n\\t\\t   // if no server is available drop the request and continue\\n            if(available.empty())\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t// get the next available server\\n            auto itr = available.lower_bound(i%k);\\n\\t\\t\\t\\n\\t\\t\\t// wrap around\\n            if(itr==available.end()){\\n                itr = available.begin();\\n            }\\n           \\n\\t\\t    // schedule the process\\n            servers[*itr]++;\\n            \\n            pq.push({arrival[i]+load[i],*itr});\\n            int val = *itr;\\n\\t\\t\\t\\n\\t\\t\\t// mark server as known available\\n            available.erase(val);\\n           \\n            max_val = max(max_val,servers[val]);\\n\\n        }\\n     \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// get all busiest servers\\n        for(int i=0;i<servers.size();i++){\\n            if(servers[i] == max_val)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877287,
                "title": "java-brutal-force",
                "content": "Please see the code, should be easy to understand;\\n```\\n    public List<Integer> busiestServers(int k, int[] as, int[] ls) {\\n        int exp[] = new int[k], cnt[] = new int[k], max = 0;\\n        for (int i = 0; i < as.length; i++) {\\n            int t = as[i], l = ls[i], s = i % k;\\n            for (int j = 0; j < k; j++, s++) {\\n                if (s == k) s = 0;\\n                if (exp[s] <= t) {  // check if free by last job expiration time;\\n                    cnt[s]++;\\n                    exp[s] = t + l;  // load the job and set the job exp time;\\n                    break;\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == max) res.add(i);\\n            else if (cnt[i] > max) {\\n                max = cnt[i];\\n                res = new ArrayList<>();\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> busiestServers(int k, int[] as, int[] ls) {\\n        int exp[] = new int[k], cnt[] = new int[k], max = 0;\\n        for (int i = 0; i < as.length; i++) {\\n            int t = as[i], l = ls[i], s = i % k;\\n            for (int j = 0; j < k; j++, s++) {\\n                if (s == k) s = 0;\\n                if (exp[s] <= t) {  // check if free by last job expiration time;\\n                    cnt[s]++;\\n                    exp[s] = t + l;  // load the job and set the job exp time;\\n                    break;\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == max) res.add(i);\\n            else if (cnt[i] > max) {\\n                max = cnt[i];\\n                res = new ArrayList<>();\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876843,
                "title": "c-simple-o-nlogn-solution-sorted-available-servers-current-requests",
                "content": "Idea : Maintain a list of available servers in a ordered set. \\nWhen a new request arrives, take the first available server by using lower_bound on the set, if we reach end of set, use the first server in the set. \\nAssign the free server the request and maintain this in a set of `<finish-time, server-id>`.\\n\\nTo get servers who have finished execution, before assigning a new request, just check the server requests set and remove completed requests and mark these servers available.\\n\\nTo identify the busiest server(s), maintain a count of requests handled by each server and use it after all the requests are completed.\\n\\nTime complexity : O(nlogn)\\nSpace complexity : O(k)\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled_requests(k);\\n        set<pair<int, int>> current_requests;\\n        set<int> available_servers;\\n        for(int i = 0; i < k; i++) {\\n            available_servers.insert(i);\\n        }\\n\\n        for(int i = 0; i < arrival.size(); i++) {\\n            while(!current_requests.empty()) {\\n                auto x = current_requests.begin();\\n                if(x->first <= arrival[i]) {\\n                    available_servers.insert(x->second); // add in available servers\\n                    current_requests.erase(current_requests.begin());\\n                } else {\\n                    break;\\n                }\\n            }\\n            int server_id = i % k;\\n            if(available_servers.size() == 0) {\\n                continue;\\n            }\\n            auto it = available_servers.lower_bound(server_id);\\n            if(it == available_servers.end()) {\\n                // cyclic behaviour\\n                it = available_servers.begin();\\n            }\\n            int u = *it;\\n            available_servers.erase(u); // remove from available servers\\n            handled_requests[u]++;\\n\\n            current_requests.insert({arrival[i] + load[i], u});\\n        }\\n        \\n        vector<int> ans;\\n        int m = *max_element(handled_requests.begin(), handled_requests.end());\\n        for(int i = 0; i < k; i++) {\\n            if(handled_requests[i] == m) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled_requests(k);\\n        set<pair<int, int>> current_requests;\\n        set<int> available_servers;\\n        for(int i = 0; i < k; i++) {\\n            available_servers.insert(i);\\n        }\\n\\n        for(int i = 0; i < arrival.size(); i++) {\\n            while(!current_requests.empty()) {\\n                auto x = current_requests.begin();\\n                if(x->first <= arrival[i]) {\\n                    available_servers.insert(x->second); // add in available servers\\n                    current_requests.erase(current_requests.begin());\\n                } else {\\n                    break;\\n                }\\n            }\\n            int server_id = i % k;\\n            if(available_servers.size() == 0) {\\n                continue;\\n            }\\n            auto it = available_servers.lower_bound(server_id);\\n            if(it == available_servers.end()) {\\n                // cyclic behaviour\\n                it = available_servers.begin();\\n            }\\n            int u = *it;\\n            available_servers.erase(u); // remove from available servers\\n            handled_requests[u]++;\\n\\n            current_requests.insert({arrival[i] + load[i], u});\\n        }\\n        \\n        vector<int> ans;\\n        int m = *max_element(handled_requests.begin(), handled_requests.end());\\n        for(int i = 0; i < k; i++) {\\n            if(handled_requests[i] == m) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876797,
                "title": "java-o-nlogk-use-treeset-and-priorityqueue",
                "content": "Well, this question is really straight forward.\\nMy first idea is follow the instruction listed in description and simulate.\\n\\nSome common skills that we can think of:\\nTo track the frequency of each server, we use an array.\\nTo track the time point of each server\\'s availability, we use an array to record the time point server will be free.\\n\\nBut if we try `i`, `i + 1`, `i + 2`, ... , it will definatly lead to TLE.\\nSo, how to quickly find next empty server?\\nWe can use a `TreeSet` to store the index of all free servers, then we can quickly find next free serve.\\nAlso, to track which server will be free at a time point, we need to maintain a heap of busy servers.\\n\\n\\n```java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int fre[] = new int[k], availability[] = new int[k], max = 0;\\n        \\n        TreeSet<Integer> free = new TreeSet<>();\\n        PriorityQueue<Integer> busy = new PriorityQueue<>((a, b) -> availability[a] - availability[b]);\\n        \\n        for(int i = 0; i < k; i++) free.add(i);\\n        \\n        for(int i = 0; i < arrival.length; i++) {\\n            // try to get all free nodes\\n            while(!busy.isEmpty() && availability[busy.peek()] <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue ; // drop\\n            \\n            \\n            if(free.contains(i % k)) { // i + k server is free\\n                free.remove(i % k);\\n                availability[i % k] = arrival[i] + load[i];\\n                busy.add(i % k);\\n                \\n                fre[i % k]++;\\n                max = Math.max(max, fre[i % k]);\\n            } else { // find next free server\\n                Integer nxt = free.ceiling(i % k); // try to find a free server next to i\\n                if(nxt == null) nxt = free.first(); // no free server with index larger than i. So we use a server with minimum index\\n                \\n                free.remove(nxt);\\n                availability[nxt] = arrival[i] + load[i];\\n                busy.add(nxt);\\n                \\n                fre[nxt]++;\\n                max = Math.max(max, fre[nxt]);\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < k; i++) if(fre[i] == max) res.add(i);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int fre[] = new int[k], availability[] = new int[k], max = 0;\\n        \\n        TreeSet<Integer> free = new TreeSet<>();\\n        PriorityQueue<Integer> busy = new PriorityQueue<>((a, b) -> availability[a] - availability[b]);\\n        \\n        for(int i = 0; i < k; i++) free.add(i);\\n        \\n        for(int i = 0; i < arrival.length; i++) {\\n            // try to get all free nodes\\n            while(!busy.isEmpty() && availability[busy.peek()] <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue ; // drop\\n            \\n            \\n            if(free.contains(i % k)) { // i + k server is free\\n                free.remove(i % k);\\n                availability[i % k] = arrival[i] + load[i];\\n                busy.add(i % k);\\n                \\n                fre[i % k]++;\\n                max = Math.max(max, fre[i % k]);\\n            } else { // find next free server\\n                Integer nxt = free.ceiling(i % k); // try to find a free server next to i\\n                if(nxt == null) nxt = free.first(); // no free server with index larger than i. So we use a server with minimum index\\n                \\n                free.remove(nxt);\\n                availability[nxt] = arrival[i] + load[i];\\n                busy.add(nxt);\\n                \\n                fre[nxt]++;\\n                max = Math.max(max, fre[nxt]);\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < k; i++) if(fre[i] == max) res.add(i);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877164,
                "title": "java-treemap-and-priorityqueue",
                "content": "```\\nclass Server {\\n    int tr = 0; // Total Requests\\n    int ft = 0; // Finishing Time\\n    int index; // Server Index\\n    \\n    public Server(int index) {\\n        this.index = index;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n       \\n        TreeMap<Integer, Server> available = new TreeMap<>(); // Map of Available Servers\\n        PriorityQueue<Server> busy = new PriorityQueue<>((Server a, Server b) -> {\\n            return a.ft - b.ft;\\n        });\\n        List<Server> list = new ArrayList<>();\\n        for(int i = 0; i < k; i++) {\\n            Server server = new Server(i);\\n            list.add(server);\\n            available.put(i, server);\\n        }\\n       int max = 0;\\n       for(int i = 0; i < arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().ft <= arrival[i]){\\n                Server server = busy.remove();\\n                available.put(server.index, server);\\n            }\\n            if(available.size() == 0) continue;\\n            int req = (i % k);\\n            int serverIndex = -1;\\n            if(available.ceilingKey(req) != null) serverIndex = available.ceilingKey(req);           \\n            else serverIndex = available.firstKey();\\n            Server server = available.get(serverIndex);\\n            server.ft = arrival[i] + load[i];\\n            server.tr += 1;\\n            max = Math.max(max, server.tr);\\n            busy.add(server);\\n            available.remove(serverIndex);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int j =0; j < k; j++) {\\n            if(list.get(j).tr == max) result.add(j);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Server {\\n    int tr = 0; // Total Requests\\n    int ft = 0; // Finishing Time\\n    int index; // Server Index\\n    \\n    public Server(int index) {\\n        this.index = index;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n       \\n        TreeMap<Integer, Server> available = new TreeMap<>(); // Map of Available Servers\\n        PriorityQueue<Server> busy = new PriorityQueue<>((Server a, Server b) -> {\\n            return a.ft - b.ft;\\n        });\\n        List<Server> list = new ArrayList<>();\\n        for(int i = 0; i < k; i++) {\\n            Server server = new Server(i);\\n            list.add(server);\\n            available.put(i, server);\\n        }\\n       int max = 0;\\n       for(int i = 0; i < arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().ft <= arrival[i]){\\n                Server server = busy.remove();\\n                available.put(server.index, server);\\n            }\\n            if(available.size() == 0) continue;\\n            int req = (i % k);\\n            int serverIndex = -1;\\n            if(available.ceilingKey(req) != null) serverIndex = available.ceilingKey(req);           \\n            else serverIndex = available.firstKey();\\n            Server server = available.get(serverIndex);\\n            server.ft = arrival[i] + load[i];\\n            server.tr += 1;\\n            max = Math.max(max, server.tr);\\n            busy.add(server);\\n            available.remove(serverIndex);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int j =0; j < k; j++) {\\n            if(list.get(j).tr == max) result.add(j);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876910,
                "title": "python-o-nlogk-sortedlist-and-heap",
                "content": "Approach 1. Simulate (TLE)\\n\\nWe do exactly what we are told in the problem statement.\\n```python \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        endtimes = [0] * k\\n        count    = [0] * k\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            serveridx = aidx % k\\n            if endtimes[serveridx]<=a:\\n                count[serveridx]+=1\\n                endtimes[serveridx] = a+l\\n            else:\\n                nextserveridx = (serveridx + 1) % k\\n                while nextserveridx != serveridx:\\n                    if endtimes[nextserveridx] <= a:\\n                        count[nextserveridx]+=1\\n                        endtimes[nextserveridx] = a + l\\n                        break\\n                    nextserveridx = (nextserveridx + 1) % k\\n        \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```\\nN=number of requests\\nK=number of servers\\nTime: O(NK)\\nSpace: O(K)\\n\\nApproach 2. Use SortedList and Heap\\n\\nWe need to find a better way to find the next available server. Since we need to find the next available server in a circular way, we can use a SortedList to give us O(logK) time for finding the next available server. And we also need to remember the servers that are curently used. We can use a heap to keeptrack of the earliest ending request and pop it when a new request starts later.\\n\\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k # keep track of how many requests handled each server\\n        \\n        available_servers = SortedList(range(k)) # a sorted list containing indices of available servers\\n        heap_endtimes = [] # use a heap data structure that contains tuples (end_time, server_idx)\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            while h and h[0][0] <= a: # when a new request start time is greater that the endtime of any request\\n                _, free_server_idx = heapq.heappop(heap_endtimes) # free the server  from the hea[\\n                available_servers.add(free_server_idx) # and add it to the available servers list\\n\\n\\t\\t\\tif len(available_servers)==0: \\n                continue\\n                \\n            serveridx = aidx % k # which server should handle this request according to the presented rule?\\n            i = available_servers.bisect_left(serveridx) % len(available_servers) # i will point either to the serveridx if it exists in the sorted list, or it will point to the next one\\n            actual_server = available_servers.pop(i) # remove the server from the available list\\n            count[actual_server]+=1 # increment the number of times the server had been used\\n            heapq.heappush(heap_endtimes, (a+l, actual_server)) # make the server end at a+l\\n            \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```\\nTime: O(NlogK)\\nSpace: O(K)",
                "solutionTags": [],
                "code": "```python \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        endtimes = [0] * k\\n        count    = [0] * k\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            serveridx = aidx % k\\n            if endtimes[serveridx]<=a:\\n                count[serveridx]+=1\\n                endtimes[serveridx] = a+l\\n            else:\\n                nextserveridx = (serveridx + 1) % k\\n                while nextserveridx != serveridx:\\n                    if endtimes[nextserveridx] <= a:\\n                        count[nextserveridx]+=1\\n                        endtimes[nextserveridx] = a + l\\n                        break\\n                    nextserveridx = (nextserveridx + 1) % k\\n        \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k # keep track of how many requests handled each server\\n        \\n        available_servers = SortedList(range(k)) # a sorted list containing indices of available servers\\n        heap_endtimes = [] # use a heap data structure that contains tuples (end_time, server_idx)\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            while h and h[0][0] <= a: # when a new request start time is greater that the endtime of any request\\n                _, free_server_idx = heapq.heappop(heap_endtimes) # free the server  from the hea[\\n                available_servers.add(free_server_idx) # and add it to the available servers list\\n\\n\\t\\t\\tif len(available_servers)==0: \\n                continue\\n                \\n            serveridx = aidx % k # which server should handle this request according to the presented rule?\\n            i = available_servers.bisect_left(serveridx) % len(available_servers) # i will point either to the serveridx if it exists in the sorted list, or it will point to the next one\\n            actual_server = available_servers.pop(i) # remove the server from the available list\\n            count[actual_server]+=1 # increment the number of times the server had been used\\n            heapq.heappush(heap_endtimes, (a+l, actual_server)) # make the server end at a+l\\n            \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346318,
                "title": "java-treeset-with-priorityqueue",
                "content": "We want to maintain two pools of servers - a busy pool and an available pool. Every time a request comes in, we will first check which servers in our busy pool become available. Then we iterate over the available pool starting from `i % k` and wrapping around until we find a free server. Then this server is transferred from our available pool to the busy pool. We model the available pool as a sorted set so we can quickly answer queries of the form give me the id right after `x`. The busy pool is modelled as priority queue with key being the finishing time of currently processing request. Once a request arrives (i.e. we iterate to it), then we go over our busy pool to remove servers which stopped processing before the arrival time of the current request and transfer it to the available pool. Once available pool is updated, we assign a server to it.\\n\\n```\\nclass Solution {\\n    class Server {\\n        final int id;\\n        final int busyTime;\\n        public Server(int id, int busyTime){\\n            this.id = id;\\n            this.busyTime = busyTime;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        PriorityQueue<Server> busy = new PriorityQueue<>((a, b) -> a.busyTime - b.busyTime);\\n        int[] requestCount = new int[k];\\n        int n = arrival.length;\\n        for(int id = 0; id < k; id++){\\n            available.add(id);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int defaultServer = (i % k);\\n            while(!busy.isEmpty() && busy.peek().busyTime <= arrival[i]){\\n                Server top = busy.poll();\\n                available.add(top.id);\\n            }\\n            \\n            if(available.isEmpty())continue;\\n            Integer nextServer = available.ceiling(defaultServer);\\n            nextServer = (nextServer != null) ? \\n                nextServer : available.ceiling(0);\\n            int requestEnd = arrival[i] + load[i];\\n            available.remove(nextServer);\\n            busy.add(new Server(nextServer, requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n        \\n        int maxRequests = Integer.MIN_VALUE;\\n        List<Integer> busiestServers = new ArrayList<>();\\n        for(int id = 0; id < k; id++){\\n            maxRequests = Math.max(maxRequests, requestCount[id]);\\n        }\\n        \\n        for(int id = 0; id < k; id++){\\n            if(requestCount[id] == maxRequests)busiestServers.add(id);\\n        }\\n        \\n        return busiestServers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Server {\\n        final int id;\\n        final int busyTime;\\n        public Server(int id, int busyTime){\\n            this.id = id;\\n            this.busyTime = busyTime;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        PriorityQueue<Server> busy = new PriorityQueue<>((a, b) -> a.busyTime - b.busyTime);\\n        int[] requestCount = new int[k];\\n        int n = arrival.length;\\n        for(int id = 0; id < k; id++){\\n            available.add(id);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int defaultServer = (i % k);\\n            while(!busy.isEmpty() && busy.peek().busyTime <= arrival[i]){\\n                Server top = busy.poll();\\n                available.add(top.id);\\n            }\\n            \\n            if(available.isEmpty())continue;\\n            Integer nextServer = available.ceiling(defaultServer);\\n            nextServer = (nextServer != null) ? \\n                nextServer : available.ceiling(0);\\n            int requestEnd = arrival[i] + load[i];\\n            available.remove(nextServer);\\n            busy.add(new Server(nextServer, requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n        \\n        int maxRequests = Integer.MIN_VALUE;\\n        List<Integer> busiestServers = new ArrayList<>();\\n        for(int id = 0; id < k; id++){\\n            maxRequests = Math.max(maxRequests, requestCount[id]);\\n        }\\n        \\n        for(int id = 0; id < k; id++){\\n            if(requestCount[id] == maxRequests)busiestServers.add(id);\\n        }\\n        \\n        return busiestServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824708,
                "title": "c-maintain-priority-queue-of-busy-servers-and-keep-free-server-in-diff-place-for-fast-look-up",
                "content": "```cpp\\nclass Node {\\npublic:\\n    int end;\\n    int serverId;\\n};\\n\\n//min heap comparator\\nbool operator< (const Node &a, const Node &b) {\\n    return a.end > b.end;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<Node> busyServer;        \\n        set<int> freeServer;\\n        int n = load.size();\\n        unordered_map<int, int> serverLoad;\\n        for (int i = 0; i < k; ++i) {\\n            freeServer.insert(i);\\n        }\\n        int loadSoFar = 0;\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            //pick all the servers\\n            //which have become free now;\\n            while (busyServer.size() > 0 && busyServer.top().end <= start) {\\n                freeServer.insert(busyServer.top().serverId);\\n                busyServer.pop();\\n            }\\n            //If there is a server available\\n            //then pick it\\n            if (freeServer.size() > 0) {\\n                auto it = freeServer.lower_bound(i % k);\\n                if (it == freeServer.end()) {\\n                    it = freeServer.begin();\\n                }\\n                int serverId = *it;\\n                freeServer.erase(it);\\n                busyServer.push({start + duration, serverId});\\n                ++serverLoad[serverId];\\n                if (serverLoad[serverId] > loadSoFar) {\\n                    res = serverId;\\n                    loadSoFar = serverLoad[serverId];\\n                }                    \\n            }\\n        }\\n        vector<int> result;\\n        for (pair<int, int> e: serverLoad) {\\n            if (e.second == loadSoFar) {\\n                result.push_back(e.first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Node {\\npublic:\\n    int end;\\n    int serverId;\\n};\\n\\n//min heap comparator\\nbool operator< (const Node &a, const Node &b) {\\n    return a.end > b.end;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<Node> busyServer;        \\n        set<int> freeServer;\\n        int n = load.size();\\n        unordered_map<int, int> serverLoad;\\n        for (int i = 0; i < k; ++i) {\\n            freeServer.insert(i);\\n        }\\n        int loadSoFar = 0;\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            //pick all the servers\\n            //which have become free now;\\n            while (busyServer.size() > 0 && busyServer.top().end <= start) {\\n                freeServer.insert(busyServer.top().serverId);\\n                busyServer.pop();\\n            }\\n            //If there is a server available\\n            //then pick it\\n            if (freeServer.size() > 0) {\\n                auto it = freeServer.lower_bound(i % k);\\n                if (it == freeServer.end()) {\\n                    it = freeServer.begin();\\n                }\\n                int serverId = *it;\\n                freeServer.erase(it);\\n                busyServer.push({start + duration, serverId});\\n                ++serverLoad[serverId];\\n                if (serverLoad[serverId] > loadSoFar) {\\n                    res = serverId;\\n                    loadSoFar = serverLoad[serverId];\\n                }                    \\n            }\\n        }\\n        vector<int> result;\\n        for (pair<int, int> e: serverLoad) {\\n            if (e.second == loadSoFar) {\\n                result.push_back(e.first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423326,
                "title": "java-o-n-log-k-time-complexity-solution-using-treeset-and-priority-queue",
                "content": "```\\nclass ServerInfo {\\n    private int serverId;\\n    private int nextAvailableTime;\\n    \\n    public ServerInfo (int serverId, int nextAvailableTime) {\\n        this.serverId = serverId;\\n        this. nextAvailableTime = nextAvailableTime;\\n    }   \\n    \\n    public int getNextAvailableTime() {\\n        return this.nextAvailableTime;\\n    }    \\n    \\n    public int getServerId() {\\n        return this.serverId;\\n    }\\n}\\n\\nclass ServerComparator implements Comparator<ServerInfo> {\\n    public int compare(ServerInfo s1, ServerInfo s2) {\\n        if (s1.getNextAvailableTime() == s2.getNextAvailableTime())\\n            return Integer.compare(s1.getServerId(), s2.getServerId());\\n        return Integer.compare(s1.getNextAvailableTime(), s2.getNextAvailableTime());\\n    }\\n}\\n\\nclass Solution {\\n    \\n    ServerComparator serverComparator = new ServerComparator();\\n    \\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int[] serverRequestsCounter = new int[k];\\n        \\n        \\n        // Initially all servers are idle\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n        for (int serverId=0; serverId<k; serverId++) {\\n            availableServers.add(serverId);\\n        }\\n        \\n        // Maintain the buzy servers in Priority Queue, when new arrival time comes, free up previous servers\\n        PriorityQueue<ServerInfo> buzyServers = new PriorityQueue<>(serverComparator);\\n        \\n        for (int idx=0; idx<arrival.length; idx++) {\\n            \\n            int arrivalTime = arrival[idx];\\n\\n            while (!buzyServers.isEmpty() \\n                   && arrivalTime >= buzyServers.peek().getNextAvailableTime()) {\\n                \\n                availableServers.add(buzyServers.poll().getServerId());\\n                \\n            }\\n            \\n            if (availableServers.isEmpty())\\n                continue;\\n            \\n            // This will give next server Id which is freed up\\n            Integer assignedServerId = availableServers.ceiling(idx % k);\\n            \\n            if (assignedServerId == null) {\\n                assignedServerId = availableServers.first();\\n            }\\n            \\n            serverRequestsCounter[assignedServerId]++;\\n            \\n            // Remove the assigned server from available pool\\n            availableServers.remove(assignedServerId);\\n                  \\n            // Add the assigned server to buzy pool\\n            buzyServers.add(new ServerInfo(assignedServerId, arrivalTime + load[idx]));\\n        \\n        }\\n        \\n        return busiestServers(serverRequestsCounter, k);\\n    }\\n    \\n    \\n    private List<Integer> busiestServers (int[] serverRequestsCounter, int numServers) {\\n        int maxRequests = 0;\\n        \\n        for  (int i=0; i<numServers; i++) {\\n            maxRequests = Math.max(serverRequestsCounter[i], maxRequests);\\n        }\\n        \\n        List<Integer> busiestServers = new ArrayList<>();\\n            \\n        for (int i=0; i<numServers; i++) {\\n            if (serverRequestsCounter[i] == maxRequests) {\\n                busiestServers.add(i);\\n            }\\n        }\\n        \\n        return busiestServers;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n    ServerComparator serverComparator = new ServerComparator();\\n    \\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int[] serverRequestsCounter = new int[k];\\n        \\n        \\n        // Initially all servers are idle\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n        for (int serverId=0; serverId<k; serverId++) {\\n            availableServers.add(serverId);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 933702,
                "title": "python-fenwick-tree-o-n-log-k",
                "content": "**Goal:**\\n\\nThe objective here is to iterate over the list of jobs (arrival times and loads) and assign each job to a server. \\nKeep track of how many jobs each server handled and return a list of the most productive servers.  \\n\\n**Approach:**\\n\\nAt the beginning all the servers are free.\\nAssign the first job to server 0, the second job to server 1, ..., the k<sup>th</sup> to server k-1.  No problems.\\n\\nAfter the first k jobs have been assigned, a server must start it\\'s second job.\\nTo find out which servers are done with their first job and ready to accept a second job,\\nwe could iterate over a list of servers and see which servers have an end time less than \\nor equal to the current time. But this would be very time consuming.  \\n\\nInstead store the busy servers in a min-heap where each busy server is a tuple (end_time, server_id).  \\nWhere end_time is the time that the server will finish its current job and server_id is the index of the server.  \\nAll busy servers with an end_time earlier than the current time (arrival[i]) are now free and can be popped off the server heap.  \\n\\nAssign the current job to the first free server to the right of the current index.  \\nWrap around to the start of the server list if necessary.  \\nKeep count of how many jobs each server receives in a hash map.\\nOnce all jobs have been assigned to servers - or dropped - return a list of the most productive servers.  \\n\\n**The Challenge:**\\n\\nThis problem is more than deserving of it\\'s hard rating.  \\nWhat makes this problem difficult is finding the first free server in **less than** linear time.  \\n\\nThe first free server can be found with a linear search (as shown in the Simple Solution).\\nHowever, this will result in an overall time complexity of O(n<sup>2</sup>) which will TLE.\\n\\nIn the aptly named Fenwick Tree Solution, a Fenwick Tree is used to speed up the process of finding the first free server.\\nFenwick trees serve the same purpose as a presum array in that they provide fast range sum queries.\\nThe difference is that they take a little longer to query **but** they are much faster to update.  \\n\\n| |Create| Range Sum Query|Update|\\n|---|---|---|---|\\n|Fenwick Tree| O(n)| O(log(n)) | O(log(n)) |\\n|Presum Array| O(n) | O(1) | O(n) |\\n\\nTo use a Fenwick tree to find the first free server, use a binary array servers where server[i] = 1 \\nmeans the i<sup>th</sup> sever is busy and server[i] = 0 means the i<sup>th</sup> server is free.  \\n\\nIf a free server exists in the range [i, j] then the range sum query of range [i, j] will be less than the length of the range.  \\nThen binary search for the left-most range of length 1 that has a sum of 0.  \\n\\n\\n**Observations:**\\n\\nIf there are more servers than there are jobs, then the first n servers will all get 1 job.\\nThe solution reduces to range(n) where n is the number of jobs. \\n\\nIf there is only one free server, then that server **must** receive the current job.  \\nKeep track of which servers are not busy in a set.  \\nWhen the length of the set is 1, we can assign the current job in O(log(n)) time as opposed to O(log(n)<sup>2</sup>) time.  \\n\\n<details>\\n\\n<b><summary>Simple Solution: (click to show)</summary></b>\\n\\n```python\\n#Runtime: TLE\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        requests_handled = collections.defaultdict(int)\\n        servers = [] # server heap (end_time, server_id)\\n        free_servers = set(range(k))\\n        \\n        for i, (t, c) in enumerate(zip(arrival, load)):\\n            \\n            while servers and servers[0][0] <= t:\\n                free_servers.add(heapq.heappop(servers)[1])\\n            \\n            if free_servers:\\n                \\n                # find first free server\\n                target_server = i % k\\n                while target_server not in free_servers:\\n                    target_server = (target_server + 1) % k\\n                \\n                # mark the server as busy\\n                free_servers.remove(target_server)\\n                \\n                # add the server to the server heap\\n                heapq.heappush(servers, (t + c, target_server))\\n                requests_handled[target_server] += 1\\n        \\n        maxi = max(requests_handled.values())\\n        return [server for server in requests_handled if requests_handled[server] == maxi]\\n```\\n\\n</details>\\n\\n\\n<details>\\n\\n<b><summary>Fenwick Tree Solution: (click to show)</summary></b>\\n\\n```python\\n# Runtime: 4264 ms\\nclass Fenwick(object):\\n    def __init__(self, arr):\\n        self.arr = [0] + arr\\n        self.fen = self.arr[:]\\n        self.construct()\\n    \\n    def construct(self):\\n        for i in range(len(self.fen)):\\n            j = i + self.lsb(i)\\n            if j < len(self.fen):\\n                self.fen[j] += self.fen[i]\\n            \\n    def lsb(self, n):\\n        \\'\\'\\'return the least significant bit of n\\'\\'\\'\\n        return -n&n\\n    \\n    def presum(self, i):\\n        \\'\\'\\'return sum of array from 0:i\\'\\'\\'\\n        res = 0\\n        while i:\\n            res += self.fen[i]\\n            i -= self.lsb(i)\\n        return res\\n    \\n    def range_sum(self, i, j):\\n        \\'\\'\\'return sum of array from i: j inclusive\\'\\'\\'\\n        i, j = i+1, j+1\\n        return self.presum(j) - self.presum(i-1)\\n    \\n    def update(self, i, val):\\n        \\'\\'\\'change value at arr[i] to val ; i.e. arr[i] = 1 if server busy and arr[i] = 0 if free\\'\\'\\'\\n        i += 1\\n        diff = val - self.arr[i]\\n        self.arr[i] = val\\n        while i < len(self.fen):\\n            self.fen[i] += diff\\n            i += self.lsb(i)\\n    \\n    def free_server_in_range(self, i, j):\\n        \\'\\'\\'returns True if there is a free server in the range [i,j] inclusive\\'\\'\\'\\n        return self.range_sum(i-1, j-1) < (j - i + 1)\\n    \\n    def binary_search(self, low, high):\\n        \\'\\'\\'Finds the left-most server that is free in the range low, high inclusive\\'\\'\\'\\n        first_free = float(\\'inf\\')\\n        if self.free_server_in_range(low, high):\\n            while low <= high:\\n                j = (low + high) // 2\\n                if self.free_server_in_range(low, j):\\n                    first_free = min(j, first_free)\\n                    high = j - 1\\n                else:\\n                    low = j + 1\\n        return first_free\\n    \\n    def find_first_free_server(self, i):\\n        \\'\\'\\'Returns the index of the first free server to the right of server i (wrapping around to server 0 if needed)\\'\\'\\'\\n        first_free = self.binary_search(i, len(self.arr) - 1)\\n        return (first_free - 1) if (first_free != float(\\'inf\\')) else (self.binary_search(1, i-1) - 1)\\n\\n    \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        if k >= len(arrival):          # If we have more servers than jobs then\\n            return range(len(arrival)) # the first n servers will all receive 1 job\\n        \\n        end = [a + c for a,c in zip(arrival, load)]                                  # end[i] is the time at which the (i)th job will finished\\n        requests_handled = collections.defaultdict(lambda: 1)                        # All servers get one job to start with\\n        t_naught = arrival[k]                                                        # Arrival time of the (k)th job\\n        free_servers = Fenwick([int(end[i] > t_naught) for i in range(k)])           # All servers that finish their job before t_naught are free\\n        not_in_use = set(i for i in range(k) if end[i] <= t_naught)                  # Set of servers that are free\\n        servers = [(arrival[i] + load[i], i) for i in range(k) if end[i] > t_naught] # active server heap (end_time, server_id)\\n        heapq.heapify(servers)\\n        \\n        for i in range(k, len(arrival)):\\n            t = arrival[i]\\n            e = end[i]\\n            i = i % k\\n            \\n            while servers and servers[0][0] <= t:  # Remove all servers that have completed their job from the server heap\\n                s = heapq.heappop(servers)[1]\\n                free_servers.update(s, 0)          # 0 means the server is now free\\n                not_in_use.add(s)\\n            \\n            if len(servers) < k - 1:\\n                target_server = free_servers.find_first_free_server(i+1) if free_servers.arr[i+1] else i\\n                not_in_use.remove(target_server)             # mark server as not free\\n                free_servers.update(target_server, 1)        # 1 means the server is now busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n            elif len(servers) == k - 1:\\n                target_server = not_in_use.pop()             # There is only one server available to use\\n                free_servers.update(target_server, 1)        # mark server as busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n                \\n        maxi = max(requests_handled.values())\\n        return (server for server in requests_handled if requests_handled[server] == maxi)\\n```\\n\\n</details>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n#Runtime: TLE\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        requests_handled = collections.defaultdict(int)\\n        servers = [] # server heap (end_time, server_id)\\n        free_servers = set(range(k))\\n        \\n        for i, (t, c) in enumerate(zip(arrival, load)):\\n            \\n            while servers and servers[0][0] <= t:\\n                free_servers.add(heapq.heappop(servers)[1])\\n            \\n            if free_servers:\\n                \\n                # find first free server\\n                target_server = i % k\\n                while target_server not in free_servers:\\n                    target_server = (target_server + 1) % k\\n                \\n                # mark the server as busy\\n                free_servers.remove(target_server)\\n                \\n                # add the server to the server heap\\n                heapq.heappush(servers, (t + c, target_server))\\n                requests_handled[target_server] += 1\\n        \\n        maxi = max(requests_handled.values())\\n        return [server for server in requests_handled if requests_handled[server] == maxi]\\n```\n```python\\n# Runtime: 4264 ms\\nclass Fenwick(object):\\n    def __init__(self, arr):\\n        self.arr = [0] + arr\\n        self.fen = self.arr[:]\\n        self.construct()\\n    \\n    def construct(self):\\n        for i in range(len(self.fen)):\\n            j = i + self.lsb(i)\\n            if j < len(self.fen):\\n                self.fen[j] += self.fen[i]\\n            \\n    def lsb(self, n):\\n        \\'\\'\\'return the least significant bit of n\\'\\'\\'\\n        return -n&n\\n    \\n    def presum(self, i):\\n        \\'\\'\\'return sum of array from 0:i\\'\\'\\'\\n        res = 0\\n        while i:\\n            res += self.fen[i]\\n            i -= self.lsb(i)\\n        return res\\n    \\n    def range_sum(self, i, j):\\n        \\'\\'\\'return sum of array from i: j inclusive\\'\\'\\'\\n        i, j = i+1, j+1\\n        return self.presum(j) - self.presum(i-1)\\n    \\n    def update(self, i, val):\\n        \\'\\'\\'change value at arr[i] to val ; i.e. arr[i] = 1 if server busy and arr[i] = 0 if free\\'\\'\\'\\n        i += 1\\n        diff = val - self.arr[i]\\n        self.arr[i] = val\\n        while i < len(self.fen):\\n            self.fen[i] += diff\\n            i += self.lsb(i)\\n    \\n    def free_server_in_range(self, i, j):\\n        \\'\\'\\'returns True if there is a free server in the range [i,j] inclusive\\'\\'\\'\\n        return self.range_sum(i-1, j-1) < (j - i + 1)\\n    \\n    def binary_search(self, low, high):\\n        \\'\\'\\'Finds the left-most server that is free in the range low, high inclusive\\'\\'\\'\\n        first_free = float(\\'inf\\')\\n        if self.free_server_in_range(low, high):\\n            while low <= high:\\n                j = (low + high) // 2\\n                if self.free_server_in_range(low, j):\\n                    first_free = min(j, first_free)\\n                    high = j - 1\\n                else:\\n                    low = j + 1\\n        return first_free\\n    \\n    def find_first_free_server(self, i):\\n        \\'\\'\\'Returns the index of the first free server to the right of server i (wrapping around to server 0 if needed)\\'\\'\\'\\n        first_free = self.binary_search(i, len(self.arr) - 1)\\n        return (first_free - 1) if (first_free != float(\\'inf\\')) else (self.binary_search(1, i-1) - 1)\\n\\n    \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        if k >= len(arrival):          # If we have more servers than jobs then\\n            return range(len(arrival)) # the first n servers will all receive 1 job\\n        \\n        end = [a + c for a,c in zip(arrival, load)]                                  # end[i] is the time at which the (i)th job will finished\\n        requests_handled = collections.defaultdict(lambda: 1)                        # All servers get one job to start with\\n        t_naught = arrival[k]                                                        # Arrival time of the (k)th job\\n        free_servers = Fenwick([int(end[i] > t_naught) for i in range(k)])           # All servers that finish their job before t_naught are free\\n        not_in_use = set(i for i in range(k) if end[i] <= t_naught)                  # Set of servers that are free\\n        servers = [(arrival[i] + load[i], i) for i in range(k) if end[i] > t_naught] # active server heap (end_time, server_id)\\n        heapq.heapify(servers)\\n        \\n        for i in range(k, len(arrival)):\\n            t = arrival[i]\\n            e = end[i]\\n            i = i % k\\n            \\n            while servers and servers[0][0] <= t:  # Remove all servers that have completed their job from the server heap\\n                s = heapq.heappop(servers)[1]\\n                free_servers.update(s, 0)          # 0 means the server is now free\\n                not_in_use.add(s)\\n            \\n            if len(servers) < k - 1:\\n                target_server = free_servers.find_first_free_server(i+1) if free_servers.arr[i+1] else i\\n                not_in_use.remove(target_server)             # mark server as not free\\n                free_servers.update(target_server, 1)        # 1 means the server is now busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n            elif len(servers) == k - 1:\\n                target_server = not_in_use.pop()             # There is only one server available to use\\n                free_servers.update(target_server, 1)        # mark server as busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n                \\n        maxi = max(requests_handled.values())\\n        return (server for server in requests_handled if requests_handled[server] == maxi)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171163,
                "title": "python3-fast-solution-with-mathematical-derivation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to sort server_id in range: [i, i+k)\\nso we have:\\ni <= server_id + m*k < i+k\\n-> server_id + m*k = i + x  where x in range[0, k)\\n-> server_id % k + 0 = i % k + x\\n-> x = server_id % k - i % k\\nthat means we can use id = i + x = i + (server_id - i) % k  as key of the heap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\n        available_servers = list(range(k))\\n        busy_servers = []\\n        cnt = [0] * k\\n\\n        for i in range(len(arrival)):\\n            start, duration = arrival[i], load[i]\\n            while busy_servers and busy_servers[0][0] <= start:\\n                _, server = heapq.heappop(busy_servers)\\n                heapq.heappush(available_servers, i + (server - i) % k)\\n            if available_servers:\\n                server = heapq.heappop(available_servers) % k\\n                cnt[server] += 1\\n                heapq.heappush(busy_servers, (start + duration, server))\\n\\n        mx = max(cnt)\\n        return [i for i in range(len(cnt)) if cnt[i] == mx]\\n        \\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\n        available_servers = list(range(k))\\n        busy_servers = []\\n        cnt = [0] * k\\n\\n        for i in range(len(arrival)):\\n            start, duration = arrival[i], load[i]\\n            while busy_servers and busy_servers[0][0] <= start:\\n                _, server = heapq.heappop(busy_servers)\\n                heapq.heappush(available_servers, i + (server - i) % k)\\n            if available_servers:\\n                server = heapq.heappop(available_servers) % k\\n                cnt[server] += 1\\n                heapq.heappush(busy_servers, (start + duration, server))\\n\\n        mx = max(cnt)\\n        return [i for i in range(len(cnt)) if cnt[i] == mx]\\n        \\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346411,
                "title": "python-super-readable-solution-sortedlist-heap",
                "content": "#### The basic approach to this question is:\\n* iterate arrival and load values\\n\\t* Identify all available servers\\n\\t* Find the next available server and increase its handle count\\n\\t* Mark it is busy\\n\\n* return all servers that reached the same request handled count\\n\\n#### The main problem here is find an efficient method to:\\n* Know at any time which servers are available and which are busy\\n\\t* My implementation here is inspired by the question [Meetings Rooms II](https://leetcode.com/problems/meeting-rooms-ii/). We can use a min heap holding the end time of each meeting (busy time in our case) to know which servers are **busy** and when they are going to be **available again**.\\n* Find the **correct** next available server\\n\\t* In order to comply with the defined routing algorithm in the question, I keep a sorted list of the avaiable servers indices.\\tThis gives me the ability to do a binary search (O(logk)) in order to find the next available server\\n\\t\\n\\n\\n\\n\\n```\\nimport heapq\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # map server to its handle count\\n        server_busy_count = [0] * k\\n        \\n        # init heap\\n        busy_servers_heap = []\\n        \\n        # init available servers sortedlist -> klogk\\n        available_servers = SortedList([idx for idx in range(k)])\\n        \\n        # iterate arrivals\\n        for req_idx, (curr_arrival, curr_load) in enumerate(zip(arrival, load)):\\n            # pop all available servers from heap\\n            while busy_servers_heap and curr_arrival >= busy_servers_heap[0][0]:\\n                _, server_idx = heapq.heappop(busy_servers_heap)\\n    \\n                # add servers to available sorted list\\n                available_servers.add(server_idx)\\n            \\n            # all servers are busy -> drop request\\n            if not available_servers: continue\\n            \\n            # binary search on available list to find the correct available server\\n            desired_server_idx = req_idx % k\\n            next_idx = available_servers.bisect_left(desired_server_idx)\\n            \\n            # no bigger idx found, use the first available server\\n            if next_idx == len(available_servers):\\n                next_idx = 0\\n            \\n            # select server by the next_idx calculated\\n            selected_server = available_servers[next_idx]\\n            \\n            # increase selected server handle count\\n            server_busy_count[selected_server] += 1\\n            \\n            # add selected server with end time to the heap\\n            heapq.heappush(busy_servers_heap, (curr_arrival + curr_load, selected_server))\\n            \\n            # pop selected servers from the available list\\n            available_servers.remove(selected_server)\\n            \\n        # return all servers the handled the max request count\\n        max_busy = max(server_busy_count)\\n        return [idx for idx in range(k) if server_busy_count[idx] == max_busy]           \\n```\\n\\n\\n#### Please upvote if you find this solution helpful, so it could help others as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nimport heapq\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # map server to its handle count\\n        server_busy_count = [0] * k\\n        \\n        # init heap\\n        busy_servers_heap = []\\n        \\n        # init available servers sortedlist -> klogk\\n        available_servers = SortedList([idx for idx in range(k)])\\n        \\n        # iterate arrivals\\n        for req_idx, (curr_arrival, curr_load) in enumerate(zip(arrival, load)):\\n            # pop all available servers from heap\\n            while busy_servers_heap and curr_arrival >= busy_servers_heap[0][0]:\\n                _, server_idx = heapq.heappop(busy_servers_heap)\\n    \\n                # add servers to available sorted list\\n                available_servers.add(server_idx)\\n            \\n            # all servers are busy -> drop request\\n            if not available_servers: continue\\n            \\n            # binary search on available list to find the correct available server\\n            desired_server_idx = req_idx % k\\n            next_idx = available_servers.bisect_left(desired_server_idx)\\n            \\n            # no bigger idx found, use the first available server\\n            if next_idx == len(available_servers):\\n                next_idx = 0\\n            \\n            # select server by the next_idx calculated\\n            selected_server = available_servers[next_idx]\\n            \\n            # increase selected server handle count\\n            server_busy_count[selected_server] += 1\\n            \\n            # add selected server with end time to the heap\\n            heapq.heappush(busy_servers_heap, (curr_arrival + curr_load, selected_server))\\n            \\n            # pop selected servers from the available list\\n            available_servers.remove(selected_server)\\n            \\n        # return all servers the handled the max request count\\n        max_busy = max(server_busy_count)\\n        return [idx for idx in range(k) if server_busy_count[idx] == max_busy]           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980482,
                "title": "java-elegant-and-concise-using-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Integer> avalServers = new TreeSet<>();\\n        for(int i=0; i<k; i++){\\n            avalServers.add(i);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); // [Ending Times, Server]\\n        int[] count = new int[k]; // To count the number of requests handled by each server\\n        for(int i=0; i<arrival.length; i++){\\n            // Free the servers who have serviced the request\\n            while(!pq.isEmpty() && pq.peek()[0] <= arrival[i]){\\n                avalServers.add(pq.poll()[1]);\\n            }\\n            \\n            // Find the available server  for the current request \\n            if(avalServers.size() == 0) continue; // Request Dropped\\n            \\n            int serverReq = i%k;\\n            Integer nextServ = avalServers.ceiling(serverReq);\\n            if(nextServ != null){\\n                avalServers.remove(nextServ);\\n            }else{\\n                // Find the smallest numbered server\\n                nextServ = avalServers.first();\\n                avalServers.remove(nextServ);\\n            }\\n            \\n            pq.offer(new int[]{arrival[i] + load[i], nextServ});\\n            count[nextServ]++; \\n        }\\n        \\n        int max = -1;\\n        List<Integer> ans = null;\\n        for(int i=0; i<k; i++){\\n            if(count[i] > max){\\n                ans = new ArrayList<>();\\n                max = count[i];\\n                ans.add(i);\\n            }else if(count[i] == max){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Integer> avalServers = new TreeSet<>();\\n        for(int i=0; i<k; i++){\\n            avalServers.add(i);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); // [Ending Times, Server]\\n        int[] count = new int[k]; // To count the number of requests handled by each server\\n        for(int i=0; i<arrival.length; i++){\\n            // Free the servers who have serviced the request\\n            while(!pq.isEmpty() && pq.peek()[0] <= arrival[i]){\\n                avalServers.add(pq.poll()[1]);\\n            }\\n            \\n            // Find the available server  for the current request \\n            if(avalServers.size() == 0) continue; // Request Dropped\\n            \\n            int serverReq = i%k;\\n            Integer nextServ = avalServers.ceiling(serverReq);\\n            if(nextServ != null){\\n                avalServers.remove(nextServ);\\n            }else{\\n                // Find the smallest numbered server\\n                nextServ = avalServers.first();\\n                avalServers.remove(nextServ);\\n            }\\n            \\n            pq.offer(new int[]{arrival[i] + load[i], nextServ});\\n            count[nextServ]++; \\n        }\\n        \\n        int max = -1;\\n        List<Integer> ans = null;\\n        for(int i=0; i<k; i++){\\n            if(count[i] > max){\\n                ans = new ArrayList<>();\\n                max = count[i];\\n                ans.add(i);\\n            }else if(count[i] == max){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957427,
                "title": "c-priority-queue-set-beat-77",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = (int)arrival.size();\\n        \\n        set<int> freeServers;\\n        for (int i = 0; i < k; i++) freeServers.insert(i);\\n        \\n        vector<int> serverTaskCount(k, 0);\\n        \\n        set<pair<int, int>> workingServers;     // [end time, server index]\\n        for (int i = 0; i < n; i++) {\\n            int startTime = arrival[i];\\n            \\n            while (!workingServers.empty() && workingServers.begin()->first <= startTime) {\\n                auto s = *workingServers.begin();\\n                workingServers.erase(workingServers.begin());\\n                freeServers.insert(s.second);\\n            }\\n            \\n            if (freeServers.empty()) continue;\\n            \\n            int serverIndex = -1;\\n            auto it = freeServers.lower_bound(i % k);\\n            if (it == freeServers.end()) {\\n                serverIndex = *freeServers.begin();\\n                freeServers.erase(freeServers.begin());\\n            } else {\\n                serverIndex = *it;\\n                freeServers.erase(it);\\n            }\\n            \\n            workingServers.insert({startTime + load[i], serverIndex});\\n            \\n            serverTaskCount[serverIndex]++;\\n            //printf(\"Task %d (%d, %d) assigned to server %d\\\\n\", i, startTime, load[i], serverIndex);\\n        }\\n        // for (auto x : serverTaskCount) cout << x << \" \";\\n        // cout << endl;\\n        \\n        vector<int> ret;\\n        int maxVal = *max_element(serverTaskCount.begin(), serverTaskCount.end());\\n        for (int i = 0; i < k; i++) \\n            if (maxVal == serverTaskCount[i]) ret.push_back(i);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = (int)arrival.size();\\n        \\n        set<int> freeServers;\\n        for (int i = 0; i < k; i++) freeServers.insert(i);\\n        \\n        vector<int> serverTaskCount(k, 0);\\n        \\n        set<pair<int, int>> workingServers;     // [end time, server index]\\n        for (int i = 0; i < n; i++) {\\n            int startTime = arrival[i];\\n            \\n            while (!workingServers.empty() && workingServers.begin()->first <= startTime) {\\n                auto s = *workingServers.begin();\\n                workingServers.erase(workingServers.begin());\\n                freeServers.insert(s.second);\\n            }\\n            \\n            if (freeServers.empty()) continue;\\n            \\n            int serverIndex = -1;\\n            auto it = freeServers.lower_bound(i % k);\\n            if (it == freeServers.end()) {\\n                serverIndex = *freeServers.begin();\\n                freeServers.erase(freeServers.begin());\\n            } else {\\n                serverIndex = *it;\\n                freeServers.erase(it);\\n            }\\n            \\n            workingServers.insert({startTime + load[i], serverIndex});\\n            \\n            serverTaskCount[serverIndex]++;\\n            //printf(\"Task %d (%d, %d) assigned to server %d\\\\n\", i, startTime, load[i], serverIndex);\\n        }\\n        // for (auto x : serverTaskCount) cout << x << \" \";\\n        // cout << endl;\\n        \\n        vector<int> ret;\\n        int maxVal = *max_element(serverTaskCount.begin(), serverTaskCount.end());\\n        for (int i = 0; i < k; i++) \\n            if (maxVal == serverTaskCount[i]) ret.push_back(i);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1277420,
                "title": "segment-tree-based-solution-beats-88-solutions-in-time-and-96-solutions-in-memory",
                "content": "```\\n#define MAXN 100001\\nclass Solution {\\npublic:\\n    int seg[4*MAXN];\\n    void update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        update(ind,l,mid,2*i+1,x);\\n        update(ind,mid+1,r,2*i+2,x);\\n        seg[i]=min(seg[2*i+1],seg[2*i+2]);\\n    }\\n    int query(int st,int en,int l,int r,int i,int x)\\n    {\\n        //cout<<l<<\" \"<<r<<\"\\\\n\";\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid=(l+r)/2;\\n        int lf=query(st,en,l,mid,2*i+1,x);\\n        if(lf!=-1)\\n            return lf;\\n        int rf=query(st,en,mid+1,r,2*i+2,x);\\n        return rf;\\n    }\\n    int que(int st,int en,int l,int r,int i,int x)\\n    {\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid=(l+r)/2;\\n        int rf=que(st,en,mid+1,r,2*i+1,x);\\n        if(rf!=-1)\\n            return rf;\\n        int lf=que(st,en,l,mid,2*i+2,x);\\n        return lf;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {\\n        int i,j,n=arr.size();\\n        j=-1;\\n        vector<int> b(n,0),ans;\\n        map<int,int> m;\\n        for(i=0;i<n;i++)\\n        {\\n            int x=query(i%k,k-1,0,k-1,0,arr[i]);\\n            if(x!=-1)\\n            {\\n                //cout<<1<<\" \"<<x<<\" \"<<i<<\"\\\\n\";\\n                m[x]++;\\n                b[x]=arr[i]+lo[i];\\n                update(x,0,k-1,0,b[x]);\\n                continue;\\n            }\\n            int y=query(0,i%k-1,0,k-1,0,arr[i]);\\n            if(y!=-1)\\n            {\\n                //cout<<2<<\" \"<<y<<\" \"<<i<<\"\\\\n\";\\n                m[y]++;\\n                b[y]=arr[i]+lo[i];\\n                update(y,0,k-1,0,b[y]);\\n            }\\n        }\\n        int maxi=0;\\n        for(auto e:m)\\n            maxi=max(maxi,e.second);\\n        // for(auto e:m)\\n        // cout<<e.first<<\" \"<<e.second<<\"\\\\n\";\\n        for(auto e:m)\\n        {\\n            if(e.second==maxi)\\n                ans.push_back(e.first);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int seg[4*MAXN];\\n    void update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 942408,
                "title": "rust-binary-heap-and-btreeset",
                "content": "I use a BTreeSet to keep track of the  of the available servers and and a priority queue to keep track of the assigned requests. \\n\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        let k = k as usize;\\n        let mut servers = BTreeSet::new();\\n        for i in 0..k {\\n            servers.insert(i);\\n        }\\n        \\n        let mut activeRequests: BinaryHeap<Reverse<(i32, usize)>> = BinaryHeap::new();\\n        let mut iterator = arrival.iter().zip(load.iter()).peekable();\\n        let mut requests = vec![0; k];\\n        let mut i = 0;\\n        \\n        while let Some((&t2, &l)) = iterator.peek() {\\n            if activeRequests.peek().is_none() || (activeRequests.peek().unwrap().0).0 > t2 {\\n                let (time, load) = iterator.next().unwrap();\\n                \\n                if servers.len() > 0 {\\n                    let s = if let Some(server) = servers.range(i..).next() {\\n                        *server\\n                    } else {\\n                        *servers.range(..).next().unwrap()\\n                    };\\n                    servers.remove(&s);\\n                    requests[s] += 1;\\n                    activeRequests.push(Reverse((time+load, s)));\\n                }\\n                i += 1;\\n                i %= k;\\n            } else {\\n                let Reverse((_, server)) = activeRequests.pop().unwrap();\\n                servers.insert(server);\\n            }\\n        }\\n\\n        let maxR = *requests.iter().max().unwrap();\\n        requests.iter().enumerate().filter(|x| *x.1 == maxR).map(|x|x.0 as i32).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        let k = k as usize;\\n        let mut servers = BTreeSet::new();\\n        for i in 0..k {\\n            servers.insert(i);\\n        }\\n        \\n        let mut activeRequests: BinaryHeap<Reverse<(i32, usize)>> = BinaryHeap::new();\\n        let mut iterator = arrival.iter().zip(load.iter()).peekable();\\n        let mut requests = vec![0; k];\\n        let mut i = 0;\\n        \\n        while let Some((&t2, &l)) = iterator.peek() {\\n            if activeRequests.peek().is_none() || (activeRequests.peek().unwrap().0).0 > t2 {\\n                let (time, load) = iterator.next().unwrap();\\n                \\n                if servers.len() > 0 {\\n                    let s = if let Some(server) = servers.range(i..).next() {\\n                        *server\\n                    } else {\\n                        *servers.range(..).next().unwrap()\\n                    };\\n                    servers.remove(&s);\\n                    requests[s] += 1;\\n                    activeRequests.push(Reverse((time+load, s)));\\n                }\\n                i += 1;\\n                i %= k;\\n            } else {\\n                let Reverse((_, server)) = activeRequests.pop().unwrap();\\n                servers.insert(server);\\n            }\\n        }\\n\\n        let maxR = *requests.iter().max().unwrap();\\n        requests.iter().enumerate().filter(|x| *x.1 == maxR).map(|x|x.0 as i32).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881649,
                "title": "line-sweep",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int[] eventToServer = new int[arrival.length];\\n        TreeSet<Integer> freeServers = new TreeSet<>();\\n        for(int i = 0; i<k; i++){\\n            freeServers.add(i);\\n        }\\n        \\n        Set<Integer> eventsDropped = new HashSet<>();\\n        \\n        int[][] events = new int[arrival.length*2][];//[time, eventID, start/end:0/1]\\n        \\n        for(int i = 0; i<arrival.length; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            events[i] = new int[]{start, i, 0};\\n            events[i+arrival.length] = new int[]{end, i, 1};\\n        }\\n        \\n        Arrays.sort(events, (i,j)->{\\n            if(i[0]-j[0]!=0){\\n                return i[0]-j[0];\\n            }\\n            if(i[2]==0 && j[2]==1){\\n                return 1;\\n            }else if(i[2]==1 && j[2]==0){\\n                return -1;\\n            }\\n            return i[1]-j[1];\\n        });\\n        \\n        for(int i = 0; i<(arrival.length*2); i++){\\n            int[] event = events[i];\\n            int serverID = event[1]%k;\\n            \\n            if(event[2]==0){\\n                if(freeServers.size()>0){\\n                    Integer actualServerID = freeServers.ceiling(serverID);\\n                    if(actualServerID==null){\\n                        serverID=-1;\\n                        actualServerID = freeServers.ceiling(serverID);\\n                    }\\n                    counts[actualServerID]++;\\n                    freeServers.remove(actualServerID);\\n                    eventToServer[event[1]] = actualServerID;\\n                }else{\\n                    eventsDropped.add(event[1]);\\n                }\\n            }else{\\n                if(!eventsDropped.contains(event[1])){\\n                    freeServers.add(eventToServer[event[1]]);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        List<Integer> result = new ArrayList<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i<k; i++){\\n            if(max<counts[i]){\\n                result.clear();\\n                max = counts[i];\\n                result.add(i);\\n            }else if(max==counts[i]){\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int[] eventToServer = new int[arrival.length];\\n        TreeSet<Integer> freeServers = new TreeSet<>();\\n        for(int i = 0; i<k; i++){\\n            freeServers.add(i);\\n        }\\n        \\n        Set<Integer> eventsDropped = new HashSet<>();\\n        \\n        int[][] events = new int[arrival.length*2][];//[time, eventID, start/end:0/1]\\n        \\n        for(int i = 0; i<arrival.length; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            events[i] = new int[]{start, i, 0};\\n            events[i+arrival.length] = new int[]{end, i, 1};\\n        }\\n        \\n        Arrays.sort(events, (i,j)->{\\n            if(i[0]-j[0]!=0){\\n                return i[0]-j[0];\\n            }\\n            if(i[2]==0 && j[2]==1){\\n                return 1;\\n            }else if(i[2]==1 && j[2]==0){\\n                return -1;\\n            }\\n            return i[1]-j[1];\\n        });\\n        \\n        for(int i = 0; i<(arrival.length*2); i++){\\n            int[] event = events[i];\\n            int serverID = event[1]%k;\\n            \\n            if(event[2]==0){\\n                if(freeServers.size()>0){\\n                    Integer actualServerID = freeServers.ceiling(serverID);\\n                    if(actualServerID==null){\\n                        serverID=-1;\\n                        actualServerID = freeServers.ceiling(serverID);\\n                    }\\n                    counts[actualServerID]++;\\n                    freeServers.remove(actualServerID);\\n                    eventToServer[event[1]] = actualServerID;\\n                }else{\\n                    eventsDropped.add(event[1]);\\n                }\\n            }else{\\n                if(!eventsDropped.contains(event[1])){\\n                    freeServers.add(eventToServer[event[1]]);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        List<Integer> result = new ArrayList<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i<k; i++){\\n            if(max<counts[i]){\\n                result.clear();\\n                max = counts[i];\\n                result.add(i);\\n            }else if(max==counts[i]){\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877305,
                "title": "golang-solutions-using-three-heaps-with-runnable-tests",
                "content": "Idea is based on the following Python solution: https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps\\n\\nRunnable tests on playground: https://play.golang.org/p/KmXY1RIWA5z\\n\\n```go\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n\\t// min heaps of items, sorted by \"priority\" value:\\n\\t//  - jobs heap    - will store requests that are being processed right now\\n\\t//  - serversBef   - will store ordered list of servers with server number less than one we need\\n\\t//  - serversAfter - will store ordered list of servers with server number equal or greater\\n\\tvar jobs, serversBef, serversAfter PriorityQueue\\n\\tvar reqs = make([]int, k) // to store number of handled requests\\n\\n\\t// populate initial list of available servers\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tvar node = &Item{\\n\\t\\t\\tnum:      i,\\n\\t\\t\\tpriority: i,\\n\\t\\t\\tindex:    i,\\n\\t\\t}\\n\\n\\t\\tserversBef = append(serversBef, node)\\n\\t}\\n\\theap.Init(&serversBef)\\n\\n\\tfor i := range arrival {\\n\\t\\tsec := arrival[i]\\n\\t\\tload := load[i]\\n\\t\\tnum := i % k\\n\\t\\t// fmt.Println(sec, \"Looking for server\", num)\\n\\n\\t\\t// if we need first server, than swap\\n\\t\\t// \"before\" and \"after\" heaps, because all\\n\\t\\t// servers should become \"after\" at this point\\n\\t\\tif num == 0 {\\n\\t\\t\\tserversAfter = serversBef\\n\\t\\t\\tserversBef = PriorityQueue{}\\n\\t\\t}\\n\\n\\t\\t// check if some jobs completed, so we can\\n\\t\\t// count server as available\\n\\t\\tfor jobs.Len() > 0 {\\n\\t\\t\\t// since jobs are prioritized (sorted) by\\n\\t\\t\\t// time, it is enough to keep popping jobs\\n\\t\\t\\t// from the queue and check if time it\\'s time\\n\\t\\t\\tjob := heap.Pop(&jobs).(*Item)\\n\\t\\t\\tif job.priority > sec {\\n\\t\\t\\t\\t// if job\\'s time hasn\\'t passed yet\\n\\t\\t\\t\\t// put it back to the list, and stop checking\\n\\t\\t\\t\\theap.Push(&jobs, job)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now we know that this server become available\\n\\t\\t\\tnode := &Item{num: job.num, priority: job.num}\\n\\t\\t\\t// put it in the proper queue of nodes (sorted by server num)\\n\\t\\t\\tif job.num < num {\\n\\t\\t\\t\\theap.Push(&serversBef, node)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\theap.Push(&serversAfter, node)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar node *Item\\n\\t\\t// check if any server with number equal or\\n\\t\\t// greater to our is available, if it is\\n\\t\\t// pop the smallest one, if not\\n\\t\\t// pop from the \"before\" queue\\n\\t\\tif serversAfter.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversAfter).(*Item)\\n\\t\\t} else if serversBef.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversBef).(*Item)\\n\\t\\t} else {\\n\\t\\t\\t// if both queues are empty, this means\\n\\t\\t\\t// that all servers are busy at the moment\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// add job processed by this node to the\\n\\t\\t// jobs queue\\n\\t\\tjob := &Item{\\n\\t\\t\\tnum:      node.num,\\n\\t\\t\\tpriority: sec + load,\\n\\t\\t}\\n\\t\\theap.Push(&jobs, job)\\n\\t\\t// and increase processes requests count\\n\\t\\treqs[node.num]++\\n\\t}\\n\\n\\t// now find the busiest servers\\n\\tvar mr = map[int][]int{}\\n\\tvar max = 0\\n\\tfor i, r := range reqs {\\n\\t\\tif r > max {\\n\\t\\t\\tmax = r\\n\\t\\t}\\n\\t\\tmr[r] = append(mr[r], i)\\n\\t}\\n\\n\\treturn mr[max]\\n}\\n\\n// PQ implementation:\\n\\n// https://golang.org/src/container/heap/example_pq_test.go\\n// An Item is something we manage in a priority queue.\\ntype Item struct {\\n\\tnum      int\\n\\tpriority int\\n\\tindex    int\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\tif pq[i].priority == pq[j].priority {\\n\\t\\treturn pq[i].num < pq[j].num\\n\\t}\\n\\treturn pq[i].priority < pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n\\t// min heaps of items, sorted by \"priority\" value:\\n\\t//  - jobs heap    - will store requests that are being processed right now\\n\\t//  - serversBef   - will store ordered list of servers with server number less than one we need\\n\\t//  - serversAfter - will store ordered list of servers with server number equal or greater\\n\\tvar jobs, serversBef, serversAfter PriorityQueue\\n\\tvar reqs = make([]int, k) // to store number of handled requests\\n\\n\\t// populate initial list of available servers\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tvar node = &Item{\\n\\t\\t\\tnum:      i,\\n\\t\\t\\tpriority: i,\\n\\t\\t\\tindex:    i,\\n\\t\\t}\\n\\n\\t\\tserversBef = append(serversBef, node)\\n\\t}\\n\\theap.Init(&serversBef)\\n\\n\\tfor i := range arrival {\\n\\t\\tsec := arrival[i]\\n\\t\\tload := load[i]\\n\\t\\tnum := i % k\\n\\t\\t// fmt.Println(sec, \"Looking for server\", num)\\n\\n\\t\\t// if we need first server, than swap\\n\\t\\t// \"before\" and \"after\" heaps, because all\\n\\t\\t// servers should become \"after\" at this point\\n\\t\\tif num == 0 {\\n\\t\\t\\tserversAfter = serversBef\\n\\t\\t\\tserversBef = PriorityQueue{}\\n\\t\\t}\\n\\n\\t\\t// check if some jobs completed, so we can\\n\\t\\t// count server as available\\n\\t\\tfor jobs.Len() > 0 {\\n\\t\\t\\t// since jobs are prioritized (sorted) by\\n\\t\\t\\t// time, it is enough to keep popping jobs\\n\\t\\t\\t// from the queue and check if time it\\'s time\\n\\t\\t\\tjob := heap.Pop(&jobs).(*Item)\\n\\t\\t\\tif job.priority > sec {\\n\\t\\t\\t\\t// if job\\'s time hasn\\'t passed yet\\n\\t\\t\\t\\t// put it back to the list, and stop checking\\n\\t\\t\\t\\theap.Push(&jobs, job)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now we know that this server become available\\n\\t\\t\\tnode := &Item{num: job.num, priority: job.num}\\n\\t\\t\\t// put it in the proper queue of nodes (sorted by server num)\\n\\t\\t\\tif job.num < num {\\n\\t\\t\\t\\theap.Push(&serversBef, node)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\theap.Push(&serversAfter, node)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar node *Item\\n\\t\\t// check if any server with number equal or\\n\\t\\t// greater to our is available, if it is\\n\\t\\t// pop the smallest one, if not\\n\\t\\t// pop from the \"before\" queue\\n\\t\\tif serversAfter.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversAfter).(*Item)\\n\\t\\t} else if serversBef.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversBef).(*Item)\\n\\t\\t} else {\\n\\t\\t\\t// if both queues are empty, this means\\n\\t\\t\\t// that all servers are busy at the moment\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// add job processed by this node to the\\n\\t\\t// jobs queue\\n\\t\\tjob := &Item{\\n\\t\\t\\tnum:      node.num,\\n\\t\\t\\tpriority: sec + load,\\n\\t\\t}\\n\\t\\theap.Push(&jobs, job)\\n\\t\\t// and increase processes requests count\\n\\t\\treqs[node.num]++\\n\\t}\\n\\n\\t// now find the busiest servers\\n\\tvar mr = map[int][]int{}\\n\\tvar max = 0\\n\\tfor i, r := range reqs {\\n\\t\\tif r > max {\\n\\t\\t\\tmax = r\\n\\t\\t}\\n\\t\\tmr[r] = append(mr[r], i)\\n\\t}\\n\\n\\treturn mr[max]\\n}\\n\\n// PQ implementation:\\n\\n// https://golang.org/src/container/heap/example_pq_test.go\\n// An Item is something we manage in a priority queue.\\ntype Item struct {\\n\\tnum      int\\n\\tpriority int\\n\\tindex    int\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\tif pq[i].priority == pq[j].priority {\\n\\t\\treturn pq[i].num < pq[j].num\\n\\t}\\n\\treturn pq[i].priority < pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545310,
                "title": "c-code-for-beginners-easy-understanding-code-set-binary-search-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> serverUsed(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> lockedServer;\\n        set<int> serverAvail;\\n        for(int i=0;i<k;i++){\\n            serverAvail.insert(i);\\n        }\\n        for(int i=0;i<arrival.size();i++){\\n            while(!lockedServer.empty() && lockedServer.top().first<=arrival[i]){  // every server that has deadline before this arrival\\n                serverAvail.insert(lockedServer.top().second);\\n                lockedServer.pop();\\n            }\\n            if(serverAvail.empty()){  // if no server available, whoops, this current task skipped\\n                continue;\\n            }\\n            auto serverAssigned=serverAvail.lower_bound(i%k);  // get as per condition the server \\n            if(serverAssigned==serverAvail.end()){\\n                serverAssigned=serverAvail.begin();\\n            }\\n            lockedServer.push({arrival[i]+load[i],*serverAssigned});\\n            serverUsed[*serverAssigned]++;\\n            serverAvail.erase(*serverAssigned);\\n        }\\n        \\n        int mxUsage=*max_element(serverUsed.begin(),serverUsed.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++){\\n            if(serverUsed[i]==mxUsage){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> serverUsed(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> lockedServer;\\n        set<int> serverAvail;\\n        for(int i=0;i<k;i++){\\n            serverAvail.insert(i);\\n        }\\n        for(int i=0;i<arrival.size();i++){\\n            while(!lockedServer.empty() && lockedServer.top().first<=arrival[i]){  // every server that has deadline before this arrival\\n                serverAvail.insert(lockedServer.top().second);\\n                lockedServer.pop();\\n            }\\n            if(serverAvail.empty()){  // if no server available, whoops, this current task skipped\\n                continue;\\n            }\\n            auto serverAssigned=serverAvail.lower_bound(i%k);  // get as per condition the server \\n            if(serverAssigned==serverAvail.end()){\\n                serverAssigned=serverAvail.begin();\\n            }\\n            lockedServer.push({arrival[i]+load[i],*serverAssigned});\\n            serverUsed[*serverAssigned]++;\\n            serverAvail.erase(*serverAssigned);\\n        }\\n        \\n        int mxUsage=*max_element(serverUsed.begin(),serverUsed.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++){\\n            if(serverUsed[i]==mxUsage){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287566,
                "title": "java-priorityqueue-and-treeset-with-explanation-o-nlogk",
                "content": "Queue to add the running/busy servers after assigning the work load.\\nTreeSet to add the available/free servers - treeset maintains ascending order, add the servers from 0 -> k-1 in the treeset.\\nserverHandledReqCount int[] array to keep the count of the requests handled by each server.\\n\\niterate over the arrival times, if the running servers queue is empty, get the server from the available servers queue.\\nwith the formula - available.ceiling(idx % k);\\n\\nadd the arrivalTime + loadTime = workTime and the server index into the runningServers queue.\\n\\npeek if the server\\'s work time is less than or equal to the next task completion time, if it is poll those servers from the running servers queue and add the index of that server to the availableServerIdxs treeSet\\n\\nlastly iterate over the serverHandledReqCount[] array and get the max value and add those servers who has the max value into a list and return that list\\n\\n``` \\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        // use a tree to track available servers\\n        TreeSet<Integer> availableServerIdxs = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            availableServerIdxs.add(num);\\n        }\\n        // use a PQ to maintain the availability based on curTime + loadTime and the server index = idx%k\\n        Queue<int[]> runningServers = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        \\n        int[] serverHandledReqCount = new int[k];\\n        \\n        for (int idx = 0; idx < arrival.length; idx++) {\\n            int newTaskCompletionTime = arrival[idx];\\n            \\n          //  peek if the server\\'s work time is less than or equal to the next task completion time, if it is poll those servers from the running servers queue and add the index of that server to the availableServerIdxs treeSet\\n            while (!runningServers.isEmpty() && runningServers.peek()[0] <= newTaskCompletionTime) {\\n                int freedServer = runningServers.poll()[1];\\n                availableServerIdxs.add(freedServer);\\n            }\\n            \\n            if (availableServerIdxs.size() == 0) continue; // all busy\\n            \\n            // to always get the last freed server\\n            Integer serverIdx = availableServerIdxs.ceiling(idx % k);\\n            \\n            if (serverIdx == null) {\\n                serverIdx = availableServerIdxs.first();\\n            }\\n            \\n            serverHandledReqCount[serverIdx]++;\\n            availableServerIdxs.remove(serverIdx);\\n            \\n            runningServers.offer(new int[] {newTaskCompletionTime + load[idx], serverIdx});\\n        }\\n        \\n        int max = Arrays.stream(serverHandledReqCount).max().getAsInt();\\n        return IntStream.range(0, k).filter(i -> serverHandledReqCount[i] == max).boxed().collect(Collectors.toList());\\n        \\n        //return findMaxesInCounter(counter);\\n    }\\n    \\n    /*\\n    private List<Integer> findMaxesInCounter(int[] counter) {\\n        int max = 0;\\n        for (int i = 0; i < counter.length; i++) {\\n            max = Math.max(max, counter[i]);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] == max) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n    */\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        // use a tree to track available servers\\n        TreeSet<Integer> availableServerIdxs = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            availableServerIdxs.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1769140,
                "title": "java-solution-using-heap-and-sorted-set",
                "content": "We use 2 data structures that together answer the main question (faster compared to linear scan):\\n*Which server with **smallest id with ceiling i%k** is **available** at time arrival[i]?*\\n\\n1. **availability** can be answered by Min heap ordered by end time of each server called busy.\\n2. **smalled id with ceiling i%k** can be answered by sorted set ordered by server id called free.\\n\\nWhile iterating over the loads:\\n1. move free servers from busy to free at arrival[i] (server.freeAt <= arrival[i])\\n2. query free servers to return smallest id after i%k (if none, get smallet id after 0).\\n3. update freeAt and move server from free to busy.\\n\\nKeep track of maxServer handled and add to the return list accodingly.\\n \\n```\\nclass Solution {\\n    \\n    static class Server {\\n        int id;\\n        int freeAt;\\n        int tasksHandled;\\n        \\n        public Server(int id, int freeAt) {\\n            this.id = id;\\n            this.freeAt = freeAt;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            Server s = (Server) o;\\n            return s.id == this.id;\\n        }\\n        \\n        public int hashCode() {\\n            return this.id;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Server> free = new TreeSet<Server>((x, y) -> {return x.id - y.id;});\\n        PriorityQueue<Server> busy = new PriorityQueue<Server>((x, y) -> {return x.freeAt - y.freeAt;});\\n        \\n        int maxHandled = 0;\\n        List<Integer> maxHandleServers = null;\\n        \\n        for(int i=0; i<k; i++) free.add(new Server(i, 0));\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().freeAt <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue;\\n            \\n            Server freeServer = free.ceiling(new Server(i%k, 0));\\n            if(freeServer == null) freeServer = free.first();\\n            \\n            freeServer.freeAt = arrival[i] + load[i];\\n            freeServer.tasksHandled++;\\n            \\n            if(freeServer.tasksHandled > maxHandled) {\\n                maxHandled = freeServer.tasksHandled;\\n                maxHandleServers = new ArrayList();\\n                maxHandleServers.add(freeServer.id);\\n            } else if(freeServer.tasksHandled == maxHandled) {\\n                maxHandleServers.add(freeServer.id);\\n            }\\n            \\n            free.remove(freeServer);\\n            busy.add(freeServer);\\n        }\\n        \\n        return maxHandleServers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class Server {\\n        int id;\\n        int freeAt;\\n        int tasksHandled;\\n        \\n        public Server(int id, int freeAt) {\\n            this.id = id;\\n            this.freeAt = freeAt;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            Server s = (Server) o;\\n            return s.id == this.id;\\n        }\\n        \\n        public int hashCode() {\\n            return this.id;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Server> free = new TreeSet<Server>((x, y) -> {return x.id - y.id;});\\n        PriorityQueue<Server> busy = new PriorityQueue<Server>((x, y) -> {return x.freeAt - y.freeAt;});\\n        \\n        int maxHandled = 0;\\n        List<Integer> maxHandleServers = null;\\n        \\n        for(int i=0; i<k; i++) free.add(new Server(i, 0));\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().freeAt <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue;\\n            \\n            Server freeServer = free.ceiling(new Server(i%k, 0));\\n            if(freeServer == null) freeServer = free.first();\\n            \\n            freeServer.freeAt = arrival[i] + load[i];\\n            freeServer.tasksHandled++;\\n            \\n            if(freeServer.tasksHandled > maxHandled) {\\n                maxHandled = freeServer.tasksHandled;\\n                maxHandleServers = new ArrayList();\\n                maxHandleServers.add(freeServer.id);\\n            } else if(freeServer.tasksHandled == maxHandled) {\\n                maxHandleServers.add(freeServer.id);\\n            }\\n            \\n            free.remove(freeServer);\\n            busy.add(freeServer);\\n        }\\n        \\n        return maxHandleServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711856,
                "title": "swift-heap-o-nlogn-logk",
                "content": "See details explaination from this article\\nhttps://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps\\n\\nBelow is Swift version\\n```\\nclass Heap<T> {\\n    private var data: [T] = []\\n    var count: Int {\\n        return data.count\\n    }\\n    private var sort: ((T, T) -> Bool)!\\n    init (_ sort: @escaping ((T, T) -> Bool)) {\\n        self.sort = sort\\n    }\\n    private func p(_ i: Int) -> Int { return (i - 1) / 2 }\\n    private func l(_ i: Int) -> Int { return i * 2 + 1 }\\n    private func r(_ i: Int) -> Int { return i * 2 + 2 }\\n    func isEmpty() -> Bool {\\n        return data.isEmpty\\n    }\\n    func add(_ val: T) {\\n        data.append(val)\\n        swim(data.count - 1)\\n    }\\n    private func swim(_ i: Int) {\\n        if sort(data[i], data[p(i)]) {\\n            data.swapAt(i, p(i))\\n            swim(p(i))\\n        }\\n    }\\n    func remove() -> T? {\\n        if data.count == 0 { return nil }\\n        if data.count == 1 { return data.removeLast() }\\n        let node = data[0]\\n        data[0] = data.removeLast()\\n        dive(0)\\n        return node\\n    }\\n    private func dive(_ i: Int) {\\n        let left = l(i) >= data.count ? data[i] : data[l(i)]\\n        let right = r(i) >= data.count ? data[i] : data[r(i)]\\n        if sort(left, data[i]) || sort(right, data[i]) {\\n            if sort(left, right) {\\n                data.swapAt(i, l(i))\\n                dive(l(i))\\n            } else {\\n                data.swapAt(i, r(i))\\n                dive(r(i))\\n            }\\n        }\\n    }\\n    func top() -> T? {\\n        return data.first\\n    }\\n}\\n\\nclass Solution {\\n    // Time: O(nlogn * logk) n is number of request, k is number of servers\\n    // Space: O(n+k)\\n    func busiestServers(_ k: Int, _ arrival: [Int], _ load: [Int]) -> [Int] {     \\n        // store current server are working, stored by end time\\n        var sessions = Heap<(Int,Int)> { $0.0 < $1.0 } \\n        \\n        // store server of current round\\n        var currentRound = Heap<Int> { $0 < $1 }\\n        \\n        // store server of next round\\n        var nextRound = Heap<Int> { $0 < $1 }\\n        for i in 0..<k {\\n            nextRound.add(i)\\n        }\\n        \\n        // record how many request of a server executed\\n        var timesheet = Array(repeating: 0, count: k)\\n        \\n        // map into requests (startTime, duration)\\n        var requests: [(Int, Int)] = []\\n        for i in 0..<arrival.count {\\n            requests.append((arrival[i], load[i]))\\n        }\\n        \\n        // start requesting...\\n        for (index, (startTime, duration)) in requests.enumerated() {\\n            let roundRobinServer = index % k\\n            // it is time to go back\\n            if roundRobinServer == 0 {\\n                currentRound = nextRound\\n                nextRound = Heap<Int> { $0 < $1 }\\n            }\\n            \\n            // releases servers which already done executing previous requests\\n            while sessions.count > 0 && sessions.top()!.0 <= startTime {\\n                let freeServer = sessions.remove()!.1\\n                \\n                // if server is free is < roundRobinServer, so it should be added to next round (current round more priority)\\n                if freeServer < roundRobinServer {\\n                    nextRound.add(freeServer)\\n                } else {\\n                    currentRound.add(freeServer)\\n                }\\n            }\\n            \\n            // now just pick a server from current round\\n            var chosenServer = -1\\n            if currentRound.count > 0 {\\n                chosenServer = currentRound.remove()!\\n            // if current round is out of server, consider to next round\\n            } else if nextRound.count > 0 {\\n                chosenServer = nextRound.remove()!\\n            }\\n            \\n            // if no server is availble, drop that\\n            if chosenServer == -1 {\\n                continue\\n            }\\n            \\n            // increment for the server execute this request\\n            timesheet[chosenServer] += 1\\n            // ... and add it into session\\n            sessions.add((startTime + duration, chosenServer))\\n        }\\n        \\n        // find out the maximum requests and all server has same amount\\n        var ans: [Int] = []\\n        var maxRequest = 0\\n        for server in 0..<timesheet.count {\\n            if maxRequest < timesheet[server] {\\n                maxRequest = timesheet[server]\\n                ans = []\\n            }\\n            if maxRequest == timesheet[server] {\\n                ans.append(server)\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Heap<T> {\\n    private var data: [T] = []\\n    var count: Int {\\n        return data.count\\n    }\\n    private var sort: ((T, T) -> Bool)!\\n    init (_ sort: @escaping ((T, T) -> Bool)) {\\n        self.sort = sort\\n    }\\n    private func p(_ i: Int) -> Int { return (i - 1) / 2 }\\n    private func l(_ i: Int) -> Int { return i * 2 + 1 }\\n    private func r(_ i: Int) -> Int { return i * 2 + 2 }\\n    func isEmpty() -> Bool {\\n        return data.isEmpty\\n    }\\n    func add(_ val: T) {\\n        data.append(val)\\n        swim(data.count - 1)\\n    }\\n    private func swim(_ i: Int) {\\n        if sort(data[i], data[p(i)]) {\\n            data.swapAt(i, p(i))\\n            swim(p(i))\\n        }\\n    }\\n    func remove() -> T? {\\n        if data.count == 0 { return nil }\\n        if data.count == 1 { return data.removeLast() }\\n        let node = data[0]\\n        data[0] = data.removeLast()\\n        dive(0)\\n        return node\\n    }\\n    private func dive(_ i: Int) {\\n        let left = l(i) >= data.count ? data[i] : data[l(i)]\\n        let right = r(i) >= data.count ? data[i] : data[r(i)]\\n        if sort(left, data[i]) || sort(right, data[i]) {\\n            if sort(left, right) {\\n                data.swapAt(i, l(i))\\n                dive(l(i))\\n            } else {\\n                data.swapAt(i, r(i))\\n                dive(r(i))\\n            }\\n        }\\n    }\\n    func top() -> T? {\\n        return data.first\\n    }\\n}\\n\\nclass Solution {\\n    // Time: O(nlogn * logk) n is number of request, k is number of servers\\n    // Space: O(n+k)\\n    func busiestServers(_ k: Int, _ arrival: [Int], _ load: [Int]) -> [Int] {     \\n        // store current server are working, stored by end time\\n        var sessions = Heap<(Int,Int)> { $0.0 < $1.0 } \\n        \\n        // store server of current round\\n        var currentRound = Heap<Int> { $0 < $1 }\\n        \\n        // store server of next round\\n        var nextRound = Heap<Int> { $0 < $1 }\\n        for i in 0..<k {\\n            nextRound.add(i)\\n        }\\n        \\n        // record how many request of a server executed\\n        var timesheet = Array(repeating: 0, count: k)\\n        \\n        // map into requests (startTime, duration)\\n        var requests: [(Int, Int)] = []\\n        for i in 0..<arrival.count {\\n            requests.append((arrival[i], load[i]))\\n        }\\n        \\n        // start requesting...\\n        for (index, (startTime, duration)) in requests.enumerated() {\\n            let roundRobinServer = index % k\\n            // it is time to go back\\n            if roundRobinServer == 0 {\\n                currentRound = nextRound\\n                nextRound = Heap<Int> { $0 < $1 }\\n            }\\n            \\n            // releases servers which already done executing previous requests\\n            while sessions.count > 0 && sessions.top()!.0 <= startTime {\\n                let freeServer = sessions.remove()!.1\\n                \\n                // if server is free is < roundRobinServer, so it should be added to next round (current round more priority)\\n                if freeServer < roundRobinServer {\\n                    nextRound.add(freeServer)\\n                } else {\\n                    currentRound.add(freeServer)\\n                }\\n            }\\n            \\n            // now just pick a server from current round\\n            var chosenServer = -1\\n            if currentRound.count > 0 {\\n                chosenServer = currentRound.remove()!\\n            // if current round is out of server, consider to next round\\n            } else if nextRound.count > 0 {\\n                chosenServer = nextRound.remove()!\\n            }\\n            \\n            // if no server is availble, drop that\\n            if chosenServer == -1 {\\n                continue\\n            }\\n            \\n            // increment for the server execute this request\\n            timesheet[chosenServer] += 1\\n            // ... and add it into session\\n            sessions.add((startTime + duration, chosenServer))\\n        }\\n        \\n        // find out the maximum requests and all server has same amount\\n        var ans: [Int] = []\\n        var maxRequest = 0\\n        for server in 0..<timesheet.count {\\n            if maxRequest < timesheet[server] {\\n                maxRequest = timesheet[server]\\n                ans = []\\n            }\\n            if maxRequest == timesheet[server] {\\n                ans.append(server)\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411210,
                "title": "c-intuitive-map-heap-set-binary-search",
                "content": "Servers : The available servers right now\\npq : Busy servers right now\\nbusy : a map which contains the number of requests a servere handles\\n\\nIntuition : We compare the end time of currently busy servers with the arrival time of the new request. If the arrival time is greater, that means our server has finished its task and is now free to use.\\n\\nHow to handle next request?\\nSince the set is sorted, we search the next element which is greater than or equal to the required server. If we can\\'t find any such server, then we go back to the begining of the set to find the first free server.\\n\\nWe can further optimize it using unordered_map for busy.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> servers;\\n        priority_queue< pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > pq;\\n        \\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        \\n        map<int ,int> busy;\\n        int n=arrival.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int start=arrival[i],end=arrival[i]+load[i];\\n            while(!pq.empty() and pq.top().first<=start)\\n            {\\n                auto it=pq.top();\\n                pq.pop();\\n                servers.insert(it.second);\\n            }\\n            if(servers.empty())\\n                continue;\\n            auto ser=servers.lower_bound(i%k);\\n            if(ser==servers.end())\\n                ser=servers.begin();\\n            \\n            int serverNo=*ser;\\n            cout<<serverNo<<\" \";\\n            pq.push({end,serverNo});\\n            busy[serverNo]++;\\n            servers.erase(ser);\\n        }\\n        int maxBusy=0;\\n        for(auto it:busy)\\n            maxBusy=max(maxBusy,it.second);\\n        vector<int> res;\\n        for(auto it:busy)\\n        {\\n            if(it.second==maxBusy)\\n                res.push_back(it.first);\\n        }\\n        return res;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> servers;\\n        priority_queue< pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > pq;\\n        \\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        \\n        map<int ,int> busy;\\n        int n=arrival.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int start=arrival[i],end=arrival[i]+load[i];\\n            while(!pq.empty() and pq.top().first<=start)\\n            {\\n                auto it=pq.top();\\n                pq.pop();\\n                servers.insert(it.second);\\n            }\\n            if(servers.empty())\\n                continue;\\n            auto ser=servers.lower_bound(i%k);\\n            if(ser==servers.end())\\n                ser=servers.begin();\\n            \\n            int serverNo=*ser;\\n            cout<<serverNo<<\" \";\\n            pq.push({end,serverNo});\\n            busy[serverNo]++;\\n            servers.erase(ser);\\n        }\\n        int maxBusy=0;\\n        for(auto it:busy)\\n            maxBusy=max(maxBusy,it.second);\\n        vector<int> res;\\n        for(auto it:busy)\\n        {\\n            if(it.second==maxBusy)\\n                res.push_back(it.first);\\n        }\\n        return res;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1343862,
                "title": "c-priority-queue-set-suggestions-improvements-are-welcome",
                "content": "```\\n\\ntypedef pair<int, int> pr;\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    \\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        // min heap to store busy servers\\n        priority_queue<pr, vector<pr>, greater<pr>> busy;\\n        \\n        // set to store available servers\\n        set<int> avail;\\n        \\n        int count[k]; // keep track of hits for each server\\n\\n        int currentServer = 0; //for current starting index\\n        \\n        for(int j = 0; j<k; j++){\\n            avail.insert(j);\\n            count[j] = 0;\\n        }\\n        \\n \\n        int t = 0;       \\n        for(int i: arrival){\\n            \\n            currentServer = t % k; //set starting server for checking\\n \\n            //pop freed-up servers\\n            while(!busy.empty() && busy.top().first <= i){\\n\\n                avail.insert(busy.top().second);\\n                busy.pop();\\n            }\\n                 \\n            //iterators for next available server(returns next available server if desired server is busy)\\n            auto it = avail.lower_bound(currentServer);\\n            \\n    //iterators for next available server(returns next available server after loop back, if (it) is null)\\n            auto it0 = avail.lower_bound(0);\\n            \\n            // push into busy servers, remove from available servers\\n            if(it != avail.end()){\\n               busy.push(make_pair(i+load[t], *it));\\n               count[*it]++;\\n                avail.erase(*it);\\n            } else if(it0 != avail.end()){\\n                busy.push(make_pair(i+load[t], *it0));\\n                count[*it0]++;\\n                avail.erase(*it0);\\n            }\\n           \\n           t++;\\n        }\\n        \\n        vector<int> res;\\n        \\n        int max = 0;\\n        \\n        for(int y: count){\\n            max = y > max ? y : max;\\n        }\\n        \\n        for(int y=0; y<k; y++){\\n            if(count[y] == max) res.push_back(y);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n\\ntypedef pair<int, int> pr;\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    \\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        // min heap to store busy servers\\n        priority_queue<pr, vector<pr>, greater<pr>> busy;\\n        \\n        // set to store available servers\\n        set<int> avail;\\n        \\n        int count[k]; // keep track of hits for each server\\n\\n        int currentServer = 0; //for current starting index\\n        \\n        for(int j = 0; j<k; j++){\\n            avail.insert(j);\\n            count[j] = 0;\\n        }\\n        \\n \\n        int t = 0;       \\n        for(int i: arrival){\\n            \\n            currentServer = t % k; //set starting server for checking\\n \\n            //pop freed-up servers\\n            while(!busy.empty() && busy.top().first <= i){\\n\\n                avail.insert(busy.top().second);\\n                busy.pop();\\n            }\\n                 \\n            //iterators for next available server(returns next available server if desired server is busy)\\n            auto it = avail.lower_bound(currentServer);\\n            \\n    //iterators for next available server(returns next available server after loop back, if (it) is null)\\n            auto it0 = avail.lower_bound(0);\\n            \\n            // push into busy servers, remove from available servers\\n            if(it != avail.end()){\\n               busy.push(make_pair(i+load[t], *it));\\n               count[*it]++;\\n                avail.erase(*it);\\n            } else if(it0 != avail.end()){\\n                busy.push(make_pair(i+load[t], *it0));\\n                count[*it0]++;\\n                avail.erase(*it0);\\n            }\\n           \\n           t++;\\n        }\\n        \\n        vector<int> res;\\n        \\n        int max = 0;\\n        \\n        for(int y: count){\\n            max = y > max ? y : max;\\n        }\\n        \\n        for(int y=0; y<k; y++){\\n            if(count[y] == max) res.push_back(y);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191274,
                "title": "java-treeset-with-priorityqueue-w-explanation",
                "content": "For each query, put all of the available servers at that point to the TreeSet, so that you can find the successor in ```O(log(k))``` time. For tracking which all servers are available at the moment w/o going through the entire list, maintain a Min-Heap w.r.t finishing time, so that we can add them all to the TreeSet.\\n```\\nclass Solution \\n{\\n    public List<Integer> busiestServers(int k, int[] time, int[] load) \\n    {\\n        PriorityQueue<int[]> q=new PriorityQueue<int[]>((a,b)->((int[])a)[1]-((int[])b)[1]);\\n        TreeSet<Integer> ptr=new TreeSet<Integer>();\\n        for(int i=0;i<k;++i)\\n            ptr.add(i);\\n        int[] count=new int[k];\\n        int val=0;\\n        for(int i=0;i<time.length;++i)\\n        {\\n            while(!q.isEmpty()&&q.peek()[1]<=time[i])\\n                ptr.add(q.poll()[0]);\\n            int server=i%k;\\n            int ret=-1;\\n            if(ptr.isEmpty())\\n                continue;\\n            else if(ptr.contains(server))\\n                ret=server;\\n            else\\n            {\\n                Integer temp=ptr.higher(server);\\n                if(temp!=null)\\n                    ret=temp;\\n                else\\n                    ret=ptr.first();\\n            }\\n            if(ret!=-1)\\n            {\\n                val=Math.max(val,++count[ret]);\\n                ptr.remove(ret);\\n                q.add(new int[]{ret,time[i]+load[i]});\\n            }\\n        }\\n        List<Integer> ret=new ArrayList<Integer>();\\n        for(int i=0;i<k;++i)\\n            if(count[i]==val)\\n                ret.add(i);\\n        return ret;\\n    }\\n}\\n`````",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```O(log(k))```\n```\\nclass Solution \\n{\\n    public List<Integer> busiestServers(int k, int[] time, int[] load) \\n    {\\n        PriorityQueue<int[]> q=new PriorityQueue<int[]>((a,b)->((int[])a)[1]-((int[])b)[1]);\\n        TreeSet<Integer> ptr=new TreeSet<Integer>();\\n        for(int i=0;i<k;++i)\\n            ptr.add(i);\\n        int[] count=new int[k];\\n        int val=0;\\n        for(int i=0;i<time.length;++i)\\n        {\\n            while(!q.isEmpty()&&q.peek()[1]<=time[i])\\n                ptr.add(q.poll()[0]);\\n            int server=i%k;\\n            int ret=-1;\\n            if(ptr.isEmpty())\\n                continue;\\n            else if(ptr.contains(server))\\n                ret=server;\\n            else\\n            {\\n                Integer temp=ptr.higher(server);\\n                if(temp!=null)\\n                    ret=temp;\\n                else\\n                    ret=ptr.first();\\n            }\\n            if(ret!=-1)\\n            {\\n                val=Math.max(val,++count[ret]);\\n                ptr.remove(ret);\\n                q.add(new int[]{ret,time[i]+load[i]});\\n            }\\n        }\\n        List<Integer> ret=new ArrayList<Integer>();\\n        for(int i=0;i<k;++i)\\n            if(count[i]==val)\\n                ret.add(i);\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950834,
                "title": "c-using-priority-queue-and-set-plz-have-a-look-for-your-better-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ar array\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) {\\n        \\n        set<int >st;\\n        vector<int>freq(k);//For Finding the Busy Server \\n        for(int i=0;i<k;i++)//Initial Available Server\\n            st.insert(i);\\n        priority_queue<ar<int,2>,vector<ar<int,2> > ,greater<ar<int,2> > >pq;\\n        for(int i=0;i<A.size(); i++)\\n        {\\n            while(!pq.empty()&& pq.top()[0]<=A[i])\\n            {\\n                st.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            if(st.size()==0)// Currently Not available any Server,its means All Servers are Busy..So this request is dropped\\n            continue;\\n                auto it=st.lower_bound(i%k);// for finding next available server\\n                if(it==st.end())\\n                    it=st.lower_bound(0);\\n                int val=*it;\\n                freq[val]++;//Increase the  handled requests by this server \\n                st.erase(it);\\n                pq.push({A[i]+L[i],val});\\n            \\n        }\\n        \\n      int val=*max_element(freq.begin(),freq.end());\\n      vector<int>ans;\\n        for(int i=0;i<k; i++)\\n        {\\n            if(freq[i]==val)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ar array\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) {\\n        \\n        set<int >st;\\n        vector<int>freq(k);//For Finding the Busy Server \\n        for(int i=0;i<k;i++)//Initial Available Server\\n            st.insert(i);\\n        priority_queue<ar<int,2>,vector<ar<int,2> > ,greater<ar<int,2> > >pq;\\n        for(int i=0;i<A.size(); i++)\\n        {\\n            while(!pq.empty()&& pq.top()[0]<=A[i])\\n            {\\n                st.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            if(st.size()==0)// Currently Not available any Server,its means All Servers are Busy..So this request is dropped\\n            continue;\\n                auto it=st.lower_bound(i%k);// for finding next available server\\n                if(it==st.end())\\n                    it=st.lower_bound(0);\\n                int val=*it;\\n                freq[val]++;//Increase the  handled requests by this server \\n                st.erase(it);\\n                pq.push({A[i]+L[i],val});\\n            \\n        }\\n        \\n      int val=*max_element(freq.begin(),freq.end());\\n      vector<int>ans;\\n        for(int i=0;i<k; i++)\\n        {\\n            if(freq[i]==val)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931292,
                "title": "java-treeset-priorityqueue-131-ms-faster-than-44-71-62-4-mb-less-than-7-45",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] cnts = new int[k];\\n        int maxCnt = 0;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; ++i) {\\n            available.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        int n = load.length;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[1] <= start) {\\n                available.add(pq.poll()[0]);\\n            }\\n            if (available.isEmpty()) {\\n                continue;\\n            }\\n            Integer server = available.ceiling(i % k);\\n            if (server == null) {\\n                server = available.first();\\n            }\\n            available.remove(server);\\n            pq.offer(new int[]{server, start + load[i]});\\n            if (++cnts[server] >= maxCnt) {\\n                if (cnts[server] > maxCnt) {\\n                    maxCnt = cnts[server];\\n                    res.clear();\\n                }\\n                res.add(server);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] cnts = new int[k];\\n        int maxCnt = 0;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; ++i) {\\n            available.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        int n = load.length;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[1] <= start) {\\n                available.add(pq.poll()[0]);\\n            }\\n            if (available.isEmpty()) {\\n                continue;\\n            }\\n            Integer server = available.ceiling(i % k);\\n            if (server == null) {\\n                server = available.first();\\n            }\\n            available.remove(server);\\n            pq.offer(new int[]{server, start + load[i]});\\n            if (++cnts[server] >= maxCnt) {\\n                if (cnts[server] > maxCnt) {\\n                    maxCnt = cnts[server];\\n                    res.clear();\\n                }\\n                res.add(server);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926162,
                "title": "c-staightforward",
                "content": "```\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> freeServers;\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> jobs; //complete time, server No.\\n        vector<int> counter(k,0);\\n        for(int i=0;i<arrival.size();i++){\\n            const int t = arrival[i];\\n            \\n            // check done job, and free the servers\\n            while(!jobs.empty() && jobs.top().first <= t){\\n                auto [t_out, server] = jobs.top(); jobs.pop();\\n                freeServers.insert(server);\\n            }\\n            \\n            if(freeServers.empty()) continue;\\n            \\n            // assign job to a server\\n            auto it = freeServers.lower_bound(i%k);\\n            if(it == freeServers.end()) it = freeServers.begin();\\n            const int server = *it;\\n            freeServers.erase(it);\\n            jobs.push(pair(t+load[i], server));\\n            counter[server]++;\\n        }\\n        \\n        const int maxCount = *max_element(counter.begin(), counter.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++) if(counter[i] == maxCount) res.push_back(i);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> freeServers;\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> jobs; //complete time, server No.\\n        vector<int> counter(k,0);\\n        for(int i=0;i<arrival.size();i++){\\n            const int t = arrival[i];\\n            \\n            // check done job, and free the servers\\n            while(!jobs.empty() && jobs.top().first <= t){\\n                auto [t_out, server] = jobs.top(); jobs.pop();\\n                freeServers.insert(server);\\n            }\\n            \\n            if(freeServers.empty()) continue;\\n            \\n            // assign job to a server\\n            auto it = freeServers.lower_bound(i%k);\\n            if(it == freeServers.end()) it = freeServers.begin();\\n            const int server = *it;\\n            freeServers.erase(it);\\n            jobs.push(pair(t+load[i], server));\\n            counter[server]++;\\n        }\\n        \\n        const int maxCount = *max_element(counter.begin(), counter.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++) if(counter[i] == maxCount) res.push_back(i);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 887507,
                "title": "simple-python-sortedlist-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\ndef busiestServers(self, k: int, a: List[int], l: List[int]) -> List[int]:\\n\\tans, pq = Counter(), []\\n\\tsl = SortedList(range(k))\\n\\tfor req, (t, ld) in enumerate(zip(a, l)):            \\n\\t\\twhile pq and pq[0][0] <= t: sl.add(heappop(pq)[1])\\n\\t\\tif not sl: continue\\n\\t\\ti = sl.bisect_left(req % k)\\n\\t\\tif i >= len(sl): i = 0\\n\\t\\th = sl.pop(i)\\n\\t\\theappush(pq, (t+ld, h))\\n\\t\\tans[h] += 1            \\n\\tmx = max(ans.values())\\n\\treturn [h for h in ans if ans[h] == mx]",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\ndef busiestServers(self, k: int, a: List[int], l: List[int]) -> List[int]:\\n\\tans, pq = Counter(), []\\n\\tsl = SortedList(range(k))\\n\\tfor req, (t, ld) in enumerate(zip(a, l)):            \\n\\t\\twhile pq and pq[0][0] <= t: sl.add(heappop(pq)[1])\\n\\t\\tif not sl: continue\\n\\t\\ti = sl.bisect_left(req % k)\\n\\t\\tif i >= len(sl): i = 0\\n\\t\\th = sl.pop(i)\\n\\t\\theappush(pq, (t+ld, h))\\n\\t\\tans[h] += 1            \\n\\tmx = max(ans.values())\\n\\treturn [h for h in ans if ans[h] == mx]",
                "codeTag": "Python3"
            },
            {
                "id": 879270,
                "title": "java-o-nlogn-with-treeset-and-priorityqueue-more-comprehensive-with-server-class",
                "content": "``` java\\nclass Solution {\\n    private class Server {\\n        // index of server, 0, 1, ..., k-1\\n        public int id;\\n        // release time on timeline\\n        public int release;\\n        // number of requests this server handled\\n        public int requests;\\n\\t\\t\\n        public Server(int id) {\\n            this.id = id;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        if (k == 0 || arrival == null || load == null || arrival.length < 1 || load.length < 1 || arrival.length != load.length) {\\n            return null;\\n        }\\n        \\n        TreeSet<Server> availableServers = new TreeSet<>(Comparator.comparing(s -> s.id));\\n        PriorityQueue<Server> busyServers = new PriorityQueue<>(Comparator.comparing(s -> s.release));\\n        int maxRequests = 0;\\n\\n        // initially all servers are available\\n        for (int i=0; i<k; ++i) {\\n            availableServers.add(new Server(i));\\n        }\\n\\n        int n = arrival.length;\\n        for (int i=0; i<n; ++i) {\\n            int requestStart = arrival[i];\\n            int requestLoad = load[i];\\n\\n            // release all servers that completed the task at requestStart time\\n            while(!busyServers.isEmpty() && busyServers.peek().release <= requestStart) {\\n                Server s = busyServers.poll();\\n                availableServers.add(s);\\n            }\\n            \\n\\t\\t\\t// all servers are busy\\n            if (availableServers.isEmpty()) {\\n                continue;\\n            }\\n\\n            // find a server from i%k, i%k+1, ...\\n            Server s = availableServers.ceiling(new Server(i%k));\\n\\t\\t\\t// wrap around if no server after i%k\\n            if (s == null) {\\n                s = availableServers.first();\\n            }\\n            availableServers.remove(s);\\n            \\n            s.release = requestStart + requestLoad;\\n            ++s.requests;\\n            maxRequests = Math.max(maxRequests, s.requests);\\n\\n            busyServers.add(s);\\n        }\\n\\n        List<Integer> busiestServers = new ArrayList<>();\\n        \\n        for (Server s: busyServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        for (Server s: availableServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        return busiestServers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    private class Server {\\n        // index of server, 0, 1, ..., k-1\\n        public int id;\\n        // release time on timeline\\n        public int release;\\n        // number of requests this server handled\\n        public int requests;\\n\\t\\t\\n        public Server(int id) {\\n            this.id = id;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        if (k == 0 || arrival == null || load == null || arrival.length < 1 || load.length < 1 || arrival.length != load.length) {\\n            return null;\\n        }\\n        \\n        TreeSet<Server> availableServers = new TreeSet<>(Comparator.comparing(s -> s.id));\\n        PriorityQueue<Server> busyServers = new PriorityQueue<>(Comparator.comparing(s -> s.release));\\n        int maxRequests = 0;\\n\\n        // initially all servers are available\\n        for (int i=0; i<k; ++i) {\\n            availableServers.add(new Server(i));\\n        }\\n\\n        int n = arrival.length;\\n        for (int i=0; i<n; ++i) {\\n            int requestStart = arrival[i];\\n            int requestLoad = load[i];\\n\\n            // release all servers that completed the task at requestStart time\\n            while(!busyServers.isEmpty() && busyServers.peek().release <= requestStart) {\\n                Server s = busyServers.poll();\\n                availableServers.add(s);\\n            }\\n            \\n\\t\\t\\t// all servers are busy\\n            if (availableServers.isEmpty()) {\\n                continue;\\n            }\\n\\n            // find a server from i%k, i%k+1, ...\\n            Server s = availableServers.ceiling(new Server(i%k));\\n\\t\\t\\t// wrap around if no server after i%k\\n            if (s == null) {\\n                s = availableServers.first();\\n            }\\n            availableServers.remove(s);\\n            \\n            s.release = requestStart + requestLoad;\\n            ++s.requests;\\n            maxRequests = Math.max(maxRequests, s.requests);\\n\\n            busyServers.add(s);\\n        }\\n\\n        List<Integer> busiestServers = new ArrayList<>();\\n        \\n        for (Server s: busyServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        for (Server s: availableServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        return busiestServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878406,
                "title": "c-easy-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        //stores all the servers that are busy.\\n        //pair.first = time at which it will get free\\n        //pair.second = id of the server\\n        set<pair<int,int>>busyServer;\\n        \\n        //tracks the number of requests served by k servers\\n        vector<int>frequency(k,0);\\n        \\n        //tracks the available servers.\\n        set<int>availableServer;\\n        for(int i=0;i<k;i++){\\n            availableServer.insert(i);\\n        }\\n        \\n        //simulate the process\\n        for(int i=0;i<arrival.size();i++){\\n            while(!busyServer.empty()){              \\n                //it pointing to first pair of busyServer\\n                auto it = busyServer.begin();\\n                \\n                if(it->first<=arrival[i]){\\n                    //unload the first server because at time\\n                    //arrival[i], that server will become free to use again.\\n                    //Add the id of that server to available server.\\n                    availableServer.insert(it->second);\\n                    busyServer.erase(it);\\n                }else{\\n                    //if the first element has greater time than\\n                    //arrival[i] then all the elements of set will have \\n                    //greater than arrival[i], as set is sorted in increasing order\\n                    break;\\n                }\\n            }   \\n            \\n            //if there are no available servers then drop the current request\\n            if(availableServer.size()==0){\\n                continue;\\n            }\\n            \\n            //find the i%k server from available server. If that points to end\\n            //then take the first available server from the list, assuming the cyclic \\n            //nature\\n            auto it = availableServer.lower_bound(i%k);\\n            if(it==availableServer.end()){\\n                it = availableServer.begin();\\n            }\\n            \\n            //remove the it from available server and insert into busy server\\n            //note: insert ending time = arrival[i]+load[i]\\n            int id = *it;\\n            frequency[id]++;\\n            availableServer.erase(it);\\n            busyServer.insert({arrival[i]+load[i],id});\\n        }\\n        \\n        //finding the busiest server\\n        vector<int>result;\\n        int maxx = -1;\\n        for(auto it:frequency){\\n            maxx = max(maxx,it);\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(frequency[i]==maxx){\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        //stores all the servers that are busy.\\n        //pair.first = time at which it will get free\\n        //pair.second = id of the server\\n        set<pair<int,int>>busyServer;\\n        \\n        //tracks the number of requests served by k servers\\n        vector<int>frequency(k,0);\\n        \\n        //tracks the available servers.\\n        set<int>availableServer;\\n        for(int i=0;i<k;i++){\\n            availableServer.insert(i);\\n        }\\n        \\n        //simulate the process\\n        for(int i=0;i<arrival.size();i++){\\n            while(!busyServer.empty()){              \\n                //it pointing to first pair of busyServer\\n                auto it = busyServer.begin();\\n                \\n                if(it->first<=arrival[i]){\\n                    //unload the first server because at time\\n                    //arrival[i], that server will become free to use again.\\n                    //Add the id of that server to available server.\\n                    availableServer.insert(it->second);\\n                    busyServer.erase(it);\\n                }else{\\n                    //if the first element has greater time than\\n                    //arrival[i] then all the elements of set will have \\n                    //greater than arrival[i], as set is sorted in increasing order\\n                    break;\\n                }\\n            }   \\n            \\n            //if there are no available servers then drop the current request\\n            if(availableServer.size()==0){\\n                continue;\\n            }\\n            \\n            //find the i%k server from available server. If that points to end\\n            //then take the first available server from the list, assuming the cyclic \\n            //nature\\n            auto it = availableServer.lower_bound(i%k);\\n            if(it==availableServer.end()){\\n                it = availableServer.begin();\\n            }\\n            \\n            //remove the it from available server and insert into busy server\\n            //note: insert ending time = arrival[i]+load[i]\\n            int id = *it;\\n            frequency[id]++;\\n            availableServer.erase(it);\\n            busyServer.insert({arrival[i]+load[i],id});\\n        }\\n        \\n        //finding the busiest server\\n        vector<int>result;\\n        int maxx = -1;\\n        for(auto it:frequency){\\n            maxx = max(maxx,it);\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(frequency[i]==maxx){\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877081,
                "title": "python-using-2-heaps-one-for-blocked-machine-one-for-next-available",
                "content": "heap for blocked servers are easy to think for me.\\nthe next available heapq will always give i%k highest priority and so on\\n\\n\\n\\tdef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        hq=[] # heap order by free time\\n\\t\\thqs=[i for i in range(k)] # constant length heap , order by index\\n        l=[0 for i in range(k)]\\n        for i in range(len(arrival)):\\n            #free all the available machine and push into index based heap \\n            while hq:\\n                \\n                if hq[0][0]<=arrival[i]:\\n                    t=heapq.heappop(hq)\\n                    if t[1]%k>=i%k:\\n                        heapq.heappush(hqs,t[1]%k+(i//k)*k)\\n                    else:\\n                        heapq.heappush(hqs,t[1]%k+(i//k+1)*k)\\n                    #print(i,t)\\n                else:\\n                    break\\n            #get first available index (i%k has priority)\\n            if hqs:\\n                t=heapq.heappop(hqs)\\n                j=t%k\\n                l[j]+=1\\n                heapq.heappush(hq,(arrival[i]+load[i],j%k))\\n            \\n        ans=[]\\n        mmm=max(l)\\n        #print(l)\\n        for i in range(k):\\n            if l[i]==mmm:\\n                ans.append(i)\\n        return ans\\n",
                "solutionTags": [],
                "code": "heap for blocked servers are easy to think for me.\\nthe next available heapq will always give i%k highest priority and so on\\n\\n\\n\\tdef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        hq=[] # heap order by free time\\n\\t\\thqs=[i for i in range(k)] # constant length heap , order by index\\n        l=[0 for i in range(k)]\\n        for i in range(len(arrival)):\\n            #free all the available machine and push into index based heap \\n            while hq:\\n                \\n                if hq[0][0]<=arrival[i]:\\n                    t=heapq.heappop(hq)\\n                    if t[1]%k>=i%k:\\n                        heapq.heappush(hqs,t[1]%k+(i//k)*k)\\n                    else:\\n                        heapq.heappush(hqs,t[1]%k+(i//k+1)*k)\\n                    #print(i,t)\\n                else:\\n                    break\\n            #get first available index (i%k has priority)\\n            if hqs:\\n                t=heapq.heappop(hqs)\\n                j=t%k\\n                l[j]+=1\\n                heapq.heappush(hq,(arrival[i]+load[i],j%k))\\n            \\n        ans=[]\\n        mmm=max(l)\\n        #print(l)\\n        for i in range(k):\\n            if l[i]==mmm:\\n                ans.append(i)\\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 876972,
                "title": "slow-ass-javascript",
                "content": "I imagine the area this needs to be optimized is finding the correct server, but not sure how to approach that\\n\\n```\\n\\nconst busiestServers = ( k, arrival, load ) => {\\n    \\n    // keep track of how many requests each server handled\\n    const handled = Array(k).fill(0)\\n    \\n    // keep track of when each server will be available again\\n    const servers = Array(k).fill(0)\\n    \\n    // finds the ideal available server\\n    // i think there\\'s an optimization here but not clue how to approach it\\n    const findserver = ( i, t ) => {\\n        let j = i % k\\n        if ( servers[j] <= t ) return j\\n\\n        for ( let l = j + 1; l < k; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        for ( let l = 0; l < j; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        \\n        return false\\n    }\\n    \\n    let max = 0\\n    arrival.forEach( ( time, i ) => {\\n\\n        // find available\\n        let serverIndex = findserver( i, time )\\n        if ( false === serverIndex ) return\\n        \\n        // add load\\n        handled[ serverIndex ]++\\n        max = Math.max( max, handled[ serverIndex ] )\\n        servers[ serverIndex ] = time + load[i]\\n    })\\n\\n    return handled.reduce( ( a, x, i ) => x == max ? a.push( i ) && a : a, [] )\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst busiestServers = ( k, arrival, load ) => {\\n    \\n    // keep track of how many requests each server handled\\n    const handled = Array(k).fill(0)\\n    \\n    // keep track of when each server will be available again\\n    const servers = Array(k).fill(0)\\n    \\n    // finds the ideal available server\\n    // i think there\\'s an optimization here but not clue how to approach it\\n    const findserver = ( i, t ) => {\\n        let j = i % k\\n        if ( servers[j] <= t ) return j\\n\\n        for ( let l = j + 1; l < k; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        for ( let l = 0; l < j; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        \\n        return false\\n    }\\n    \\n    let max = 0\\n    arrival.forEach( ( time, i ) => {\\n\\n        // find available\\n        let serverIndex = findserver( i, time )\\n        if ( false === serverIndex ) return\\n        \\n        // add load\\n        handled[ serverIndex ]++\\n        max = Math.max( max, handled[ serverIndex ] )\\n        servers[ serverIndex ] = time + load[i]\\n    })\\n\\n    return handled.reduce( ( a, x, i ) => x == max ? a.push( i ) && a : a, [] )\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876941,
                "title": "java-segment-tree-o-n-log-k",
                "content": "Use a SegmentTree for the minimum with query operation to find the first index greater than l that has a value <= to arrival time.\\nIf we can\\'t find a server that is not busy with index greater than the target index, search from index 0. If both searches fail drop the request.\\n\\nThis SegmentTree implementation is almost exactly the same as problems https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/C and\\nhttps://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D\\n\\n```\\n    private static class SegTree {\\n        int leftMost, rightMost;\\n        SegTree left, right;\\n        int min;\\n\\n        SegTree(int leftMost, int rightMost, int[] arr) {\\n            this.leftMost = leftMost;\\n            this.rightMost = rightMost;\\n            if (leftMost == rightMost) {\\n                min = arr[leftMost];\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                left = new SegTree(leftMost, mid, arr);\\n                right = new SegTree(mid + 1, rightMost, arr);\\n                recalc();\\n            }\\n        }\\n\\n        private void recalc() {\\n            if (leftMost == rightMost) {\\n                return;\\n            }\\n            min = Math.min(left.min, right.min);\\n        }\\n\\n        private int query(int idx, int val) {\\n            if (min > val || rightMost < idx) {\\n                return -1;\\n            }\\n            if (leftMost == rightMost) {\\n                return leftMost;\\n            }\\n            final int resL = left.query(idx, val);\\n            return resL != -1 ? resL : right.query(idx, val);\\n        }\\n\\n        private void update(int idx, int val) {\\n            if (leftMost == rightMost) {\\n                min = val;\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                if (idx <= mid) {\\n                    left.update(idx, val);\\n                } else {\\n                    right.update(idx, val);\\n                }\\n                recalc();\\n            }\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        final int[] handled = new int[k];\\n        final List<Integer> res = new ArrayList<>();\\n        final SegTree st = new SegTree(0, k - 1, new int[k]);\\n        for (int i = 0; i < arrival.length; i++) {\\n            final int target = i % k;\\n            int pos = st.query(target, arrival[i]);\\n            if (pos < target) {\\n                pos = st.query(0, arrival[i]);\\n            }\\n            if (pos != -1) {\\n                handled[pos]++;\\n                st.update(pos, arrival[i] + load[i]);\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < k; i++) {\\n            max = Math.max(max, handled[i]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (handled[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static class SegTree {\\n        int leftMost, rightMost;\\n        SegTree left, right;\\n        int min;\\n\\n        SegTree(int leftMost, int rightMost, int[] arr) {\\n            this.leftMost = leftMost;\\n            this.rightMost = rightMost;\\n            if (leftMost == rightMost) {\\n                min = arr[leftMost];\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                left = new SegTree(leftMost, mid, arr);\\n                right = new SegTree(mid + 1, rightMost, arr);\\n                recalc();\\n            }\\n        }\\n\\n        private void recalc() {\\n            if (leftMost == rightMost) {\\n                return;\\n            }\\n            min = Math.min(left.min, right.min);\\n        }\\n\\n        private int query(int idx, int val) {\\n            if (min > val || rightMost < idx) {\\n                return -1;\\n            }\\n            if (leftMost == rightMost) {\\n                return leftMost;\\n            }\\n            final int resL = left.query(idx, val);\\n            return resL != -1 ? resL : right.query(idx, val);\\n        }\\n\\n        private void update(int idx, int val) {\\n            if (leftMost == rightMost) {\\n                min = val;\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                if (idx <= mid) {\\n                    left.update(idx, val);\\n                } else {\\n                    right.update(idx, val);\\n                }\\n                recalc();\\n            }\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        final int[] handled = new int[k];\\n        final List<Integer> res = new ArrayList<>();\\n        final SegTree st = new SegTree(0, k - 1, new int[k]);\\n        for (int i = 0; i < arrival.length; i++) {\\n            final int target = i % k;\\n            int pos = st.query(target, arrival[i]);\\n            if (pos < target) {\\n                pos = st.query(0, arrival[i]);\\n            }\\n            if (pos != -1) {\\n                handled[pos]++;\\n                st.update(pos, arrival[i] + load[i]);\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < k; i++) {\\n            max = Math.max(max, handled[i]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (handled[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876818,
                "title": "how-to-optimise-the-inner-while-loop",
                "content": "Hello,\\n\\nMy following solution gave TLE and I got stuck at how to optimise this further.\\n\\nHow can I approach such problem?\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        long[] busy = new long[k];\\n        int[] nums = new int[k];\\n        int max = 0;\\n        for(int i=0;i<arrival.length; i++){\\n            int server = i % k;\\n            while(busy[server]>arrival[i]) {\\n                server = (server+1) % k;\\n                if(server == i%k) break;\\n            }\\n            System.out.println(busy[server]+\" \"+arrival[i]+\" \"+i+\" server=\"+server);\\n            if(busy[server]>arrival[i]) continue;\\n            \\n            busy[server] = arrival[i]+load[i];\\n            nums[server]++;\\n            max = Math.max(max, nums[server]);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<k;i++){\\n            System.out.println(nums[i]);\\n            if(nums[i]==max) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        long[] busy = new long[k];\\n        int[] nums = new int[k];\\n        int max = 0;\\n        for(int i=0;i<arrival.length; i++){\\n            int server = i % k;\\n            while(busy[server]>arrival[i]) {\\n                server = (server+1) % k;\\n                if(server == i%k) break;\\n            }\\n            System.out.println(busy[server]+\" \"+arrival[i]+\" \"+i+\" server=\"+server);\\n            if(busy[server]>arrival[i]) continue;\\n            \\n            busy[server] = arrival[i]+load[i];\\n            nums[server]++;\\n            max = Math.max(max, nums[server]);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<k;i++){\\n            System.out.println(nums[i]);\\n            if(nums[i]==max) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876800,
                "title": "binary-search-priority-queue-well-explained-nlogn-java",
                "content": "```\\nclass Solution {\\n  class node {\\n    int expire;\\n    int idx;\\n\\n    node(int e, int i) {\\n      expire = e;\\n      idx = i;\\n    }\\n  }\\n\\n  public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n    //Free Server List.\\n    TreeSet<Integer> ts = new TreeSet<>();\\n    for (int i = 0; i < k; i++)\\n      ts.add(i);\\n\\n\\n    int max_count = 0;\\n\\n    HashMap<Integer, Integer> count = new HashMap<>();\\n\\n    //Maintains the count list of busy servers by computation expiration time\\n    PriorityQueue<node> pq = new PriorityQueue<>((node a, node b) -> a.expire - b.expire);\\n\\n    for (int i = 0; i < arrival.length; i++) {\\n\\n      //Add to free server list if the computation is finished\\n      while (!pq.isEmpty() && pq.peek().expire <= arrival[i]) {\\n        node p = pq.poll();\\n        ts.add(p.idx);\\n      }\\n\\n      //No Free Server\\n      if (ts.size() == 0)\\n        continue;\\n\\n\\n      //Find next server that is equal or just greater.\\n      Integer ceil = ts.ceiling(i % k);\\n\\n\\n      //If not found get the first available server\\n      if (ceil == null)\\n        ceil = ts.first();\\n\\n\\n      //Remove from free server list\\n      ts.remove(ceil);\\n\\n      count.put(ceil, count.getOrDefault(ceil, 0) + 1);\\n\\n      //Add to busy server list.\\n      pq.add(new node(arrival[i] + load[i], ceil));\\n\\t  \\n\\t  //update maxcount\\n\\t  max_count=Math.max(max_count,count.get(ceil));\\n\\n\\n    }\\n\\n\\n    //Get the most used server.\\n    List<Integer> ans= new ArrayList<>();\\n\\n    for (Map.Entry<Integer,Integer> e:count.entrySet())\\n    {\\n      if (e.getValue()==max_count)\\n      {\\n        ans.add(e.getKey());\\n      }\\n    }\\n\\n    return ans;\\n\\n\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  class node {\\n    int expire;\\n    int idx;\\n\\n    node(int e, int i) {\\n      expire = e;\\n      idx = i;\\n    }\\n  }\\n\\n  public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n    //Free Server List.\\n    TreeSet<Integer> ts = new TreeSet<>();\\n    for (int i = 0; i < k; i++)\\n      ts.add(i);\\n\\n\\n    int max_count = 0;\\n\\n    HashMap<Integer, Integer> count = new HashMap<>();\\n\\n    //Maintains the count list of busy servers by computation expiration time\\n    PriorityQueue<node> pq = new PriorityQueue<>((node a, node b) -> a.expire - b.expire);\\n\\n    for (int i = 0; i < arrival.length; i++) {\\n\\n      //Add to free server list if the computation is finished\\n      while (!pq.isEmpty() && pq.peek().expire <= arrival[i]) {\\n        node p = pq.poll();\\n        ts.add(p.idx);\\n      }\\n\\n      //No Free Server\\n      if (ts.size() == 0)\\n        continue;\\n\\n\\n      //Find next server that is equal or just greater.\\n      Integer ceil = ts.ceiling(i % k);\\n\\n\\n      //If not found get the first available server\\n      if (ceil == null)\\n        ceil = ts.first();\\n\\n\\n      //Remove from free server list\\n      ts.remove(ceil);\\n\\n      count.put(ceil, count.getOrDefault(ceil, 0) + 1);\\n\\n      //Add to busy server list.\\n      pq.add(new node(arrival[i] + load[i], ceil));\\n\\t  \\n\\t  //update maxcount\\n\\t  max_count=Math.max(max_count,count.get(ceil));\\n\\n\\n    }\\n\\n\\n    //Get the most used server.\\n    List<Integer> ans= new ArrayList<>();\\n\\n    for (Map.Entry<Integer,Integer> e:count.entrySet())\\n    {\\n      if (e.getValue()==max_count)\\n      {\\n        ans.add(e.getKey());\\n      }\\n    }\\n\\n    return ans;\\n\\n\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065320,
                "title": "c-segment-tree-binary-search",
                "content": "For each arrival, just find nearest index free using binary search + segment tree. Here is my implementation. If you find it helpful, please upvote. thank you for reading.\\n\\n# Code\\n```\\nvoid update(int node, int start, int end, int pos, int val, vector<int> &seg){\\n    if(start > pos || end < pos){\\n        return;\\n    }\\n    if(start == end){\\n        seg[node] = val;\\n        return;\\n    }\\n    int mid = (start+end)/2;\\n    update(node*2+1, start, mid, pos, val, seg);\\n    update(node*2+2, mid+1, end, pos, val, seg);\\n    seg[node] = min(seg[node*2+1], seg[node*2+2]);\\n}\\n\\nint get(int node, int start, int end, int left, int right, vector<int> &seg){\\n    if(start > right || end < left){\\n        return INT_MAX;\\n    }\\n    if(left<=start && end <= right){\\n        return seg[node];\\n    }\\n    int mid = (start+end)/2;\\n    return min(get(node*2+1, start, mid, left, right, seg), get(node*2+2, mid+1, end, left, right, seg));\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> seg(4*k+4, 0);\\n        vector<int> contain(k, 0);\\n        for(int i=0; i<arrival.size(); i++){\\n            \\n            int low = (i%k);\\n            int high = k-1;\\n            int index = -1;\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                \\n                if(get(0, 0, k-1, i%k, mid, seg) <= arrival[i]){\\n                    index = mid;\\n                    high = mid-1;\\n                }\\n                else{\\n                    low = mid+1;\\n                }\\n            }\\n            if(index == -1){\\n                low = 0;\\n                high = (i%k)-1;\\n                while(low <= high){\\n                    int mid = (low+high)/2;\\n                    if(get(0, 0, k-1, 0, mid, seg) <= arrival[i]){\\n                        index = mid;\\n                        high = mid-1;\\n                    }\\n                    else{\\n                        low = mid+1;\\n                    }\\n                }\\n            }\\n            if(index != -1){\\n                update(0, 0, k-1, index, arrival[i]+load[i], seg);\\n                contain[index] += 1;\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = -1;\\n        for(int i=0; i<k; i++){\\n            if(contain[i] > maxx){\\n                ans.clear();\\n                maxx = contain[i];\\n            }\\n            if(contain[i] == maxx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Segment Tree"
                ],
                "code": "```\\nvoid update(int node, int start, int end, int pos, int val, vector<int> &seg){\\n    if(start > pos || end < pos){\\n        return;\\n    }\\n    if(start == end){\\n        seg[node] = val;\\n        return;\\n    }\\n    int mid = (start+end)/2;\\n    update(node*2+1, start, mid, pos, val, seg);\\n    update(node*2+2, mid+1, end, pos, val, seg);\\n    seg[node] = min(seg[node*2+1], seg[node*2+2]);\\n}\\n\\nint get(int node, int start, int end, int left, int right, vector<int> &seg){\\n    if(start > right || end < left){\\n        return INT_MAX;\\n    }\\n    if(left<=start && end <= right){\\n        return seg[node];\\n    }\\n    int mid = (start+end)/2;\\n    return min(get(node*2+1, start, mid, left, right, seg), get(node*2+2, mid+1, end, left, right, seg));\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> seg(4*k+4, 0);\\n        vector<int> contain(k, 0);\\n        for(int i=0; i<arrival.size(); i++){\\n            \\n            int low = (i%k);\\n            int high = k-1;\\n            int index = -1;\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                \\n                if(get(0, 0, k-1, i%k, mid, seg) <= arrival[i]){\\n                    index = mid;\\n                    high = mid-1;\\n                }\\n                else{\\n                    low = mid+1;\\n                }\\n            }\\n            if(index == -1){\\n                low = 0;\\n                high = (i%k)-1;\\n                while(low <= high){\\n                    int mid = (low+high)/2;\\n                    if(get(0, 0, k-1, 0, mid, seg) <= arrival[i]){\\n                        index = mid;\\n                        high = mid-1;\\n                    }\\n                    else{\\n                        low = mid+1;\\n                    }\\n                }\\n            }\\n            if(index != -1){\\n                update(0, 0, k-1, index, arrival[i]+load[i], seg);\\n                contain[index] += 1;\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = -1;\\n        for(int i=0; i<k; i++){\\n            if(contain[i] > maxx){\\n                ans.clear();\\n                maxx = contain[i];\\n            }\\n            if(contain[i] == maxx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057098,
                "title": "python3-simulate-servers-using-sorted-list-and-heap",
                "content": "```\\nfrom sortedcontainers import SortedList\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        processed = [0]*k\\n        ready = SortedList(list(range(k)))\\n        processing = []  # (ready time, server number)\\n        for i, a, l in zip(range(len(arrival)), arrival, load):\\n            while processing and processing[0][0] <= a:\\n                _, s = heappop(processing)\\n                ready.add(s)\\n            \\n            if not ready:\\n                continue\\n            index = ready.bisect_left(i%k)\\n            if index == len(ready):\\n                index = 0\\n            s = ready[index]\\n            ready.pop(index)\\n            processed[s] += 1\\n            heappush(processing, (a+l, s))\\n\\n        m = max(processed)\\n        return [i for i in range(k) if processed[i] == m]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        processed = [0]*k\\n        ready = SortedList(list(range(k)))\\n        processing = []  # (ready time, server number)\\n        for i, a, l in zip(range(len(arrival)), arrival, load):\\n            while processing and processing[0][0] <= a:\\n                _, s = heappop(processing)\\n                ready.add(s)\\n            \\n            if not ready:\\n                continue\\n            index = ready.bisect_left(i%k)\\n            if index == len(ready):\\n                index = 0\\n            s = ready[index]\\n            ready.pop(index)\\n            processed[s] += 1\\n            heappush(processing, (a+l, s))\\n\\n        m = max(processed)\\n        return [i for i in range(k) if processed[i] == m]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033661,
                "title": "c-sortedset-nlogn",
                "content": "# Intuition\\nUse SortedSet to overcome TimeLimitExceeded issue.\\n\\n# Approach\\nChecking the existence in SortedSet is O(1) and doing search is a binary search operation since collection is sorted.\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n)) \\n(n is count of arrival)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    class DuplicateKeyComparer : IComparer<int>\\n    {\\n        public int Compare(int x, int y)\\n        {\\n            int result = x.CompareTo(y);\\n\\n            result = result == 0 ? 1 : result;\\n\\n            return result;\\n        }            \\n    }\\n\\n    class ServerEqualityComparer : IComparer<Server>\\n    {\\n        public int Compare(Server x, Server y)\\n        {\\n            if (x == null || y == null) return -1;\\n\\n            return x.Id.CompareTo(y.Id);\\n        }\\n\\n        public bool Equals(Server x, Server y)\\n        {\\n            if(x == null || y == null) return false;\\n\\n            return x.Id.Equals(y.Id);\\n        }\\n\\n        public int GetHashCode(Server obj)\\n        {\\n            return obj.Id.GetHashCode();\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Id { get; set; }\\n\\n        public int ReqCount { get; set; }\\n\\n        public int FreeTime { get; set;}\\n    }\\n\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        var busyServers = new SortedList<int, Server>(new DuplicateKeyComparer()); // free time, server\\n        var serverRange = Enumerable.Range(0, k);\\n        var serverReqCount = new Dictionary<int, int>(serverRange.Select(i => new KeyValuePair<int, int>(i, 0))); // server, req count\\n        var freeServers = new SortedSet<Server>(serverRange.Select(i => new Server\\n        {\\n            FreeTime = 0,\\n            Id = i,\\n            ReqCount = 0\\n        }), new ServerEqualityComparer());\\n\\n        for (var i = 0; i < arrival.Length; i++)\\n        {\\n            while (busyServers.Count > 0 && busyServers.ElementAt(0).Value.FreeTime <= arrival[i])\\n            {\\n                var firstServer = busyServers.First().Value;\\n                freeServers.Add(firstServer);\\n                busyServers.RemoveAt(0);\\n            }\\n\\n            if (freeServers.Count == 0)\\n            {\\n                //req dropped\\n                continue;\\n            }\\n\\n            Server freeServer = null;\\n\\n            if (freeServers.Contains(new Server { Id = i % k }))\\n            {\\n                freeServers.TryGetValue(new Server { Id = i % k }, out freeServer);\\n            }\\n            else\\n            {\\n                //first or default will do binary search if the collection is sorted\\n                freeServer = freeServers.FirstOrDefault(j => j.Id > (i % k)) ?? freeServers.Min;                    \\n            }\\n\\n            serverReqCount[freeServer.Id]++;\\n            freeServer.FreeTime = arrival[i] + load[i];\\n            busyServers.Add(freeServer.FreeTime, freeServer);\\n            freeServers.Remove(freeServer);\\n        }\\n\\n        var maxReqCount = 0;\\n        var maxReqServers = new List<int>(serverReqCount.Count);\\n\\n        foreach (var item in serverReqCount)\\n        {\\n            if (item.Value > maxReqCount)\\n            {\\n                maxReqCount = item.Value;\\n                maxReqServers = new List<int> { item.Key };\\n            }\\n            else if (item.Value == maxReqCount)\\n            {\\n                maxReqServers.Add(item.Key);\\n            }\\n        }\\n\\n        return maxReqServers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\npublic class Solution {\\n\\n    class DuplicateKeyComparer : IComparer<int>\\n    {\\n        public int Compare(int x, int y)\\n        {\\n            int result = x.CompareTo(y);\\n\\n            result = result == 0 ? 1 : result;\\n\\n            return result;\\n        }            \\n    }\\n\\n    class ServerEqualityComparer : IComparer<Server>\\n    {\\n        public int Compare(Server x, Server y)\\n        {\\n            if (x == null || y == null) return -1;\\n\\n            return x.Id.CompareTo(y.Id);\\n        }\\n\\n        public bool Equals(Server x, Server y)\\n        {\\n            if(x == null || y == null) return false;\\n\\n            return x.Id.Equals(y.Id);\\n        }\\n\\n        public int GetHashCode(Server obj)\\n        {\\n            return obj.Id.GetHashCode();\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Id { get; set; }\\n\\n        public int ReqCount { get; set; }\\n\\n        public int FreeTime { get; set;}\\n    }\\n\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        var busyServers = new SortedList<int, Server>(new DuplicateKeyComparer()); // free time, server\\n        var serverRange = Enumerable.Range(0, k);\\n        var serverReqCount = new Dictionary<int, int>(serverRange.Select(i => new KeyValuePair<int, int>(i, 0))); // server, req count\\n        var freeServers = new SortedSet<Server>(serverRange.Select(i => new Server\\n        {\\n            FreeTime = 0,\\n            Id = i,\\n            ReqCount = 0\\n        }), new ServerEqualityComparer());\\n\\n        for (var i = 0; i < arrival.Length; i++)\\n        {\\n            while (busyServers.Count > 0 && busyServers.ElementAt(0).Value.FreeTime <= arrival[i])\\n            {\\n                var firstServer = busyServers.First().Value;\\n                freeServers.Add(firstServer);\\n                busyServers.RemoveAt(0);\\n            }\\n\\n            if (freeServers.Count == 0)\\n            {\\n                //req dropped\\n                continue;\\n            }\\n\\n            Server freeServer = null;\\n\\n            if (freeServers.Contains(new Server { Id = i % k }))\\n            {\\n                freeServers.TryGetValue(new Server { Id = i % k }, out freeServer);\\n            }\\n            else\\n            {\\n                //first or default will do binary search if the collection is sorted\\n                freeServer = freeServers.FirstOrDefault(j => j.Id > (i % k)) ?? freeServers.Min;                    \\n            }\\n\\n            serverReqCount[freeServer.Id]++;\\n            freeServer.FreeTime = arrival[i] + load[i];\\n            busyServers.Add(freeServer.FreeTime, freeServer);\\n            freeServers.Remove(freeServer);\\n        }\\n\\n        var maxReqCount = 0;\\n        var maxReqServers = new List<int>(serverReqCount.Count);\\n\\n        foreach (var item in serverReqCount)\\n        {\\n            if (item.Value > maxReqCount)\\n            {\\n                maxReqCount = item.Value;\\n                maxReqServers = new List<int> { item.Key };\\n            }\\n            else if (item.Value == maxReqCount)\\n            {\\n                maxReqServers.Add(item.Key);\\n            }\\n        }\\n\\n        return maxReqServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029615,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> ans;\\n    vector<int> times(k);\\n    set<int> idleServers;\\n    // (endTime, server)\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\\n\\n    for (int i = 0; i < k; ++i)\\n      idleServers.insert(i);\\n\\n    for (int i = 0; i < arrival.size(); ++i) {\\n      // Pop all servers that are available now.\\n      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {\\n        idleServers.insert(minHeap.top().second);\\n        minHeap.pop();\\n      }\\n      // Get next available server.\\n      const int server = getNextAvailableServer(idleServers, i, k);\\n      if (server == -1)\\n        continue;\\n      ++times[server];\\n      minHeap.emplace(arrival[i] + load[i], server);\\n      idleServers.erase(server);\\n    }\\n\\n    const int busiest = *max_element(times.begin(), times.end());\\n    for (int i = 0; i < k; ++i)\\n      if (times[i] == busiest)\\n        ans.push_back(i);\\n    return ans;\\n  }\\n\\n private:\\n  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,\\n                             int k) {\\n    if (idleServers.empty())\\n      return -1;\\n    const auto it = idleServers.lower_bound(ithRequest % k);\\n    return it == idleServers.cend() ? *idleServers.begin() : *it;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> ans;\\n    vector<int> times(k);\\n    set<int> idleServers;\\n    // (endTime, server)\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\\n\\n    for (int i = 0; i < k; ++i)\\n      idleServers.insert(i);\\n\\n    for (int i = 0; i < arrival.size(); ++i) {\\n      // Pop all servers that are available now.\\n      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {\\n        idleServers.insert(minHeap.top().second);\\n        minHeap.pop();\\n      }\\n      // Get next available server.\\n      const int server = getNextAvailableServer(idleServers, i, k);\\n      if (server == -1)\\n        continue;\\n      ++times[server];\\n      minHeap.emplace(arrival[i] + load[i], server);\\n      idleServers.erase(server);\\n    }\\n\\n    const int busiest = *max_element(times.begin(), times.end());\\n    for (int i = 0; i < k; ++i)\\n      if (times[i] == busiest)\\n        ans.push_back(i);\\n    return ans;\\n  }\\n\\n private:\\n  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,\\n                             int k) {\\n    if (idleServers.empty())\\n      return -1;\\n    const auto it = idleServers.lower_bound(ithRequest % k);\\n    return it == idleServers.cend() ? *idleServers.begin() : *it;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991958,
                "title": "minheap-map-easily-understandable-commented-code-c-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are few smart decisions that we need to make\\n1. Choosing set over vection for maintaining availaible servers, so that we can use the power of lower_bound directly to get the next availaible server faster (instead of linearly scanning over the next availaible server)\\n2. Using priority queue(min heap on ending time) for busy servers. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set <int> availaible; // We are using set to maintain currently availaible servers\\n        for(int i=0;i<k;i++) availaible.insert(i); // Currently all servers are availaible\\n\\n        vector <int> usedCount(k,0); // Used to maintain how many times given server is used\\n        priority_queue <pair <int,int>,vector <pair <int,int>>, greater <pair <int,int>>> busy; // end time,server id -> min queue\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            // Making busy servers availaible whose endTime is less than current time (arrival time) \\n            while(!busy.empty() && arrival[i]>=busy.top().first){\\n                availaible.insert(busy.top().second);\\n                busy.pop();\\n            }\\n\\n            // Checking if any server is availaible, and making the candidate server busy\\n            if(availaible.size()){\\n                auto server = availaible.lower_bound(i%k);\\n                if(server==availaible.end()){\\n                    server = availaible.begin();\\n                }\\n                int serverId = *server;\\n                availaible.erase(server);\\n                int endTime = arrival[i]+load[i];\\n                usedCount[serverId]++;\\n                busy.push({endTime,serverId}); \\n            }\\n        }\\n\\n        // Finding the maximum number of time any server is used \\n        int mx = *max_element(usedCount.begin(),usedCount.end());\\n        // Adding servers in ans\\n        vector <int> ans;\\n        for(int i=0;i<usedCount.size();i++){\\n            if(usedCount[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set <int> availaible; // We are using set to maintain currently availaible servers\\n        for(int i=0;i<k;i++) availaible.insert(i); // Currently all servers are availaible\\n\\n        vector <int> usedCount(k,0); // Used to maintain how many times given server is used\\n        priority_queue <pair <int,int>,vector <pair <int,int>>, greater <pair <int,int>>> busy; // end time,server id -> min queue\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            // Making busy servers availaible whose endTime is less than current time (arrival time) \\n            while(!busy.empty() && arrival[i]>=busy.top().first){\\n                availaible.insert(busy.top().second);\\n                busy.pop();\\n            }\\n\\n            // Checking if any server is availaible, and making the candidate server busy\\n            if(availaible.size()){\\n                auto server = availaible.lower_bound(i%k);\\n                if(server==availaible.end()){\\n                    server = availaible.begin();\\n                }\\n                int serverId = *server;\\n                availaible.erase(server);\\n                int endTime = arrival[i]+load[i];\\n                usedCount[serverId]++;\\n                busy.push({endTime,serverId}); \\n            }\\n        }\\n\\n        // Finding the maximum number of time any server is used \\n        int mx = *max_element(usedCount.begin(),usedCount.end());\\n        // Adding servers in ans\\n        vector <int> ans;\\n        for(int i=0;i<usedCount.size();i++){\\n            if(usedCount[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928951,
                "title": "min-heap-priorityqueue-and-ordered-set-treeset-in-kotlin",
                "content": "Improved version of my [basic solution](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/solutions/3928920/basic-brute-force-style-approach-in-kotlin-o-n-k-and-o-k/). Using an ordered set to store only the available servers and a priority queue to keep end times cuts down run time and storage significantly.\\n# Intuition\\nStore available servers in an ordered set, since the requests come in order. Keep a min heap of times when servers are going to become available again. Loop through requests and add servers to available/busy according to the time.\\n\\n# Approach\\n- Add all servers to available set.\\n- Loop through requests.\\n- If the current time is greater than the available times of servers in the busy server heap, add them to the available server set.\\n- Check if the k % i server, or the next one is available. If it is not then take the first available server. **Bonus of using ordered set**.\\n- Increment requests taken counter for the server and add it to the busy heap.\\n- Loop through requests taken and return the servers with the most.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(maxOf(n, k))$$ worst case (full set/heap)\\n\\n# Code\\n```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val availableServers = TreeSet<Int>() { a, b -> a - b }\\n        val busyServers = PriorityQueue<Pair<Int, Int>>() { a, b -> a.second - b.second } // Pair of (server, availableTime)\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (i in 0 until k) {\\n            availableServers.add(i)\\n        }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            while (busyServers.isNotEmpty() && busyServers.peek().second <= arrival[requestNumber]) {\\n                availableServers.add(busyServers.poll().first)\\n            }\\n\\n            if (availableServers.isNotEmpty()) {\\n                val server = availableServers.ceiling(requestNumber % k) ?: availableServers.first()\\n                requestsTaken[server]++\\n                availableServers.remove(server)\\n                busyServers.offer(Pair(server, arrival[requestNumber] + load[requestNumber]))\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val availableServers = TreeSet<Int>() { a, b -> a - b }\\n        val busyServers = PriorityQueue<Pair<Int, Int>>() { a, b -> a.second - b.second } // Pair of (server, availableTime)\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (i in 0 until k) {\\n            availableServers.add(i)\\n        }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            while (busyServers.isNotEmpty() && busyServers.peek().second <= arrival[requestNumber]) {\\n                availableServers.add(busyServers.poll().first)\\n            }\\n\\n            if (availableServers.isNotEmpty()) {\\n                val server = availableServers.ceiling(requestNumber % k) ?: availableServers.first()\\n                requestsTaken[server]++\\n                availableServers.remove(server)\\n                busyServers.offer(Pair(server, arrival[requestNumber] + load[requestNumber]))\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928920,
                "title": "basic-brute-force-style-approach-in-kotlin-o-n-k-and-o-k",
                "content": "Pretty basic first approach that came to mind. This is probably not good enough for an interview on it\\'s own, however could be a decent starting point for you to make some optimizations when asked, such as using a min heap and an ordered set instead of the IntArrays, as in my [improved solution.](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/solutions/3928951/min-heap-priorityqueue-and-ordered-set-treeset-in-kotlin/)\\n\\n# Intuition\\nStore the time each server will be available again after a request, loop through for each request and see if it can take the request.\\n\\n# Approach\\n- Set all servers to be free at -1, so they are all able to take requests at the start.\\n- Set all of the servers requests taken to 0.\\n- Loop through requests, if the request start time is larger than the servers \"free\" time, it can take the request, so set it\\'s next available time to the time of the request + the load, and increment requests taken.\\n- Reset the server counter if it loops around all of them.\\n- Go through requests taken and return the servers with largest values.\\n\\n# Complexity\\n- Time complexity: $$O(n*k)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val freeTimes = IntArray(k) { -1 }\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            var i = 0\\n            var currentServer = requestNumber % k\\n            while (i < k) {\\n                if (currentServer == k) {\\n                    currentServer = 0\\n                }\\n                if (freeTimes[currentServer] <= arrival[requestNumber]) {\\n                    freeTimes[currentServer] = arrival[requestNumber] + load[requestNumber]\\n                    requestsTaken[currentServer]++\\n                    currentServer++\\n                    break\\n                }\\n                currentServer++\\n                i++\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val freeTimes = IntArray(k) { -1 }\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            var i = 0\\n            var currentServer = requestNumber % k\\n            while (i < k) {\\n                if (currentServer == k) {\\n                    currentServer = 0\\n                }\\n                if (freeTimes[currentServer] <= arrival[requestNumber]) {\\n                    freeTimes[currentServer] = arrival[requestNumber] + load[requestNumber]\\n                    requestsTaken[currentServer]++\\n                    currentServer++\\n                    break\\n                }\\n                currentServer++\\n                i++\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898171,
                "title": "c-greedy-easy-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to meeting rooms III question. We can use set, priority queue and map to solve this question. Solve this using greedy approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to break the solution in smaller parts and you will be able to solve it easily.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        int n = arrival.size();\\n        vector<int> endTime(n);\\n        for(int i=0;i<n;i++)\\n            endTime[i] = arrival[i] + load[i];\\n\\n        //(endTime,serverNo)\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> trackRequests;\\n        set<int> unusedServers;\\n        unordered_map<int,int> freq;        \\n\\n        for(int i=0;i<k;i++)\\n            unusedServers.insert(i);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int start = arrival[i];\\n            int end = endTime[i];\\n\\n            // remove all the requests that has been done\\n            while(!trackRequests.empty() && trackRequests.top().first<=start)\\n            {\\n                unusedServers.insert(trackRequests.top().second);\\n                trackRequests.pop();\\n            }\\n\\n            int assignServer = i%k;\\n            if(unusedServers.find(assignServer)!=unusedServers.end())\\n            {\\n                unusedServers.erase(assignServer);\\n                trackRequests.push({end, assignServer});\\n                freq[assignServer]++;\\n            }\\n            else\\n            {\\n                if(unusedServers.size()==0)\\n                {\\n                    // all servers are busy\\n                    continue;\\n                }\\n                else\\n                {\\n                    auto lb = unusedServers.lower_bound(assignServer);\\n                    if(lb==unusedServers.end())\\n                    {\\n                        auto lb_start = unusedServers.lower_bound(0);\\n                        int newGivenServer = *lb_start;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                    else\\n                    {\\n                        int newGivenServer = *lb;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxValue = 0;\\n        vector<int> server;\\n\\n        for(auto m: freq)\\n            maxValue = max(maxValue, m.second);\\n        \\n        for(auto m: freq)\\n        {\\n            if(m.second == maxValue)\\n                server.push_back(m.first);\\n        }\\n\\n        return server;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        int n = arrival.size();\\n        vector<int> endTime(n);\\n        for(int i=0;i<n;i++)\\n            endTime[i] = arrival[i] + load[i];\\n\\n        //(endTime,serverNo)\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> trackRequests;\\n        set<int> unusedServers;\\n        unordered_map<int,int> freq;        \\n\\n        for(int i=0;i<k;i++)\\n            unusedServers.insert(i);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int start = arrival[i];\\n            int end = endTime[i];\\n\\n            // remove all the requests that has been done\\n            while(!trackRequests.empty() && trackRequests.top().first<=start)\\n            {\\n                unusedServers.insert(trackRequests.top().second);\\n                trackRequests.pop();\\n            }\\n\\n            int assignServer = i%k;\\n            if(unusedServers.find(assignServer)!=unusedServers.end())\\n            {\\n                unusedServers.erase(assignServer);\\n                trackRequests.push({end, assignServer});\\n                freq[assignServer]++;\\n            }\\n            else\\n            {\\n                if(unusedServers.size()==0)\\n                {\\n                    // all servers are busy\\n                    continue;\\n                }\\n                else\\n                {\\n                    auto lb = unusedServers.lower_bound(assignServer);\\n                    if(lb==unusedServers.end())\\n                    {\\n                        auto lb_start = unusedServers.lower_bound(0);\\n                        int newGivenServer = *lb_start;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                    else\\n                    {\\n                        int newGivenServer = *lb;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxValue = 0;\\n        vector<int> server;\\n\\n        for(auto m: freq)\\n            maxValue = max(maxValue, m.second);\\n        \\n        for(auto m: freq)\\n        {\\n            if(m.second == maxValue)\\n                server.push_back(m.first);\\n        }\\n\\n        return server;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856231,
                "title": "java-o-nlog-n-treeset-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();\\n        for (int i = 0; i < k; i++) {\\n            available.add(i);\\n        }\\n\\n        int[] count = new int[k];\\n        int max = 0;\\n\\n        // 0 => end time\\n        // 1 => server index\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2) -> Integer.compare(v1[0], v2[0]));\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            \\n            int time = arrival[i];\\n            int l = load[i];\\n\\n            while ( ! pq.isEmpty() && pq.peek()[0] <= time) {\\n                available.add(pq.poll()[1]);\\n            }\\n\\n            if (available.size() == 0) {\\n                continue;\\n            }\\n\\n            Integer si = available.ceiling(i % k);\\n            if (si == null) {\\n                si = available.first();\\n            }\\n            available.remove(si);\\n\\n            pq.add(new int[]{time + l, si});\\n            count[si]++;\\n            max = Math.max(max, count[si]);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();\\n        for (int i = 0; i < k; i++) {\\n            available.add(i);\\n        }\\n\\n        int[] count = new int[k];\\n        int max = 0;\\n\\n        // 0 => end time\\n        // 1 => server index\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2) -> Integer.compare(v1[0], v2[0]));\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            \\n            int time = arrival[i];\\n            int l = load[i];\\n\\n            while ( ! pq.isEmpty() && pq.peek()[0] <= time) {\\n                available.add(pq.poll()[1]);\\n            }\\n\\n            if (available.size() == 0) {\\n                continue;\\n            }\\n\\n            Integer si = available.ceiling(i % k);\\n            if (si == null) {\\n                si = available.first();\\n            }\\n            available.remove(si);\\n\\n            pq.add(new int[]{time + l, si});\\n            count[si]++;\\n            max = Math.max(max, count[si]);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837770,
                "title": "easy-cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n            return a;\\n        return b;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        /*\\n\\n        3 servers are present...\\n        time OF ARRIVAL OF requests are 1,2,3,4,5\\n\\n        at time 1 : server 1 is blocked\\n        at time 2 : server 2 is blocked\\n        at time 3 : server 3 is blocked\\n        at time 4 : server 2 is used (1 --> 4 over, 2--> empty , 3--> 2 time over)\\n        at time 5 : No server is empty, so dropped..\\n\\n        server 1 and 3 handled only ONE request... Server 2 handled 2 requests\\n\\n        so server 2 is the ans...\\n\\n        */\\n\\n        vector<int> cnt(k+1,0);\\n        set<int> freeServers;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<min(k,arrival.size());i++){\\n            pq.push({arrival[i]+load[i], i});\\n            cnt[i]++;\\n        }\\n\\n        for(int i=k;i<arrival.size();i++)\\n        {\\n            if(freeServers.size() || (pq.size() && arrival[i]>=pq.top().first))\\n            {\\n                while(pq.size() && arrival[i]>=pq.top().first){\\n                    freeServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                set<int> :: iterator nearestServer;\\n                nearestServer = lower_bound(freeServers.begin(),freeServers.end(),i%k);\\n                if(nearestServer==freeServers.end())\\n                    nearestServer = freeServers.begin();\\n                \\n                int curr = *nearestServer;\\n                cnt[curr]++;\\n                pq.push({arrival[i]+load[i],curr});\\n                freeServers.erase(nearestServer);\\n            }\\n        }\\n\\n        int maxi = -1;\\n        for(int i=0;i<k;i++)\\n            maxi = max(maxi,cnt[i]);\\n        \\n        vector<int> res;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(cnt[i]==maxi)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n            return a;\\n        return b;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        /*\\n\\n        3 servers are present...\\n        time OF ARRIVAL OF requests are 1,2,3,4,5\\n\\n        at time 1 : server 1 is blocked\\n        at time 2 : server 2 is blocked\\n        at time 3 : server 3 is blocked\\n        at time 4 : server 2 is used (1 --> 4 over, 2--> empty , 3--> 2 time over)\\n        at time 5 : No server is empty, so dropped..\\n\\n        server 1 and 3 handled only ONE request... Server 2 handled 2 requests\\n\\n        so server 2 is the ans...\\n\\n        */\\n\\n        vector<int> cnt(k+1,0);\\n        set<int> freeServers;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<min(k,arrival.size());i++){\\n            pq.push({arrival[i]+load[i], i});\\n            cnt[i]++;\\n        }\\n\\n        for(int i=k;i<arrival.size();i++)\\n        {\\n            if(freeServers.size() || (pq.size() && arrival[i]>=pq.top().first))\\n            {\\n                while(pq.size() && arrival[i]>=pq.top().first){\\n                    freeServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                set<int> :: iterator nearestServer;\\n                nearestServer = lower_bound(freeServers.begin(),freeServers.end(),i%k);\\n                if(nearestServer==freeServers.end())\\n                    nearestServer = freeServers.begin();\\n                \\n                int curr = *nearestServer;\\n                cnt[curr]++;\\n                pq.push({arrival[i]+load[i],curr});\\n                freeServers.erase(nearestServer);\\n            }\\n        }\\n\\n        int maxi = -1;\\n        for(int i=0;i<k;i++)\\n            maxi = max(maxi,cnt[i]);\\n        \\n        vector<int> res;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(cnt[i]==maxi)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749727,
                "title": "java-solution-using-treeset-and-priorityqueue",
                "content": "\\n\\n# Approach\\nWe want to maintain two pools of servers - a busy pool and an available pool. Every time a request comes in, we will first check which servers in our busy pool become available. Then we iterate over the available pool starting from i % k and wrapping around until we find a free server. Then this server is transferred from our available pool to the busy pool. We model the available pool as a sorted set so we can quickly answer queries of the form give me the id right after x. The busy pool is modelled as priority queue with key being the finishing time of currently processing request. Once a request arrives (i.e. we iterate to it), then we go over our busy pool to remove servers which stopped processing before the arrival time of the current request and transfer it to the available pool. Once available pool is updated, we assign a server to it. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class server{\\n        int id;\\n        int busyTime;\\n        public server(int i,int t){\\n            id=i;\\n            busyTime=t;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        // treeset is used to find next avalible server (using celling method) in case default server is not avalible\\n        TreeSet<Integer> available=new TreeSet<>();\\n        // to keep track of server that become avalible at cur arival time we will keep them in sorted order of busyTime\\n        PriorityQueue<server> busy=new PriorityQueue<>((a,b)->{\\n            return Integer.compare(a.busyTime,b.busyTime);\\n        });\\n        // to keep track of number request handled by each server to find bussiest server finally\\n        int[] requestCount=new int[k];\\n        int n=arrival.length;\\n        for(int id=0;id<k;id++){\\n            available.add(id);\\n        }\\n\\n\\n        for(int i=0;i<arrival.length;i++){\\n            int defaultServer=i%k;\\n            // remove available server from busyQueue which has busyTime less then cur arrival time\\n            while(!busy.isEmpty() && busy.peek().busyTime<=arrival[i]){\\n                server top=busy.poll();\\n                available.add(top.id);\\n            }\\n\\n            // if there is no available server then we will drop this request\\n            if(available.isEmpty()) continue;\\n\\n            // find nextServer available from available treeSet  ceiling will return next value present that is greater or equal to cur number if no number then it will return null to store null we will use wrapper class Integer\\n            Integer nextServer=available.ceiling(defaultServer);\\n            nextServer=(nextServer!=null)?nextServer:available.ceiling(0);\\n\\n            int requestEnd=arrival[i]+load[i];\\n\\n            available.remove(nextServer);\\n            busy.add(new server(nextServer,requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n\\n\\n        int maxRequests=Integer.MIN_VALUE;\\n        List<Integer> busiestServer=new ArrayList<>();\\n        for(int id=0;id<k;id++){\\n            maxRequests=Math.max(maxRequests,requestCount[id]);\\n        }\\n        for(int id=0;id<k;id++){\\n            if(maxRequests==requestCount[id]){\\n                busiestServer.add(id);\\n            }\\n        }\\n        return busiestServer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class server{\\n        int id;\\n        int busyTime;\\n        public server(int i,int t){\\n            id=i;\\n            busyTime=t;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        // treeset is used to find next avalible server (using celling method) in case default server is not avalible\\n        TreeSet<Integer> available=new TreeSet<>();\\n        // to keep track of server that become avalible at cur arival time we will keep them in sorted order of busyTime\\n        PriorityQueue<server> busy=new PriorityQueue<>((a,b)->{\\n            return Integer.compare(a.busyTime,b.busyTime);\\n        });\\n        // to keep track of number request handled by each server to find bussiest server finally\\n        int[] requestCount=new int[k];\\n        int n=arrival.length;\\n        for(int id=0;id<k;id++){\\n            available.add(id);\\n        }\\n\\n\\n        for(int i=0;i<arrival.length;i++){\\n            int defaultServer=i%k;\\n            // remove available server from busyQueue which has busyTime less then cur arrival time\\n            while(!busy.isEmpty() && busy.peek().busyTime<=arrival[i]){\\n                server top=busy.poll();\\n                available.add(top.id);\\n            }\\n\\n            // if there is no available server then we will drop this request\\n            if(available.isEmpty()) continue;\\n\\n            // find nextServer available from available treeSet  ceiling will return next value present that is greater or equal to cur number if no number then it will return null to store null we will use wrapper class Integer\\n            Integer nextServer=available.ceiling(defaultServer);\\n            nextServer=(nextServer!=null)?nextServer:available.ceiling(0);\\n\\n            int requestEnd=arrival[i]+load[i];\\n\\n            available.remove(nextServer);\\n            busy.add(new server(nextServer,requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n\\n\\n        int maxRequests=Integer.MIN_VALUE;\\n        List<Integer> busiestServer=new ArrayList<>();\\n        for(int id=0;id<k;id++){\\n            maxRequests=Math.max(maxRequests,requestCount[id]);\\n        }\\n        for(int id=0;id<k;id++){\\n            if(maxRequests==requestCount[id]){\\n                busiestServer.add(id);\\n            }\\n        }\\n        return busiestServer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573593,
                "title": "servers-with-most-number-of-handled-requests-c-explained-solution",
                "content": "***Upvote If Found Helpful !!!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and needs bit of observation. The pre-requisite for this question is **heaps**. We can also solve this problem through C++ **sets**. Let\\'s move towards the problem. Now initially we know that all servers are free. In order to keep track of which servers are free, we can easily maintain a set. Now to keep track of ending time of job requests and to update the free servers, we use **priority queue (min heap)** of type pair with ending time and the server handling that job. Now whenever a new request comes in, just check all the servers that can be freed. After this, find the next available server as asked in the problem. One can see that using sets for holding free servers helps us to use lower bound to get next available free server in logarithmic time. If free does not contains any free servers, then automatically that request would not be handled. At the end, just find the maximum number of requests handled and their corresponding servers. The implementation of above logic goes below : \\n\\n# Complexity\\n- Time complexity: **O(N*logK)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(K)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        ios_base::sync_with_stdio(0);\\n        vector<int>busy(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n = load.size(); set<int>free;\\n        for(int i = 0; i < k; i++){\\n            free.insert(i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int end_time = arrival[i] + load[i];\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                free.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(free.size()){\\n                set<int>::iterator iter;\\n                iter = free.lower_bound(i % k);\\n                if(iter == free.end()){\\n                    iter = free.begin();\\n                }\\n                int u = *iter;\\n                busy[u]++;\\n                pq.push({end_time,u});\\n                free.erase(u);\\n            }\\n        }\\n        int max_load = *max_element(busy.begin(),busy.end());\\n        vector<int>ans;\\n        for(int i = 0; i < k; i++){\\n            if(busy[i] == max_load){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        ios_base::sync_with_stdio(0);\\n        vector<int>busy(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n = load.size(); set<int>free;\\n        for(int i = 0; i < k; i++){\\n            free.insert(i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int end_time = arrival[i] + load[i];\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                free.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(free.size()){\\n                set<int>::iterator iter;\\n                iter = free.lower_bound(i % k);\\n                if(iter == free.end()){\\n                    iter = free.begin();\\n                }\\n                int u = *iter;\\n                busy[u]++;\\n                pq.push({end_time,u});\\n                free.erase(u);\\n            }\\n        }\\n        int max_load = *max_element(busy.begin(),busy.end());\\n        vector<int>ans;\\n        for(int i = 0; i < k; i++){\\n            if(busy[i] == max_load){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435372,
                "title": "intuitive-straightforward-solution-with-binary-search-tree-in-python-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved by using heaps with some tricky properties. The heap solution is good and smart, but less intuitive and not that easy to understand. Fortunately, this problem can also be solved in a very intuitive approach in the same time complexity  by using an ordered container. In Python, we can happily employ the powerful `SortedList` or `SortedSet` in this problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis straightforward solution maintains a priority queue (i.e., `heapq`) for the requests under processing and a table for the available servers by using `SortedSet`. At each time step, we clean done requests from the queue for freeing servers. Then, we look up the available server for the arrival request. When a server is found, we assign the request to the server, and update the priority queue and the `SortedSet` accordingly.  \\n\\nLike a balanced binary search tree, the operations including adding a server, removing a server, and finding a server can be performed in $$O(\\\\log k)$$ with `SortedSet`, where $$k$$ is the number of servers. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is $$O(n \\\\log k)$$ where $$n$$ is the number of requests and $$k$$ is the number of servers. Note that the complexity of this solution is the same as the heap solution. The heap solution is faster due to its less overhead, but this solution is more straightforward and easy to understand. \\n\\n# Code\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        requests = []\\n        servers = SortedSet(range(k))\\n        counter = defaultdict(int)\\n        for i, (t, d) in enumerate(zip(arrival, load)):\\n            while len(requests) and requests[0][0] <= t:\\n                servers.add(requests[0][1])\\n                heapq.heappop(requests)\\n            if len(servers) == 0:\\n                continue\\n            p = servers.bisect_left(i % k)\\n            server = servers[p] if p < len(servers) else servers[0]\\n            servers.remove(server)\\n            heapq.heappush(requests, (t+d, server))\\n            counter[server] += 1\\n        max_loads = max(counter.values())\\n        return [s for s, c in counter.items() if c == max_loads]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        requests = []\\n        servers = SortedSet(range(k))\\n        counter = defaultdict(int)\\n        for i, (t, d) in enumerate(zip(arrival, load)):\\n            while len(requests) and requests[0][0] <= t:\\n                servers.add(requests[0][1])\\n                heapq.heappop(requests)\\n            if len(servers) == 0:\\n                continue\\n            p = servers.bisect_left(i % k)\\n            server = servers[p] if p < len(servers) else servers[0]\\n            servers.remove(server)\\n            heapq.heappush(requests, (t+d, server))\\n            counter[server] += 1\\n        max_loads = max(counter.values())\\n        return [s for s, c in counter.items() if c == max_loads]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421432,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_requests * log(k))\\n * Space Complexity: O(k)\\n * where `n_requests` is the length of the vector `arrival`\\n */\\nclass Solution {\\n public:\\n  vector<int> busiestServers(const int k,\\n                             const vector<int> &arrival,\\n                             const vector<int> &load) {\\n    using pq_node_t = pair<int, int>;   // {the server, the available time of the server}\\n    set<int> available_servers;\\n    for (int server = 0; server < k; ++server) {\\n      available_servers.emplace(server);\\n    }\\n    \\n    auto compare = [](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq_busy_servers(compare);\\n    \\n    int used_times[k];\\n    memset(used_times, 0, sizeof(used_times));\\n    \\n    const int n_requests = static_cast<int>(arrival.size());\\n    for (int request = 0; request < n_requests; ++request) {\\n      const int request_arrival_time = arrival[request];\\n      const int request_completed_time = arrival[request] + load[request];\\n      while (!pq_busy_servers.empty() && pq_busy_servers.top().second <= request_arrival_time) {\\n        available_servers.emplace(pq_busy_servers.top().first);\\n        pq_busy_servers.pop();\\n      }\\n      \\n      if (available_servers.empty()) {\\n        continue;\\n      }\\n      \\n      const int target_server = request % k;\\n      auto lb = available_servers.lower_bound(target_server);\\n      if (lb == available_servers.end()) {\\n        lb = available_servers.begin();\\n      }\\n      ++used_times[*lb];\\n      pq_busy_servers.emplace(*lb, request_completed_time);\\n      available_servers.erase(lb);\\n    }\\n    \\n    int max_times = 0;\\n    vector<int> ret;\\n    for (int server = 0; server < k; ++server) {\\n      if (used_times[server] >= max_times) {\\n        if (used_times[server] > max_times) {\\n          max_times = used_times[server];\\n          ret.clear();\\n        }\\n        ret.emplace_back(server);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_requests * log(k))\\n * Space Complexity: O(k)\\n * where `n_requests` is the length of the vector `arrival`\\n */\\nclass Solution {\\n public:\\n  vector<int> busiestServers(const int k,\\n                             const vector<int> &arrival,\\n                             const vector<int> &load) {\\n    using pq_node_t = pair<int, int>;   // {the server, the available time of the server}\\n    set<int> available_servers;\\n    for (int server = 0; server < k; ++server) {\\n      available_servers.emplace(server);\\n    }\\n    \\n    auto compare = [](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq_busy_servers(compare);\\n    \\n    int used_times[k];\\n    memset(used_times, 0, sizeof(used_times));\\n    \\n    const int n_requests = static_cast<int>(arrival.size());\\n    for (int request = 0; request < n_requests; ++request) {\\n      const int request_arrival_time = arrival[request];\\n      const int request_completed_time = arrival[request] + load[request];\\n      while (!pq_busy_servers.empty() && pq_busy_servers.top().second <= request_arrival_time) {\\n        available_servers.emplace(pq_busy_servers.top().first);\\n        pq_busy_servers.pop();\\n      }\\n      \\n      if (available_servers.empty()) {\\n        continue;\\n      }\\n      \\n      const int target_server = request % k;\\n      auto lb = available_servers.lower_bound(target_server);\\n      if (lb == available_servers.end()) {\\n        lb = available_servers.begin();\\n      }\\n      ++used_times[*lb];\\n      pq_busy_servers.emplace(*lb, request_completed_time);\\n      available_servers.erase(lb);\\n    }\\n    \\n    int max_times = 0;\\n    vector<int> ret;\\n    for (int server = 0; server < k; ++server) {\\n      if (used_times[server] >= max_times) {\\n        if (used_times[server] > max_times) {\\n          max_times = used_times[server];\\n          ret.clear();\\n        }\\n        ret.emplace_back(server);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388719,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;  //{endtime, id}\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>count(k) ;\\n        set<int>canUseServer ;\\n        priority_queue<PII, vector<PII>, greater<PII>>busyPQ ;\\n        for(int i = 0; i < k; i++)\\n            canUseServer.insert(i) ;    \\n        for(int i = 0; i < arrival.size(); i++)\\n        {\\n            int start =  arrival[i] ;\\n            int end = start + load[i] ;\\n            while(!busyPQ.empty() && busyPQ.top().first <= start)\\n            {\\n                int id = busyPQ.top().second ;\\n                busyPQ.pop() ;\\n                canUseServer.insert(id) ;\\n            }\\n            if(canUseServer.empty())\\n                continue ;\\n            \\n            auto it = canUseServer.lower_bound(i%k) ;\\n            \\n            if(it == canUseServer.end())\\n                it = canUseServer.begin() ;\\n            \\n            int id = *it ;\\n            canUseServer.erase(id) ;\\n            count[id]++ ;\\n            busyPQ.push({end, id}) ;\\n        }\\n        vector<int>ret ;\\n        auto it = max_element(count.begin(), count.end()) ;\\n        int maxCount = *it;\\n        \\n        for(auto iter = it ; iter != count.end(); iter++){\\n            if(*iter == maxCount)\\n                ret.push_back(iter - count.begin()) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nusing PII = pair<int, int> ;  //{endtime, id}\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>count(k) ;\\n        set<int>canUseServer ;\\n        priority_queue<PII, vector<PII>, greater<PII>>busyPQ ;\\n        for(int i = 0; i < k; i++)\\n            canUseServer.insert(i) ;    \\n        for(int i = 0; i < arrival.size(); i++)\\n        {\\n            int start =  arrival[i] ;\\n            int end = start + load[i] ;\\n            while(!busyPQ.empty() && busyPQ.top().first <= start)\\n            {\\n                int id = busyPQ.top().second ;\\n                busyPQ.pop() ;\\n                canUseServer.insert(id) ;\\n            }\\n            if(canUseServer.empty())\\n                continue ;\\n            \\n            auto it = canUseServer.lower_bound(i%k) ;\\n            \\n            if(it == canUseServer.end())\\n                it = canUseServer.begin() ;\\n            \\n            int id = *it ;\\n            canUseServer.erase(id) ;\\n            count[id]++ ;\\n            busyPQ.push({end, id}) ;\\n        }\\n        vector<int>ret ;\\n        auto it = max_element(count.begin(), count.end()) ;\\n        int maxCount = *it;\\n        \\n        for(auto iter = it ; iter != count.end(); iter++){\\n            if(*iter == maxCount)\\n                ret.push_back(iter - count.begin()) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306223,
                "title": "python3-binary-search-tree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Binary search Tree though it looks big logic is pretty simple for all operations\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BSTNode:\\n    def __init__(self,val,left=None,right=None):\\n        self.val = val\\n        self.leftCount,self.rightCount = 0,0\\n        self.there = True\\n        self.left = left\\n        #self.par = None\\n        self.right = right\\n\\nclass Tree:\\n    def __init__(self,k):\\n        self.root = self.makingTree(0,k-1)[0]\\n\\n    \\n    def makingTree(self,i,j):\\n        if j<i:return None,0\\n        mid = (i+j)//2\\n        l,r = self.makingTree(i,mid-1),self.makingTree(mid+1,j)\\n        root = BSTNode(mid,l[0],r[0])\\n        root.leftCount = l[1]\\n        root.rightCount = r[1]\\n        return root,1+root.leftCount+root.rightCount\\n\\n    def findBetterLeastThan(self,val):\\n        a = float(\\'inf\\')\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val>val:\\n                a = min(a,self.findLeast(temp))\\n                temp = temp.left\\n            else:temp = temp.right\\n        a = min(a,self.findLeast(temp))\\n        return a\\n    \\n    def findLeast(self,node):\\n        ans = float(\\'inf\\')\\n        if node.there:return node.val\\n        temp = node.right\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def abbaLeast(self):\\n        ans = float(\\'inf\\')\\n        temp = self.root\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def allotNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount -= 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount -= 1\\n                temp = temp.left\\n        temp.there = False\\n\\n    def freeNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount += 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount += 1\\n                temp = temp.left\\n        temp.there = True\\n\\n    def getAlloted(self,val):\\n        a = self.findBetterLeastThan(val)\\n        if a==float(\\'inf\\'):\\n            a = self.abbaLeast()\\n        if a!=float(\\'inf\\'):\\n            self.allotNode(a)\\n            return a\\n        return -1\\n    \\n    def printTree(self):\\n        arr = []\\n        def getThis(root=self.root):\\n            if not root:return\\n            getThis(root.left)\\n            arr.append([root.val,root.there])\\n            getThis(root.right)\\n        getThis()\\n        print(arr)\\n    \\n    \\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freeAt = defaultdict(list)\\n        count = [0]*k\\n        arr = set()\\n        allotments = defaultdict(lambda:-1)\\n        for i in range(len(arrival)):\\n            arr.add(arrival[i])\\n            allotments[arrival[i]] = i\\n            arr.add(arrival[i]+load[i])\\n        arr = sorted(list(arr))\\n        root = Tree(k)\\n        for i in arr:\\n            for node in freeAt[i]:\\n                root.freeNode(node)\\n            if allotments[i]+1:\\n                comp = root.getAlloted(allotments[i]%k)\\n                #print(allotments[i],allotments[i]%k,i,arrival[allotments[i]]+load[allotments[i]],comp)\\n                #if i==94:root.printTree()\\n                if comp+1:\\n                    count[comp]+=1\\n                    freeAt[arrival[allotments[i]]+load[allotments[i]]].append(comp)\\n        go = max(count)\\n        ans = []\\n        #print(arr)\\n        for i in range(len(count)):\\n            if count[i]==go:ans.append(i)\\n        #print(count)\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTNode:\\n    def __init__(self,val,left=None,right=None):\\n        self.val = val\\n        self.leftCount,self.rightCount = 0,0\\n        self.there = True\\n        self.left = left\\n        #self.par = None\\n        self.right = right\\n\\nclass Tree:\\n    def __init__(self,k):\\n        self.root = self.makingTree(0,k-1)[0]\\n\\n    \\n    def makingTree(self,i,j):\\n        if j<i:return None,0\\n        mid = (i+j)//2\\n        l,r = self.makingTree(i,mid-1),self.makingTree(mid+1,j)\\n        root = BSTNode(mid,l[0],r[0])\\n        root.leftCount = l[1]\\n        root.rightCount = r[1]\\n        return root,1+root.leftCount+root.rightCount\\n\\n    def findBetterLeastThan(self,val):\\n        a = float(\\'inf\\')\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val>val:\\n                a = min(a,self.findLeast(temp))\\n                temp = temp.left\\n            else:temp = temp.right\\n        a = min(a,self.findLeast(temp))\\n        return a\\n    \\n    def findLeast(self,node):\\n        ans = float(\\'inf\\')\\n        if node.there:return node.val\\n        temp = node.right\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def abbaLeast(self):\\n        ans = float(\\'inf\\')\\n        temp = self.root\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def allotNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount -= 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount -= 1\\n                temp = temp.left\\n        temp.there = False\\n\\n    def freeNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount += 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount += 1\\n                temp = temp.left\\n        temp.there = True\\n\\n    def getAlloted(self,val):\\n        a = self.findBetterLeastThan(val)\\n        if a==float(\\'inf\\'):\\n            a = self.abbaLeast()\\n        if a!=float(\\'inf\\'):\\n            self.allotNode(a)\\n            return a\\n        return -1\\n    \\n    def printTree(self):\\n        arr = []\\n        def getThis(root=self.root):\\n            if not root:return\\n            getThis(root.left)\\n            arr.append([root.val,root.there])\\n            getThis(root.right)\\n        getThis()\\n        print(arr)\\n    \\n    \\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freeAt = defaultdict(list)\\n        count = [0]*k\\n        arr = set()\\n        allotments = defaultdict(lambda:-1)\\n        for i in range(len(arrival)):\\n            arr.add(arrival[i])\\n            allotments[arrival[i]] = i\\n            arr.add(arrival[i]+load[i])\\n        arr = sorted(list(arr))\\n        root = Tree(k)\\n        for i in arr:\\n            for node in freeAt[i]:\\n                root.freeNode(node)\\n            if allotments[i]+1:\\n                comp = root.getAlloted(allotments[i]%k)\\n                #print(allotments[i],allotments[i]%k,i,arrival[allotments[i]]+load[allotments[i]],comp)\\n                #if i==94:root.printTree()\\n                if comp+1:\\n                    count[comp]+=1\\n                    freeAt[arrival[allotments[i]]+load[allotments[i]]].append(comp)\\n        go = max(count)\\n        ans = []\\n        #print(arr)\\n        for i in range(len(count)):\\n            if count[i]==go:ans.append(i)\\n        #print(count)\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293792,
                "title": "python-simple-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        available, busy, dict1 = [i for i in range(k)], [], collections.defaultdict(int)\\n\\n        for i,start in enumerate(arrival):\\n            while busy and busy[0][0] <= start:\\n                heapq.heappush(available,i + (heapq.heappop(busy)[1] - i)%k)\\n\\n            if available:\\n                j = heapq.heappop(available)%k\\n                dict1[j] += 1\\n                heapq.heappush(busy,(start+load[i],j))\\n\\n        max_val = max(dict1.values())\\n\\n        return [key for key,val in dict1.items() if val == max_val]\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        available, busy, dict1 = [i for i in range(k)], [], collections.defaultdict(int)\\n\\n        for i,start in enumerate(arrival):\\n            while busy and busy[0][0] <= start:\\n                heapq.heappush(available,i + (heapq.heappop(busy)[1] - i)%k)\\n\\n            if available:\\n                j = heapq.heappop(available)%k\\n                dict1[j] += 1\\n                heapq.heappush(busy,(start+load[i],j))\\n\\n        max_val = max(dict1.values())\\n\\n        return [key for key,val in dict1.items() if val == max_val]\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216491,
                "title": "python3-two-heap-solution-explained-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to prioritize our useage of the servers in a set range. This is similar to modular arithmetic, so we should look for a priority queue solution that can use a modular approach, like a circular priority queue. In this case, we arrive at the solution through comparison of the server ids, which are in order of the ith server to be processed at any given point in time. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet up a list of servers currently available, called servers. \\nSet up an empty list of servers processing. \\nSet up a number of tasks by server of size k and value 0 to start. \\nLoop over the indices of your arrival index \\n- As you do, get the arrival time and the load size for the current arrival\\n- While you have servers processing, and the servers that are processing have a finish time before the current arrival time \\n    - Get the prior_task and server_id by popping off from the servers_processing \\n    - Push into the servers heap this server by its identification key at this point in the circular priority queue of servers with key value of arrival_index + (server_id - arrival_index) % k. See comments for details. \\n- Then, if you have servers avaialble \\n    - Pop out the most recent to complete one in ith order by using a heappop from servers and taking modulo of k for the value. This is needed to turn the arrival_index + (server_id - arrival_index) % k back into the correct server_id. For completeness, see example after time complexity. \\n    - Increment the number of tasks by server at this server by 1 \\n    - Push this ((arrival_time + load_size), server) back into servers processing \\n\\nAt end, get your highest productivity (number of tasks cleared by a server) \\nUse list comprehension to build the list of server for server in your range of servers if number of tasks by server at server is equal to highest productivity (as requested by problem)  \\n\\n# Complexity\\n- Time complexity: We need to process N arrivals \\n- During each arrival, we might process up to the ith arrival in a pop push fashion, necessitating an amount of work at most equal to N log N (where we go until the last prossible process before popping everything off of the servers processing before pushing them back into the arrivals) \\n- During each arrival, we may also do a 2 log N amount of work for popping from the servers and pushing to the servers processing. \\n- This gives an overall runtime of N log N. \\n\\n- Space complexity: At worst, we will store the entire space in the processing of this at least twice (Once for the heaps, and once for the return list if eveyrone processed only one item). So, we have O(N) space. \\n\\nExample for completeness \\nConsider the test case below \\nk = 3 \\nArrivals = [1,2,3,4,8,9,10]\\nLoads = [5,2,10,3,1,2,2]\\n\\nAt arrival index 0, we have arrival time 1 and load size five\\nWe\\'ll end up popping server 0 and incrementing tasks at 0 \\nThis leaves us at end of arrival index 0 in state of \\nServers -> [1, 2]\\nNumber_of_tasks_per_server = [1, 0, 0]\\nprocessing_servers -> [(6, 0)]\\n\\nAt arrival index 1, we have arrival time 2 and load size 2 \\nWe\\'ll end up popping server 1 and incrementing tasks at 1 \\nThis leaves us at end of arrival index 1 in state of \\nServers -> [2]\\nNumber_of_tasks_per_server = [1, 1, 0]\\nprocessing_servers = [(4, 1), (6, 0)]\\n\\nAt arrival index 2, we have arrival time of 3 and load size of 10 \\nWe\\'ll end up popping server 2 and incrementing tasks at 2 \\nThis leaves uas at end of arrival index 2 in state of \\nServers -> []\\nNumber_of_tasks_per_server -> [1, 1, 1]\\nprocessing_servers = [(4, 1), (6, 0), (13, 2)]\\n\\nAt arrival index 3, we have arrival time of 4 and load size of 3\\nWe now have a servers_processing[0][0] that is <= arrival time\\nSo, we pop from processing servers to get \\n- prior_task, server_id = 4, 1\\n- arrival_index = 3 \\n- 3 + (1 - 3) mod 3 = 4 \\n- servers -> [4]\\nWe now will pop server 4, however! we will do mod k on it (as we did on the others) and get a result of 1 (the server we started with!)\\nWe increment server 1 then and push in a node of (7, 1)\\nWe end arrival index 3 with \\nServers -> []\\nNumber_of_tasks_per_server = [1, 2, 1]\\nProcessing_servers = [(6, 0), (7, 1), (13, 2)]\\n\\nThe rest are left as an exercise but hopefully this has helped you get the process so you can check the rest. If not, please post in the comments about what can be made more clear and I\\'ll do my best. \\n\\n# Code\\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # heap of servers currently available \\n        servers = list(range(k))\\n        # heap of servers currently processing \\n        servers_processing = []\\n        # number of tasks at this server over time \\n        number_of_tasks_by_server = [0]*k\\n\\n        # for each arrival in arrival\\n        for arrival_index in range(len(arrival)) : \\n            # get the arrival time and load size \\n            arrival_time = arrival[arrival_index]\\n            load_size = load[arrival_index]\\n            # while you have servers that were processing and have now finished \\n            while servers_processing and servers_processing[0][0] <= arrival_time : \\n                # finish those tasks you have completed \\n                prior_task, server_id = heapq.heappop(servers_processing)\\n                # print(\"Prior task at \", server_id, \" now completed.\")\\n                # push back into servers the current server_id at it\\'s heap key \\n                # the heap key is determined as arrival_index + (server_id - arrival_index) % k \\n                # this is because we are in a limited space (go to ith server until k, then loop back)\\n                # so, server_id + m*k  = i + x \\n                # where we have x going from 0 up to but not including k and i as some time quality \\n                # we then take modular of k of both sides \\n                # server_id % k + 0 (as m*k%k == 0) = i % k + x (as c % k == c iff c in [0, k)) \\n                # x = server_id % k - i % k \\n                # we then simplify by joining similar modulo\\'s \\n                # x = (server_id - i) % k \\n                # With x equal to this, if we use i as arrival index and go back to line 23 \\n                # we get server_id + mk = arrival_index + (server_id - arrival_index) % k \\n                # This means we can use arrival_index + (server_id - arrival_index) % k as our heap key \\n                # and that in doing so, it will map to a specific server id \\n                heapq.heappush(servers, arrival_index + (server_id - arrival_index)%k)\\n            # if you have servers available \\n            if servers : \\n                # get the next server by using heapq.heappop and keeping within k \\n                server = heapq.heappop(servers)%k\\n                # at this server, up the tasks by one \\n                number_of_tasks_by_server[server] += 1 \\n                # push this server into our servers processing with finish time of arrival_time plus load_size\\n                heapq.heappush(servers_processing, ((arrival_time+load_size), server))\\n            # else : \\n            #     print(\"No servers available, dropping task \", arrival_index, \" of size \", load_size)\\n\\n        highest_productivity = max(number_of_tasks_by_server)\\n        return [server for server in range(k) if number_of_tasks_by_server[server]==highest_productivity]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # heap of servers currently available \\n        servers = list(range(k))\\n        # heap of servers currently processing \\n        servers_processing = []\\n        # number of tasks at this server over time \\n        number_of_tasks_by_server = [0]*k\\n\\n        # for each arrival in arrival\\n        for arrival_index in range(len(arrival)) : \\n            # get the arrival time and load size \\n            arrival_time = arrival[arrival_index]\\n            load_size = load[arrival_index]\\n            # while you have servers that were processing and have now finished \\n            while servers_processing and servers_processing[0][0] <= arrival_time : \\n                # finish those tasks you have completed \\n                prior_task, server_id = heapq.heappop(servers_processing)\\n                # print(\"Prior task at \", server_id, \" now completed.\")\\n                # push back into servers the current server_id at it\\'s heap key \\n                # the heap key is determined as arrival_index + (server_id - arrival_index) % k \\n                # this is because we are in a limited space (go to ith server until k, then loop back)\\n                # so, server_id + m*k  = i + x \\n                # where we have x going from 0 up to but not including k and i as some time quality \\n                # we then take modular of k of both sides \\n                # server_id % k + 0 (as m*k%k == 0) = i % k + x (as c % k == c iff c in [0, k)) \\n                # x = server_id % k - i % k \\n                # we then simplify by joining similar modulo\\'s \\n                # x = (server_id - i) % k \\n                # With x equal to this, if we use i as arrival index and go back to line 23 \\n                # we get server_id + mk = arrival_index + (server_id - arrival_index) % k \\n                # This means we can use arrival_index + (server_id - arrival_index) % k as our heap key \\n                # and that in doing so, it will map to a specific server id \\n                heapq.heappush(servers, arrival_index + (server_id - arrival_index)%k)\\n            # if you have servers available \\n            if servers : \\n                # get the next server by using heapq.heappop and keeping within k \\n                server = heapq.heappop(servers)%k\\n                # at this server, up the tasks by one \\n                number_of_tasks_by_server[server] += 1 \\n                # push this server into our servers processing with finish time of arrival_time plus load_size\\n                heapq.heappush(servers_processing, ((arrival_time+load_size), server))\\n            # else : \\n            #     print(\"No servers available, dropping task \", arrival_index, \" of size \", load_size)\\n\\n        highest_productivity = max(number_of_tasks_by_server)\\n        return [server for server in range(k) if number_of_tasks_by_server[server]==highest_productivity]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032079,
                "title": "priority-queue-set-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>freq(k,0);\\n        vector<int>ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>busy_server;\\n        set<int>free_server;\\n        for(int i=0;i<k;i++)\\n            free_server.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            int start_time=arrival[i];\\n            int end_time=start_time+load[i];\\n            while(busy_server.size()>0 && busy_server.top().first<=start_time){\\n                free_server.insert(busy_server.top().second);\\n                busy_server.pop();\\n            }\\n            if(free_server.size()>0){\\n                auto itr = free_server.lower_bound(i%k);\\n                if(itr==free_server.end())\\n                    itr=free_server.begin();\\n                busy_server.push({end_time,*itr});\\n                freq[*itr]++;\\n                free_server.erase(*itr);\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        int val=0;\\n        for(int i=0;i<k;i++)\\n            val=max(val,freq[i]);\\n        \\n        for(int i=0;i<k;i++){\\n            if(freq[i]==val){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>freq(k,0);\\n        vector<int>ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>busy_server;\\n        set<int>free_server;\\n        for(int i=0;i<k;i++)\\n            free_server.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            int start_time=arrival[i];\\n            int end_time=start_time+load[i];\\n            while(busy_server.size()>0 && busy_server.top().first<=start_time){\\n                free_server.insert(busy_server.top().second);\\n                busy_server.pop();\\n            }\\n            if(free_server.size()>0){\\n                auto itr = free_server.lower_bound(i%k);\\n                if(itr==free_server.end())\\n                    itr=free_server.begin();\\n                busy_server.push({end_time,*itr});\\n                freq[*itr]++;\\n                free_server.erase(*itr);\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        int val=0;\\n        for(int i=0;i<k;i++)\\n            val=max(val,freq[i]);\\n        \\n        for(int i=0;i<k;i++){\\n            if(freq[i]==val){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020002,
                "title": "c-priorityqueue-ordered-set-binary-search-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int mxHandling = 0;\\n        // free server Ids\\n        set<int> free;\\n        // busy {freeTime, serverId} sorted in ascending order of free time.\\n        priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<pair<int64, int>>> busy;\\n        // {serverId --> count of tasks handled}\\n        int count[k + 1];\\n        for(int i = 0; i < k; i++) {\\n            free.insert(i);\\n            count[i] = 0;\\n        }\\n        int n = arrival.size();\\n        for(int i = 0; i < n; i++) {\\n            while(!busy.empty() && busy.top().first <= arrival[i]) {\\n                auto [freeTime, serverId] = busy.top();\\n                busy.pop();\\n                free.insert(serverId); \\n            }\\n            // request dropped if all servers are busy\\n            if(free.size() == 0) { \\n                continue;\\n            }\\n            auto it = free.lower_bound(i % k);\\n            if(it == free.end()) {\\n                it = free.begin();\\n            }\\n            int recommendedServerId = *it;    \\n            count[recommendedServerId]++;\\n            mxHandling = max(mxHandling, count[recommendedServerId]);\\n            busy.push({(int64)arrival[i] + load[i], recommendedServerId});\\n            free.erase(recommendedServerId);\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) {\\n            if(count[i] == mxHandling) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int mxHandling = 0;\\n        // free server Ids\\n        set<int> free;\\n        // busy {freeTime, serverId} sorted in ascending order of free time.\\n        priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<pair<int64, int>>> busy;\\n        // {serverId --> count of tasks handled}\\n        int count[k + 1];\\n        for(int i = 0; i < k; i++) {\\n            free.insert(i);\\n            count[i] = 0;\\n        }\\n        int n = arrival.size();\\n        for(int i = 0; i < n; i++) {\\n            while(!busy.empty() && busy.top().first <= arrival[i]) {\\n                auto [freeTime, serverId] = busy.top();\\n                busy.pop();\\n                free.insert(serverId); \\n            }\\n            // request dropped if all servers are busy\\n            if(free.size() == 0) { \\n                continue;\\n            }\\n            auto it = free.lower_bound(i % k);\\n            if(it == free.end()) {\\n                it = free.begin();\\n            }\\n            int recommendedServerId = *it;    \\n            count[recommendedServerId]++;\\n            mxHandling = max(mxHandling, count[recommendedServerId]);\\n            busy.push({(int64)arrival[i] + load[i], recommendedServerId});\\n            free.erase(recommendedServerId);\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) {\\n            if(count[i] == mxHandling) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929257,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:N lon(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeMap<Integer,Server> freeServer = new TreeMap<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            freeServer.put(i,new Server(0,0,i));\\n        }\\n\\n        PriorityQueue<Server> busyServer = new PriorityQueue<>((a,b)->a.endTime-b.endTime);\\n        for(int i = 0;i<arrival.length;i++)\\n        {\\n            while(!busyServer.isEmpty() && busyServer.peek().endTime<=arrival[i])\\n            {\\n                Server free = busyServer.poll();\\n                freeServer.put(free.id,free);\\n            }\\n            if(freeServer.isEmpty())\\n                continue;\\n            int index = i%k;\\n            Entry<Integer, Server> server = freeServer.ceilingEntry(index);\\n            if(server==null)\\n            {\\n                server = freeServer.firstEntry();\\n            }\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"arrival[i] -->>\"+arrival[i]);\\n            freeServer.remove(server.getKey());\\n            server.getValue().endTime = arrival[i]+load[i];\\n            server.getValue().count++;\\n            busyServer.add(server.getValue());\\n            //System.out.println(\"free Server -->>\"+freeServer);\\n            \\n        }\\n\\n         while(!busyServer.isEmpty())\\n        {\\n            Server free = busyServer.poll();\\n            freeServer.put(free.id,free);\\n        }\\n        \\n        int maxRequest = 0;\\n        for(Server server:freeServer.values())\\n        {\\n            maxRequest =Math.max(maxRequest, server.count);\\n        }\\n        // System.out.println(\"maxRequest -->>\"+maxRequest);\\n        // System.out.println(\"free Server -->>\"+freeServer);\\n        List<Integer> result = new ArrayList<>();\\n        for(int id:freeServer.keySet())\\n        {\\n            if(freeServer.get(id).count==maxRequest)\\n                result.add(id);\\n        }\\n        return result;\\n        \\n    }\\n    class Server{\\n        int endTime;\\n        int count;\\n        int id;\\n        public Server(int endTime, int count, int id)\\n        {\\n            this.endTime = endTime;\\n            this.count = count;\\n            this.id = id;\\n        }\\n        @Override\\n        public String toString() {\\n            return \"Server [endTime=\" + endTime + \", count=\" + count + \", id=\" + id + \"]\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeMap<Integer,Server> freeServer = new TreeMap<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            freeServer.put(i,new Server(0,0,i));\\n        }\\n\\n        PriorityQueue<Server> busyServer = new PriorityQueue<>((a,b)->a.endTime-b.endTime);\\n        for(int i = 0;i<arrival.length;i++)\\n        {\\n            while(!busyServer.isEmpty() && busyServer.peek().endTime<=arrival[i])\\n            {\\n                Server free = busyServer.poll();\\n                freeServer.put(free.id,free);\\n            }\\n            if(freeServer.isEmpty())\\n                continue;\\n            int index = i%k;\\n            Entry<Integer, Server> server = freeServer.ceilingEntry(index);\\n            if(server==null)\\n            {\\n                server = freeServer.firstEntry();\\n            }\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"arrival[i] -->>\"+arrival[i]);\\n            freeServer.remove(server.getKey());\\n            server.getValue().endTime = arrival[i]+load[i];\\n            server.getValue().count++;\\n            busyServer.add(server.getValue());\\n            //System.out.println(\"free Server -->>\"+freeServer);\\n            \\n        }\\n\\n         while(!busyServer.isEmpty())\\n        {\\n            Server free = busyServer.poll();\\n            freeServer.put(free.id,free);\\n        }\\n        \\n        int maxRequest = 0;\\n        for(Server server:freeServer.values())\\n        {\\n            maxRequest =Math.max(maxRequest, server.count);\\n        }\\n        // System.out.println(\"maxRequest -->>\"+maxRequest);\\n        // System.out.println(\"free Server -->>\"+freeServer);\\n        List<Integer> result = new ArrayList<>();\\n        for(int id:freeServer.keySet())\\n        {\\n            if(freeServer.get(id).count==maxRequest)\\n                result.add(id);\\n        }\\n        return result;\\n        \\n    }\\n    class Server{\\n        int endTime;\\n        int count;\\n        int id;\\n        public Server(int endTime, int count, int id)\\n        {\\n            this.endTime = endTime;\\n            this.count = count;\\n            this.id = id;\\n        }\\n        @Override\\n        public String toString() {\\n            return \"Server [endTime=\" + endTime + \", count=\" + count + \", id=\" + id + \"]\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879799,
                "title": "using-2-heap",
                "content": "```\\ntype Server struct {\\n    Id int\\n    AvailableAt int\\n}\\n\\ntype BusyPriorityQ []Server\\n\\nfunc (pq BusyPriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq BusyPriorityQ) Less(i, j int) bool {\\n    return pq[i].AvailableAt < pq[j].AvailableAt \\n}\\n\\nfunc (pq BusyPriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *BusyPriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *BusyPriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\ntype FreePriorityQ []Server\\n\\nfunc (pq FreePriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq FreePriorityQ) Less(i, j int) bool {\\n    return pq[i].Id < pq[j].Id \\n}\\n\\nfunc (pq FreePriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *FreePriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *FreePriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    busyPq := &BusyPriorityQ{}\\n    freePq := &FreePriorityQ{}\\n    \\n    heap.Init(freePq)\\n    heap.Init(busyPq)\\n    \\n    for i:=0; i<k;i++ {\\n        heap.Push(freePq, Server{\\n            Id : i,\\n            AvailableAt: 0,\\n        })\\n    }\\n    \\n    count := make([]int, k)\\n    max := 0\\n    \\n    for i:=0; i<len(arrival); i++ {\\n        startTime := arrival[i]\\n        endTime := startTime + load[i]\\n        \\n        for len(*busyPq) > 0 && (*busyPq)[0].AvailableAt <= startTime{\\n            nextFreeServer := heap.Pop(busyPq).(Server)\\n            \\n            serverId := nextFreeServer.Id\\n            \\n            modifiedId := serverId - i\\n            \\n            for modifiedId < 0 {\\n                modifiedId = modifiedId + k\\n            }\\n            \\n            modifiedId = modifiedId % k + i\\n            //fmt.Println(serverId, modifiedId, i, (serverId - i) % k)\\n            nextFreeServer.Id  = modifiedId\\n            heap.Push(freePq, nextFreeServer)\\n        }\\n        \\n        if len(*freePq) > 0 {\\n            assigning := heap.Pop(freePq).(Server)\\n            assigning.AvailableAt = endTime\\n            \\n            busyId  := assigning.Id % k \\n            assigning.Id = busyId\\n            \\n            heap.Push(busyPq, assigning)\\n            \\n            count[assigning.Id]++\\n            \\n            if max < count[assigning.Id] {\\n                max = count[assigning.Id]\\n            }\\n        }\\n    }\\n    \\n    \\n    result := []int{}\\n    for i:=0; i<k; i++ {\\n        if count[i] == max {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Server struct {\\n    Id int\\n    AvailableAt int\\n}\\n\\ntype BusyPriorityQ []Server\\n\\nfunc (pq BusyPriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq BusyPriorityQ) Less(i, j int) bool {\\n    return pq[i].AvailableAt < pq[j].AvailableAt \\n}\\n\\nfunc (pq BusyPriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *BusyPriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *BusyPriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\ntype FreePriorityQ []Server\\n\\nfunc (pq FreePriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq FreePriorityQ) Less(i, j int) bool {\\n    return pq[i].Id < pq[j].Id \\n}\\n\\nfunc (pq FreePriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *FreePriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *FreePriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    busyPq := &BusyPriorityQ{}\\n    freePq := &FreePriorityQ{}\\n    \\n    heap.Init(freePq)\\n    heap.Init(busyPq)\\n    \\n    for i:=0; i<k;i++ {\\n        heap.Push(freePq, Server{\\n            Id : i,\\n            AvailableAt: 0,\\n        })\\n    }\\n    \\n    count := make([]int, k)\\n    max := 0\\n    \\n    for i:=0; i<len(arrival); i++ {\\n        startTime := arrival[i]\\n        endTime := startTime + load[i]\\n        \\n        for len(*busyPq) > 0 && (*busyPq)[0].AvailableAt <= startTime{\\n            nextFreeServer := heap.Pop(busyPq).(Server)\\n            \\n            serverId := nextFreeServer.Id\\n            \\n            modifiedId := serverId - i\\n            \\n            for modifiedId < 0 {\\n                modifiedId = modifiedId + k\\n            }\\n            \\n            modifiedId = modifiedId % k + i\\n            //fmt.Println(serverId, modifiedId, i, (serverId - i) % k)\\n            nextFreeServer.Id  = modifiedId\\n            heap.Push(freePq, nextFreeServer)\\n        }\\n        \\n        if len(*freePq) > 0 {\\n            assigning := heap.Pop(freePq).(Server)\\n            assigning.AvailableAt = endTime\\n            \\n            busyId  := assigning.Id % k \\n            assigning.Id = busyId\\n            \\n            heap.Push(busyPq, assigning)\\n            \\n            count[assigning.Id]++\\n            \\n            if max < count[assigning.Id] {\\n                max = count[assigning.Id]\\n            }\\n        }\\n    }\\n    \\n    \\n    result := []int{}\\n    for i:=0; i<k; i++ {\\n        if count[i] == max {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2879228,
                "title": "easy-to-understand-brute-force-solution",
                "content": "```\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    serverReqCount := make([]int, k)\\n    servers := make([]int, k)\\n    \\n    maxRequestServed := 0  // max request served by any sever \\n    \\n    for i:=0; i<len(arrival); i++ {\\n        arrivalTime := arrival[i]\\n        duration := load[i]\\n        nextServer := i % k // request will go to this server as per questioon\\n        for j:=0; j<k; j++ { // iterate over all servers \\n            if nextServer == k {  // reached to last server, start from frist\\n                nextServer = 0\\n            }\\n            if servers[nextServer] <= arrivalTime {\\n                servers[nextServer] = arrivalTime + duration  // serving requat till this time\\n                serverReqCount[nextServer]++\\n                \\n                if maxRequestServed < serverReqCount[nextServer] {\\n                    maxRequestServed = serverReqCount[nextServer]\\n                }\\n                break\\n            }\\n            nextServer++\\n        }\\n    \\n    }\\n    \\n    result := []int{}\\n    // all servers which served max request\\n    for i:=0; i<len(serverReqCount); i++ {\\n        if serverReqCount[i] == maxRequestServed {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    serverReqCount := make([]int, k)\\n    servers := make([]int, k)\\n    \\n    maxRequestServed := 0  // max request served by any sever \\n    \\n    for i:=0; i<len(arrival); i++ {\\n        arrivalTime := arrival[i]\\n        duration := load[i]\\n        nextServer := i % k // request will go to this server as per questioon\\n        for j:=0; j<k; j++ { // iterate over all servers \\n            if nextServer == k {  // reached to last server, start from frist\\n                nextServer = 0\\n            }\\n            if servers[nextServer] <= arrivalTime {\\n                servers[nextServer] = arrivalTime + duration  // serving requat till this time\\n                serverReqCount[nextServer]++\\n                \\n                if maxRequestServed < serverReqCount[nextServer] {\\n                    maxRequestServed = serverReqCount[nextServer]\\n                }\\n                break\\n            }\\n            nextServer++\\n        }\\n    \\n    }\\n    \\n    result := []int{}\\n    // all servers which served max request\\n    for i:=0; i<len(serverReqCount); i++ {\\n        if serverReqCount[i] == maxRequestServed {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848573,
                "title": "just-working-one-for-js-as-no-one-exists",
                "content": "# Intuition\\nThe solution in general not very hard. \\nWe just need to track min next server before and after the current one.\\nAnd of course when the processing will be finished for already working.\\n\\n\\n# Approach\\n3 MinPriorityQueue\\n\\n1 - We keep tracking when the server will be free.\\n2 - We tracking the next min value after k%i\\n3 - We tracking the next min value before k%i\\n\\nOn each iteration we try to take the server from 2, if no from 3 if no - drop.\\nOn each new cercle 3 becomes 2.\\n \\n\\n\\n# Complexity\\n- Time complexity:\\narrival.length * log(k)\\n\\n- Space complexity:\\narrival.length + k\\n\\n# Code\\n```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    let louds = {};\\n\\n    let processing = new MinPriorityQueue();\\n    let servers1 = new MinPriorityQueue();\\n    let servers2 = new MinPriorityQueue();\\n    let max = 0;\\n\\n    for (let i = 0; i < k; i++) {\\n        servers2.enqueue(i, i);\\n    }\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        let start = arrival[i];\\n        let end = start + load[i];\\n\\n        let iterator = i % k;\\n\\n        if (iterator == 0) {\\n            servers1 = servers2;\\n            servers2 = new MinPriorityQueue();\\n        }\\n\\n        while (processing.front() && processing.front().priority <= start) {\\n            let servers = processing.dequeue();\\n            if (servers.element < iterator) {\\n                servers2.enqueue(servers.element);\\n            } else {\\n                servers1.enqueue(servers.element);\\n            }\\n        }\\n\\n        let server = null;\\n\\n        if (servers1.front()) {\\n            server = servers1.dequeue().element;\\n        } else if (servers2.front()) {\\n            server = servers2.dequeue().element;\\n        }\\n\\n        if (server != null) {\\n            if (louds[server] == undefined) {\\n                louds[server] = 0;\\n            }\\n            louds[server]++;\\n            max = Math.max(louds[server], max);\\n            processing.enqueue(server, end);\\n        }\\n    }\\n    \\n    let result = [];\\n    for (let prop in louds) {\\n        if (louds[prop] == max) {\\n            result.push(prop);\\n        }\\n\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    let louds = {};\\n\\n    let processing = new MinPriorityQueue();\\n    let servers1 = new MinPriorityQueue();\\n    let servers2 = new MinPriorityQueue();\\n    let max = 0;\\n\\n    for (let i = 0; i < k; i++) {\\n        servers2.enqueue(i, i);\\n    }\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        let start = arrival[i];\\n        let end = start + load[i];\\n\\n        let iterator = i % k;\\n\\n        if (iterator == 0) {\\n            servers1 = servers2;\\n            servers2 = new MinPriorityQueue();\\n        }\\n\\n        while (processing.front() && processing.front().priority <= start) {\\n            let servers = processing.dequeue();\\n            if (servers.element < iterator) {\\n                servers2.enqueue(servers.element);\\n            } else {\\n                servers1.enqueue(servers.element);\\n            }\\n        }\\n\\n        let server = null;\\n\\n        if (servers1.front()) {\\n            server = servers1.dequeue().element;\\n        } else if (servers2.front()) {\\n            server = servers2.dequeue().element;\\n        }\\n\\n        if (server != null) {\\n            if (louds[server] == undefined) {\\n                louds[server] = 0;\\n            }\\n            louds[server]++;\\n            max = Math.max(louds[server], max);\\n            processing.enqueue(server, end);\\n        }\\n    }\\n    \\n    let result = [];\\n    for (let prop in louds) {\\n        if (louds[prop] == max) {\\n            result.push(prop);\\n        }\\n\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841074,
                "title": "c-std-set-for-free-servers-and-std-priority-queue-for-busy-servers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<pair<int,int>> serverLoad(k);\\n        std::set<int> freeServers;\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> busyServers;\\n\\t\\t/* initially, all servers are free */\\n        for (int i=0; i<k; i++) {\\n            freeServers.insert(i);\\n        }\\n        for (int i=0; i<k; i++) {\\n            serverLoad[i] = {0,i};\\n        }\\n        for (int i=0; i<arrival.size(); i++) {\\n\\t\\t/* check which servers become free at this arrival time and move them to the free servers set */\\n            while((!busyServers.empty()) && (busyServers.top().first <= arrival[i])) {\\n                int server = busyServers.top().second;\\n                busyServers.pop();\\n                freeServers.insert(server);\\n            }\\n\\t\\t\\t/* find the available server to assign to this request */\\n            auto itr = freeServers.lower_bound(i%k);\\n            if (itr == freeServers.end()) {\\n                itr = freeServers.begin();\\n            }\\n            if (itr != freeServers.end()) {\\n\\t\\t\\t/* asign server and move th eserver to busy pq */\\n                busyServers.push({arrival[i]+load[i], *itr});\\n                serverLoad[*itr].first++;\\n                freeServers.erase(itr);\\n            }\\n        }\\n\\t\\t/* find all servers that are teh busyest */\\n        sort(serverLoad.begin(), serverLoad.end(), greater<pair<int,int>>());\\n        vector<int> result;\\n        result.emplace_back(serverLoad[0].second);\\n        for(int i=1; i<serverLoad.size(); i++) {\\n            if (serverLoad[i].first == serverLoad[0].first) {\\n                result.emplace_back(serverLoad[i].second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<pair<int,int>> serverLoad(k);\\n        std::set<int> freeServers;\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> busyServers;\\n\\t\\t/* initially, all servers are free */\\n        for (int i=0; i<k; i++) {\\n            freeServers.insert(i);\\n        }\\n        for (int i=0; i<k; i++) {\\n            serverLoad[i] = {0,i};\\n        }\\n        for (int i=0; i<arrival.size(); i++) {\\n\\t\\t/* check which servers become free at this arrival time and move them to the free servers set */\\n            while((!busyServers.empty()) && (busyServers.top().first <= arrival[i])) {\\n                int server = busyServers.top().second;\\n                busyServers.pop();\\n                freeServers.insert(server);\\n            }\\n\\t\\t\\t/* find the available server to assign to this request */\\n            auto itr = freeServers.lower_bound(i%k);\\n            if (itr == freeServers.end()) {\\n                itr = freeServers.begin();\\n            }\\n            if (itr != freeServers.end()) {\\n\\t\\t\\t/* asign server and move th eserver to busy pq */\\n                busyServers.push({arrival[i]+load[i], *itr});\\n                serverLoad[*itr].first++;\\n                freeServers.erase(itr);\\n            }\\n        }\\n\\t\\t/* find all servers that are teh busyest */\\n        sort(serverLoad.begin(), serverLoad.end(), greater<pair<int,int>>());\\n        vector<int> result;\\n        result.emplace_back(serverLoad[0].second);\\n        for(int i=1; i<serverLoad.size(); i++) {\\n            if (serverLoad[i].first == serverLoad[0].first) {\\n                result.emplace_back(serverLoad[i].second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813930,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> svs;\\n        for(int i = 0; i < k; i++) svs.insert(i);\\n        priority_queue<array<int, 2>> pq;\\n        int N = arrival.size(), cnt[100001]{}, r = 0, server = 0, max_v = 0;\\n        for(int i = 0; i < N; i++) {\\n            while(!pq.empty() && -pq.top()[0] <= arrival[i]) {\\n                svs.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            r = i%k;\\n            if(svs.size()) {\\n                auto p = svs.lower_bound(r);\\n                if(p != svs.end()) server = *p;\\n                else server = *begin(svs);\\n                max_v = max(max_v, ++cnt[server]);\\n                svs.erase(server);\\n                pq.push({-(arrival[i]+ load[i]), server});\\n            }\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < k; i++) if(cnt[i] == max_v) res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> svs;\\n        for(int i = 0; i < k; i++) svs.insert(i);\\n        priority_queue<array<int, 2>> pq;\\n        int N = arrival.size(), cnt[100001]{}, r = 0, server = 0, max_v = 0;\\n        for(int i = 0; i < N; i++) {\\n            while(!pq.empty() && -pq.top()[0] <= arrival[i]) {\\n                svs.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            r = i%k;\\n            if(svs.size()) {\\n                auto p = svs.lower_bound(r);\\n                if(p != svs.end()) server = *p;\\n                else server = *begin(svs);\\n                max_v = max(max_v, ++cnt[server]);\\n                svs.erase(server);\\n                pq.push({-(arrival[i]+ load[i]), server});\\n            }\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < k; i++) if(cnt[i] == max_v) res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803656,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>&load) {\\n     int n=arr.size();\\n        \\n      vector<int>v;\\n        //server and req completed\\n        unordered_map<int,int>mp;\\n        \\n        // time , server\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >pq;\\n        \\n    \\n        //server  available\\n        set<int>st;\\n        \\n    //intially all server free so we assign first k req to server\\n        \\n    for(int i=0;i<k&&i<n;i++){\\n     pq.push({arr[i]+load[i] , i});\\n        mp[i]++;\\n    }     \\n  for(int i=k;i<n;i++){\\n  \\n      //we enter if any server is available or free the server at same time when new req arrive.\\n    if(st.size() || (!pq.empty()&&pq.top().first <= arr[i])){\\n        \\n      while(!pq.empty()&&pq.top().first <= arr[i]){\\n          st.insert(pq.top().second);\\n          pq.pop();\\n      }\\n          \\n    auto server=lower_bound(st.begin(),st.end(),i%k);\\n   \\n      if(server==st.end())\\n          server=st.begin();\\n        \\n  pq.push({arr[i]+load[i],*server});\\n        mp[*server]++;  \\n        \\n        st.erase(server);\\n    }  \\n      \\n      \\n  }    \\n        \\n        \\n  int req=0;\\n        \\n    for(auto x:mp) req=max(req,x.second);\\n        \\n  for(auto x:mp){\\n      if(x.second==req)v.push_back(x.first);\\n  }      \\n        \\n        \\n        \\n  return v;      \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>&load) {\\n     int n=arr.size();\\n        \\n      vector<int>v;\\n        //server and req completed\\n        unordered_map<int,int>mp;\\n        \\n        // time , server\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >pq;\\n        \\n    \\n        //server  available\\n        set<int>st;\\n        \\n    //intially all server free so we assign first k req to server\\n        \\n    for(int i=0;i<k&&i<n;i++){\\n     pq.push({arr[i]+load[i] , i}",
                "codeTag": "Java"
            },
            {
                "id": 2799288,
                "title": "c-segment-tree-detailed-explanation",
                "content": "# Intuition\\nPorted from C++: https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/solutions/1277420/segment-tree-based-solution-beats-88-solutions-in-time-and-96-solutions-in-memory/?topicTags=binary-tree\\n\\n# Approach\\nThere\\'s a reason why there aren\\'t many C# solutions for this problem. Most approaches use Java\\'s TreeSet which has no good equivalent in C#. Sometimes you can get away with SortedSet, but not in this problem. Using SortedSet you can get at most 104/108 in LeetCode, where the time limit exceptions start to occurr. Our bottleneck occurrs when we need to search for free servers. In Java we can use TreeSet\\'s Ceiling which is  O(logn), but C# has nothing close to that, in terms of performance, that can work with SortedSets, thus we time out. Fortunately, we can still solve this problem using Segment Trees.\\n\\nThe code below has an array representation of a segment tree. For each node at index $$i$$, the left child is at index $$(2*i+1)$$, right child at $$(2*i+2)$$ and the parent is at  $$(\\u230A(i \\u2013 1) / 2\\u230B)$$. \\n\\nThe memory needed for allocation for the segment tree should be at least $$(2 ** 2\\u2308log2n\\u2309  \\u2013 1)$$. The code below is using $$4*MAXN$$, which is larger than that.\\n\\n## Update\\n```\\nvoid Update(int ind,int l,int r,int i,int x)\\n```\\n\\n$$ind$$: index of current server\\n$$l$$: smallest valid server index\\n$$r$$: highest valid server index\\n$$i$$: segment tree array index to be updated\\n$$x$$: arrivalTime + load for the package that the current server is handling\\n\\n\\nThe first line of this method returns if the index of the current server is out of bounds of our tree, or our tree max and min are swaped.\\n\\n```\\n    if(ind>r||ind<l||l>r) return ;\\n```\\n\\nThe following situation handled consists of when the array has only one element $$(l==r)$$, then we store $$x$$ at the current node of the segment tree.\\nSince $$l==r$$, $$ind$$ has to be equal to $$l$$ as well, otherwise we\\'d be out of bounds.\\n\\n```\\nif(l==r)\\n{\\n    if(l==ind)\\n        seg[i]=x;\\n    return ;\\n}\\n```\\n\\nIf there is more than one element, then we recur for left and right subtrees and store the minimum of $$x$$ values in this node.\\n\\n ```\\nint mid=(l+r)/2;\\nUpdate(ind,l,mid,2*i+1,x);\\nUpdate(ind,mid+1,r,2*i+2,x);\\nseg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n```\\nAll levels of the constructed segment tree will be completely filled except the last level. The last level are the leaves, which are the server array elements, thus not needing to be stored.\\n\\n## Query\\n```\\nint Query(int st,int en,int l,int r,int i,int x)\\n```\\nst: start of query range\\nen: end of query range\\nl: smallest valid server index\\nr: highest valid server index\\ni: index of current node in the segment tree\\nx: arrival time\\n\\nNote that Query returns server indexes, not intervals.\\n\\n## BusiestServers\\n\\n1-Iterate over the arrival time array\\n2-start with a query for i%k to k-1, the server with lowest index will be returned if any server is available\\n3-increment the usage counter for that server\\n4-update the segment tree\\n5-start again until all start times were iterated\\n\\n3b-if the first query returned -1, do a second query for 0 to i%k-1\\n4b-go back to 3\\n\\n6-indetify the busiest servers and return them as an array\\n\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    static readonly int MAXN = 100001;\\n    static int[] seg;\\n    void Update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        Update(ind,l,mid,2*i+1,x);\\n        Update(ind,mid+1,r,2*i+2,x);\\n        seg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n    }\\n    int Query(int st,int en,int l,int r,int i,int x)\\n    {\\n\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid = (l+r)/2;\\n        int lf = Query(st,en,l,mid,2*i+1,x);\\n        if(lf!=-1)\\n            return lf;\\n        int rf = Query(st,en,mid+1,r,2*i+2,x);\\n        return rf;\\n    }\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        int i,n=arrival.Length;\\n        seg = new int[4*MAXN];\\n        List<int> b = new List<int>(new int[n]),ans = new();\\n        Dictionary<int,int> m = new();\\n        for( i = 0; i< k; i++)\\n        {\\n            m.Add(i,0);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int x=Query(i%k,k-1,0,k-1,0,arrival[i]);\\n            if(x!=-1)\\n            {\\n                m[x]++;\\n                b[x] = arrival[i] + load[i];\\n                Update(x,0,k-1,0,b[x]);\\n                continue;\\n            }\\n            int y = Query(0,i%k-1,0,k-1,0,arrival[i]);\\n            if(y != -1)\\n            {\\n                m[y]++;\\n                b[y]= arrival[i] + load[i];\\n                Update(y,0,k-1,0,b[y]);\\n            }\\n        }\\n        int maxi=0;\\n        foreach(var e in m)\\n            maxi = Math.Max(maxi,e.Value);\\n\\n        foreach(var e in m)\\n        {\\n            if(e.Value == maxi)\\n                ans.Add(e.Key);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nvoid Update(int ind,int l,int r,int i,int x)\\n```\n```\\n    if(ind>r||ind<l||l>r) return ;\\n```\n```\\nif(l==r)\\n{\\n    if(l==ind)\\n        seg[i]=x;\\n    return ;\\n}\\n```\n```\\nint mid=(l+r)/2;\\nUpdate(ind,l,mid,2*i+1,x);\\nUpdate(ind,mid+1,r,2*i+2,x);\\nseg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n```\n```\\nint Query(int st,int en,int l,int r,int i,int x)\\n```\n```\\npublic class Solution \\n{\\n    static readonly int MAXN = 100001;\\n    static int[] seg;\\n    void Update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        Update(ind,l,mid,2*i+1,x);\\n        Update(ind,mid+1,r,2*i+2,x);\\n        seg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n    }\\n    int Query(int st,int en,int l,int r,int i,int x)\\n    {\\n\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid = (l+r)/2;\\n        int lf = Query(st,en,l,mid,2*i+1,x);\\n        if(lf!=-1)\\n            return lf;\\n        int rf = Query(st,en,mid+1,r,2*i+2,x);\\n        return rf;\\n    }\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        int i,n=arrival.Length;\\n        seg = new int[4*MAXN];\\n        List<int> b = new List<int>(new int[n]),ans = new();\\n        Dictionary<int,int> m = new();\\n        for( i = 0; i< k; i++)\\n        {\\n            m.Add(i,0);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int x=Query(i%k,k-1,0,k-1,0,arrival[i]);\\n            if(x!=-1)\\n            {\\n                m[x]++;\\n                b[x] = arrival[i] + load[i];\\n                Update(x,0,k-1,0,b[x]);\\n                continue;\\n            }\\n            int y = Query(0,i%k-1,0,k-1,0,arrival[i]);\\n            if(y != -1)\\n            {\\n                m[y]++;\\n                b[y]= arrival[i] + load[i];\\n                Update(y,0,k-1,0,b[y]);\\n            }\\n        }\\n        int maxi=0;\\n        foreach(var e in m)\\n            maxi = Math.Max(maxi,e.Value);\\n\\n        foreach(var e in m)\\n        {\\n            if(e.Value == maxi)\\n                ans.Add(e.Key);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735772,
                "title": "c-ordered-set-min-heap-easy-to-understand",
                "content": "1. Since all servers are free initially, we can assign first k requests to first k servers.\\n2. We need to maintain a min-heap which contains requests sorted according to their end time. We also need to maintain a sorted set of all available servers.\\n3. Whenever a new request arrives, we can remove all requests which have ended from the min-heap and add the freed server back to the sorted set.\\n4. If there is no free server currently, we can continue with next request since current request will be dropped.\\n5. Otherwise, we can get the server which should serve this request using `i%k`. We can then binary search on the available sorted list of servers to get free server closest to `i%k`.\\n6. If there is no such server, start from begining and pick the 0th available server - `s.begin()`\\n7. Add the new request to min-heap & erase the picked server from set of available servers.\\n8. Increment the `server_freq` for this index.\\n9. Iterate over all server frequencies to get list of servers which processed most of the requests & return the list.\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        set<int> s;\\n        int ans = 0;\\n        unordered_map<int, int> server_freq;\\n        for(int i = 0; i < min(k, (int)arrival.size()); i++) {\\n            pq.push({ arrival[i] + load[i], i });\\n            server_freq[i] = 1;\\n            ans = 1;\\n        }\\n        for(int i = k; i < arrival.size(); i++) {\\n            while(!pq.empty() && pq.top().first <= arrival[i]) {\\n                s.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(s.size() == 0) continue;\\n            int idx = i%k;\\n            auto it = s.lower_bound(idx);\\n            if(it == s.end()) it = s.begin();\\n            int use_idx = *it;\\n            server_freq[use_idx]++;\\n            if(server_freq[use_idx] > ans) ans = server_freq[use_idx];\\n            pq.push({ arrival[i] + load[i], use_idx });\\n            s.erase(use_idx);\\n        }\\n        vector<int> res;\\n        for(auto it = server_freq.begin(); it != server_freq.end(); it++) {\\n            if(it->second == ans) res.push_back(it->first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        set<int> s;\\n        int ans = 0;\\n        unordered_map<int, int> server_freq;\\n        for(int i = 0; i < min(k, (int)arrival.size()); i++) {\\n            pq.push({ arrival[i] + load[i], i });\\n            server_freq[i] = 1;\\n            ans = 1;\\n        }\\n        for(int i = k; i < arrival.size(); i++) {\\n            while(!pq.empty() && pq.top().first <= arrival[i]) {\\n                s.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(s.size() == 0) continue;\\n            int idx = i%k;\\n            auto it = s.lower_bound(idx);\\n            if(it == s.end()) it = s.begin();\\n            int use_idx = *it;\\n            server_freq[use_idx]++;\\n            if(server_freq[use_idx] > ans) ans = server_freq[use_idx];\\n            pq.push({ arrival[i] + load[i], use_idx });\\n            s.erase(use_idx);\\n        }\\n        vector<int> res;\\n        for(auto it = server_freq.begin(); it != server_freq.end(); it++) {\\n            if(it->second == ans) res.push_back(it->first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727118,
                "title": "46-lines-of-bliss-optimization-idea-borrowed-from-lechen999",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]); // minHeap\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] timesBusyCount = new int[k];\\n        List<Integer> busiestServers = new LinkedList<>();\\n        \\n        // init:\\n        busy.add(new int[]{0, arrival[0] + load[0]});\\n        // server with the index of 0 becomes busy right away\\n        for(int i=1;i<k;i++) available.add(i);\\n        int max = 1;\\n        busiestServers.add(0);\\n        timesBusyCount[0]=1;\\n        \\n        for(int i=1; i<arrival.length;i++){\\n            \\n            // free up all servers that became free on ith arrival\\n            while(!busy.isEmpty() && busy.peek()[1] <= arrival[i]){\\n                int[] pair = busy.poll();\\n                available.add(pair[0]);\\n            }\\n            \\n            int requestedServer = i%k;\\n            \\n            Integer nextBestServer = available.ceiling(requestedServer);\\n            if(!available.isEmpty() && nextBestServer == null) // starting from the beginning of the collection\\n                nextBestServer = available.first();\\n            \\n            if(nextBestServer !=null){\\n                busy.add(new int[]{nextBestServer, arrival[i] + load[i]});\\n                available.remove(nextBestServer);\\n                timesBusyCount[nextBestServer]++;\\n                if(timesBusyCount[nextBestServer] > max){\\n                    busiestServers = new LinkedList<>();\\n                    busiestServers.add(nextBestServer);\\n                    max = timesBusyCount[nextBestServer];\\n                }\\n                else if(timesBusyCount[nextBestServer] == max)\\n                    busiestServers.add(nextBestServer);\\n            }\\n            \\n        }\\n        return busiestServers;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]); // minHeap\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] timesBusyCount = new int[k];\\n        List<Integer> busiestServers = new LinkedList<>();\\n        \\n        // init:\\n        busy.add(new int[]{0, arrival[0] + load[0]});\\n        // server with the index of 0 becomes busy right away\\n        for(int i=1;i<k;i++) available.add(i);\\n        int max = 1;\\n        busiestServers.add(0);\\n        timesBusyCount[0]=1;\\n        \\n        for(int i=1; i<arrival.length;i++){\\n            \\n            // free up all servers that became free on ith arrival\\n            while(!busy.isEmpty() && busy.peek()[1] <= arrival[i]){\\n                int[] pair = busy.poll();\\n                available.add(pair[0]);\\n            }\\n            \\n            int requestedServer = i%k;\\n            \\n            Integer nextBestServer = available.ceiling(requestedServer);\\n            if(!available.isEmpty() && nextBestServer == null) // starting from the beginning of the collection\\n                nextBestServer = available.first();\\n            \\n            if(nextBestServer !=null){\\n                busy.add(new int[]{nextBestServer, arrival[i] + load[i]});\\n                available.remove(nextBestServer);\\n                timesBusyCount[nextBestServer]++;\\n                if(timesBusyCount[nextBestServer] > max){\\n                    busiestServers = new LinkedList<>();\\n                    busiestServers.add(nextBestServer);\\n                    max = timesBusyCount[nextBestServer];\\n                }\\n                else if(timesBusyCount[nextBestServer] == max)\\n                    busiestServers.add(nextBestServer);\\n            }\\n            \\n        }\\n        return busiestServers;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683390,
                "title": "java-beat-42-treeset-and-priority-o-n-k-logk",
                "content": "1. create PriorityQueue busy to help maintain every server that has assigned task, the endTime. And pops all that can accept new task once need;\\n2. create free TreeSet to records all servers that can serve, use i % k to rotately find one can serve tasks.\\n3. create int[100010] to record every server executed tasks number, iterate to find all with max tasks.  \\n```\\n    //records how many load each server worked on.\\n    int[] cnt;\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //only need K servers.\\n\\t\\tcnt = new int[k];\\n        int n = arrival.length, max = 0;\\n        //record <idx, endTime> to record each server\\'s free time start point \\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        //need to find >= (i % k) th sever, which needs servers in order, and ceiling function.\\n        TreeSet<Integer> free = new TreeSet();\\n        for(int i = 0 ; i < k; i++) {\\n            free.add(i);\\n        }\\n        for(int i = 0 ; i < n; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            //add back all previous buys servers to free, if they can pick up new taskes.\\n\\t\\t\\t// each task is arrival in increasing start time order.\\n            while(!busy.isEmpty() && busy.peek()[1] <= start) {\\n                free.add(busy.poll()[0]);\\n            }\\n            //find the >= (i%K)\\n            Integer server = free.ceiling(i % k);\\n            if(server == null) {\\n                //if no bigger one, start from 0;\\n                server = free.ceiling(0);\\n            }\\n            //need to drop the task\\n            if(server == null) continue;\\n            free.remove(server);\\n            //means one server is doing something\\n            busy.add(new int[]{server, end});\\n            max = Math.max(max, ++cnt[server]);\\n        }\\n        \\n        List<Integer> res = new ArrayList();\\n        for(int i = 0 ; i < k; i++) {\\n            if(cnt[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n    //records how many load each server worked on.\\n    int[] cnt;\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //only need K servers.\\n\\t\\tcnt = new int[k];\\n        int n = arrival.length, max = 0;\\n        //record <idx, endTime> to record each server\\'s free time start point \\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        //need to find >= (i % k) th sever, which needs servers in order, and ceiling function.\\n        TreeSet<Integer> free = new TreeSet();\\n        for(int i = 0 ; i < k; i++) {\\n            free.add(i);\\n        }\\n        for(int i = 0 ; i < n; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            //add back all previous buys servers to free, if they can pick up new taskes.\\n\\t\\t\\t// each task is arrival in increasing start time order.\\n            while(!busy.isEmpty() && busy.peek()[1] <= start) {\\n                free.add(busy.poll()[0]);\\n            }\\n            //find the >= (i%K)\\n            Integer server = free.ceiling(i % k);\\n            if(server == null) {\\n                //if no bigger one, start from 0;\\n                server = free.ceiling(0);\\n            }\\n            //need to drop the task\\n            if(server == null) continue;\\n            free.remove(server);\\n            //means one server is doing something\\n            busy.add(new int[]{server, end});\\n            max = Math.max(max, ++cnt[server]);\\n        }\\n        \\n        List<Integer> res = new ArrayList();\\n        for(int i = 0 ; i < k; i++) {\\n            if(cnt[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525707,
                "title": "nlogn-solution-using-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();//we will keep the available servers in order\\n        int[] count = new int[k];\\n        for(int i=0;i<k;i++){\\n            available.add(i);\\n        }\\n        int max = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b)->Integer.compare(a[1], b[1]));//arr will be 1st param id of server and 2nd be the end time\\n        for(int i=0;i<arrival.length;i++){\\n            while(!pq.isEmpty() && pq.peek()[1] <= arrival[i]) {\\n                int[] arr = pq.remove();\\n                available.add(arr[0]);\\n            }\\n            if(available.contains(i%k)){\\n                available.remove(i%k);\\n                count[i%k]++;\\n                max = Math.max(max, count[i%k]);\\n                pq.add(new int[]{i%k, arrival[i]+load[i]});\\n            } else if(available.size() > 0){\\n                Integer next = available.higher(i%k) != null?available.higher(i%k):available.first();\\n                available.remove(next);\\n                count[next]++;\\n                max = Math.max(max, count[next]);\\n                pq.add(new int[]{next, arrival[i]+load[i]});    \\n            }\\n        }\\n        List<Integer> result = new LinkedList();\\n        for(int i=0;i<k;i++){\\n            if(count[i] == max){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n//each request will have an end time , we will keep it in sorted order and will remove the \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();//we will keep the available servers in order\\n        int[] count = new int[k];\\n        for(int i=0;i<k;i++){\\n            available.add(i);\\n        }\\n        int max = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b)->Integer.compare(a[1], b[1]));//arr will be 1st param id of server and 2nd be the end time\\n        for(int i=0;i<arrival.length;i++){\\n            while(!pq.isEmpty() && pq.peek()[1] <= arrival[i]) {\\n                int[] arr = pq.remove();\\n                available.add(arr[0]);\\n            }\\n            if(available.contains(i%k)){\\n                available.remove(i%k);\\n                count[i%k]++;\\n                max = Math.max(max, count[i%k]);\\n                pq.add(new int[]{i%k, arrival[i]+load[i]});\\n            } else if(available.size() > 0){\\n                Integer next = available.higher(i%k) != null?available.higher(i%k):available.first();\\n                available.remove(next);\\n                count[next]++;\\n                max = Math.max(max, count[next]);\\n                pq.add(new int[]{next, arrival[i]+load[i]});    \\n            }\\n        }\\n        List<Integer> result = new LinkedList();\\n        for(int i=0;i<k;i++){\\n            if(count[i] == max){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n//each request will have an end time , we will keep it in sorted order and will remove the \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523922,
                "title": "python-brute-force-using-sortedset-4258-ms-50-1-mb",
                "content": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def busiestServers(self, k, arrival, load):\\n        \"\"\"\\n        :type k: int\\n        :type arrival: List[int]\\n        :type load: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        servers = list()\\n        emptyServers = SortedSet()\\n        handledRequestsCounter = list()\\n        for i in range(k):\\n            # initialise servers, each server (i.e. inner lists), if not empty,\\n            # should contain 2 values; request ID & enteredTime (time upon the request entered the server)\\n            servers.append([])\\n            \\n            # initialise emptyServers; all servers should be in emptyServers at the start\\n            emptyServers.add(i)\\n            \\n            # initialise handledRequestsCounter;\\n            # counts the number of requests each server has handled\\n            handledRequestsCounter.append(0)\\n        \\n        # initialise lastProcessedRequest\\n        # contains last known successful request\\n        lastProcessedRequest = None\\n\\n        processingRequests = dict()\\n\\n        # create timeSet to collate timings\\n        timeSet = set()\\n        for i, arrivalTime in enumerate(arrival):\\n            # add time upon requests will arrive at server\\n            timeSet.add(arrivalTime)\\n\\n            # add time upon requests should leave server\\n            timeSet.add(arrivalTime + load[i])\\n\\n        # create timeList for time to loop over\\n        timeList = sorted(timeSet)\\n        \\n        for time in timeList:\\n            # clear server and update handledRequestsCounter if load time is completed\\n            if time in processingRequests:\\n                for server in processingRequests[time]:\\n                    handledRequestsCounter[server] += 1\\n                    del servers[server][:]\\n                    emptyServers.add(server)\\n                else:\\n                    processingRequests.pop(time)\\n                    \\n            # move on to the next request after the last known successful request\\n            if lastProcessedRequest is None:\\n                i = 0\\n            else:\\n                i = lastProcessedRequest + 1\\n            \\n            # when all requests have arrived but some requests have not completed load time, move on to next iteration to complete their load time\\n            if i >= len(arrival):\\n                continue\\n\\n            arrivalTime = arrival[i]\\n            \\n            if arrivalTime == time:\\n                # when arrivalTime == time, request tries to enter a server\\n\\n                if len(servers[i%k]) == 0:\\n                    # if (i%k)th server is empty, request will enter this server\\n                    servers[i%k].extend((i, time))\\n                    emptyServers.remove(i%k)\\n                    try:\\n                        processingRequests[arrivalTime + load[i]].append(i%k)\\n                    except KeyError:\\n                        processingRequests[arrivalTime + load[i]] = [i%k]\\n                    # let server = servers[i%k]\\n                    # server[0] is requestID while server[1] is enteredTime\\n\\n                elif len(emptyServers) > 0:\\n                    # if (i%k)th server is occupied,\\n                    # request tries to enter servers after (i%k)th server\\n                    if emptyServers[-1] < i%k:\\n                        server = emptyServers[0]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(0)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n                    else:\\n                        v = emptyServers.bisect_left(i%k)\\n                        server = emptyServers[v]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(v)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n\\n                lastProcessedRequest = i\\n\\n            # if all servers are occupied, request is dropped; nothing will be done with this request\\n            \\n        maximumHandledRequests = max(handledRequestsCounter)\\n        # find all servers with maximumHandledRequests and collate them in busiestServers list\\n        busiestServers = [server for server, n in enumerate(handledRequestsCounter) if n == maximumHandledRequests]\\n\\n        return busiestServers\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def busiestServers(self, k, arrival, load):\\n        \"\"\"\\n        :type k: int\\n        :type arrival: List[int]\\n        :type load: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        servers = list()\\n        emptyServers = SortedSet()\\n        handledRequestsCounter = list()\\n        for i in range(k):\\n            # initialise servers, each server (i.e. inner lists), if not empty,\\n            # should contain 2 values; request ID & enteredTime (time upon the request entered the server)\\n            servers.append([])\\n            \\n            # initialise emptyServers; all servers should be in emptyServers at the start\\n            emptyServers.add(i)\\n            \\n            # initialise handledRequestsCounter;\\n            # counts the number of requests each server has handled\\n            handledRequestsCounter.append(0)\\n        \\n        # initialise lastProcessedRequest\\n        # contains last known successful request\\n        lastProcessedRequest = None\\n\\n        processingRequests = dict()\\n\\n        # create timeSet to collate timings\\n        timeSet = set()\\n        for i, arrivalTime in enumerate(arrival):\\n            # add time upon requests will arrive at server\\n            timeSet.add(arrivalTime)\\n\\n            # add time upon requests should leave server\\n            timeSet.add(arrivalTime + load[i])\\n\\n        # create timeList for time to loop over\\n        timeList = sorted(timeSet)\\n        \\n        for time in timeList:\\n            # clear server and update handledRequestsCounter if load time is completed\\n            if time in processingRequests:\\n                for server in processingRequests[time]:\\n                    handledRequestsCounter[server] += 1\\n                    del servers[server][:]\\n                    emptyServers.add(server)\\n                else:\\n                    processingRequests.pop(time)\\n                    \\n            # move on to the next request after the last known successful request\\n            if lastProcessedRequest is None:\\n                i = 0\\n            else:\\n                i = lastProcessedRequest + 1\\n            \\n            # when all requests have arrived but some requests have not completed load time, move on to next iteration to complete their load time\\n            if i >= len(arrival):\\n                continue\\n\\n            arrivalTime = arrival[i]\\n            \\n            if arrivalTime == time:\\n                # when arrivalTime == time, request tries to enter a server\\n\\n                if len(servers[i%k]) == 0:\\n                    # if (i%k)th server is empty, request will enter this server\\n                    servers[i%k].extend((i, time))\\n                    emptyServers.remove(i%k)\\n                    try:\\n                        processingRequests[arrivalTime + load[i]].append(i%k)\\n                    except KeyError:\\n                        processingRequests[arrivalTime + load[i]] = [i%k]\\n                    # let server = servers[i%k]\\n                    # server[0] is requestID while server[1] is enteredTime\\n\\n                elif len(emptyServers) > 0:\\n                    # if (i%k)th server is occupied,\\n                    # request tries to enter servers after (i%k)th server\\n                    if emptyServers[-1] < i%k:\\n                        server = emptyServers[0]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(0)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n                    else:\\n                        v = emptyServers.bisect_left(i%k)\\n                        server = emptyServers[v]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(v)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n\\n                lastProcessedRequest = i\\n\\n            # if all servers are occupied, request is dropped; nothing will be done with this request\\n            \\n        maximumHandledRequests = max(handledRequestsCounter)\\n        # find all servers with maximumHandledRequests and collate them in busiestServers list\\n        busiestServers = [server for server, n in enumerate(handledRequestsCounter) if n == maximumHandledRequests]\\n\\n        return busiestServers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521733,
                "title": "java-solution-101ms-100-time-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        //trivial case\\n        if (k >= arrival.length){\\n            for (int i = 0; i < arrival.length; ++i){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        \\n        //set time to arrival[0]\\n        int time = arrival[0];\\n        TreeSet<Integer> freeIndexSet = new TreeSet<>();\\n        int[] taskCount = new int[k];\\n        PriorityQueue<int[]> nextFree = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int i = 0;\\n        for (; i < k; ++i){\\n            nextFree.offer(new int[]{i, arrival[i] + load[i]});\\n        }\\n        \\n        \\n        //for each index in arrival\\n        for (; i < arrival.length; ++i){\\n            //move time to arrival[i]\\n            time = arrival[i];\\n            \\n            //remove from nextFree if servers become free, add to freeset\\n            while (!nextFree.isEmpty() && nextFree.peek()[1] <= time){\\n                freeIndexSet.add(nextFree.poll()[0]);\\n            }\\n            \\n            //try to assign task with load\\n            if (nextFree.size() < k){\\n                //if successful, add to count of server task\\n                int index = i % k;\\n\\n                Integer higherIndex = freeIndexSet.ceiling(index);\\n                if (higherIndex != null){\\n                    index = higherIndex.intValue();\\n                }\\n\\n                else {\\n                    index = freeIndexSet.ceiling(0).intValue();\\n                }\\n                \\n                ++taskCount[index];\\n                nextFree.offer(new int[] {index, time + load[i]});\\n                freeIndexSet.remove(index);\\n            }\\n        }\\n        \\n        //find servers with most arrivals\\n        int max = 0;\\n        for (int j = 0; j < k; ++j){\\n            max = Math.max(max, taskCount[j]);\\n        }\\n        \\n        for (int j = 0; j < k; ++j){\\n            if (max == taskCount[j]){\\n                result.add(j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        //trivial case\\n        if (k >= arrival.length){\\n            for (int i = 0; i < arrival.length; ++i){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        \\n        //set time to arrival[0]\\n        int time = arrival[0];\\n        TreeSet<Integer> freeIndexSet = new TreeSet<>();\\n        int[] taskCount = new int[k];\\n        PriorityQueue<int[]> nextFree = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int i = 0;\\n        for (; i < k; ++i){\\n            nextFree.offer(new int[]{i, arrival[i] + load[i]});\\n        }\\n        \\n        \\n        //for each index in arrival\\n        for (; i < arrival.length; ++i){\\n            //move time to arrival[i]\\n            time = arrival[i];\\n            \\n            //remove from nextFree if servers become free, add to freeset\\n            while (!nextFree.isEmpty() && nextFree.peek()[1] <= time){\\n                freeIndexSet.add(nextFree.poll()[0]);\\n            }\\n            \\n            //try to assign task with load\\n            if (nextFree.size() < k){\\n                //if successful, add to count of server task\\n                int index = i % k;\\n\\n                Integer higherIndex = freeIndexSet.ceiling(index);\\n                if (higherIndex != null){\\n                    index = higherIndex.intValue();\\n                }\\n\\n                else {\\n                    index = freeIndexSet.ceiling(0).intValue();\\n                }\\n                \\n                ++taskCount[index];\\n                nextFree.offer(new int[] {index, time + load[i]});\\n                freeIndexSet.remove(index);\\n            }\\n        }\\n        \\n        //find servers with most arrivals\\n        int max = 0;\\n        for (int j = 0; j < k; ++j){\\n            max = Math.max(max, taskCount[j]);\\n        }\\n        \\n        for (int j = 0; j < k; ++j){\\n            if (max == taskCount[j]){\\n                result.add(j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518932,
                "title": "java-solution-with-explanation-map-treeset-heap",
                "content": "```\\n/**\\n    *   Keep a min heap for request-endTime sorted on endTime\\n    *   keep all available servers in treeset (for faster get of ceiling values)\\n    *   for every time remove completed requests from the heap\\n    *   then take next available server from set\\n    *   keep counting freq for each server\\n    *   at last, create result by iterating over freq map for max freq servers\\n    */\\n    \\n    // O(k + n*k*logk)\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // [time, server]\\n        TreeSet<Integer> servers = new TreeSet<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i < k; i++) servers.add(i); // O(k)\\n        \\n        for(int i = 0; i < arrival.length; i++) { // O(n)\\n            int t = arrival[i];\\n            while(!pq.isEmpty() && pq.peek()[0] <= t) servers.add(pq.poll()[1]); // O(klogk)\\n            \\n            if(servers.size() == 0) continue;\\n            Integer s = servers.ceiling(i%k);\\n            if(s == null) s = servers.first();\\n            servers.remove(s);\\n            \\n            freq.put(s, freq.getOrDefault(s, 0) + 1);\\n            max = Math.max(max, freq.get(s));\\n            pq.add(new int[] {t + load[i], s});\\n        }\\n                \\n        List<Integer> res = new ArrayList<>();\\n        for(int r: freq.keySet()) {\\n            if(max == freq.get(r)) res.add(r);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n    *   Keep a min heap for request-endTime sorted on endTime\\n    *   keep all available servers in treeset (for faster get of ceiling values)\\n    *   for every time remove completed requests from the heap\\n    *   then take next available server from set\\n    *   keep counting freq for each server\\n    *   at last, create result by iterating over freq map for max freq servers\\n    */\\n    \\n    // O(k + n*k*logk)\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // [time, server]\\n        TreeSet<Integer> servers = new TreeSet<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i < k; i++) servers.add(i); // O(k)\\n        \\n        for(int i = 0; i < arrival.length; i++) { // O(n)\\n            int t = arrival[i];\\n            while(!pq.isEmpty() && pq.peek()[0] <= t) servers.add(pq.poll()[1]); // O(klogk)\\n            \\n            if(servers.size() == 0) continue;\\n            Integer s = servers.ceiling(i%k);\\n            if(s == null) s = servers.first();\\n            servers.remove(s);\\n            \\n            freq.put(s, freq.getOrDefault(s, 0) + 1);\\n            max = Math.max(max, freq.get(s));\\n            pq.add(new int[] {t + load[i], s});\\n        }\\n                \\n        List<Integer> res = new ArrayList<>();\\n        for(int r: freq.keySet()) {\\n            if(max == freq.get(r)) res.add(r);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506300,
                "title": "c-set-priority-queue-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int maxReq = 0;\\n        set<int> availableServers;\\n        unordered_map<int,int>serverToReqCount;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                auto cur = pq.top();\\n                pq.pop();\\n                availableServers.insert(cur.second);\\n            }\\n            \\n            if(!availableServers.size())\\n                continue;\\n            \\n            int serverId = i % k;\\n            \\n            set<int>::iterator itr = availableServers.lower_bound(serverId);\\n            \\n            if(itr == availableServers.end()){\\n               itr = availableServers.begin();\\n            }\\n            \\n            serverToReqCount[*itr]++;\\n            maxReq= max(maxReq, serverToReqCount[*itr]);\\n            pq.push({end, *itr});\\n            \\n            availableServers.erase(itr);\\n  \\n        }\\n        \\n        vector<int>ans;\\n        \\n        for(auto p: serverToReqCount){\\n            if(p.second == maxReq)\\n                ans.push_back(p.first);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int maxReq = 0;\\n        set<int> availableServers;\\n        unordered_map<int,int>serverToReqCount;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                auto cur = pq.top();\\n                pq.pop();\\n                availableServers.insert(cur.second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2461960,
                "title": "java-priorityqueue-treeset",
                "content": "It is just another two heap technique. O(NlgK) time complexity\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        PriorityQueue<int[]> busy = new PriorityQueue<>(Comparator.comparing(e -> e[1]));\\n        TreeSet<Integer> avail = new TreeSet<>();\\n        int len = arrival.length;\\n        for(int i = 0; i < k; i++) {\\n            busy.add(new int[]{i, 0});\\n        }\\n        \\n        for(int i = 0; i < len; i++) {\\n            int time = arrival[i];\\n            int override = time + load[i];\\n            while(!busy.isEmpty() && busy.peek()[1] <= time) {\\n                avail.add(busy.poll()[0]);\\n            }\\n            if(avail.isEmpty()) continue;\\n            Integer find = avail.ceiling(i % k);\\n            if(find == null) find = avail.first();\\n            cnt[find]++;\\n            busy.add(new int[]{find, override});\\n            avail.remove(find);\\n        }\\n        \\n        List<Integer> ans = new LinkedList<>();\\n        int max = cnt[0];\\n        for(int i = 0; i < k; i++) {\\n            if(cnt[i] == max) {\\n                ans.add(i);\\n            }\\n            else if(cnt[i] > max) {\\n                max = cnt[i];\\n                ans.clear();\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        PriorityQueue<int[]> busy = new PriorityQueue<>(Comparator.comparing(e -> e[1]));\\n        TreeSet<Integer> avail = new TreeSet<>();\\n        int len = arrival.length;\\n        for(int i = 0; i < k; i++) {\\n            busy.add(new int[]{i, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2444915,
                "title": "c-multimap-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available_servers;\\n        multimap<int,int> next_free_servers;\\n        vector<int> res;\\n \\t    vector<int> top_servers(k, 0);\\n \\n        for(int i = 0; i < k; ++i)\\n\\t\\t    available_servers.insert(i);\\n\\n\\t    for(int i = 0; i < arrival.size(); ++i) {\\n\\t\\t    int exec_time = arrival[i] + load[i];\\n            \\n            for(it = next_free_servers.begin(); it != next_free_servers.end(); ++it) {\\n                if(it->first > arrival[i])\\n                    break;\\n                available_servers.insert(it->second);\\n            }\\n            next_free_servers.erase(next_free_servers.begin(), it);\\n           \\n            if(!available_servers.size())\\n                continue;\\n            \\n            auto exec_server = available_servers.lower_bound(i % k);\\n            if(exec_server == available_servers.end())\\n                exec_server = available_servers.begin();\\n\\n            next_free_servers.insert(make_pair(exec_time, *exec_server));\\n            ++top_servers[*exec_server];\\n            available_servers.erase(exec_server);\\n        }\\n         \\n        int max_handled_server = *max_element(top_servers.begin(), top_servers.end());\\n        for(int i = 0; i < top_servers.size(); ++i) {\\n            if(top_servers[i] == max_handled_server)\\n                res.emplace_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available_servers;\\n        multimap<int,int> next_free_servers;\\n        vector<int> res;\\n \\t    vector<int> top_servers(k, 0);\\n \\n        for(int i = 0; i < k; ++i)\\n\\t\\t    available_servers.insert(i);\\n\\n\\t    for(int i = 0; i < arrival.size(); ++i) {\\n\\t\\t    int exec_time = arrival[i] + load[i];\\n            \\n            for(it = next_free_servers.begin(); it != next_free_servers.end(); ++it) {\\n                if(it->first > arrival[i])\\n                    break;\\n                available_servers.insert(it->second);\\n            }\\n            next_free_servers.erase(next_free_servers.begin(), it);\\n           \\n            if(!available_servers.size())\\n                continue;\\n            \\n            auto exec_server = available_servers.lower_bound(i % k);\\n            if(exec_server == available_servers.end())\\n                exec_server = available_servers.begin();\\n\\n            next_free_servers.insert(make_pair(exec_time, *exec_server));\\n            ++top_servers[*exec_server];\\n            available_servers.erase(exec_server);\\n        }\\n         \\n        int max_handled_server = *max_element(top_servers.begin(), top_servers.end());\\n        for(int i = 0; i < top_servers.size(); ++i) {\\n            if(top_servers[i] == max_handled_server)\\n                res.emplace_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437691,
                "title": "python-priority-queue-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        available = list(range(k)) \\n        busy = [] \\n        result = [0] * k\\n        \\n        for index, come in enumerate(arrival):\\n            while busy and busy[0][0] <= come: \\n                _, free = heapq.heappop(busy)\\n                heapq.heappush(available, index + (free - index) % k) \\n            if available: \\n                assigned = heapq.heappop(available) % k\\n                heapq.heappush(busy, (come + load[index], assigned))\\n                result[assigned] += 1\\n        \\n        Max = max(result)\\n        return [i for i in range(k) if result[i] == Max]\\n    \\n    \"\"\"\\n    Maintan two priority queues. AVAILABLE and BUSY. \\n    Take for example, input as k = 3; arrival = [1,2,3,4,5]; load = [5,2,3,3,3]\\n    Initialize AVAILABLE with (0, 1, 2).\\n    Push the servers into BUSY when tasks are assigned. \\n    In this example, you assign 0th item to server 0 (0 % 3).\\n    1st item to server 1 (1 % 3).\\n    2nd item to server 2 (2 % 3).\\n    At this stage, AVAILABLE is empty. BUSY = [(4, 1), (6, 0), (6, 1)]\\n    When you are inserting 3rd item with load 3, you need to assign it to \\n    (3 % 3) = 0th server. However, you can pop ony 1st server at this time. So, you\\n    have to assign it to first server.\\n    The expression, index + (free - index) % k does this.\\n    Here, index = 3. free = 1. index + (free - index) % 3 = 3 + (-2) % 3.\\n    That is, 3 + 1 = 4.\\n    This 4 is pulled out the the priority queue as 4 % 3 = 1.\\n    That is , we are saying server 0 is busy, add it one. \\n    This is exacly what the expression index + (free - index) % k does.\\n    \\n    Now, assume even 1 was not available, and server 2 is available. \\n    index = 3. free = 2. index + (free - index) % k = 3 + (2 - 3) % 3\\n    3 + (-1) % 3 = 3 + 2 = 5.\\n    When you pull this 5 out of the queue, you do 5 % 3 = 2. \\n    That is, you are adding the task to server 2.\\n    \\n    \"\"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        available = list(range(k)) \\n        busy = [] \\n        result = [0] * k\\n        \\n        for index, come in enumerate(arrival):\\n            while busy and busy[0][0] <= come: \\n                _, free = heapq.heappop(busy)\\n                heapq.heappush(available, index + (free - index) % k) \\n            if available: \\n                assigned = heapq.heappop(available) % k\\n                heapq.heappush(busy, (come + load[index], assigned))\\n                result[assigned] += 1\\n        \\n        Max = max(result)\\n        return [i for i in range(k) if result[i] == Max]\\n    \\n    \"\"\"\\n    Maintan two priority queues. AVAILABLE and BUSY. \\n    Take for example, input as k = 3; arrival = [1,2,3,4,5]; load = [5,2,3,3,3]\\n    Initialize AVAILABLE with (0, 1, 2).\\n    Push the servers into BUSY when tasks are assigned. \\n    In this example, you assign 0th item to server 0 (0 % 3).\\n    1st item to server 1 (1 % 3).\\n    2nd item to server 2 (2 % 3).\\n    At this stage, AVAILABLE is empty. BUSY = [(4, 1), (6, 0), (6, 1)]\\n    When you are inserting 3rd item with load 3, you need to assign it to \\n    (3 % 3) = 0th server. However, you can pop ony 1st server at this time. So, you\\n    have to assign it to first server.\\n    The expression, index + (free - index) % k does this.\\n    Here, index = 3. free = 1. index + (free - index) % 3 = 3 + (-2) % 3.\\n    That is, 3 + 1 = 4.\\n    This 4 is pulled out the the priority queue as 4 % 3 = 1.\\n    That is , we are saying server 0 is busy, add it one. \\n    This is exacly what the expression index + (free - index) % k does.\\n    \\n    Now, assume even 1 was not available, and server 2 is available. \\n    index = 3. free = 2. index + (free - index) % k = 3 + (2 - 3) % 3\\n    3 + (-1) % 3 = 3 + 2 = 5.\\n    When you pull this 5 out of the queue, you do 5 % 3 = 2. \\n    That is, you are adding the task to server 2.\\n    \\n    \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435047,
                "title": "python-consider-start-and-end-of-request-as-an-event-and-process-stream-of-events",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        free, processing, reqs = SortedList(range(k)), {}, [0] * k\\n        mx = 0       \\n        for t, tp, i in sorted(e for i, (r, t) in enumerate(zip(arrival, load)) for e in [(r, \\'S\\', i), (r+t, \\'E\\', i)]):\\n            if tp == \\'S\\': # Start of request\\n                if free:\\n                    sn = free.pop(free.bisect_left(i%k) % len(free))\\n                    processing[i] = sn\\n                    reqs[sn] += 1\\n                    mx = max(reqs[sn], mx)\\n                \\n            else: # End of request\\n                if i in processing:\\n                    sn = processing[i]\\n                    del processing[i]\\n                    free.add(sn)\\n    \\n        return [s for s, r in enumerate(reqs) if r == mx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        free, processing, reqs = SortedList(range(k)), {}, [0] * k\\n        mx = 0       \\n        for t, tp, i in sorted(e for i, (r, t) in enumerate(zip(arrival, load)) for e in [(r, \\'S\\', i), (r+t, \\'E\\', i)]):\\n            if tp == \\'S\\': # Start of request\\n                if free:\\n                    sn = free.pop(free.bisect_left(i%k) % len(free))\\n                    processing[i] = sn\\n                    reqs[sn] += 1\\n                    mx = max(reqs[sn], mx)\\n                \\n            else: # End of request\\n                if i in processing:\\n                    sn = processing[i]\\n                    del processing[i]\\n                    free.add(sn)\\n    \\n        return [s for s, r in enumerate(reqs) if r == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396274,
                "title": "c-set-and-priority-queue",
                "content": "We keep track of the busy servers in a priority queue and the ready servers in a set.\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> requests_handled(k, 0);\\n        // busy_servers is pq<pair<next avail time, server>>\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy_servers;\\n        set<int> ready_servers;\\n        for (int i = 0; i < k; ++i) {\\n            ready_servers.insert(i);\\n        }\\n        for (int i = 0; i < arrival.size(); ++i) {\\n            while (!busy_servers.empty() && busy_servers.top().first <= arrival[i]) {\\n                ready_servers.insert(busy_servers.top().second);\\n                busy_servers.pop();\\n            }\\n            if (ready_servers.empty()) continue;\\n            auto iter = ready_servers.lower_bound(i % k);\\n            if (iter == ready_servers.end()) {\\n                iter = ready_servers.begin();\\n            }\\n            ++requests_handled[*iter];\\n            busy_servers.push(make_pair(arrival[i] + load[i], *iter));\\n            ready_servers.erase(iter);\\n        }\\n        vector<int> busiest_servers;\\n        int max_requests = *max_element(requests_handled.begin(), requests_handled.end());\\n        for (int i = 0; i < k; ++i) {\\n            if (requests_handled[i] == max_requests) {\\n                busiest_servers.push_back(i);\\n            }\\n        }\\n        return busiest_servers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> requests_handled(k, 0);\\n        // busy_servers is pq<pair<next avail time, server>>\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy_servers;\\n        set<int> ready_servers;\\n        for (int i = 0; i < k; ++i) {\\n            ready_servers.insert(i);\\n        }\\n        for (int i = 0; i < arrival.size(); ++i) {\\n            while (!busy_servers.empty() && busy_servers.top().first <= arrival[i]) {\\n                ready_servers.insert(busy_servers.top().second);\\n                busy_servers.pop();\\n            }\\n            if (ready_servers.empty()) continue;\\n            auto iter = ready_servers.lower_bound(i % k);\\n            if (iter == ready_servers.end()) {\\n                iter = ready_servers.begin();\\n            }\\n            ++requests_handled[*iter];\\n            busy_servers.push(make_pair(arrival[i] + load[i], *iter));\\n            ready_servers.erase(iter);\\n        }\\n        vector<int> busiest_servers;\\n        int max_requests = *max_element(requests_handled.begin(), requests_handled.end());\\n        for (int i = 0; i < k; ++i) {\\n            if (requests_handled[i] == max_requests) {\\n                busiest_servers.push_back(i);\\n            }\\n        }\\n        return busiest_servers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394558,
                "title": "java-treeset-heap-0-nlogn",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //arrival are sorted until that arrival get all the free servers\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        //id - end time\\n        \\n        int[]serve=new int[k];\\n        TreeSet<Integer>set=new TreeSet<>();\\n        \\n        for(int i=0;i<k;i++)set.add(i);\\n        \\n        int maxf=0;\\n            \\n        for(int i=0;i<arrival.length;i++){\\n            while(pq.size()>0 && pq.peek()[1] <= arrival[i])\\n                  set.add(pq.remove()[0]); //that server is now free to use\\n        \\n            int m=i%k;\\n            Integer ceil1=set.ceiling(m);\\n            Integer ceil2=set.ceiling(0);\\n            \\n           //System.out.println(ceil1+\" \"+ceil2);\\n            \\n            if(ceil1!=null){\\n                serve[ceil1]++;\\n                maxf=Math.max(maxf,serve[ceil1]);\\n                set.remove(ceil1);\\n                \\n                pq.add(new int[]{ceil1,arrival[i]+load[i]});\\n            }else if(ceil2!=null){\\n                serve[ceil2]++;\\n                maxf=Math.max(maxf,serve[ceil2]);\\n                set.remove(ceil2);\\n                \\n                pq.add(new int[]{ceil2,arrival[i]+load[i]});\\n            }\\n        }\\n        \\n        List<Integer>l=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n            if(serve[i]==maxf)l.add(i);\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //arrival are sorted until that arrival get all the free servers\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        //id - end time\\n        \\n        int[]serve=new int[k];\\n        TreeSet<Integer>set=new TreeSet<>();\\n        \\n        for(int i=0;i<k;i++)set.add(i);\\n        \\n        int maxf=0;\\n            \\n        for(int i=0;i<arrival.length;i++){\\n            while(pq.size()>0 && pq.peek()[1] <= arrival[i])\\n                  set.add(pq.remove()[0]); //that server is now free to use\\n        \\n            int m=i%k;\\n            Integer ceil1=set.ceiling(m);\\n            Integer ceil2=set.ceiling(0);\\n            \\n           //System.out.println(ceil1+\" \"+ceil2);\\n            \\n            if(ceil1!=null){\\n                serve[ceil1]++;\\n                maxf=Math.max(maxf,serve[ceil1]);\\n                set.remove(ceil1);\\n                \\n                pq.add(new int[]{ceil1,arrival[i]+load[i]});\\n            }else if(ceil2!=null){\\n                serve[ceil2]++;\\n                maxf=Math.max(maxf,serve[ceil2]);\\n                set.remove(ceil2);\\n                \\n                pq.add(new int[]{ceil2,arrival[i]+load[i]});\\n            }\\n        }\\n        \\n        List<Integer>l=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n            if(serve[i]==maxf)l.add(i);\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370859,
                "title": "nlogk-sweep-line-pq",
                "content": "1- maintain end time (X) in priority queue \\n2- scan through arrivals times\\n3- pop heap for all the events before time\\n4- binary look for the free server\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for(int idx=0; idx < k; ++idx) free.add(idx);\\n        int [] perf = new int[k];\\n        int max = 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((u, v) -> {\\n            int cmp = Integer.compare(u[0], v[0]);\\n            if(cmp != 0) return cmp;\\n            return Integer.compare(u[1], v[1]);\\n        });\\n        \\n        for(int idx=0; idx < arrival.length; ++idx) {\\n            int time = arrival[idx];\\n            //sweep out end times\\n            while(!pq.isEmpty() && pq.peek()[0] <= time) {\\n                free.add(pq.peek()[1]);\\n                pq.poll();\\n            }\\n            \\n            //~ drop req\\n            if(pq.size() == k) continue;\\n            \\n            //~ guaranteed that at least one server is free \\n            Integer srv = idx%k;\\n            srv = free.ceiling(srv);\\n            if(srv == null) srv = free.first();\\n            \\n            free.remove(srv);\\n            pq.add(new int[]{time+load[idx], srv});\\n            perf[srv] += 1;\\n            max = Math.max(perf[srv], max);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for(int idx=0; idx < k; ++idx)  if(perf[idx] == max) res.add(idx);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for(int idx=0; idx < k; ++idx) free.add(idx);\\n        int [] perf = new int[k];\\n        int max = 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((u, v) -> {\\n            int cmp = Integer.compare(u[0], v[0]);\\n            if(cmp != 0) return cmp;\\n            return Integer.compare(u[1], v[1]);\\n        });\\n        \\n        for(int idx=0; idx < arrival.length; ++idx) {\\n            int time = arrival[idx];\\n            //sweep out end times\\n            while(!pq.isEmpty() && pq.peek()[0] <= time) {\\n                free.add(pq.peek()[1]);\\n                pq.poll();\\n            }\\n            \\n            //~ drop req\\n            if(pq.size() == k) continue;\\n            \\n            //~ guaranteed that at least one server is free \\n            Integer srv = idx%k;\\n            srv = free.ceiling(srv);\\n            if(srv == null) srv = free.first();\\n            \\n            free.remove(srv);\\n            pq.add(new int[]{time+load[idx], srv});\\n            perf[srv] += 1;\\n            max = Math.max(perf[srv], max);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for(int idx=0; idx < k; ++idx)  if(perf[idx] == max) res.add(idx);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282388,
                "title": "java-priority-queue-treeset-oo",
                "content": "**Explanation**\\n1. What you have in hand is the list of available servers\\n2. adding each process to the min heap with end time (arrival + load) and allocated server\\n3. before adding, make sure you remove the process which is complete, and those servers to the available servers list.\\n4. Keep track of the max variable of utilized server.\\n5. get the result.\\n\\n**if you like the solution, please upvote!**\\n\\n```\\nclass Solution {\\n    static class Process {\\n        int end, server;\\n        Process(int end, int server) {\\n            this.end = end;\\n            this.server = server;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Queue<Process> minHeap = new PriorityQueue<Process>((p1, p2) -> Integer.compare(p1.end, p2.end));\\n        \\n        TreeSet<Integer> availableServers = new TreeSet();\\n        for (int server = 0; server < k; server++) {\\n            availableServers.add(server);\\n        }\\n        int requests = arrival.length;\\n        int[] serversUsed = new int[k];\\n        int max = Integer.MIN_VALUE;\\n        for (int request = 0; request < requests; request++) {\\n            while (!minHeap.isEmpty() && minHeap.peek().end <= arrival[request]) {\\n                Process process = minHeap.remove();\\n                availableServers.add(process.server);\\n            }\\n            \\n            if (availableServers.isEmpty()) continue;\\n            Integer nextAvailableServer = availableServers.ceiling(request % k);\\n            if (nextAvailableServer == null) nextAvailableServer = availableServers.first();\\n            minHeap.offer(new Process(arrival[request] + load[request], nextAvailableServer));\\n            serversUsed[nextAvailableServer]++;\\n            max = Math.max(max, serversUsed[nextAvailableServer]);\\n            availableServers.remove(nextAvailableServer);\\n        }\\n        List<Integer> result = new ArrayList();\\n        for (int server = 0; server < k; server++) {\\n            if (serversUsed[server] == max) {\\n                result.add(server);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    static class Process {\\n        int end, server;\\n        Process(int end, int server) {\\n            this.end = end;\\n            this.server = server;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Queue<Process> minHeap = new PriorityQueue<Process>((p1, p2) -> Integer.compare(p1.end, p2.end));\\n        \\n        TreeSet<Integer> availableServers = new TreeSet();\\n        for (int server = 0; server < k; server++) {\\n            availableServers.add(server);\\n        }\\n        int requests = arrival.length;\\n        int[] serversUsed = new int[k];\\n        int max = Integer.MIN_VALUE;\\n        for (int request = 0; request < requests; request++) {\\n            while (!minHeap.isEmpty() && minHeap.peek().end <= arrival[request]) {\\n                Process process = minHeap.remove();\\n                availableServers.add(process.server);\\n            }\\n            \\n            if (availableServers.isEmpty()) continue;\\n            Integer nextAvailableServer = availableServers.ceiling(request % k);\\n            if (nextAvailableServer == null) nextAvailableServer = availableServers.first();\\n            minHeap.offer(new Process(arrival[request] + load[request], nextAvailableServer));\\n            serversUsed[nextAvailableServer]++;\\n            max = Math.max(max, serversUsed[nextAvailableServer]);\\n            availableServers.remove(nextAvailableServer);\\n        }\\n        List<Integer> result = new ArrayList();\\n        for (int server = 0; server < k; server++) {\\n            if (serversUsed[server] == max) {\\n                result.add(server);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265634,
                "title": "c-priority-queue-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // O((N+K)logk) time, O(K) space\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        busiest = INT_MIN;\\n        this->k = k;\\n        inUse.resize(k,0);\\n        \\n        // O(KlogK) time, O(K) space. Where K is k\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\\n        \\n        // O(N) for outer loop. Where N is the number of requests.\\n        for(int i=0;i<arrival.size();i++)\\n        {\\n            int curTime = arrival[i];\\n            int loadTime = load[i];\\n            \\n            int serverId = -1;\\n            // pop finished requests\\n            while(!pq.empty() && pq.top().first <= curTime)\\n            {\\n                serverId = pq.top().second;\\n                inUse[serverId] = 0;\\n                freeServers.insert(serverId);\\n                pq.pop();\\n            }\\n            \\n            // push current request\\n            // O(logK)\\n            if(pq.empty())\\n            {\\n                serverId = i%k;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }\\n            else if(pq.size() < k)\\n            {\\n                int j = i;\\n                auto iter = freeServers.lower_bound(j%k);\\n                if(iter == freeServers.end())\\n                {\\n                    iter = freeServers.lower_bound(0);\\n                }\\n                \\n                serverId = *iter;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }  \\n        }\\n        \\n        // O(K)\\n        findAns();\\n        return ans;\\n    }\\n    \\nprivate:\\n    int k, busiest;\\n    vector<int> inUse;\\n    vector<int> ans;\\n    set<int> freeServers;\\n    unordered_map<int,int> serverCount; // serverId-> requests handled by this server.\\n    \\n    void findAns()\\n    {\\n        for(const auto& element : serverCount)\\n        {\\n            if(element.second == busiest)\\n                ans.push_back(element.first);\\n        }\\n    }\\n    \\n    void pushRequest(int serverId, int curTime, int loadTime,\\n                     priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>>& pq)\\n    {\\n        inUse[serverId] = 1;\\n        freeServers.erase(serverId);\\n        serverCount[serverId]++;\\n        busiest = max(busiest, serverCount[serverId]);\\n        pq.push( {curTime+loadTime, serverId} );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O((N+K)logk) time, O(K) space\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        busiest = INT_MIN;\\n        this->k = k;\\n        inUse.resize(k,0);\\n        \\n        // O(KlogK) time, O(K) space. Where K is k\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\\n        \\n        // O(N) for outer loop. Where N is the number of requests.\\n        for(int i=0;i<arrival.size();i++)\\n        {\\n            int curTime = arrival[i];\\n            int loadTime = load[i];\\n            \\n            int serverId = -1;\\n            // pop finished requests\\n            while(!pq.empty() && pq.top().first <= curTime)\\n            {\\n                serverId = pq.top().second;\\n                inUse[serverId] = 0;\\n                freeServers.insert(serverId);\\n                pq.pop();\\n            }\\n            \\n            // push current request\\n            // O(logK)\\n            if(pq.empty())\\n            {\\n                serverId = i%k;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }\\n            else if(pq.size() < k)\\n            {\\n                int j = i;\\n                auto iter = freeServers.lower_bound(j%k);\\n                if(iter == freeServers.end())\\n                {\\n                    iter = freeServers.lower_bound(0);\\n                }\\n                \\n                serverId = *iter;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }  \\n        }\\n        \\n        // O(K)\\n        findAns();\\n        return ans;\\n    }\\n    \\nprivate:\\n    int k, busiest;\\n    vector<int> inUse;\\n    vector<int> ans;\\n    set<int> freeServers;\\n    unordered_map<int,int> serverCount; // serverId-> requests handled by this server.\\n    \\n    void findAns()\\n    {\\n        for(const auto& element : serverCount)\\n        {\\n            if(element.second == busiest)\\n                ans.push_back(element.first);\\n        }\\n    }\\n    \\n    void pushRequest(int serverId, int curTime, int loadTime,\\n                     priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>>& pq)\\n    {\\n        inUse[serverId] = 1;\\n        freeServers.erase(serverId);\\n        serverCount[serverId]++;\\n        busiest = max(busiest, serverCount[serverId]);\\n        pq.push( {curTime+loadTime, serverId} );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240266,
                "title": "c-set-map",
                "content": "* `free` maintains the servers which are free to take up requests.\\n\\n* `busy` includes the pairs of  [time it takes to finish the assigned task, server].\\n\\n* The Tricky part is while iterating in `arrivals` , we check for the lower_bound of index `i%k` in `free` , that will automatically ensure that next free server picked. \\n```\\nclass Solution {\\npublic:\\n    set<int> free ;\\n    set<pair<int,int>> busy ; // finish_time , id\\n    map<int,int> mpp ;\\n    int maxi  = 0 ;\\n    vector<int> ans ;\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        for(int i = 0 ; i < k ; ++i) free.insert(i) , free.insert(i + k) ;\\n        \\n        for(int i = 0 ; i < arrival.size() ; ++i ){\\n            while(busy.size() and arrival[i] >= begin(busy)->first){\\n                free.insert(begin(busy)->second % k) ;\\n                free.insert(begin(busy)->second % k + k) ;\\n                busy.erase(begin(busy));\\n            }\\n            if(free.empty()) continue ;\\n            \\n            int server = (*free.lower_bound(i%k)) % k ; \\n            free.erase(server) ; free.erase(server + k) ;\\n            busy.insert({arrival[i] + load[i] , server}) ;\\n            ++mpp[server] ; maxi = max(maxi,mpp[server]) ;\\n        }\\n        \\n        for(auto &x : mpp) if(x.second == maxi) ans.push_back(x.first) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> free ;\\n    set<pair<int,int>> busy ; // finish_time , id\\n    map<int,int> mpp ;\\n    int maxi  = 0 ;\\n    vector<int> ans ;\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        for(int i = 0 ; i < k ; ++i) free.insert(i) , free.insert(i + k) ;\\n        \\n        for(int i = 0 ; i < arrival.size() ; ++i ){\\n            while(busy.size() and arrival[i] >= begin(busy)->first){\\n                free.insert(begin(busy)->second % k) ;\\n                free.insert(begin(busy)->second % k + k) ;\\n                busy.erase(begin(busy));\\n            }\\n            if(free.empty()) continue ;\\n            \\n            int server = (*free.lower_bound(i%k)) % k ; \\n            free.erase(server) ; free.erase(server + k) ;\\n            busy.insert({arrival[i] + load[i] , server}) ;\\n            ++mpp[server] ; maxi = max(maxi,mpp[server]) ;\\n        }\\n        \\n        for(auto &x : mpp) if(x.second == maxi) ans.push_back(x.first) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232928,
                "title": "cpp-min-heap-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& load) {\\n        int n=arr.size();\\n        set<int>st;\\n        vector<int>cnt(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<k;i++)pq.push({0,i});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=i%k;\\n            int tme=arr[i];\\n            while(pq.size()>0&&pq.top().first<=tme)\\n            {\\n                st.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            auto idx=st.lower_bound(pos);\\n            if(idx==st.end())\\n            idx=st.lower_bound(0);\\n            if(idx==st.end())continue;\\n            int id=*idx;\\n            pq.push({load[i]+tme,id});\\n            cnt[id]++;\\n            //cout<<id<<\"\\\\n\";\\n            st.erase(idx);\\n        }\\n        int mxm=0;\\n        for(auto&p:cnt)mxm=max(mxm,p);\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){if(cnt[i]==mxm)ans.push_back(i);}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& load) {\\n        int n=arr.size();\\n        set<int>st;\\n        vector<int>cnt(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<k;i++)pq.push({0,i});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=i%k;\\n            int tme=arr[i];\\n            while(pq.size()>0&&pq.top().first<=tme)\\n            {\\n                st.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            auto idx=st.lower_bound(pos);\\n            if(idx==st.end())\\n            idx=st.lower_bound(0);\\n            if(idx==st.end())continue;\\n            int id=*idx;\\n            pq.push({load[i]+tme,id});\\n            cnt[id]++;\\n            //cout<<id<<\"\\\\n\";\\n            st.erase(idx);\\n        }\\n        int mxm=0;\\n        for(auto&p:cnt)mxm=max(mxm,p);\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){if(cnt[i]==mxm)ans.push_back(i);}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2230313,
                "title": "c-heap-set-easy-solution-faster-than-83",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>avalServers;\\n        for(int i=0; i<k; i++){\\n            avalServers.insert(i);\\n        }\\n        int len = arrival.size();\\n        vector<int>taskCount(k,0);\\n        int maxCount = 0;\\n        priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> minH; // {endTime, id}\\n        for(int task = 0; task<len; task++){\\n            int startTime = arrival[task];\\n            retrieveServer(minH, startTime, avalServers);\\n            \\n\\t\\t\\t//find next aval server\\n            if(avalServers.empty()) continue;\\n            auto iter = avalServers.lower_bound(task%k);\\n            if(iter == avalServers.end()) iter=avalServers.begin();\\n            int curServer = *iter;\\n            taskCount[curServer]++;\\n            maxCount = max(maxCount, taskCount[curServer]);\\n            \\n            avalServers.erase(curServer);\\n            minH.push({startTime+load[task], curServer});\\n        }\\n        \\n        vector<int>res;\\n        for(int i=0; i<k; i++){\\n            if(taskCount[i]==maxCount){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void retrieveServer(priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> & minH, int startTime,\\n                       set<int>& avalServers){\\n        while(!minH.empty() && (minH.top().first)<=startTime){\\n            avalServers.insert(minH.top().second);\\n            minH.pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>avalServers;\\n        for(int i=0; i<k; i++){\\n            avalServers.insert(i);\\n        }\\n        int len = arrival.size();\\n        vector<int>taskCount(k,0);\\n        int maxCount = 0;\\n        priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> minH; // {endTime, id}\\n        for(int task = 0; task<len; task++){\\n            int startTime = arrival[task];\\n            retrieveServer(minH, startTime, avalServers);\\n            \\n\\t\\t\\t//find next aval server\\n            if(avalServers.empty()) continue;\\n            auto iter = avalServers.lower_bound(task%k);\\n            if(iter == avalServers.end()) iter=avalServers.begin();\\n            int curServer = *iter;\\n            taskCount[curServer]++;\\n            maxCount = max(maxCount, taskCount[curServer]);\\n            \\n            avalServers.erase(curServer);\\n            minH.push({startTime+load[task], curServer});\\n        }\\n        \\n        vector<int>res;\\n        for(int i=0; i<k; i++){\\n            if(taskCount[i]==maxCount){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void retrieveServer(priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> & minH, int startTime,\\n                       set<int>& avalServers){\\n        while(!minH.empty() && (minH.top().first)<=startTime){\\n            avalServers.insert(minH.top().second);\\n            minH.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219059,
                "title": "balanced-bst-algorithm",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206274,
                "title": "javascript-tle-solution-with-priorityqueue-and-hashset",
                "content": "```\\nvar busiestServers = function(k, arrival, load) {\\n    let loadMap = {};\\n    let pq = new MinPriorityQueue({ compare: (a,b) => a[1] - b[1] });\\n    let availableServers = new Set(new Array(k).fill(0).map((_, index) => index));\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        // calc end time\\n        let end = arrival[i] + load[i];\\n        \\n        // bring server back\\n        while (pq.front()?.[1] <= arrival[i]) {\\n            const [server] = pq.dequeue();\\n            availableServers.add(server);\\n        }\\n        \\n        let server = i % k;\\n        // drop if no available server\\n        if (availableServers.size === 0) continue;\\n        \\n        // find the next avaiable sever\\n        while (!availableServers.has(server)) {\\n            server++;\\n            if (server === k + 1) {\\n                server = 0;\\n            }\\n        }\\n        \\n        // record the load\\n        if (!loadMap[server]) {\\n            loadMap[server] = 0;\\n        }\\n        \\n        loadMap[server]++;\\n        \\n        availableServers.delete(server);\\n        pq.enqueue([server, end]);\\n    }\\n    \\n    let res = [];\\n    let sorted = Object.entries(loadMap).sort((a,b) => b[1] - a[1]);\\n    let max = sorted[0][1];\\n    let i = 0;\\n    while (sorted[i]?.[1] === max) {\\n        res.push(+sorted[i++][0]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar busiestServers = function(k, arrival, load) {\\n    let loadMap = {};\\n    let pq = new MinPriorityQueue({ compare: (a,b) => a[1] - b[1] });\\n    let availableServers = new Set(new Array(k).fill(0).map((_, index) => index));\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        // calc end time\\n        let end = arrival[i] + load[i];\\n        \\n        // bring server back\\n        while (pq.front()?.[1] <= arrival[i]) {\\n            const [server] = pq.dequeue();\\n            availableServers.add(server);\\n        }\\n        \\n        let server = i % k;\\n        // drop if no available server\\n        if (availableServers.size === 0) continue;\\n        \\n        // find the next avaiable sever\\n        while (!availableServers.has(server)) {\\n            server++;\\n            if (server === k + 1) {\\n                server = 0;\\n            }\\n        }\\n        \\n        // record the load\\n        if (!loadMap[server]) {\\n            loadMap[server] = 0;\\n        }\\n        \\n        loadMap[server]++;\\n        \\n        availableServers.delete(server);\\n        pq.enqueue([server, end]);\\n    }\\n    \\n    let res = [];\\n    let sorted = Object.entries(loadMap).sort((a,b) => b[1] - a[1]);\\n    let max = sorted[0][1];\\n    let i = 0;\\n    while (sorted[i]?.[1] === max) {\\n        res.push(+sorted[i++][0]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186916,
                "title": "python-heap-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, x: List[int], y: List[int]) -> List[int]:\\n        z=SortedList([i for i in range(k)])\\n        q=[]\\n        f=defaultdict(int)\\n        l=len(x)\\n        for i in range(l):\\n            while q and q[0][0]<=x[i]:\\n                _,b=heappop(q)\\n                z.add(b)\\n            if not z:continue\\n            index=z.bisect_left(i%k)\\n            if index>=len(z):index=0\\n            heappush(q,(y[i]+x[i],z[index]))\\n            f[z[index]]+=1\\n            del z[index]\\n        ma=max(f.values())\\n        return [i for i in f if f[i]==ma]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, x: List[int], y: List[int]) -> List[int]:\\n        z=SortedList([i for i in range(k)])\\n        q=[]\\n        f=defaultdict(int)\\n        l=len(x)\\n        for i in range(l):\\n            while q and q[0][0]<=x[i]:\\n                _,b=heappop(q)\\n                z.add(b)\\n            if not z:continue\\n            index=z.bisect_left(i%k)\\n            if index>=len(z):index=0\\n            heappush(q,(y[i]+x[i],z[index]))\\n            f[z[index]]+=1\\n            del z[index]\\n        ma=max(f.values())\\n        return [i for i in f if f[i]==ma]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143059,
                "title": "c-priority-queue-ordered-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int i, j;\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int handledReq[k];\\n        int maxServe = 0;\\n        \\n        for(i = 0; i < k; i++){\\n            available.insert(i);\\n            handledReq[i] = 0;\\n        }\\n        \\n        for(i = 0; i < arrival.size(); i++){\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                j = pq.top().second;\\n                available.insert(j);\\n                pq.pop();\\n            }\\n            \\n            j = i % k;\\n            \\n            auto it = available.lower_bound(j);\\n            \\n            if(it == available.end()){\\n                it = available.begin();\\n            }\\n            \\n            if(it != available.end()){\\n                j = *it;\\n           \\n                handledReq[j]++; \\n                maxServe = max(handledReq[j], maxServe);\\n                pq.push(make_pair(arrival[i] + load[i], j));\\n                available.erase(it);\\n            }\\n        }\\n        \\n        vector<int> maxReq;\\n        for(i = 0; i < k; i++){\\n            if(handledReq[i] == maxServe){\\n                maxReq.push_back(i);\\n            }\\n        }\\n        \\n        return maxReq;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int i, j;\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int handledReq[k];\\n        int maxServe = 0;\\n        \\n        for(i = 0; i < k; i++){\\n            available.insert(i);\\n            handledReq[i] = 0;\\n        }\\n        \\n        for(i = 0; i < arrival.size(); i++){\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                j = pq.top().second;\\n                available.insert(j);\\n                pq.pop();\\n            }\\n            \\n            j = i % k;\\n            \\n            auto it = available.lower_bound(j);\\n            \\n            if(it == available.end()){\\n                it = available.begin();\\n            }\\n            \\n            if(it != available.end()){\\n                j = *it;\\n           \\n                handledReq[j]++; \\n                maxServe = max(handledReq[j], maxServe);\\n                pq.push(make_pair(arrival[i] + load[i], j));\\n                available.erase(it);\\n            }\\n        }\\n        \\n        vector<int> maxReq;\\n        for(i = 0; i < k; i++){\\n            if(handledReq[i] == maxServe){\\n                maxReq.push_back(i);\\n            }\\n        }\\n        \\n        return maxReq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133652,
                "title": "python-two-heaps",
                "content": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        available = [i for i in range(k)]\\n        busy = []\\n        res = defaultdict(int)\\n        for i, s in enumerate(arrival):\\n            while busy and busy[0][0] <= s:\\n                heappush(available, i + (heappop(busy)[1]-i) % k)\\n            if available:\\n                j = heappop(available)%k\\n                res[j] += 1\\n                heappush(busy,(s+load[i], j))\\n        busiest = max(res.values())\\n        return [i for i in res if res[i] == busiest ]\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        available = [i for i in range(k)]\\n        busy = []\\n        res = defaultdict(int)\\n        for i, s in enumerate(arrival):\\n            while busy and busy[0][0] <= s:\\n                heappush(available, i + (heappop(busy)[1]-i) % k)\\n            if available:\\n                j = heappop(available)%k\\n                res[j] += 1\\n                heappush(busy,(s+load[i], j))\\n        busiest = max(res.values())\\n        return [i for i in res if res[i] == busiest ]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2106364,
                "title": "don-t-use-set-use-map-for-lower-bound-because-map-s-lower-bound-is-too-must-fast-than-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& load) \\n    {\\n        int cnt[k+1];   memset(cnt,0,sizeof(cnt));\\n        set<pair<int,int>> free;\\n        map<int,bool> avl;\\n        for(int i=0;i<k;i++) \\n            avl.insert({i,1});\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            while(free.size()>0 && (*free.begin()).first<=a[i])\\n                avl.insert({(*free.begin()).second,1}),free.erase(free.begin());\\n            \\n            auto it=avl.lower_bound(i%k);\\n            if(it==avl.end() && avl.size()>0)\\n                it=avl.begin();\\n            if(it!=avl.end())\\n            {\\n                cnt[(*it).first]++;\\n                free.insert({a[i]+load[i],(*it).first});\\n                avl.erase(it);\\n            }\\n        }\\n                           \\n        int mx=0;\\n        for(int i=0;i<k;i++)\\n            mx=max(mx,cnt[i]);\\n        vector<int> ans;\\n        for(int i=0;i<k;i++)\\n            if(cnt[i]==mx)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& load) \\n    {\\n        int cnt[k+1];   memset(cnt,0,sizeof(cnt));\\n        set<pair<int,int>> free;\\n        map<int,bool> avl;\\n        for(int i=0;i<k;i++) \\n            avl.insert({i,1});\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            while(free.size()>0 && (*free.begin()).first<=a[i])\\n                avl.insert({(*free.begin()).second,1}),free.erase(free.begin());\\n            \\n            auto it=avl.lower_bound(i%k);\\n            if(it==avl.end() && avl.size()>0)\\n                it=avl.begin();\\n            if(it!=avl.end())\\n            {\\n                cnt[(*it).first]++;\\n                free.insert({a[i]+load[i],(*it).first});\\n                avl.erase(it);\\n            }\\n        }\\n                           \\n        int mx=0;\\n        for(int i=0;i<k;i++)\\n            mx=max(mx,cnt[i]);\\n        vector<int> ans;\\n        for(int i=0;i<k;i++)\\n            if(cnt[i]==mx)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092247,
                "title": "simple-python-sorted-list",
                "content": "```\\nfrom sortedcontainers import SortedList\\nimport heapq\\nclass Solution:\\n    def do_task(self, idx, stt, end):\\n        while self.busy and self.busy[0][0] <= stt:\\n            s, i = heapq.heappop(self.busy)\\n            self.idle.add(i)\\n        if len(self.idle) == 0:\\n            return\\n        ii = idx % self.k\\n        if self.idle[-1] >= ii:\\n            x = self.idle.bisect_left(ii)\\n        else:\\n            x = 0\\n        i = self.idle.pop(x)\\n        self.ct_map[i] += 1\\n        heapq.heappush(self.busy, (end, i))\\n    \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.k = k\\n        self.idle = SortedList()\\n        for i in range(k):\\n            self.idle.add(i)\\n        self.busy = []\\n        self.ct_map = {i: 0 for i in range(k)}\\n        idx = 0\\n        for stt, ld in zip(arrival, load):\\n            end = stt+ld\\n            self.do_task(idx, stt, end)\\n            idx += 1\\n        \\n        rst = []\\n        bct = 0\\n        for i, ct in self.ct_map.items():\\n            if ct > bct:\\n                bct = ct\\n                rst = [i]\\n            elif ct == bct:\\n                rst.append(i)\\n        return rst\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nimport heapq\\nclass Solution:\\n    def do_task(self, idx, stt, end):\\n        while self.busy and self.busy[0][0] <= stt:\\n            s, i = heapq.heappop(self.busy)\\n            self.idle.add(i)\\n        if len(self.idle) == 0:\\n            return\\n        ii = idx % self.k\\n        if self.idle[-1] >= ii:\\n            x = self.idle.bisect_left(ii)\\n        else:\\n            x = 0\\n        i = self.idle.pop(x)\\n        self.ct_map[i] += 1\\n        heapq.heappush(self.busy, (end, i))\\n    \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.k = k\\n        self.idle = SortedList()\\n        for i in range(k):\\n            self.idle.add(i)\\n        self.busy = []\\n        self.ct_map = {i: 0 for i in range(k)}\\n        idx = 0\\n        for stt, ld in zip(arrival, load):\\n            end = stt+ld\\n            self.do_task(idx, stt, end)\\n            idx += 1\\n        \\n        rst = []\\n        bct = 0\\n        for i, ct in self.ct_map.items():\\n            if ct > bct:\\n                bct = ct\\n                rst = [i]\\n            elif ct == bct:\\n                rst.append(i)\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085094,
                "title": "c-priority-queue-ordered-set",
                "content": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>servers;\\n        unordered_map<int,int>count;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            \\n            while(!pq.empty()  && pq.top().first<=arrival[i]){\\n                auto fr = pq.top();\\n                pq.pop();\\n                servers.insert(fr.second);\\n            }\\n            \\n            if(!servers.size())\\n                continue;\\n            \\n            auto it = servers.lower_bound(i%k);\\n            if(it==servers.end()){\\n                it = servers.begin();\\n            }\\n            int server = *it;\\n            count[server]++;\\n            pq.push({arrival[i]+load[i],server});\\n            servers.erase(it);\\n        }\\n        int mx = 0;\\n        vector<int>ans;\\n        for(auto it :count){\\n            mx = max(mx,it.second);\\n        }\\n        for(auto it : count){\\n            if(it.second==mx){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>servers;\\n        unordered_map<int,int>count;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            \\n            while(!pq.empty()  && pq.top().first<=arrival[i]){\\n                auto fr = pq.top();\\n                pq.pop();\\n                servers.insert(fr.second);\\n            }\\n            \\n            if(!servers.size())\\n                continue;\\n            \\n            auto it = servers.lower_bound(i%k);\\n            if(it==servers.end()){\\n                it = servers.begin();\\n            }\\n            int server = *it;\\n            count[server]++;\\n            pq.push({arrival[i]+load[i],server});\\n            servers.erase(it);\\n        }\\n        int mx = 0;\\n        vector<int>ans;\\n        for(auto it :count){\\n            mx = max(mx,it.second);\\n        }\\n        for(auto it : count){\\n            if(it.second==mx){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041097,
                "title": "java-priorityqueue-treeset-easy-to-understand",
                "content": "Maintain a treeset for all free server ids. Each time, try to get a server id from the treeset by:\\n```\\n\\t\\t\\tint index = i % k;    \\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n```\\n\\nMaintain a min priority queue for server id and end time pair, sort by end time in asending order. Each time, when a new task comes, just free the server from the priority queue if its end time <= task start time.\\n\\n**Code**\\n```\\n   public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        TreeSet<Integer> freeServers = new TreeSet();\\n        int max = 0;\\n        for(int i=0; i<k; i++) {\\n           freeServers.add(i); \\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1])); //server, time\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            int total = start + duration;\\n            \\n            while(!pq.isEmpty() && pq.peek()[1] <= start) {\\n                freeServers.add(pq.poll()[0]);\\n            }\\n            \\n            if(freeServers.isEmpty()) {\\n                continue;\\n            }\\n            \\n            int index = i % k;\\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n            freeServers.remove(serverId);\\n            counts[serverId]++;\\n            max = Math.max(max, counts[serverId]);\\n            pq.offer(new int[]{serverId, total});\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for(int i=0; i<k; i++) {\\n            if(counts[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\tint index = i % k;    \\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n```\n```\\n   public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        TreeSet<Integer> freeServers = new TreeSet();\\n        int max = 0;\\n        for(int i=0; i<k; i++) {\\n           freeServers.add(i); \\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1])); //server, time\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            int total = start + duration;\\n            \\n            while(!pq.isEmpty() && pq.peek()[1] <= start) {\\n                freeServers.add(pq.poll()[0]);\\n            }\\n            \\n            if(freeServers.isEmpty()) {\\n                continue;\\n            }\\n            \\n            int index = i % k;\\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n            freeServers.remove(serverId);\\n            counts[serverId]++;\\n            max = Math.max(max, counts[serverId]);\\n            pq.offer(new int[]{serverId, total});\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for(int i=0; i<k; i++) {\\n            if(counts[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017380,
                "title": "why-this-case-failed",
                "content": "My codes failed on one test case :\\n3\\n[1,2,3,4,8,9,10]\\n[5,2,10,3,1,2,2]\\nI return [0,1] while it expect [1]\\nWhy it failed?\\nLet\\'s market the abve request as [a,b,c,d,e,f,g]\\nIt will be handled like :\\nserver 0: aaaaa--eff-\\nserver 1: -bbddd-gg\\nserver 2:--cccccccccc\\nserver 0  will handle 3 requests arrived on 1,8 and 9\\nserver 1 also handle 3 requests arrive on 2, 4 and 10\\n\\nDid I misunderstood anything?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1995686,
                "title": "python-sortedlist-and-heap",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        completed = [0] * k\\n        tasks = []\\n        available = SortedList(range(k))\\n        greatest = 0\\n        out = []\\n        for i, (t, l) in enumerate(zip(arrival, load)):\\n            while tasks and tasks[0][0] <= t:\\n                _, server = heappop(tasks)\\n                completed[server] += 1\\n                if completed[server] > greatest:\\n                    greatest = completed[server]\\n                    out = [server]\\n                elif completed[server] == greatest:\\n                    out.append(server)\\n                available.add(server)\\n            if len(available) == 0:\\n                continue\\n            server = i % k\\n            index = available.bisect_left(server)\\n            if index == len(available):\\n                index = 0\\n            heappush(tasks, (t + l, available.pop(index)))\\n        while tasks:\\n            _, server = tasks.pop()\\n            completed[server] += 1\\n            if completed[server] > greatest:\\n                greatest = completed[server]\\n                out = [server]\\n            elif completed[server] == greatest:\\n                out.append(server)\\n        return out\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        completed = [0] * k\\n        tasks = []\\n        available = SortedList(range(k))\\n        greatest = 0\\n        out = []\\n        for i, (t, l) in enumerate(zip(arrival, load)):\\n            while tasks and tasks[0][0] <= t:\\n                _, server = heappop(tasks)\\n                completed[server] += 1\\n                if completed[server] > greatest:\\n                    greatest = completed[server]\\n                    out = [server]\\n                elif completed[server] == greatest:\\n                    out.append(server)\\n                available.add(server)\\n            if len(available) == 0:\\n                continue\\n            server = i % k\\n            index = available.bisect_left(server)\\n            if index == len(available):\\n                index = 0\\n            heappush(tasks, (t + l, available.pop(index)))\\n        while tasks:\\n            _, server = tasks.pop()\\n            completed[server] += 1\\n            if completed[server] > greatest:\\n                greatest = completed[server]\\n                out = [server]\\n            elif completed[server] == greatest:\\n                out.append(server)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977192,
                "title": "python-heap-bisect-with-sorted-array-with-explanation-in-comments",
                "content": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        keep track of number of requests served by a server x in requestsCnts array\\n        keep track of availability of server using sorted array,\\n            use python\\'s bisect_left to insert and find available servers in sorted array\\n        keep track of requests completion aka expiry time to server via expiryTimeToServers and, \\n        when time == expiry time, make associated server available.\\n        use a min-heap to get minimum completion times\\n            e.g. heap array [(5, server0)]\\n        At end of serving all requests,\\n        iterate throguh requestsCnts to find busiestServers\\n        \\n        time complexity calc - n = requests, k = servers\\n        We have to iterate each request in for loop - o(n) \\n        - o(logk) - for bringing servers in available state during each arrival of request\\n        - o(logk) - to find next available server\\n        but when we remove a server from available servers list. we take o(k) time and this\\n        in worst case can happen for all requests\\n        so o(n*k) + o(k) = o(n*k)\\n        \\n        memory\\n        o(k) for requestsCnts and availableServers, o(n) for expiryTimeToServer,\\n        \\'\\'\\'\\n        from heapq import heappop, heappush\\n        import bisect\\n        requestsCnts = [0]*k\\n        availableServers = []\\n        for i in range(k):\\n            availableServers.append(i)\\n        expiryTimeToServer = []\\n        \\n        def getFirstAvailableServer(requestIdx):\\n            n = len(availableServers)\\n            if requestIdx > availableServers[n-1]:\\n                serverIdx = availableServers[0]\\n            else:\\n                i = bisect.bisect_left(availableServers, requestIdx)\\n                serverIdx = availableServers[i]\\n            availableServers.remove(serverIdx)\\n            return serverIdx\\n        \\n        def insertAvailableServer(server):\\n            n = len(availableServers)\\n            if n == 0:\\n                availableServers.append(server)\\n                return\\n            i = bisect.bisect_left(availableServers, server)\\n            availableServers.insert(i, server)\\n                \\n        for requestIdx, arrivaltime in enumerate(arrival):\\n            # if server is becoming availble make server available\\n            while len(expiryTimeToServer) > 0:\\n                availabilityTime, server = heappop(expiryTimeToServer)\\n                if availabilityTime > arrivaltime:\\n                    heappush(expiryTimeToServer, (availabilityTime, server))\\n                    break\\n                \\n                #make server available\\n                insertAvailableServer(server)\\n                \\n            if len(availableServers) == 0:\\n                continue\\n                \\n            serverIdx = getFirstAvailableServer(requestIdx%k)\\n            # add no. of request handled by this available server\\n            requestsCnts[serverIdx] += 1\\n            # add request expiry in expiryTimeToServer map\\n            heappush(expiryTimeToServer, (arrivaltime+load[requestIdx], serverIdx))\\n            \\n        # iterate over requestsCnts\\n        maxRequests, busiestServers = 0, []\\n        for i, requests in enumerate(requestsCnts):\\n            if requests > maxRequests:\\n                maxRequests = requests\\n                busiestServers = [i]\\n            elif requests == maxRequests:\\n                busiestServers.append(i)\\n                \\n        return busiestServers\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        keep track of number of requests served by a server x in requestsCnts array\\n        keep track of availability of server using sorted array,\\n            use python\\'s bisect_left to insert and find available servers in sorted array\\n        keep track of requests completion aka expiry time to server via expiryTimeToServers and, \\n        when time == expiry time, make associated server available.\\n        use a min-heap to get minimum completion times\\n            e.g. heap array [(5, server0)]\\n        At end of serving all requests,\\n        iterate throguh requestsCnts to find busiestServers\\n        \\n        time complexity calc - n = requests, k = servers\\n        We have to iterate each request in for loop - o(n) \\n        - o(logk) - for bringing servers in available state during each arrival of request\\n        - o(logk) - to find next available server\\n        but when we remove a server from available servers list. we take o(k) time and this\\n        in worst case can happen for all requests\\n        so o(n*k) + o(k) = o(n*k)\\n        \\n        memory\\n        o(k) for requestsCnts and availableServers, o(n) for expiryTimeToServer,\\n        \\'\\'\\'\\n        from heapq import heappop, heappush\\n        import bisect\\n        requestsCnts = [0]*k\\n        availableServers = []\\n        for i in range(k):\\n            availableServers.append(i)\\n        expiryTimeToServer = []\\n        \\n        def getFirstAvailableServer(requestIdx):\\n            n = len(availableServers)\\n            if requestIdx > availableServers[n-1]:\\n                serverIdx = availableServers[0]\\n            else:\\n                i = bisect.bisect_left(availableServers, requestIdx)\\n                serverIdx = availableServers[i]\\n            availableServers.remove(serverIdx)\\n            return serverIdx\\n        \\n        def insertAvailableServer(server):\\n            n = len(availableServers)\\n            if n == 0:\\n                availableServers.append(server)\\n                return\\n            i = bisect.bisect_left(availableServers, server)\\n            availableServers.insert(i, server)\\n                \\n        for requestIdx, arrivaltime in enumerate(arrival):\\n            # if server is becoming availble make server available\\n            while len(expiryTimeToServer) > 0:\\n                availabilityTime, server = heappop(expiryTimeToServer)\\n                if availabilityTime > arrivaltime:\\n                    heappush(expiryTimeToServer, (availabilityTime, server))\\n                    break\\n                \\n                #make server available\\n                insertAvailableServer(server)\\n                \\n            if len(availableServers) == 0:\\n                continue\\n                \\n            serverIdx = getFirstAvailableServer(requestIdx%k)\\n            # add no. of request handled by this available server\\n            requestsCnts[serverIdx] += 1\\n            # add request expiry in expiryTimeToServer map\\n            heappush(expiryTimeToServer, (arrivaltime+load[requestIdx], serverIdx))\\n            \\n        # iterate over requestsCnts\\n        maxRequests, busiestServers = 0, []\\n        for i, requests in enumerate(requestsCnts):\\n            if requests > maxRequests:\\n                maxRequests = requests\\n                busiestServers = [i]\\n            elif requests == maxRequests:\\n                busiestServers.append(i)\\n                \\n        return busiestServers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927616,
                "title": "c-clean-code",
                "content": "Named all things best to their use. \\nPLease UPVOTE if u like.\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector <array<int, 3>> events;\\n        int n = arrival.size();\\n        for (int i = 0; i < n; ++i) {\\n            events.push_back({arrival[i], 1, i});\\n            events.push_back({arrival[i] + load[i], 0, i});\\n        }\\n        sort(events.begin(), events.end());\\n        vector <int> cnt(k);\\n        vector <int> busiest;\\n        set <int> working;\\n        set <int> free;\\n        for (int i = 0; i < k; ++i) {\\n            free.insert(i);\\n        }\\n        vector <int> who(n, -1);\\n        for (int i = 0; i < events.size(); ++i) {\\n            int time = events[i][0];\\n            int type = events[i][1];\\n            int idx = events[i][2];\\n            if (type == 0) {\\n                if (who[idx] != -1) {\\n                    working.erase(who[idx]);\\n                    free.insert(who[idx]);\\n                }\\n            } else {\\n                int who_can = idx % k;\\n                if (free.size() == 0) {\\n                    who[idx] = -1;\\n                    continue;\\n                } else {\\n                    auto it = free.lower_bound(who_can);\\n                    if (it == free.end()) {\\n                        it = free.begin();\\n                    }\\n                    who_can = *it;\\n                    free.erase(who_can);\\n                    cnt[who_can]++;\\n                    working.insert(who_can);\\n                    who[idx] = who_can;\\n                }\\n            }\\n        }\\n        int mx = 0;\\n        /*\\n            For debugging..\\n        for (int i = 0; i < n; ++i) {\\n            cout << who[i] << \" \";\\n        }\\n        cout << \\'\\\\n\\';\\n        */\\n        for (int i = 0; i < k; ++i) {\\n            mx = max(mx, cnt[i]);\\n            //cout << cnt[i] << \" \";\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) {\\n                busiest.push_back(i);\\n            }\\n        }\\n        return busiest;\\n    }\\n};\\n```\\nComment down below for further Queries.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector <array<int, 3>> events;\\n        int n = arrival.size();\\n        for (int i = 0; i < n; ++i) {\\n            events.push_back({arrival[i], 1, i});\\n            events.push_back({arrival[i] + load[i], 0, i});\\n        }\\n        sort(events.begin(), events.end());\\n        vector <int> cnt(k);\\n        vector <int> busiest;\\n        set <int> working;\\n        set <int> free;\\n        for (int i = 0; i < k; ++i) {\\n            free.insert(i);\\n        }\\n        vector <int> who(n, -1);\\n        for (int i = 0; i < events.size(); ++i) {\\n            int time = events[i][0];\\n            int type = events[i][1];\\n            int idx = events[i][2];\\n            if (type == 0) {\\n                if (who[idx] != -1) {\\n                    working.erase(who[idx]);\\n                    free.insert(who[idx]);\\n                }\\n            } else {\\n                int who_can = idx % k;\\n                if (free.size() == 0) {\\n                    who[idx] = -1;\\n                    continue;\\n                } else {\\n                    auto it = free.lower_bound(who_can);\\n                    if (it == free.end()) {\\n                        it = free.begin();\\n                    }\\n                    who_can = *it;\\n                    free.erase(who_can);\\n                    cnt[who_can]++;\\n                    working.insert(who_can);\\n                    who[idx] = who_can;\\n                }\\n            }\\n        }\\n        int mx = 0;\\n        /*\\n            For debugging..\\n        for (int i = 0; i < n; ++i) {\\n            cout << who[i] << \" \";\\n        }\\n        cout << \\'\\\\n\\';\\n        */\\n        for (int i = 0; i < k; ++i) {\\n            mx = max(mx, cnt[i]);\\n            //cout << cnt[i] << \" \";\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) {\\n                busiest.push_back(i);\\n            }\\n        }\\n        return busiest;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1887825,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>available = getSet(k);\\n        map<int,int>frequencies;\\n        set<pair<int,int>>busy;\\n        for(int i = 0; i < arrival.size(); ++i) {\\n            int arrivalTime = arrival[i], loadTime = load[i];\\n            while(busy.size() && busy.begin()->first <= arrivalTime) {\\n                auto [availableTime, index] = *busy.begin();\\n                available.insert(index);\\n                busy.erase(busy.begin());\\n            }\\n            if(available.empty()) {\\n                continue;\\n            }\\n            int position = getPosition(i,k,available);\\n            frequencies[position]++;\\n            busy.insert({arrivalTime+loadTime, position});\\n        }\\n        return getResult(frequencies);\\n    }\\n    \\n    int getPosition(int i, int k, set<int>&available) {\\n        int position = i%k;\\n        auto pos = available.lower_bound(position);\\n        if(pos == available.end()) {\\n            pos = available.begin();\\n        }\\n        position = *pos;\\n        available.erase(pos);\\n        return position;\\n    }\\n    \\n    vector<int> getResult(map<int,int>&frequencies) {\\n        int maxFrequency = 0;\\n        vector<int>result;\\n        for(auto [value, frequency]: frequencies) {\\n            maxFrequency = max(maxFrequency, frequency);\\n        }\\n        for(auto [value, frequency]: frequencies) {\\n            if(frequency == maxFrequency) {\\n                result.push_back(value);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    set<int> getSet(int k) {\\n        set<int>available;\\n        for(int i = 0; i < k; ++i) {\\n            available.insert(i);\\n        }\\n        return available;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>available = getSet(k);\\n        map<int,int>frequencies;\\n        set<pair<int,int>>busy;\\n        for(int i = 0; i < arrival.size(); ++i) {\\n            int arrivalTime = arrival[i], loadTime = load[i];\\n            while(busy.size() && busy.begin()->first <= arrivalTime) {\\n                auto [availableTime, index] = *busy.begin();\\n                available.insert(index);\\n                busy.erase(busy.begin());\\n            }\\n            if(available.empty()) {\\n                continue;\\n            }\\n            int position = getPosition(i,k,available);\\n            frequencies[position]++;\\n            busy.insert({arrivalTime+loadTime, position});\\n        }\\n        return getResult(frequencies);\\n    }\\n    \\n    int getPosition(int i, int k, set<int>&available) {\\n        int position = i%k;\\n        auto pos = available.lower_bound(position);\\n        if(pos == available.end()) {\\n            pos = available.begin();\\n        }\\n        position = *pos;\\n        available.erase(pos);\\n        return position;\\n    }\\n    \\n    vector<int> getResult(map<int,int>&frequencies) {\\n        int maxFrequency = 0;\\n        vector<int>result;\\n        for(auto [value, frequency]: frequencies) {\\n            maxFrequency = max(maxFrequency, frequency);\\n        }\\n        for(auto [value, frequency]: frequencies) {\\n            if(frequency == maxFrequency) {\\n                result.push_back(value);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    set<int> getSet(int k) {\\n        set<int>available;\\n        for(int i = 0; i < k; ++i) {\\n            available.insert(i);\\n        }\\n        return available;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884534,
                "title": "first-version-python-heap",
                "content": "```import heapq\\nimport bisect\\n\\nclass Solution:\\n    def __init__(self):\\n        self.availableServers = []\\n        self.requestsOfServers = []\\n        self.trackRunningProcess = []\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n#         initialize severs\\'statues\\n        for i in range(k):\\n            self.availableServers.append(i)\\n            self.requestsOfServers.append(0)\\n#             heapify two lists\\n        heapq.heapify(self.trackRunningProcess)\\n        heapq.heapify(self.availableServers)\\n#         Start to handle requests\\n        for index, (a, l) in enumerate(zip(arrival, load)):\\n            # print(self.availableServers)\\n            # print(self.requestsOfServers)\\n            # print(self.trackRunningProcess)\\n            totalTimeCost = a + l\\n#             Need to pop servers which has done the request when the new request arrives\\n            while len(self.trackRunningProcess) and self.trackRunningProcess[0][0] <= a:\\n                heapq.heappush(self.availableServers, self.trackRunningProcess[0][1])\\n                heapq.heappop(self.trackRunningProcess)\\n#             Need to handle current request now\\n#             Check whether there is available serevr now\\n            if index%k in self.availableServers:\\n                heapq.heappush(self.trackRunningProcess, (totalTimeCost, index%k))\\n                self.availableServers.remove(index%k)\\n                self.requestsOfServers[index%k] += 1\\n            else:\\n                if len(self.availableServers):\\n                    serverToBeUsed = index%k\\n                    self.availableServers.sort()\\n                    if bisect.bisect_left(self.availableServers, serverToBeUsed) == len(self.availableServers):\\n                        serverToBeUsed = heapq.heappop(self.availableServers)\\n                    else:\\n                        serverToBeUsed = self.availableServers[bisect.bisect_left(self.availableServers, serverToBeUsed)]\\n                        self.availableServers.remove(serverToBeUsed)\\n                    heapq.heappush(self.trackRunningProcess, (totalTimeCost, serverToBeUsed))\\n                    self.requestsOfServers[serverToBeUsed] += 1\\n                else:\\n#                     drop this request\\n                    continue\\n#         Calculate the result\\n        # print(self.requestsOfServers)\\n        maxRqs = max(self.requestsOfServers)\\n        return [i for i, val in enumerate(self.requestsOfServers) if val == maxRqs ]\\n        \\n",
                "solutionTags": [],
                "code": "```import heapq\\nimport bisect\\n\\nclass Solution:\\n    def __init__(self):\\n        self.availableServers = []\\n        self.requestsOfServers = []\\n        self.trackRunningProcess = []\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n#         initialize severs\\'statues\\n        for i in range(k):\\n            self.availableServers.append(i)\\n            self.requestsOfServers.append(0)\\n#             heapify two lists\\n        heapq.heapify(self.trackRunningProcess)\\n        heapq.heapify(self.availableServers)\\n#         Start to handle requests\\n        for index, (a, l) in enumerate(zip(arrival, load)):\\n            # print(self.availableServers)\\n            # print(self.requestsOfServers)\\n            # print(self.trackRunningProcess)\\n            totalTimeCost = a + l\\n#             Need to pop servers which has done the request when the new request arrives\\n            while len(self.trackRunningProcess) and self.trackRunningProcess[0][0] <= a:\\n                heapq.heappush(self.availableServers, self.trackRunningProcess[0][1])\\n                heapq.heappop(self.trackRunningProcess)\\n#             Need to handle current request now\\n#             Check whether there is available serevr now\\n            if index%k in self.availableServers:\\n                heapq.heappush(self.trackRunningProcess, (totalTimeCost, index%k))\\n                self.availableServers.remove(index%k)\\n                self.requestsOfServers[index%k] += 1\\n            else:\\n                if len(self.availableServers):\\n                    serverToBeUsed = index%k\\n                    self.availableServers.sort()\\n                    if bisect.bisect_left(self.availableServers, serverToBeUsed) == len(self.availableServers):\\n                        serverToBeUsed = heapq.heappop(self.availableServers)\\n                    else:\\n                        serverToBeUsed = self.availableServers[bisect.bisect_left(self.availableServers, serverToBeUsed)]\\n                        self.availableServers.remove(serverToBeUsed)\\n                    heapq.heappush(self.trackRunningProcess, (totalTimeCost, serverToBeUsed))\\n                    self.requestsOfServers[serverToBeUsed] += 1\\n                else:\\n#                     drop this request\\n                    continue\\n#         Calculate the result\\n        # print(self.requestsOfServers)\\n        maxRqs = max(self.requestsOfServers)\\n        return [i for i, val in enumerate(self.requestsOfServers) if val == maxRqs ]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1875744,
                "title": "scala-using-treeset-and-treemap",
                "content": "```\\nobject Solution {\\n    def busiestServers(k: Int, arrival: Array[Int], load: Array[Int]): List[Int] = {\\n        import scala.collection.mutable._\\n        val availableServers = TreeSet[Int](Range(0,k).toList: _*)\\n        val busyServers = TreeMap[Int ,ListBuffer[Int]]().withDefaultValue(ListBuffer.empty[Int])\\n        val count = Array.fill[Int](k)(0)\\n        var maxRequest = 0\\n        \\n        arrival.zipWithIndex.foreach { case (arrivalTime, requestIdx) =>\\n            busyServers.rangeTo(arrivalTime).foreach { case (endTime, servers) =>\\n                servers.foreach { server =>\\n                    availableServers.add(server)\\n                }\\n                busyServers.remove(endTime)\\n            }\\n            \\n            val fromNatural = availableServers.rangeFrom(requestIdx % k).headOption\\n            val fromStart = availableServers.rangeUntil(requestIdx % k).headOption\\n            \\n            val headOpt = (fromNatural, fromStart) match {\\n                case (Some(_), _) => fromNatural\\n                case (_, Some(_)) => fromStart\\n                case (_, _) => None\\n            }\\n            \\n            headOpt.map { server => \\n                availableServers.remove(server) \\n                busyServers.put(arrivalTime + load(requestIdx), busyServers(arrivalTime + load(requestIdx)) :+ server)\\n                count(server) += 1\\n                maxRequest = maxRequest max count(server)\\n            }\\n        }\\n        \\n        count.zipWithIndex.filter(_._1 == maxRequest).map(_._2).toList\\n    }                           \\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def busiestServers(k: Int, arrival: Array[Int], load: Array[Int]): List[Int] = {\\n        import scala.collection.mutable._\\n        val availableServers = TreeSet[Int](Range(0,k).toList: _*)\\n        val busyServers = TreeMap[Int ,ListBuffer[Int]]().withDefaultValue(ListBuffer.empty[Int])\\n        val count = Array.fill[Int](k)(0)\\n        var maxRequest = 0\\n        \\n        arrival.zipWithIndex.foreach { case (arrivalTime, requestIdx) =>\\n            busyServers.rangeTo(arrivalTime).foreach { case (endTime, servers) =>\\n                servers.foreach { server =>\\n                    availableServers.add(server)\\n                }\\n                busyServers.remove(endTime)\\n            }\\n            \\n            val fromNatural = availableServers.rangeFrom(requestIdx % k).headOption\\n            val fromStart = availableServers.rangeUntil(requestIdx % k).headOption\\n            \\n            val headOpt = (fromNatural, fromStart) match {\\n                case (Some(_), _) => fromNatural\\n                case (_, Some(_)) => fromStart\\n                case (_, _) => None\\n            }\\n            \\n            headOpt.map { server => \\n                availableServers.remove(server) \\n                busyServers.put(arrivalTime + load(requestIdx), busyServers(arrivalTime + load(requestIdx)) :+ server)\\n                count(server) += 1\\n                maxRequest = maxRequest max count(server)\\n            }\\n        }\\n        \\n        count.zipWithIndex.filter(_._1 == maxRequest).map(_._2).toList\\n    }                           \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1762973,
                "title": "python3-using-sortedlist",
                "content": "```\\n\"\"\"\\nBorrowed idea of using SortedList from \\nhttps://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/887507/Simple-python-SortedList-solution\\n\"\"\"\\nfrom heapq import heappop, heappush, heapify\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.K = k\\n        self.availables = SortedList([_ for _ in range(k)])\\n        self.busy_servers = []  # store [end time, server idx]\\n        self.count = {i:0 for i in range(k)}\\n        \\n        for i, (arrive, load) in enumerate(zip(arrival, load)):\\n            self.updateAvailables(arrive)\\n            sidx = self.getServerIdx(i)\\n            self.runServer(sidx, arrive, load)\\n        \\n        max_count = max(self.count.values())\\n        ret = []\\n        for i in self.count:\\n            if self.count[i] == max_count:\\n                ret.append(i)\\n        \\n        return ret\\n            \\n    def updateAvailables(self, arrive):\\n        while self.busy_servers and self.busy_servers[0][0] <= arrive:\\n            end_time, server_idx = heappop(self.busy_servers)\\n            self.availables.add(server_idx)\\n            \\n    def getServerIdx(self, i):\\n        if not self.availables:\\n            return -1\\n\\n        idx = self.availables.bisect_left(i%self.K)\\n        if idx >= len(self.availables):\\n            idx = 0\\n        return self.availables[idx]\\n\\n    \\n    def runServer(self, i, arrive, load):\\n        if i >= 0:\\n            self.availables.remove(i)\\n            self.count[i] += 1\\n            heappush(self.busy_servers, [arrive+load, i])\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nBorrowed idea of using SortedList from \\nhttps://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/887507/Simple-python-SortedList-solution\\n\"\"\"\\nfrom heapq import heappop, heappush, heapify\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.K = k\\n        self.availables = SortedList([_ for _ in range(k)])\\n        self.busy_servers = []  # store [end time, server idx]\\n        self.count = {i:0 for i in range(k)}\\n        \\n        for i, (arrive, load) in enumerate(zip(arrival, load)):\\n            self.updateAvailables(arrive)\\n            sidx = self.getServerIdx(i)\\n            self.runServer(sidx, arrive, load)\\n        \\n        max_count = max(self.count.values())\\n        ret = []\\n        for i in self.count:\\n            if self.count[i] == max_count:\\n                ret.append(i)\\n        \\n        return ret\\n            \\n    def updateAvailables(self, arrive):\\n        while self.busy_servers and self.busy_servers[0][0] <= arrive:\\n            end_time, server_idx = heappop(self.busy_servers)\\n            self.availables.add(server_idx)\\n            \\n    def getServerIdx(self, i):\\n        if not self.availables:\\n            return -1\\n\\n        idx = self.availables.bisect_left(i%self.K)\\n        if idx >= len(self.availables):\\n            idx = 0\\n        return self.availables[idx]\\n\\n    \\n    def runServer(self, i, arrive, load):\\n        if i >= 0:\\n            self.availables.remove(i)\\n            self.count[i] += 1\\n            heappush(self.busy_servers, [arrive+load, i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698776,
                "title": "explanation-of-the-existing-set-and-priroity-queue-solution",
                "content": "Already people have posted solution using existing set and priority queue.. I am not going to paste just the code as it has already been done.. I am more going inside about why someone reached to this solution..\\n\\nOk, so first thing first, we have servers 0,1,2,3,......k and now we have been given arrival [] array, each element represents the time at which they are reaching to the servers.. the arrival time (aka arrival array) is in strictly increasing order.. meaning we have them in sorted order.. problem is that if you look at the figure 1 then soon you will realize that those are processed on different servers and on different time. So what can we do.??? Well, first we need to know how much each server is processed or processing at time t. To do that we need to have an array, lets call it ```num_processed``` .. where can store how many times a server has been processed. Since there are k servers so the  ```num_processed``` is of k size.\\n\\nNow at time t we need to know how many servers are available to process the requests, question says we need to pick ```i%k``` right off the bat, if it is busy then we need to go to next one.. meaning if x = i%k and if x is busy then go to x+1, x+2 and so on.. now if somehow we maintain a data strucutre where which stores currrently available servers we can just search for xth element in the data structure and if not then go x+1 etc.. so we need something to store the currerntly available servers.. now note that if we simple stuff the servers in an array then we wont know which one is available or not.. but if we can store the servers based on the lowest load time then we can simply say smallest load will finish first.. hence we need a set (aka binary search tree) where we can easily pick the element with less load time and put them in the available list.\\n\\nNow we have the available list of servers.. all we need to do is find x (mentioned above) and then if it is busy then go to x+1, x+2 etc.. fortunately lower_bound of set gives us the first value which is going to be less than x, what the hell does it even mean? It means that we will find first server close to i%k value in the set.. aka first available server close to i%k. now we have server number which is available.. we need to use it.. now we need an array which keeps what server is being used, lets call it ```num_processed```.. so we will go to that index (server id) and increment that value.. we will do this operation for the arrival array.\\n\\nOnce we have the array (num_processed), we will find maximum of it and whatever server is being used at that maximum value in num_processed is our answer.\\n\\n```\\n int findServer(set<int>& available, int cond) {\\n        if (available.empty())\\n            return -1;\\n        \\n        auto later = available.lower_bound(cond);\\n        if (later != available.end()) \\n            return *later;\\n            \\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        int num_processed[k];\\n        \\n        //make all server available\\n        for (int i = 0; i < k; i++){\\n            available.insert(i);\\n            num_processed[i] = 0;\\n        }\\n        \\n        // process the requests\\n        for (int i = 0; i < arrival.size(); i++) {\\n            \\n            // Retreiving the parameter\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            \\n            \\n            // iterating all the min heap elements which has \\n            // arrival time less than or equal to curr arrival\\n            // Meaning they arrived before the current arrival\\n            // and min heap meaning we have the available servers\\n            // in sorted order.\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            \\n            int cond = i % k;\\n            int server_to_use = findServer(available, cond);\\n            if (server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival+ load[i], server_to_use));\\n            }\\n            \\n        }\\n        \\n        int max_val = num_processed[0];\\n        for (int i = 1; i < k; i++) {\\n            max_val = max(max_val, num_processed[i]);\\n        }\\n        \\n        vector<int> result;\\n        for (int i = 0; i < k; i++) {\\n            if (num_processed[i] == max_val) {\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```num_processed```\n```num_processed```\n```i%k```\n```num_processed```\n```\\n int findServer(set<int>& available, int cond) {\\n        if (available.empty())\\n            return -1;\\n        \\n        auto later = available.lower_bound(cond);\\n        if (later != available.end()) \\n            return *later;\\n            \\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        int num_processed[k];\\n        \\n        //make all server available\\n        for (int i = 0; i < k; i++){\\n            available.insert(i);\\n            num_processed[i] = 0;\\n        }\\n        \\n        // process the requests\\n        for (int i = 0; i < arrival.size(); i++) {\\n            \\n            // Retreiving the parameter\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            \\n            \\n            // iterating all the min heap elements which has \\n            // arrival time less than or equal to curr arrival\\n            // Meaning they arrived before the current arrival\\n            // and min heap meaning we have the available servers\\n            // in sorted order.\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            \\n            int cond = i % k;\\n            int server_to_use = findServer(available, cond);\\n            if (server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival+ load[i], server_to_use));\\n            }\\n            \\n        }\\n        \\n        int max_val = num_processed[0];\\n        for (int i = 1; i < k; i++) {\\n            max_val = max(max_val, num_processed[i]);\\n        }\\n        \\n        vector<int> result;\\n        for (int i = 0; i < k; i++) {\\n            if (num_processed[i] == max_val) {\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679966,
                "title": "python-match-server-for-request-w-2-heaps-c-match-requests-for-server-with-1-heap",
                "content": "Frankly I found the efficient way to solve this problem is hard for me.\\nMy brute force approach met with TLE error because it has O(nk) time complexity.\\nI then used two heaps to store available servers and potential candidates respectively, for each request. It still has TLE because it has O(nklogk) time.\\nI then looked up the others in the Discussion. Even that took me a while to figure out how their code worked. The idea is, we need to traverse the requests as it comes, then we can do either:\\n1. match request to available servers, use two efficient data structures to store free servers and busy servers. we can :\\n\\t\\tA. In C++, use ordered map or ordered set which offers  lower_bound() operation in O(logK) time to find the i%k server or its next available free server in cyclic order.\\n\\t\\tB. in Python, devise a clever formula for re-indexing the server: i+(x-i)%k , this will magically number the right server (honestly I won\\'t be able to come up with such a clever formula in an interview); \\n\\t\\tC. Or in Python, from sortedcontainers improt sorteddict or sortedset or sortedlist\\n2. match servers to pick up suitable requests, for each ith request, we put it in an ordered map<availTime,load>, then we target only the i%k server, let it pick up from a historically accumulated to-do tasks stored in the map. With map.lower_bound() and iterator we can efficient retrieval of available server set in O(logN) time, because the backlog can be O(N) long in worst case scenario.\\n```\\nclass Solution:\\n    def busiestServers2_heaps(self, k: int, arrival: List[int], load: List[int]) -> List[int]:  #failed with TLE at 100/108\\n        from queue import PriorityQueue\\n        pq=heapq.heapify(lst:=[(0,s) for s in range(k)])\\n        handled=[0]*k\\n        busiest=0\\n        candidate=PriorityQueue()\\n        for i in range(len(arrival)):\\n            t=arrival[i]\\n            target=i%k\\n            while lst and lst[0][0]<=t:  #lst stores server\\'s (availability , index), we first find all available servers\\n                avail,server=heapq.heappop(lst)\\n                server=(server-target+k)%k\\n                candidate.put((server,avail),block=False,timeout=None) #candidate stores server\\'s (index, availability) , where smallest index is the server that will server current request. we use min heap to put that server on the top\\n                if server==0: # Got what we prefer, no need to continue\\n                    break\\n            if not candidate.empty():  # the server of choice is the top element in the min heap according to its index\\n                server,avail=candidate.get(block=False,timeout=None)\\n                server=(server+target)%k\\n                handled[server]+=1\\n                busiest=max(busiest,handled[server])\\n                heapq.heappush(lst,(t+load[i],server))\\n                while not candidate.empty():\\n                    server,avail=candidate.get(block=False,timeout=None)\\n                    server=(server+target)%k\\n                    heapq.heappush(lst,(avail,server))\\n        return [i for i,v in enumerate(handled) if v==busiest]\\n    \\'\\'\\'\\n    An useful Test case\\n    3\\n    [1,2,3,4,8,9,10]\\n    [5,2,10,3,1,2,2]\\n    \\'\\'\\' \\n\\t# use two min heaps, one to track free servers, one to track busy servers. \\n\\t# when a new request arrives, free as many servers as possible into free heap, \\n\\t# then use i+(x-i)%k to magically specify the i%k server or its next available server in cyclic order.\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap, stores free server\\n        busy = []  # a min heap to store busy server\\n        res = [0] * k\\n        x=-1 #impotant for the i+(x-i)%k to work, note in Python/R, -4%3 yields 2, not -1 (as JS/JAVA/C#/C/C++/Scala)\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n\\t\\t\\t\\t#i+(x-i)%k guarantees the i%k or its next available free server will be the lowest in the available heap\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k  # , (i+(x-i)%k)%k restores the index of the selected server\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```\\n\\nC++ TLDR. \\nSorry for the verbosity. This is to document my trial and error for quick future reference, and for anyone who is interested or share the same frustration.\\nApproach 1. Brute force looping through each request , trying to find available server. Failed as this is O(nk)\\nApproach 2. Looping thru requests, for each request, focus on the i%k server only, try to find all suitable requests that are currently available in the ordered tree (map), including the one that was not served by (i-x)%k servers because that server was busy and rolled up to the current i%k server.  Because the map is ordered, we can find all suitable request by call map.lower_bound() which takes O(lgN) time. This works because time complexity is O(nlogN).\\nApproach 3. Based on idea of Approach 2,but try to use priority_queue instead of ordered tree map to track available requests in the order of arrival time. This attempt failed because there is no good way to find the suitable requests in priority queue efficiently for the target server (i%k). I ended up using scanning through all requests and find the suitable one, and push back non-selected requests back to the priority queue. This encountered TLE as the time complexity is now O(N*N*logN) because I popped and pushed back the pq/heap.\\nApproach 4. Use  an ordered set to track all free servers\\'s availablity time set<avail, idx>,  also maintain a priority queues for busy servers. When a new request arrives, we free available servers from busy queue as pair<idx,avail> and put into free queue. If the free queue is not empty, we find the right server by set.lower_bound(i%k), if not found, pick set.begin() . That\\'s the i%k or its next available server. The lower_bound is O(logK) time. The popping from busy and pushing into free queue operations takes place at most (N-k) times. so the outer loop (traversing each request) takes O(NlogK), and shuffling between queues takes (N-k)logK times, so the overall time is still O(NlogK) !!!!\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServersBForce(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled(k,0);\\n        vector<int> avail(k,0);\\n        priority_queue<pair<int,int>> pq;\\n\\n        int maxv=0,nextAvail=0;\\n        for (auto i=0; i<arrival.size(); ++i) {\\n            auto s=i%k,t=arrival[i],tried=0;\\n            //BUG 1: while (avail[s]<t && ...) => avail[s]>t ...\\n            while (avail[s]>t && tried<k) s=(s+1)%k,++tried;\\n            if (tried==k) continue;\\n            ++handled[s];\\n            avail[s]=t+load[i];\\n            maxv=max(maxv,handled[s]);\\n        }\\n        auto busiest=vector<int>();\\n        //BUG 2: lambda (i,v) => lambda (v,i)\\n        for_each(begin(handled), handled.end(),[&](int& v)->void {\\n           if  (v==maxv) busiest.push_back(&v-&(*begin(handled))); \\n        });\\n        return busiest; \\n    }\\n\\n    //using treeset and priority queue \\n\\t/* Quoted from @lzl124631x: \\n\\tset<int> free contains the index of available servers. busy is a min-heap each item of which is a pair of { endTime, serverIndex }.\\n\\nWhen we find an available server, we erase it from free, and put { endTime, serverIndex } into a min-heap busy.\\n\\nFor each arrival[i], we first free all those servers from busy whose endTime is smaller than or equal to arrival[i], then find the first available server in free whose index is greater than i % k in circular order.\\n\\nAbout time complexity, iterating the N elements in A and L takes O(N), within each iteration, the amortized time complexity is O(logK). It\\'s because the sizes of the free and busy are at most K, so each push and pop operation takes O(logK) time.\\n\\nNote that for the loop popping busy, since at most we can pop busy K times and each pop takes O(logK) time, it looks like it\\'s O(KlogK) and the busy\\'s popping operation takes O(NKlogK) overall. But since we at most pop busy N - K times through out the entire function, so the busy\\'s popping operation takes at most (N - k)logK time. Thus the funtion\\'s overall time complexity is still O(NlogK).\\n*/\\n    vector<int> busiestServers2(int k, vector<int>& A, vector<int>& L) {\\n        vector<int> cnt(k);\\n        set<int> free;\\n        for (int i = 0; i < k; ++i) free.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> busy; // endTime, serverIndex\\n        for (int i = 0; i < A.size(); ++i) {\\n            int start = A[i], end = start + L[i];\\n            while (busy.size() && busy.top().first <= start) {\\n                int server = busy.top().second;\\n                busy.pop();\\n                free.insert(server);\\n            }\\n            if (free.empty()) continue;\\n            //this is where the logK operations are done\\n            auto it = free.lower_bound(i % k); //lower bound picks free server idx>=i%k \\n            if (it == free.end()) it = free.begin(); //if no server >=i%k is free, pick lowest\\n            cnt[*it]++;\\n            busy.emplace(end, *it);\\n            free.erase(*it);\\n        }\\n        vector<int> ans;\\n        int mx = *max_element(begin(cnt), end(cnt));\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> busiestServers3(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work, if the top of pq blocks current server from picking subsequent availble requests, those requests will be mis-assigned to the next server.  4 [1,3,4,5,10,12] [11,9,3,1,9,12]\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i,skip=0;\\n        while (true){\\n            if (i<A.size())  pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n            if (!pq.empty())   {\\n                if (pq.top().first<avail[i%k]) skip++;\\n                else skip=0;\\n            }\\n            if (skip==k) {pq.pop(); skip=0;lasti=i;}\\n            while (!pq.empty() && pq.top().first>=avail[i%k]) {\\n                if (i-lasti<=k) {\\n                   auto [a,l]=pq.top();\\n                   avail[i%k]=a+l;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                }\\n               pq.pop();\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers4(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work even after modification, still get TLE error at 102/180 case point when k=2543. This basically is similar to brute force solution which trying to match each request with available server, the pop-look-pushback approach is not efficient with O(1) vector, let alone pq.\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true){\\n            if (i<A.size())   pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n                   vector<item> pushback;\\n                while (!pq.empty() && pq.top().first< avail[i%k]) {\\n                    pushback.push_back(pq.top());\\n                    pq.pop();\\n                }\\n                while (!pq.empty()) {\\n                    if (pq.top().first>=avail[i%k]) {\\n                       avail[i%k]=pq.top().first+pq.top().second;\\n                       ++handled[i%k];\\n                       lasti=i; \\n                       pq.pop();\\n                    }\\n                    else {\\n                        pushback.push_back(pq.top());\\n                        pq.pop();\\n                    }\\n                }\\n                while (!pushback.empty()) {\\n                    pq.push(pushback.back());\\n                    pushback.pop_back();\\n                }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) { \\n        map<int,int> m;\\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true) {\\n            if (i<A.size())  m[A[i]]=L[i];\\n            else if (i-lasti>k )  break;\\n            auto it=m.lower_bound(avail[i%k]);\\n            while ( it!=m.end()) {\\n                   avail[i%k]=it->first+it->second;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                   m.erase(it);\\n                   it=m.lower_bound(avail[i%k]);\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def busiestServers2_heaps(self, k: int, arrival: List[int], load: List[int]) -> List[int]:  #failed with TLE at 100/108\\n        from queue import PriorityQueue\\n        pq=heapq.heapify(lst:=[(0,s) for s in range(k)])\\n        handled=[0]*k\\n        busiest=0\\n        candidate=PriorityQueue()\\n        for i in range(len(arrival)):\\n            t=arrival[i]\\n            target=i%k\\n            while lst and lst[0][0]<=t:  #lst stores server\\'s (availability , index), we first find all available servers\\n                avail,server=heapq.heappop(lst)\\n                server=(server-target+k)%k\\n                candidate.put((server,avail),block=False,timeout=None) #candidate stores server\\'s (index, availability) , where smallest index is the server that will server current request. we use min heap to put that server on the top\\n                if server==0: # Got what we prefer, no need to continue\\n                    break\\n            if not candidate.empty():  # the server of choice is the top element in the min heap according to its index\\n                server,avail=candidate.get(block=False,timeout=None)\\n                server=(server+target)%k\\n                handled[server]+=1\\n                busiest=max(busiest,handled[server])\\n                heapq.heappush(lst,(t+load[i],server))\\n                while not candidate.empty():\\n                    server,avail=candidate.get(block=False,timeout=None)\\n                    server=(server+target)%k\\n                    heapq.heappush(lst,(avail,server))\\n        return [i for i,v in enumerate(handled) if v==busiest]\\n    \\'\\'\\'\\n    An useful Test case\\n    3\\n    [1,2,3,4,8,9,10]\\n    [5,2,10,3,1,2,2]\\n    \\'\\'\\' \\n\\t# use two min heaps, one to track free servers, one to track busy servers. \\n\\t# when a new request arrives, free as many servers as possible into free heap, \\n\\t# then use i+(x-i)%k to magically specify the i%k server or its next available server in cyclic order.\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap, stores free server\\n        busy = []  # a min heap to store busy server\\n        res = [0] * k\\n        x=-1 #impotant for the i+(x-i)%k to work, note in Python/R, -4%3 yields 2, not -1 (as JS/JAVA/C#/C/C++/Scala)\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n\\t\\t\\t\\t#i+(x-i)%k guarantees the i%k or its next available free server will be the lowest in the available heap\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k  # , (i+(x-i)%k)%k restores the index of the selected server\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServersBForce(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled(k,0);\\n        vector<int> avail(k,0);\\n        priority_queue<pair<int,int>> pq;\\n\\n        int maxv=0,nextAvail=0;\\n        for (auto i=0; i<arrival.size(); ++i) {\\n            auto s=i%k,t=arrival[i],tried=0;\\n            //BUG 1: while (avail[s]<t && ...) => avail[s]>t ...\\n            while (avail[s]>t && tried<k) s=(s+1)%k,++tried;\\n            if (tried==k) continue;\\n            ++handled[s];\\n            avail[s]=t+load[i];\\n            maxv=max(maxv,handled[s]);\\n        }\\n        auto busiest=vector<int>();\\n        //BUG 2: lambda (i,v) => lambda (v,i)\\n        for_each(begin(handled), handled.end(),[&](int& v)->void {\\n           if  (v==maxv) busiest.push_back(&v-&(*begin(handled))); \\n        });\\n        return busiest; \\n    }\\n\\n    //using treeset and priority queue \\n\\t/* Quoted from @lzl124631x: \\n\\tset<int> free contains the index of available servers. busy is a min-heap each item of which is a pair of { endTime, serverIndex }.\\n\\nWhen we find an available server, we erase it from free, and put { endTime, serverIndex } into a min-heap busy.\\n\\nFor each arrival[i], we first free all those servers from busy whose endTime is smaller than or equal to arrival[i], then find the first available server in free whose index is greater than i % k in circular order.\\n\\nAbout time complexity, iterating the N elements in A and L takes O(N), within each iteration, the amortized time complexity is O(logK). It\\'s because the sizes of the free and busy are at most K, so each push and pop operation takes O(logK) time.\\n\\nNote that for the loop popping busy, since at most we can pop busy K times and each pop takes O(logK) time, it looks like it\\'s O(KlogK) and the busy\\'s popping operation takes O(NKlogK) overall. But since we at most pop busy N - K times through out the entire function, so the busy\\'s popping operation takes at most (N - k)logK time. Thus the funtion\\'s overall time complexity is still O(NlogK).\\n*/\\n    vector<int> busiestServers2(int k, vector<int>& A, vector<int>& L) {\\n        vector<int> cnt(k);\\n        set<int> free;\\n        for (int i = 0; i < k; ++i) free.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> busy; // endTime, serverIndex\\n        for (int i = 0; i < A.size(); ++i) {\\n            int start = A[i], end = start + L[i];\\n            while (busy.size() && busy.top().first <= start) {\\n                int server = busy.top().second;\\n                busy.pop();\\n                free.insert(server);\\n            }\\n            if (free.empty()) continue;\\n            //this is where the logK operations are done\\n            auto it = free.lower_bound(i % k); //lower bound picks free server idx>=i%k \\n            if (it == free.end()) it = free.begin(); //if no server >=i%k is free, pick lowest\\n            cnt[*it]++;\\n            busy.emplace(end, *it);\\n            free.erase(*it);\\n        }\\n        vector<int> ans;\\n        int mx = *max_element(begin(cnt), end(cnt));\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> busiestServers3(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work, if the top of pq blocks current server from picking subsequent availble requests, those requests will be mis-assigned to the next server.  4 [1,3,4,5,10,12] [11,9,3,1,9,12]\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i,skip=0;\\n        while (true){\\n            if (i<A.size())  pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n            if (!pq.empty())   {\\n                if (pq.top().first<avail[i%k]) skip++;\\n                else skip=0;\\n            }\\n            if (skip==k) {pq.pop(); skip=0;lasti=i;}\\n            while (!pq.empty() && pq.top().first>=avail[i%k]) {\\n                if (i-lasti<=k) {\\n                   auto [a,l]=pq.top();\\n                   avail[i%k]=a+l;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                }\\n               pq.pop();\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers4(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work even after modification, still get TLE error at 102/180 case point when k=2543. This basically is similar to brute force solution which trying to match each request with available server, the pop-look-pushback approach is not efficient with O(1) vector, let alone pq.\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true){\\n            if (i<A.size())   pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n                   vector<item> pushback;\\n                while (!pq.empty() && pq.top().first< avail[i%k]) {\\n                    pushback.push_back(pq.top());\\n                    pq.pop();\\n                }\\n                while (!pq.empty()) {\\n                    if (pq.top().first>=avail[i%k]) {\\n                       avail[i%k]=pq.top().first+pq.top().second;\\n                       ++handled[i%k];\\n                       lasti=i; \\n                       pq.pop();\\n                    }\\n                    else {\\n                        pushback.push_back(pq.top());\\n                        pq.pop();\\n                    }\\n                }\\n                while (!pushback.empty()) {\\n                    pq.push(pushback.back());\\n                    pushback.pop_back();\\n                }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) { \\n        map<int,int> m;\\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true) {\\n            if (i<A.size())  m[A[i]]=L[i];\\n            else if (i-lasti>k )  break;\\n            auto it=m.lower_bound(avail[i%k]);\\n            while ( it!=m.end()) {\\n                   avail[i%k]=it->first+it->second;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                   m.erase(it);\\n                   it=m.lower_bound(avail[i%k]);\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648304,
                "title": "java-treeset-and-pq",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<Integer[]> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1[0], o2[0]));\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n        }\\n        HashMap<Integer, Integer> serverTime = new HashMap<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {\\n                Integer[] curr = pq.poll();\\n                free.add(curr[1]);\\n            }\\n            if (!free.isEmpty()) {\\n                if (free.contains(i % k)) {\\n                    pq.add(new Integer[]{arrival[i] + load[i], i % k});\\n                    serverTime.put(i % k, serverTime.getOrDefault(i % k, 0) + 1);\\n                    free.remove(i % k);\\n                } else {\\n                    Integer server = free.higher(i % k);\\n                    if (server == null) {\\n                        server = free.first();\\n                    }\\n                    pq.add(new Integer[]{arrival[i] + load[i], server});\\n                    free.remove(server);\\n                    serverTime.put(server, serverTime.getOrDefault(server, 0) + 1);\\n                }\\n            }\\n        }\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(serverTime.entrySet());\\n        list.sort((o1, o2) -> -Integer.compare(o1.getValue(), o2.getValue()));\\n        List<Integer> ans = new ArrayList<>();\\n        int max = list.get(0).getValue();\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i).getValue() == max) {\\n                ans.add(list.get(i).getKey());\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<Integer[]> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1[0], o2[0]));\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n        }\\n        HashMap<Integer, Integer> serverTime = new HashMap<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {\\n                Integer[] curr = pq.poll();\\n                free.add(curr[1]);\\n            }\\n            if (!free.isEmpty()) {\\n                if (free.contains(i % k)) {\\n                    pq.add(new Integer[]{arrival[i] + load[i], i % k});\\n                    serverTime.put(i % k, serverTime.getOrDefault(i % k, 0) + 1);\\n                    free.remove(i % k);\\n                } else {\\n                    Integer server = free.higher(i % k);\\n                    if (server == null) {\\n                        server = free.first();\\n                    }\\n                    pq.add(new Integer[]{arrival[i] + load[i], server});\\n                    free.remove(server);\\n                    serverTime.put(server, serverTime.getOrDefault(server, 0) + 1);\\n                }\\n            }\\n        }\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(serverTime.entrySet());\\n        list.sort((o1, o2) -> -Integer.compare(o1.getValue(), o2.getValue()));\\n        List<Integer> ans = new ArrayList<>();\\n        int max = list.get(0).getValue();\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i).getValue() == max) {\\n                ans.add(list.get(i).getKey());\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567170,
                "title": "c-set-and-priority-queue-solution",
                "content": "The idea is as follows - we maintain two data structures, one is a set of available servers we can use, and one is a priority queue of servers, consisting of a pair of a server id and the next time the server is available, and the priority is given by the next time the server will be available. Each time we get a new request, we look in our set of available servers to find the next available server as in the problem statement. This is handled in the query function. If we find a server, we increment the number of times that server has been used, and we push that server, onto the priority queue, with priority given by the current time plus the load, as this will be the next time the server will be available. If N is the number of requests we have to process, then the runtime will be NlogN. Indeed, each Query operation will take log(N) time, as there can be at most N available times. Also, for each request, we add at most 1 element to the priority queue, so we will be doing at most N push and pops from the priority queue, each of which can take at most log(N) time. Note that at any given request, we may perform more than one pop from the priority queue, but this does not affect the overall runtime because over the lifetime of the program, we are still doing at most N pops. \\n\\n```\\n#include <set>\\n#include <queue>\\n#include <utility>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    \\n    int query(const set<int>& available, int i) {\\n        if(available.empty()) {return -1;}\\n        \\n        auto later = available.lower_bound(i);\\n        if(later != available.end()) {return *later;}\\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        int num_processed[k];\\n        for(int i = 0; i < k; i++) {available.insert(i); num_processed[i] = 0;}\\n        \\n        for(int i = 0; i < arrival.size(); i++) {\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            int server_to_use = query(available, i%k); \\n            if(server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival + curr_load, server_to_use));\\n            }\\n        }\\n        int max_val = num_processed[0];\\n        for(int i = 1; i < k; i++) {\\n            if(num_processed[i] > max_val) {\\n                max_val = num_processed[i];\\n            }\\n        }\\n        vector<int> biggest_servers;\\n        for(int i = 0; i < k; i++) {\\n            if(num_processed[i] == max_val) {\\n                biggest_servers.push_back(i);\\n            }\\n        }\\n        return biggest_servers;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <set>\\n#include <queue>\\n#include <utility>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    \\n    int query(const set<int>& available, int i) {\\n        if(available.empty()) {return -1;}\\n        \\n        auto later = available.lower_bound(i);\\n        if(later != available.end()) {return *later;}\\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        int num_processed[k];\\n        for(int i = 0; i < k; i++) {available.insert(i); num_processed[i] = 0;}\\n        \\n        for(int i = 0; i < arrival.size(); i++) {\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            int server_to_use = query(available, i%k); \\n            if(server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival + curr_load, server_to_use));\\n            }\\n        }\\n        int max_val = num_processed[0];\\n        for(int i = 1; i < k; i++) {\\n            if(num_processed[i] > max_val) {\\n                max_val = num_processed[i];\\n            }\\n        }\\n        vector<int> biggest_servers;\\n        for(int i = 0; i < k; i++) {\\n            if(num_processed[i] == max_val) {\\n                biggest_servers.push_back(i);\\n            }\\n        }\\n        return biggest_servers;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1449176,
                "title": "can-anyone-explain-what-is-ordered-set",
                "content": "can anyone explain what is ordered set",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1432118,
                "title": "simple-java-solution-using-array-runtime-o-n-and-space-o-k",
                "content": "Simple solution:\\n\\n\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        int[] serversAvailability = new int[k];\\n        int[] serversProcessCount = new int[k];\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            int startTime = arrival[i];\\n            int endTime = startTime + load[i];\\n\\n            int initialServer = i % k;\\n            int currentServer = initialServer;\\n\\n            do {\\n                int exitingProcessEndTime = serversAvailability[currentServer];\\n                if (exitingProcessEndTime <= startTime) {\\n                    serversAvailability[currentServer] = endTime;\\n                    serversProcessCount[currentServer] = serversProcessCount[currentServer] + 1;\\n                    break;\\n                }\\n                currentServer++;\\n                if (currentServer == k) {\\n                    currentServer = 0;\\n                }\\n            } while (currentServer != initialServer);\\n        }\\n\\n        int max = 0;\\n        Map<Integer, List<Integer>> maxProcessCountMap = new HashMap<Integer, List<Integer>>();\\n        for (int i = 0; i < k; i++) {\\n            if (serversProcessCount[i] >= max) {\\n                max = serversProcessCount[i];\\n                List<Integer> processors = maxProcessCountMap.get(max);\\n                if (processors == null) {\\n                    processors = new ArrayList<Integer>();\\n                    maxProcessCountMap.put(max, processors);\\n                }\\n\\n                processors.add(i);\\n\\n            }\\n        }\\n\\n        return maxProcessCountMap.get(max);\\n    }",
                "solutionTags": [],
                "code": "Simple solution:\\n\\n\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        int[] serversAvailability = new int[k];\\n        int[] serversProcessCount = new int[k];\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            int startTime = arrival[i];\\n            int endTime = startTime + load[i];\\n\\n            int initialServer = i % k;\\n            int currentServer = initialServer;\\n\\n            do {\\n                int exitingProcessEndTime = serversAvailability[currentServer];\\n                if (exitingProcessEndTime <= startTime) {\\n                    serversAvailability[currentServer] = endTime;\\n                    serversProcessCount[currentServer] = serversProcessCount[currentServer] + 1;\\n                    break;\\n                }\\n                currentServer++;\\n                if (currentServer == k) {\\n                    currentServer = 0;\\n                }\\n            } while (currentServer != initialServer);\\n        }\\n\\n        int max = 0;\\n        Map<Integer, List<Integer>> maxProcessCountMap = new HashMap<Integer, List<Integer>>();\\n        for (int i = 0; i < k; i++) {\\n            if (serversProcessCount[i] >= max) {\\n                max = serversProcessCount[i];\\n                List<Integer> processors = maxProcessCountMap.get(max);\\n                if (processors == null) {\\n                    processors = new ArrayList<Integer>();\\n                    maxProcessCountMap.put(max, processors);\\n                }\\n\\n                processors.add(i);\\n\\n            }\\n        }\\n\\n        return maxProcessCountMap.get(max);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1383896,
                "title": "python-heap-maths",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        server_timers= []\\n        task_count= [0 for _ in range(k)]\\n        avail_servers=list(range(k))\\n        for i,arr in enumerate(arrival):\\n            while server_timers and server_timers[0][0]<=arr:\\n                heappush(avail_servers,i+(heappop(server_timers)[1]-i)%k)\\n            if avail_servers:\\n                assigned_server=heappop(avail_servers)%k;\\n                heappush(server_timers,(arr+load[i],assigned_server))\\n                task_count[assigned_server]+=1\\n        maxx=max(task_count)\\n        return [i for i in range(k) if task_count[i]==maxx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        server_timers= []\\n        task_count= [0 for _ in range(k)]\\n        avail_servers=list(range(k))\\n        for i,arr in enumerate(arrival):\\n            while server_timers and server_timers[0][0]<=arr:\\n                heappush(avail_servers,i+(heappop(server_timers)[1]-i)%k)\\n            if avail_servers:\\n                assigned_server=heappop(avail_servers)%k;\\n                heappush(server_timers,(arr+load[i],assigned_server))\\n                task_count[assigned_server]+=1\\n        maxx=max(task_count)\\n        return [i for i in range(k) if task_count[i]==maxx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238486,
                "title": "c-ordered-map-priority-queue",
                "content": "class Solution {\\n    \\n    struct Compare\\n    {\\n        bool operator ()(pair<int, int> const& p1, pair<int, int> const& p2)\\n        {\\n            return p1.first > p2.first;\\n        }\\n    };\\n    \\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        set<int> available_servers;\\n        for (int i=0;i<k;i++)\\n            available_servers.emplace(i);\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minheap;\\n                \\n        vector<int> freq (k, 0);\\n        for (int i=0;i<arrival.size();i++)\\n        {            \\n            while (!minheap.empty())\\n            {\\n                auto top = minheap.top();\\n                if(top.first <= arrival[i])\\n                {\\n                    minheap.pop();\\n                    available_servers.emplace(top.second);\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            set<int>::iterator it;\\n            it = available_servers.lower_bound(i % k);\\n            if (it == available_servers.end())\\n                it = available_servers.lower_bound(0);\\n            \\n            if (it != available_servers.end())\\n            {\\n                minheap.emplace(arrival[i] + load[i], *it);\\n                \\n                freq[*it]++;\\n            \\n                available_servers.erase(it);\\n            }\\n        }\\n        \\n        vector<int> result;\\n        int max = *max_element(freq.begin(), freq.end());\\n        for (int i=0; i<k; i++)\\n        {\\n            if (freq[i] == max)\\n                result.emplace_back(i);\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    struct Compare\\n    {\\n        bool operator ()(pair<int, int> const& p1, pair<int, int> const& p2)\\n        {\\n            return p1.first > p2.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1132392,
                "title": "treeset-solution",
                "content": "greedily choose the server from the pool and then count the busiest servers \\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int dp[] = new int[k], n = arrival.length;\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for (int i = 0; i < k; i++){\\n            ts.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for (int i = 0; i < n; i++){\\n            int cur = i%k, time = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[0] <= time){\\n                ts.add(pq.poll()[1]);\\n            }\\n            if (ts.isEmpty()) continue;\\n            if (ts.contains(cur)){\\n                dp[cur]++;\\n                pq.add(new int[]{time+load[i],cur});\\n                ts.remove(cur);\\n            }else{\\n                Integer max = ts.ceiling(cur);\\n                if (max != null){\\n                    dp[max]++;\\n                    pq.add(new int[]{time+load[i],max});\\n                    ts.remove(max);\\n                }else{\\n                    int nxt = ts.ceiling(0);\\n                    dp[nxt]++;\\n                    pq.add(new int[]{time+load[i],nxt});\\n                    ts.remove(nxt);\\n                }\\n            }\\n        }\\n        int cnt = 0;\\n        for (int i: dp){\\n            cnt = Math.max(i,cnt);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0 ; i < k; i++){\\n            if (dp[i] == cnt) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int dp[] = new int[k], n = arrival.length;\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for (int i = 0; i < k; i++){\\n            ts.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for (int i = 0; i < n; i++){\\n            int cur = i%k, time = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[0] <= time){\\n                ts.add(pq.poll()[1]);\\n            }\\n            if (ts.isEmpty()) continue;\\n            if (ts.contains(cur)){\\n                dp[cur]++;\\n                pq.add(new int[]{time+load[i],cur});\\n                ts.remove(cur);\\n            }else{\\n                Integer max = ts.ceiling(cur);\\n                if (max != null){\\n                    dp[max]++;\\n                    pq.add(new int[]{time+load[i],max});\\n                    ts.remove(max);\\n                }else{\\n                    int nxt = ts.ceiling(0);\\n                    dp[nxt]++;\\n                    pq.add(new int[]{time+load[i],nxt});\\n                    ts.remove(nxt);\\n                }\\n            }\\n        }\\n        int cnt = 0;\\n        for (int i: dp){\\n            cnt = Math.max(i,cnt);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0 ; i < k; i++){\\n            if (dp[i] == cnt) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087601,
                "title": "javascript-solution",
                "content": "Here\\'s my javascript solution. Time is so limited, I had to avoid using ```i % k``` and instead used an iterator.\\n\\n```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    var serverHits = [];\\n    var servers = [];\\n    var imk = k-1;\\n    \\n    for(let i in load) {\\n        var j = 0;\\n        imk++;\\n        if(imk >= k) imk -= k;\\n        while(j < k) {\\n            currentServer = (imk) + j;\\n            if(currentServer >= k) currentServer -= k;\\n            if(arrival[i] >= (servers[currentServer] ?? 0)) {\\n                servers[currentServer] = arrival[i] + load[i];\\n                serverHits[currentServer] = (serverHits[currentServer] ?? 0) + 1;\\n                break;\\n            }\\n            j++;\\n        }\\n    }\\n    var maxHits = Math.max(...serverHits);\\n    var maxHitServers = [];\\n    for(let hitServer in serverHits) {\\n        if(serverHits[hitServer] == maxHits) maxHitServers.push(hitServer);\\n    }\\n    \\n    return maxHitServers;\\n};\\n```",
                "solutionTags": [],
                "code": "```i % k```\n```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    var serverHits = [];\\n    var servers = [];\\n    var imk = k-1;\\n    \\n    for(let i in load) {\\n        var j = 0;\\n        imk++;\\n        if(imk >= k) imk -= k;\\n        while(j < k) {\\n            currentServer = (imk) + j;\\n            if(currentServer >= k) currentServer -= k;\\n            if(arrival[i] >= (servers[currentServer] ?? 0)) {\\n                servers[currentServer] = arrival[i] + load[i];\\n                serverHits[currentServer] = (serverHits[currentServer] ?? 0) + 1;\\n                break;\\n            }\\n            j++;\\n        }\\n    }\\n    var maxHits = Math.max(...serverHits);\\n    var maxHitServers = [];\\n    for(let hitServer in serverHits) {\\n        if(serverHits[hitServer] == maxHits) maxHitServers.push(hitServer);\\n    }\\n    \\n    return maxHitServers;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067108,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        TreeSet<Integer> avail = new TreeSet();\\n        for(int i=0; i<k; i++)\\n            avail.add(i);\\n        int max = 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>((a,b)->(a[1]-b[1]));\\n        for(int i=0; i<arrival.length; i++){\\n            while(!q.isEmpty()){\\n                if(q.peek()[1]<=arrival[i])\\n                    avail.add(q.poll()[0]);\\n                else break;\\n            }\\n            Integer sevIdx = avail.ceiling(i%k);\\n            if(sevIdx == null)\\n                sevIdx = avail.ceiling(0);\\n            if(sevIdx != null){\\n                avail.remove(sevIdx);\\n                cnt[sevIdx]++;\\n                q.offer(new int[]{sevIdx, arrival[i]+load[i]});\\n                if(cnt[sevIdx]>max)\\n                    max = cnt[sevIdx];\\n            }\\n        }\\n        List<Integer> res = new ArrayList();\\n        for(int i=0; i<cnt.length; i++)\\n            if(cnt[i] == max)\\n                res.add(i);\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        TreeSet<Integer> avail = new TreeSet();\\n        for(int i=0; i<k; i++)\\n            avail.add(i);\\n        int max = 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>((a,b)->(a[1]-b[1]));\\n        for(int i=0; i<arrival.length; i++){\\n            while(!q.isEmpty()){\\n                if(q.peek()[1]<=arrival[i])\\n                    avail.add(q.poll()[0]);\\n                else break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054308,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "The question requires us to keep two information at any point of time, available servers and the time values at which the occupied servers, will be free. So, we will need two data structures, a **TreeSet** and a **PriorityQueue**.\\n\\n**Why TreeSet ?**\\nBecause, we need to pick the server on the basis of the given algorithm. *If there was no such condition, we could have done with the PriorityQueue alone.*\\nTreeSet will keep the indicies of available servers, in a sorted order, and searching the required index and the next greatest index is fast.\\n\\n**Why PriorityQueue ?**\\nBecause, PriorityQueue will keep the information when the occupied servers are going to be free, in the order sorted by the free time. So, at every point of time, we can simply pick all the servers, which are free, and add to the available servers TreeSet.\\n\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int maxReqHandled = 0;\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n\\t\\tPriorityQueue<int[]> pQueue = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        // int[] : {serverIndex, timeAtWhichItWillBeFree}\\n        for (int i = 0; i < k; i++) availableServers.add(i);\\n        for (int i = 0; i < arrival.length; i++) {\\n            int reqStartTime = arrival[i], reqEndTime = arrival[i] + load[i];\\n            while (!pQueue.isEmpty() && pQueue.peek()[1] <= reqStartTime) {\\n                availableServers.add(pQueue.poll()[0]);\\n            }\\n            Integer server = availableServers.ceiling(i % k);\\n            if (server == null) server = availableServers.ceiling(0);\\n\\t\\t\\t// check from i%k to k, then from 0 to i%k\\n            if (server != null) {\\n                availableServers.remove(server);\\n                pQueue.add(new int[] {server, reqEndTime});\\n                counts[server]++;\\n                if (counts[server] > maxReqHandled) maxReqHandled = counts[server];\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (counts[i] == maxReqHandled) res.add(i);\\n        }\\n        return res;\\n    }\\n```\\nI hope, it helps someone!",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int maxReqHandled = 0;\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n\\t\\tPriorityQueue<int[]> pQueue = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        // int[] : {serverIndex, timeAtWhichItWillBeFree}\\n        for (int i = 0; i < k; i++) availableServers.add(i);\\n        for (int i = 0; i < arrival.length; i++) {\\n            int reqStartTime = arrival[i], reqEndTime = arrival[i] + load[i];\\n            while (!pQueue.isEmpty() && pQueue.peek()[1] <= reqStartTime) {\\n                availableServers.add(pQueue.poll()[0]);\\n            }\\n            Integer server = availableServers.ceiling(i % k);\\n            if (server == null) server = availableServers.ceiling(0);\\n\\t\\t\\t// check from i%k to k, then from 0 to i%k\\n            if (server != null) {\\n                availableServers.remove(server);\\n                pQueue.add(new int[] {server, reqEndTime});\\n                counts[server]++;\\n                if (counts[server] > maxReqHandled) maxReqHandled = counts[server];\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (counts[i] == maxReqHandled) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011087,
                "title": "help-java-not-using-priority-queue",
                "content": "Why is this solution resulting in time out? \\n\\nTime complexity should be O(N*K) where K is number of servers , N is number of requests.\\n\\n```\\nclass Solution {\\n    HashMap<Integer, Stack<Integer>> monitor = new HashMap<>();\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int ans = -1;\\n        for (int i = 0; i< arrival.length; i++) {\\n            int server = getServer(k, i, arrival, load);\\n            if (server == -1) continue;\\n            \\n            Stack<Integer> stack = monitor.getOrDefault(server, new Stack<Integer>());\\n            stack.push(arrival[i]+load[i]);\\n            monitor.put(server, stack);\\n            \\n            ans = Math.max(ans, stack.size());\\n        }\\n        \\n        ArrayList<Integer> result = new ArrayList<>();\\n        if (ans == -1) {return result;}\\n        \\n        for (Integer e: monitor.keySet()){\\n            Stack<Integer> values = monitor.get(e); \\n            if (values.size() == ans) result.add(e);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int getServer(int k, int index, int[]arrival, int[]load) {\\n        if (index < k) return index;\\n            \\n        int end = -1;\\n        int server = -1;\\n        for (int i = 0; i<k; i++) {\\n            server = (index+i) %k ;\\n            end = monitor.get(server).peek(); \\n            if (end <= arrival[index]) {\\n                return server;                \\n            }\\n        }\\n        \\n        return -1;    \\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Stack<Integer>> monitor = new HashMap<>();\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int ans = -1;\\n        for (int i = 0; i< arrival.length; i++) {\\n            int server = getServer(k, i, arrival, load);\\n            if (server == -1) continue;\\n            \\n            Stack<Integer> stack = monitor.getOrDefault(server, new Stack<Integer>());\\n            stack.push(arrival[i]+load[i]);\\n            monitor.put(server, stack);\\n            \\n            ans = Math.max(ans, stack.size());\\n        }\\n        \\n        ArrayList<Integer> result = new ArrayList<>();\\n        if (ans == -1) {return result;}\\n        \\n        for (Integer e: monitor.keySet()){\\n            Stack<Integer> values = monitor.get(e); \\n            if (values.size() == ans) result.add(e);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int getServer(int k, int index, int[]arrival, int[]load) {\\n        if (index < k) return index;\\n            \\n        int end = -1;\\n        int server = -1;\\n        for (int i = 0; i<k; i++) {\\n            server = (index+i) %k ;\\n            end = monitor.get(server).peek(); \\n            if (end <= arrival[index]) {\\n                return server;                \\n            }\\n        }\\n        \\n        return -1;    \\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990366,
                "title": "share-my-java-solution-using-tree-set-and-sliding-window-algorithm",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] count = new int[k];\\n        List<int[]> times = new ArrayList<>();\\n        for(int i=0;i<arrival.length;i++){\\n            times.add(new int[]{arrival[i], arrival[i]+load[i]});\\n        }\\n        \\n        TreeSet<Integer> avail = new TreeSet<>();\\n        for(int i=0;i<k;i++){\\n            avail.add(i);\\n        }\\n        int max_count = 0;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for(int i=0;i<times.size();i++){\\n            int[] cur_interval = times.get(i);\\n            int start = cur_interval[0];\\n            int end = cur_interval[1];\\n            while(minHeap.size()!=0){\\n                int[] temp = minHeap.peek();\\n                if(temp[0]<=start){\\n                    minHeap.poll();\\n                    avail.add(temp[1]);\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            int index = i%k;\\n            Integer pos = avail.ceiling(index);\\n            if(pos==null || pos>=k){\\n                pos = avail.ceiling(0);\\n            }\\n            // System.out.println(pos);\\n            if(pos!=null && pos<k){\\n                count[pos]++;\\n                avail.remove(pos);\\n                minHeap.offer(new int[]{end, pos});\\n                max_count = Math.max(max_count, count[pos]);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<count.length;i++){\\n            if(max_count == count[i]){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] count = new int[k];\\n        List<int[]> times = new ArrayList<>();\\n        for(int i=0;i<arrival.length;i++){\\n            times.add(new int[]{arrival[i], arrival[i]+load[i]});\\n        }\\n        \\n        TreeSet<Integer> avail = new TreeSet<>();\\n        for(int i=0;i<k;i++){\\n            avail.add(i);\\n        }\\n        int max_count = 0;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for(int i=0;i<times.size();i++){\\n            int[] cur_interval = times.get(i);\\n            int start = cur_interval[0];\\n            int end = cur_interval[1];\\n            while(minHeap.size()!=0){\\n                int[] temp = minHeap.peek();\\n                if(temp[0]<=start){\\n                    minHeap.poll();\\n                    avail.add(temp[1]);\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            int index = i%k;\\n            Integer pos = avail.ceiling(index);\\n            if(pos==null || pos>=k){\\n                pos = avail.ceiling(0);\\n            }\\n            // System.out.println(pos);\\n            if(pos!=null && pos<k){\\n                count[pos]++;\\n                avail.remove(pos);\\n                minHeap.offer(new int[]{end, pos});\\n                max_count = Math.max(max_count, count[pos]);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<count.length;i++){\\n            if(max_count == count[i]){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930342,
                "title": "straightforward-java-solution-treeset-and-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[k];\\n        int maxCount = 0;\\n        TreeSet<Integer> availableServer = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            availableServer.add(i);\\n        }\\n        Queue<int[]> runningServer = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] == b[1]) {\\n                    return a[0] - b[0];\\n                }\\n                return a[1] - b[1];\\n            }\\n        });\\n        for (int i = 0; i < arrival.length; i++) {\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            while (!runningServer.isEmpty() && runningServer.peek()[1] <= start) {\\n                availableServer.add(runningServer.poll()[0]);\\n            }\\n            Integer assignedServer = availableServer.ceiling(i % k);\\n            if (assignedServer == null) {\\n                assignedServer = availableServer.ceiling(0);\\n                if (assignedServer == null) {\\n                    continue;\\n                }\\n            }\\n            availableServer.remove(assignedServer);\\n            runningServer.add(new int[]{assignedServer, end});\\n            count[assignedServer]++;\\n            maxCount = Math.max(maxCount, count[assignedServer]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxCount) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[k];\\n        int maxCount = 0;\\n        TreeSet<Integer> availableServer = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            availableServer.add(i);\\n        }\\n        Queue<int[]> runningServer = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] == b[1]) {\\n                    return a[0] - b[0];\\n                }\\n                return a[1] - b[1];\\n            }\\n        });\\n        for (int i = 0; i < arrival.length; i++) {\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            while (!runningServer.isEmpty() && runningServer.peek()[1] <= start) {\\n                availableServer.add(runningServer.poll()[0]);\\n            }\\n            Integer assignedServer = availableServer.ceiling(i % k);\\n            if (assignedServer == null) {\\n                assignedServer = availableServer.ceiling(0);\\n                if (assignedServer == null) {\\n                    continue;\\n                }\\n            }\\n            availableServer.remove(assignedServer);\\n            runningServer.add(new int[]{assignedServer, end});\\n            count[assignedServer]++;\\n            maxCount = Math.max(maxCount, count[assignedServer]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxCount) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914177,
                "title": "why-using-treeset-instead-of-priorityqueue-for-endtime-serverid-pair-times-out",
                "content": "Following solution uses TreeSet and does not pass the time limit.\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<int[]> busy = new TreeSet<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[0] == b[0] ? a[1] - b[1] : a[0]-b[0];\\n            }    \\n        });\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.add(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final TreeSet<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        Iterator<int[]> it = busy.iterator();\\n        \\n        while (it.hasNext()) {\\n            int[] entry = it.next();\\n            \\n            if (entry[0] <= time) {\\n                available.add(entry[1]);\\n                it.remove();\\n            }\\n        }\\n    }\\n}\\n```\\n\\nBut if i use Priority Queue i.e. following solution it passes why ?\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> (a[0]-b[0]));\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.offer(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final PriorityQueue<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        \\n        while (!busy.isEmpty() && busy.peek()[0] <= time) {\\n            available.add(busy.poll()[1]);\\n        }\\n    }\\n}\\n```\\n\\nAlso, how to prove that time complexity of while loop for iteration within priority queue is log(K) ? In worst case, we might have to pop out all the elements within Priority Queue.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<int[]> busy = new TreeSet<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[0] == b[0] ? a[1] - b[1] : a[0]-b[0];\\n            }    \\n        });\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.add(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final TreeSet<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        Iterator<int[]> it = busy.iterator();\\n        \\n        while (it.hasNext()) {\\n            int[] entry = it.next();\\n            \\n            if (entry[0] <= time) {\\n                available.add(entry[1]);\\n                it.remove();\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> (a[0]-b[0]));\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.offer(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final PriorityQueue<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        \\n        while (!busy.isEmpty() && busy.peek()[0] <= time) {\\n            available.add(busy.poll()[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897267,
                "title": "ruby-o-n-log-m-solution-using-only-arrays",
                "content": "## Brute force solution that gives TLE. \\n*Complexity:* `O(N * K)`, where `N` - the number of tasks.\\n\\n```\\ndef busiest_servers(k, arrival, load)\\n  job_end_times = [0] * k # busy till time per sever\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    cond = proc { |j| job_end_times[j] <= time }\\n    j = (i % k...k).find(&cond) || (0...i % k).find(&cond) # O(K)\\n    next unless j\\n\\n    job_end_times[j] = time + duration\\n\\n    # count taken tasks\\n    cnt[j] += 1\\n    max_cnt = cnt[j] if cnt[j] > max_cnt\\n  end\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\\n\\n## Optimization\\n\\nTo speed up the next available server lookup, we\\'ll search only within available servers using binray search.\\nAdd available servers sorted `Array`  with servers numbers and list of in-progress tasks (`jobs`) sorted by tasks end time.\\n\\n*Complexity:* `O(N * log M)`, where `N` - the number of tasks, `M` - max(`N`, `K`)\\n\\n```\\nJob = Struct.new(:server_no, :end_time)\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = *0...k # available servers\\n  jobs = [] # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      job = jobs.delete_at(0)\\n      insert_at = servers.bsearch_index { |n| n >= job.server_no } || servers.size\\n      servers.insert(insert_at, job.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    j = servers.bsearch_index { |n| n >= ik } || 0\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    server_no = servers.delete_at(j)\\n    end_time = time + duration\\n    insert_at = jobs.bsearch_index { |j| j.end_time >= end_time } || jobs.size\\n    jobs.insert(insert_at, Job[server_no, end_time])\\n\\n    # count taken tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\\n\\n## Some refactoring\\nIntroduce `SortedArray` class with method `#add` and make jobs comparable by end time. \\n\\n```\\nclass Job < Struct.new(:server_no, :end_time)\\n  include Comparable\\n\\n  def <=>(other)\\n    end_time <=> other.end_time\\n  end\\nend\\n\\nclass SortedArray < Array\\n  def add(val)\\n    insert_at = bsearch_index { |n| n >= val } || size\\n    insert(insert_at, val)\\n  end\\nend\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = SortedArray.new(k) { |i| i } # available servers\\n  jobs = SortedArray.new # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      servers.add(jobs.shift.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    server_no = servers.delete_at(servers.bsearch_index { |n| n >= ik } || 0)\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    jobs.add(Job[server_no, time + duration])\\n\\n    # count assigned tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef busiest_servers(k, arrival, load)\\n  job_end_times = [0] * k # busy till time per sever\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    cond = proc { |j| job_end_times[j] <= time }\\n    j = (i % k...k).find(&cond) || (0...i % k).find(&cond) # O(K)\\n    next unless j\\n\\n    job_end_times[j] = time + duration\\n\\n    # count taken tasks\\n    cnt[j] += 1\\n    max_cnt = cnt[j] if cnt[j] > max_cnt\\n  end\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\n```\\nJob = Struct.new(:server_no, :end_time)\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = *0...k # available servers\\n  jobs = [] # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      job = jobs.delete_at(0)\\n      insert_at = servers.bsearch_index { |n| n >= job.server_no } || servers.size\\n      servers.insert(insert_at, job.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    j = servers.bsearch_index { |n| n >= ik } || 0\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    server_no = servers.delete_at(j)\\n    end_time = time + duration\\n    insert_at = jobs.bsearch_index { |j| j.end_time >= end_time } || jobs.size\\n    jobs.insert(insert_at, Job[server_no, end_time])\\n\\n    # count taken tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\n```\\nclass Job < Struct.new(:server_no, :end_time)\\n  include Comparable\\n\\n  def <=>(other)\\n    end_time <=> other.end_time\\n  end\\nend\\n\\nclass SortedArray < Array\\n  def add(val)\\n    insert_at = bsearch_index { |n| n >= val } || size\\n    insert(insert_at, val)\\n  end\\nend\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = SortedArray.new(k) { |i| i } # available servers\\n  jobs = SortedArray.new # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      servers.add(jobs.shift.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    server_no = servers.delete_at(servers.bsearch_index { |n| n >= ik } || 0)\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    jobs.add(Job[server_no, time + duration])\\n\\n    # count assigned tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885027,
                "title": "cpp14-solution-priority-queue-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> s;\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > pq;\\n        int n = int(arrival.size());\\n        unordered_map<int,int> mpp;\\n        for(int i = 0 ; i < k ; ++i) s.insert(i);\\n        for(int i = 0 ; i < n ; ++i){\\n            int start = arrival[i];\\n            int end   = start + load[i];\\n            while(1){\\n                if(pq.empty() == true) break;\\n                int currentending = pq.top().first;\\n                if(currentending <= start){\\n                    s.insert(pq.top().second);\\n                    pq.pop();\\n                    continue;\\n                }\\n                else break;\\n            }\\n            if(s.size() == 0) continue;\\n            int first = i % k ;\\n            auto it = s.find(first);\\n            if(it != s.end()){\\n                s.erase(s.find(first));\\n                pq.push({end , first});\\n                mpp[first]++;\\n                continue;\\n            }\\n            else if(it == s.end()){\\n                auto itr = s.lower_bound(first);\\n                if(itr == s.end()){\\n                    itr = s.begin();\\n                }\\n                int now = *itr;\\n                mpp[now]++;\\n                pq.push({end , now});\\n                s.erase(s.find(now));\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = INT_MIN;\\n        for(auto x : mpp) maxx = max(maxx , x.second) ;\\n        for(auto x : mpp) if(x.second == maxx){\\n            ans.push_back(x.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> s;\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > pq;\\n        int n = int(arrival.size());\\n        unordered_map<int,int> mpp;\\n        for(int i = 0 ; i < k ; ++i) s.insert(i);\\n        for(int i = 0 ; i < n ; ++i){\\n            int start = arrival[i];\\n            int end   = start + load[i];\\n            while(1){\\n                if(pq.empty() == true) break;\\n                int currentending = pq.top().first;\\n                if(currentending <= start){\\n                    s.insert(pq.top().second);\\n                    pq.pop();\\n                    continue;\\n                }\\n                else break;\\n            }\\n            if(s.size() == 0) continue;\\n            int first = i % k ;\\n            auto it = s.find(first);\\n            if(it != s.end()){\\n                s.erase(s.find(first));\\n                pq.push({end , first});\\n                mpp[first]++;\\n                continue;\\n            }\\n            else if(it == s.end()){\\n                auto itr = s.lower_bound(first);\\n                if(itr == s.end()){\\n                    itr = s.begin();\\n                }\\n                int now = *itr;\\n                mpp[now]++;\\n                pq.push({end , now});\\n                s.erase(s.find(now));\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = INT_MIN;\\n        for(auto x : mpp) maxx = max(maxx , x.second) ;\\n        for(auto x : mpp) if(x.second == maxx){\\n            ans.push_back(x.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883952,
                "title": "treemap-priority-queue-based-solution",
                "content": "set is List of Server\\nmap is for request processed\\nPriorityQueue to know when that server will be free \\n\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer>  set  = new TreeSet<>();\\n        HashMap<Integer, Integer> map =  new HashMap<>();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {return a[0] - b[0];});\\n        int l = arrival.length;\\n        \\n        for(int  i = 0; i < k; i++)\\n            set.add(i);\\n        \\n        int maxReq = 0;\\n        for(int i  = 0; i < l; i++) {\\n            int exp = i%k;\\n            int at = arrival[i];\\n            \\n            while(!pq.isEmpty() && pq.peek()[0] <=  at ) {\\n                int tarr[] = pq.poll();\\n                set.add(tarr[1]);\\n            }\\n            \\n             Integer server =  set.ceiling(exp);\\n             if(server == null){\\n               server =  set.ceiling(0);\\n             }\\n            if(server == null){\\n                continue;\\n            }\\n            set.remove(server);\\n            pq.add(new int[] {arrival[i] + load[i], server});\\n            map.put( server, map.getOrDefault( server, 0)+ 1);\\n            if(maxReq < map.get(server))\\n                maxReq = map.get(server);\\n        }\\n        \\n        List<Integer>  list  = new ArrayList<>();\\n        for( Map.Entry<Integer, Integer>  e : map.entrySet()) {\\n            if(e.getValue() ==  maxReq)\\n                list.add(e.getKey());\\n        }\\n        \\n        return list;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer>  set  = new TreeSet<>();\\n        HashMap<Integer, Integer> map =  new HashMap<>();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {return a[0] - b[0];}",
                "codeTag": "Java"
            },
            {
                "id": 883302,
                "title": "c-version-timeout-2-versions",
                "content": "**simple version (107 of 108 passed)**\\n```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            var servers = Enumerable.Repeat(1, k).ToArray();\\n\\n            var loadCount = new int[k];\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (servers[serverIndex] <= arrival[i])\\n                    {\\n                        servers[serverIndex] = arrival[i] + load[i];\\n                        loadCount[serverIndex]++;\\n                        if (loadCount[serverIndex] > max)\\n                        {\\n                            max = loadCount[serverIndex];\\n                        }\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == servers.Length)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n            List<int> result = GetResult(loadCount, max);\\n\\n            return result;\\n        }\\n\\n        private static List<int> GetResult(int[] loadCount, int max)\\n        {\\n            var result = new List<int>();\\n            for (int i = 0; i < loadCount.Length; i++)\\n            {\\n                if (loadCount[i] == max)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```\\n\\n\\n**using sortedset\\n105 / 108 test cases passed.**\\n```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests_2\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            SortedSet<Server> busyServers = new SortedSet<Server>(new BusyServerComparer());\\n            SortedDictionary<int, Server> freeServers = new SortedDictionary<int, Server>();\\n            for (int i = 0; i < k; i++)\\n            {\\n                freeServers.Add(i, new Server { Index = i });\\n            }\\n\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                while ((busyServers.Count > 0) && (busyServers.First().BusyUntil <= arrival[i]))\\n                {\\n                    var srv = busyServers.First();\\n                    freeServers.Add(srv.Index, srv);\\n                    busyServers.Remove(srv);\\n                }\\n\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (freeServers.ContainsKey(serverIndex))\\n                    {\\n                        var srv = freeServers[serverIndex];\\n                        srv.BusyUntil = arrival[i] + load[i];\\n                        srv.Used++;\\n                        if (srv.Used > max)\\n                        {\\n                            max = srv.Used;\\n                        }\\n                        busyServers.Add(srv);\\n                        freeServers.Remove(srv.Index);\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == k)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n\\n            List<int> result = new List<int>();\\n            foreach (var sr in busyServers)\\n            {\\n                if (sr.Used == max)\\n                    result.Add(sr.Index);\\n            }\\n\\n            foreach (var sr in freeServers)\\n            {\\n                if (sr.Value.Used == max)\\n                    result.Add(sr.Key);\\n            }\\n\\n            return result;\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Index { get; set; }\\n        public int BusyUntil { get; set; }\\n        public int Used { get; set; }\\n    }\\n\\n    class BusyServerComparer : IComparer<Server>\\n    {\\n        public int Compare(Server a, Server b)\\n        { \\n            //first by BusyUntil\\n            int result = a.BusyUntil.CompareTo(b.BusyUntil);\\n\\n            //then index\\n            if (result == 0)\\n                result = a.Index.CompareTo(b.Index);\\n\\n\\n\\n            return result;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            var servers = Enumerable.Repeat(1, k).ToArray();\\n\\n            var loadCount = new int[k];\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (servers[serverIndex] <= arrival[i])\\n                    {\\n                        servers[serverIndex] = arrival[i] + load[i];\\n                        loadCount[serverIndex]++;\\n                        if (loadCount[serverIndex] > max)\\n                        {\\n                            max = loadCount[serverIndex];\\n                        }\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == servers.Length)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n            List<int> result = GetResult(loadCount, max);\\n\\n            return result;\\n        }\\n\\n        private static List<int> GetResult(int[] loadCount, int max)\\n        {\\n            var result = new List<int>();\\n            for (int i = 0; i < loadCount.Length; i++)\\n            {\\n                if (loadCount[i] == max)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```\n```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests_2\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            SortedSet<Server> busyServers = new SortedSet<Server>(new BusyServerComparer());\\n            SortedDictionary<int, Server> freeServers = new SortedDictionary<int, Server>();\\n            for (int i = 0; i < k; i++)\\n            {\\n                freeServers.Add(i, new Server { Index = i });\\n            }\\n\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                while ((busyServers.Count > 0) && (busyServers.First().BusyUntil <= arrival[i]))\\n                {\\n                    var srv = busyServers.First();\\n                    freeServers.Add(srv.Index, srv);\\n                    busyServers.Remove(srv);\\n                }\\n\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (freeServers.ContainsKey(serverIndex))\\n                    {\\n                        var srv = freeServers[serverIndex];\\n                        srv.BusyUntil = arrival[i] + load[i];\\n                        srv.Used++;\\n                        if (srv.Used > max)\\n                        {\\n                            max = srv.Used;\\n                        }\\n                        busyServers.Add(srv);\\n                        freeServers.Remove(srv.Index);\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == k)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n\\n            List<int> result = new List<int>();\\n            foreach (var sr in busyServers)\\n            {\\n                if (sr.Used == max)\\n                    result.Add(sr.Index);\\n            }\\n\\n            foreach (var sr in freeServers)\\n            {\\n                if (sr.Value.Used == max)\\n                    result.Add(sr.Key);\\n            }\\n\\n            return result;\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Index { get; set; }\\n        public int BusyUntil { get; set; }\\n        public int Used { get; set; }\\n    }\\n\\n    class BusyServerComparer : IComparer<Server>\\n    {\\n        public int Compare(Server a, Server b)\\n        { \\n            //first by BusyUntil\\n            int result = a.BusyUntil.CompareTo(b.BusyUntil);\\n\\n            //then index\\n            if (result == 0)\\n                result = a.Index.CompareTo(b.Index);\\n\\n\\n\\n            return result;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882858,
                "title": "java-solution-treeset-less-code",
                "content": "```\\nclass Solution {\\n    \\n    class Server {\\n        int idx;\\n        int load=0;\\n        int cnt=0;\\n        Server(int idx, int load){\\n            this.idx = idx;\\n            this.load = load;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Server> set1 = new TreeSet<>((a, b)->{return a.idx-b.idx;});  // sort by index\\n        TreeSet<Server> set2 = new TreeSet<>((a, b)->{return a.load == b.load?a.idx-b.idx:a.load-b.load;}); // sort by load\\n        \\n        for(int i=0; i<k; i++)\\n            set1.add(new Server(i, 0));\\n\\t\\t\\t\\n        int max = 0;\\n     \\n        for(int i=0; i<arrival.length; i++){\\n\\t\\t    // for each loop, \\n\\t\\t\\t// get all available servers from set2 and add to set1, \\n\\t\\t\\t// get the first available server from set1, update the load and cnt\\n\\t\\t\\t// put the server to set2\\n            \\n            Set<Server> sub = set2.headSet(new Server(999999, arrival[i]));\\n            Iterator<Server> it = sub.iterator();\\n            \\n            while(it.hasNext()){\\n                Server next = it.next();\\n                it.remove();\\n                set1.add(next);\\n            }\\n\\n            if(set1.isEmpty()) continue; // no available server\\n            Server ser = set1.ceiling(new Server(i%k, 0));\\n            if(ser==null) ser=set1.first();\\n            ser.load=arrival[i]+load[i];\\n            ser.cnt++;\\n            set1.remove(ser);\\n            set2.add(ser);\\n            \\n            max = Math.max(max, ser.cnt);\\n        }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(Server s:set1) if(s.cnt==max) list.add(s.idx);\\n        for(Server s:set2) if(s.cnt==max) list.add(s.idx);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Server {\\n        int idx;\\n        int load=0;\\n        int cnt=0;\\n        Server(int idx, int load){\\n            this.idx = idx;\\n            this.load = load;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Server> set1 = new TreeSet<>((a, b)->{return a.idx-b.idx;});  // sort by index\\n        TreeSet<Server> set2 = new TreeSet<>((a, b)->{return a.load == b.load?a.idx-b.idx:a.load-b.load;}); // sort by load\\n        \\n        for(int i=0; i<k; i++)\\n            set1.add(new Server(i, 0));\\n\\t\\t\\t\\n        int max = 0;\\n     \\n        for(int i=0; i<arrival.length; i++){\\n\\t\\t    // for each loop, \\n\\t\\t\\t// get all available servers from set2 and add to set1, \\n\\t\\t\\t// get the first available server from set1, update the load and cnt\\n\\t\\t\\t// put the server to set2\\n            \\n            Set<Server> sub = set2.headSet(new Server(999999, arrival[i]));\\n            Iterator<Server> it = sub.iterator();\\n            \\n            while(it.hasNext()){\\n                Server next = it.next();\\n                it.remove();\\n                set1.add(next);\\n            }\\n\\n            if(set1.isEmpty()) continue; // no available server\\n            Server ser = set1.ceiling(new Server(i%k, 0));\\n            if(ser==null) ser=set1.first();\\n            ser.load=arrival[i]+load[i];\\n            ser.cnt++;\\n            set1.remove(ser);\\n            set2.add(ser);\\n            \\n            max = Math.max(max, ser.cnt);\\n        }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(Server s:set1) if(s.cnt==max) list.add(s.idx);\\n        for(Server s:set2) if(s.cnt==max) list.add(s.idx);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880610,
                "title": "priority-queue-and-set-hashmap-in-c-o-nlog-k",
                "content": "class Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        set<int> availables;\\n        for (int i = 0; i < k; ++i) {\\n            availables.insert(i);\\n        }\\n        vector<int> count(k);\\n        for (int i = 0; i < size(arrival); ++i) {\\n            while (!empty(min_heap) && min_heap.top().first <= arrival[i]) {\\n                pair<int,int>v = min_heap.top();\\n                min_heap.pop();\\n                availables.insert(v.second);\\n            }\\n            if (empty(availables)) {\\n                continue;\\n            }\\n            auto it = availables.lower_bound(i % k);\\n            if (it == end(availables)) {\\n                it = begin(availables);\\n            }\\n            ++count[*it];\\n            min_heap.emplace(arrival[i] + load[i], *it);\\n            availables.erase(it);\\n        }\\n        int max_count = *max_element(cbegin(count), cend(count));\\n        vector<int> result;\\n        for (int i = 0; i < k; ++i) {\\n            if (count[i] == max_count) {\\n                result.emplace_back(i);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity - O(nlogK)\\nSpace Complexity - O(K)\\nHope this will be helpful",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        set<int> availables;\\n        for (int i = 0; i < k; ++i) {\\n            availables.insert(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 880103,
                "title": "python-heap-sortedlist",
                "content": "Heap tracks working servers and SortedList stores idle servers.\\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        num_tasks = [0] * k\\n        heap = []\\n        sl = SortedList([i for i in range(k)] + [i+k for i in range(k)])\\n        for i, (s, t) in enumerate(zip(arrival, load)):\\n            i %= k\\n            while heap and heap[0][0] <= s:\\n                _, j = heapq.heappop(heap)\\n                sl.add(j)\\n                sl.add(j+k)\\n            if len(sl):\\n                j = sl[sl.bisect_left(i)] % k\\n                sl.remove(j)\\n                sl.remove(j+k)\\n                num_tasks[j] += 1\\n                heapq.heappush(heap, (s+t, j))\\n        m = max(num_tasks)\\n        return [i for i, n in enumerate(num_tasks) if n == m]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        num_tasks = [0] * k\\n        heap = []\\n        sl = SortedList([i for i in range(k)] + [i+k for i in range(k)])\\n        for i, (s, t) in enumerate(zip(arrival, load)):\\n            i %= k\\n            while heap and heap[0][0] <= s:\\n                _, j = heapq.heappop(heap)\\n                sl.add(j)\\n                sl.add(j+k)\\n            if len(sl):\\n                j = sl[sl.bisect_left(i)] % k\\n                sl.remove(j)\\n                sl.remove(j+k)\\n                num_tasks[j] += 1\\n                heapq.heappush(heap, (s+t, j))\\n        m = max(num_tasks)\\n        return [i for i, n in enumerate(num_tasks) if n == m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880095,
                "title": "java-o-nlogn-using-only-treeset",
                "content": "Idea is simple, we maintain a sorted list of free servers (initially all servers are free) and process request endpoints (start & end) in order of increasing time. If its end of req, we remove from free servers. We first look for request index (ri) % k. If this server is free, then we use it, otherwise we look for next free server with index > ri, and we remove from free servers.\\nWe maintain count in an array for each server and return servers with max no of req at the end.\\n\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n\\n    static class Point {\\n        private final int x, index;\\n        private final boolean start;\\n\\n        Point(int x, int index, boolean start) {\\n            this.x = x;\\n            this.index = index;\\n            this.start = start;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        // INIT\\n        TreeSet<Integer> free = new TreeSet<>();\\n        Map<Integer, Integer> reqToServer = new HashMap<>();\\n        Integer[] servers = new Integer[k];\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n            servers[i] = i;\\n        }\\n\\n        // BUILD POINTS TO PROCESS\\n        List<Point> points = buildPointsToProcess(arrival, load);\\n\\n        // PROCESS POINTS\\n        int[] count = new int[k];\\n        for (Point point : points) {\\n            processPoint(k, free, reqToServer, servers, count, point);\\n        }\\n\\n        // CALC ANS\\n        return findServersWithMaxReq(k, count);\\n    }\\n\\n    private void processPoint(int k, TreeSet<Integer> free, Map<Integer, Integer> reqToServer, Integer[] servers,\\n            int[] count, Point point) {\\n\\n        if (!point.start) {\\n\\n            // PROCESS END OF REQ\\n            if (reqToServer.containsKey(point.index)) {\\n                Integer s = reqToServer.get(point.index);\\n                reqToServer.remove(point.index);\\n                free.add(s);\\n            }\\n            return;\\n        }\\n\\n        if (free.isEmpty()) {\\n\\n            // DROP REQ\\n            return;\\n        }\\n\\n        // FIND A FREE SERVER TO PROCESS REQ\\n        int ri = point.index % k;\\n        Integer server;\\n        if (free.contains(servers[ri])) {\\n\\n            // CURR SERVER CAN HANDLE REQ\\n            server = servers[ri];\\n        } else {\\n\\n            // LOOK FOR FREE SERVER WITH HIGHER INDEX THAN s\\n            server = free.higher(servers[ri]);\\n            if (server == null) {\\n\\n                // LOOK FOR FREE SERVER WITH LOWEST INDEX\\n                server = free.higher(-1);\\n            }\\n        }\\n\\n        // SERVE REQUEST\\n        free.remove(server);\\n        count[server]++;\\n        reqToServer.put(point.index, server);\\n    }\\n\\n    private List<Point> buildPointsToProcess(int[] arrival, int[] load) {\\n        List<Point> points = new ArrayList<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            points.add(new Point(arrival[i], i, true));\\n            points.add(new Point(arrival[i] + load[i], i, false));\\n        }\\n        points.sort((p1, p2) -> {\\n            int compare = Integer.compare(p1.x, p2.x);\\n            if (compare != 0) {\\n                return compare;\\n            }\\n            if (!p1.start && p2.start) {\\n                return -1;\\n            }\\n            if (p1.start && !p2.start) {\\n                return 1;\\n            }\\n            return Integer.compare(p1.index, p2.index);\\n        });\\n        return points;\\n    }\\n\\n    private List<Integer> findServersWithMaxReq(int k, int[] count) {\\n\\n        // FIND MAX\\n        int maxc = Integer.MIN_VALUE;\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] > maxc) {\\n                maxc = count[i];\\n            }\\n        }\\n\\n        // FIND ALL VALUES = MAX\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxc) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n\\n    static class Point {\\n        private final int x, index;\\n        private final boolean start;\\n\\n        Point(int x, int index, boolean start) {\\n            this.x = x;\\n            this.index = index;\\n            this.start = start;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        // INIT\\n        TreeSet<Integer> free = new TreeSet<>();\\n        Map<Integer, Integer> reqToServer = new HashMap<>();\\n        Integer[] servers = new Integer[k];\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n            servers[i] = i;\\n        }\\n\\n        // BUILD POINTS TO PROCESS\\n        List<Point> points = buildPointsToProcess(arrival, load);\\n\\n        // PROCESS POINTS\\n        int[] count = new int[k];\\n        for (Point point : points) {\\n            processPoint(k, free, reqToServer, servers, count, point);\\n        }\\n\\n        // CALC ANS\\n        return findServersWithMaxReq(k, count);\\n    }\\n\\n    private void processPoint(int k, TreeSet<Integer> free, Map<Integer, Integer> reqToServer, Integer[] servers,\\n            int[] count, Point point) {\\n\\n        if (!point.start) {\\n\\n            // PROCESS END OF REQ\\n            if (reqToServer.containsKey(point.index)) {\\n                Integer s = reqToServer.get(point.index);\\n                reqToServer.remove(point.index);\\n                free.add(s);\\n            }\\n            return;\\n        }\\n\\n        if (free.isEmpty()) {\\n\\n            // DROP REQ\\n            return;\\n        }\\n\\n        // FIND A FREE SERVER TO PROCESS REQ\\n        int ri = point.index % k;\\n        Integer server;\\n        if (free.contains(servers[ri])) {\\n\\n            // CURR SERVER CAN HANDLE REQ\\n            server = servers[ri];\\n        } else {\\n\\n            // LOOK FOR FREE SERVER WITH HIGHER INDEX THAN s\\n            server = free.higher(servers[ri]);\\n            if (server == null) {\\n\\n                // LOOK FOR FREE SERVER WITH LOWEST INDEX\\n                server = free.higher(-1);\\n            }\\n        }\\n\\n        // SERVE REQUEST\\n        free.remove(server);\\n        count[server]++;\\n        reqToServer.put(point.index, server);\\n    }\\n\\n    private List<Point> buildPointsToProcess(int[] arrival, int[] load) {\\n        List<Point> points = new ArrayList<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            points.add(new Point(arrival[i], i, true));\\n            points.add(new Point(arrival[i] + load[i], i, false));\\n        }\\n        points.sort((p1, p2) -> {\\n            int compare = Integer.compare(p1.x, p2.x);\\n            if (compare != 0) {\\n                return compare;\\n            }\\n            if (!p1.start && p2.start) {\\n                return -1;\\n            }\\n            if (p1.start && !p2.start) {\\n                return 1;\\n            }\\n            return Integer.compare(p1.index, p2.index);\\n        });\\n        return points;\\n    }\\n\\n    private List<Integer> findServersWithMaxReq(int k, int[] count) {\\n\\n        // FIND MAX\\n        int maxc = Integer.MIN_VALUE;\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] > maxc) {\\n                maxc = count[i];\\n            }\\n        }\\n\\n        // FIND ALL VALUES = MAX\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxc) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878620,
                "title": "c-simple",
                "content": "```\\nstruct Node{\\n        int sid;\\n        int endTime;\\n    };\\n    \\n    struct CompareTime{\\n        bool operator()(const Node & lhs, const Node & rhs){\\n           return lhs.endTime > rhs.endTime; \\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        if(arrival.size() <= k){\\n            vector<int> ans;\\n            for(int i=0;i<min((int)arrival.size(), k);i++)\\n                ans.push_back(i);\\n            return ans;\\n        }\\n        vector<bool> available(k, true);\\n        priority_queue<Node, vector<Node>, CompareTime> pq;\\n        unordered_map<int, int> count;\\n        set<int> availableServers;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        int maxCount = -1;\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            while(!pq.empty() && pq.top().endTime <= arrival[i]){\\n                availableServers.insert(pq.top().sid);\\n                available[pq.top().sid] = true;\\n                pq.pop();\\n            }\\n            if(available[i%k]){\\n                count[i%k]++;\\n                maxCount = max(maxCount, count[i%k]);\\n                available[i%k] = false;\\n                availableServers.erase(i%k);\\n                Node n;\\n                n.sid = i%k;\\n                n.endTime = arrival[i] + load[i];\\n                pq.push(n);\\n            }\\n            else if(!available[i%k] && !availableServers.empty()){\\n                int id = -1;\\n                auto it = availableServers.lower_bound(i%k);\\n                auto it2 = availableServers.lower_bound(INT_MAX);\\n                if(i%k < *it)\\n                    id = *it;\\n                if( availableServers.size() > 1 && *it == *it2 && ( i%k > *it)){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                else if(availableServers.size() == 1 ){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                if(id!= -1 && available[id]){\\n                    available[id] = false;\\n                    availableServers.erase(id);\\n                    count[id]++;\\n                    maxCount = max(maxCount, count[id]);\\n                    Node n;\\n                    n.sid = id;\\n                    n.endTime = arrival[i]+ load[i];\\n                    pq.push(n);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = count.begin(); it!= count.end(); it++)\\n            if(it->second == maxCount)\\n                ans.push_back(it->first);\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n        int sid;\\n        int endTime;\\n    };\\n    \\n    struct CompareTime{\\n        bool operator()(const Node & lhs, const Node & rhs){\\n           return lhs.endTime > rhs.endTime; \\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        if(arrival.size() <= k){\\n            vector<int> ans;\\n            for(int i=0;i<min((int)arrival.size(), k);i++)\\n                ans.push_back(i);\\n            return ans;\\n        }\\n        vector<bool> available(k, true);\\n        priority_queue<Node, vector<Node>, CompareTime> pq;\\n        unordered_map<int, int> count;\\n        set<int> availableServers;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        int maxCount = -1;\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            while(!pq.empty() && pq.top().endTime <= arrival[i]){\\n                availableServers.insert(pq.top().sid);\\n                available[pq.top().sid] = true;\\n                pq.pop();\\n            }\\n            if(available[i%k]){\\n                count[i%k]++;\\n                maxCount = max(maxCount, count[i%k]);\\n                available[i%k] = false;\\n                availableServers.erase(i%k);\\n                Node n;\\n                n.sid = i%k;\\n                n.endTime = arrival[i] + load[i];\\n                pq.push(n);\\n            }\\n            else if(!available[i%k] && !availableServers.empty()){\\n                int id = -1;\\n                auto it = availableServers.lower_bound(i%k);\\n                auto it2 = availableServers.lower_bound(INT_MAX);\\n                if(i%k < *it)\\n                    id = *it;\\n                if( availableServers.size() > 1 && *it == *it2 && ( i%k > *it)){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                else if(availableServers.size() == 1 ){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                if(id!= -1 && available[id]){\\n                    available[id] = false;\\n                    availableServers.erase(id);\\n                    count[id]++;\\n                    maxCount = max(maxCount, count[id]);\\n                    Node n;\\n                    n.sid = id;\\n                    n.endTime = arrival[i]+ load[i];\\n                    pq.push(n);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = count.begin(); it!= count.end(); it++)\\n            if(it->second == maxCount)\\n                ans.push_back(it->first);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878508,
                "title": "java-two-treemap",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] A, int[] load) {\\n        List<Integer>res=new ArrayList<>();    \\n        \\n        int servers[]=new int[k];\\n        TreeMap<Integer,List<Integer>>treemap=new TreeMap<>();\\n        TreeMap<Integer,Integer>treemap1=new TreeMap<>();\\n        \\n        for(int i=0;i<k;i++){\\n            treemap1.put(i,0);\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            int mod=i%k;\\n            int cur=A[i];\\n            \\n            Integer floor=treemap.floorKey(cur);\\n           \\n            if(floor!=null){\\n                List<Integer>clean=new ArrayList<>();\\n                \\n                for(Integer end:treemap.keySet()){\\n                    if(end>floor)break;\\n                    clean.add(end);\\n                    List<Integer>l=treemap.get(end);\\n                    for(int index:l){\\n                         treemap1.put(index,end);\\n                    }\\n                }\\n                \\n                for(Integer key:clean){\\n                    treemap.remove(key);\\n                }\\n            }\\n            \\n            Integer first=treemap1.ceilingKey(mod);\\n            if(first!=null){\\n                int index=first;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(first);\\n                continue;\\n            }\\n            \\n            Integer second=treemap1.ceilingKey(0);\\n            if(second!=null){\\n                int index=second;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(second);\\n  \\n            }\\n        }\\n        \\n        \\n        int max=0;\\n        for(int i:servers){\\n            max=Math.max(i,max);\\n        }\\n        for(int i=0;i<servers.length;i++){\\n            if(servers[i]==max)res.add(i);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] A, int[] load) {\\n        List<Integer>res=new ArrayList<>();    \\n        \\n        int servers[]=new int[k];\\n        TreeMap<Integer,List<Integer>>treemap=new TreeMap<>();\\n        TreeMap<Integer,Integer>treemap1=new TreeMap<>();\\n        \\n        for(int i=0;i<k;i++){\\n            treemap1.put(i,0);\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            int mod=i%k;\\n            int cur=A[i];\\n            \\n            Integer floor=treemap.floorKey(cur);\\n           \\n            if(floor!=null){\\n                List<Integer>clean=new ArrayList<>();\\n                \\n                for(Integer end:treemap.keySet()){\\n                    if(end>floor)break;\\n                    clean.add(end);\\n                    List<Integer>l=treemap.get(end);\\n                    for(int index:l){\\n                         treemap1.put(index,end);\\n                    }\\n                }\\n                \\n                for(Integer key:clean){\\n                    treemap.remove(key);\\n                }\\n            }\\n            \\n            Integer first=treemap1.ceilingKey(mod);\\n            if(first!=null){\\n                int index=first;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(first);\\n                continue;\\n            }\\n            \\n            Integer second=treemap1.ceilingKey(0);\\n            if(second!=null){\\n                int index=second;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(second);\\n  \\n            }\\n        }\\n        \\n        \\n        int max=0;\\n        for(int i:servers){\\n            max=Math.max(i,max);\\n        }\\n        for(int i=0;i<servers.length;i++){\\n            if(servers[i]==max)res.add(i);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878180,
                "title": "segment-tree-c-easy-explanation",
                "content": "```\\n#include <bits/stdc++.h>\\n#include<algorithm>\\n#include<string>\\nusing namespace std;\\n#define ll int\\n// #define int long long\\n#define ld long double\\n#define ff first\\n#define ss string \\n#define se second\\n#define endl \"\\\\n\"\\n#define ub upper_bound\\n#define lb lower_bound\\n#define clr(a,x) memset(a,x,sizeof(a))\\n#define alt(v) v.begin(),v.end()\\n#define ralt(v) v.rbegin(),v.rend()\\n#define pb emplace_back\\n#define mp make_pair\\nconst int N = 2e5+5;\\n\\n\\nll minseg[4*N];\\n\\n\\nvoid update(int nd,int ss,int se,int pos,ll val)\\n{\\n    if(ss > pos or se < pos)\\n        return;\\n    if(ss == se and se == pos)\\n    {\\n        minseg[nd] = val;\\n        return;\\n    }\\n    int mid = (ss+se)/2;\\n    update(2*nd,ss,mid,pos,val);\\n    update(2*nd+1,mid+1,se,pos,val);\\n    minseg[nd] = min(minseg[2*nd],minseg[2*nd+1]);\\n}\\n\\n// we find the smallest index j such that arr[j] <= k and j>=l.\\nint query(int nd,int ss,int se,ll k,int l)\\n{\\n    // the whole segment([ss,se]) not satisfy the condition j >= l and arr[j] <= k\\n    if(minseg[nd] > k or se < l)\\n        return -2;\\n    \\n    if(ss == se){\\n        if(minseg[nd] <= k)\\n            return se;\\n        // no element satisfy the given condition.\\n        return -1;\\n    }\\n    \\n    int mid = (ss+se)/2;\\n    int x = -2;\\n    // As we need smallest index so we go first left subtree then right if any element present\\n    // in left subtree that satisfy the given condition then we simply return that index otherwise\\n    // we go right subtree.\\n    x = query(2*nd,ss,mid,k,l);\\n    if(x != -2)\\n        return x;\\n    return query(2*nd+1,mid+1,se,k,l);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) \\n    {   \\n        // Everytime we start itteration from i%k(curserver) th server as we indicate server from 1 to k(not 0 to k-1) \\n        // so we increase the curserver value  by 1 to get actual server.   \\n        \\n        // If the curserver is 4 then we start to find 1st free server 4 - > 5 -> 6 - > 7 -> 8....-> k-> 1-> 2-> 3 in this way.\\n        // if we not get any free server then simply skip that request.\\n        \\n        // For that we build a circular array of 2*k length and every position indicate (position % k) th server.\\n        // i.e position array actually look like as = [1,2,3,4,5...k,1,2,3....k]\\n        \\n        // In every position we kept the time position%k th server take to finish last request.As initially every server free so \\n        // we initialize the array by 0.\\n        \\n        // i.e array look like arr = [0,0,0,0,0..0] and indexarray = [1,2,3,..k,k+1,k+2,k+3..k+k]\\n        \\n        //  Everytime we try to find index j that follow the given condition : ->\\n        //  i.> j >= curserver(i.e. i%k + 1)\\n        //  ii.> arr[j] <= arrival[i] (i.e. j th server take atmost arrival[i] time to finish last request).\\n        \\n        // Afterthat curserver will be j%k (if the index j = k+5 we indicate that as 5 th server).\\n        \\n        // we increae the value of cnt_req[curserver] by 1 as 1 more request added to that server.\\n        \\n        // Afterthat we update the value of arr[curserver] and arr[curserver + k] by arrival[i] + load[i].\\n        // i.e. curserver % k th server and (curserver + k)%k server take (arrival[i] + load[i]) time to finish that request.\\n        \\n        // As initially all element in the array is 0 so we initialize every node in segment tree by 0.\\n        for(int i = 1; i <= 8*k; ++i)\\n            minseg[i] = 0;\\n        \\n        vector<int>cnt_req(k+1,0); // initial with 0\\n        // cnt_req[i] indicate how many request finish by ith server.\\n        \\n        for(int i = 0; i < arrival.size();++i)\\n        {\\n            int curserver = i%k + 1;\\n            // query return the free index that is the value of arr[index] <= arrival[i]\\n            // and index >= curserver, if no server then it\\'s simply return -1. \\n            curserver = query(1,1,2*k,arrival[i],curserver);\\n            \\n            // no free server exist.\\n            if(curserver < 0)\\n                continue;\\n            \\n            curserver %= k;\\n            if(curserver == 0)\\n                curserver = k;\\n            \\n            cnt_req[curserver]++;\\n            update(1,1,2*k,curserver,arrival[i] + load[i]);\\n            update(1,1,2*k,curserver + k,arrival[i] + load[i]);\\n        }\\n        \\n        // iterate on cnt_req and find all busiest server.\\n        int mxval = *max_element(alt(cnt_req));\\n        vector<int>ans;\\n        \\n        for(int i = 1; i <= k; ++i)\\n            if(cnt_req[i] == mxval)\\n                ans.pb(i-1); // as question say server indicate 0 to k-1.\\n    \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\nTime - O(klogk)\\nIf any doubt regrading implementation and logic please comment below I am happy to help you.\\n",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\n#include<algorithm>\\n#include<string>\\nusing namespace std;\\n#define ll int\\n// #define int long long\\n#define ld long double\\n#define ff first\\n#define ss string \\n#define se second\\n#define endl \"\\\\n\"\\n#define ub upper_bound\\n#define lb lower_bound\\n#define clr(a,x) memset(a,x,sizeof(a))\\n#define alt(v) v.begin(),v.end()\\n#define ralt(v) v.rbegin(),v.rend()\\n#define pb emplace_back\\n#define mp make_pair\\nconst int N = 2e5+5;\\n\\n\\nll minseg[4*N];\\n\\n\\nvoid update(int nd,int ss,int se,int pos,ll val)\\n{\\n    if(ss > pos or se < pos)\\n        return;\\n    if(ss == se and se == pos)\\n    {\\n        minseg[nd] = val;\\n        return;\\n    }\\n    int mid = (ss+se)/2;\\n    update(2*nd,ss,mid,pos,val);\\n    update(2*nd+1,mid+1,se,pos,val);\\n    minseg[nd] = min(minseg[2*nd],minseg[2*nd+1]);\\n}\\n\\n// we find the smallest index j such that arr[j] <= k and j>=l.\\nint query(int nd,int ss,int se,ll k,int l)\\n{\\n    // the whole segment([ss,se]) not satisfy the condition j >= l and arr[j] <= k\\n    if(minseg[nd] > k or se < l)\\n        return -2;\\n    \\n    if(ss == se){\\n        if(minseg[nd] <= k)\\n            return se;\\n        // no element satisfy the given condition.\\n        return -1;\\n    }\\n    \\n    int mid = (ss+se)/2;\\n    int x = -2;\\n    // As we need smallest index so we go first left subtree then right if any element present\\n    // in left subtree that satisfy the given condition then we simply return that index otherwise\\n    // we go right subtree.\\n    x = query(2*nd,ss,mid,k,l);\\n    if(x != -2)\\n        return x;\\n    return query(2*nd+1,mid+1,se,k,l);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) \\n    {   \\n        // Everytime we start itteration from i%k(curserver) th server as we indicate server from 1 to k(not 0 to k-1) \\n        // so we increase the curserver value  by 1 to get actual server.   \\n        \\n        // If the curserver is 4 then we start to find 1st free server 4 - > 5 -> 6 - > 7 -> 8....-> k-> 1-> 2-> 3 in this way.\\n        // if we not get any free server then simply skip that request.\\n        \\n        // For that we build a circular array of 2*k length and every position indicate (position % k) th server.\\n        // i.e position array actually look like as = [1,2,3,4,5...k,1,2,3....k]\\n        \\n        // In every position we kept the time position%k th server take to finish last request.As initially every server free so \\n        // we initialize the array by 0.\\n        \\n        // i.e array look like arr = [0,0,0,0,0..0] and indexarray = [1,2,3,..k,k+1,k+2,k+3..k+k]\\n        \\n        //  Everytime we try to find index j that follow the given condition : ->\\n        //  i.> j >= curserver(i.e. i%k + 1)\\n        //  ii.> arr[j] <= arrival[i] (i.e. j th server take atmost arrival[i] time to finish last request).\\n        \\n        // Afterthat curserver will be j%k (if the index j = k+5 we indicate that as 5 th server).\\n        \\n        // we increae the value of cnt_req[curserver] by 1 as 1 more request added to that server.\\n        \\n        // Afterthat we update the value of arr[curserver] and arr[curserver + k] by arrival[i] + load[i].\\n        // i.e. curserver % k th server and (curserver + k)%k server take (arrival[i] + load[i]) time to finish that request.\\n        \\n        // As initially all element in the array is 0 so we initialize every node in segment tree by 0.\\n        for(int i = 1; i <= 8*k; ++i)\\n            minseg[i] = 0;\\n        \\n        vector<int>cnt_req(k+1,0); // initial with 0\\n        // cnt_req[i] indicate how many request finish by ith server.\\n        \\n        for(int i = 0; i < arrival.size();++i)\\n        {\\n            int curserver = i%k + 1;\\n            // query return the free index that is the value of arr[index] <= arrival[i]\\n            // and index >= curserver, if no server then it\\'s simply return -1. \\n            curserver = query(1,1,2*k,arrival[i],curserver);\\n            \\n            // no free server exist.\\n            if(curserver < 0)\\n                continue;\\n            \\n            curserver %= k;\\n            if(curserver == 0)\\n                curserver = k;\\n            \\n            cnt_req[curserver]++;\\n            update(1,1,2*k,curserver,arrival[i] + load[i]);\\n            update(1,1,2*k,curserver + k,arrival[i] + load[i]);\\n        }\\n        \\n        // iterate on cnt_req and find all busiest server.\\n        int mxval = *max_element(alt(cnt_req));\\n        vector<int>ans;\\n        \\n        for(int i = 1; i <= k; ++i)\\n            if(cnt_req[i] == mxval)\\n                ans.pb(i-1); // as question say server indicate 0 to k-1.\\n    \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 878101,
                "title": "use-set-and-priority-queue-to-record-the-id-of-server-idle-and-in-working",
                "content": "Use `\\tset<int> idle` to record the idle server id, and find the next usable one in `log(k)` time. i.e. first use `lower_bound` to search server those id is greater than or equal `i % p`. And if find none, just choose the smallest id.\\n\\nUse `priority_queue<pair<int, int>> work` to remember the server in working and the time it finish the current request. When a new requent arrives, we populate those server that will be idle at that time.\\n\\n``` c++\\nvector<int> busiestServers(int K, vector<int>& A, vector<int>& load)\\n{\\n  vector<int> req(K);\\n  set<int> idle;\\n  priority_queue<pair<int, int>> work;\\n  for (int i = 0; i < K; ++i)\\n    idle.insert(i);\\n\\n  int len = static_cast<int>(A.size());\\n  for (int i = 0; i < len; ++i)\\n  {\\n    int f = A[i];\\n    int t = f + load[i];\\n    int p = i % K;\\n    while (!work.empty())\\n    {\\n      auto ei = work.top();\\n      if (ei.first < -f)\\n        break;\\n      idle.insert(ei.second);\\n      work.pop();\\n    }\\n    if (idle.empty())\\n      continue;\\n    auto it = idle.lower_bound(p);\\n    if (it == idle.end())\\n      it = idle.begin();\\n    p = *it;\\n    idle.erase(it);\\n    work.push({ -t, p });\\n    req[p] += 1;\\n  }\\n\\n  int num = 0;\\n  vector<int> ans;\\n  for (int i = 0; i < K; ++i)\\n    num = max(num, req[i]);\\n  for (int i = 0; i < K; ++i)\\n  {\\n    if (req[i] == num)\\n      ans.push_back(i);\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "``` c++\\nvector<int> busiestServers(int K, vector<int>& A, vector<int>& load)\\n{\\n  vector<int> req(K);\\n  set<int> idle;\\n  priority_queue<pair<int, int>> work;\\n  for (int i = 0; i < K; ++i)\\n    idle.insert(i);\\n\\n  int len = static_cast<int>(A.size());\\n  for (int i = 0; i < len; ++i)\\n  {\\n    int f = A[i];\\n    int t = f + load[i];\\n    int p = i % K;\\n    while (!work.empty())\\n    {\\n      auto ei = work.top();\\n      if (ei.first < -f)\\n        break;\\n      idle.insert(ei.second);\\n      work.pop();\\n    }\\n    if (idle.empty())\\n      continue;\\n    auto it = idle.lower_bound(p);\\n    if (it == idle.end())\\n      it = idle.begin();\\n    p = *it;\\n    idle.erase(it);\\n    work.push({ -t, p });\\n    req[p] += 1;\\n  }\\n\\n  int num = 0;\\n  vector<int> ans;\\n  for (int i = 0; i < K; ++i)\\n    num = max(num, req[i]);\\n  for (int i = 0; i < K; ++i)\\n  {\\n    if (req[i] == num)\\n      ans.push_back(i);\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877970,
                "title": "simple-c-find-the-first-trailing-one",
                "content": "```\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\tvector<int> res;\\n\\tset<int> mySet;\\n\\tvector<int> cnt(k, 0);\\n\\tstd::set<int>::iterator it;\\n\\tint maxVal = 0;\\n\\n\\tfor (int i = 0; i < k; ++i) mySet.insert(i);\\n\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> myQueue;\\n\\n\\tfor (int i = 0; i < arrival.size(); ++i) {\\n\\n\\t\\twhile (!myQueue.empty() && myQueue.top().first <= arrival[i]) {\\n\\t\\t\\tmySet.insert(myQueue.top().second);\\n\\t\\t\\tmyQueue.pop();\\n\\t\\t}\\n\\n\\t\\tif (mySet.empty()) continue;\\n\\n\\t\\tit = mySet.lower_bound(i % k);\\n\\n\\t\\tif (it == mySet.end()) it = mySet.begin();\\n\\n\\t\\t++cnt[*it];\\n\\t\\tmaxVal = max(maxVal, cnt[*it]);\\n\\n\\t\\tmyQueue.push({arrival[i] + load[i], *it});\\n\\t\\tmySet.erase(it);\\n\\t}\\n\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tif (cnt[i] == maxVal) res.push_back(i);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\tvector<int> res;\\n\\tset<int> mySet;\\n\\tvector<int> cnt(k, 0);\\n\\tstd::set<int>::iterator it;\\n\\tint maxVal = 0;\\n\\n\\tfor (int i = 0; i < k; ++i) mySet.insert(i);\\n\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> myQueue;\\n\\n\\tfor (int i = 0; i < arrival.size(); ++i) {\\n\\n\\t\\twhile (!myQueue.empty() && myQueue.top().first <= arrival[i]) {\\n\\t\\t\\tmySet.insert(myQueue.top().second);\\n\\t\\t\\tmyQueue.pop();\\n\\t\\t}\\n\\n\\t\\tif (mySet.empty()) continue;\\n\\n\\t\\tit = mySet.lower_bound(i % k);\\n\\n\\t\\tif (it == mySet.end()) it = mySet.begin();\\n\\n\\t\\t++cnt[*it];\\n\\t\\tmaxVal = max(maxVal, cnt[*it]);\\n\\n\\t\\tmyQueue.push({arrival[i] + load[i], *it});\\n\\t\\tmySet.erase(it);\\n\\t}\\n\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tif (cnt[i] == maxVal) res.push_back(i);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877674,
                "title": "rust-translated-80ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        use std::collections::{BTreeSet, BinaryHeap};\\n\\n        let mut freq = vec![0; k as usize];\\n        let mut max = 0;\\n        let mut free = BTreeSet::<i32>::new();\\n        let mut busy = BinaryHeap::<(i32, i32)>::new(); // (avail(x), x)\\n        for i in 0..k {\\n            free.insert(i as i32);\\n        }\\n\\n        for i in 0..arrival.len() {\\n            while !busy.is_empty() && -busy.peek().unwrap().0 <= arrival[i] {\\n                free.insert(busy.pop().unwrap().1);\\n            }\\n            if free.is_empty() {\\n                continue;\\n            }\\n            let pos = i % k as usize;\\n            if free.contains(&(pos as i32)) {\\n                free.remove(&(pos as i32));\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, pos as i32));\\n                freq[pos as usize] += 1;\\n                if freq[pos] > max {\\n                    max = freq[pos];\\n                }\\n            } else {\\n                let mut next = free.range(pos as i32..).next();\\n                if next.is_none() {\\n                    next = free.range(0..).next();\\n                }\\n                let x = *next.unwrap();\\n                free.remove(&x);\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, x));\\n                freq[x as usize] += 1;\\n                if freq[x as usize] > max {\\n                    max = freq[x as usize];\\n                }\\n            }\\n        }\\n\\n        let mut ans = vec![];\\n        for (i, &x) in freq.iter().enumerate() {\\n            if x == max {\\n                ans.push(i as i32)\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_busiest_servers() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 5], vec![5, 2, 3, 3, 3]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_02() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4], vec![1, 2, 1, 2]),\\n            vec![0]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_03() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3], vec![10, 12, 11]),\\n            vec![0, 1, 2]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_04() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 8, 9, 10], vec![5, 2, 10, 3, 1, 2, 2]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_05() {\\n        assert_eq!(Solution::busiest_servers(1, vec![1], vec![1]), vec![0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        use std::collections::{BTreeSet, BinaryHeap};\\n\\n        let mut freq = vec![0; k as usize];\\n        let mut max = 0;\\n        let mut free = BTreeSet::<i32>::new();\\n        let mut busy = BinaryHeap::<(i32, i32)>::new(); // (avail(x), x)\\n        for i in 0..k {\\n            free.insert(i as i32);\\n        }\\n\\n        for i in 0..arrival.len() {\\n            while !busy.is_empty() && -busy.peek().unwrap().0 <= arrival[i] {\\n                free.insert(busy.pop().unwrap().1);\\n            }\\n            if free.is_empty() {\\n                continue;\\n            }\\n            let pos = i % k as usize;\\n            if free.contains(&(pos as i32)) {\\n                free.remove(&(pos as i32));\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, pos as i32));\\n                freq[pos as usize] += 1;\\n                if freq[pos] > max {\\n                    max = freq[pos];\\n                }\\n            } else {\\n                let mut next = free.range(pos as i32..).next();\\n                if next.is_none() {\\n                    next = free.range(0..).next();\\n                }\\n                let x = *next.unwrap();\\n                free.remove(&x);\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, x));\\n                freq[x as usize] += 1;\\n                if freq[x as usize] > max {\\n                    max = freq[x as usize];\\n                }\\n            }\\n        }\\n\\n        let mut ans = vec![];\\n        for (i, &x) in freq.iter().enumerate() {\\n            if x == max {\\n                ans.push(i as i32)\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_busiest_servers() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 5], vec![5, 2, 3, 3, 3]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_02() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4], vec![1, 2, 1, 2]),\\n            vec![0]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_03() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3], vec![10, 12, 11]),\\n            vec![0, 1, 2]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_04() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 8, 9, 10], vec![5, 2, 10, 3, 1, 2, 2]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_05() {\\n        assert_eq!(Solution::busiest_servers(1, vec![1], vec![1]), vec![0]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877415,
                "title": "detailed-explanation-with-print-statements-100-100-time-mem-python3",
                "content": "I included a whole bunch of Print statements, so that you can see the progression of the algorithm step by step. Obviously you need to comment those out if you want to submit this.\\n\\nHere\\'s how we solve this problem. The \"solution\" is actually very simple, the implementation is the hard part. The solution is for every arrival, choose the first server we encounter that is availble, starting from server (how many arrivals we\\'ve had)%k. The difficult part is doing this efficiently. The clue, is we require only two pieces of information\\n1. Figure out a way to maintain a list of all available servers at any time\\n2. Choose the element in that list that is first encountered\\n\\nTo do this, we maintain two data structures. The first, is a list of available servers. Ideally we want that this array is sorted in terms of which we would encounter first, so this way for every arrival we could just take its first element. That\\'s actually too hard to do; after every arrival, the ordering actually changes to send the latest server to the back of the line. Instead, we will settle for just sorting it normally, then use binary search to index into wherever we need. It\\'s an $O(log(m))$ penalty, for m the queue length.\\n\\nSecond, we maintain a heap of tuples (earilest server availability time, server number). For every arrival, this allows us to quickly extract all servers that are available. We just keep taking the server with earliset availability up until the current one. We then insert all of these using python\\'s binary search module \"bisect\" into the sorted array of available servers. Rinse and repeat.\\n\\nThe last parts concerning res, curr, and c are just to keep track of the busiest servers, there\\'s no deep insight there.\\n\\nI suggest trying out the code on some of the test cases to see how the algorithm works\\n\\n```\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        print(\\'*\\'*20)\\n        print(\\'Prints logs.\\\\n The \\\\\\'busy\\\\\\' server is formatted with entries\\\\n (earliest availability, server number)\\')\\n        print(f\\'There are {k} servers total, {len(arrival)} requests\\')\\n        print(\\'*\\'*20)\\n        \\n        import heapq, bisect\\n        res, curr, c = [], float(\\'-inf\\'), {i:0 for i in range(k)}\\n        q, nq = list(range(k)), []\\n        for m, z in enumerate(zip(arrival, load)):\\n            a, b = z\\n            while nq and nq[0][0] <= a:\\n                time, idx = heapq.heappop(nq)\\n                bisect.insort(q, idx)\\n            if q:\\n\\t\\t\\t\\n                print(\"start time:\", a, \"Preferred server:\",m%k)\\n                print(\"Available servers:\", q)\\n\\t\\t\\t\\t\\n                i = q.pop(bisect.bisect_left(q, m%k)%len(q))\\n\\t\\t\\t\\t\\n                print(\"Busy servers:\", nq)\\n                print(\"Choosing server\",i,\"...\\\\n\")\\n\\t\\t\\t\\t\\n                heapq.heappush(nq, (a+b,i))\\n                c[i] += 1\\n                if c[i] > curr:\\n                    res, curr = [i], c[i]\\n                elif c[i] == curr:\\n                    res.append(i)\\n\\t\\t\\t\\t\\t\\n        print(\\'-\\'*40)\\n        print(\\'Printing number of accepted requests per server...\\')\\n        print(c)\\n        return res\\n```\\n\\nAs an example output, suppose we give it the inputs:\\n\\nnum of servers: 3\\narrival times: [1,2,3,4,5]\\nload times: [5,2,3,3,3]\\n\\nThen we would output:\\n********************\\nPrints logs.\\n The \\'busy\\' server is formatted with entries\\n (earliest availability, server number)\\nThere are 3 servers total, 5 requests\\n********************\\nstart time: 1 Preferred server: 0\\nAvailable servers: [0, 1, 2]\\nBusy servers: []\\nChoosing server 0 ...\\n\\nstart time: 2 Preferred server: 1\\nAvailable servers: [1, 2]\\nBusy servers: [(6, 0)]\\nChoosing server 1 ...\\n\\nstart time: 3 Preferred server: 2\\nAvailable servers: [2]\\nBusy servers: [(4, 1), (6, 0)]\\nChoosing server 2 ...\\n\\nstart time: 4 Preferred server: 0\\nAvailable servers: [1]\\nBusy servers: [(6, 0), (6, 2)]\\nChoosing server 1 ...\\n\\n----------------------------------------\\nPrinting number of accepted requests per server...\\n{0: 1, 1: 2, 2: 1}\\n",
                "solutionTags": [],
                "code": "```\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        print(\\'*\\'*20)\\n        print(\\'Prints logs.\\\\n The \\\\\\'busy\\\\\\' server is formatted with entries\\\\n (earliest availability, server number)\\')\\n        print(f\\'There are {k} servers total, {len(arrival)} requests\\')\\n        print(\\'*\\'*20)\\n        \\n        import heapq, bisect\\n        res, curr, c = [], float(\\'-inf\\'), {i:0 for i in range(k)}\\n        q, nq = list(range(k)), []\\n        for m, z in enumerate(zip(arrival, load)):\\n            a, b = z\\n            while nq and nq[0][0] <= a:\\n                time, idx = heapq.heappop(nq)\\n                bisect.insort(q, idx)\\n            if q:\\n\\t\\t\\t\\n                print(\"start time:\", a, \"Preferred server:\",m%k)\\n                print(\"Available servers:\", q)\\n\\t\\t\\t\\t\\n                i = q.pop(bisect.bisect_left(q, m%k)%len(q))\\n\\t\\t\\t\\t\\n                print(\"Busy servers:\", nq)\\n                print(\"Choosing server\",i,\"...\\\\n\")\\n\\t\\t\\t\\t\\n                heapq.heappush(nq, (a+b,i))\\n                c[i] += 1\\n                if c[i] > curr:\\n                    res, curr = [i], c[i]\\n                elif c[i] == curr:\\n                    res.append(i)\\n\\t\\t\\t\\t\\t\\n        print(\\'-\\'*40)\\n        print(\\'Printing number of accepted requests per server...\\')\\n        print(c)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 877353,
                "title": "java-o-nlogn-o-nlogk-with-explaination-and-comment",
                "content": "The idea is simulating the whole process. For the time when a job start and a end, we create a event, and sort these events. \\n\\n```Java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] a, int[] l) {\\n        TreeSet<Integer> servers = new TreeSet<>();  // the set stores availabe servers \\n        for (int i = 0; i < k; i++) {\\n            servers.add(i);\\n        }\\n        int[] jobs = new int[k];   // jobs[i] stores how many job ith server finished so far\\n        List<Event> events = new ArrayList<>();\\n        for (int i = 0; i < a.length; i++) {\\n            events.add(new Event(i, 1, a[i]));\\n            events.add(new Event(i, 0, a[i] + l[i]));\\n        }\\n        Collections.sort(events, (e1, e2) -> {\\n            return e1.time == e2.time ? e1.time - e2.time : e1.time - e2.time;   // we sort the the event by \\n\\t\\t\\t// the time stamp, when the timestamp is same, we put the ending event first, so we can free the server as soon as possible.\\n        });\\n        Map<Integer, Integer> idToServer = new HashMap<>();   // this stores mapping between job.id and server\\n        for (Event event : events) {\\n            if (event.start == 1) {\\n                if (servers.isEmpty()) {   // if no available server, we have to drop the job\\n                    continue;\\n                } else {\\n                    int server = nextServer(servers, event.id % k); // find next available server \\n                    idToServer.put(event.id, server);      // recording the mapping\\n                    jobs[server]++;\\n                    servers.remove(server);\\n                }\\n            } else {\\n                Integer server = idToServer.get(event.id);   // if server == null means the job was dropped.\\n                if (server != null) {\\n                    servers.add(server);    // add the server back to available servers.\\n                }\\n            }\\n        }\\n        int max = IntStream.of(jobs).max().getAsInt();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < jobs.length; i++) {\\n            if (jobs[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int nextServer(TreeSet<Integer> servers, int id) {\\n        Integer nextServer = servers.ceiling(id);\\n        return nextServer != null ? nextServer : servers.first();\\n    }\\n    \\n    \\n    public static class Event {\\n        \\n        public int start; // 1 start 0 end\\n        \\n        public int time;\\n        \\n        public int id;\\n        \\n        public Event(int id, int start, int time) {\\n            this.start = start;\\n            this.time = time;\\n            this.id = id;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] a, int[] l) {\\n        TreeSet<Integer> servers = new TreeSet<>();  // the set stores availabe servers \\n        for (int i = 0; i < k; i++) {\\n            servers.add(i);\\n        }\\n        int[] jobs = new int[k];   // jobs[i] stores how many job ith server finished so far\\n        List<Event> events = new ArrayList<>();\\n        for (int i = 0; i < a.length; i++) {\\n            events.add(new Event(i, 1, a[i]));\\n            events.add(new Event(i, 0, a[i] + l[i]));\\n        }\\n        Collections.sort(events, (e1, e2) -> {\\n            return e1.time == e2.time ? e1.time - e2.time : e1.time - e2.time;   // we sort the the event by \\n\\t\\t\\t// the time stamp, when the timestamp is same, we put the ending event first, so we can free the server as soon as possible.\\n        });\\n        Map<Integer, Integer> idToServer = new HashMap<>();   // this stores mapping between job.id and server\\n        for (Event event : events) {\\n            if (event.start == 1) {\\n                if (servers.isEmpty()) {   // if no available server, we have to drop the job\\n                    continue;\\n                } else {\\n                    int server = nextServer(servers, event.id % k); // find next available server \\n                    idToServer.put(event.id, server);      // recording the mapping\\n                    jobs[server]++;\\n                    servers.remove(server);\\n                }\\n            } else {\\n                Integer server = idToServer.get(event.id);   // if server == null means the job was dropped.\\n                if (server != null) {\\n                    servers.add(server);    // add the server back to available servers.\\n                }\\n            }\\n        }\\n        int max = IntStream.of(jobs).max().getAsInt();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < jobs.length; i++) {\\n            if (jobs[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int nextServer(TreeSet<Integer> servers, int id) {\\n        Integer nextServer = servers.ceiling(id);\\n        return nextServer != null ? nextServer : servers.first();\\n    }\\n    \\n    \\n    public static class Event {\\n        \\n        public int start; // 1 start 0 end\\n        \\n        public int time;\\n        \\n        public int id;\\n        \\n        public Event(int id, int start, int time) {\\n            this.start = start;\\n            this.time = time;\\n            this.id = id;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877296,
                "title": "c-using-map-priority-queue-t-c-o-n-log-k-log-n",
                "content": "```\\n/*\\nfreeServers -> is used as find nearest element or exact value of (i % k)-> to achieve this we are using Lower_Bound\\n\\npq (min heap <arrival_time + load, serverNumber>) -> is used to remove expired element\\n\\t\\nmp -> is used to store frequency of the server(how many request served by each server)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n       \\n        map<int,int> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int> > > pq;\\n       \\n        map<int,int> freeServers;\\n\\n        for(int i = 0; i < k; i++) freeServers[i]++;\\n        \\n        int len = arrival.size();\\n        \\n        int mx = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            \\n            while(!pq.empty() && arrival[i] >= pq.top().first) {\\n                freeServers[pq.top().second]++;\\n                pq.pop();   \\n            }\\n            \\n            auto it =  freeServers.lower_bound(i % k);\\n            if(it == freeServers.end() && freeServers.size() > 0) {\\n                it = freeServers.begin();\\n            }\\n            \\n            if(it != freeServers.end()) {\\n                mp[it->first]++;\\n                mx = max(mx, mp[it->first]);\\n                pq.push({arrival[i] + load[i], it->first});\\n                freeServers.erase(it);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++) {\\n            if(it->second == mx) {\\n                ans.push_back(it->first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nfreeServers -> is used as find nearest element or exact value of (i % k)-> to achieve this we are using Lower_Bound\\n\\npq (min heap <arrival_time + load, serverNumber>) -> is used to remove expired element\\n\\t\\nmp -> is used to store frequency of the server(how many request served by each server)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n       \\n        map<int,int> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int> > > pq;\\n       \\n        map<int,int> freeServers;\\n\\n        for(int i = 0; i < k; i++) freeServers[i]++;\\n        \\n        int len = arrival.size();\\n        \\n        int mx = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            \\n            while(!pq.empty() && arrival[i] >= pq.top().first) {\\n                freeServers[pq.top().second]++;\\n                pq.pop();   \\n            }\\n            \\n            auto it =  freeServers.lower_bound(i % k);\\n            if(it == freeServers.end() && freeServers.size() > 0) {\\n                it = freeServers.begin();\\n            }\\n            \\n            if(it != freeServers.end()) {\\n                mp[it->first]++;\\n                mx = max(mx, mp[it->first]);\\n                pq.push({arrival[i] + load[i], it->first});\\n                freeServers.erase(it);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++) {\\n            if(it->second == mx) {\\n                ans.push_back(it->first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877202,
                "title": "easy-cpp-solution-using-min-heap-and-ordered-set",
                "content": "CPP solution using minheap and ordered set.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int *counter;\\n\\n    \\n    struct compare{\\n        bool operator() (const pair<int,int> & p1,const pair<int,int> & p2 ){\\n             return p1.second > p2.second;\\n//             > gives minheap\\n//             < gives maxheap\\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    \\n//         the idea is to use a set for free servers\\n//         and a min Heap to store busy servers. \\n//         min heap is according to their min end times. -- but key is the serverid\\n        vector<int> ans;\\n        \\n        counter = new int[k];\\n        memset(counter, 0, sizeof(int)*k);\\n        \\n        int maxfound = INT_MIN;\\n        \\n        set<int> freeservers;\\n        priority_queue<pair<int,int>, vector< pair<int,int> >, compare> busy;\\n        \\n        for(int i=0;i<k;i++)\\n            freeservers.insert(i);\\n        \\n        for(int i=0; i<arrival.size();i++){\\n            \\n            \\n//             second is time, first is serverid -- in queue.\\n            \\n//             whatever is actually free.. put it in ther freeserver set.\\n            while(!busy.empty() && busy.top().second <= arrival[i]){\\n                freeservers.insert(busy.top().first);\\n                busy.pop();\\n            }\\n            \\n            \\n            if(freeservers.empty())\\n                continue;\\n            \\n//             get a free server. starting at i%k.\\n            // try right to i%k\\n            auto x = freeservers.lower_bound(i%k);\\n            if(x == freeservers.end()){\\n                // now pick the least available. -- which is the first element.\\n                x = freeservers.begin();\\n            }\\n            \\n            int usethis;\\n            usethis = *x;\\n        \\n            busy.push({usethis, arrival[i] + load[i]});\\n            freeservers.erase(usethis);\\n            counter[usethis] ++;\\n            \\n            maxfound = max(maxfound, counter[usethis]);\\n        }\\n        \\n        \\n        for(int i=0;i<k;i++){\\n            if(counter[i] == maxfound)\\n                ans.push_back(i);\\n        }\\n            \\n        delete [] counter;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int *counter;\\n\\n    \\n    struct compare{\\n        bool operator() (const pair<int,int> & p1,const pair<int,int> & p2 ){\\n             return p1.second > p2.second;\\n//             > gives minheap\\n//             < gives maxheap\\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    \\n//         the idea is to use a set for free servers\\n//         and a min Heap to store busy servers. \\n//         min heap is according to their min end times. -- but key is the serverid\\n        vector<int> ans;\\n        \\n        counter = new int[k];\\n        memset(counter, 0, sizeof(int)*k);\\n        \\n        int maxfound = INT_MIN;\\n        \\n        set<int> freeservers;\\n        priority_queue<pair<int,int>, vector< pair<int,int> >, compare> busy;\\n        \\n        for(int i=0;i<k;i++)\\n            freeservers.insert(i);\\n        \\n        for(int i=0; i<arrival.size();i++){\\n            \\n            \\n//             second is time, first is serverid -- in queue.\\n            \\n//             whatever is actually free.. put it in ther freeserver set.\\n            while(!busy.empty() && busy.top().second <= arrival[i]){\\n                freeservers.insert(busy.top().first);\\n                busy.pop();\\n            }\\n            \\n            \\n            if(freeservers.empty())\\n                continue;\\n            \\n//             get a free server. starting at i%k.\\n            // try right to i%k\\n            auto x = freeservers.lower_bound(i%k);\\n            if(x == freeservers.end()){\\n                // now pick the least available. -- which is the first element.\\n                x = freeservers.begin();\\n            }\\n            \\n            int usethis;\\n            usethis = *x;\\n        \\n            busy.push({usethis, arrival[i] + load[i]});\\n            freeservers.erase(usethis);\\n            counter[usethis] ++;\\n            \\n            maxfound = max(maxfound, counter[usethis]);\\n        }\\n        \\n        \\n        for(int i=0;i<k;i++){\\n            if(counter[i] == maxfound)\\n                ans.push_back(i);\\n        }\\n            \\n        delete [] counter;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877071,
                "title": "python-heap-sortedlist-o-nlog-k",
                "content": "Comments are mentioned below but the basic idea is to keep a sortedList (BST datastructure) for the available servers at all times and use a heap to add servers that become available again later on back into the available servers list and binary search the available servers to find the closest server to the present idx%k.\\n```\\nfrom sortedcontainers import SortedList\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        # This is a BST this way we can keep the available sorted so we can search through with binary search.\\n        avail = SortedList(range(k))\\n        inf = float(\\'inf\\')\\n        # Add infinity at the end to deal with the case that that all values are smaller than target so it is\\n        # FFF, which will return the last F but this will cause ambiguity with the case that FFT, so I added on\\n        # infinity so that these cases would not be ambiguous with FFFT and FFTT, so the FFFT will wrap around back to the\\n        # zeroth element in available servers.  While the other one will just retern the last element in available servers.\\n        avail.add(inf)\\n        count = [0] * k\\n        # The heap will allow us to add servers that become newly available again back into available servers BST\\n        heap = []\\n\\n        def possible(val, target):\\n            return val >= target\\n        # Binary search in the form of FFTT and we return the first occurrence of T.\\n        def binary_search(target, arr):\\n            lo, hi = 0, len(arr) - 1\\n            while lo < hi:\\n                mid = lo + hi >> 1\\n                if not possible(arr[mid], target):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n            return lo\\n\\n        for idx, (a, l) in enumerate(zip(arrival, load)):\\n            # Pop from heap if the expiration time is less than the current arrival time. \\n            # Then added to the sorted available servers list.  \\n            while heap and heap[0][0] <= a:\\n                _, index = heapq.heappop(heap)\\n                avail.add(index)\\n\\n            n = len(avail)\\n            # There are no servers available right now\\n            if n == 1:\\n                continue\\n            # The reason for mod with n-1 is because if the binary search returns the last value in the avail.\\n            # We want to wrap around back to the first element in the available servers.\\n            avail_idx = binary_search(idx % k, avail) % (n - 1)\\n\\n            server_idx = avail[avail_idx]\\n            expiration_time = a + l\\n            # push this into the heap with the server_idx saved, and the expiration time.\\n            heapq.heappush(heap, (expiration_time, server_idx))\\n            avail.remove(server_idx)\\n            count[server_idx] += 1\\n        ans = []\\n        goal = max(count)\\n        for i, val in enumerate(count):\\n            if val == goal:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        # This is a BST this way we can keep the available sorted so we can search through with binary search.\\n        avail = SortedList(range(k))\\n        inf = float(\\'inf\\')\\n        # Add infinity at the end to deal with the case that that all values are smaller than target so it is\\n        # FFF, which will return the last F but this will cause ambiguity with the case that FFT, so I added on\\n        # infinity so that these cases would not be ambiguous with FFFT and FFTT, so the FFFT will wrap around back to the\\n        # zeroth element in available servers.  While the other one will just retern the last element in available servers.\\n        avail.add(inf)\\n        count = [0] * k\\n        # The heap will allow us to add servers that become newly available again back into available servers BST\\n        heap = []\\n\\n        def possible(val, target):\\n            return val >= target\\n        # Binary search in the form of FFTT and we return the first occurrence of T.\\n        def binary_search(target, arr):\\n            lo, hi = 0, len(arr) - 1\\n            while lo < hi:\\n                mid = lo + hi >> 1\\n                if not possible(arr[mid], target):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n            return lo\\n\\n        for idx, (a, l) in enumerate(zip(arrival, load)):\\n            # Pop from heap if the expiration time is less than the current arrival time. \\n            # Then added to the sorted available servers list.  \\n            while heap and heap[0][0] <= a:\\n                _, index = heapq.heappop(heap)\\n                avail.add(index)\\n\\n            n = len(avail)\\n            # There are no servers available right now\\n            if n == 1:\\n                continue\\n            # The reason for mod with n-1 is because if the binary search returns the last value in the avail.\\n            # We want to wrap around back to the first element in the available servers.\\n            avail_idx = binary_search(idx % k, avail) % (n - 1)\\n\\n            server_idx = avail[avail_idx]\\n            expiration_time = a + l\\n            # push this into the heap with the server_idx saved, and the expiration time.\\n            heapq.heappush(heap, (expiration_time, server_idx))\\n            avail.remove(server_idx)\\n            count[server_idx] += 1\\n        ans = []\\n        goal = max(count)\\n        for i, val in enumerate(count):\\n            if val == goal:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876995,
                "title": "python-solution-with-two-heaps-rotated-key",
                "content": "The trick is to use `server + i - i % k + (k if server < i % k else 0)` to simulate the circular process.\\n\\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k\\n        busyUntil = [0] * k\\n        busyHeap = [] # heap of servers with key being busyUntil[server]\\n        availableHeap = list((i, i) for i in range(k)) # heap of servers with key being the rotation index of server.\\n        heapify(availableHeap)\\n\\n        def getRotationKey(server, i):\\n            return server + i - i % k + (k if server < i % k else 0)\\n\\n        for i in range(len(arrival)):\\n            t = arrival[i]\\n            ld = load[i]\\n            \\n            while busyHeap and busyHeap[0][0] <= t:\\n                _, server = heappop(busyHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n                \\n            while availableHeap and availableHeap[0][0] < i:\\n                _, server = heappop(availableHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n\\n            if not availableHeap:\\n                continue\\n\\n            _, server = heappop(availableHeap)\\n            heappush(busyHeap, (t + ld, server))\\n            busyUntil[server] = t + ld\\n            count[server] += 1\\n            \\n        most = max(count)\\n        return [server for server, c in enumerate(count) if c == most]\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k\\n        busyUntil = [0] * k\\n        busyHeap = [] # heap of servers with key being busyUntil[server]\\n        availableHeap = list((i, i) for i in range(k)) # heap of servers with key being the rotation index of server.\\n        heapify(availableHeap)\\n\\n        def getRotationKey(server, i):\\n            return server + i - i % k + (k if server < i % k else 0)\\n\\n        for i in range(len(arrival)):\\n            t = arrival[i]\\n            ld = load[i]\\n            \\n            while busyHeap and busyHeap[0][0] <= t:\\n                _, server = heappop(busyHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n                \\n            while availableHeap and availableHeap[0][0] < i:\\n                _, server = heappop(availableHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n\\n            if not availableHeap:\\n                continue\\n\\n            _, server = heappop(availableHeap)\\n            heappush(busyHeap, (t + ld, server))\\n            busyUntil[server] = t + ld\\n            count[server] += 1\\n            \\n        most = max(count)\\n        return [server for server, c in enumerate(count) if c == most]\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876983,
                "title": "c-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstruct comp{\\n\\t\\t\\tbool operator()(const pair<int,int>& a, const pair<int,int>& b){\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\t\\t\\tpriority_queue< pair<int,int> ,vector<pair<int,int>>,comp> qu; // for busy server\\n\\t\\t\\tset<int> S; // for non-busy server\\n\\t\\t\\tfor(int i = 0;i < k; i++ ){\\n\\t\\t\\t\\tS.insert(i);\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tvector<int> server(k,0);\\n\\n\\t\\t\\tfor(int i = 0;i < arrival.size(); i++){\\n\\t\\t\\t\\tint ii = i % k;\\n\\t\\t\\t\\twhile(!qu.empty() && qu.top().second <= arrival[i]){\\n\\t\\t\\t\\t\\tS.insert(qu.top().first);\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(S.empty()) continue;\\n\\t\\t\\t\\tauto it = S.lower_bound(ii);\\n\\t\\t\\t\\tif( it == S.end() ){\\n\\t\\t\\t\\t\\tqu.push( make_pair( *S.begin(), arrival[i] + load[i] ) );\\n\\t\\t\\t\\t\\tserver[*S.begin()]++;\\n\\t\\t\\t\\t\\tS.erase(S.begin());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tqu.push( make_pair( *it, arrival[i] + load[i] ) );\\n\\t\\t\\t\\t\\tserver[*it]++;\\n\\t\\t\\t\\t\\tS.erase(*it);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint big = 0;\\n\\t\\t\\tfor(int i = 0;i < k; i++){\\n\\t\\t\\t\\tbig = max(big,server[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0 ;i < k; i++){\\n\\t\\t\\t\\tif(server[i] == big)\\n\\t\\t\\t\\t\\tans.push_back( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstruct comp{\\n\\t\\t\\tbool operator()(const pair<int,int>& a, const pair<int,int>& b){\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 876978,
                "title": "same-implementation-but-one-solution-passes-the-other-doesn-t",
                "content": "During the contest, I came up with a solution for problem 4, but kept getting TLE. After the contest, I look at ASAPIN\\'s code (rank 1) and found that my solution and implementation is practically the same as his, yet his solution runs in <100ms for k = 8500, but mine runs in ~1500ms for the same input.\\n\\nMy solution (~1500ms for k = 8500):\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = arrival.size();\\n        vector<int> cnt(k);\\n        priority_queue<pair<int, int>> end;\\n        set<int> nxt;\\n        for (int i = 0; i < k; i++) {\\n            nxt.insert(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!end.empty() && -(end.top().first) <= arrival[i]) {\\n                nxt.insert(end.top().second);\\n                end.pop();\\n            }\\n            if (nxt.empty()) continue;\\n            auto it = lower_bound(nxt.begin(), nxt.end(), i % k);\\n            if (it == nxt.end()) {\\n                it = nxt.begin();\\n            }\\n            int server = *it;\\n            end.push({-(arrival[i] + load[i]), server});\\n            //cout << i << \\' \\' << server << \\' \\' << (arrival[i] + load[i]) << endl;\\n            nxt.erase(it);\\n            cnt[server]++;\\n        }\\n        \\n        vector<int> ans;\\n        int mx = *max_element(cnt.begin(), cnt.end());\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == mx) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nASAPIN\\'s code (<100ms for k = 8500)\\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& b) {\\n        set<int> r;\\n        for(int i = 0; i < k; i++) r.insert(i);\\n        priority_queue<pair<int, int> > bsy;\\n        int Q = a.size();\\n        map<int, int> res;\\n        for(int i = 0; i < Q; i++) {\\n            int pos = i % k;\\n            int tim = a[i];\\n            int lod = b[i];\\n            while(!bsy.empty() && bsy.top().fi * -1 <= tim) {\\n                r.insert(bsy.top().se);\\n                bsy.pop();\\n            }\\n            if(r.empty()) continue;\\n            else {\\n                auto itr = r.lower_bound(pos);\\n                if(itr == r.end()) itr = r.begin();\\n                pos = *itr;\\n                r.erase(pos);\\n                res[pos] += 1;\\n                bsy.push(make_pair(-a[i] - b[i], pos));\\n            }\\n        }\\n        int mx = 0;\\n        for(auto it : res) {\\n            mx = max(mx, it.se);\\n        }\\n        vector<int> vec;\\n        for(auto it : res) {\\n            if(it.se == mx) vec.pb(it.fi);\\n        }\\n        return vec;\\n    }\\n};\\n```\\nCan someone explain why this is happening?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = arrival.size();\\n        vector<int> cnt(k);\\n        priority_queue<pair<int, int>> end;\\n        set<int> nxt;\\n        for (int i = 0; i < k; i++) {\\n            nxt.insert(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!end.empty() && -(end.top().first) <= arrival[i]) {\\n                nxt.insert(end.top().second);\\n                end.pop();\\n            }\\n            if (nxt.empty()) continue;\\n            auto it = lower_bound(nxt.begin(), nxt.end(), i % k);\\n            if (it == nxt.end()) {\\n                it = nxt.begin();\\n            }\\n            int server = *it;\\n            end.push({-(arrival[i] + load[i]), server});\\n            //cout << i << \\' \\' << server << \\' \\' << (arrival[i] + load[i]) << endl;\\n            nxt.erase(it);\\n            cnt[server]++;\\n        }\\n        \\n        vector<int> ans;\\n        int mx = *max_element(cnt.begin(), cnt.end());\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == mx) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& b) {\\n        set<int> r;\\n        for(int i = 0; i < k; i++) r.insert(i);\\n        priority_queue<pair<int, int> > bsy;\\n        int Q = a.size();\\n        map<int, int> res;\\n        for(int i = 0; i < Q; i++) {\\n            int pos = i % k;\\n            int tim = a[i];\\n            int lod = b[i];\\n            while(!bsy.empty() && bsy.top().fi * -1 <= tim) {\\n                r.insert(bsy.top().se);\\n                bsy.pop();\\n            }\\n            if(r.empty()) continue;\\n            else {\\n                auto itr = r.lower_bound(pos);\\n                if(itr == r.end()) itr = r.begin();\\n                pos = *itr;\\n                r.erase(pos);\\n                res[pos] += 1;\\n                bsy.push(make_pair(-a[i] - b[i], pos));\\n            }\\n        }\\n        int mx = 0;\\n        for(auto it : res) {\\n            mx = max(mx, it.se);\\n        }\\n        vector<int> vec;\\n        for(auto it : res) {\\n            if(it.se == mx) vec.pb(it.fi);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 876931,
                "title": "c-356ms-100-o-n-log-k-easy-segment-tree",
                "content": "Practice problem on CodeForces EDU - [https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D](http://)\\n\\nUsing time in -ve because it I already have above implemented Segment Tree and It\\'s easier for me to work with max queries.\\n\\n```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\n\\nclass segtree{\\npublic:\\n    int n;\\n    vector<int> arr;\\n    bool q;\\n    int merge(int a, int b){\\n        return max(a, b);\\n    }\\n    \\n    segtree(int n){\\n        this->n=n;\\n        int x=1;\\n        while (x<n) x*=2;\\n        arr.assign(2*x, INT_MIN);\\n    }\\n    \\n    void build(vector<int>& v, int x, int left, int right){\\n        if (left+1==right){\\n            arr[x]=v[left];\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        build(v, 2*x+1, left, mid);\\n        build(v, 2*x+2, mid, right);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n    }\\n    \\n    void build(vector<int>& v){\\n        build(v, 0, 0, n);\\n    };\\n    \\n    void set(int i, int val){\\n        set(i, val, 0, n, 0);\\n        return;\\n    }\\n    \\n    void set(int i, int val, int left, int right, int x){\\n        if (left+1==right) {\\n            arr[x]=val;\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        if (i<mid) set(i, val, left, mid, 2*x+1);\\n        else set(i, val, mid, right, 2*x+2);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n        return;\\n    }\\n    int lbound(int l, int k){\\n        q=true;\\n        int rex=lbound(l, k, 0, 0, n);\\n        if (q) return -1;\\n        return rex;\\n    }\\n    \\n    int lbound(int l, int k, int x, int left, int right){\\n        if (left+1==right){\\n            q=false;\\n            return left;\\n        }\\n        int mid=left+(right-left)/2;\\n        int a, b;\\n        if (arr[2*x+1]>=k && l<mid) {\\n            a=lbound(l, k, 2*x+1, left, mid);\\n            if (!q) return a;\\n        }\\n        if (q && arr[2*x+2]>=k) return lbound(l, k, 2*x+2, mid, right);\\n        return -1;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> fr(k, 0);\\n        int n=arrival.size();\\n        vector<int> nums(k, 0);\\n        segtree st=segtree(k);\\n        st.build(nums);\\n        int y, z, maxfr;     // maxfr = current max frequency of any server\\n        for (int i=0; i<n; ++i){\\n            y=-arrival[i];                             // using -ve arrival time because time when server is free is also -ve\\n            z=st.lbound(i%k,  y);                // min indice z>=i%k such that nums[z]>=nums[i%k]\\n            if (z==-1) z=st.lbound(0, y);\\n            if (z!=-1){\\n                fr[z]++;\\n                maxfr=max(maxfr, fr[z]);\\n                st.set(z, y-load[i]);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(k);\\n        for (int i=0; i<k; ++i){\\n            if (fr[i]==maxfr){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\n\\nclass segtree{\\npublic:\\n    int n;\\n    vector<int> arr;\\n    bool q;\\n    int merge(int a, int b){\\n        return max(a, b);\\n    }\\n    \\n    segtree(int n){\\n        this->n=n;\\n        int x=1;\\n        while (x<n) x*=2;\\n        arr.assign(2*x, INT_MIN);\\n    }\\n    \\n    void build(vector<int>& v, int x, int left, int right){\\n        if (left+1==right){\\n            arr[x]=v[left];\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        build(v, 2*x+1, left, mid);\\n        build(v, 2*x+2, mid, right);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n    }\\n    \\n    void build(vector<int>& v){\\n        build(v, 0, 0, n);\\n    };\\n    \\n    void set(int i, int val){\\n        set(i, val, 0, n, 0);\\n        return;\\n    }\\n    \\n    void set(int i, int val, int left, int right, int x){\\n        if (left+1==right) {\\n            arr[x]=val;\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        if (i<mid) set(i, val, left, mid, 2*x+1);\\n        else set(i, val, mid, right, 2*x+2);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n        return;\\n    }\\n    int lbound(int l, int k){\\n        q=true;\\n        int rex=lbound(l, k, 0, 0, n);\\n        if (q) return -1;\\n        return rex;\\n    }\\n    \\n    int lbound(int l, int k, int x, int left, int right){\\n        if (left+1==right){\\n            q=false;\\n            return left;\\n        }\\n        int mid=left+(right-left)/2;\\n        int a, b;\\n        if (arr[2*x+1]>=k && l<mid) {\\n            a=lbound(l, k, 2*x+1, left, mid);\\n            if (!q) return a;\\n        }\\n        if (q && arr[2*x+2]>=k) return lbound(l, k, 2*x+2, mid, right);\\n        return -1;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> fr(k, 0);\\n        int n=arrival.size();\\n        vector<int> nums(k, 0);\\n        segtree st=segtree(k);\\n        st.build(nums);\\n        int y, z, maxfr;     // maxfr = current max frequency of any server\\n        for (int i=0; i<n; ++i){\\n            y=-arrival[i];                             // using -ve arrival time because time when server is free is also -ve\\n            z=st.lbound(i%k,  y);                // min indice z>=i%k such that nums[z]>=nums[i%k]\\n            if (z==-1) z=st.lbound(0, y);\\n            if (z!=-1){\\n                fr[z]++;\\n                maxfr=max(maxfr, fr[z]);\\n                st.set(z, y-load[i]);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(k);\\n        for (int i=0; i<k; ++i){\\n            if (fr[i]==maxfr){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 876912,
                "title": "java-o-nk-103-108-test-cases-passed",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> out = new ArrayList<>();\\n        Map<Integer, Node> map = new HashMap<>();\\n        \\n        for (int i=0;i<arrival.length;i++) {\\n            int server = i%k;\\n            if (!map.containsKey(server)) {\\n                map.put(server, new Node(arrival[i],load[i],1));\\n            } else {\\n                int origServer = server;\\n                boolean flag = false;\\n                while(map.get(server)!=null && map.get(server).start+map.get(server).load>arrival[i]) {\\n                    server = (server+1)%k;\\n                    if (server == origServer) {\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if (!flag) {\\n                    int cnt = map.get(server).cnt;\\n                     map.put(server, new Node(arrival[i],load[i], cnt+1));\\n                }\\n            }\\n        }\\n        int busy = -1;\\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            busy = Math.max(busy, e.getValue().cnt);\\n        }\\n        \\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            if (busy == e.getValue().cnt)\\n                out.add(e.getKey());\\n        }\\n        \\n        return out;\\n    }\\n}\\nclass Node {\\n    int start;\\n    int load;\\n    int cnt;\\n    public Node(int start, int load, int cnt) {\\n        this.start = start;\\n        this.load = load;\\n        this.cnt = cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> out = new ArrayList<>();\\n        Map<Integer, Node> map = new HashMap<>();\\n        \\n        for (int i=0;i<arrival.length;i++) {\\n            int server = i%k;\\n            if (!map.containsKey(server)) {\\n                map.put(server, new Node(arrival[i],load[i],1));\\n            } else {\\n                int origServer = server;\\n                boolean flag = false;\\n                while(map.get(server)!=null && map.get(server).start+map.get(server).load>arrival[i]) {\\n                    server = (server+1)%k;\\n                    if (server == origServer) {\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if (!flag) {\\n                    int cnt = map.get(server).cnt;\\n                     map.put(server, new Node(arrival[i],load[i], cnt+1));\\n                }\\n            }\\n        }\\n        int busy = -1;\\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            busy = Math.max(busy, e.getValue().cnt);\\n        }\\n        \\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            if (busy == e.getValue().cnt)\\n                out.add(e.getKey());\\n        }\\n        \\n        return out;\\n    }\\n}\\nclass Node {\\n    int start;\\n    int load;\\n    int cnt;\\n    public Node(int start, int load, int cnt) {\\n        this.start = start;\\n        this.load = load;\\n        this.cnt = cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876897,
                "title": "please-tell-me-why-my-java-oop-approach-fails-sample-cases-passed",
                "content": "```\\nclass Solution {\\n    \\n    List<Server> servers = new ArrayList();\\n    int k;\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        this.k = k;\\n        \\n        for (int i = 0; i < k; i++) {\\n            servers.add(new Server(i));\\n        }\\n        \\n        int last = arrival[0];\\n        for (int i = 0; i < arrival.length; i++) {\\n            if (i == 0) {\\n                addLoad(i, load[i]);\\n            } else {\\n                incrementAll(arrival[i] - last);\\n                last = arrival[i];\\n                addLoad(i, load[i]);\\n            }\\n        }\\n        \\n        printAll();\\n        \\n        return getBusiest();\\n    }\\n    \\n    List<Integer> getBusiest() {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (Server s : servers) {\\n            max = Math.max(max, s.count);\\n        }\\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        for (Server s : servers) {\\n            if (s.count == max) {\\n                list.add(s.index);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    void incrementAll(int times) {\\n        for (Server s : servers) {\\n            s.increment(times);\\n        }\\n    }\\n    \\n    void addLoad(int index, int load) {\\n        if (servers.get(index % k).isIdle()) {\\n            servers.get(index % k).addLoad(load);\\n            return;\\n        }\\n        \\n        for (Server s : servers) {\\n            if (s.isIdle()) {\\n                s.addLoad(load);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    void printAll() {\\n        System.out.println(servers.toString());\\n    }\\n    \\n    class Server {\\n        int index;\\n        int load;\\n        int count;\\n        \\n        Server(int index) {\\n            this.index = index;\\n        }\\n        \\n        boolean isIdle() {\\n            return load == 0;\\n        }\\n        \\n        void addLoad(int load) {\\n            this.load = load;\\n            count++;\\n        }\\n        \\n        void increment(int times) {\\n            load = Math.max(0, load - times);\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return String.format(\"%d, count=%d\", index, count);\\n        }\\n    }\\n}\\n```\\n\\nSomehow it fails on this input\\n```\\n7\\n[1,3,4,5,6,11,12,13,15,19,20,21,23,25,31,32]\\n[9,16,14,1,5,15,6,10,1,1,7,5,11,4,4,6]\\n\\nOutput:\\n[0,2,3]\\nExpected:\\n[0]\\nStdout:\\n[0, count=3, 1, count=2, 2, count=3, 3, count=3, 4, count=2, 5, count=1, 6, count=2]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<Server> servers = new ArrayList();\\n    int k;\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        this.k = k;\\n        \\n        for (int i = 0; i < k; i++) {\\n            servers.add(new Server(i));\\n        }\\n        \\n        int last = arrival[0];\\n        for (int i = 0; i < arrival.length; i++) {\\n            if (i == 0) {\\n                addLoad(i, load[i]);\\n            } else {\\n                incrementAll(arrival[i] - last);\\n                last = arrival[i];\\n                addLoad(i, load[i]);\\n            }\\n        }\\n        \\n        printAll();\\n        \\n        return getBusiest();\\n    }\\n    \\n    List<Integer> getBusiest() {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (Server s : servers) {\\n            max = Math.max(max, s.count);\\n        }\\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        for (Server s : servers) {\\n            if (s.count == max) {\\n                list.add(s.index);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    void incrementAll(int times) {\\n        for (Server s : servers) {\\n            s.increment(times);\\n        }\\n    }\\n    \\n    void addLoad(int index, int load) {\\n        if (servers.get(index % k).isIdle()) {\\n            servers.get(index % k).addLoad(load);\\n            return;\\n        }\\n        \\n        for (Server s : servers) {\\n            if (s.isIdle()) {\\n                s.addLoad(load);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    void printAll() {\\n        System.out.println(servers.toString());\\n    }\\n    \\n    class Server {\\n        int index;\\n        int load;\\n        int count;\\n        \\n        Server(int index) {\\n            this.index = index;\\n        }\\n        \\n        boolean isIdle() {\\n            return load == 0;\\n        }\\n        \\n        void addLoad(int load) {\\n            this.load = load;\\n            count++;\\n        }\\n        \\n        void increment(int times) {\\n            load = Math.max(0, load - times);\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return String.format(\"%d, count=%d\", index, count);\\n        }\\n    }\\n}\\n```\n```\\n7\\n[1,3,4,5,6,11,12,13,15,19,20,21,23,25,31,32]\\n[9,16,14,1,5,15,6,10,1,1,7,5,11,4,4,6]\\n\\nOutput:\\n[0,2,3]\\nExpected:\\n[0]\\nStdout:\\n[0, count=3, 1, count=2, 2, count=3, 3, count=3, 4, count=2, 5, count=1, 6, count=2]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567081,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            },
            {
                "id": 1570188,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            },
            {
                "id": 1931671,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            },
            {
                "id": 1677199,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Cost to Reach Destination in Time",
        "question_content": "<p>There is a country of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> where <strong>all the cities are connected</strong> by bi-directional roads. The roads are represented as a 2D integer array <code>edges</code> where <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> denotes a road between cities <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> that takes <code>time<sub>i</sub></code> minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.</p>\n\n<p>Each time you pass through a city, you must pay a passing fee. This is represented as a <strong>0-indexed</strong> integer array <code>passingFees</code> of length <code>n</code> where <code>passingFees[j]</code> is the amount of dollars you must pay when you pass through city <code>j</code>.</p>\n\n<p>In the beginning, you are at city <code>0</code> and want to reach city <code>n - 1</code> in <code>maxTime</code><strong> minutes or less</strong>. The <strong>cost</strong> of your journey is the <strong>summation of passing fees</strong> for each city that you passed through at some moment of your journey (<strong>including</strong> the source and destination cities).</p>\n\n<p>Given <code>maxTime</code>, <code>edges</code>, and <code>passingFees</code>, return <em>the <strong>minimum cost</strong> to complete your journey, or </em><code>-1</code><em> if you cannot complete it within </em><code>maxTime</code><em> minutes</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></p>\n\n<pre>\n<strong>Input:</strong> maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The path to take is 0 -&gt; 1 -&gt; 2 -&gt; 5, which takes 30 minutes and has $11 worth of passing fees.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<strong>Output:</strong> 48\n<strong>Explanation:</strong> The path to take is 0 -&gt; 3 -&gt; 4 -&gt; 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -&gt; 1 -&gt; 2 -&gt; 5 since it would take too long.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is no way to reach city 5 from city 0 within 25 minutes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxTime &lt;= 1000</code></li>\n\t<li><code>n == passingFees.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>n - 1 &lt;= edges.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>1 &lt;= passingFees[j] &lt;= 1000</code>&nbsp;</li>\n\t<li>The graph may contain multiple edges between two nodes.</li>\n\t<li>The graph does not contain self loops.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1328953,
                "title": "c-solution-dijkstra-s-algorithm",
                "content": "**Solution**\\n\\nThe problem can be solved using standard Dijkstra algorithm with slight modifications.\\n\\n- In priority queue for each vertex a vector corresponding to {cost, time, vertex} is stored.\\n- The priority queue will be a min-heap, the vectors will be arranged first by cost and then by time.\\n- Source vertex (0) will be push into min-heap first.\\n- Follow the standard dijkstra by popping vertices and traverse the connected edges.\\n- The difference here will be that only those edges will be traversed which will not cause the time to exceed  `maxTime`.\\n- Also a new entry will be pushed to heap if the cost or time of vertex will reduce.\\n- At the end return the cost of destination vertex(`dest`).\\n\\n**Note**: The reason for including extra condition which is allowing to traverse edges which cause the time to reduce is that it is possible that these edges led us to destination. However if we just traverse those edge causing cost to decrease then we are ignoring the time which can lead us to a non-optimal answer or even a case where time exceed the `maxTime` leading us to return `-1`.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj[1001];\\n    int cost[1001], time[1001];\\n    \\n    int dijkstra(int src, int dest, int maxTime) {\\n        \\n        for (int i = 1; i <= dest; i++) {\\n            cost[i] = INT_MAX;\\n            time[i] = INT_MAX;\\n        }\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({cost[src], time[src], src});\\n        \\n        while (pq.empty() == 0) {\\n            vector<int> z = pq.top(); pq.pop();\\n            \\n            int c = z[0];     // cost\\n            int t = z[1];     // time\\n            int v = z[2];     // vertex\\n            \\n            for (int i=0;i<adj[v].size();i++) {\\n                \\n\\t\\t\\t    // if this edge does not cause the time to exceed maxTime\\n                if (t + adj[v][i][1] <= maxTime) {\\n                    \\n\\t\\t\\t\\t    // if cost will decrease\\n                    if (cost[adj[v][i][0]] > c + adj[v][i][2]) {\\n                        cost[adj[v][i][0]] = c + adj[v][i][2];\\n                        \\n                        time[adj[v][i][0]] = t + adj[v][i][1];\\n                        pq.push({cost[adj[v][i][0]], time[adj[v][i][0]], adj[v][i][0]});\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// if time will decrease\\n                    else if (time[adj[v][i][0]] > t + adj[v][i][1]) {\\n                        time[adj[v][i][0]] = t + adj[v][i][1];\\n                        pq.push({c + adj[v][i][2], time[adj[v][i][0]], adj[v][i][0]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost[dest];\\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        int i, x, y, t, e = edges.size(), n = fee.size();\\n        \\n        for (i=0;i<e;i++) {\\n            x = edges[i][0];\\n            y = edges[i][1];\\n            t = edges[i][2];\\n            \\n            adj[x].push_back({y, t, fee[y]});\\n            adj[y].push_back({x, t, fee[x]});\\n        }\\n        \\n        cost[0] = fee[0];\\n        time[0] = 0;\\n        \\n        int ans = dijkstra(0, n-1, maxTime);\\n        \\n        if(ans == INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj[1001];\\n    int cost[1001], time[1001];\\n    \\n    int dijkstra(int src, int dest, int maxTime) {\\n        \\n        for (int i = 1; i <= dest; i++) {\\n            cost[i] = INT_MAX;\\n            time[i] = INT_MAX;\\n        }\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({cost[src], time[src], src});\\n        \\n        while (pq.empty() == 0) {\\n            vector<int> z = pq.top(); pq.pop();\\n            \\n            int c = z[0];     // cost\\n            int t = z[1];     // time\\n            int v = z[2];     // vertex\\n            \\n            for (int i=0;i<adj[v].size();i++) {\\n                \\n\\t\\t\\t    // if this edge does not cause the time to exceed maxTime\\n                if (t + adj[v][i][1] <= maxTime) {\\n                    \\n\\t\\t\\t\\t    // if cost will decrease\\n                    if (cost[adj[v][i][0]] > c + adj[v][i][2]) {\\n                        cost[adj[v][i][0]] = c + adj[v][i][2];\\n                        \\n                        time[adj[v][i][0]] = t + adj[v][i][1];\\n                        pq.push({cost[adj[v][i][0]], time[adj[v][i][0]], adj[v][i][0]});\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// if time will decrease\\n                    else if (time[adj[v][i][0]] > t + adj[v][i][1]) {\\n                        time[adj[v][i][0]] = t + adj[v][i][1];\\n                        pq.push({c + adj[v][i][2], time[adj[v][i][0]], adj[v][i][0]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost[dest];\\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        int i, x, y, t, e = edges.size(), n = fee.size();\\n        \\n        for (i=0;i<e;i++) {\\n            x = edges[i][0];\\n            y = edges[i][1];\\n            t = edges[i][2];\\n            \\n            adj[x].push_back({y, t, fee[y]});\\n            adj[y].push_back({x, t, fee[x]});\\n        }\\n        \\n        cost[0] = fee[0];\\n        time[0] = 0;\\n        \\n        int ans = dijkstra(0, n-1, maxTime);\\n        \\n        if(ans == INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328989,
                "title": "python3-modified-djikstra-s",
                "content": "The problem is very similar to cheapest flight within K stops.\\nhttps://leetcode.com/problems/cheapest-flights-within-k-stops/ \\n\\n\\n\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        \\n        g = [[] for i in range(n)]\\n        for e in edges:\\n            g[e[0]].append((e[1], e[2]))\\n            g[e[1]].append((e[0], e[2]))\\n            \\n        times = {}\\n        \\n        pq = [(passingFees[0],0,0)]\\n        \\n        while pq:\\n            cost, node, time = heapq.heappop(pq)\\n            \\n            if time > maxTime:\\n                continue\\n            \\n            if node == n-1:\\n                return cost\\n            \\n            if node not in times or times[node] > time:\\n                times[node] = time\\n                for nbor, trip in g[node]:\\n                    heapq.heappush(pq, (passingFees[nbor]+cost, nbor, time+trip))\\n            \\n            \\n    \\n        return -1\\n```\\n\\nEdit - A lot of folks have question over why we need to consider costlier routes later for the same node. Hope the below image clarifies those questions.\\n\\n\\n![image](https://assets.leetcode.com/users/images/9a025b9e-4e77-4fe3-bfb4-c05ee4185f4e_1626046391.5261254.jpeg)\\n\\n\\nIn this image - B is discovered first via the node A1, but the route A1-B-C does not meet the time constraint. \\n\\nThen B is again discovered via the node A2, this time the cost is more, but the time to reach C via A2-B-C meets the time constraint.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        \\n        g = [[] for i in range(n)]\\n        for e in edges:\\n            g[e[0]].append((e[1], e[2]))\\n            g[e[1]].append((e[0], e[2]))\\n            \\n        times = {}\\n        \\n        pq = [(passingFees[0],0,0)]\\n        \\n        while pq:\\n            cost, node, time = heapq.heappop(pq)\\n            \\n            if time > maxTime:\\n                continue\\n            \\n            if node == n-1:\\n                return cost\\n            \\n            if node not in times or times[node] > time:\\n                times[node] = time\\n                for nbor, trip in g[node]:\\n                    heapq.heappush(pq, (passingFees[nbor]+cost, nbor, time+trip))\\n            \\n            \\n    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328992,
                "title": "java-solution-priorityqueue",
                "content": "Please upvote if you like the solution :)\\n\\n```\\nclass Solution {\\n    List<int []> [] graph;\\n    \\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        graph = new List [n];\\n        \\n        int [] minTime = new int [n];\\n        \\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < n; ++i){\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for (int [] edge : edges){\\n            graph[edge[0]].add(new int [] {edge[1], edge[2] });\\n            graph[edge[1]].add(new int [] {edge[0], edge[2] });\\n        }\\n        \\n        PriorityQueue<int []> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        queue.add(new int [] {0, passingFees[0], 0});\\n        \\n        // node, fee, time spent\\n        int [] current;\\n        int size;\\n        \\n        int time, score;\\n        \\n        while (!queue.isEmpty()){\\n            current = queue.poll();\\n            \\n            if (current[2] >= minTime[current[0]])\\n                continue;\\n            \\n            minTime[current[0]] = current[2];\\n            \\n            if (current[0] == n - 1)\\n                return current[1];\\n            \\n            for (int [] next : graph[current[0]]){\\n                time = current[2] + next[1];\\n                score = current[1] + passingFees[next[0]];\\n                \\n                if (time > maxTime)\\n                    continue;\\n                else if (time > minTime[next[0]])\\n                    continue;\\n                \\n                queue.add(new int [] { next[0], score, time });\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<int []> [] graph;\\n    \\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        graph = new List [n];\\n        \\n        int [] minTime = new int [n];\\n        \\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < n; ++i){\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for (int [] edge : edges){\\n            graph[edge[0]].add(new int [] {edge[1], edge[2] });\\n            graph[edge[1]].add(new int [] {edge[0], edge[2] });\\n        }\\n        \\n        PriorityQueue<int []> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        queue.add(new int [] {0, passingFees[0], 0});\\n        \\n        // node, fee, time spent\\n        int [] current;\\n        int size;\\n        \\n        int time, score;\\n        \\n        while (!queue.isEmpty()){\\n            current = queue.poll();\\n            \\n            if (current[2] >= minTime[current[0]])\\n                continue;\\n            \\n            minTime[current[0]] = current[2];\\n            \\n            if (current[0] == n - 1)\\n                return current[1];\\n            \\n            for (int [] next : graph[current[0]]){\\n                time = current[2] + next[1];\\n                score = current[1] + passingFees[next[0]];\\n                \\n                if (time > maxTime)\\n                    continue;\\n                else if (time > minTime[next[0]])\\n                    continue;\\n                \\n                queue.add(new int [] { next[0], score, time });\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329158,
                "title": "easy-top-down-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> adj;\\n    int dp[1002][1002];\\n    int go(int sum,vector<int> &cost,int src=0)\\n    {\\n        if(sum<0)\\n            return INT_MAX-1000;\\n        if(src==cost.size()-1)\\n            return sum>=0?0:INT_MAX-1000;\\n        if(dp[sum][src]!=-1)\\n            return dp[sum][src];\\n        int res=INT_MAX-1000;\\n        for(auto i:adj[src])\\n        {\\n            res=min(res,cost[src]+go(sum-i.second,cost,i.first));\\n        }\\n        return dp[sum][src]=res;\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        adj.clear();\\n          for(auto i:edges)\\n          {\\n              adj[i[0]].push_back({i[1],i[2]});\\n              adj[i[1]].push_back({i[0],i[2]});\\n          }\\n        int ans=go(maxTime,cost);\\n        if(ans==2147482647)\\n            return -1;\\n        return cost[size(cost)-1]+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<pair<int,int>>> adj;\\n    int dp[1002][1002];\\n    int go(int sum,vector<int> &cost,int src=0)\\n    {\\n        if(sum<0)\\n            return INT_MAX-1000;\\n        if(src==cost.size()-1)\\n            return sum>=0?0:INT_MAX-1000;\\n        if(dp[sum][src]!=-1)\\n            return dp[sum][src];\\n        int res=INT_MAX-1000;\\n        for(auto i:adj[src])\\n        {\\n            res=min(res,cost[src]+go(sum-i.second,cost,i.first));\\n        }\\n        return dp[sum][src]=res;\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        adj.clear();\\n          for(auto i:edges)\\n          {\\n              adj[i[0]].push_back({i[1],i[2]});\\n              adj[i[1]].push_back({i[0],i[2]});\\n          }\\n        int ans=go(maxTime,cost);\\n        if(ans==2147482647)\\n            return -1;\\n        return cost[size(cost)-1]+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329145,
                "title": "c-dijkstra",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Dijkstra\\n\\nUse a min-heap to have the nodes with the smallest cost at the top.\\n\\n![image](https://assets.leetcode.com/users/images/d70e3034-ecac-4912-82ef-b9bb5a40741a_1625943562.271901.png)\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE)\\n// Space: O(V + E)\\nclass Solution {\\n    typedef array<int, 3> Node; // node, time, cost\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& E, vector<int>& F) {\\n        int N = F.size();\\n        vector<unordered_map<int, int>> G(N);\\n        vector<int> minTime(N, maxTime + 1);\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1], t = e[2];\\n            if (G[u].count(v)) { // For duplicated edges, we just need to keep track of the edge with smallest time.\\n                G[u][v] = G[v][u] = min(G[u][v], t);\\n            } else {\\n                G[u][v] = G[v][u] = t;\\n            }\\n        }\\n        auto cmp = [](auto &a, auto &b) { return a[2] > b[2]; }; // min-heap: Heap top is the node with the smallest cost to reach\\n        priority_queue<Node, vector<Node>, decltype(cmp)> pq(cmp);\\n        pq.push({0, 0, F[0]});\\n        minTime[0] = 0;\\n        while (pq.size()) {\\n            auto [u, time, c] = pq.top();\\n            pq.pop();\\n            if (u == N - 1) return c;\\n            for (auto &[v, t] : G[u]) {\\n                int nt = time + t, nc = c + F[v];\\n                if (nt < minTime[v]) {\\n                    minTime[v] = nt;\\n                    pq.push({v, nt, nc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE)\\n// Space: O(V + E)\\nclass Solution {\\n    typedef array<int, 3> Node; // node, time, cost\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& E, vector<int>& F) {\\n        int N = F.size();\\n        vector<unordered_map<int, int>> G(N);\\n        vector<int> minTime(N, maxTime + 1);\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1], t = e[2];\\n            if (G[u].count(v)) { // For duplicated edges, we just need to keep track of the edge with smallest time.\\n                G[u][v] = G[v][u] = min(G[u][v], t);\\n            } else {\\n                G[u][v] = G[v][u] = t;\\n            }\\n        }\\n        auto cmp = [](auto &a, auto &b) { return a[2] > b[2]; }; // min-heap: Heap top is the node with the smallest cost to reach\\n        priority_queue<Node, vector<Node>, decltype(cmp)> pq(cmp);\\n        pq.push({0, 0, F[0]});\\n        minTime[0] = 0;\\n        while (pq.size()) {\\n            auto [u, time, c] = pq.top();\\n            pq.pop();\\n            if (u == N - 1) return c;\\n            for (auto &[v, t] : G[u]) {\\n                int nt = time + t, nc = c + F[v];\\n                if (nt < minTime[v]) {\\n                    minTime[v] = nt;\\n                    pq.push({v, nt, nc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366641,
                "title": "java-20-lines-bottom-up-dp-clear-explanation",
                "content": "# Explaination:\\n* Create a 2D matrix  `dp[maxTime+1][n]` and initialise the elements to `infinity`.  \\n* `dp[t][i] `stores the minimum cost to reach node `i` **at `time = t`** . \\n* At `t = 0`, you are at `source = 0`, \\n* Since you have to pay fees to be even present at a node, so you start the journey with minimum fees of `fee[source]` . So update the dp as `dp[0][0] = fee[source]`. \\n* Now start looping from `currTime = 0` to `currTime = maxTime`. For each `currTime`, loop through every `edge {a,b,timeCost}`. \\n* If `dp[currTime][i] == infinity`, then it means that node` i` was not reachable **at** `t = currTime`\\n* So, while looping through every `edge {a,b,timeCost}`, check if `dp[currTime][a]  == infinity` or `dp[currTime][b]  == infinity` before making any change to dp state.\\n* Let `fromNode = a` and `toNode = b` (we have to again swap these to handle bidirectional movement )\\n* If `dp[currTime][fromNode]  != infinity`, then it means at` t = currTime` we have managed to reach `fromNode` so we can traverse to `toNode` at `timeCost`, hence we will reach `toNode` at `reachTime = currTime + timeCost`\\n* If this `reachTime <= maxTime`, update the cost in `dp`\\n* After the dp is populated, loop through from `t = 0`  to `t = maxTime` and pick the minCost from `dp[t][n]`\\n\\n\\n-----\\n**Request:** Please upvote this post if you found it helpful. This is the only way you can show your gratitude for my work.\\n\\n------\\n\\n\\n\\n# Code:\\n<iframe src=\"https://leetcode.com/playground/2BNqd9sJ/shared\" frameBorder=\"0\" width=\"1000\" height=\"420\"></iframe>\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "# Explaination:\\n* Create a 2D matrix  `dp[maxTime+1][n]` and initialise the elements to `infinity`.  \\n* `dp[t][i] `stores the minimum cost to reach node `i` **at `time = t`** . \\n* At `t = 0`, you are at `source = 0`, \\n* Since you have to pay fees to be even present at a node, so you start the journey with minimum fees of `fee[source]` . So update the dp as `dp[0][0] = fee[source]`. \\n* Now start looping from `currTime = 0` to `currTime = maxTime`. For each `currTime`, loop through every `edge {a,b,timeCost}`. \\n* If `dp[currTime][i] == infinity`, then it means that node` i` was not reachable **at** `t = currTime`\\n* So, while looping through every `edge {a,b,timeCost}`, check if `dp[currTime][a]  == infinity` or `dp[currTime][b]  == infinity` before making any change to dp state.\\n* Let `fromNode = a` and `toNode = b` (we have to again swap these to handle bidirectional movement )\\n* If `dp[currTime][fromNode]  != infinity`, then it means at` t = currTime` we have managed to reach `fromNode` so we can traverse to `toNode` at `timeCost`, hence we will reach `toNode` at `reachTime = currTime + timeCost`\\n* If this `reachTime <= maxTime`, update the cost in `dp`\\n* After the dp is populated, loop through from `t = 0`  to `t = maxTime` and pick the minCost from `dp[t][n]`\\n\\n\\n-----\\n**Request:** Please upvote this post if you found it helpful. This is the only way you can show your gratitude for my work.\\n\\n------\\n\\n\\n\\n# Code:\\n<iframe src=\"https://leetcode.com/playground/2BNqd9sJ/shared\" frameBorder=\"0\" width=\"1000\" height=\"420\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1329478,
                "title": "c-solution-100-knapsack-dp-problem-in-graph",
                "content": "we can assume it as a knapsack DP problem with passtime as cost[n], maxTime as Total Weight,edge time as weight[n]. we have to minimize the total cost with a Weight Constraints (maxTime).\\nHere is the recursive approach with memoization.\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int time,vector<pair<int,int>> adj[],int v,vector<int> &pass){\\n        if(time<0) return INT_MAX;\\n        int n = pass.size();\\n        if(v==n-1){\\n            return pass[v];\\n        }\\n        if(dp[v][time]!=-1) return dp[v][time];\\n        int cost = INT_MAX;\\n        for(auto &x:adj[v]){\\n            int u = x.first;\\n            int temp = x.second;\\n            if(temp<=time){\\n               int sol = solve(time-temp,adj,u,pass);\\n            cost = min(cost,sol);\\n            }\\n        }\\n        if(cost==INT_MAX) return dp[v][time] = INT_MAX;\\n        return dp[v][time] = cost + pass[v]; \\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = pass.size();\\n        vector<pair<int,int>> adj[n];\\n        for(int i = 0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));\\n             adj[edges[i][1]].push_back(make_pair(edges[i][0],edges[i][2]));\\n            \\n        }\\n        int ans = solve(maxTime,adj,0,pass);\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```\\nPlease leave a comment if needs help.\\nIf you like it ...please upvote so that it can reach to other people also.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int time,vector<pair<int,int>> adj[],int v,vector<int> &pass){\\n        if(time<0) return INT_MAX;\\n        int n = pass.size();\\n        if(v==n-1){\\n            return pass[v];\\n        }\\n        if(dp[v][time]!=-1) return dp[v][time];\\n        int cost = INT_MAX;\\n        for(auto &x:adj[v]){\\n            int u = x.first;\\n            int temp = x.second;\\n            if(temp<=time){\\n               int sol = solve(time-temp,adj,u,pass);\\n            cost = min(cost,sol);\\n            }\\n        }\\n        if(cost==INT_MAX) return dp[v][time] = INT_MAX;\\n        return dp[v][time] = cost + pass[v]; \\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = pass.size();\\n        vector<pair<int,int>> adj[n];\\n        for(int i = 0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));\\n             adj[edges[i][1]].push_back(make_pair(edges[i][0],edges[i][2]));\\n            \\n        }\\n        int ans = solve(maxTime,adj,0,pass);\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166087,
                "title": "21ms-beats-100-dijkstra-with-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Standard Dijkstra, [40ms](https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/submissions/894999497/)\\n```java\\nclass Solution {\\n    record Node(int i, int t) {}\\n    record Cell(int i, int t, int c) {}\\n    public int minCost(int maxTime, int[][] edges, int[] fees) {\\n        int n = fees.length;\\n\\n        // create the adjacency list graph\\n        List<Node>[] g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            g[e[0]].add(new Node(e[1], e[2]));\\n            g[e[1]].add(new Node(e[0], e[2]));\\n        }\\n\\n        // Dijkstra\\n        Queue<Cell> q = new PriorityQueue<>((a, b) -> a.c == b.c ? a.t - b.t : a.c - b.c);\\n        int[] T = new int[n]; // 1. visited: de-dup 2. de-dup on worst time\\n\\n        q.offer(new Cell(0, 0, fees[0]));\\n        Arrays.fill(T, maxTime + 1);\\n        T[0] = 0;\\n\\n        while (!q.isEmpty()) {\\n            var cur = q.poll();\\n            if (cur.i == n-1) return cur.c;\\n            \\n            for (var nei : g[cur.i]) {\\n                int t2 = cur.t + nei.t;\\n                if (t2 >= T[nei.i]) continue; // if time is worst, no reason to continue\\n                T[nei.i] = t2;\\n                q.offer(new Cell(nei.i, t2, cur.c + fees[nei.i]));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n# Optimize on time, early pruning [21ms](https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/submissions/895019270/)\\n```java\\nclass Solution {\\n    record Node(int i, int t) {}\\n    record Cell(int i, int t, int c) {}\\n    public int minCost(int maxTime, int[][] edges, int[] fees) {\\n        int n = fees.length;\\n\\n        // create the graph\\n        List<Node>[] g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            g[e[0]].add(new Node(e[1], e[2]));\\n            g[e[1]].add(new Node(e[0], e[2]));\\n        }\\n\\n        // min time from end to each node\\n        int[] time = new int[n];\\n        Arrays.fill(time, Integer.MAX_VALUE);\\n        time[n-1] = 0;\\n        Queue<Integer> q = new PriorityQueue<>((a, b) -> time[a] - time[b]);\\n        q.offer(n-1);\\n        while (!q.isEmpty()) {\\n            int cur = q.poll();\\n            for (var nei : g[cur]) {\\n                int t2 = time[cur] + nei.t;\\n                if (t2 >= time[nei.i]) continue;\\n                time[nei.i] = t2;\\n                q.offer(nei.i);\\n            }\\n        }\\n\\n        // Dijkstra\\n        Queue<Cell> q2 = new PriorityQueue<>((a, b) -> a.c - b.c);\\n        int[] T = new int[n]; // 1. visited: de-dup 2. de-dup on worst time\\n\\n        q2.offer(new Cell(0, 0, fees[0]));\\n        Arrays.fill(T, maxTime + 1);\\n        T[0] = 0;\\n\\n        while (!q2.isEmpty()) {\\n            var cur = q2.poll();\\n            if (cur.i == n-1) return cur.c;\\n            \\n            for (var nei : g[cur.i]) {\\n                int t2 = cur.t + nei.t;\\n                if (time[nei.i] + t2 > maxTime) continue; // at this point we know we can skip\\n                if (t2 >= T[nei.i]) continue; // if time is worst, no reason to continue\\n                T[nei.i] = t2;\\n                q2.offer(new Cell(nei.i, t2, cur.c + fees[nei.i]));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    record Node(int i, int t) {}\\n    record Cell(int i, int t, int c) {}\\n    public int minCost(int maxTime, int[][] edges, int[] fees) {\\n        int n = fees.length;\\n\\n        // create the adjacency list graph\\n        List<Node>[] g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            g[e[0]].add(new Node(e[1], e[2]));\\n            g[e[1]].add(new Node(e[0], e[2]));\\n        }\\n\\n        // Dijkstra\\n        Queue<Cell> q = new PriorityQueue<>((a, b) -> a.c == b.c ? a.t - b.t : a.c - b.c);\\n        int[] T = new int[n]; // 1. visited: de-dup 2. de-dup on worst time\\n\\n        q.offer(new Cell(0, 0, fees[0]));\\n        Arrays.fill(T, maxTime + 1);\\n        T[0] = 0;\\n\\n        while (!q.isEmpty()) {\\n            var cur = q.poll();\\n            if (cur.i == n-1) return cur.c;\\n            \\n            for (var nei : g[cur.i]) {\\n                int t2 = cur.t + nei.t;\\n                if (t2 >= T[nei.i]) continue; // if time is worst, no reason to continue\\n                T[nei.i] = t2;\\n                q.offer(new Cell(nei.i, t2, cur.c + fees[nei.i]));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    record Node(int i, int t) {}\\n    record Cell(int i, int t, int c) {}\\n    public int minCost(int maxTime, int[][] edges, int[] fees) {\\n        int n = fees.length;\\n\\n        // create the graph\\n        List<Node>[] g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            g[e[0]].add(new Node(e[1], e[2]));\\n            g[e[1]].add(new Node(e[0], e[2]));\\n        }\\n\\n        // min time from end to each node\\n        int[] time = new int[n];\\n        Arrays.fill(time, Integer.MAX_VALUE);\\n        time[n-1] = 0;\\n        Queue<Integer> q = new PriorityQueue<>((a, b) -> time[a] - time[b]);\\n        q.offer(n-1);\\n        while (!q.isEmpty()) {\\n            int cur = q.poll();\\n            for (var nei : g[cur]) {\\n                int t2 = time[cur] + nei.t;\\n                if (t2 >= time[nei.i]) continue;\\n                time[nei.i] = t2;\\n                q.offer(nei.i);\\n            }\\n        }\\n\\n        // Dijkstra\\n        Queue<Cell> q2 = new PriorityQueue<>((a, b) -> a.c - b.c);\\n        int[] T = new int[n]; // 1. visited: de-dup 2. de-dup on worst time\\n\\n        q2.offer(new Cell(0, 0, fees[0]));\\n        Arrays.fill(T, maxTime + 1);\\n        T[0] = 0;\\n\\n        while (!q2.isEmpty()) {\\n            var cur = q2.poll();\\n            if (cur.i == n-1) return cur.c;\\n            \\n            for (var nei : g[cur.i]) {\\n                int t2 = cur.t + nei.t;\\n                if (time[nei.i] + t2 > maxTime) continue; // at this point we know we can skip\\n                if (t2 >= T[nei.i]) continue; // if time is worst, no reason to continue\\n                T[nei.i] = t2;\\n                q2.offer(new Cell(nei.i, t2, cur.c + fees[nei.i]));\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329036,
                "title": "modified-dijkstra-s",
                "content": "We run Dijkstra, and for each node we track the sorted list of `{fee, time}`. This allows us to prune costly paths that do not save us time.\\n \\nI initially did not use the min heap for the queue, and got TLE. \\n\\n**C++**\\n```cpp\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n    vector<set<array<int, 2>>> state(fees.size()); // city: {fee, time}\\n    vector<vector<array<int, 2>>> al(fees.size()); // city i : {city j, time}\\n    for (auto &e : edges) {\\n        al[e[0]].push_back({e[1], e[2]});\\n        al[e[1]].push_back({e[0], e[2]});\\n    }\\n    priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> q;\\n    q.push({fees[0], 0, 0}); // {fee, time, city}\\n    while(!q.empty()) {\\n        auto [fee, time, city] = q.top(); q.pop();\\n        if (city == fees.size() - 1)\\n            return fee;\\n        for (auto [city1, time1] : al[city]) {\\n            if (time + time1 <= maxTime) {\\n                auto it = state[city1].upper_bound({fee + fees[city1], time + time1});\\n                if (it == begin(state[city1]) || (*prev(it))[1] > time + time1) {\\n                    state[city1].insert({fee + fees[city1], time + time1});\\n                    q.push({fee + fees[city1], time + time1, city1 });\\n                }\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n    vector<set<array<int, 2>>> state(fees.size()); // city: {fee, time}\\n    vector<vector<array<int, 2>>> al(fees.size()); // city i : {city j, time}\\n    for (auto &e : edges) {\\n        al[e[0]].push_back({e[1], e[2]});\\n        al[e[1]].push_back({e[0], e[2]});\\n    }\\n    priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> q;\\n    q.push({fees[0], 0, 0}); // {fee, time, city}\\n    while(!q.empty()) {\\n        auto [fee, time, city] = q.top(); q.pop();\\n        if (city == fees.size() - 1)\\n            return fee;\\n        for (auto [city1, time1] : al[city]) {\\n            if (time + time1 <= maxTime) {\\n                auto it = state[city1].upper_bound({fee + fees[city1], time + time1});\\n                if (it == begin(state[city1]) || (*prev(it))[1] > time + time1) {\\n                    state[city1].insert({fee + fees[city1], time + time1});\\n                    q.push({fee + fees[city1], time + time1, city1 });\\n                }\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387532,
                "title": "c-dijkstra-track-time-taken-instead-of-visited-nodes-picture-illustration",
                "content": "This problem is very similar to **787. Cheapest Flights Within K Stops**\\nIn dijkstra algo, we keep track of minimum distance, and we stop traversing node once it is visited.\\n\\nWe do so, because we know that once a node is processed with minimum distance, no matter what other routes we take, it will no more be minimum.\\n\\nWe can take similar idea here. The condition is that, we are allowed to visit a node as long as we can visit within `maxTime` minutes.\\n\\nLet\\'s take an example below-\\n\\nFor the simplicity, I have taken time spent for each path as per the below graph, and `maxTime` as 5.\\n![image](https://assets.leetcode.com/users/images/b401983f-c103-4fa4-bc80-d23c3831c6b0_1628271830.0042944.png)\\n\\nFrom the above, there are two possible paths [sky, blue] to reach destination. \\nEach path will take 5 mins, and cost of sky path will be 10, where as cost of blue path will be 9.\\n\\nNotice that, to reach node-1 from node-0, we can take sky or blue path. \\nAt first glance, we can pick sky path, because it will give us minimum cost(1 + 5) as compared to blue path(1 + 2 + 5).\\n\\nBut later on, sky path will be more costlier to us than blue path. So we should be considering every possible path as long as the total time spent doesn\\'t exceed the `maxTime`.  \\n\\nWhenever we notice that the new time spent to reach a particular node exceeds the previous time spent, we will stop considering the node.\\n\\nRest, it will be as similar as dijkstra algo.\\n\\n<iframe src=\"https://leetcode.com/playground/NLiZpaAy/shared\" frameBorder=\"0\" width=\"900\" height=\"700\"></iframe>\\n\\nTime and space complexity will be same as dijkstra algo.",
                "solutionTags": [],
                "code": "This problem is very similar to **787. Cheapest Flights Within K Stops**\\nIn dijkstra algo, we keep track of minimum distance, and we stop traversing node once it is visited.\\n\\nWe do so, because we know that once a node is processed with minimum distance, no matter what other routes we take, it will no more be minimum.\\n\\nWe can take similar idea here. The condition is that, we are allowed to visit a node as long as we can visit within `maxTime` minutes.\\n\\nLet\\'s take an example below-\\n\\nFor the simplicity, I have taken time spent for each path as per the below graph, and `maxTime` as 5.\\n![image](https://assets.leetcode.com/users/images/b401983f-c103-4fa4-bc80-d23c3831c6b0_1628271830.0042944.png)\\n\\nFrom the above, there are two possible paths [sky, blue] to reach destination. \\nEach path will take 5 mins, and cost of sky path will be 10, where as cost of blue path will be 9.\\n\\nNotice that, to reach node-1 from node-0, we can take sky or blue path. \\nAt first glance, we can pick sky path, because it will give us minimum cost(1 + 5) as compared to blue path(1 + 2 + 5).\\n\\nBut later on, sky path will be more costlier to us than blue path. So we should be considering every possible path as long as the total time spent doesn\\'t exceed the `maxTime`.  \\n\\nWhenever we notice that the new time spent to reach a particular node exceeds the previous time spent, we will stop considering the node.\\n\\nRest, it will be as similar as dijkstra algo.\\n\\n<iframe src=\"https://leetcode.com/playground/NLiZpaAy/shared\" frameBorder=\"0\" width=\"900\" height=\"700\"></iframe>\\n\\nTime and space complexity will be same as dijkstra algo.",
                "codeTag": "Unknown"
            },
            {
                "id": 1329417,
                "title": "c-solution-using-dijkstra-s-algorithm-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& e, vector<int>& fees) {\\n        \\n        //the number of nodes\\n        int n=fees.size();\\n        \\n        using pi=pair<int,pair<int,int>> ;\\n        //min heap \\n        //pq contains the format {cost,{time,node}} \\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        \\n        //create a adjacency list\\n        vector<vector<pair<int,int>>> adj(fees.size());\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1],e[i][2]});\\n            adj[e[i][1]].push_back({e[i][0],e[i][2]});\\n        }\\n        \\n        \\n        vector<int> cost(n,INT_MAX);\\n        vector<int> time(n,INT_MAX);\\n        cost[0]=fees[0];\\n        time[0]=0;\\n        \\n        pq.push({cost[0],{time[0],0}});\\n        while(!pq.empty())\\n        {\\n            auto [currCost,v]=pq.top();\\n            auto [currMin,node]=v;\\n            pq.pop();\\n            for(auto [x,t] :  adj[node])\\n            {\\n                \\n                //if you can reach the city in <=maxTime\\n                if(currMin + t <= maxTime)\\n                {\\n                    //check if the cost can be decreased\\n                    if(cost[x] > currCost+fees[x])\\n                    {\\n                        cost[x]=currCost+fees[x];\\n                        \\n                        time[x] = currMin + t;\\n                        //push it into pq\\n                        pq.push({cost[x],{time[x],x}});\\n                    }\\n                    \\n                    //if the cost of the current node cannot be decreased then check\\n                    //if we can decrease the time of the node\\n                    else if(time[x] > currMin+t)\\n                    {\\n                        //update the time\\n                        time[x]=currMin+t;\\n                        //push it into pq\\n                        pq.push({currCost+fees[x],{time[x],x}});\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return cost[n-1]==INT_MAX ? -1 : cost[n-1];\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& e, vector<int>& fees) {\\n        \\n        //the number of nodes\\n        int n=fees.size();\\n        \\n        using pi=pair<int,pair<int,int>> ;\\n        //min heap \\n        //pq contains the format {cost,{time,node}} \\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        \\n        //create a adjacency list\\n        vector<vector<pair<int,int>>> adj(fees.size());\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1],e[i][2]});\\n            adj[e[i][1]].push_back({e[i][0],e[i][2]});\\n        }\\n        \\n        \\n        vector<int> cost(n,INT_MAX);\\n        vector<int> time(n,INT_MAX);\\n        cost[0]=fees[0];\\n        time[0]=0;\\n        \\n        pq.push({cost[0],{time[0],0}});\\n        while(!pq.empty())\\n        {\\n            auto [currCost,v]=pq.top();\\n            auto [currMin,node]=v;\\n            pq.pop();\\n            for(auto [x,t] :  adj[node])\\n            {\\n                \\n                //if you can reach the city in <=maxTime\\n                if(currMin + t <= maxTime)\\n                {\\n                    //check if the cost can be decreased\\n                    if(cost[x] > currCost+fees[x])\\n                    {\\n                        cost[x]=currCost+fees[x];\\n                        \\n                        time[x] = currMin + t;\\n                        //push it into pq\\n                        pq.push({cost[x],{time[x],x}});\\n                    }\\n                    \\n                    //if the cost of the current node cannot be decreased then check\\n                    //if we can decrease the time of the node\\n                    else if(time[x] > currMin+t)\\n                    {\\n                        //update the time\\n                        time[x]=currMin+t;\\n                        //push it into pq\\n                        pq.push({currCost+fees[x],{time[x],x}});\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return cost[n-1]==INT_MAX ? -1 : cost[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328971,
                "title": "simple-dijstra-algorithm-with-explanation-cpp",
                "content": "```\\n//Basically the problem is Single source shortest path problem with time constraint.\\n\\n// DIJSTRA ALGO\\n//PLEASE GUYZ UPVOTE IT!!! THANK YOU\\n\\n\\n\\n\\n\\n#define pr pair<int, pair<int, int>>\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n\\n    \\n    int minCost(int maxTime, vector<vector<int>>& ed, vector<int>& pass) {\\n        int n = pass.size();\\n        vector<pair<int, int>> adj[n];\\n        \\n        //making a graph\\n        for(vector<int> e: ed) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n            adj[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        //taking min priority queue as {cost, vertex, time} \\n        priority_queue<pr, vector<pr>, greater<pr>> pq;\\n        //Initial vertex\\n        pq.push({pass[0], {0, 0}});\\n        \\n        //map to track of vertex which is visited with minimum time\\n        //It maps vertex and minimum time to reach that vertex\\n        unordered_map<int, int> vis;\\n        \\n        \\n        //Simple Dijstra algorithm\\n        while(!pq.empty()) {\\n            pr crr = pq.top(); pq.pop();\\n            int curr = crr.second.first, time = crr.second.second, cost = crr.first;\\n            \\n            //Destination\\n            if(curr == n-1) return cost;\\n            \\n            //Visited with current time\\n            vis[curr] = time;\\n            \\n            for(pair<int, int> p: adj[curr]) {\\n                int ad = p.first, ctime = p.second;\\n                int ttime = time + ctime;\\n                \\n                //if vertex is not visited or vertex is visited prior but with more time, we push it into queue else continue\\n                if(vis.find(ad) != vis.end() && vis[ad] <= ttime) continue;\\n                vis[ad] = ttime;\\n                //check if total time is less or equal to maxTime\\n                if(ttime <= maxTime) pq.push({cost + pass[ad], {ad, ttime}});\\n            }\\n            \\n        }\\n        \\n        //Not possible\\n        return -1;\\n        \\n        //If you understood please upvote!!!\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    \\n    int minCost(int maxTime, vector<vector<int>>& ed, vector<int>& pass) {\\n        int n = pass.size();\\n        vector<pair<int, int>> adj[n];\\n        \\n        //making a graph\\n        for(vector<int> e: ed) {\\n            adj[e[0]].push_back({e[1], e[2]}",
                "codeTag": "Java"
            },
            {
                "id": 3696874,
                "title": "c-dp-recursive-dijkstra-two-approach",
                "content": "# Code: (Using dp)\\n```\\nclass Solution{\\npublic:\\n    int dp[1002][1002], n;\\n    int solve(int maxTime, int src, vector<int> &cost, vector<pair<int, int>> g[])\\n    {\\n        if (maxTime < 0)\\n            return 1e9;\\n\\n        if (src == n - 1)\\n            return maxTime >= 0 ? cost[n - 1] : 1e9;\\n\\n        if (dp[maxTime][src] != -1)\\n            return dp[maxTime][src];\\n\\n        int ans = 1e9;\\n        for (auto [child, time] : g[src])\\n            ans = min(ans, cost[src] + solve(maxTime - time, child, cost, g));\\n\\n        return dp[maxTime][src] = ans;\\n    }\\n\\n    int minCost(int maxTime, vector<vector<int>> &edges, vector<int> &cost)\\n    {\\n        n = cost.size();\\n        vector<pair<int, int>> g[n];\\n        memset(dp, -1, sizeof(dp));\\n        for (auto edge : edges)\\n        {\\n            g[edge[0]].push_back({edge[1], edge[2]});\\n            g[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        int ans = solve(maxTime, 0, cost, g);\\n        return ans == 1e9 ? -1 : ans;\\n    }\\n};\\n\\n```\\n\\n\\n# Code: (Using Dijkstra)\\n```\\nclass Solution {\\npublic:\\n    struct comp{\\n        int fees, time, node;\\n    };\\n\\n    struct graph_comp{\\n        int child, time, fees;\\n    };\\n\\n    struct myCmp{\\n        bool operator()(comp below, comp above)\\n        {\\n            if(below.fees == above.fees)\\n                return below.time > above.time;\\n            \\n            return below.fees > above.fees;\\n        }\\n    };\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<graph_comp> g[n];\\n        for(auto edge : edges)\\n        {\\n            g[edge[0]].push_back({edge[1], edge[2], passingFees[edge[1]]});\\n            g[edge[1]].push_back({edge[0], edge[2], passingFees[edge[0]]});\\n        }\\n\\n        priority_queue<comp, vector<comp>, myCmp> pq;\\n        vector<int> cost(n, 1e9);\\n        vector<int> time(n, 1e9);\\n\\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        pq.push({cost[0], time[0], 0});\\n\\n        while(!pq.empty())\\n        {\\n            auto par = pq.top();\\n            pq.pop();\\n\\n            for(auto curr : g[par.node])\\n            {\\n                if(par.time + curr.time > maxTime)\\n                    continue;\\n                \\n                if(cost[curr.child] > par.fees + curr.fees)\\n                {\\n                    cost[curr.child] = par.fees + curr.fees;\\n                    time[curr.child] = par.time + curr.time;\\n                    pq.push({cost[curr.child], time[curr.child], curr.child});\\n                }\\n                else if(time[curr.child] > par.time + curr.time)\\n                {\\n                    time[curr.child] = par.time + curr.time;\\n                    pq.push({par.fees + curr.fees, time[curr.child], curr.child});\\n                }\\n\\n            }\\n        }\\n\\n        return cost[n - 1] == 1e9 ? -1 : cost[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph",
                    "Recursion",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int dp[1002][1002], n;\\n    int solve(int maxTime, int src, vector<int> &cost, vector<pair<int, int>> g[])\\n    {\\n        if (maxTime < 0)\\n            return 1e9;\\n\\n        if (src == n - 1)\\n            return maxTime >= 0 ? cost[n - 1] : 1e9;\\n\\n        if (dp[maxTime][src] != -1)\\n            return dp[maxTime][src];\\n\\n        int ans = 1e9;\\n        for (auto [child, time] : g[src])\\n            ans = min(ans, cost[src] + solve(maxTime - time, child, cost, g));\\n\\n        return dp[maxTime][src] = ans;\\n    }\\n\\n    int minCost(int maxTime, vector<vector<int>> &edges, vector<int> &cost)\\n    {\\n        n = cost.size();\\n        vector<pair<int, int>> g[n];\\n        memset(dp, -1, sizeof(dp));\\n        for (auto edge : edges)\\n        {\\n            g[edge[0]].push_back({edge[1], edge[2]});\\n            g[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        int ans = solve(maxTime, 0, cost, g);\\n        return ans == 1e9 ? -1 : ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    struct comp{\\n        int fees, time, node;\\n    };\\n\\n    struct graph_comp{\\n        int child, time, fees;\\n    };\\n\\n    struct myCmp{\\n        bool operator()(comp below, comp above)\\n        {\\n            if(below.fees == above.fees)\\n                return below.time > above.time;\\n            \\n            return below.fees > above.fees;\\n        }\\n    };\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<graph_comp> g[n];\\n        for(auto edge : edges)\\n        {\\n            g[edge[0]].push_back({edge[1], edge[2], passingFees[edge[1]]});\\n            g[edge[1]].push_back({edge[0], edge[2], passingFees[edge[0]]});\\n        }\\n\\n        priority_queue<comp, vector<comp>, myCmp> pq;\\n        vector<int> cost(n, 1e9);\\n        vector<int> time(n, 1e9);\\n\\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        pq.push({cost[0], time[0], 0});\\n\\n        while(!pq.empty())\\n        {\\n            auto par = pq.top();\\n            pq.pop();\\n\\n            for(auto curr : g[par.node])\\n            {\\n                if(par.time + curr.time > maxTime)\\n                    continue;\\n                \\n                if(cost[curr.child] > par.fees + curr.fees)\\n                {\\n                    cost[curr.child] = par.fees + curr.fees;\\n                    time[curr.child] = par.time + curr.time;\\n                    pq.push({cost[curr.child], time[curr.child], curr.child});\\n                }\\n                else if(time[curr.child] > par.time + curr.time)\\n                {\\n                    time[curr.child] = par.time + curr.time;\\n                    pq.push({par.fees + curr.fees, time[curr.child], curr.child});\\n                }\\n\\n            }\\n        }\\n\\n        return cost[n - 1] == 1e9 ? -1 : cost[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989163,
                "title": "c-dijkstra-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int minfs = INT_MAX;\\n        \\n        vector<pair<int,int>> adj[passingFees.size()];\\n        \\n        // Creating the adjacency list...\\n        for(auto it : edges){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        \\n        // Initialising time and cost array which will be populated as time[i] = minimum time to reach ith node...\\n        vector<int> time(passingFees.size(),INT_MAX);\\n        \\n        // cost[i] = min cost to reach ith node from 0...\\n        vector<int> cost(passingFees.size(),INT_MAX);\\n        \\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        \\n        // Creating min-heap which will keep sorted values in priority of { cost, time, node }...\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        \\n        pq.push({cost[0],{0,0}});\\n        \\n        // Dijkstra\\'s Algo...\\n        while(!pq.empty()){\\n            auto tops = pq.top();\\n            pq.pop();\\n            \\n            int node = tops.second.second;\\n            \\n            int cst = tops.first;\\n            int tm = tops.second.first;\\n            \\n            if(node == passingFees.size() - 1 && tm <= maxTime){\\n                \\n                // If we have reached the n-1th node then return the cost...\\n                return minfs = min(minfs,cst);\\n            }\\n            \\n            for(auto it : adj[node]){\\n                int nowdtm = it.second;\\n                int nowcst = passingFees[it.first];\\n                \\n                // push the node if its cheaper and time to reach it is less than maxTime...\\n                if(tm + nowdtm <= maxTime && cost[it.first] >= cst + nowcst){\\n                    cost[it.first] = cst + nowcst;\\n                    time[it.first] = nowdtm + tm;\\n                    pq.push({cst + nowcst,{nowdtm + tm,it.first}});\\n                }\\n                \\n                // push the node if time to reach it is less than the time it took before..\\n                else if(nowdtm + tm < time[it.first]){\\n                    time[it.first] = nowdtm + tm;\\n                    pq.push({cst + nowcst,{nowdtm + tm,it.first}});\\n                }\\n            }\\n            \\n        }\\n        \\n        // If the distance from 0 - N-1 node is not updated then its impossible to reach...\\n        if(minfs == INT_MAX) return -1;\\n        return minfs;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int minfs = INT_MAX;\\n        \\n        vector<pair<int,int>> adj[passingFees.size()];\\n        \\n        // Creating the adjacency list...\\n        for(auto it : edges){\\n            adj[it[0]].push_back({it[1],it[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2561805,
                "title": "simple-dijkstra-s-implementation-c-smooth-af",
                "content": "```\\n#define pb push_back\\n#define F first\\n#define S second\\n#define pii pair<int,int>\\n#define vi vector<int>\\n#define vii vector<pii>\\n#define vvi vector<vector<int>>\\n#define vvpii vector<vector<pair<int,int>>>\\n#define vc vector\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        int n = pass.size();\\n        vvpii g(n);\\n        for(auto it : edges)\\n        {\\n            g[it[0]].pb({it[1],it[2]});\\n            g[it[1]].pb({it[0],it[2]});\\n        }\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({pass[0], 0, 0});\\n        vector<int> time(n,maxTime + 1);\\n        time[0] = 0;\\n        \\n        \\n        while(!pq.empty())\\n        {\\n            int curr_cost = pq.top()[0];\\n            int curr_node = pq.top()[1];\\n            int curr_time = pq.top()[2];\\n            pq.pop();\\n            \\n            if(curr_node == n-1) return curr_cost;\\n            \\n            for(auto [v,t] : g[curr_node])\\n            {\\n                int newTime = curr_time + t, newCost = curr_cost + pass[v];\\n                if(newTime < time[v])\\n                {\\n                    time[v] = newTime;\\n                    pq.push({newCost, v, newTime});\\n                }\\n            }\\n        }\\n        \\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define pb push_back\\n#define F first\\n#define S second\\n#define pii pair<int,int>\\n#define vi vector<int>\\n#define vii vector<pii>\\n#define vvi vector<vector<int>>\\n#define vvpii vector<vector<pair<int,int>>>\\n#define vc vector\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        int n = pass.size();\\n        vvpii g(n);\\n        for(auto it : edges)\\n        {\\n            g[it[0]].pb({it[1],it[2]});\\n            g[it[1]].pb({it[0],it[2]});\\n        }\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({pass[0], 0, 0});\\n        vector<int> time(n,maxTime + 1);\\n        time[0] = 0;\\n        \\n        \\n        while(!pq.empty())\\n        {\\n            int curr_cost = pq.top()[0];\\n            int curr_node = pq.top()[1];\\n            int curr_time = pq.top()[2];\\n            pq.pop();\\n            \\n            if(curr_node == n-1) return curr_cost;\\n            \\n            for(auto [v,t] : g[curr_node])\\n            {\\n                int newTime = curr_time + t, newCost = curr_cost + pass[v];\\n                if(newTime < time[v])\\n                {\\n                    time[v] = newTime;\\n                    pq.push({newCost, v, newTime});\\n                }\\n            }\\n        }\\n        \\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349723,
                "title": "java-dfs-dp-memoisation-simple-solution",
                "content": "```\\nclass Solution {\\n    class Edge {\\n        int src, nbr, wt;\\n        public Edge(int src, int nbr, int wt) {\\n            this.src = src;\\n            this.nbr = nbr;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<Edge>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(new Edge(edge[0], edge[1], edge[2]));\\n            graph[edge[1]].add(new Edge(edge[1], edge[0], edge[2]));\\n        }\\n        return DFS(graph, 0, maxTime, passingFees, new Integer[1001][maxTime + 1]);\\n    }\\n    \\n    private int DFS(List<Edge>[] graph, int src, int remTime, int[] passingFees, Integer[][] dp){\\n        if(remTime < 0)\\n            return -1;\\n        if(dp[src][remTime] != null)\\n            return dp[src][remTime];\\n        if(src == passingFees.length - 1)\\n            return (dp[src][remTime] = passingFees[src]);\\n        int min = -1;\\n        for(Edge e : graph[src]){\\n            int x = DFS(graph, e.nbr, remTime - e.wt, passingFees, dp);\\n            if(min == -1)\\n                min = x;\\n            else if(x != -1)\\n                min = Math.min(min, x);\\n        }\\n        if(min == -1)\\n            return (dp[src][remTime] = -1);\\n        return (dp[src][remTime] = min + passingFees[src]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Edge {\\n        int src, nbr, wt;\\n        public Edge(int src, int nbr, int wt) {\\n            this.src = src;\\n            this.nbr = nbr;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<Edge>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(new Edge(edge[0], edge[1], edge[2]));\\n            graph[edge[1]].add(new Edge(edge[1], edge[0], edge[2]));\\n        }\\n        return DFS(graph, 0, maxTime, passingFees, new Integer[1001][maxTime + 1]);\\n    }\\n    \\n    private int DFS(List<Edge>[] graph, int src, int remTime, int[] passingFees, Integer[][] dp){\\n        if(remTime < 0)\\n            return -1;\\n        if(dp[src][remTime] != null)\\n            return dp[src][remTime];\\n        if(src == passingFees.length - 1)\\n            return (dp[src][remTime] = passingFees[src]);\\n        int min = -1;\\n        for(Edge e : graph[src]){\\n            int x = DFS(graph, e.nbr, remTime - e.wt, passingFees, dp);\\n            if(min == -1)\\n                min = x;\\n            else if(x != -1)\\n                min = Math.min(min, x);\\n        }\\n        if(min == -1)\\n            return (dp[src][remTime] = -1);\\n        return (dp[src][remTime] = min + passingFees[src]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329436,
                "title": "java-priorityqueue-100-faster",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minCost(int maxTime, int[][] edges, int[] Fees) {\\n\\n\\t\\t\\tint target=Fees.length-1;\\n\\t\\t\\tint[] visited=new int[Fees.length];\\n\\t\\t\\tArrays.fill(visited,-1);\\n\\t\\t\\tMap<Integer,List<int[]>> map=new HashMap<>();\\n\\n\\t\\t\\tfor(int[] x: edges){\\n\\t\\t\\t\\tint u=x[0];\\n\\t\\t\\t\\tint v=x[1];\\n\\t\\t\\t\\tint time=x[2];\\n\\n\\t\\t\\t\\tmap.putIfAbsent(u,new ArrayList<>());\\n\\t\\t\\t\\tmap.putIfAbsent(v,new ArrayList<>());\\n\\t\\t\\t\\tmap.get(u).add(new int[]{v,time});\\n\\t\\t\\t\\tmap.get(v).add(new int[]{u,time});\\n\\t\\t\\t}\\n\\n\\t\\t\\tPriorityQueue<int[]> queue=new PriorityQueue<>((a,b)->a[1]==b[1] ? a[2]-b[2] : a[1]-b[1]);\\n\\t\\t\\tqueue.add(new int[]{0,Fees[0],0});\\n\\t\\t\\tvisited[0]=0;\\n\\t\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\t\\tint[] curr=queue.poll();\\n\\t\\t\\t\\tint u=curr[0];\\n\\t\\t\\t\\tint cost=curr[1];\\n\\t\\t\\t\\tint time=curr[2];\\n\\t\\t\\t\\tif(u==target)\\n\\t\\t\\t\\t\\t return cost;\\n\\t\\t\\t\\tfor(int next[] : map.get(u)){\\n\\t\\t\\t\\t\\tint v=next[0];\\n\\t\\t\\t\\t\\tif(visited[v]!=-1 && time+next[1]>=visited[v])\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tvisited[v]=time+next[1];\\n\\t\\t\\t\\t\\tif(time+next[1]<=maxTime){\\n\\t\\t\\t\\t\\t\\tqueue.add(new int[]{v,cost+Fees[v],time+next[1]});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minCost(int maxTime, int[][] edges, int[] Fees) {\\n\\n\\t\\t\\tint target=Fees.length-1;\\n\\t\\t\\tint[] visited=new int[Fees.length];\\n\\t\\t\\tArrays.fill(visited,-1);\\n\\t\\t\\tMap<Integer,List<int[]>> map=new HashMap<>();\\n\\n\\t\\t\\tfor(int[] x: edges){\\n\\t\\t\\t\\tint u=x[0];\\n\\t\\t\\t\\tint v=x[1];\\n\\t\\t\\t\\tint time=x[2];\\n\\n\\t\\t\\t\\tmap.putIfAbsent(u,new ArrayList<>());\\n\\t\\t\\t\\tmap.putIfAbsent(v,new ArrayList<>());\\n\\t\\t\\t\\tmap.get(u).add(new int[]{v,time}",
                "codeTag": "Java"
            },
            {
                "id": 1619399,
                "title": "dijkstra-s-with-slight-modification",
                "content": "This concept can be generalised whenever minimization based on two things need to be done and when a parameter has to be just smaller than a threshold. \\n1) In such  a case , we will make a min heap kind of thing with key or thing to minimize being the minimum value which we must return.\\n2) The second parameter must be minimized for the cases if the first parameter minimization is  not done.\\n\\nThat is, priority wise minimization have to be considered.\\n\\nIn this question, we find that we have 2 reasons for putting an element in the multiset.\\n1) If cost is decreased, and time required <= threshold time.\\n2) Else if cost of the next won\\'t be reduced, then we have to see if the time for next node is minimized, so that there is a possibility that some unexplored nodes are found.\\n\\nSo, performing these 2 cases, we wiil receive the most optimal cost to reach (n-1)th node following the threshold constraint.\\n\\nC++ code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n        \\n        int n = fees.size();\\n        \\n        vector<pair<int,int>> vt[n];\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            vt[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            \\n            vt[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        multiset<pair<int,pair<int,int>>> ms;\\n        \\n        ms.insert({fees[0],{0,0}});\\n        \\n        vector<int> tim(n,INT_MAX);\\n        tim[0]= 0;\\n        \\n        vector<int> cost(n,INT_MAX);\\n       \\n        \\n        while(!ms.empty())\\n        {\\n            pair<int,pair<int,int>> hr= *ms.begin();\\n            \\n            int cst= hr.first;\\n            int cur= hr.second.first;\\n            int tm= hr.second.second;\\n            \\n            ms.erase(ms.begin());\\n            \\n            \\n            if(cur==n-1)\\n                return cost[cur];\\n            \\n            for(auto it:vt[cur])\\n            {\\n                if(tm+it.second<=maxTime)\\n                {\\n                     if(cst+fees[it.first] < cost[it.first])\\n                {\\n                    cost[it.first]= cst+fees[it.first];\\n                    tim[it.first]= tm+it.second;     \\n                    ms.insert({cost[it.first],{it.first,tm+ it.second}});\\n                }\\n                    \\n                else if( (tim[it.first] > tm + it.second)){\\n                \\n                    tim[it.first]= tm+it.second;\\n                    ms.insert({cst+fees[it.first],{it.first,tm + it.second}});    \\n                }\\n            }\\n            \\n        }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n        \\n        int n = fees.size();\\n        \\n        vector<pair<int,int>> vt[n];\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            vt[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            \\n            vt[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        multiset<pair<int,pair<int,int>>> ms;\\n        \\n        ms.insert({fees[0],{0,0}});\\n        \\n        vector<int> tim(n,INT_MAX);\\n        tim[0]= 0;\\n        \\n        vector<int> cost(n,INT_MAX);\\n       \\n        \\n        while(!ms.empty())\\n        {\\n            pair<int,pair<int,int>> hr= *ms.begin();\\n            \\n            int cst= hr.first;\\n            int cur= hr.second.first;\\n            int tm= hr.second.second;\\n            \\n            ms.erase(ms.begin());\\n            \\n            \\n            if(cur==n-1)\\n                return cost[cur];\\n            \\n            for(auto it:vt[cur])\\n            {\\n                if(tm+it.second<=maxTime)\\n                {\\n                     if(cst+fees[it.first] < cost[it.first])\\n                {\\n                    cost[it.first]= cst+fees[it.first];\\n                    tim[it.first]= tm+it.second;     \\n                    ms.insert({cost[it.first],{it.first,tm+ it.second}});\\n                }\\n                    \\n                else if( (tim[it.first] > tm + it.second)){\\n                \\n                    tim[it.first]= tm+it.second;\\n                    ms.insert({cst+fees[it.first],{it.first,tm + it.second}});    \\n                }\\n            }\\n            \\n        }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377171,
                "title": "c-simple-dfs-memo-knapsack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001],n;\\n    int dfs(int curr,int k,vector<vector<pair<int,int>>>& g, vector<int>& cost){\\n        if(curr==n-1) // if destination reached, return it\\'s cost\\n            return cost[n-1];\\n        if(dp[curr][k]!=-1)  // if already computed, return it\\n            return dp[curr][k];\\n        int mn=INT_MAX;\\n        for(int i=0;i<g[curr].size();i++){\\n            if(k<g[curr][i].second) // if time to visit the node, is less than remaining time, continue\\n                continue;\\n            int a=dfs(g[curr][i].first,k-g[curr][i].second,g,cost);\\n            if(a!=INT_MAX)\\n                mn=min(mn,cost[curr]+a);\\n        }\\n        return dp[curr][k]=mn;\\n    }\\n    int minCost(int k, vector<vector<int>>& edges, vector<int>& cost) {\\n        n=cost.size();\\n        int l=edges.size();\\n        vector<vector<pair<int,int>>>g(n);\\n        for(int i=0;i<l;i++){\\n            g[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            g[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        dfs(0,k,g,cost); \\n        return dp[0][k]==INT_MAX?-1:dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001],n;\\n    int dfs(int curr,int k,vector<vector<pair<int,int>>>& g, vector<int>& cost){\\n        if(curr==n-1) // if destination reached, return it\\'s cost\\n            return cost[n-1];\\n        if(dp[curr][k]!=-1)  // if already computed, return it\\n            return dp[curr][k];\\n        int mn=INT_MAX;\\n        for(int i=0;i<g[curr].size();i++){\\n            if(k<g[curr][i].second) // if time to visit the node, is less than remaining time, continue\\n                continue;\\n            int a=dfs(g[curr][i].first,k-g[curr][i].second,g,cost);\\n            if(a!=INT_MAX)\\n                mn=min(mn,cost[curr]+a);\\n        }\\n        return dp[curr][k]=mn;\\n    }\\n    int minCost(int k, vector<vector<int>>& edges, vector<int>& cost) {\\n        n=cost.size();\\n        int l=edges.size();\\n        vector<vector<pair<int,int>>>g(n);\\n        for(int i=0;i<l;i++){\\n            g[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            g[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        dfs(0,k,g,cost); \\n        return dp[0][k]==INT_MAX?-1:dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718328,
                "title": "simple-c-solution-dijkstra-s-algorithm-runtime-214ms",
                "content": "**if you like my approach please hit the upvote button : )**\\n<iframe src=\"https://leetcode.com/playground/8FjPYQu8/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "**if you like my approach please hit the upvote button : )**\\n<iframe src=\"https://leetcode.com/playground/8FjPYQu8/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1421809,
                "title": "python3-easy-bellman-ford-solution",
                "content": "dp solution.\\n\\n```python\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \\'\\'\\'\\n        Time: O((m+n)* maxtime), where m is length of edges\\n        Space: O(n*maxtime)\\n        \\'\\'\\'\\n        n = len(passingFees)\\n        dp = [[math.inf]*(n) for _ in range(maxTime+1)]\\n        dp[0][0] = passingFees[0]\\n\\n        ans = math.inf\\n        for k in range(1, maxTime+1):\\n            for x, y, time in edges:\\n                if k >= time:\\n                    # dual direction\\n                    dp[k][y] = min(dp[k][y], dp[k-time][x] + passingFees[y])\\n                    dp[k][x] = min(dp[k][x], dp[k-time][y] + passingFees[x])\\n                \\n            ans = min(ans, dp[k][n-1])\\n        \\n        if ans == math.inf:\\n            return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \\'\\'\\'\\n        Time: O((m+n)* maxtime), where m is length of edges\\n        Space: O(n*maxtime)\\n        \\'\\'\\'\\n        n = len(passingFees)\\n        dp = [[math.inf]*(n) for _ in range(maxTime+1)]\\n        dp[0][0] = passingFees[0]\\n\\n        ans = math.inf\\n        for k in range(1, maxTime+1):\\n            for x, y, time in edges:\\n                if k >= time:\\n                    # dual direction\\n                    dp[k][y] = min(dp[k][y], dp[k-time][x] + passingFees[y])\\n                    dp[k][x] = min(dp[k][x], dp[k-time][y] + passingFees[x])\\n                \\n            ans = min(ans, dp[k][n-1])\\n        \\n        if ans == math.inf:\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329413,
                "title": "java-dijkstra-clean-code-35ms-faster-than-100",
                "content": "I messed up basic Dijkstra and couldn\\'t solve this during the contest. The idea is same as Dijkstra, with the only difference here is that we need to maintain another array to track the amount of `time` taken to reach every vertex. Unlike basic Dijkstra, this helps us to also keep the intermediate solutions with larger cost but lesser time in the priority queue. At every node we encounter in our path, we check if we\\'ve reached the node before. If we\\'ve reached the node before with a higher fees or with a higher time, we update the fees/time accordingly and add the node to the priority-queue.\\n\\n```\\nclass Solution {\\n        \\n    public int minCost(int maxTime, int[][] edges, int[] fees) {\\n        List<List<int[]>> graph = new ArrayList();\\n        for (int i=0;i<fees.length;i++) {\\n            graph.add(new ArrayList());\\n        }\\n        for (int[] edge: edges) {\\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\\n        }\\n        int[] fees2Reach = new int[fees.length];\\n        int[] time2Reach = new int[fees.length];\\n        Arrays.fill(time2Reach, Integer.MAX_VALUE);\\n        Arrays.fill(fees2Reach, Integer.MAX_VALUE);\\n        time2Reach[0] = 0;\\n        fees2Reach[0] = fees[0];\\n        // sort by fees since we need minimum cost\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> {\\n            return a[1] - b[1];\\n        });\\n        pq.offer(new int[]{0, fees[0], 0}); // time, fees, city\\n        while (!pq.isEmpty()) {\\n            int[] arr = pq.poll();\\n            if (arr[2]==fees.length-1) return arr[1];   // reached last city\\n            for (int[] vertTime: graph.get(arr[2])) {\\n                int vertex = vertTime[0];\\n                int time = vertTime[1];\\n                if (arr[0] + time > maxTime) continue;\\n                if (arr[0] + time < time2Reach[vertex]) {\\n                    time2Reach[vertex] = arr[0] + time;\\n                    fees2Reach[vertex] = arr[1] + fees[vertex];\\n                    pq.offer(new int[]{arr[0] + time, arr[1] + fees[vertex], vertex});\\n                } else if (arr[1] + fees[vertex] < fees2Reach[vertex]) {\\n                    fees2Reach[vertex] = arr[1] + fees[vertex];\\n                    pq.offer(new int[]{arr[0] + time, arr[1] + fees[vertex], vertex});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    public int minCost(int maxTime, int[][] edges, int[] fees) {\\n        List<List<int[]>> graph = new ArrayList();\\n        for (int i=0;i<fees.length;i++) {\\n            graph.add(new ArrayList());\\n        }\\n        for (int[] edge: edges) {\\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\\n        }\\n        int[] fees2Reach = new int[fees.length];\\n        int[] time2Reach = new int[fees.length];\\n        Arrays.fill(time2Reach, Integer.MAX_VALUE);\\n        Arrays.fill(fees2Reach, Integer.MAX_VALUE);\\n        time2Reach[0] = 0;\\n        fees2Reach[0] = fees[0];\\n        // sort by fees since we need minimum cost\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> {\\n            return a[1] - b[1];\\n        });\\n        pq.offer(new int[]{0, fees[0], 0}); // time, fees, city\\n        while (!pq.isEmpty()) {\\n            int[] arr = pq.poll();\\n            if (arr[2]==fees.length-1) return arr[1];   // reached last city\\n            for (int[] vertTime: graph.get(arr[2])) {\\n                int vertex = vertTime[0];\\n                int time = vertTime[1];\\n                if (arr[0] + time > maxTime) continue;\\n                if (arr[0] + time < time2Reach[vertex]) {\\n                    time2Reach[vertex] = arr[0] + time;\\n                    fees2Reach[vertex] = arr[1] + fees[vertex];\\n                    pq.offer(new int[]{arr[0] + time, arr[1] + fees[vertex], vertex});\\n                } else if (arr[1] + fees[vertex] < fees2Reach[vertex]) {\\n                    fees2Reach[vertex] = arr[1] + fees[vertex];\\n                    pq.offer(new int[]{arr[0] + time, arr[1] + fees[vertex], vertex});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196602,
                "title": "c-2-solutions-dp-dijkstra-s-algorithm",
                "content": "Dynamic Programming\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int PASS_MAX = 10000000;\\n        vector<vector<int>> dp(maxTime + 1, vector<int>(passingFees.size(), PASS_MAX));\\n        \\n        dp[0][0] = passingFees[0];\\n        for (int i=1; i<=maxTime; ++i) {\\n            for (int j=0; j<edges.size(); ++j) {\\n                if (edges[j][2] > i) {\\n                    continue;\\n                }\\n                int city1 = edges[j][0];\\n                int city2 = edges[j][1];\\n                int time = edges[j][2];\\n                dp[i][city1] = min(dp[i][city1], dp[i - time][city2] + passingFees[city1]);\\n                dp[i][city2] = min(dp[i][city2], dp[i - time][city1] + passingFees[city2]);\\n            }\\n        }\\n        int ans = PASS_MAX;\\n        for (int i=0; i<=maxTime; ++i) {\\n            ans = min(ans, dp[i][passingFees.size()-1]);\\n        }\\n        if (ans == PASS_MAX) {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n// Time : O(TE) T = maxtime E = edge\\n// Space : O(TN)\\n```\\nDijkstra\\'s Algorithm\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> myHeap;\\n        \\n        vector<vector<pair<int, int>>> edge (n, vector<pair<int, int>>());\\n        for (int i=0; i<edges.size(); ++i) {\\n            edge[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            edge[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        vector<int> dist(n, INT_MAX);\\n        dist[0] = 0;\\n        myHeap.push({passingFees[0], {0, 0}});\\n        while (!myHeap.empty()) {\\n            int node = myHeap.top().second.first;\\n            int fee = myHeap.top().first;\\n            int time = myHeap.top().second.second;\\n            myHeap.pop();\\n            \\n            if (node == n - 1) {\\n                return fee;\\n            }\\n            for (int i=0; i<edge[node].size(); ++i) {\\n                int neighbor = edge[node][i].first;\\n                int travel_time = edge[node][i].second;\\n                if (time + travel_time > maxTime) {\\n                    continue;\\n                }\\n                if (dist[neighbor] > time + travel_time) {\\n                    dist[neighbor] = time + travel_time;\\n                    myHeap.push({fee + passingFees[neighbor], {neighbor, time + travel_time}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n// Time : O(Elogn)\\n// Space : O(n + E)\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int PASS_MAX = 10000000;\\n        vector<vector<int>> dp(maxTime + 1, vector<int>(passingFees.size(), PASS_MAX));\\n        \\n        dp[0][0] = passingFees[0];\\n        for (int i=1; i<=maxTime; ++i) {\\n            for (int j=0; j<edges.size(); ++j) {\\n                if (edges[j][2] > i) {\\n                    continue;\\n                }\\n                int city1 = edges[j][0];\\n                int city2 = edges[j][1];\\n                int time = edges[j][2];\\n                dp[i][city1] = min(dp[i][city1], dp[i - time][city2] + passingFees[city1]);\\n                dp[i][city2] = min(dp[i][city2], dp[i - time][city1] + passingFees[city2]);\\n            }\\n        }\\n        int ans = PASS_MAX;\\n        for (int i=0; i<=maxTime; ++i) {\\n            ans = min(ans, dp[i][passingFees.size()-1]);\\n        }\\n        if (ans == PASS_MAX) {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n// Time : O(TE) T = maxtime E = edge\\n// Space : O(TN)\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> myHeap;\\n        \\n        vector<vector<pair<int, int>>> edge (n, vector<pair<int, int>>());\\n        for (int i=0; i<edges.size(); ++i) {\\n            edge[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            edge[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        vector<int> dist(n, INT_MAX);\\n        dist[0] = 0;\\n        myHeap.push({passingFees[0], {0, 0}});\\n        while (!myHeap.empty()) {\\n            int node = myHeap.top().second.first;\\n            int fee = myHeap.top().first;\\n            int time = myHeap.top().second.second;\\n            myHeap.pop();\\n            \\n            if (node == n - 1) {\\n                return fee;\\n            }\\n            for (int i=0; i<edge[node].size(); ++i) {\\n                int neighbor = edge[node][i].first;\\n                int travel_time = edge[node][i].second;\\n                if (time + travel_time > maxTime) {\\n                    continue;\\n                }\\n                if (dist[neighbor] > time + travel_time) {\\n                    dist[neighbor] = time + travel_time;\\n                    myHeap.push({fee + passingFees[neighbor], {neighbor, time + travel_time}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n// Time : O(Elogn)\\n// Space : O(n + E)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794367,
                "title": "why-simple-dfs-isn-t-working",
                "content": "I have a simple DFS code. Why isn\\'t it working.\\n\\nIt is saying Wrong Answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX, n, t;\\n    void dfs(vector<vector<pair<int, int>>>& graph, vector<int>& vis, int curr, int time, int total, vector<int>& pass){\\n     //   cout<<curr<<\"->\"<<total<<\" \";\\n      //  total += pass[curr];\\n       // if(total > 862) return;\\n        if(time > t) return; \\n        if(curr == n-1){\\n            ans = min(ans, total);\\n            return;\\n        }\\n        \\n        vis[curr] = 1;\\n        for(pair<int, int> i: graph[curr]){\\n            if(vis[i.first] == 2 or vis[i.first] == 1) continue;\\n            dfs(graph, vis, i.first, time+i.second, total+pass[i.first], pass);\\n       //     cout<<ans<<\" \";\\n        }\\n        vis[curr] = 2;\\n         \\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        ans = INT_MAX;\\n        n = pass.size();\\n        vector<int> vis(n);\\n        //flag = false;\\n        t = maxTime;\\n        vector<vector<pair<int, int>>> graph(n, vector<pair<int, int>>());\\n        for(vector<int> i: edges){\\n            graph[i[0]].push_back({i[1], i[2]});\\n            graph[i[1]].push_back({i[0], i[2]});\\n        }\\n        \\n        dfs(graph, vis, 0, 0, pass[0], pass);\\n        \\n        return ans == INT_MAX? -1: ans;\\n    }\\n};\\n```\\nAny help will be appriciated :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX, n, t;\\n    void dfs(vector<vector<pair<int, int>>>& graph, vector<int>& vis, int curr, int time, int total, vector<int>& pass){\\n     //   cout<<curr<<\"->\"<<total<<\" \";\\n      //  total += pass[curr];\\n       // if(total > 862) return;\\n        if(time > t) return; \\n        if(curr == n-1){\\n            ans = min(ans, total);\\n            return;\\n        }\\n        \\n        vis[curr] = 1;\\n        for(pair<int, int> i: graph[curr]){\\n            if(vis[i.first] == 2 or vis[i.first] == 1) continue;\\n            dfs(graph, vis, i.first, time+i.second, total+pass[i.first], pass);\\n       //     cout<<ans<<\" \";\\n        }\\n        vis[curr] = 2;\\n         \\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        ans = INT_MAX;\\n        n = pass.size();\\n        vector<int> vis(n);\\n        //flag = false;\\n        t = maxTime;\\n        vector<vector<pair<int, int>>> graph(n, vector<pair<int, int>>());\\n        for(vector<int> i: edges){\\n            graph[i[0]].push_back({i[1], i[2]});\\n            graph[i[1]].push_back({i[0], i[2]});\\n        }\\n        \\n        dfs(graph, vis, 0, 0, pass[0], pass);\\n        \\n        return ans == INT_MAX? -1: ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1595611,
                "title": "python-dijkstra-s-algorithm-solution-with-explanation",
                "content": "We can simply apply Djikstra\\'s Algorithm based on the cost as the key to expand paths. However, we need to prune paths that exceed the max time. As well, we might want to revisit nodes that costed less time even though they had a higher cost. This lets us try all valid paths incase the min cost path goes past the max time limit.\\n\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        heap = [(passingFees[0],0,0)] # (cost, time, curr)\\n        nodeToTime = {}\\n        \\n        \\n        edgesDict = defaultdict(list)\\n        for a,b,time in edges:\\n            edgesDict[a].append((b,time))\\n            edgesDict[b].append((a, time))\\n                \\n        while heap:\\n            cost, time, curr = heappop(heap)\\n            \\n            if time > maxTime:\\n                continue\\n                \\n            if curr == n -  1:\\n                return cost\\n            \\n            # No point in visting this node again if it was visited before with a lower cost AND lower time.\\n            if curr not in nodeToTime or nodeToTime[curr] > time:\\n                \\n                nodeToTime[curr] = time\\n\\n                for nextNode, travelTime in edgesDict[curr]:\\n                    heappush(heap, (cost + passingFees[nextNode], time + travelTime, nextNode))\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        heap = [(passingFees[0],0,0)] # (cost, time, curr)\\n        nodeToTime = {}\\n        \\n        \\n        edgesDict = defaultdict(list)\\n        for a,b,time in edges:\\n            edgesDict[a].append((b,time))\\n            edgesDict[b].append((a, time))\\n                \\n        while heap:\\n            cost, time, curr = heappop(heap)\\n            \\n            if time > maxTime:\\n                continue\\n                \\n            if curr == n -  1:\\n                return cost\\n            \\n            # No point in visting this node again if it was visited before with a lower cost AND lower time.\\n            if curr not in nodeToTime or nodeToTime[curr] > time:\\n                \\n                nodeToTime[curr] = time\\n\\n                for nextNode, travelTime in edgesDict[curr]:\\n                    heappush(heap, (cost + passingFees[nextNode], time + travelTime, nextNode))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410980,
                "title": "c-solution-dp-with-dijkstra-easy-to-understand",
                "content": "Below solution combines DP with Dijkstra\\'s algorithm to achive the min cost possible. Do comment if anything is not clear.\\n\\n```\\ntypedef pair<int,pair<int,int>> pii;\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n\\n\\t//state of dp(i,j) : stores the min cost to reach city \\'i\\' in \\'j\\' max time;\\n    int dp[n][maxTime+1];\\n      \\n\\t\\t\\n\\t\\t//without using another array for time will result in TLE since it will explore more paths, hence \\n\\t\\t//using another array that stores the min time the city was discovered. This improves the TC to a \\n\\t\\t//huge extent as it prunes some path.\\n\\t\\t\\n        int ttime[n];\\n        for(int i=0;i<n;i++){\\n            ttime[i]=INT_MAX;\\n            for(int j=0;j<=maxTime;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        ttime[0]=0;\\n        dp[0][0]=passingFees[0];\\n        \\n        vector<vector<int>>adj[n];\\n        for(auto x:edges){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n\\t\\t// first priority is to minimise the cost associated with the path, {cost, city, time}\\n        priority_queue<pii,vector<pii>,greater<pii>>minHeap;\\n        minHeap.push({passingFees[0],{0,0}});\\n        \\n        while(!minHeap.empty()){\\n            auto top=minHeap.top();\\n            minHeap.pop();\\n           \\n\\t\\t   int u=top.second.first; \\n            int time=top.second.second;\\n            int cost=top.first;\\n\\n\\t\\t\\tif(u==n-1)return cost;\\n\\n\\t\\t\\tttime[u]=time;\\n            \\n            for(auto x:adj[u]){\\n\\t\\t\\t// this is the pruning part, where we are only exploring paths that can be reached earlier than \\n\\t\\t\\t//the time already required.\\n                if(time+x[1]<ttime[x[0]]){\\n                    if(time+x[1]<=maxTime){\\n\\t\\t\\t\\t\\t//now we are checking if the cost to reach the neighbor is less than the already minimum \\n\\t\\t\\t\\t\\t//cost, denoted by dp[x[0]][time+x[1]], denoting min cost to reach x[0] in \\'time+x[1]\\' max \\n\\t\\t\\t\\t\\t//time.\\n                        if(cost+passingFees[x[0]]<dp[x[0]][time+x[1]] ){\\n                            dp[x[0]][time+x[1]]=cost+passingFees[x[0]];\\n                            ttime[x[0]]=time+x[1];\\n                            minHeap.push({dp[x[0]][time+x[1]],{x[0],time+x[1]}});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n\\n\\t//state of dp(i,j) : stores the min cost to reach city \\'i\\' in \\'j\\' max time;\\n    int dp[n][maxTime+1];\\n      \\n\\t\\t\\n\\t\\t//without using another array for time will result in TLE since it will explore more paths, hence \\n\\t\\t//using another array that stores the min time the city was discovered. This improves the TC to a \\n\\t\\t//huge extent as it prunes some path.\\n\\t\\t\\n        int ttime[n];\\n        for(int i=0;i<n;i++){\\n            ttime[i]=INT_MAX;\\n            for(int j=0;j<=maxTime;j++){\\n                dp[i][j]=INT_MAX;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1391502,
                "title": "java-34-ms-clean-memoization-dijkstra-s-algo",
                "content": "```\\nDijkstra\\'s Algo : 34 ms\\n\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] costVtx) {\\n        int N = costVtx.length;\\n        ArrayList<int[]>[] graph = new ArrayList[N];\\n        for(int i = 0; i < N ; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] e : edges){\\n            int u = e[0], v = e[1], w = e[2];\\n            graph[u].add(new int[]{v, w});\\n            graph[v].add(new int[]{u, w});\\n        }\\n        int[] timeHold = new int[N];\\n        Arrays.fill(timeHold, (int) 1e9);\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            return a[1] - b[1];\\n        });\\n        // vtx | cost | time \\n        pq.add(new int[]{0, costVtx[0], 0});\\n        timeHold[0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] p = pq.remove();\\n            int vtx = p[0], cost = p[1], time = p[2]; \\n            if(vtx == costVtx.length - 1) return cost;\\n            for(int[] e : graph[vtx]){\\n                int v = e[0], n_time = e[1];\\n                if(time + n_time > maxTime) continue;\\n                if(time + n_time < timeHold[v]){\\n                    timeHold[v] = n_time + time;\\n                    pq.add(new int[]{v, cost + costVtx[v], timeHold[v]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nMemoization : 234 ms\\n\\nclass Solution {\\n    ArrayList<int[]>[] graph;\\n    int[][] dp;\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = 1000;\\n        dp = new int[1001][maxTime + 1];\\n        for(int[] d : dp) Arrays.fill(d, -1);\\n        graph = new ArrayList[n];\\n        for(int i = 0; i < n ; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges){\\n            int u = e[0], v = e[1], w = e[2];\\n            graph[u].add(new int[]{v,w});\\n            graph[v].add(new int[]{u,w});\\n        }\\n        int ans = costMaker(maxTime, passingFees, 0);\\n        return ans >= (int) 1e8 ? -1 : ans;\\n    }\\n    \\n    public int costMaker(int time, int[] fees, int src){\\n        if(time < 0) return (int) 1e8;\\n        if(src == fees.length - 1) return dp[src][time] =  fees[src];\\n        if(dp[src][time] != -1) return dp[src][time];\\n        int cost = (int) 1e8;\\n        for(int[] e : graph[src]){\\n            int v = e[0], w = e[1];\\n            cost = Math.min(cost, costMaker(time - w, fees, v));\\n        }\\n        return dp[src][time] = cost + fees[src];\\n    }\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nDijkstra\\'s Algo : 34 ms\\n\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] costVtx) {\\n        int N = costVtx.length;\\n        ArrayList<int[]>[] graph = new ArrayList[N];\\n        for(int i = 0; i < N ; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] e : edges){\\n            int u = e[0], v = e[1], w = e[2];\\n            graph[u].add(new int[]{v, w});\\n            graph[v].add(new int[]{u, w});\\n        }\\n        int[] timeHold = new int[N];\\n        Arrays.fill(timeHold, (int) 1e9);\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            return a[1] - b[1];\\n        });\\n        // vtx | cost | time \\n        pq.add(new int[]{0, costVtx[0], 0});\\n        timeHold[0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] p = pq.remove();\\n            int vtx = p[0], cost = p[1], time = p[2]; \\n            if(vtx == costVtx.length - 1) return cost;\\n            for(int[] e : graph[vtx]){\\n                int v = e[0], n_time = e[1];\\n                if(time + n_time > maxTime) continue;\\n                if(time + n_time < timeHold[v]){\\n                    timeHold[v] = n_time + time;\\n                    pq.add(new int[]{v, cost + costVtx[v], timeHold[v]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nMemoization : 234 ms\\n\\nclass Solution {\\n    ArrayList<int[]>[] graph;\\n    int[][] dp;\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = 1000;\\n        dp = new int[1001][maxTime + 1];\\n        for(int[] d : dp) Arrays.fill(d, -1);\\n        graph = new ArrayList[n];\\n        for(int i = 0; i < n ; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges){\\n            int u = e[0], v = e[1], w = e[2];\\n            graph[u].add(new int[]{v,w});\\n            graph[v].add(new int[]{u,w});\\n        }\\n        int ans = costMaker(maxTime, passingFees, 0);\\n        return ans >= (int) 1e8 ? -1 : ans;\\n    }\\n    \\n    public int costMaker(int time, int[] fees, int src){\\n        if(time < 0) return (int) 1e8;\\n        if(src == fees.length - 1) return dp[src][time] =  fees[src];\\n        if(dp[src][time] != -1) return dp[src][time];\\n        int cost = (int) 1e8;\\n        for(int[] e : graph[src]){\\n            int v = e[0], w = e[1];\\n            cost = Math.min(cost, costMaker(time - w, fees, v));\\n        }\\n        return dp[src][time] = cost + fees[src];\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376323,
                "title": "c-solution-modified-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>>mat(n);\\n        vector<int>cost(n,INT_MAX);\\n        vector<int>time(n,INT_MAX);\\n        for(auto x:edges)\\n        {\\n            mat[x[0]].push_back({x[1],x[2]});\\n            mat[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>>pq;\\n        cost[0]=passingFees[0];\\n        time[0]=0;\\n        pq.push({cost[0],time[0],0});\\n        \\n        while(!pq.empty())\\n        {\\n            auto t =pq.top();\\n            pq.pop();\\n            {\\n                for(auto x:mat[t[2]])\\n                {\\n                    int t_x =x.second;\\n                    int y=x.first;\\n                    if((cost[y]>t[0]+passingFees[y]) ||(time[y]>t[1]+t_x))\\n                    {\\n                        if(t[1]+t_x<=maxTime)\\n                        {\\n                            if(cost[y]>t[0]+passingFees[y])\\n                            {\\n                                cost[y]=t[0]+passingFees[y];\\n                                time[y]=t[1]+t_x;\\n                                pq.push({cost[y],time[y],y}); \\n                            }\\n                            else if(time[y]>t[1]+t_x)\\n                            {\\n                                time[y]=t[1]+t_x;\\n                                pq.push({t[0]+passingFees[y],time[y],y}); \\n                            }\\n                              \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(time[n-1]>maxTime||cost[n-1]==INT_MAX)\\n            return -1;\\n        else\\n            return cost[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>>mat(n);\\n        vector<int>cost(n,INT_MAX);\\n        vector<int>time(n,INT_MAX);\\n        for(auto x:edges)\\n        {\\n            mat[x[0]].push_back({x[1],x[2]});\\n            mat[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>>pq;\\n        cost[0]=passingFees[0];\\n        time[0]=0;\\n        pq.push({cost[0],time[0],0});\\n        \\n        while(!pq.empty())\\n        {\\n            auto t =pq.top();\\n            pq.pop();\\n            {\\n                for(auto x:mat[t[2]])\\n                {\\n                    int t_x =x.second;\\n                    int y=x.first;\\n                    if((cost[y]>t[0]+passingFees[y]) ||(time[y]>t[1]+t_x))\\n                    {\\n                        if(t[1]+t_x<=maxTime)\\n                        {\\n                            if(cost[y]>t[0]+passingFees[y])\\n                            {\\n                                cost[y]=t[0]+passingFees[y];\\n                                time[y]=t[1]+t_x;\\n                                pq.push({cost[y],time[y],y}); \\n                            }\\n                            else if(time[y]>t[1]+t_x)\\n                            {\\n                                time[y]=t[1]+t_x;\\n                                pq.push({t[0]+passingFees[y],time[y],y}); \\n                            }\\n                              \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(time[n-1]>maxTime||cost[n-1]==INT_MAX)\\n            return -1;\\n        else\\n            return cost[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374824,
                "title": "optimised-dijkstra-algo-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // dry run kia for whole day.... maja aa gya\\n    vector<vector<int>> graph[1001];\\n    int time[1001], cost[1001];\\n    int dijikstra(int src, int dest, int maxTime) {\\n        for (int i = 1; i <= dest; ++i) {\\n            time[i] = INT_MAX;\\n            cost[i] = INT_MAX;\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({cost[src], time[src], src});\\n        while (!pq.empty()) {\\n            vector<int> temp = pq.top(); pq.pop();\\n            int c = temp[0];\\n            int t = temp[1];\\n            int u = temp[2];\\n            \\n            for (int i = 0; i < graph[u].size(); ++i) {\\n                if (t + graph[u][i][1] <= maxTime) {\\n                    if (c + graph[u][i][2] < cost[graph[u][i][0]]) {\\n                        cost[graph[u][i][0]] = c + graph[u][i][2];\\n                        time[graph[u][i][0]] = t + graph[u][i][1];\\n                        pq.push({cost[graph[u][i][0]], time[graph[u][i][0]], graph[u][i][0]});\\n                    } else if (graph[u][i][1] + t < time[graph[u][i][0]]) {\\n                        time[graph[u][i][0]] = graph[u][i][1] + t;\\n                        pq.push({c + graph[u][i][2], time[graph[u][i][0]], graph[u][i][0]});\\n                    }\\n                }\\n            }\\n        }\\n        return cost[dest];\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& arr, vector<int>& fee) {\\n        int n = arr.size();\\n        // graph.assign(n, vector<int>());\\n        // time.assign(n, INT_MAX);\\n        // cost.assign(n, INT_MAX);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int u = arr[i][0];\\n            int v = arr[i][1];\\n            int t = arr[i][2];\\n            \\n            graph[u].push_back({v, t, fee[v]});\\n            graph[v].push_back({u, t, fee[u]});\\n        }\\n        \\n        cost[0] = fee[0];\\n        time[0] = 0;\\n        \\n        int ans = dijikstra(0, fee.size() - 1, maxTime);\\n        if (ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // dry run kia for whole day.... maja aa gya\\n    vector<vector<int>> graph[1001];\\n    int time[1001], cost[1001];\\n    int dijikstra(int src, int dest, int maxTime) {\\n        for (int i = 1; i <= dest; ++i) {\\n            time[i] = INT_MAX;\\n            cost[i] = INT_MAX;\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        pq.push({cost[src], time[src], src});\\n        while (!pq.empty()) {\\n            vector<int> temp = pq.top(); pq.pop();\\n            int c = temp[0];\\n            int t = temp[1];\\n            int u = temp[2];\\n            \\n            for (int i = 0; i < graph[u].size(); ++i) {\\n                if (t + graph[u][i][1] <= maxTime) {\\n                    if (c + graph[u][i][2] < cost[graph[u][i][0]]) {\\n                        cost[graph[u][i][0]] = c + graph[u][i][2];\\n                        time[graph[u][i][0]] = t + graph[u][i][1];\\n                        pq.push({cost[graph[u][i][0]], time[graph[u][i][0]], graph[u][i][0]});\\n                    } else if (graph[u][i][1] + t < time[graph[u][i][0]]) {\\n                        time[graph[u][i][0]] = graph[u][i][1] + t;\\n                        pq.push({c + graph[u][i][2], time[graph[u][i][0]], graph[u][i][0]});\\n                    }\\n                }\\n            }\\n        }\\n        return cost[dest];\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& arr, vector<int>& fee) {\\n        int n = arr.size();\\n        // graph.assign(n, vector<int>());\\n        // time.assign(n, INT_MAX);\\n        // cost.assign(n, INT_MAX);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int u = arr[i][0];\\n            int v = arr[i][1];\\n            int t = arr[i][2];\\n            \\n            graph[u].push_back({v, t, fee[v]});\\n            graph[v].push_back({u, t, fee[u]});\\n        }\\n        \\n        cost[0] = fee[0];\\n        time[0] = 0;\\n        \\n        int ans = dijikstra(0, fee.size() - 1, maxTime);\\n        if (ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338301,
                "title": "java-solution-dijkstra-best-first-search",
                "content": "The base idea is to extend Dijkstra algorithm, or better to be called \"Best first search\" for easy understanding. Despite being wikipedia, I really recommend a deep read of it https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm. We maintain a Priority Queue, and the Queue tracks best candidates that could lead to desired outcome: minimum cost to the destination.\\n\\nBut, how do you model the constraint of time? You can just play blind for now, ignore it being a constraint, check every item in the queue as you would in regular single source best path problem, AND, whenever you find a solution, that is we reached the destination using best candidates from Priority Queue, you check the arrival time! If it exceeds the limit, we just dig into our queue again, until we found one, return the cost, or we give up, return -1.\\n\\nNow, several traps / important insights of this problem:\\n\\n- You must also insert a <location, time, cost> tuple into the queue even when the cost is sub-optimal. Why? Bcoz the optimal guy *could* result in time out! Therefore, you must also *compromise* by adding sub optimal tuples. But again, if we behave desperate by adding anything, you will get TLE... So, we only add tuples when there are *potential for improvements*, that is\\n\\t- reduce in cost OR\\n\\t- reduce in time cost.\\n- Another early stopping opportunity: before you insert tuples into the queue, if its present time cost already > maxTime, we avoid insertion.\\n\\nNow we have walked through the general ideas + the problem specific tricks, here is the java code. Note that the comparator is kind of niche, you can just compare only on cost, and still acquire the similar performance, hinting the case of same cost different time has low impact on the overall computation.\\n\\n```\\nclass Record {\\n    int loc;\\n    int cost;\\n    int time;\\n    \\n    public Record(int loc, int cost, int time) {\\n        this.loc = loc;\\n        this.cost = cost;\\n        this.time = time;\\n    }\\n    \\n    public int compareTo(Record other) {\\n        // First compare cost, if same, track time.\\n        if (this.cost > other.cost) {\\n            return 1;\\n        } else if (this.cost < other.cost) {\\n            return -1;\\n        } else if (this.time > other.time) {\\n            return 1;\\n        } else if (this.time < other.time) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\\nclass RecordCompare implements Comparator<Record> {\\n    @Override\\n    public int compare (Record a, Record b) {\\n        return a.compareTo(b);\\n    }\\n}\\n\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        // Build adj matrix of time cost.\\n        int[][] time_adj = new int[passingFees.length][passingFees.length];\\n        for (int i = 0; i < time_adj.length; i++) {\\n            for (int j = 0; j < time_adj[0].length; j++) {\\n                time_adj[i][j] = -1;\\n            }\\n        }\\n        \\n        for (int[] rd : edges) {\\n            if (time_adj[rd[0]][rd[1]] == -1 ||\\n                time_adj[rd[0]][rd[1]] > rd[2]) {\\n                time_adj[rd[0]][rd[1]] = rd[2];\\n                time_adj[rd[1]][rd[0]] = rd[2];\\n            }\\n        }\\n        \\n        // Best first search as if Dijkstra algorithm.\\n        // PQ which tracks the cost. \\n        // PriorityQueue<Record> bestQueue = new PriorityQueue<Record>(10, \\n        //                                       ((o1, o2) -> o1.cost - o2.cost));\\n        PriorityQueue<Record> bestQueue = new PriorityQueue<Record>(10, new RecordCompare());\\n        \\n        bestQueue.offer(new Record(0, passingFees[0], 0));\\n        // Helper arrays for early stopping. We don\\'t need to explore worse \\n        // candidates vs. those in the bestQueue.\\n        int[] bestTime = new int[passingFees.length];\\n        int[] bestCost = new int[passingFees.length];\\n        bestTime[0] = 0;\\n        bestCost[0] = passingFees[0];\\n        for (int i = 1; i < passingFees.length; i++) {\\n            bestTime[i] = maxTime + 1;\\n            bestCost[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        while (bestQueue.size() >0) {\\n            Record curNode = bestQueue.poll();\\n            \\n            // Check result.\\n            if (curNode.loc == passingFees.length - 1 &&\\n                curNode.time <= maxTime) {\\n                return curNode.cost;\\n            }\\n            \\n            for (int i = 0; i < passingFees.length; i++) {\\n                if (i == curNode.loc) {\\n                    continue;\\n                }\\n                \\n                if (time_adj[curNode.loc][i] != -1 &&\\n                    (bestTime[i] > (curNode.time + time_adj[curNode.loc][i]) ||\\n                     bestCost[i] > (curNode.cost + passingFees[i]))\\n                   ) {\\n                    \\n                    // No hope, early stop.\\n                    if (curNode.time + time_adj[curNode.loc][i] > maxTime) {\\n                        continue;\\n                    }\\n                    \\n                    bestTime[i] = (curNode.time + time_adj[curNode.loc][i]);\\n                    bestCost[i] = (curNode.cost + passingFees[i]);\\n                    \\n                    bestQueue.offer(new Record(i, bestCost[i], bestTime[i]));\\n                }\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Record {\\n    int loc;\\n    int cost;\\n    int time;\\n    \\n    public Record(int loc, int cost, int time) {\\n        this.loc = loc;\\n        this.cost = cost;\\n        this.time = time;\\n    }\\n    \\n    public int compareTo(Record other) {\\n        // First compare cost, if same, track time.\\n        if (this.cost > other.cost) {\\n            return 1;\\n        } else if (this.cost < other.cost) {\\n            return -1;\\n        } else if (this.time > other.time) {\\n            return 1;\\n        } else if (this.time < other.time) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\\nclass RecordCompare implements Comparator<Record> {\\n    @Override\\n    public int compare (Record a, Record b) {\\n        return a.compareTo(b);\\n    }\\n}\\n\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        // Build adj matrix of time cost.\\n        int[][] time_adj = new int[passingFees.length][passingFees.length];\\n        for (int i = 0; i < time_adj.length; i++) {\\n            for (int j = 0; j < time_adj[0].length; j++) {\\n                time_adj[i][j] = -1;\\n            }\\n        }\\n        \\n        for (int[] rd : edges) {\\n            if (time_adj[rd[0]][rd[1]] == -1 ||\\n                time_adj[rd[0]][rd[1]] > rd[2]) {\\n                time_adj[rd[0]][rd[1]] = rd[2];\\n                time_adj[rd[1]][rd[0]] = rd[2];\\n            }\\n        }\\n        \\n        // Best first search as if Dijkstra algorithm.\\n        // PQ which tracks the cost. \\n        // PriorityQueue<Record> bestQueue = new PriorityQueue<Record>(10, \\n        //                                       ((o1, o2) -> o1.cost - o2.cost));\\n        PriorityQueue<Record> bestQueue = new PriorityQueue<Record>(10, new RecordCompare());\\n        \\n        bestQueue.offer(new Record(0, passingFees[0], 0));\\n        // Helper arrays for early stopping. We don\\'t need to explore worse \\n        // candidates vs. those in the bestQueue.\\n        int[] bestTime = new int[passingFees.length];\\n        int[] bestCost = new int[passingFees.length];\\n        bestTime[0] = 0;\\n        bestCost[0] = passingFees[0];\\n        for (int i = 1; i < passingFees.length; i++) {\\n            bestTime[i] = maxTime + 1;\\n            bestCost[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        while (bestQueue.size() >0) {\\n            Record curNode = bestQueue.poll();\\n            \\n            // Check result.\\n            if (curNode.loc == passingFees.length - 1 &&\\n                curNode.time <= maxTime) {\\n                return curNode.cost;\\n            }\\n            \\n            for (int i = 0; i < passingFees.length; i++) {\\n                if (i == curNode.loc) {\\n                    continue;\\n                }\\n                \\n                if (time_adj[curNode.loc][i] != -1 &&\\n                    (bestTime[i] > (curNode.time + time_adj[curNode.loc][i]) ||\\n                     bestCost[i] > (curNode.cost + passingFees[i]))\\n                   ) {\\n                    \\n                    // No hope, early stop.\\n                    if (curNode.time + time_adj[curNode.loc][i] > maxTime) {\\n                        continue;\\n                    }\\n                    \\n                    bestTime[i] = (curNode.time + time_adj[curNode.loc][i]);\\n                    bestCost[i] = (curNode.cost + passingFees[i]);\\n                    \\n                    bestQueue.offer(new Record(i, bestCost[i], bestTime[i]));\\n                }\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329119,
                "title": "easiest-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int t[1001][1001];\\n    \\n    int Solve(vector<pair<int,int> > A[] , vector<int>&money , int node , int time , int Target , int maxTime)\\n    {\\n\\n        if(time>maxTime)\\n            return 100000000;\\n        \\n        if(node==Target)\\n        {\\n            return money[Target] ;\\n        }\\n    \\n        if(t[node][time]!=-1) return t[node][time] ; \\n        \\n        int Ans = 100000000 ;\\n        for(auto child:A[node])\\n        {\\n            \\n            if( time+child.second<=maxTime)\\n                {   \\n                    int temp = money[node]+Solve(A,money,child.first,time+child.second,Target,maxTime) ;\\n                    \\n                    Ans = min(Ans,temp) ;\\n                }\\n        }\\n        \\n        \\n        \\n        return t[node][time] =Ans; \\n    }\\n    \\n    \\n    \\n    \\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& A) {\\n        int N = edges.size() ;\\n        vector<pair<int,int>> V[N+1] ;\\n        int n = -1;\\n        for(auto x:edges){\\n            V[x[0]].push_back({x[1],x[2]}) ;\\n            V[x[1]].push_back({x[0],x[2]}) ;\\n            n = max({n,x[0],x[1]});\\n        }\\n        \\n        memset(t,-1,sizeof(t)) ;\\n        \\n        int Ans = Solve(V,A,0,0,n,maxTime) ;\\n        \\n        return (Ans<100000000)?Ans:-1 ;\\n}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int t[1001][1001];\\n    \\n    int Solve(vector<pair<int,int> > A[] , vector<int>&money , int node , int time , int Target , int maxTime)\\n    {\\n\\n        if(time>maxTime)\\n            return 100000000;\\n        \\n        if(node==Target)\\n        {\\n            return money[Target] ;\\n        }\\n    \\n        if(t[node][time]!=-1) return t[node][time] ; \\n        \\n        int Ans = 100000000 ;\\n        for(auto child:A[node])\\n        {\\n            \\n            if( time+child.second<=maxTime)\\n                {   \\n                    int temp = money[node]+Solve(A,money,child.first,time+child.second,Target,maxTime) ;\\n                    \\n                    Ans = min(Ans,temp) ;\\n                }\\n        }\\n        \\n        \\n        \\n        return t[node][time] =Ans; \\n    }\\n    \\n    \\n    \\n    \\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& A) {\\n        int N = edges.size() ;\\n        vector<pair<int,int>> V[N+1] ;\\n        int n = -1;\\n        for(auto x:edges){\\n            V[x[0]].push_back({x[1],x[2]}) ;\\n            V[x[1]].push_back({x[0],x[2]}) ;\\n            n = max({n,x[0],x[1]});\\n        }\\n        \\n        memset(t,-1,sizeof(t)) ;\\n        \\n        int Ans = Solve(V,A,0,0,n,maxTime) ;\\n        \\n        return (Ans<100000000)?Ans:-1 ;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795181,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int time,vector<pair<int,int>> adj[],int v,vector<int> &pass){\\n        if(time<0) return INT_MAX;\\n        int n = pass.size();\\n        if(v==n-1){\\n            return pass[v];\\n        }\\n        if(dp[v][time]!=-1) return dp[v][time];\\n        int cost = INT_MAX;\\n        for(auto &x:adj[v]){\\n            int u = x.first;\\n            int temp = x.second;\\n            if(temp<=time){\\n               int sol = solve(time-temp,adj,u,pass);\\n            cost = min(cost,sol);\\n            }\\n        }\\n        if(cost==INT_MAX) return dp[v][time] = INT_MAX;\\n        return dp[v][time] = cost + pass[v]; \\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = pass.size();\\n        vector<pair<int,int>> adj[n];\\n        for(int i = 0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));\\n             adj[edges[i][1]].push_back(make_pair(edges[i][0],edges[i][2]));\\n            \\n        }\\n        int ans = solve(maxTime,adj,0,pass);\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int time,vector<pair<int,int>> adj[],int v,vector<int> &pass){\\n        if(time<0) return INT_MAX;\\n        int n = pass.size();\\n        if(v==n-1){\\n            return pass[v];\\n        }\\n        if(dp[v][time]!=-1) return dp[v][time];\\n        int cost = INT_MAX;\\n        for(auto &x:adj[v]){\\n            int u = x.first;\\n            int temp = x.second;\\n            if(temp<=time){\\n               int sol = solve(time-temp,adj,u,pass);\\n            cost = min(cost,sol);\\n            }\\n        }\\n        if(cost==INT_MAX) return dp[v][time] = INT_MAX;\\n        return dp[v][time] = cost + pass[v]; \\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& pass) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = pass.size();\\n        vector<pair<int,int>> adj[n];\\n        for(int i = 0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));\\n             adj[edges[i][1]].push_back(make_pair(edges[i][0],edges[i][2]));\\n            \\n        }\\n        int ans = solve(maxTime,adj,0,pass);\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408038,
                "title": "c-modified-dijkstra-worst-case-o-elogv-time-o-e-v-space",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int\\n    minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        // Problem is modeled as an undirected graph wherein :-\\n        // Cities are the graph vertices\\n        // Bidirectional roads between cities are graph edges between vertices\\n        // representing cities. Travel time between cities is the edge cost.\\n        // The minimum journey between first city (0) and last city (n - 1)\\n        // would be the shortest path between the two vertices based on the \\n        // two parameters; total edge travel time not exceeding the maxTime\\n        // and total passing time of all path vertices on the path being the\\n        // minimum => modified Dijkstra with two constraints\\n        return minCostViaModifiedDijkstra(maxTime, edges, passingFees);\\n    }\\n    \\n\\tprivate:\\n    \\n    // Models the edge between 2 graph vertices (i.e. road between cities)\\n    typedef struct _EdgeInfo {\\n        // Neighbour vertex\\n        int nv;\\n        // Edge cost\\n        int cost;\\n    } EdgeInfoT;\\n    \\n    int\\n    minCostViaModifiedDijkstra(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        // Construct graph\\n        buildGraph(edges);\\n        \\n        // Modified Dijkstra operating on two constraints to find the shortest path\\n        // betwen 0 and \\'n - 1\\' vertices\\n        // 1. Commence from vertex 0 with path cost being passing fee of vertex\\n        //    0 at time \\'0\\'. Add vertex 0 to priority queue (PQ)\\n        // 2. Select a vertex from the PQ to processed. Vertex which can reached\\n        //    with least edge travel time is prioritised over others stored as\\n        //    this reduces the chance of travel time hitting maxTime leading to\\n        //    journey termination. Tie breaker amongst vertices with same travel\\n        //    time is by preferring the vertex with shortest path cost (sum of all\\n        //    vertex passing times on the path)\\n        // 3. Skip processing the selected vertex \\'v\\'; if the vertex was already\\n        //    reached earlier via a journey path earlier with lesser total travel\\n        //    time and lesser path cost\\n        // 4. Update the total travel time and path cost for the selected vertex\\n        //    with the new values\\n        // 5. Explore all neighbour vertices of the selected vertex \\'v\\'\\n        // 6. Neigbour vertices of \\'v\\' which can be reached within the max allowable\\n        //    travel time are added to the PQ for processing in the subsequent\\n        //    iterations\\n        // 7. Go to step 2 as long as there is vertex in the PQ for processing\\n        \\n        // Vertex reachability information\\n        typedef struct _VertexInfo {\\n            // Vertex\\n            int v;\\n            // Total travel time to reach vertex \\'v\\' (sum of edge times)\\n            // from start vertex \\'0\\'\\n            long time;\\n            // Total path cost to reach vertex \\'v\\' (sum of passing times\\n            // of all vertices on the path) from start vertex \\'0\\'\\n            long pathCost;\\n        } VertexInfoT;\\n        \\n        typedef struct _VertexInfoCmpObj {\\n            bool\\n            operator()(const VertexInfoT& vi1, const VertexInfoT& vi2) {\\n                // Prefer vertex with lower journey cost if the travel times\\n                // are same; else prefer vertex with lesser travel time\\n                if (vi1.time == vi2.time) {\\n                    return vi1.pathCost > vi2.pathCost;\\n                }\\n                return vi1.time > vi2.time;\\n            }\\n        } VertexInfoCmpObj;\\n        // Priority Queue of vertex reachability information\\n        priority_queue<VertexInfoT, vector<VertexInfoT>, VertexInfoCmpObj> pq;\\n        \\n        int nVertices = passingFees.size();\\n        // Tracks the minimum journey/path cost to each vertex from vertex 0\\n        vector<long> minCostV(nVertices, numeric_limits<int>::max());\\n        // Tracks the minimum travel time cost to each vertex from vertex 0\\n        vector<long> minTimeV(nVertices, numeric_limits<int>::max());\\n        \\n        // Step 1. Start from vertex 0. Add to PQ\\n        minCostV[0] = 0;\\n        VertexInfoT vi;\\n        vi.v = 0;\\n        vi.time = 0;\\n        vi.pathCost = passingFees[0];\\n        pq.push(vi);\\n        \\n        while (!pq.empty()) {\\n            // Step 2. Select and dequeue the vertex at front of PQ\\n            auto reachableVertexInfo = pq.top();\\n            pq.pop();\\n            // Selected vertex params\\n            auto v = reachableVertexInfo.v;\\n            auto time = reachableVertexInfo.time;\\n            auto pCost = reachableVertexInfo.pathCost;\\n            \\n            // Step 3. Selected vertex was reachable from vertex \\'0\\' via a \\n            // path with lesser/same travel time and path cost. So no sense\\n            // in processing the vertex this time\\n            if ((time >= minTimeV[v]) &&\\n                (pCost >= minCostV[v]))  {\\n                continue;\\n            }\\n            \\n            // Step 4. Update total travel time and path cost to reach\\n            // selected vertex as per new reacahbility info\\n            minCostV[v] = min(minCostV[v], pCost);\\n            minTimeV[v] = min(minTimeV[v], time);\\n            \\n            // Step 5. Iterate over each neighbor of selected vertex\\n            auto & nbrInfoV = _adjList[v];\\n            for (auto & nbrInfo : nbrInfoV) {\\n                auto edgeCost = nbrInfo.cost;\\n                auto nv = nbrInfo.nv;\\n                if (edgeCost + time <= maxTime) {\\n                    // Neighbour reachable from vertex from vertex \\'0\\' within\\n                    // the max allowable travel time. Enqueue vertex to PQ\\n                    // for further processing\\n                    VertexInfoT nvInfo;\\n                    nvInfo.v = nv;\\n                    // Update the travel time and path cost  to neighbpur \\'nv\\'\\n                    // via last hop as current select vertex\\n                    nvInfo.time = edgeCost + time;\\n                    nvInfo.pathCost = pCost + passingFees[nv];\\n                    pq.push(nvInfo);\\n                }\\n            }\\n        }\\n        \\n        \\n        int minCostToDest = minCostV[nVertices - 1];\\n        return (minCostToDest == numeric_limits<int>::max()) ? -1 : minCostToDest;\\n    }\\n    \\n    void\\n    buildGraph(vector<vector<int>>& edges) {\\n        // Iterate over each edge of the graph\\n        for (auto & edge : edges) {\\n            // Edge vertices and cost\\n            auto u = edge[0];\\n            auto v = edge[1];\\n            auto cost = edge[2];\\n            // Bidirectional edge - add both (u, v) and (v, u) to\\n            // graph adjacency list\\n            EdgeInfoT e;\\n            e.cost = cost;\\n            e.nv = v;\\n            _adjList[u].emplace_back(e);\\n            e.nv = u;\\n            _adjList[v].emplace_back(e);\\n        }\\n    }\\n    \\n    // Data members\\n    \\n    // Graph Adjacency list representation. Maps each vertex to list of\\n    // edges incident on the vertex. Edge information consists of neighbour\\n    // vertex and edge cost tuples\\n    unordered_map<int, vector<EdgeInfoT> > _adjList;\\n\\t};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int\\n    minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        // Problem is modeled as an undirected graph wherein :-\\n        // Cities are the graph vertices\\n        // Bidirectional roads between cities are graph edges between vertices\\n        // representing cities. Travel time between cities is the edge cost.\\n        // The minimum journey between first city (0) and last city (n - 1)\\n        // would be the shortest path between the two vertices based on the \\n        // two parameters; total edge travel time not exceeding the maxTime\\n        // and total passing time of all path vertices on the path being the\\n        // minimum => modified Dijkstra with two constraints\\n        return minCostViaModifiedDijkstra(maxTime, edges, passingFees);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2301441,
                "title": "3-state-djikstra-c-71",
                "content": "```\\n//less cost are covered first hence only time contraint.\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(auto it: edges){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        set<vector<int>> s;\\n        vector<int> vis(n,1005);\\n        s.insert({passingFees[0],0,0});\\n        vis[0]=0;\\n        while(!s.empty()){\\n            vector<int> x=*s.begin();\\n            s.erase(s.begin());\\n            if(x[1]==n-1)\\n                return x[0];\\n            for(auto it: adj[x[1]]){\\n                if(x[2]+it.second<vis[it.first] && x[2]+it.second<=maxTime){\\n                    vis[it.first]=x[2]+it.second;\\n                    s.insert({x[0]+passingFees[it.first],it.first,x[2]+it.second});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//less cost are covered first hence only time contraint.\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(auto it: edges){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        set<vector<int>> s;\\n        vector<int> vis(n,1005);\\n        s.insert({passingFees[0],0,0});\\n        vis[0]=0;\\n        while(!s.empty()){\\n            vector<int> x=*s.begin();\\n            s.erase(s.begin());\\n            if(x[1]==n-1)\\n                return x[0];\\n            for(auto it: adj[x[1]]){\\n                if(x[2]+it.second<vis[it.first] && x[2]+it.second<=maxTime){\\n                    vis[it.first]=x[2]+it.second;\\n                    s.insert({x[0]+passingFees[it.first],it.first,x[2]+it.second});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143196,
                "title": "c-easy-simple-topdown-dp-memomization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<pair<int,int>>>& a, vector<int>& p,vector<vector<int>>& dp,int n,int t,int q){\\n        if(t<0)\\n            return INT_MAX;\\n        if(q==n-1)\\n            return p[q];\\n        if(dp[q][t]!=-1)\\n            return dp[q][t];\\n        \\n        int ans=INT_MAX;\\n        for(auto& x:a[q]){\\n            int res=solve(a,p,dp,n,t-x.second,x.first);\\n            ans=min(ans,(res==INT_MAX?res:res+p[q]));\\n        }\\n        return dp[q][t]=ans;\\n    }\\n    \\n    int minCost(int t, vector<vector<int>>& g, vector<int>& p) {\\n        int n=p.size();\\n        vector<vector<int>> dp(n,vector<int>(t+1,-1));\\n        vector<vector<pair<int,int>>> a(n);\\n        for(auto& x:g){\\n            a[x[0]].push_back({x[1],x[2]});\\n            a[x[1]].push_back({x[0],x[2]});\\n        }\\n        int ans=solve(a,p,dp,n,t,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<pair<int,int>>>& a, vector<int>& p,vector<vector<int>>& dp,int n,int t,int q){\\n        if(t<0)\\n            return INT_MAX;\\n        if(q==n-1)\\n            return p[q];\\n        if(dp[q][t]!=-1)\\n            return dp[q][t];\\n        \\n        int ans=INT_MAX;\\n        for(auto& x:a[q]){\\n            int res=solve(a,p,dp,n,t-x.second,x.first);\\n            ans=min(ans,(res==INT_MAX?res:res+p[q]));\\n        }\\n        return dp[q][t]=ans;\\n    }\\n    \\n    int minCost(int t, vector<vector<int>>& g, vector<int>& p) {\\n        int n=p.size();\\n        vector<vector<int>> dp(n,vector<int>(t+1,-1));\\n        vector<vector<pair<int,int>>> a(n);\\n        for(auto& x:g){\\n            a[x[0]].push_back({x[1],x[2]});\\n            a[x[1]].push_back({x[0],x[2]});\\n        }\\n        int ans=solve(a,p,dp,n,t,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142631,
                "title": "javascript-solution-using-djikstra-s",
                "content": "There\\'s two key points to solving this problem. \\n\\nFirstly you need a way to ensure you only add to the queue when it will either be a benefit to cost or time. And the 2nd thing to note is that there could be more than one edge with a different time factor so you should only try to  store the best time for each edge.\\n\\nWith that in mind the solution below is an application of Djikstra\\'s algorithm to solve for best cost vs a limit on max time.\\n\\n```\\nvar minCost = function (maxTime, edges, passingFees) {\\n    const n = passingFees.length;\\n    const graph = new Array(n);\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const [from, to, time] = edges[i];\\n\\n        graph[from] = graph[from] || [];\\n        graph[from][to] = Math.min(graph[from][to] ?? Infinity, time);\\n\\n        graph[to] = graph[to] || [];\\n        graph[to][from] = Math.min(graph[to][from] ?? Infinity, time);\\n    }\\n\\n    const q = new MinPriorityQueue();\\n    q.enqueue([0, 0], passingFees[0]);\\n\\n    const bestTimes = new Array(n).fill(Infinity);\\n\\n    while (q.size()) {\\n        const { element, priority } = q.dequeue();\\n        const [currNode, currTime] = element;\\n        \\n        if (currNode === n - 1) {\\n            return priority;\\n        }\\n\\n        for (const node in graph[currNode]) {\\n            const nextNode = parseInt(node);\\n            const nextTime = graph[currNode][node] + currTime;\\n\\n            if (nextTime <= maxTime && nextTime < bestTimes[nextNode]) {\\n                bestTimes[nextNode] = nextTime;\\n                q.enqueue([nextNode, nextTime], passingFees[nextNode] + priority);\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```\\n\\nEdited thanks to @da5idf",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minCost = function (maxTime, edges, passingFees) {\\n    const n = passingFees.length;\\n    const graph = new Array(n);\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const [from, to, time] = edges[i];\\n\\n        graph[from] = graph[from] || [];\\n        graph[from][to] = Math.min(graph[from][to] ?? Infinity, time);\\n\\n        graph[to] = graph[to] || [];\\n        graph[to][from] = Math.min(graph[to][from] ?? Infinity, time);\\n    }\\n\\n    const q = new MinPriorityQueue();\\n    q.enqueue([0, 0], passingFees[0]);\\n\\n    const bestTimes = new Array(n).fill(Infinity);\\n\\n    while (q.size()) {\\n        const { element, priority } = q.dequeue();\\n        const [currNode, currTime] = element;\\n        \\n        if (currNode === n - 1) {\\n            return priority;\\n        }\\n\\n        for (const node in graph[currNode]) {\\n            const nextNode = parseInt(node);\\n            const nextTime = graph[currNode][node] + currTime;\\n\\n            if (nextTime <= maxTime && nextTime < bestTimes[nextNode]) {\\n                bestTimes[nextNode] = nextTime;\\n                q.enqueue([nextNode, nextTime], passingFees[nextNode] + priority);\\n            }\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104389,
                "title": "java-dijkstra-faster-than-90-46-less-memo-than-95-41",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<int[]>[] graph = buildGraph(n, edges);\\n\\t\\t// priority queue makes sure we are polling lowest fee every time\\n        PriorityQueue<Node> q = new PriorityQueue<>((a, b) -> Integer.compare(a.fee, b.fee));\\n\\t\\t// The visited records the minimum time to reach that node\\n        int[] visited = new int[n];\\n        Arrays.fill(visited, Integer.MAX_VALUE);\\n        q.offer(new Node(passingFees[0], 0, 0));\\n        while (!q.isEmpty()) {\\n            Node c = q.poll();\\n            if (c.city == n - 1) return c.fee;          \\n            for (int[] neighbor: graph[c.city]) {\\n                if (c.time + neighbor[1] > maxTime) continue;\\n                int newTime = c.time + neighbor[1];\\n\\t\\t\\t\\t// only if new time to reach the node becomes smaller we have better chance to reach destination\\n                if (newTime < visited[neighbor[0]]) {\\n                    visited[neighbor[0]] = newTime;\\n                    q.offer(new Node(passingFees[neighbor[0]] + c.fee, c.time + neighbor[1], neighbor[0]));\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n    private List<int[]>[] buildGraph(int n, int[][] edges) {\\n        List<int[]>[] graph = new List[n];\\n        Arrays.setAll(graph, r -> new ArrayList<>());\\n        for (int[] edge: edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int time = edge[2];\\n            graph[from].add(new int[] { to, time });\\n            graph[to].add(new int[] { from, time });\\n        }\\n        return graph;\\n    }\\n    private static class Node {\\n        int fee;\\n        int time;\\n        int city;\\n        public Node(int fee, int time, int city) {\\n            this.fee = fee;\\n            this.time = time;\\n            this.city = city;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<int[]>[] graph = buildGraph(n, edges);\\n\\t\\t// priority queue makes sure we are polling lowest fee every time\\n        PriorityQueue<Node> q = new PriorityQueue<>((a, b) -> Integer.compare(a.fee, b.fee));\\n\\t\\t// The visited records the minimum time to reach that node\\n        int[] visited = new int[n];\\n        Arrays.fill(visited, Integer.MAX_VALUE);\\n        q.offer(new Node(passingFees[0], 0, 0));\\n        while (!q.isEmpty()) {\\n            Node c = q.poll();\\n            if (c.city == n - 1) return c.fee;          \\n            for (int[] neighbor: graph[c.city]) {\\n                if (c.time + neighbor[1] > maxTime) continue;\\n                int newTime = c.time + neighbor[1];\\n\\t\\t\\t\\t// only if new time to reach the node becomes smaller we have better chance to reach destination\\n                if (newTime < visited[neighbor[0]]) {\\n                    visited[neighbor[0]] = newTime;\\n                    q.offer(new Node(passingFees[neighbor[0]] + c.fee, c.time + neighbor[1], neighbor[0]));\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n    private List<int[]>[] buildGraph(int n, int[][] edges) {\\n        List<int[]>[] graph = new List[n];\\n        Arrays.setAll(graph, r -> new ArrayList<>());\\n        for (int[] edge: edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int time = edge[2];\\n            graph[from].add(new int[] { to, time });\\n            graph[to].add(new int[] { from, time });\\n        }\\n        return graph;\\n    }\\n    private static class Node {\\n        int fee;\\n        int time;\\n        int city;\\n        public Node(int fee, int time, int city) {\\n            this.fee = fee;\\n            this.time = time;\\n            this.city = city;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031928,
                "title": "c-dijkstra-s-algorithm-intuitive-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        int n = fee.size();\\n        vector<vector<pair<int, int>>> adj(n, vector<pair<int, int>>());\\n        \\n        for(vector<int>& e: edges){\\n            int u = e[0], v = e[1], t = e[2];\\n            adj[u].push_back({t, v});\\n            adj[v].push_back({t, u});\\n        }\\n        \\n        vector<int> times(n, maxTime + 1);\\n        auto cmp = [](auto& a, auto& b) {return a[0] > b[0];};\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, decltype(cmp)> q(cmp);\\n        \\n        q.push({fee[0], 0, 0});\\n        \\n        while(q.size() > 0){\\n            auto [price, t, u] = q.top();\\n            q.pop();\\n            \\n            if(u == n - 1) return price;\\n            \\n            //if we already process \\'u\\' (than previously it had smaller price)\\n            //and if then it had time at most \\'t\\' time we can skip\\n            //otherwise \\'t\\' is the smallest time for \\'u\\' until now\\n            if(times[u] <= t) continue;\\n            else times[u] = t;\\n            \\n            for(auto& [t1, v]: adj[u]){\\n                //again same reasoning\\n                if(times[v] <= t + t1) continue;\\n                q.push({price + fee[v], t1 + t, v});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        int n = fee.size();\\n        vector<vector<pair<int, int>>> adj(n, vector<pair<int, int>>());\\n        \\n        for(vector<int>& e: edges){\\n            int u = e[0], v = e[1], t = e[2];\\n            adj[u].push_back({t, v});\\n            adj[v].push_back({t, u});\\n        }\\n        \\n        vector<int> times(n, maxTime + 1);\\n        auto cmp = [](auto& a, auto& b) {return a[0] > b[0];};\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, decltype(cmp)> q(cmp);\\n        \\n        q.push({fee[0], 0, 0});\\n        \\n        while(q.size() > 0){\\n            auto [price, t, u] = q.top();\\n            q.pop();\\n            \\n            if(u == n - 1) return price;\\n            \\n            //if we already process \\'u\\' (than previously it had smaller price)\\n            //and if then it had time at most \\'t\\' time we can skip\\n            //otherwise \\'t\\' is the smallest time for \\'u\\' until now\\n            if(times[u] <= t) continue;\\n            else times[u] = t;\\n            \\n            for(auto& [t1, v]: adj[u]){\\n                //again same reasoning\\n                if(times[v] <= t + t1) continue;\\n                q.push({price + fee[v], t1 + t, v});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891287,
                "title": "c-simple-to-understand-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        const int INF = 1e9 + 5;\\n        int n = passingFees.size();\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            int w = e[2];\\n            adj[u].push_back({v, w});\\n            adj[v].push_back({u, w});\\n        }\\n        vector<vector<int>> dp(maxTime+1, vector<int>(n, INF));\\n        //dp[i][j] = min cost to reach city j, int time i\\n        dp[0][0] = passingFees[0];\\n        for(int t=0; t<=maxTime; ++t) {\\n            for(int u=0; u<n; u++) {\\n                if(dp[t][u] >= INF)continue;\\n                for(auto [v, time]: adj[u]) {\\n                    int t2 = t + time;\\n                    if(t2 > maxTime)continue;\\n                    dp[t2][v] = min(dp[t2][v], dp[t][u] + passingFees[v]);\\n                }\\n            }\\n        }\\n        int res = INF;\\n        for(int t=0; t<=maxTime; ++t) {\\n            res = min(res, dp[t][n-1]);\\n        }\\n        if(res >= INF)return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        const int INF = 1e9 + 5;\\n        int n = passingFees.size();\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            int w = e[2];\\n            adj[u].push_back({v, w});\\n            adj[v].push_back({u, w});\\n        }\\n        vector<vector<int>> dp(maxTime+1, vector<int>(n, INF));\\n        //dp[i][j] = min cost to reach city j, int time i\\n        dp[0][0] = passingFees[0];\\n        for(int t=0; t<=maxTime; ++t) {\\n            for(int u=0; u<n; u++) {\\n                if(dp[t][u] >= INF)continue;\\n                for(auto [v, time]: adj[u]) {\\n                    int t2 = t + time;\\n                    if(t2 > maxTime)continue;\\n                    dp[t2][v] = min(dp[t2][v], dp[t][u] + passingFees[v]);\\n                }\\n            }\\n        }\\n        int res = INF;\\n        for(int t=0; t<=maxTime; ++t) {\\n            res = min(res, dp[t][n-1]);\\n        }\\n        if(res >= INF)return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875444,
                "title": "easy-dp",
                "content": "\\t#define pi pair<int,int>\\n\\n\\tclass Solution {\\n\\t\\tint dp[1001][1001];\\n\\t\\tint f(vector<pi> g[],int u,int currTime,int&maxTime,vector<int>& passingFees){\\n\\t\\t\\tif(currTime > maxTime) return (1e8);\\n\\t\\t\\tif(u == passingFees.size()-1) return passingFees[u];\\n\\t\\t\\tif(dp[u][currTime]!=-1) return dp[u][currTime];\\n\\n\\t\\t\\tint ans = (1e8);\\n\\t\\t\\tfor(auto [cost,v]:g[u]){\\n\\t\\t\\t\\tans = min(ans,f(g,v,currTime + cost,maxTime,passingFees));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[u][currTime] = ans + passingFees[u];\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n\\t\\t\\tint n = passingFees.size();\\n\\t\\t\\tvector<pi> g[n];\\n\\t\\t\\tfor(auto it:edges){\\n\\t\\t\\t\\tg[it[0]].push_back({it[2],it[1]});\\n\\t\\t\\t\\tg[it[1]].push_back({it[2],it[0]});\\n\\t\\t\\t}\\n\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\t\\t\\tint ans = f(g,0,0,maxTime,passingFees);\\n\\t\\t\\treturn (ans>=(1e8)?-1:ans);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint dp[1001][1001];\\n\\t\\tint f(vector<pi> g[],int u,int currTime,int&maxTime,vector<int>& passingFees){\\n\\t\\t\\tif(currTime > maxTime) return (1e8);\\n\\t\\t\\tif(u == passingFees.size()-1) return passingFees[u];\\n\\t\\t\\tif(dp[u][currTime]!=-1) return dp[u][currTime];\\n\\n\\t\\t\\tint ans = (1e8);\\n\\t\\t\\tfor(auto [cost,v]:g[u]){\\n\\t\\t\\t\\tans = min(ans,f(g,v,currTime + cost,maxTime,passingFees));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1815117,
                "title": "modified-dijkstra-s-with-intuition",
                "content": "Instead of visited array that we normally put we have to make visited for time as there may exists a solution with more cost but with desired time and we have visited array for a node which might be come in the path of optimal solution we will miss the best solution\\n\\n```\\nclass Solution {\\n\\n\\tpublic int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n\\t\\tint dest = passingFees.length - 1;\\n\\t\\tArrayList<Edge>[] graph = new ArrayList[passingFees.length];\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tgraph[i] = new ArrayList();\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < edges.length; i++) {\\n\\t\\t\\tint src = edges[i][0];\\n\\t\\t\\tint nbr = edges[i][1];\\n\\t\\t\\tint time = edges[i][2];\\n\\t\\t\\tgraph[src].add(new Edge(nbr, time, passingFees[src]));\\n\\t\\t\\tgraph[nbr].add(new Edge(src, time, passingFees[nbr]));\\n\\n\\t\\t}\\n\\t\\tint[] visited = new int[passingFees.length];\\n\\t\\tArrays.fill(visited, -1);\\n\\t\\tPriorityQueue<Edge> q = new PriorityQueue<>();\\n\\t\\tq.add(new Edge(0, 0, passingFees[0]));\\n\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\tEdge r = q.poll();\\n\\t\\t\\tif (r.nbr == dest)\\n\\t\\t\\t\\treturn r.fees;\\n\\t\\t\\tfor (Edge nbr : graph[r.nbr]) {\\n\\t\\t\\t\\tif (visited[nbr.nbr] != -1 && r.time + nbr.time >= visited[nbr.nbr])\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvisited[nbr.nbr] = r.time + nbr.time;\\n\\t\\t\\t\\tif (r.time + nbr.time <= maxTime) {\\n\\t\\t\\t\\t\\tq.add(new Edge(nbr.nbr, r.time + nbr.time, r.fees + passingFees[nbr.nbr]));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic static class Edge implements Comparable<Edge> {\\n\\n\\t\\tint nbr;\\n\\t\\tint time;\\n\\t\\tint fees;\\n\\n\\t\\tpublic Edge(int nbr, int time, int fees) {\\n\\n\\t\\t\\tthis.nbr = nbr;\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\tthis.fees = fees;\\n\\t\\t}\\n\\n\\t\\tpublic int compareTo(Edge o) {\\n\\t\\t\\treturn this.fees - o.fees;\\n\\t\\t}\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\n\\tpublic int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n\\t\\tint dest = passingFees.length - 1;\\n\\t\\tArrayList<Edge>[] graph = new ArrayList[passingFees.length];\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tgraph[i] = new ArrayList();\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1726257,
                "title": "java-simple-solution-runtime-56ms",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        ArrayList<ArrayList<road>> country= new ArrayList<ArrayList<road>>();\\n        int l=passingFees.length;\\n        for(int i=0;i<l;i++)\\n        {\\n            country.add(new ArrayList<road>());\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            country.get(edges[i][0]).add(new road(edges[i][1],edges[i][2]));\\n            country.get(edges[i][1]).add(new road(edges[i][0],edges[i][2]));\\n        }\\n        return smartdrive(maxTime,0,l-1,passingFees,country);\\n    }\\n    public int smartdrive(int maxTime, int s, int e, int []fees, ArrayList<ArrayList<road>> country)\\n    {\\n        PriorityQueue<costpriority> order= new PriorityQueue<costpriority>(new prioritycomparator());\\n        order.offer( new costpriority(fees[s],s,0));\\n        int []cost= new int[fees.length];\\n        int []time= new int[fees.length];\\n        Arrays.fill(cost,Integer.MAX_VALUE);\\n        Arrays.fill(time,Integer.MAX_VALUE);\\n        cost[s]=fees[s];\\n        time[s]=0;\\n        while(order.size()>0)\\n        {\\n            costpriority top=order.poll();\\n            int c=top.cost;\\n            int x=top.city;\\n            int t=top.time;\\n            if(t>maxTime)\\n                continue;\\n            if(x==e)\\n                return c;\\n            for(road i:country.get(x))\\n            {\\n                if(fees[i.city]+c<cost[i.city])\\n                {\\n                    cost[i.city]=fees[i.city]+c;\\n                    time[i.city]=i.time+t;\\n                    order.offer(new costpriority(cost[i.city],i.city,time[i.city]));\\n                }\\n                if(i.time+t<time[i.city])\\n                {\\n                    time[i.city]=i.time+t;\\n                    order.offer(new costpriority(fees[i.city]+c,i.city,time[i.city]));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    class road{\\n        int city;\\n        int time;\\n        road(int city,int time)\\n        {\\n            this.city=city;\\n            this.time=time;\\n        }\\n    }\\n    class prioritycomparator implements Comparator<costpriority>{\\n        public int compare(costpriority a, costpriority b)\\n        {\\n            return a.cost-b.cost;\\n        }\\n    }\\n    class costpriority{\\n        int cost;\\n        int city;\\n        int time;\\n        costpriority(int cost, int city, int time)\\n        {\\n            this.cost=cost;\\n            this.city=city;\\n            this.time=time;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        ArrayList<ArrayList<road>> country= new ArrayList<ArrayList<road>>();\\n        int l=passingFees.length;\\n        for(int i=0;i<l;i++)\\n        {\\n            country.add(new ArrayList<road>());\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            country.get(edges[i][0]).add(new road(edges[i][1],edges[i][2]));\\n            country.get(edges[i][1]).add(new road(edges[i][0],edges[i][2]));\\n        }\\n        return smartdrive(maxTime,0,l-1,passingFees,country);\\n    }\\n    public int smartdrive(int maxTime, int s, int e, int []fees, ArrayList<ArrayList<road>> country)\\n    {\\n        PriorityQueue<costpriority> order= new PriorityQueue<costpriority>(new prioritycomparator());\\n        order.offer( new costpriority(fees[s],s,0));\\n        int []cost= new int[fees.length];\\n        int []time= new int[fees.length];\\n        Arrays.fill(cost,Integer.MAX_VALUE);\\n        Arrays.fill(time,Integer.MAX_VALUE);\\n        cost[s]=fees[s];\\n        time[s]=0;\\n        while(order.size()>0)\\n        {\\n            costpriority top=order.poll();\\n            int c=top.cost;\\n            int x=top.city;\\n            int t=top.time;\\n            if(t>maxTime)\\n                continue;\\n            if(x==e)\\n                return c;\\n            for(road i:country.get(x))\\n            {\\n                if(fees[i.city]+c<cost[i.city])\\n                {\\n                    cost[i.city]=fees[i.city]+c;\\n                    time[i.city]=i.time+t;\\n                    order.offer(new costpriority(cost[i.city],i.city,time[i.city]));\\n                }\\n                if(i.time+t<time[i.city])\\n                {\\n                    time[i.city]=i.time+t;\\n                    order.offer(new costpriority(fees[i.city]+c,i.city,time[i.city]));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    class road{\\n        int city;\\n        int time;\\n        road(int city,int time)\\n        {\\n            this.city=city;\\n            this.time=time;\\n        }\\n    }\\n    class prioritycomparator implements Comparator<costpriority>{\\n        public int compare(costpriority a, costpriority b)\\n        {\\n            return a.cost-b.cost;\\n        }\\n    }\\n    class costpriority{\\n        int cost;\\n        int city;\\n        int time;\\n        costpriority(int cost, int city, int time)\\n        {\\n            this.cost=cost;\\n            this.city=city;\\n            this.time=time;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653313,
                "title": "c-dijkastra-dp",
                "content": "```\\nclass Solution {\\n    typedef pair<int, int> edge;\\n    struct cmp {\\n        bool operator()(const array<int, 3> &first,\\n                        const array<int, 3> &second) {\\n            return first[2] > second[2];\\n        }\\n    };\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        unordered_map<int, vector<edge>> g;\\n        for (auto v: edges) {\\n            g[v[0]].push_back({v[1], v[2]});\\n            g[v[1]].push_back({v[0], v[2]});\\n        }\\n        int n = passingFees.size();\\n        std::priority_queue<array<int, 3>, vector<array<int, 3>>,\\n                              cmp> q;\\n        q.push({0, 0, passingFees[0]});\\n        vector<int> nodeTimes(n, INT_MAX);\\n        vector<vector<int>> dp(n, vector<int>(maxTime+1, INT_MAX));\\n        while (q.empty() == false) {\\n            auto [start, time, cost] = q.top();\\n            if (start == n-1) break;\\n            q.pop();\\n            for (auto [node, ntime]: g[start]) {\\n                if (time+ntime <= nodeTimes[node]) {\\n                    if (time+ntime <= maxTime) {\\n                        if (passingFees[node]+cost <= dp[node][time+ntime]) {\\n                            nodeTimes[node] = time+ntime;\\n                            dp[node][time+ntime] = passingFees[node]+cost;\\n                            q.push({node, time+ntime, cost+passingFees[node]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return (q.empty())?-1: *std::min_element(std::begin(dp[n-1]), std::end(dp[n-1]));    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef pair<int, int> edge;\\n    struct cmp {\\n        bool operator()(const array<int, 3> &first,\\n                        const array<int, 3> &second) {\\n            return first[2] > second[2];\\n        }\\n    };\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        unordered_map<int, vector<edge>> g;\\n        for (auto v: edges) {\\n            g[v[0]].push_back({v[1], v[2]});\\n            g[v[1]].push_back({v[0], v[2]});\\n        }\\n        int n = passingFees.size();\\n        std::priority_queue<array<int, 3>, vector<array<int, 3>>,\\n                              cmp> q;\\n        q.push({0, 0, passingFees[0]});\\n        vector<int> nodeTimes(n, INT_MAX);\\n        vector<vector<int>> dp(n, vector<int>(maxTime+1, INT_MAX));\\n        while (q.empty() == false) {\\n            auto [start, time, cost] = q.top();\\n            if (start == n-1) break;\\n            q.pop();\\n            for (auto [node, ntime]: g[start]) {\\n                if (time+ntime <= nodeTimes[node]) {\\n                    if (time+ntime <= maxTime) {\\n                        if (passingFees[node]+cost <= dp[node][time+ntime]) {\\n                            nodeTimes[node] = time+ntime;\\n                            dp[node][time+ntime] = passingFees[node]+cost;\\n                            q.push({node, time+ntime, cost+passingFees[node]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return (q.empty())?-1: *std::min_element(std::begin(dp[n-1]), std::end(dp[n-1]));    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578153,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minCost(int maxtime,vector<vector<int>>&nums,vector<int>&fee) \\n    {\\n        int n=fee.size();\\n        vector<pair<int,int>>dp[n+100];\\n        vector<int>dis(n+1000,INT_MAX);\\n        for(auto it:nums)\\n        {\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({fee[0],0,0});\\n        while(pq.size())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            int f=temp[0];\\n            int time=temp[1];\\n            int node=temp[2];\\n            if(node==n-1)\\n            {\\n                return f;\\n            }\\n            for(auto it:dp[node])\\n            {\\n                int new_time=time+it.second;\\n                if(new_time<=maxtime&&dis[it.first]>time+it.second)\\n                {\\n                   dis[it.first]=new_time;\\n                   pq.push({f+fee[it.first],new_time,it.first});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minCost(int maxtime,vector<vector<int>>&nums,vector<int>&fee) \\n    {\\n        int n=fee.size();\\n        vector<pair<int,int>>dp[n+100];\\n        vector<int>dis(n+1000,INT_MAX);\\n        for(auto it:nums)\\n        {\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({fee[0],0,0});\\n        while(pq.size())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            int f=temp[0];\\n            int time=temp[1];\\n            int node=temp[2];\\n            if(node==n-1)\\n            {\\n                return f;\\n            }\\n            for(auto it:dp[node])\\n            {\\n                int new_time=time+it.second;\\n                if(new_time<=maxtime&&dis[it.first]>time+it.second)\\n                {\\n                   dis[it.first]=new_time;\\n                   pq.push({f+fee[it.first],new_time,it.first});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523781,
                "title": "python-dijkstra-algorithm",
                "content": "Main observation is that we might reach the same node again searching for path that is under our time limit. Hence we apply BFS on that node again (if already applied) instead of dropping.\\n```\\nfrom collections import defaultdict\\nfrom heapq import heappop,heappush\\nclass Solution:\\n    mn = float(\\'inf\\')\\n    def minCost(self, mxt: int, edges: List[List[int]], fees: List[int]) -> int:\\n        n = len(fees)\\n        adj = defaultdict(list)\\n        tms = defaultdict(lambda : float(\\'inf\\'))   ### need this dictionary to  account the reaching time at ith node. \\n        for x,y,t in edges:\\n            adj[x].append([y,t])\\n            adj[y].append([x,t])\\n        qu = []\\n        heappush(qu,(fees[0],0,0))\\n        while qu:\\n            fee,tm,nd = heappop(qu)\\n            if tm > mxt :\\n                continue\\n            if nd == n-1 :\\n                return fee\\n            if tm < tms[nd]:            ### simply if we come again at the same node and in lesser time we allow bfs over that node. \\n                for dest,time in adj[nd]:\\n                    heappush(qu,(fee+fees[dest],tm+time,dest))\\n            tms[nd] = min(tms[nd],tm)  ## store the  min reachable  time at the  node\\n        return -1\\n\\t\\t",
                "solutionTags": [],
                "code": "Main observation is that we might reach the same node again searching for path that is under our time limit. Hence we apply BFS on that node again (if already applied) instead of dropping.\\n```\\nfrom collections import defaultdict\\nfrom heapq import heappop,heappush\\nclass Solution:\\n    mn = float(\\'inf\\')\\n    def minCost(self, mxt: int, edges: List[List[int]], fees: List[int]) -> int:\\n        n = len(fees)\\n        adj = defaultdict(list)\\n        tms = defaultdict(lambda : float(\\'inf\\'))   ### need this dictionary to  account the reaching time at ith node. \\n        for x,y,t in edges:\\n            adj[x].append([y,t])\\n            adj[y].append([x,t])\\n        qu = []\\n        heappush(qu,(fees[0],0,0))\\n        while qu:\\n            fee,tm,nd = heappop(qu)\\n            if tm > mxt :\\n                continue\\n            if nd == n-1 :\\n                return fee\\n            if tm < tms[nd]:            ### simply if we come again at the same node and in lesser time we allow bfs over that node. \\n                for dest,time in adj[nd]:\\n                    heappush(qu,(fee+fees[dest],tm+time,dest))\\n            tms[nd] = min(tms[nd],tm)  ## store the  min reachable  time at the  node\\n        return -1\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1461380,
                "title": "bellman-ford-python3",
                "content": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        f = [[float(\"inf\")] * n for _ in range(maxTime + 1)]\\n        f[0][0] = passingFees[0]\\n        for t in range(1, maxTime + 1):\\n            for i, j, cost in edges:\\n                if cost <= t:\\n                    f[t][i] = min(f[t][i], f[t - cost][j] + passingFees[i])\\n                    f[t][j] = min(f[t][j], f[t - cost][i] + passingFees[j])\\n        ans = min(f[t][n - 1] for t in range(1, maxTime + 1))\\n        return -1 if ans == float(\"inf\") else ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        f = [[float(\"inf\")] * n for _ in range(maxTime + 1)]\\n        f[0][0] = passingFees[0]\\n        for t in range(1, maxTime + 1):\\n            for i, j, cost in edges:\\n                if cost <= t:\\n                    f[t][i] = min(f[t][i], f[t - cost][j] + passingFees[i])\\n                    f[t][j] = min(f[t][j], f[t - cost][i] + passingFees[j])\\n        ans = min(f[t][n - 1] for t in range(1, maxTime + 1))\\n        return -1 if ans == float(\"inf\") else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456926,
                "title": "java-min-heap-dijkstra-easy-priority-queue",
                "content": "Please comment incase of any questions\\n```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        Map<Integer,Map<Integer,Integer>> adjGrp = new HashMap<>();\\n        adjGrp = getAdjGrp(edges);\\n        int n = passingFees.length;\\n        if(noValidPath(adjGrp,n))\\n            return -1;\\n        int[] timeTaken = new int[n];\\n        Arrays.fill(timeTaken,Integer.MAX_VALUE);\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> a[1]-b[1]); \\n        timeTaken[0] = 0;  //0 is the staring point\\n        minHeap.offer(new int[]{0,passingFees[0],0});\\n        int dest = n-1;\\n        while(!minHeap.isEmpty()){\\n            int[] nodeSrc = minHeap.poll();\\n            int currTime = nodeSrc[2];\\n            int currCost = nodeSrc[1];\\n            int u = nodeSrc[0];\\n            if(u == dest){\\n                return currCost;\\n            }\\n            for(Map.Entry<Integer,Integer> vertex : adjGrp.get(u).entrySet()){\\n                int v = vertex.getKey();\\n                int time = vertex.getValue();\\n                int fee = passingFees[v]; \\n                if(currTime+time > maxTime)\\n                    continue; \\n                if(currTime+time < timeTaken[v]){\\n                    timeTaken[v] = currTime+time;\\n                    minHeap.offer(new int[]{v,fee+currCost,timeTaken[v]});                \\n                }                \\n            }                        \\n        }\\n        return -1;        \\n        \\n        \\n    }\\n    public boolean noValidPath(Map<Integer,Map<Integer,Integer>> adjGrp , int n ){\\n        for(int i = 0 ; i < n ;i++){\\n            if(!adjGrp.containsKey(i))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    //Optimization by taking on fastest road if 2 available \\n    public Map<Integer,Map<Integer,Integer>> getAdjGrp(int[][] edges){\\n        Map<Integer,Map<Integer,Integer>> adjGrp = new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int t = edges[i][2];\\n            adjGrp.putIfAbsent(u,new HashMap<Integer,Integer>());\\n            adjGrp.putIfAbsent(v,new HashMap<Integer,Integer>());   \\n            if(!adjGrp.get(u).containsKey(v))\\n                adjGrp.get(u).put(v,t);                \\n            else{\\n                if(adjGrp.get(u).get(v) > t) {\\n                    adjGrp.get(u).put(v,t); \\n                }\\n            }\\n            if(!adjGrp.get(v).containsKey(u))\\n                adjGrp.get(v).put(u,t);                \\n            else{\\n                if(adjGrp.get(v).get(u) > t )\\n                    adjGrp.get(v).put(u,t);\\n            }\\n            \\n        }\\n        return adjGrp; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        Map<Integer,Map<Integer,Integer>> adjGrp = new HashMap<>();\\n        adjGrp = getAdjGrp(edges);\\n        int n = passingFees.length;\\n        if(noValidPath(adjGrp,n))\\n            return -1;\\n        int[] timeTaken = new int[n];\\n        Arrays.fill(timeTaken,Integer.MAX_VALUE);\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> a[1]-b[1]); \\n        timeTaken[0] = 0;  //0 is the staring point\\n        minHeap.offer(new int[]{0,passingFees[0],0});\\n        int dest = n-1;\\n        while(!minHeap.isEmpty()){\\n            int[] nodeSrc = minHeap.poll();\\n            int currTime = nodeSrc[2];\\n            int currCost = nodeSrc[1];\\n            int u = nodeSrc[0];\\n            if(u == dest){\\n                return currCost;\\n            }\\n            for(Map.Entry<Integer,Integer> vertex : adjGrp.get(u).entrySet()){\\n                int v = vertex.getKey();\\n                int time = vertex.getValue();\\n                int fee = passingFees[v]; \\n                if(currTime+time > maxTime)\\n                    continue; \\n                if(currTime+time < timeTaken[v]){\\n                    timeTaken[v] = currTime+time;\\n                    minHeap.offer(new int[]{v,fee+currCost,timeTaken[v]});                \\n                }                \\n            }                        \\n        }\\n        return -1;        \\n        \\n        \\n    }\\n    public boolean noValidPath(Map<Integer,Map<Integer,Integer>> adjGrp , int n ){\\n        for(int i = 0 ; i < n ;i++){\\n            if(!adjGrp.containsKey(i))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    //Optimization by taking on fastest road if 2 available \\n    public Map<Integer,Map<Integer,Integer>> getAdjGrp(int[][] edges){\\n        Map<Integer,Map<Integer,Integer>> adjGrp = new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int t = edges[i][2];\\n            adjGrp.putIfAbsent(u,new HashMap<Integer,Integer>());\\n            adjGrp.putIfAbsent(v,new HashMap<Integer,Integer>());   \\n            if(!adjGrp.get(u).containsKey(v))\\n                adjGrp.get(u).put(v,t);                \\n            else{\\n                if(adjGrp.get(u).get(v) > t) {\\n                    adjGrp.get(u).put(v,t); \\n                }\\n            }\\n            if(!adjGrp.get(v).containsKey(u))\\n                adjGrp.get(v).put(u,t);                \\n            else{\\n                if(adjGrp.get(v).get(u) > t )\\n                    adjGrp.get(v).put(u,t);\\n            }\\n            \\n        }\\n        return adjGrp; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431804,
                "title": "python3-bfs-pruning",
                "content": "Minimum cost problem can be reduced to BFS problem. We need to add the time constraints. So we pick the minimum cost node from the heap and when adding adjacenct nodes of the picked node, we select them only if time can be reduced. We do not need to check cost since earliest visit to a node will have the minimum cost.\\n```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adjacency = defaultdict(list)\\n        min_times = {}\\n        for src,dst,time in edges:\\n            adjacency[src].append([dst,time])\\n            adjacency[dst].append([src,time])\\n        \\n        heap = []\\n        heappush(heap, (passingFees[0],0,0))\\n        min_times[0] = 0\\n        while heap:\\n            cost,time,node = heappop(heap)\\n            if node==n-1:\\n                return cost\\n            for dst,distance in adjacency[node]:\\n                if time+distance<=maxTime and min_times.get(dst,float(\\'inf\\'))>time+distance:\\n                    min_times[dst] = time+distance\\n                    heappush(heap, ( cost+passingFees[dst], time+distance,dst))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adjacency = defaultdict(list)\\n        min_times = {}\\n        for src,dst,time in edges:\\n            adjacency[src].append([dst,time])\\n            adjacency[dst].append([src,time])\\n        \\n        heap = []\\n        heappush(heap, (passingFees[0],0,0))\\n        min_times[0] = 0\\n        while heap:\\n            cost,time,node = heappop(heap)\\n            if node==n-1:\\n                return cost\\n            for dst,distance in adjacency[node]:\\n                if time+distance<=maxTime and min_times.get(dst,float(\\'inf\\'))>time+distance:\\n                    min_times[dst] = time+distance\\n                    heappush(heap, ( cost+passingFees[dst], time+distance,dst))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420371,
                "title": "almost-same-problem-as-787-cheapest-flights-within-k-stops",
                "content": "Using two arrays (minCost and minTime) to do relaxation in Dijkstra search\\n\\n787. Cheapest Flights Within K Stops\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        HashMap<Integer, Integer>[] graph = new HashMap[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new HashMap<>();\\n        for (int[] flight : flights)\\n            graph[flight[0]].put(flight[1], flight[2]);\\n\\n        int[] minCosts = new int[n], minStops = new int[n];\\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        Arrays.fill(minStops, Integer.MAX_VALUE);\\n        minCosts[src] = 0;\\n        minStops[src] = 0;\\n\\n        // The priority queue would contain (node, cost, stops)\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[]{src, 0, 0});\\n\\n        while (!pq.isEmpty()) {\\n            int[] info = pq.poll();\\n            int node = info[0], costs = info[1], stops = info[2];\\n\\n            if (node == dst) return costs;\\n\\n            for (int nextNode : graph[node].keySet()) {\\n                int price = graph[node].get(nextNode);\\n                if (stops > k) continue;\\n                if (costs + price < minCosts[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + price, stops + 1});\\n                    minCosts[nextNode] = costs + price;\\n                    minStops[nextNode] = stops + 1;\\n                } else if (stops + 1 < minStops[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + price, stops + 1});\\n                    minStops[nextNode] = stops + 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```\\n\\n\\n1928. Minimum Cost to Reach Destination in Time\\n```\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        int[] minTime = new int[n];\\n        int[] minCosts = new int[n];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        minTime[0] = 0;\\n        minCosts[0] = passingFees[0];\\n\\n        HashMap<Integer, Integer>[] graph = new HashMap[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new HashMap<>();\\n        for (int[] e : edges) {\\n            if (!graph[e[0]].containsKey(e[1]) || graph[e[0]].get(e[1]) > e[2])\\n                graph[e[0]].put(e[1], e[2]);\\n            if (!graph[e[1]].containsKey(e[0]) || graph[e[1]].get(e[0]) > e[2])\\n                graph[e[1]].put(e[0], e[2]);\\n        }\\n\\n        // The priority queue would contain (node, cost, time)\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[]{0, passingFees[0], 0});\\n\\n        while (!pq.isEmpty()) {\\n            int[] info = pq.poll();\\n            int node = info[0], costs = info[1], time = info[2];\\n            if (node == n - 1) return costs;\\n\\n            for (int nextNode : graph[node].keySet()) {\\n                int passingTime = graph[node].get(nextNode);\\n                int newFee = passingFees[nextNode];\\n                if (time + passingTime > maxTime) continue;\\n\\n                if (costs + newFee < minCosts[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + newFee, time + passingTime});\\n                    minCosts[nextNode] = costs + newFee;\\n                    minTime[nextNode] = time + passingTime;\\n                } else if (time + passingTime < minTime[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + newFee, time + passingTime});\\n                    minTime[nextNode] = time + passingTime;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        HashMap<Integer, Integer>[] graph = new HashMap[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new HashMap<>();\\n        for (int[] flight : flights)\\n            graph[flight[0]].put(flight[1], flight[2]);\\n\\n        int[] minCosts = new int[n], minStops = new int[n];\\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        Arrays.fill(minStops, Integer.MAX_VALUE);\\n        minCosts[src] = 0;\\n        minStops[src] = 0;\\n\\n        // The priority queue would contain (node, cost, stops)\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[]{src, 0, 0});\\n\\n        while (!pq.isEmpty()) {\\n            int[] info = pq.poll();\\n            int node = info[0], costs = info[1], stops = info[2];\\n\\n            if (node == dst) return costs;\\n\\n            for (int nextNode : graph[node].keySet()) {\\n                int price = graph[node].get(nextNode);\\n                if (stops > k) continue;\\n                if (costs + price < minCosts[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + price, stops + 1});\\n                    minCosts[nextNode] = costs + price;\\n                    minStops[nextNode] = stops + 1;\\n                } else if (stops + 1 < minStops[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + price, stops + 1});\\n                    minStops[nextNode] = stops + 1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```\n```\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        int[] minTime = new int[n];\\n        int[] minCosts = new int[n];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        minTime[0] = 0;\\n        minCosts[0] = passingFees[0];\\n\\n        HashMap<Integer, Integer>[] graph = new HashMap[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new HashMap<>();\\n        for (int[] e : edges) {\\n            if (!graph[e[0]].containsKey(e[1]) || graph[e[0]].get(e[1]) > e[2])\\n                graph[e[0]].put(e[1], e[2]);\\n            if (!graph[e[1]].containsKey(e[0]) || graph[e[1]].get(e[0]) > e[2])\\n                graph[e[1]].put(e[0], e[2]);\\n        }\\n\\n        // The priority queue would contain (node, cost, time)\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[]{0, passingFees[0], 0});\\n\\n        while (!pq.isEmpty()) {\\n            int[] info = pq.poll();\\n            int node = info[0], costs = info[1], time = info[2];\\n            if (node == n - 1) return costs;\\n\\n            for (int nextNode : graph[node].keySet()) {\\n                int passingTime = graph[node].get(nextNode);\\n                int newFee = passingFees[nextNode];\\n                if (time + passingTime > maxTime) continue;\\n\\n                if (costs + newFee < minCosts[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + newFee, time + passingTime});\\n                    minCosts[nextNode] = costs + newFee;\\n                    minTime[nextNode] = time + passingTime;\\n                } else if (time + passingTime < minTime[nextNode]) {\\n                    pq.offer(new int[]{nextNode, costs + newFee, time + passingTime});\\n                    minTime[nextNode] = time + passingTime;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404932,
                "title": "simple-java-djikstra",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        int destination = n-1;\\n        int source = 0;\\n        Integer[] timeHold = new Integer[n];\\n        Arrays.fill(timeHold, Integer.MAX_VALUE);\\n\\n        Map<Integer,List<int[]>> graph = new HashMap();\\n        for(int[] edge : edges){\\n            int src = edge[0];\\n            int dst = edge[1];\\n            int time = edge[2];\\n            graph.putIfAbsent(src,new ArrayList());\\n            graph.putIfAbsent(dst,new ArrayList());\\n            graph.get(src).add(new int[]{dst,time});\\n            graph.get(dst).add(new int[]{src,time});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( (a, b) -> a[1] - b[1] ); //a[0] = city, a[1] = cost, a[2] = time\\n        pq.offer(new int[]{source, passingFees[source], 0});\\n        timeHold[0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int src = node[0];\\n            int fee = node[1];\\n            int time = node[2];\\n\\n            if(src == destination) // check whether destination reached ?\\n                return fee;\\n            \\n            for(int[] nei : graph.get(src)){\\n                \\n                int neiNode = nei[0];\\n                int neiTime = nei[1];\\n                                              \\n                if(time + neiTime > maxTime) // we cannot exceed maxTime, return .. \\n                    continue;\\n                \\n                if(time + neiTime < timeHold[neiNode]){\\n                    timeHold[neiNode] = time + neiTime; //we found lesser time update time Array and add this node to pq..\\n                    pq.add(new int[]{neiNode, fee + passingFees[neiNode], timeHold[neiNode]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        int destination = n-1;\\n        int source = 0;\\n        Integer[] timeHold = new Integer[n];\\n        Arrays.fill(timeHold, Integer.MAX_VALUE);\\n\\n        Map<Integer,List<int[]>> graph = new HashMap();\\n        for(int[] edge : edges){\\n            int src = edge[0];\\n            int dst = edge[1];\\n            int time = edge[2];\\n            graph.putIfAbsent(src,new ArrayList());\\n            graph.putIfAbsent(dst,new ArrayList());\\n            graph.get(src).add(new int[]{dst,time});\\n            graph.get(dst).add(new int[]{src,time});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( (a, b) -> a[1] - b[1] ); //a[0] = city, a[1] = cost, a[2] = time\\n        pq.offer(new int[]{source, passingFees[source], 0});\\n        timeHold[0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int src = node[0];\\n            int fee = node[1];\\n            int time = node[2];\\n\\n            if(src == destination) // check whether destination reached ?\\n                return fee;\\n            \\n            for(int[] nei : graph.get(src)){\\n                \\n                int neiNode = nei[0];\\n                int neiTime = nei[1];\\n                                              \\n                if(time + neiTime > maxTime) // we cannot exceed maxTime, return .. \\n                    continue;\\n                \\n                if(time + neiTime < timeHold[neiNode]){\\n                    timeHold[neiNode] = time + neiTime; //we found lesser time update time Array and add this node to pq..\\n                    pq.add(new int[]{neiNode, fee + passingFees[neiNode], timeHold[neiNode]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360536,
                "title": "python3-modified-dijkstra",
                "content": "A dictionary timeTable keep track the minimum time spent reaching each city.\\nThe DIjkstra is based on totalFee. If one city has been already visited in the algorithm and the timespent is not shorter than the previous visit, the city is not considered anymore. \\n\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        destination = len(passingFees) - 1\\n        timeTable = {}\\n        graph = {}\\n        for e in edges:\\n            u = e[0]\\n            v = e[1]\\n            d = e[2]\\n            \\n            if u not in graph:\\n                graph[u] = [(v, d)]\\n            else:\\n                graph[u].append((v, d))\\n                \\n            if v not in graph:\\n                graph[v] = [(u, d)]\\n            else:\\n                graph[v].append((u, d))\\n                \\n        # print(graph)\\n        \\n        queue = [(passingFees[0], 0, 0)] # [(totalfee, city, timespent)...]\\n        \\n        while(queue):\\n            totalFee, city, timeSpent = heapq.heappop(queue)\\n            if timeSpent > maxTime:\\n                continue\\n            elif city == destination:\\n                return totalFee\\n            elif city in timeTable and timeSpent >= timeTable[city]:\\n                continue\\n            else:\\n                timeTable[city] = timeSpent\\n                for nextCity in graph[city]:\\n                    heapq.heappush(queue,(totalFee + passingFees[nextCity[0]], nextCity[0], timeSpent + nextCity[1]))\\n            \\n        return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        destination = len(passingFees) - 1\\n        timeTable = {}\\n        graph = {}\\n        for e in edges:\\n            u = e[0]\\n            v = e[1]\\n            d = e[2]\\n            \\n            if u not in graph:\\n                graph[u] = [(v, d)]\\n            else:\\n                graph[u].append((v, d))\\n                \\n            if v not in graph:\\n                graph[v] = [(u, d)]\\n            else:\\n                graph[v].append((u, d))\\n                \\n        # print(graph)\\n        \\n        queue = [(passingFees[0], 0, 0)] # [(totalfee, city, timespent)...]\\n        \\n        while(queue):\\n            totalFee, city, timeSpent = heapq.heappop(queue)\\n            if timeSpent > maxTime:\\n                continue\\n            elif city == destination:\\n                return totalFee\\n            elif city in timeTable and timeSpent >= timeTable[city]:\\n                continue\\n            else:\\n                timeTable[city] = timeSpent\\n                for nextCity in graph[city]:\\n                    heapq.heappush(queue,(totalFee + passingFees[nextCity[0]], nextCity[0], timeSpent + nextCity[1]))\\n            \\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357198,
                "title": "modified-dijkstra-s-readable-c",
                "content": "\\n```\\nclass Solution {\\n\\t//Edge represents that there is edge pointing to val and time to reach val is time\\n    struct Edge {\\n        int val, time;\\n        Edge(int val, int time) : val(val), time(time) {}\\n    };\\n\\t//Node stores value of node, cost & time to reach from source to current node\\n    struct Node {\\n        int cost, time, val;\\n        Node(int cost, int time, int val) : cost(cost), time(time), val(val) {}\\n    };\\n    struct Comp {\\n        bool operator()(Node& n1, Node& n2) {\\n            if(n1.cost == n2.cost)\\n                return n1.time > n2.time;\\n            return n1.cost > n2.cost;\\n        }\\n    };\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<Edge> adj[n];\\n        for(auto e: edges) {\\n            adj[e[0]].push_back(Edge(e[1], e[2]));\\n            adj[e[1]].push_back(Edge(e[0], e[2]));\\n        }\\n        vector<int> cost(n, INT_MAX), time(n, INT_MAX);\\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        priority_queue<Node, vector<Node>, Comp> pq;\\n        pq.push(Node(cost[0], 0, 0));\\n        while(!pq.empty()) {\\n            Node node = pq.top();\\n            pq.pop();\\n            for(Edge edge : adj[node.val]) {\\n                if(edge.time + node.time <= maxTime) {\\n                    int totCost = node.cost + passingFees[edge.val];\\n                    int totTime = edge.time + node.time;\\n\\t\\t\\t\\t\\t//if totalCost is lesser then we\\'ll push node in queue\\n                    if(cost[edge.val] > totCost) {\\n                        cost[edge.val] = totCost;\\n                        time[edge.val] = totTime;\\n                        pq.push(Node(totCost, totTime, edge.val));\\n                    } \\n\\t\\t\\t\\t\\t//else if totalCost is lesser then we\\'ll push node in queue\\n\\t\\t\\t\\t\\telse if(time[edge.val] > totTime) {\\n                        time[edge.val] = totTime;\\n                        pq.push(Node(totCost, totTime, edge.val));\\n                    }\\n                }\\n            }\\n        }\\n        return cost[n-1] == INT_MAX ? -1 : cost[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t//Edge represents that there is edge pointing to val and time to reach val is time\\n    struct Edge {\\n        int val, time;\\n        Edge(int val, int time) : val(val), time(time) {}\\n    };\\n\\t//Node stores value of node, cost & time to reach from source to current node\\n    struct Node {\\n        int cost, time, val;\\n        Node(int cost, int time, int val) : cost(cost), time(time), val(val) {}\\n    };\\n    struct Comp {\\n        bool operator()(Node& n1, Node& n2) {\\n            if(n1.cost == n2.cost)\\n                return n1.time > n2.time;\\n            return n1.cost > n2.cost;\\n        }\\n    };\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<Edge> adj[n];\\n        for(auto e: edges) {\\n            adj[e[0]].push_back(Edge(e[1], e[2]));\\n            adj[e[1]].push_back(Edge(e[0], e[2]));\\n        }\\n        vector<int> cost(n, INT_MAX), time(n, INT_MAX);\\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        priority_queue<Node, vector<Node>, Comp> pq;\\n        pq.push(Node(cost[0], 0, 0));\\n        while(!pq.empty()) {\\n            Node node = pq.top();\\n            pq.pop();\\n            for(Edge edge : adj[node.val]) {\\n                if(edge.time + node.time <= maxTime) {\\n                    int totCost = node.cost + passingFees[edge.val];\\n                    int totTime = edge.time + node.time;\\n\\t\\t\\t\\t\\t//if totalCost is lesser then we\\'ll push node in queue\\n                    if(cost[edge.val] > totCost) {\\n                        cost[edge.val] = totCost;\\n                        time[edge.val] = totTime;\\n                        pq.push(Node(totCost, totTime, edge.val));\\n                    } \\n\\t\\t\\t\\t\\t//else if totalCost is lesser then we\\'ll push node in queue\\n\\t\\t\\t\\t\\telse if(time[edge.val] > totTime) {\\n                        time[edge.val] = totTime;\\n                        pq.push(Node(totCost, totTime, edge.val));\\n                    }\\n                }\\n            }\\n        }\\n        return cost[n-1] == INT_MAX ? -1 : cost[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356966,
                "title": "c-recursive-solution-with-proper-comments-new-technique-of-using-unordered-map-to-optimize-cost",
                "content": "```\\n/**\\n * @author      : archit \\n * @GitHub      : archit-1997\\n * @email       : architsingh456@gmail.com\\n * @file        : minCostToReachDestinationInTime.cpp\\n * @created     : Friday Jul 23, 2021 13:17:57 IST\\n */\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define P pair<int,pair<int,int>>\\n\\nclass Solution {\\npublic:\\n\\nvector<vector<pair<int,int>>> constructGraph(vector<vector<int>>& edges,int n){\\n    vector<vector<pair<int,int>>> graph(n);\\n    for(auto e : edges){\\n        graph[e[0]].push_back({e[1],e[2]});\\n        graph[e[1]].push_back({e[0],e[2]});\\n    }\\n    return graph;\\n}\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>> graph=constructGraph(edges,n);\\n\\n        priority_queue<P,vector<P>,greater<P>> q;\\n\\n        //{passingFees,{nextNode,time}}\\n        q.push({passingFees[0],{0,0}});\\n\\n        unordered_map<int,int> vis;\\n\\n        int ans=0;\\n        while(!q.empty()){\\n            pair<int,pair<int,int>> t=q.top();\\n            q.pop();\\n\\n            int cost=t.first;\\n            int curNode=t.second.first,curTime=t.second.second;\\n\\n            //reached the last node ?\\n            if(curNode==(n-1))\\n                return cost;\\n\\n            //mark visited with current time\\n            vis[curNode]=curTime;\\n\\n            for(int i=0;i<graph[curNode].size();i++){\\n                int nextNode=graph[curNode][i].first;\\n                int nextTime=graph[curNode][i].second;\\n\\n                int time=curTime+nextTime;\\n\\n                //if curnode already visited and also with a smaller time\\n                if(vis.find(nextNode)!=vis.end() && vis[nextNode]<=time)\\n                    continue;\\n\\n                //we need to mark this node as visited\\n                vis[nextNode]=time;\\n\\n                //push in queue only if time <= totalTime\\n                if(time<=maxTime)\\n                    q.push({passingFees[nextNode]+cost,{nextNode,time}});\\n            }\\n\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @author      : archit \\n * @GitHub      : archit-1997\\n * @email       : architsingh456@gmail.com\\n * @file        : minCostToReachDestinationInTime.cpp\\n * @created     : Friday Jul 23, 2021 13:17:57 IST\\n */\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define P pair<int,pair<int,int>>\\n\\nclass Solution {\\npublic:\\n\\nvector<vector<pair<int,int>>> constructGraph(vector<vector<int>>& edges,int n){\\n    vector<vector<pair<int,int>>> graph(n);\\n    for(auto e : edges){\\n        graph[e[0]].push_back({e[1],e[2]});\\n        graph[e[1]].push_back({e[0],e[2]});\\n    }\\n    return graph;\\n}\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>> graph=constructGraph(edges,n);\\n\\n        priority_queue<P,vector<P>,greater<P>> q;\\n\\n        //{passingFees,{nextNode,time}}\\n        q.push({passingFees[0],{0,0}});\\n\\n        unordered_map<int,int> vis;\\n\\n        int ans=0;\\n        while(!q.empty()){\\n            pair<int,pair<int,int>> t=q.top();\\n            q.pop();\\n\\n            int cost=t.first;\\n            int curNode=t.second.first,curTime=t.second.second;\\n\\n            //reached the last node ?\\n            if(curNode==(n-1))\\n                return cost;\\n\\n            //mark visited with current time\\n            vis[curNode]=curTime;\\n\\n            for(int i=0;i<graph[curNode].size();i++){\\n                int nextNode=graph[curNode][i].first;\\n                int nextTime=graph[curNode][i].second;\\n\\n                int time=curTime+nextTime;\\n\\n                //if curnode already visited and also with a smaller time\\n                if(vis.find(nextNode)!=vis.end() && vis[nextNode]<=time)\\n                    continue;\\n\\n                //we need to mark this node as visited\\n                vis[nextNode]=time;\\n\\n                //push in queue only if time <= totalTime\\n                if(time<=maxTime)\\n                    q.push({passingFees[nextNode]+cost,{nextNode,time}});\\n            }\\n\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1339734,
                "title": "c-dijkstra-s-algo-priority-queue",
                "content": "```\\nvector<vector<int>> adj[1001];\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int V=passingFees.size();\\n        int E=edges.size();\\n        vector<int> cost(V,INT_MAX);\\n        vector<int> time(V,INT_MAX);\\n      \\n        \\n        for(auto e: edges){\\n            adj[e[0]].push_back({e[1],e[2],passingFees[e[1]]});\\n            adj[e[1]].push_back({e[0],e[2],passingFees[e[0]]});\\n        }\\n        cost[0] = passingFees[0];\\n        time[0]=0;\\n        int ans=dijkstra(0,V-1,maxTime,cost,time);\\n        if (ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n    int dijkstra(int src,int dst,int maxTime,vector<int> &cost,vector<int> &time){\\n        \\n        \\n        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>> minh;\\n        minh.push({cost[src],time[src],src});\\n        \\n        while(!minh.empty()){\\n            vector<int> temp=minh.top();\\n            minh.pop();\\n            \\n            int c=temp[0];\\n            int t=temp[1];\\n            int v=temp[2];\\n            \\n            for(auto X: adj[v]){\\n                if(t+X[1] <= maxTime){\\n                    if(cost[X[0]] > c + X[2]){\\n                        cost[X[0]]=c+X[2];\\n                        \\n                        time[X[0]]= t+ X[1];\\n                        minh.push({cost[X[0]],time[X[0]],X[0]});\\n                    }\\n                     if(time[X[0]]> t+ X[1]){\\n                        time[X[0]]=t+X[1];\\n                        minh.push({c+X[2],time[X[0]],X[0]});\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n\\nreturn cost[dst];\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> adj[1001];\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int V=passingFees.size();\\n        int E=edges.size();\\n        vector<int> cost(V,INT_MAX);\\n        vector<int> time(V,INT_MAX);\\n      \\n        \\n        for(auto e: edges){\\n            adj[e[0]].push_back({e[1],e[2],passingFees[e[1]]});\\n            adj[e[1]].push_back({e[0],e[2],passingFees[e[0]]});\\n        }\\n        cost[0] = passingFees[0];\\n        time[0]=0;\\n        int ans=dijkstra(0,V-1,maxTime,cost,time);\\n        if (ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n    int dijkstra(int src,int dst,int maxTime,vector<int> &cost,vector<int> &time){\\n        \\n        \\n        priority_queue<vector<int>,vector<vector<int>>, greater<vector<int>>> minh;\\n        minh.push({cost[src],time[src],src});\\n        \\n        while(!minh.empty()){\\n            vector<int> temp=minh.top();\\n            minh.pop();\\n            \\n            int c=temp[0];\\n            int t=temp[1];\\n            int v=temp[2];\\n            \\n            for(auto X: adj[v]){\\n                if(t+X[1] <= maxTime){\\n                    if(cost[X[0]] > c + X[2]){\\n                        cost[X[0]]=c+X[2];\\n                        \\n                        time[X[0]]= t+ X[1];\\n                        minh.push({cost[X[0]],time[X[0]],X[0]});\\n                    }\\n                     if(time[X[0]]> t+ X[1]){\\n                        time[X[0]]=t+X[1];\\n                        minh.push({c+X[2],time[X[0]],X[0]});\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n\\nreturn cost[dst];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338309,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>>vec(n);\\n        for(auto it:edges){\\n            vec[it[0]].emplace_back(it[1],it[2]);\\n            vec[it[1]].emplace_back(it[0],it[2]);\\n        }\\n        const int inf=(int)1e9+5;\\n        vector<vector<int>>dp(maxTime+1,vector<int>(n,inf));\\n        dp[0][0]=passingFees[0];\\n        for(int time=0;time<maxTime;time++){\\n            for(int node=0;node<n;node++){\\n                if(dp[time][node]>=inf){\\n                    continue;\\n                }\\n                for(auto[x,y]:vec[node]){\\n                    if(y+time<=maxTime){\\n                        dp[y+time][x]=min(dp[y+time][x],dp[time][node]+passingFees[x]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=inf;\\n        for(int i=0;i<=maxTime;i++){\\n            ans=min(ans,dp[i][n-1]);\\n        }\\n        return ans>=inf?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>>vec(n);\\n        for(auto it:edges){\\n            vec[it[0]].emplace_back(it[1],it[2]);\\n            vec[it[1]].emplace_back(it[0],it[2]);\\n        }\\n        const int inf=(int)1e9+5;\\n        vector<vector<int>>dp(maxTime+1,vector<int>(n,inf));\\n        dp[0][0]=passingFees[0];\\n        for(int time=0;time<maxTime;time++){\\n            for(int node=0;node<n;node++){\\n                if(dp[time][node]>=inf){\\n                    continue;\\n                }\\n                for(auto[x,y]:vec[node]){\\n                    if(y+time<=maxTime){\\n                        dp[y+time][x]=min(dp[y+time][x],dp[time][node]+passingFees[x]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=inf;\\n        for(int i=0;i<=maxTime;i++){\\n            ans=min(ans,dp[i][n-1]);\\n        }\\n        return ans>=inf?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335862,
                "title": "python-c-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        auto maxCost = accumulate(begin(passingFees), end(passingFees), 1);\\n        \\n        vector<vector<pair<int, int>>> g(n, vector<pair<int, int>>());\\n        for (auto e: edges) {\\n            g[e[1]].push_back({e[0], e[2]});\\n            g[e[0]].push_back({e[1], e[2]});\\n        }\\n        \\n        vector<int> minCostToDest(n, maxCost);\\n        minCostToDest[n-1]=passingFees[n-1];\\n        priority_queue<array<int, 2>, vector<array<int, 2>>, greater<array<int, 2>>> pq;\\n        pq.push({passingFees[n-1], n-1});\\n        vector<array<int, 2>> parent(n, {-1, -1});\\n        parent[n-1] = {n-1,0};\\n        \\n        while (pq.size() > 0) {\\n            auto [curCost, curCity] = pq.top(); pq.pop();\\n            if (curCost == minCostToDest[curCity]) {\\n                for (auto [nxtCity, dTime]: g[curCity]) {\\n                    auto nxtCost = curCost + passingFees[nxtCity];\\n                    if (nxtCost < minCostToDest[nxtCity]) {\\n                        parent[nxtCity] = {curCity, dTime};\\n                        minCostToDest[nxtCity] = nxtCost;\\n                        pq.push({nxtCost, nxtCity});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        if (parent[0][0] == -1) {\\n            return -1;\\n        }\\n        int minCostTime = 0;\\n        int curCity = 0;\\n        while (curCity != n - 1) {\\n            auto [nxtCity, dTime] = parent[curCity];\\n            minCostTime += dTime;\\n            curCity = nxtCity;\\n        }\\n        if (minCostTime <= maxTime) {\\n            return minCostToDest[0];\\n        }\\n        \\n        \\n        vector<int> minTimeToDest(n, maxTime + 1);\\n        pq.push({0, n - 1});\\n        minTimeToDest[n-1] = 0;\\n        while (pq.size() > 0) {\\n            auto [curTime, curCity] = pq.top(); pq.pop();\\n            if (curTime == minTimeToDest[curCity]) {\\n                for (auto [nxtCity, dTime]: g[curCity]) {\\n                    auto nxtTime = curTime + dTime;\\n                    if (nxtTime < minTimeToDest[nxtCity]) {\\n                        minTimeToDest[nxtCity] = nxtTime;\\n                        pq.push({nxtTime, nxtCity});\\n                    }\\n                }\\n            }\\n        }\\n        if (minTimeToDest[0] > maxTime) {\\n            return -1;\\n        }\\n        \\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq3;\\n        pq3.push({0, 0, passingFees[0]});\\n        int result = maxCost;\\n        while (pq3.size() > 0) {\\n            auto [curTime, curCity, curCost] = pq3.top(); pq3.pop();\\n            if (curCost < result) {\\n                if (curCity == n - 1) {\\n                    result = curCost;\\n                } else {\\n                    for (auto [nxtCity, dTime]: g[curCity]) {\\n                        if (curCost + minCostToDest[nxtCity] < result) {\\n                            auto nxtTime = curTime + dTime;\\n                            if (nxtTime + minTimeToDest[nxtCity] <= maxTime) {\\n                                pq3.push({nxtTime, nxtCity, curCost + passingFees[nxtCity]});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        if (result < maxCost) {\\n            return result;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        \\n        maxCost = sum(passingFees) + 1\\n        # build a dictionary\\n        g = [[] for _ in range(n)]\\n        for s, d, t in edges:\\n            g[s].append((d, t))\\n            g[d].append((s, t))\\n            \\n        # run Djikstra for minimal cost from every city to destination\\n        minCostToDest = [maxCost] * n\\n        pq = [(passingFees[-1], n - 1)]\\n        parent = [(-1, -1)] * n\\n        parent[-1] = n - 1\\n        minCostToDest[-1] = passingFees[-1]\\n        while pq:\\n            curCost, curCity = heappop(pq)\\n            if curCost == minCostToDest[curCity]:\\n                for nxtCity, dTime in g[curCity]:\\n                    nxtCost = curCost + passingFees[nxtCity]\\n                    if nxtCost < minCostToDest[nxtCity]:\\n                        parent[nxtCity] = (curCity, dTime)\\n                        minCostToDest[nxtCity] = nxtCost\\n                        heappush(pq, (nxtCost, nxtCity))\\n        # no path to destination from 0\\n        if parent[0][0] == -1:\\n            return -1\\n        minCostTime = 0\\n        curCity = 0\\n        # check if the min cost path is coming under the maxTime, this is our result then\\n        while curCity != n - 1:\\n            curCity, dTime = parent[curCity]\\n            minCostTime += dTime\\n        if minCostTime <= maxTime:\\n            return minCostToDest[0]\\n        \\n        # run Djikstra for the min time to n - 1 for every city\\n        minTimeToDest = [maxTime + 1] * n\\n        pq.append((0, n - 1))\\n        minTimeToDest[-1] = 0\\n        while pq:\\n            curTime, curCity = heappop(pq)\\n            if curTime == minTimeToDest[curCity]:\\n                for nxtCity, dTime in g[curCity]:\\n                    nxtTime = curTime + dTime\\n                    if nxtTime < minTimeToDest[nxtCity]:\\n                        minTimeToDest[nxtCity] = nxtTime\\n                        heappush(pq, (nxtTime, nxtCity))\\n\\n        # check if the min time is coming over limit, no solution if it is\\n        if minTimeToDest[0] > maxTime:\\n            return -1\\n        \\n        # now run \"unbound Djikstra\"\\n        # check every possible path, only cut those that are either overtime or over the found solution\\n        pq.append((0, 0, passingFees[0]))\\n        result = maxCost\\n        while pq:\\n            curTime, curCity, curCost = heappop(pq)\\n            if curCost < result:\\n                if curCity == n - 1:\\n                    result = curCost\\n                else:\\n                    for nxtCity, dTime in g[curCity]:\\n                        if curCost + minCostToDest[nxtCity] < result:\\n                            nxtTime = curTime + dTime\\n                            if nxtTime + minTimeToDest[nxtCity] <= maxTime:\\n                                heappush(pq, (nxtTime, nxtCity, curCost + passingFees[nxtCity]))\\n        if result < maxCost:\\n            return result\\n        else:\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        auto maxCost = accumulate(begin(passingFees), end(passingFees), 1);\\n        \\n        vector<vector<pair<int, int>>> g(n, vector<pair<int, int>>());\\n        for (auto e: edges) {\\n            g[e[1]].push_back({e[0], e[2]});\\n            g[e[0]].push_back({e[1], e[2]});\\n        }\\n        \\n        vector<int> minCostToDest(n, maxCost);\\n        minCostToDest[n-1]=passingFees[n-1];\\n        priority_queue<array<int, 2>, vector<array<int, 2>>, greater<array<int, 2>>> pq;\\n        pq.push({passingFees[n-1], n-1});\\n        vector<array<int, 2>> parent(n, {-1, -1});\\n        parent[n-1] = {n-1,0};\\n        \\n        while (pq.size() > 0) {\\n            auto [curCost, curCity] = pq.top(); pq.pop();\\n            if (curCost == minCostToDest[curCity]) {\\n                for (auto [nxtCity, dTime]: g[curCity]) {\\n                    auto nxtCost = curCost + passingFees[nxtCity];\\n                    if (nxtCost < minCostToDest[nxtCity]) {\\n                        parent[nxtCity] = {curCity, dTime};\\n                        minCostToDest[nxtCity] = nxtCost;\\n                        pq.push({nxtCost, nxtCity});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        if (parent[0][0] == -1) {\\n            return -1;\\n        }\\n        int minCostTime = 0;\\n        int curCity = 0;\\n        while (curCity != n - 1) {\\n            auto [nxtCity, dTime] = parent[curCity];\\n            minCostTime += dTime;\\n            curCity = nxtCity;\\n        }\\n        if (minCostTime <= maxTime) {\\n            return minCostToDest[0];\\n        }\\n        \\n        \\n        vector<int> minTimeToDest(n, maxTime + 1);\\n        pq.push({0, n - 1});\\n        minTimeToDest[n-1] = 0;\\n        while (pq.size() > 0) {\\n            auto [curTime, curCity] = pq.top(); pq.pop();\\n            if (curTime == minTimeToDest[curCity]) {\\n                for (auto [nxtCity, dTime]: g[curCity]) {\\n                    auto nxtTime = curTime + dTime;\\n                    if (nxtTime < minTimeToDest[nxtCity]) {\\n                        minTimeToDest[nxtCity] = nxtTime;\\n                        pq.push({nxtTime, nxtCity});\\n                    }\\n                }\\n            }\\n        }\\n        if (minTimeToDest[0] > maxTime) {\\n            return -1;\\n        }\\n        \\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> pq3;\\n        pq3.push({0, 0, passingFees[0]});\\n        int result = maxCost;\\n        while (pq3.size() > 0) {\\n            auto [curTime, curCity, curCost] = pq3.top(); pq3.pop();\\n            if (curCost < result) {\\n                if (curCity == n - 1) {\\n                    result = curCost;\\n                } else {\\n                    for (auto [nxtCity, dTime]: g[curCity]) {\\n                        if (curCost + minCostToDest[nxtCity] < result) {\\n                            auto nxtTime = curTime + dTime;\\n                            if (nxtTime + minTimeToDest[nxtCity] <= maxTime) {\\n                                pq3.push({nxtTime, nxtCity, curCost + passingFees[nxtCity]});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        if (result < maxCost) {\\n            return result;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        \\n        maxCost = sum(passingFees) + 1\\n        # build a dictionary\\n        g = [[] for _ in range(n)]\\n        for s, d, t in edges:\\n            g[s].append((d, t))\\n            g[d].append((s, t))\\n            \\n        # run Djikstra for minimal cost from every city to destination\\n        minCostToDest = [maxCost] * n\\n        pq = [(passingFees[-1], n - 1)]\\n        parent = [(-1, -1)] * n\\n        parent[-1] = n - 1\\n        minCostToDest[-1] = passingFees[-1]\\n        while pq:\\n            curCost, curCity = heappop(pq)\\n            if curCost == minCostToDest[curCity]:\\n                for nxtCity, dTime in g[curCity]:\\n                    nxtCost = curCost + passingFees[nxtCity]\\n                    if nxtCost < minCostToDest[nxtCity]:\\n                        parent[nxtCity] = (curCity, dTime)\\n                        minCostToDest[nxtCity] = nxtCost\\n                        heappush(pq, (nxtCost, nxtCity))\\n        # no path to destination from 0\\n        if parent[0][0] == -1:\\n            return -1\\n        minCostTime = 0\\n        curCity = 0\\n        # check if the min cost path is coming under the maxTime, this is our result then\\n        while curCity != n - 1:\\n            curCity, dTime = parent[curCity]\\n            minCostTime += dTime\\n        if minCostTime <= maxTime:\\n            return minCostToDest[0]\\n        \\n        # run Djikstra for the min time to n - 1 for every city\\n        minTimeToDest = [maxTime + 1] * n\\n        pq.append((0, n - 1))\\n        minTimeToDest[-1] = 0\\n        while pq:\\n            curTime, curCity = heappop(pq)\\n            if curTime == minTimeToDest[curCity]:\\n                for nxtCity, dTime in g[curCity]:\\n                    nxtTime = curTime + dTime\\n                    if nxtTime < minTimeToDest[nxtCity]:\\n                        minTimeToDest[nxtCity] = nxtTime\\n                        heappush(pq, (nxtTime, nxtCity))\\n\\n        # check if the min time is coming over limit, no solution if it is\\n        if minTimeToDest[0] > maxTime:\\n            return -1\\n        \\n        # now run \"unbound Djikstra\"\\n        # check every possible path, only cut those that are either overtime or over the found solution\\n        pq.append((0, 0, passingFees[0]))\\n        result = maxCost\\n        while pq:\\n            curTime, curCity, curCost = heappop(pq)\\n            if curCost < result:\\n                if curCity == n - 1:\\n                    result = curCost\\n                else:\\n                    for nxtCity, dTime in g[curCity]:\\n                        if curCost + minCostToDest[nxtCity] < result:\\n                            nxtTime = curTime + dTime\\n                            if nxtTime + minTimeToDest[nxtCity] <= maxTime:\\n                                heappush(pq, (nxtTime, nxtCity, curCost + passingFees[nxtCity]))\\n        if result < maxCost:\\n            return result\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335256,
                "title": "c-128ms-93-dijkstra",
                "content": "Runtime: 128 ms, faster than 92.75% of C++ online submissions for Minimum Cost to Reach Destination in Time.\\nMemory Usage: 25.1 MB, less than 94.35% of C++ online submissions for Minimum Cost to Reach Destination in Time.\\n```\\nclass Solution {\\npublic:\\n  int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n    int n = passingFees.size(), CITY = n - 1;\\n    vector<vector<pair<int,int> > > graph(n);                        //city, time\\n    vector<int> limtime(n, INT_MAX);\\n    \\n      \\n    for(auto &i: edges ){\\n      graph[i[0]].push_back({ i[1], i[2] });\\n      graph[i[1]].push_back({ i[0], i[2] });\\n    }\\n     \\n    priority_queue< tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>> > pq;  //pay, time, city\\n    pq.push({0,0,0});\\n    \\n    while(!pq.empty()){\\n      auto[pay, time, city] = pq.top(); pq.pop();                                                             \\n      if(city == CITY) return pay + passingFees[0]; \\n        \\n      limtime[city] = time;\\n        \\n      for(auto &next: graph[city]){\\n        int nexttime = time + next.second;\\n        if( nexttime < limtime[next.first] ){\\n          limtime[next.first] = nexttime;\\n          if(nexttime <= maxTime) pq.push({ pay + passingFees[next.first], nexttime, next.first });\\n        }\\n      }\\n    }\\n    \\n     return -1;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n    int n = passingFees.size(), CITY = n - 1;\\n    vector<vector<pair<int,int> > > graph(n);                        //city, time\\n    vector<int> limtime(n, INT_MAX);\\n    \\n      \\n    for(auto &i: edges ){\\n      graph[i[0]].push_back({ i[1], i[2] });\\n      graph[i[1]].push_back({ i[0], i[2] });\\n    }\\n     \\n    priority_queue< tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>> > pq;  //pay, time, city\\n    pq.push({0,0,0});\\n    \\n    while(!pq.empty()){\\n      auto[pay, time, city] = pq.top(); pq.pop();                                                             \\n      if(city == CITY) return pay + passingFees[0]; \\n        \\n      limtime[city] = time;\\n        \\n      for(auto &next: graph[city]){\\n        int nexttime = time + next.second;\\n        if( nexttime < limtime[next.first] ){\\n          limtime[next.first] = nexttime;\\n          if(nexttime <= maxTime) pq.push({ pay + passingFees[next.first], nexttime, next.first });\\n        }\\n      }\\n    }\\n    \\n     return -1;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332005,
                "title": "java-dijkstras-100-faster-100-memory",
                "content": "```\\n\\tpublic int minCost(int maxTime, int[][] edges, int[] pf) {\\n        int n= pf.length;\\n        //adjacency matrix for time\\n        int[][] adj= new int[n][n];\\n        for(int i=0; i<edges.length; i++){\\n            int v1= edges[i][0], v2= edges[i][1], val= edges[i][2];\\n            if(adj[v1][v2] == 0 || adj[v1][v2] > val){\\n                adj[v1][v2]= val;\\n                adj[v2][v1]= val;\\n            }\\n        }\\n        // map is graph of connected nodes\\n        Map<Integer,List<Integer>> map= new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            map.put(i, new ArrayList<>());\\n            for(int j=0; j<n; j++){\\n                if(adj[i][j] == 0) continue;\\n                map.get(i).add(j);\\n            }\\n        }\\n        int[] minTime= new int[n];   \\n        \\n        //visited array, dont visit again if cost is greater than previous visited cost\\n        Arrays.fill(minTime,Integer.MAX_VALUE);\\n        \\n        //Dijkstras w.r.t cost because we want min cost and if time becomes > maxTime we will stop\\n        //exploring that path\\n        Queue<int[]> minHeap= new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        minHeap.add(new int[]{0,pf[0],0});\\n        while(!minHeap.isEmpty()){\\n            int[] curr= minHeap.poll();\\n            if(curr[2] > maxTime || curr[2] >= minTime[curr[0]]) continue;\\n            if(curr[0] == n-1) return curr[1];\\n            minTime[curr[0]]= curr[2];              //visit curr node with least possible time\\n            for(int neigh : map.get(curr[0])){\\n                int time= curr[2] + adj[curr[0]][neigh];\\n                int cost= curr[1] + pf[neigh];\\n                minHeap.add(new int[]{neigh,cost,time});\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minCost(int maxTime, int[][] edges, int[] pf) {\\n        int n= pf.length;\\n        //adjacency matrix for time\\n        int[][] adj= new int[n][n];\\n        for(int i=0; i<edges.length; i++){\\n            int v1= edges[i][0], v2= edges[i][1], val= edges[i][2];\\n            if(adj[v1][v2] == 0 || adj[v1][v2] > val){\\n                adj[v1][v2]= val;\\n                adj[v2][v1]= val;\\n            }\\n        }\\n        // map is graph of connected nodes\\n        Map<Integer,List<Integer>> map= new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            map.put(i, new ArrayList<>());\\n            for(int j=0; j<n; j++){\\n                if(adj[i][j] == 0) continue;\\n                map.get(i).add(j);\\n            }\\n        }\\n        int[] minTime= new int[n];   \\n        \\n        //visited array, dont visit again if cost is greater than previous visited cost\\n        Arrays.fill(minTime,Integer.MAX_VALUE);\\n        \\n        //Dijkstras w.r.t cost because we want min cost and if time becomes > maxTime we will stop\\n        //exploring that path\\n        Queue<int[]> minHeap= new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        minHeap.add(new int[]{0,pf[0],0});\\n        while(!minHeap.isEmpty()){\\n            int[] curr= minHeap.poll();\\n            if(curr[2] > maxTime || curr[2] >= minTime[curr[0]]) continue;\\n            if(curr[0] == n-1) return curr[1];\\n            minTime[curr[0]]= curr[2];              //visit curr node with least possible time\\n            for(int neigh : map.get(curr[0])){\\n                int time= curr[2] + adj[curr[0]][neigh];\\n                int cost= curr[1] + pf[neigh];\\n                minHeap.add(new int[]{neigh,cost,time});\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1331729,
                "title": "my-java-solution-using-djikstras-algorithm",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int length = passingFees.length;\\n        List<int[]>[] graph = buildGraph(edges, length);\\n        int [] minimumTime = new int [length];\\n        Arrays.fill(minimumTime, Integer.MAX_VALUE);\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n        pq.add(new int [] {0, passingFees[0], 0});\\n        // source, passingfee for source, totaltime\\n        int time = 0;\\n        int score = 0;\\n        while (!pq.isEmpty()) {\\n            int [] current = pq.poll();\\n            if (current[2] >= minimumTime[current[0]])\\n                continue;\\n            minimumTime[current[0]] = current[2];\\n            if (current[0] == length - 1)\\n                return current[1];\\n            for (int [] nextChild : graph[current[0]]) {\\n                time = current[2] + nextChild[1];\\n                score = current[1] + passingFees[nextChild[0]];\\n                if (time > maxTime)\\n                    continue;\\n                if (time > minimumTime[nextChild[0]])\\n                    continue;\\n                pq.add(new int [] {nextChild[0], score, time});\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public List<int[]>[] buildGraph(int [][] edges, int length) {\\n        List<int[]> [] graph = new ArrayList[length];\\n        for (int i=0; i<length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int [] edge : edges) {\\n            graph[edge[0]].add(new int [] {edge[1], edge[2]});\\n            graph[edge[1]].add(new int [] {edge[0], edge[2]});\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int length = passingFees.length;\\n        List<int[]>[] graph = buildGraph(edges, length);\\n        int [] minimumTime = new int [length];\\n        Arrays.fill(minimumTime, Integer.MAX_VALUE);\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n        pq.add(new int [] {0, passingFees[0], 0});\\n        // source, passingfee for source, totaltime\\n        int time = 0;\\n        int score = 0;\\n        while (!pq.isEmpty()) {\\n            int [] current = pq.poll();\\n            if (current[2] >= minimumTime[current[0]])\\n                continue;\\n            minimumTime[current[0]] = current[2];\\n            if (current[0] == length - 1)\\n                return current[1];\\n            for (int [] nextChild : graph[current[0]]) {\\n                time = current[2] + nextChild[1];\\n                score = current[1] + passingFees[nextChild[0]];\\n                if (time > maxTime)\\n                    continue;\\n                if (time > minimumTime[nextChild[0]])\\n                    continue;\\n                pq.add(new int [] {nextChild[0], score, time});\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public List<int[]>[] buildGraph(int [][] edges, int length) {\\n        List<int[]> [] graph = new ArrayList[length];\\n        for (int i=0; i<length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int [] edge : edges) {\\n            graph[edge[0]].add(new int [] {edge[1], edge[2]});\\n            graph[edge[1]].add(new int [] {edge[0], edge[2]});\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331675,
                "title": "c-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n        \\n        int n=fees.size();\\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        vector<vector<int>> dp(maxTime+1,vector<int>(n,INT_MAX));\\n        dp[0][0]=fees[0];\\n        \\n        for(int i=0;i<=maxTime;i++){\\n            for(int j=0;j<n;j++){\\n                int currFees=dp[i][j];\\n                if(currFees==INT_MAX){\\n                    continue;\\n                }\\n                for(auto node:graph[j]){\\n                    int next=node.first;\\n                    int time=i+node.second;\\n                    if(time<=maxTime){\\n                        dp[time][next]=min(dp[time][next],fees[next]+currFees);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int t=0;t<=maxTime;t++){\\n            ans=min(ans,dp[t][n-1]);\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n        \\n        int n=fees.size();\\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        vector<vector<int>> dp(maxTime+1,vector<int>(n,INT_MAX));\\n        dp[0][0]=fees[0];\\n        \\n        for(int i=0;i<=maxTime;i++){\\n            for(int j=0;j<n;j++){\\n                int currFees=dp[i][j];\\n                if(currFees==INT_MAX){\\n                    continue;\\n                }\\n                for(auto node:graph[j]){\\n                    int next=node.first;\\n                    int time=i+node.second;\\n                    if(time<=maxTime){\\n                        dp[time][next]=min(dp[time][next],fees[next]+currFees);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int t=0;t<=maxTime;t++){\\n            ans=min(ans,dp[t][n-1]);\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331267,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int helper(int v,int time ,vector<unordered_map<int,int>> &graph ,vector<vector<int>>&dp , vector<int>& fees ){\\n        if(v == n-1)\\n               return fees[n-1];\\n        if(dp[v][time]!=-1)\\n            return dp[v][time];\\n        int ans = INT_MAX;\\n        for(auto &g: graph[v]){\\n            if(time-g.second>=0){\\n                int cost = helper(g.first,time-g.second, graph,dp,fees);\\n                ans = min(ans,cost);\\n            }\\n        }\\n        return dp[v][time] = ans!=INT_MAX ? ans + fees[v] : INT_MAX;\\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n = passingFees.size(); //no of vertices\\n        vector<vector<int>> dp(n, vector<int>(maxTime+1 , -1));\\n        //you have to go from 0 to n-1 within maxTime by spending the minimum amount of money. \\n        \\n        vector<unordered_map<int,int>> graph(n);\\n        //Important point is to note that there may be multiple roads of differing travel times connecting the same two cities. So take the route with the minimum cost. \\n        for(auto & e: edges){\\n            if( graph[e[0]][e[1]]==0)\\n                graph[e[0]][e[1]] = e[2];\\n            else \\n                 graph[e[0]][e[1]] = min( graph[e[0]][e[1]] , e[2]);\\n            \\n            if(graph[e[1]][e[0]] == 0)                \\n                graph[e[1]][e[0]] = e[2];\\n            else \\n                graph[e[1]][e[0]] = min(graph[e[1]][e[0]] , e[2]);\\n        }\\n        int ans =  helper(0,maxTime,graph,dp,passingFees);                    \\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int helper(int v,int time ,vector<unordered_map<int,int>> &graph ,vector<vector<int>>&dp , vector<int>& fees ){\\n        if(v == n-1)\\n               return fees[n-1];\\n        if(dp[v][time]!=-1)\\n            return dp[v][time];\\n        int ans = INT_MAX;\\n        for(auto &g: graph[v]){\\n            if(time-g.second>=0){\\n                int cost = helper(g.first,time-g.second, graph,dp,fees);\\n                ans = min(ans,cost);\\n            }\\n        }\\n        return dp[v][time] = ans!=INT_MAX ? ans + fees[v] : INT_MAX;\\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n = passingFees.size(); //no of vertices\\n        vector<vector<int>> dp(n, vector<int>(maxTime+1 , -1));\\n        //you have to go from 0 to n-1 within maxTime by spending the minimum amount of money. \\n        \\n        vector<unordered_map<int,int>> graph(n);\\n        //Important point is to note that there may be multiple roads of differing travel times connecting the same two cities. So take the route with the minimum cost. \\n        for(auto & e: edges){\\n            if( graph[e[0]][e[1]]==0)\\n                graph[e[0]][e[1]] = e[2];\\n            else \\n                 graph[e[0]][e[1]] = min( graph[e[0]][e[1]] , e[2]);\\n            \\n            if(graph[e[1]][e[0]] == 0)                \\n                graph[e[1]][e[0]] = e[2];\\n            else \\n                graph[e[1]][e[0]] = min(graph[e[1]][e[0]] , e[2]);\\n        }\\n        int ans =  helper(0,maxTime,graph,dp,passingFees);                    \\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330810,
                "title": "python-c-dfs-with-memoization-and-explanation",
                "content": "**Point:**\\nIn between u and v there\\'s no point in taking the edge that takes longer time. Since the passingFee depends on only u and v and not the edge. So take the edge that takes minimum time.\\nRest is memoization on u and time. `dp[u][time]` represents minimum cost to reach edge `n-1` from vertex `u` with time `time` left\\n\\n### Python\\n```\\nimport collections\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        graph = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\\'inf\\')))\\n        for u, v, w in edges:\\n            graph[u][v] = min(graph[u][v], w)\\n            graph[v][u] = min(graph[v][u], w)\\n        \\n        n = len(passingFees)\\n        states = [[-1]*(maxTime+1) for _ in range(n)]\\n        def helper(u, time):\\n            if u==n-1:\\n                return passingFees[u]\\n            if states[u][time] != -1:\\n                return states[u][time]\\n            ans = float(\"inf\")\\n            for v in graph[u].keys():\\n                if time-graph[u][v]>=0:\\n                    val = helper(v, time-graph[u][v])\\n                    ans = min(ans, val)\\n            states[u][time] = ans+passingFees[u]\\n            return states[u][time]\\n        ans = helper(0, maxTime)\\n        if ans > 10000000:\\n            return -1\\n        return ans\\n```\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int helper(int u, int time, vector<vector<int>>& dp, vector<unordered_map<int, int>>& graph, vector<int>& fee){\\n        if(u==n-1){\\n            return fee[u];\\n        }\\n        if(dp[u][time] != -1){\\n            return dp[u][time];\\n        }\\n        int ans = INT_MAX-1000;\\n        for(auto &e: graph[u]){\\n            if(time-e.second>=0){\\n                int v = helper(e.first, time-e.second, dp, graph, fee);\\n                ans = min(v, ans);\\n            }\\n        }\\n        return dp[u][time] = ans+fee[u];\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n = passingFees.size();\\n        vector<vector<int>> dp(n, vector<int>(maxTime+1, -1));\\n        vector<unordered_map<int, int>> graph(n);\\n        for(auto &e: edges){\\n            if(graph[e[0]][e[1]]==0)\\n                graph[e[0]][e[1]] = e[2];\\n            else\\n                graph[e[0]][e[1]] = min(e[2], graph[e[0]][e[1]]);\\n            if(graph[e[1]][e[0]]==0)\\n                graph[e[1]][e[0]] = e[2];\\n            else\\n                graph[e[1]][e[0]] = min(e[2], graph[e[1]][e[0]]);\\n        }\\n        int ans = helper(0, maxTime, dp, graph, passingFees);\\n        return (ans>10000000)?-1:ans;\\n    }\\n};",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        graph = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\\'inf\\')))\\n        for u, v, w in edges:\\n            graph[u][v] = min(graph[u][v], w)\\n            graph[v][u] = min(graph[v][u], w)\\n        \\n        n = len(passingFees)\\n        states = [[-1]*(maxTime+1) for _ in range(n)]\\n        def helper(u, time):\\n            if u==n-1:\\n                return passingFees[u]\\n            if states[u][time] != -1:\\n                return states[u][time]\\n            ans = float(\"inf\")\\n            for v in graph[u].keys():\\n                if time-graph[u][v]>=0:\\n                    val = helper(v, time-graph[u][v])\\n                    ans = min(ans, val)\\n            states[u][time] = ans+passingFees[u]\\n            return states[u][time]\\n        ans = helper(0, maxTime)\\n        if ans > 10000000:\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330519,
                "title": "java-100-faster-space-time-dijkstra",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int[] time = new int[passingFees.length];\\n        Arrays.fill(time, Integer.MAX_VALUE);\\n        time[0] = 0;\\n        \\n        Map<Integer, List<List<Integer>>> edgesMap = new HashMap();\\n        \\n        for(int i = 0 ; i < edges.length ; i++){\\n            if(!edgesMap.containsKey(edges[i][0]))\\n                edgesMap.put(edges[i][0], new ArrayList());\\n            if(!edgesMap.containsKey(edges[i][1]))\\n                edgesMap.put(edges[i][1], new ArrayList());\\n            \\n            edgesMap.get(edges[i][0]).add(Arrays.asList(edges[i][1], edges[i][2]));\\n            edgesMap.get(edges[i][1]).add(Arrays.asList(edges[i][0], edges[i][2]));\\n        }\\n        \\n        Comparator<List<Integer>> cmp = (a,b) -> a.get(1) - b.get(1);\\n        PriorityQueue<List<Integer>> pq = new PriorityQueue(cmp);\\n        pq.add(Arrays.asList(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()){\\n            List<Integer> node = pq.poll();\\n            if(node.get(0) == passingFees.length - 1)\\n                return node.get(1);\\n            \\n            List<List<Integer>> neighbours = edgesMap.get(node.get(0));\\n            \\n            for(int i = 0 ; i < neighbours.size() ; i++){\\n                List<Integer> list = neighbours.get(i);\\n                int timeToReach = node.get(2) + list.get(1);\\n                \\n                if(timeToReach > maxTime)\\n                    continue;\\n            \\n                if(time[list.get(0)] > timeToReach){\\n                    time[list.get(0)] = timeToReach;\\n                    int cost = node.get(1) + passingFees[list.get(0)];\\n                    pq.add(Arrays.asList(list.get(0),cost,timeToReach));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int[] time = new int[passingFees.length];\\n        Arrays.fill(time, Integer.MAX_VALUE);\\n        time[0] = 0;\\n        \\n        Map<Integer, List<List<Integer>>> edgesMap = new HashMap();\\n        \\n        for(int i = 0 ; i < edges.length ; i++){\\n            if(!edgesMap.containsKey(edges[i][0]))\\n                edgesMap.put(edges[i][0], new ArrayList());\\n            if(!edgesMap.containsKey(edges[i][1]))\\n                edgesMap.put(edges[i][1], new ArrayList());\\n            \\n            edgesMap.get(edges[i][0]).add(Arrays.asList(edges[i][1], edges[i][2]));\\n            edgesMap.get(edges[i][1]).add(Arrays.asList(edges[i][0], edges[i][2]));\\n        }\\n        \\n        Comparator<List<Integer>> cmp = (a,b) -> a.get(1) - b.get(1);\\n        PriorityQueue<List<Integer>> pq = new PriorityQueue(cmp);\\n        pq.add(Arrays.asList(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()){\\n            List<Integer> node = pq.poll();\\n            if(node.get(0) == passingFees.length - 1)\\n                return node.get(1);\\n            \\n            List<List<Integer>> neighbours = edgesMap.get(node.get(0));\\n            \\n            for(int i = 0 ; i < neighbours.size() ; i++){\\n                List<Integer> list = neighbours.get(i);\\n                int timeToReach = node.get(2) + list.get(1);\\n                \\n                if(timeToReach > maxTime)\\n                    continue;\\n            \\n                if(time[list.get(0)] > timeToReach){\\n                    time[list.get(0)] = timeToReach;\\n                    int cost = node.get(1) + passingFees[list.get(0)];\\n                    pq.add(Arrays.asList(list.get(0),cost,timeToReach));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330453,
                "title": "no-dijkstra-dfs-c-beginner-city-travel",
                "content": "Many posts use Dijkstra, I look to explore dfs with memoization in this post\\n\\n**Algorithm**\\n1. Bulid the graph. Keep only minimum weights edges between two cities.\\n2. Start dfs from city 0 with maxTime remaining.\\n3. From a city ```u``` travel to all cities ```v``` using dfs if time does not run out (i.e time does not go below 0). Choose the city ```v ``` which takes minimum fees.\\n4. If you reach the final city return the fee for final city as the answer.\\n6. We memoize on fees using ```city number``` and ```time```.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\t//  {key = city u, value = {key = city v, value = time required to travel from city u to v} }\\n    vector<unordered_map<int, int>> graph;\\n    vector<vector<int>>dp;\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        n = fee.size();\\n        dp = vector<vector<int>>(n, vector<int>(maxTime+1, -1));\\n        graph = vector<unordered_map<int, int>>(n);\\n        // build the graph, keep weights which are minimum if multiple paths are present between same pair of nodes\\n        for(auto &e : edges){\\n            if(graph[e[0]].count(e[1]) == 0) graph[e[0]][e[1]] = e[2];\\n            else graph[e[0]][e[1]] = min(graph[e[0]][e[1]], e[2]);\\n            if(graph[e[1]].count(e[0]) == 0) graph[e[1]][e[0]] = e[2];\\n            else graph[e[1]][e[0]] = min(graph[e[1]][e[0]], e[2]);\\n        }\\n        int ans = dfs(fee, 0, maxTime);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    \\n    int dfs(vector<int>& fee, int u, int time){\\n        if(u == n-1) return fee[u];\\n        if(dp[u][time] != -1) return dp[u][time];\\n        \\n        int ans = INT_MAX;\\n        for(auto &e : graph[u]){\\n            int v = e.first;\\n            int vtime = e.second;\\n            if(time - vtime >= 0){\\n                int val = dfs(fee, v, time-vtime);\\n                if(val != INT_MAX){\\n                    ans = min(ans, fee[u] + val);\\n                }\\n            }\\n        }\\n        return dp[u][time] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```u```\n```v```\n```v ```\n```city number```\n```time```\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\t//  {key = city u, value = {key = city v, value = time required to travel from city u to v} }\\n    vector<unordered_map<int, int>> graph;\\n    vector<vector<int>>dp;\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        n = fee.size();\\n        dp = vector<vector<int>>(n, vector<int>(maxTime+1, -1));\\n        graph = vector<unordered_map<int, int>>(n);\\n        // build the graph, keep weights which are minimum if multiple paths are present between same pair of nodes\\n        for(auto &e : edges){\\n            if(graph[e[0]].count(e[1]) == 0) graph[e[0]][e[1]] = e[2];\\n            else graph[e[0]][e[1]] = min(graph[e[0]][e[1]], e[2]);\\n            if(graph[e[1]].count(e[0]) == 0) graph[e[1]][e[0]] = e[2];\\n            else graph[e[1]][e[0]] = min(graph[e[1]][e[0]], e[2]);\\n        }\\n        int ans = dfs(fee, 0, maxTime);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    \\n    int dfs(vector<int>& fee, int u, int time){\\n        if(u == n-1) return fee[u];\\n        if(dp[u][time] != -1) return dp[u][time];\\n        \\n        int ans = INT_MAX;\\n        for(auto &e : graph[u]){\\n            int v = e.first;\\n            int vtime = e.second;\\n            if(time - vtime >= 0){\\n                int val = dfs(fee, v, time-vtime);\\n                if(val != INT_MAX){\\n                    ans = min(ans, fee[u] + val);\\n                }\\n            }\\n        }\\n        return dp[u][time] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329610,
                "title": "c-dijkstra-modification",
                "content": "priority_queue alias heap will take care of minCost like we usaully do in Dijkstra.\\nkey point is time. \\n**push a node again to heap if u can reach it in less time than before**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    struct myComp {\\n      bool operator()(vector<int>& a,vector<int> &b){\\n          return a[1] > b[1];\\n      }\\n    };\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& p) {\\n        \\n     priority_queue<vector<int>,vector<vector<int>>,myComp> pq;\\n     pq.push({0,p[0],0});\\n     int n = p.size();\\n        \\n     vector<vector<pair<int,int>>> graph(n);\\n     for(auto it : edges){\\n         graph[it[0]].push_back({it[1],it[2]});\\n         graph[it[1]].push_back({it[0],it[2]});\\n     }\\n     vector<int> visited(n,0);\\n     \\n     while(!pq.empty()){\\n         vector<int> curr = pq.top();\\n         pq.pop();\\n         if(curr[2] > maxTime){\\n             continue;\\n         }\\n         if(curr[0] == n-1){\\n             return curr[1];\\n         }\\n        \\n         for(auto it : graph[curr[0]]){\\n             if(visited[it.first] && visited[it.first] <= it.second+curr[2]){\\n                 continue;\\n             }\\n             visited[it.first] = it.second+curr[2];\\n             if(it.second+curr[2] <= maxTime){\\n                 pq.push({it.first,curr[1]+p[it.first],curr[2]+it.second});\\n             }\\n         }\\n         \\n     }\\n      \\n        return  -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct myComp {\\n      bool operator()(vector<int>& a,vector<int> &b){\\n          return a[1] > b[1];\\n      }\\n    };\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& p) {\\n        \\n     priority_queue<vector<int>,vector<vector<int>>,myComp> pq;\\n     pq.push({0,p[0],0});\\n     int n = p.size();\\n        \\n     vector<vector<pair<int,int>>> graph(n);\\n     for(auto it : edges){\\n         graph[it[0]].push_back({it[1],it[2]});\\n         graph[it[1]].push_back({it[0],it[2]});\\n     }\\n     vector<int> visited(n,0);\\n     \\n     while(!pq.empty()){\\n         vector<int> curr = pq.top();\\n         pq.pop();\\n         if(curr[2] > maxTime){\\n             continue;\\n         }\\n         if(curr[0] == n-1){\\n             return curr[1];\\n         }\\n        \\n         for(auto it : graph[curr[0]]){\\n             if(visited[it.first] && visited[it.first] <= it.second+curr[2]){\\n                 continue;\\n             }\\n             visited[it.first] = it.second+curr[2];\\n             if(it.second+curr[2] <= maxTime){\\n                 pq.push({it.first,curr[1]+p[it.first],curr[2]+it.second});\\n             }\\n         }\\n         \\n     }\\n      \\n        return  -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329306,
                "title": "python-modified-dijkstra-hybrid-spfa",
                "content": "This is sort of like Dijkstra on fees, with times \"along for the ride\". Typically, Dijkstra stores the result for node u as it pops the next item off the min heap, and then never returns to the same node. In this case, there are three changes:\\n\\n1. We only care about the shortest edge between two vertices in the graph, so when building the graph always take the min weight edge.\\n2. Normally, Dijkstra only adds a neighbor v of the current node u to the queue if u hasn\\'t been processed before (this is also why Dijkstra can\\'t handle negative edge weights). However, in our case we have two changes: first, we re-process the node u if the new time is an improvement over the existing time; second, we only add a neighbor if its new_time is within the time constraint.\\n3. Normally, Dijkstra is SSSP and we would need to store intermediate fee values in something like a dictionary. However, this is shortest path between two nodes. Hence, we can use the heap to store our result (which will be the popped fee when u == n - 1).\\n\\nThe algorithm we end up with feels like a hybrid between Dijkstra and SPFA (shortest path faster algorithm, a modified Bellman-Ford). It\\'s like Dijkstra in that we\\'re using a heap (and adding an early exit condition because we don\\'t care about all destinations). But it\\'s like SPFA in that we only add vertices to the heap if they can contribute to the solution (which means new_time <= maxTime for this problem).\\n\\n```py\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], fees: List[int]) -> int:\\n        n = len(fees)\\n        \\n        g = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\\'inf\\')))\\n        for u, v, w in edges:\\n            g[u][v] = min(g[u][v], w)\\n            g[v][u] = min(g[v][u], w)\\n        \\n        times = {}\\n        \\n        h = [(fees[0], 0, 0)]\\n        while h:\\n            fee, time, u = heapq.heappop(h)\\n\\n            if u == n - 1:\\n                return fee\\n            \\n            if u not in times or time < times[u]:\\n                times[u] = time\\n                for v in g[u]:\\n                    new_time = time + g[u][v]\\n                    if new_time <= maxTime:\\n                        heapq.heappush(h, (fee + fees[v], new_time, v))\\n        \\n        return -1\\n```\\n\\nNow, let\\'s look at the time and space complexity. Typically, min-heap Dijkstra has a time complexity of O(E + V log V), because we process each edge at most twice and each vertex at most once (where V log V comes from popping V vertices off the heap). And space complexity of O(V + E) (the max size of the heap), which becomes O(E) for connected graphs\\n\\nThe time and space complexity of this problem are a little trickier to calculate. Intuitively, it feels psuedo-polynomial because the number of times we relax an edge depends on maxTime (the larger maxTime, the more times we can potentially relax an edge). \\n\\nI\\'d like to see some others weigh in, but my thoughts are:\\n\\nGiven that edge weights are at least 1, we can process each vertex O(maxTime) times. This is because you can have simple paths (paths with no repeated edges) of length up to maxTime. So we could process a vertex for a path of length 1 and weight maxTime with fee x, then a path of length 2 and weight maxTime - 1 with fee x, etc. Each time we process the vertex, we put it on the heap. So it seems the heap can end up as O(E * maxSize) size and the time complexity can become O(E * maxTime + (V * maxTime) * log(V * maxTime)).\\n\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], fees: List[int]) -> int:\\n        n = len(fees)\\n        \\n        g = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\\'inf\\')))\\n        for u, v, w in edges:\\n            g[u][v] = min(g[u][v], w)\\n            g[v][u] = min(g[v][u], w)\\n        \\n        times = {}\\n        \\n        h = [(fees[0], 0, 0)]\\n        while h:\\n            fee, time, u = heapq.heappop(h)\\n\\n            if u == n - 1:\\n                return fee\\n            \\n            if u not in times or time < times[u]:\\n                times[u] = time\\n                for v in g[u]:\\n                    new_time = time + g[u][v]\\n                    if new_time <= maxTime:\\n                        heapq.heappush(h, (fee + fees[v], new_time, v))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329236,
                "title": "c-o-maxtime-e-v-dynamic-programming",
                "content": "The solution is based on the winner\\'s answer.\\nThe d[i, j] state is min fee required to reach node i in time j. The minimum value to reach last node is required answer.\\n\\n```csharp\\npublic int MinCost(int maxTime, int[][] edges, int[] passingFees)\\n{\\n\\tint n = passingFees.Length;\\n\\tDictionary<int, List<(int index, int cost)>> graph = new Dictionary<int, List<(int, int)>>();\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tgraph[i] = new List<(int, int)>();\\n\\t}\\n\\n\\tforeach (var edge in edges)\\n\\t{\\n\\t\\tint u = edge[0], v = edge[1], c = edge[2];\\n\\t\\tgraph[u].Add((v, c));\\n\\t\\tgraph[v].Add((u, c));\\n\\t}\\n\\n\\tint result = int.MaxValue;\\n\\tint[,] d = new int[n, maxTime + 1];\\n\\n\\tfor (int node = 0; node < n; node++)\\n\\t{\\n\\t\\tfor (int time = 0; time <= maxTime; time++)\\n\\t\\t{\\n\\t\\t\\td[node, time] = int.MaxValue;\\n\\t\\t}\\n\\t}\\n\\n\\td[0, 0] = passingFees[0];\\n\\n\\tfor (int time = 1; time <= maxTime; time++)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tforeach (var (index, currentTime) in graph[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (time >= currentTime && d[index, time - currentTime] != int.MaxValue)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td[i, time] = Math.Min(d[i, time], d[index, time - currentTime] + passingFees[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 1; i <= maxTime; i++)\\n\\t{\\n\\t\\tresult = Math.Min(result, d[n - 1, i]);\\n\\t}\\n\\n\\treturn result == int.MaxValue ? -1 : result;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```csharp\\npublic int MinCost(int maxTime, int[][] edges, int[] passingFees)\\n{\\n\\tint n = passingFees.Length;\\n\\tDictionary<int, List<(int index, int cost)>> graph = new Dictionary<int, List<(int, int)>>();\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tgraph[i] = new List<(int, int)>();\\n\\t}\\n\\n\\tforeach (var edge in edges)\\n\\t{\\n\\t\\tint u = edge[0], v = edge[1], c = edge[2];\\n\\t\\tgraph[u].Add((v, c));\\n\\t\\tgraph[v].Add((u, c));\\n\\t}\\n\\n\\tint result = int.MaxValue;\\n\\tint[,] d = new int[n, maxTime + 1];\\n\\n\\tfor (int node = 0; node < n; node++)\\n\\t{\\n\\t\\tfor (int time = 0; time <= maxTime; time++)\\n\\t\\t{\\n\\t\\t\\td[node, time] = int.MaxValue;\\n\\t\\t}\\n\\t}\\n\\n\\td[0, 0] = passingFees[0];\\n\\n\\tfor (int time = 1; time <= maxTime; time++)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tforeach (var (index, currentTime) in graph[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (time >= currentTime && d[index, time - currentTime] != int.MaxValue)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td[i, time] = Math.Min(d[i, time], d[index, time - currentTime] + passingFees[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 1; i <= maxTime; i++)\\n\\t{\\n\\t\\tresult = Math.Min(result, d[n - 1, i]);\\n\\t}\\n\\n\\treturn result == int.MaxValue ? -1 : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1328974,
                "title": "python-heap-solution",
                "content": "Use visited, time, and cost to memorize the status of each node, update if necessary.\\nUse a minheap to prioritize cost, time.\\n\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \\n        n = len(passingFees)\\n        g = collections.defaultdict(list)\\n        for u, v, t in edges:\\n            g[u].append((v, t))\\n            g[v].append((u, t))\\n        \\n        times = [0] + [float(\\'inf\\')] * (n - 1)\\n        costs = [passingFees[0]] + [float(\\'inf\\')] * (n - 1)\\n        q = [(passingFees[0], 0, 0)] # cost, time, node\\n        visited = set()\\n        visited.add(0)\\n        while q:\\n            cost, time, node = heapq.heappop(q)\\n            if node == n - 1:\\n                if time <= maxTime:\\n                    return cost\\n                else:\\n                    return -1\\n            for neighbor, t in g[node]:\\n                if time + t <= maxTime and (neighbor not in visited or cost + passingFees[neighbor] < costs[neighbor] or time + t < times[neighbor]):\\n                    visited.add(neighbor)\\n                    times[neighbor] = min(times[neighbor], time + t)\\n                    costs[neighbor] = min(costs[neighbor], cost + passingFees[neighbor])\\n                    heapq.heappush(q, (cost + passingFees[neighbor], time + t, neighbor))\\n                    \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \\n        n = len(passingFees)\\n        g = collections.defaultdict(list)\\n        for u, v, t in edges:\\n            g[u].append((v, t))\\n            g[v].append((u, t))\\n        \\n        times = [0] + [float(\\'inf\\')] * (n - 1)\\n        costs = [passingFees[0]] + [float(\\'inf\\')] * (n - 1)\\n        q = [(passingFees[0], 0, 0)] # cost, time, node\\n        visited = set()\\n        visited.add(0)\\n        while q:\\n            cost, time, node = heapq.heappop(q)\\n            if node == n - 1:\\n                if time <= maxTime:\\n                    return cost\\n                else:\\n                    return -1\\n            for neighbor, t in g[node]:\\n                if time + t <= maxTime and (neighbor not in visited or cost + passingFees[neighbor] < costs[neighbor] or time + t < times[neighbor]):\\n                    visited.add(neighbor)\\n                    times[neighbor] = min(times[neighbor], time + t)\\n                    costs[neighbor] = min(costs[neighbor], cost + passingFees[neighbor])\\n                    heapq.heappush(q, (cost + passingFees[neighbor], time + t, neighbor))\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328961,
                "title": "java-dijkstra-s-algorithm",
                "content": "I feel like this had very tight limit for Java... even with primitive arrays it barely passes on time (some attempts TLE)\\n\\nSame code in c++ will comfortably pass\\n\\n```\\n    static int[][][] g;\\n    static int[][] edges;\\n    static int n;\\n\\n    public int minCost(int maxTime, int[][] e, int[] passingFees) {\\n        edges = e;\\n        n = passingFees.length;\\n        g = packG();\\n        final int[][] dp = new int[n][maxTime + 1];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], (int) 1e9);\\n        }\\n        dp[0][0] = passingFees[0];\\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[] { passingFees[0], 0, 0 });\\n        while (!pq.isEmpty()) {\\n            final int[] curr = pq.remove();\\n            final int d = curr[0];\\n            final int u = curr[1];\\n            final int time = curr[2];\\n            if (dp[u][time] < d) {\\n                continue;\\n            }\\n            for (int[] next : g[u]) {\\n                final int nextTime = time + next[1];\\n                if (nextTime <= maxTime) {\\n                    if (dp[next[0]][nextTime] > dp[u][time] + passingFees[next[0]]) {\\n                        dp[next[0]][nextTime] = dp[u][time] + passingFees[next[0]];\\n                        pq.offer(new int[] { dp[next[0]][nextTime], next[0], nextTime });\\n                    }\\n                }\\n            }\\n        }\\n        int res = (int) 1e9;\\n        for (int i = 0; i <= maxTime; i++) {\\n            res = Math.min(res, dp[n - 1][i]);\\n        }\\n        return res == (int) 1e9 ? -1 : res;\\n    }\\n\\n    private static int[][][] packG() {\\n        final int[][][] g = new int[n][][];\\n        final int[] size = new int[n];\\n        for (int[] edge : edges) {\\n            ++size[edge[0]];\\n            ++size[edge[1]];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            g[i] = new int[size[i]][2];\\n        }\\n        for (int[] edge : edges) {\\n            g[edge[0]][--size[edge[0]]] = new int[] { edge[1], edge[2] };\\n            g[edge[1]][--size[edge[1]]] = new int[] { edge[0], edge[2] };\\n        }\\n        return g;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    static int[][][] g;\\n    static int[][] edges;\\n    static int n;\\n\\n    public int minCost(int maxTime, int[][] e, int[] passingFees) {\\n        edges = e;\\n        n = passingFees.length;\\n        g = packG();\\n        final int[][] dp = new int[n][maxTime + 1];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], (int) 1e9);\\n        }\\n        dp[0][0] = passingFees[0];\\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[] { passingFees[0], 0, 0 });\\n        while (!pq.isEmpty()) {\\n            final int[] curr = pq.remove();\\n            final int d = curr[0];\\n            final int u = curr[1];\\n            final int time = curr[2];\\n            if (dp[u][time] < d) {\\n                continue;\\n            }\\n            for (int[] next : g[u]) {\\n                final int nextTime = time + next[1];\\n                if (nextTime <= maxTime) {\\n                    if (dp[next[0]][nextTime] > dp[u][time] + passingFees[next[0]]) {\\n                        dp[next[0]][nextTime] = dp[u][time] + passingFees[next[0]];\\n                        pq.offer(new int[] { dp[next[0]][nextTime], next[0], nextTime });\\n                    }\\n                }\\n            }\\n        }\\n        int res = (int) 1e9;\\n        for (int i = 0; i <= maxTime; i++) {\\n            res = Math.min(res, dp[n - 1][i]);\\n        }\\n        return res == (int) 1e9 ? -1 : res;\\n    }\\n\\n    private static int[][][] packG() {\\n        final int[][][] g = new int[n][][];\\n        final int[] size = new int[n];\\n        for (int[] edge : edges) {\\n            ++size[edge[0]];\\n            ++size[edge[1]];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            g[i] = new int[size[i]][2];\\n        }\\n        for (int[] edge : edges) {\\n            g[edge[0]][--size[edge[0]]] = new int[] { edge[1], edge[2] };\\n            g[edge[1]][--size[edge[1]]] = new int[] { edge[0], edge[2] };\\n        }\\n        return g;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048207,
                "title": "java-easy-modified-dijkstra-s-algorithm",
                "content": "# Intuition\\nThis problem is a variant of the shortest path problem, where you need to find the minimum cost to reach the destination. Unlike the standard shortest path problem where we only consider distances, here we have two constraints - time and cost.\\n\\nThe primary intuition is to use a modified Dijkstra\\u2019s shortest path algorithm. Traditionally, Dijkstra\\u2019s algorithm focuses only on the shortest distance, but here we need to consider the time as well as the cost. The key insight is that for each city, we might reach it multiple times with different elapsed times, so we need to track the minimum cost for each elapsed time at each city.\\n\\n# Approach\\n1. **Graph Construction:** First, we construct the graph using an adjacency list. Each city has a list of its neighboring cities and the time taken to travel to them.\\n\\n2. **Priority Queue:** We use a priority queue (with a custom comparator to prioritize nodes with lower costs) to keep track of the cities we can travel to. The priority queue helps in choosing the city with the minimum cost first.\\n\\n3. **Dynamic Programming Table:** We use a 2D DP table where dp[i][j] represents the minimum cost to reach city i in j minutes. This table helps in avoiding unnecessary calculations and reduces the overall complexity.\\n\\n4. **Traversal:** Starting from city 0, for each neighboring city, if we can travel to that city within the allowed time and the new cost is less than the previously recorded cost for that city and time, then we update the cost and add the city to the priority queue.\\n\\n5. **Termination:** The traversal continues until the priority queue is empty or we reach the destination city (i.e., city n-1). If we reach the destination, we return the cost, else we return -1.\\n\\n# Complexity\\n- Time complexity: O(V*log(V))\\n\\n- Space complexity: O(V)\\n\\n# Code\\n```\\nclass Node{\\n    int city;\\n    int cost;\\n    int time;\\n    Node(int city,int cost,int time){\\n        this.city = city;\\n        this.cost = cost;\\n        this.time = time;\\n    }\\n}\\n\\nclass Pair{\\n    int city;\\n    int time;\\n    Pair(int city,int time){\\n        this.city = city;\\n        this.time = time;\\n    }\\n}\\n\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n    \\n        int total_cities = passingFees.length;\\n\\n        ArrayList<ArrayList<Pair>> adj_list = new ArrayList<>();\\n\\n        for(int i=0;i<total_cities;i++){\\n            adj_list.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<edges.length;i++){\\n            int city1 = edges[i][0];\\n            int city2 = edges[i][1];\\n            int distance = edges[i][2];\\n            adj_list.get(city1).add(new Pair(city2,distance));\\n            adj_list.get(city2).add(new Pair(city1,distance));\\n        }\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>((x,y)-> x.cost-y.cost);\\n        pq.add(new Node(0,passingFees[0],0));\\n\\n        int[][] dp = new int[total_cities][maxTime+1];\\n        for(int[] row:dp) Arrays.fill(row,Integer.MAX_VALUE);\\n\\n        dp[0][0] = passingFees[0];\\n\\n        while(!pq.isEmpty()){\\n            \\n            Node node = pq.poll();\\n            int curr_city = node.city;\\n            int cost = node.cost;\\n            int time = node.time;\\n\\n            if(curr_city==total_cities-1) return cost;\\n\\n            for(Pair pair:adj_list.get(curr_city)){\\n\\n                int next_city = pair.city;\\n                int next_time = pair.time + time;\\n                int next_cost = cost + passingFees[next_city];\\n\\n                if(next_time>maxTime) continue;\\n\\n                if(next_cost<dp[next_city][next_time]){\\n                    dp[next_city][next_time] = next_cost;\\n                    pq.add(new Node(next_city,next_cost,next_time));\\n                }\\n\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Node{\\n    int city;\\n    int cost;\\n    int time;\\n    Node(int city,int cost,int time){\\n        this.city = city;\\n        this.cost = cost;\\n        this.time = time;\\n    }\\n}\\n\\nclass Pair{\\n    int city;\\n    int time;\\n    Pair(int city,int time){\\n        this.city = city;\\n        this.time = time;\\n    }\\n}\\n\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n    \\n        int total_cities = passingFees.length;\\n\\n        ArrayList<ArrayList<Pair>> adj_list = new ArrayList<>();\\n\\n        for(int i=0;i<total_cities;i++){\\n            adj_list.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<edges.length;i++){\\n            int city1 = edges[i][0];\\n            int city2 = edges[i][1];\\n            int distance = edges[i][2];\\n            adj_list.get(city1).add(new Pair(city2,distance));\\n            adj_list.get(city2).add(new Pair(city1,distance));\\n        }\\n\\n        PriorityQueue<Node> pq = new PriorityQueue<>((x,y)-> x.cost-y.cost);\\n        pq.add(new Node(0,passingFees[0],0));\\n\\n        int[][] dp = new int[total_cities][maxTime+1];\\n        for(int[] row:dp) Arrays.fill(row,Integer.MAX_VALUE);\\n\\n        dp[0][0] = passingFees[0];\\n\\n        while(!pq.isEmpty()){\\n            \\n            Node node = pq.poll();\\n            int curr_city = node.city;\\n            int cost = node.cost;\\n            int time = node.time;\\n\\n            if(curr_city==total_cities-1) return cost;\\n\\n            for(Pair pair:adj_list.get(curr_city)){\\n\\n                int next_city = pair.city;\\n                int next_time = pair.time + time;\\n                int next_cost = cost + passingFees[next_city];\\n\\n                if(next_time>maxTime) continue;\\n\\n                if(next_cost<dp[next_city][next_time]){\\n                    dp[next_city][next_time] = next_cost;\\n                    pq.add(new Node(next_city,next_cost,next_time));\\n                }\\n\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017745,
                "title": "dijkstra-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Cost {\\n    public:\\n        int wt, ed, cost;\\n        Cost(int wt, int ed, int cost) : wt(wt), ed(ed), cost(cost) {}\\n        bool operator<(const Cost& other) const {\\n            return cost > other.cost;\\n        }\\n    };\\n\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<vector<pair<int, int>>> adj(n); // Create an adjacency list to represent the graph.\\n        vector<vector<int>> dp(n, vector<int>(maxTime + 1, INT_MAX)); // dp[i][j] represents the minimum cost to reach city i with time j.\\n\\n        // Build the adjacency list based on the given edges.\\n        for (auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int w = edge[2];\\n            adj[u].emplace_back(v, w);\\n            adj[v].emplace_back(u, w);\\n        }\\n\\n        priority_queue<Cost> pq; // Create a priority queue to perform Dijkstra\\'s algorithm.\\n        pq.push({0, 0, passingFees[0]}); // Start from city 0 with time 0 and the passing fee for the starting city.\\n        dp[0][0] = passingFees[0]; // Initialize dp for the starting city.\\n\\n        while (!pq.empty()) {\\n            Cost cur = pq.top(); // Get the current state with the minimum cost from the priority queue.\\n            pq.pop();\\n\\n            int u = cur.ed; // Current city.\\n            int wt = cur.wt; // Current time.\\n            int cost = cur.cost; // Current cost.\\n\\n            if (u == n - 1) {\\n                return cost; // If we reach the destination city, return the minimum cost.\\n            }\\n\\n            for (auto& edge : adj[u]) {\\n                int v = edge.first; // Neighbor city.\\n                int w = edge.second; // Time required to travel to the neighbor.\\n\\n                if (wt + w <= maxTime && cost + passingFees[v] < dp[v][wt + w]) {\\n                    dp[v][wt + w] = cost + passingFees[v]; // Update the minimum cost to reach city v with time wt + w.\\n                    pq.push({wt + w, v, cost + passingFees[v]}); // Add this state to the priority queue for further exploration.\\n                }\\n            }\\n        }\\n\\n        return -1; // If we can\\'t reach the destination within maxTime, return -1.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    class Cost {\\n    public:\\n        int wt, ed, cost;\\n        Cost(int wt, int ed, int cost) : wt(wt), ed(ed), cost(cost) {}\\n        bool operator<(const Cost& other) const {\\n            return cost > other.cost;\\n        }\\n    };\\n\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<vector<pair<int, int>>> adj(n); // Create an adjacency list to represent the graph.\\n        vector<vector<int>> dp(n, vector<int>(maxTime + 1, INT_MAX)); // dp[i][j] represents the minimum cost to reach city i with time j.\\n\\n        // Build the adjacency list based on the given edges.\\n        for (auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int w = edge[2];\\n            adj[u].emplace_back(v, w);\\n            adj[v].emplace_back(u, w);\\n        }\\n\\n        priority_queue<Cost> pq; // Create a priority queue to perform Dijkstra\\'s algorithm.\\n        pq.push({0, 0, passingFees[0]}); // Start from city 0 with time 0 and the passing fee for the starting city.\\n        dp[0][0] = passingFees[0]; // Initialize dp for the starting city.\\n\\n        while (!pq.empty()) {\\n            Cost cur = pq.top(); // Get the current state with the minimum cost from the priority queue.\\n            pq.pop();\\n\\n            int u = cur.ed; // Current city.\\n            int wt = cur.wt; // Current time.\\n            int cost = cur.cost; // Current cost.\\n\\n            if (u == n - 1) {\\n                return cost; // If we reach the destination city, return the minimum cost.\\n            }\\n\\n            for (auto& edge : adj[u]) {\\n                int v = edge.first; // Neighbor city.\\n                int w = edge.second; // Time required to travel to the neighbor.\\n\\n                if (wt + w <= maxTime && cost + passingFees[v] < dp[v][wt + w]) {\\n                    dp[v][wt + w] = cost + passingFees[v]; // Update the minimum cost to reach city v with time wt + w.\\n                    pq.push({wt + w, v, cost + passingFees[v]}); // Add this state to the priority queue for further exploration.\\n                }\\n            }\\n        }\\n\\n        return -1; // If we can\\'t reach the destination within maxTime, return -1.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016110,
                "title": "simple-dijkstra-s-algorithm-c-java-python",
                "content": "# Intuition\\nSince source-single destination. Bellman-ford and Dijkstra come to mind? \\n\\n# Approach\\nDijksta\\'s algorithm. You can hear more in the linked video: \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N log N)\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<Edge>[] adj = new ArrayList[n];\\n        for (int k = 0; k < n; k++) {\\n            adj[k] = new ArrayList();\\n        }\\n        for (int k = 0; k < edges.length; k++) {\\n            int[] edge = edges[k];\\n            int u = edge[0];\\n            int v = edge[1];\\n            int t = edge[2];\\n            adj[u].add(new Edge(v, t, passingFees[v]));\\n            adj[v].add(new Edge(u, t, passingFees[u]));\\n        }\\n\\n        int[] minTime = new int[n];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b)-> (a.cost == b.cost)? a.time - b.time : a.cost - b.cost);// Consider only cost for ordering\\n        pq.add(new Edge(0, 0, passingFees[0]));\\n\\n        while (!pq.isEmpty()) {\\n            Edge current = pq.poll();\\n            int currentNode = current.node;\\n            int currentTime = current.time;\\n            int currentCost = current.cost;\\n\\n            if (currentTime > maxTime || currentTime >= minTime[currentNode]){\\n                continue;\\n            }\\n            \\n            if (currentNode == n - 1) {\\n                return currentCost; // We have reached the destination\\n            }\\n\\n            minTime[currentNode] = currentTime; // Update the minTime for this node\\n\\n            for (Edge neighborEdge : adj[currentNode]) {\\n                int neighbor = neighborEdge.node;\\n                int newTime = neighborEdge.time + currentTime;\\n                int newCost = neighborEdge.cost + currentCost;\\n\\n                if (newTime <= maxTime) {\\n                    pq.add(new Edge(neighbor, newTime, newCost));\\n                }\\n            }\\n        }\\n\\n        return -1; // If we can\\'t reach the destination within maxTime\\n    }\\n\\n    public class Edge {\\n        int node;\\n        int time;\\n        int cost;\\n\\n        public Edge(int node, int time, int cost) {\\n            this.node = node;\\n            this.time = time;\\n            this.cost = cost;\\n        }\\n    }\\n}\\n```\\n```python []\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v, t = edge\\n            adj[u].append((v, t, passingFees[v]))\\n            adj[v].append((u, t, passingFees[u]))\\n\\n        minTime = [float(\\'inf\\') for _ in range(n)]\\n        pq = []\\n        heappush(pq, (passingFees[0], 0, 0))  # cost, time, node\\n\\n        while pq:\\n            cost, time, node = heappop(pq)\\n\\n            if time > maxTime or time >= minTime[node]:\\n                continue\\n\\n            if node == n - 1:\\n                return cost\\n\\n            minTime[node] = time\\n\\n            for v, t, c in adj[node]:\\n                if time + t <= maxTime:\\n                    heappush(pq, (cost + c, time + t, v))\\n\\n        return -1\\n```\\n```c++ []\\n#include <vector>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<vector<pair<int, pair<int, int>>>> adj(n); // {node, {time, cost}}\\n        \\n        for(auto& edge : edges) {\\n            int u = edge[0], v = edge[1], t = edge[2];\\n            adj[u].push_back({v, {t, passingFees[v]}});\\n            adj[v].push_back({u, {t, passingFees[u]}});\\n        }\\n\\n        vector<int> minTime(n, INT_MAX);\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq; // {cost, {time, node}}\\n        pq.push({passingFees[0], {0, 0}});\\n        \\n        while(!pq.empty()) {\\n            int cost = pq.top().first, time = pq.top().second.first, node = pq.top().second.second;\\n            pq.pop();\\n\\n            if(time > maxTime || time >= minTime[node]) continue;\\n\\n            if(node == n - 1) return cost;\\n\\n            minTime[node] = time;\\n\\n            for(auto& next : adj[node]) {\\n                int v = next.first, t = next.second.first, c = next.second.second;\\n                if(time + t <= maxTime) {\\n                    pq.push({cost + c, {time + t, v}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<Edge>[] adj = new ArrayList[n];\\n        for (int k = 0; k < n; k++) {\\n            adj[k] = new ArrayList();\\n        }\\n        for (int k = 0; k < edges.length; k++) {\\n            int[] edge = edges[k];\\n            int u = edge[0];\\n            int v = edge[1];\\n            int t = edge[2];\\n            adj[u].add(new Edge(v, t, passingFees[v]));\\n            adj[v].add(new Edge(u, t, passingFees[u]));\\n        }\\n\\n        int[] minTime = new int[n];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b)-> (a.cost == b.cost)? a.time - b.time : a.cost - b.cost);// Consider only cost for ordering\\n        pq.add(new Edge(0, 0, passingFees[0]));\\n\\n        while (!pq.isEmpty()) {\\n            Edge current = pq.poll();\\n            int currentNode = current.node;\\n            int currentTime = current.time;\\n            int currentCost = current.cost;\\n\\n            if (currentTime > maxTime || currentTime >= minTime[currentNode]){\\n                continue;\\n            }\\n            \\n            if (currentNode == n - 1) {\\n                return currentCost; // We have reached the destination\\n            }\\n\\n            minTime[currentNode] = currentTime; // Update the minTime for this node\\n\\n            for (Edge neighborEdge : adj[currentNode]) {\\n                int neighbor = neighborEdge.node;\\n                int newTime = neighborEdge.time + currentTime;\\n                int newCost = neighborEdge.cost + currentCost;\\n\\n                if (newTime <= maxTime) {\\n                    pq.add(new Edge(neighbor, newTime, newCost));\\n                }\\n            }\\n        }\\n\\n        return -1; // If we can\\'t reach the destination within maxTime\\n    }\\n\\n    public class Edge {\\n        int node;\\n        int time;\\n        int cost;\\n\\n        public Edge(int node, int time, int cost) {\\n            this.node = node;\\n            this.time = time;\\n            this.cost = cost;\\n        }\\n    }\\n}\\n```\n```python []\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v, t = edge\\n            adj[u].append((v, t, passingFees[v]))\\n            adj[v].append((u, t, passingFees[u]))\\n\\n        minTime = [float(\\'inf\\') for _ in range(n)]\\n        pq = []\\n        heappush(pq, (passingFees[0], 0, 0))  # cost, time, node\\n\\n        while pq:\\n            cost, time, node = heappop(pq)\\n\\n            if time > maxTime or time >= minTime[node]:\\n                continue\\n\\n            if node == n - 1:\\n                return cost\\n\\n            minTime[node] = time\\n\\n            for v, t, c in adj[node]:\\n                if time + t <= maxTime:\\n                    heappush(pq, (cost + c, time + t, v))\\n\\n        return -1\\n```\n```c++ []\\n#include <vector>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<vector<pair<int, pair<int, int>>>> adj(n); // {node, {time, cost}}\\n        \\n        for(auto& edge : edges) {\\n            int u = edge[0], v = edge[1], t = edge[2];\\n            adj[u].push_back({v, {t, passingFees[v]}});\\n            adj[v].push_back({u, {t, passingFees[u]}});\\n        }\\n\\n        vector<int> minTime(n, INT_MAX);\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq; // {cost, {time, node}}\\n        pq.push({passingFees[0], {0, 0}});\\n        \\n        while(!pq.empty()) {\\n            int cost = pq.top().first, time = pq.top().second.first, node = pq.top().second.second;\\n            pq.pop();\\n\\n            if(time > maxTime || time >= minTime[node]) continue;\\n\\n            if(node == n - 1) return cost;\\n\\n            minTime[node] = time;\\n\\n            for(auto& next : adj[node]) {\\n                int v = next.first, t = next.second.first, c = next.second.second;\\n                if(time + t <= maxTime) {\\n                    pq.push({cost + c, {time + t, v}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3990248,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minCost(int maxTime, vector<vector<int>>& edges,\\n              vector<int>& passingFees) {\\n    const int n = passingFees.size();\\n    vector<vector<pair<int, int>>> graph(n);\\n\\n    for (const vector<int>& edge : edges) {\\n      const int u = edge[0];\\n      const int v = edge[1];\\n      const int w = edge[2];\\n      graph[u].emplace_back(v, w);\\n      graph[v].emplace_back(u, w);\\n    }\\n\\n    return dijkstra(graph, 0, n - 1, maxTime, passingFees);\\n  }\\n\\n private:\\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,\\n               int maxTime, const vector<int>& passingFees) {\\n    // cost[i] := min cost to reach cities[i]\\n    vector<int> cost(graph.size(), INT_MAX);\\n    // dist[i] := min time to reach cities[i]\\n    vector<int> dist(graph.size(), maxTime + 1);\\n    using T = tuple<int, int, int>;  // (cost[u], dist[u], u)\\n    priority_queue<T, vector<T>, greater<>> minHeap;\\n\\n    cost[src] = passingFees[src];\\n    dist[src] = 0;\\n    minHeap.emplace(cost[src], dist[src], src);\\n\\n    while (!minHeap.empty()) {\\n      const auto [currCost, d, u] = minHeap.top();\\n      minHeap.pop();\\n      if (u == dst)\\n        return cost[dst];\\n      for (const auto& [v, w] : graph[u]) {\\n        if (d + w > maxTime)\\n          continue;\\n        // Go from u -> v.\\n        if (currCost + passingFees[v] < cost[v]) {\\n          cost[v] = currCost + passingFees[v];\\n          dist[v] = d + w;\\n          minHeap.emplace(cost[v], dist[v], v);\\n        } else if (d + w < dist[v]) {\\n          dist[v] = d + w;\\n          minHeap.emplace(currCost + passingFees[v], dist[v], v);\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minCost(int maxTime, vector<vector<int>>& edges,\\n              vector<int>& passingFees) {\\n    const int n = passingFees.size();\\n    vector<vector<pair<int, int>>> graph(n);\\n\\n    for (const vector<int>& edge : edges) {\\n      const int u = edge[0];\\n      const int v = edge[1];\\n      const int w = edge[2];\\n      graph[u].emplace_back(v, w);\\n      graph[v].emplace_back(u, w);\\n    }\\n\\n    return dijkstra(graph, 0, n - 1, maxTime, passingFees);\\n  }\\n\\n private:\\n  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,\\n               int maxTime, const vector<int>& passingFees) {\\n    // cost[i] := min cost to reach cities[i]\\n    vector<int> cost(graph.size(), INT_MAX);\\n    // dist[i] := min time to reach cities[i]\\n    vector<int> dist(graph.size(), maxTime + 1);\\n    using T = tuple<int, int, int>;  // (cost[u], dist[u], u)\\n    priority_queue<T, vector<T>, greater<>> minHeap;\\n\\n    cost[src] = passingFees[src];\\n    dist[src] = 0;\\n    minHeap.emplace(cost[src], dist[src], src);\\n\\n    while (!minHeap.empty()) {\\n      const auto [currCost, d, u] = minHeap.top();\\n      minHeap.pop();\\n      if (u == dst)\\n        return cost[dst];\\n      for (const auto& [v, w] : graph[u]) {\\n        if (d + w > maxTime)\\n          continue;\\n        // Go from u -> v.\\n        if (currCost + passingFees[v] < cost[v]) {\\n          cost[v] = currCost + passingFees[v];\\n          dist[v] = d + w;\\n          minHeap.emplace(cost[v], dist[v], v);\\n        } else if (d + w < dist[v]) {\\n          dist[v] = d + w;\\n          minHeap.emplace(currCost + passingFees[v], dist[v], v);\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894361,
                "title": "c-solution-dijkstra-s-algorithm-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(Elog(V))$$\\n- Space complexity:\\n$$O(V)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n      int n = passingFees.size();\\n      vector<int>costs(n,INT_MAX);\\n      vector<int>totaltime(n,INT_MAX);\\n      costs[0] = passingFees[0];\\n      totaltime[0] = 0;\\n      vector<vector<pair<int,int>>>graph(n);\\n      for(auto nxt : edges){\\n        graph[nxt[0]].push_back({nxt[1],nxt[2]});\\n        graph[nxt[1]].push_back({nxt[0],nxt[2]});\\n      }\\n      priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n      ////////// {cost, node, time}\\n      pq.push({costs[0],{totaltime[0],0}});\\n\\n      while (!pq.empty())\\n      {\\n        int paid = pq.top().first, time = pq.top().second.first, node = pq.top().second.second;\\n        pq.pop();\\n        \\n        for(auto it : graph[node]){\\n          if(time+it.second <= maxTime){\\n            if(paid + passingFees[it.first] < costs[it.first]){\\n              costs[it.first]=paid+passingFees[it.first];\\n              totaltime[it.first] = time+it.second;\\n              pq.push({costs[it.first], {totaltime[it.first], it.first}});\\n            }else if(time + it.second < totaltime[it.first]){\\n              totaltime[it.first] = time+it.second;\\n              pq.push({paid+passingFees[it.first], {totaltime[it.first], it.first}});\\n            }\\n            \\n          }\\n        }\\n      }\\n      if(costs[n-1] != INT_MAX){\\n        return costs[n-1];\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n      int n = passingFees.size();\\n      vector<int>costs(n,INT_MAX);\\n      vector<int>totaltime(n,INT_MAX);\\n      costs[0] = passingFees[0];\\n      totaltime[0] = 0;\\n      vector<vector<pair<int,int>>>graph(n);\\n      for(auto nxt : edges){\\n        graph[nxt[0]].push_back({nxt[1],nxt[2]});\\n        graph[nxt[1]].push_back({nxt[0],nxt[2]});\\n      }\\n      priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n      ////////// {cost, node, time}\\n      pq.push({costs[0],{totaltime[0],0}});\\n\\n      while (!pq.empty())\\n      {\\n        int paid = pq.top().first, time = pq.top().second.first, node = pq.top().second.second;\\n        pq.pop();\\n        \\n        for(auto it : graph[node]){\\n          if(time+it.second <= maxTime){\\n            if(paid + passingFees[it.first] < costs[it.first]){\\n              costs[it.first]=paid+passingFees[it.first];\\n              totaltime[it.first] = time+it.second;\\n              pq.push({costs[it.first], {totaltime[it.first], it.first}});\\n            }else if(time + it.second < totaltime[it.first]){\\n              totaltime[it.first] = time+it.second;\\n              pq.push({paid+passingFees[it.first], {totaltime[it.first], it.first}});\\n            }\\n            \\n          }\\n        }\\n      }\\n      if(costs[n-1] != INT_MAX){\\n        return costs[n-1];\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783985,
                "title": "bfs-and-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\n    class Solution {\\n    public:\\n        vector<vector<vector<int>>>gp;\\n        int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n            int n = passingFees.size();\\n            gp.resize(n);\\n            queue<vector<int>>q;\\n            q.push({0, passingFees[0], 0});\\n            for(auto e: edges){\\n                gp[e[0]].push_back({e[1], e[2]});\\n                gp[e[1]].push_back({e[0], e[2]});\\n            }\\n            vector<vector<int>>dp(1001, vector<int>(1001, 1e9));\\n            dp[0][0] = passingFees[0];\\n            \\n            vector<int>minTime(n + 1, 1e9);\\n            vector<int>minCost(n + 1, 1e9);\\n            minTime[0] = 0;\\n            minCost[0] = passingFees[0];\\n            while(q.size()){\\n                auto u = q.front()[0];\\n                auto v = q.front()[1];\\n                auto t = q.front()[2];\\n                //cout<<u<<endl;\\n\\n                q.pop();\\n                if(dp[u][t] != v)continue;\\n\\n                for(auto next: gp[u]){\\n                    int nextu = next[0];\\n                    int nextt = next[1];\\n\\n                    if(t + nextt > maxTime)continue;\\n                    if(minTime[nextu] < t + nextt && minCost[nextu] <  v + passingFees[nextu])continue;\\n                    minTime[nextu] = min(minTime[nextu], t + nextt);\\n                    minCost[nextu] = min(minCost[nextu], v + passingFees[nextu]);\\n\\n                    if(dp[nextu][t + nextt] <= v + passingFees[nextu])continue;\\n                    dp[nextu][t + nextt] = v + passingFees[nextu];\\n\\n\\n                    q.push({nextu,  v + passingFees[nextu], nextt + t});\\n                }\\n            }\\n            //if(!dp[n-1].size())return -1;\\n            int ans = 1e9;\\n            for(auto v: dp[n-1]){\\n                ans = min(v, ans);\\n            }\\n            return ans == 1e9 ? -1 : ans;\\n        }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n    class Solution {\\n    public:\\n        vector<vector<vector<int>>>gp;\\n        int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n            int n = passingFees.size();\\n            gp.resize(n);\\n            queue<vector<int>>q;\\n            q.push({0, passingFees[0], 0});\\n            for(auto e: edges){\\n                gp[e[0]].push_back({e[1], e[2]});\\n                gp[e[1]].push_back({e[0], e[2]});\\n            }\\n            vector<vector<int>>dp(1001, vector<int>(1001, 1e9));\\n            dp[0][0] = passingFees[0];\\n            \\n            vector<int>minTime(n + 1, 1e9);\\n            vector<int>minCost(n + 1, 1e9);\\n            minTime[0] = 0;\\n            minCost[0] = passingFees[0];\\n            while(q.size()){\\n                auto u = q.front()[0];\\n                auto v = q.front()[1];\\n                auto t = q.front()[2];\\n                //cout<<u<<endl;\\n\\n                q.pop();\\n                if(dp[u][t] != v)continue;\\n\\n                for(auto next: gp[u]){\\n                    int nextu = next[0];\\n                    int nextt = next[1];\\n\\n                    if(t + nextt > maxTime)continue;\\n                    if(minTime[nextu] < t + nextt && minCost[nextu] <  v + passingFees[nextu])continue;\\n                    minTime[nextu] = min(minTime[nextu], t + nextt);\\n                    minCost[nextu] = min(minCost[nextu], v + passingFees[nextu]);\\n\\n                    if(dp[nextu][t + nextt] <= v + passingFees[nextu])continue;\\n                    dp[nextu][t + nextt] = v + passingFees[nextu];\\n\\n\\n                    q.push({nextu,  v + passingFees[nextu], nextt + t});\\n                }\\n            }\\n            //if(!dp[n-1].size())return -1;\\n            int ans = 1e9;\\n            for(auto v: dp[n-1]){\\n                ans = min(v, ans);\\n            }\\n            return ans == 1e9 ? -1 : ans;\\n        }\\n    };\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3659374,
                "title": "c-bellman-ford",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinCost(int maxTime, int[][] edges, int[] fee) {\\n       \\n        int n = fee.Length, minCost = int.MaxValue;\\n        int[,] dp = new int [maxTime+1,n];\\n        for(int row =0; row<maxTime+1;row++)\\n            for(int col=0; col<n;col++){dp[row, col]=int.MaxValue;  \\n                                        }// initialise the dp with infinity\\n        dp[0,0] = fee[0];      // cost_to_reach_sourceNode = fee[sourceNode]\\n        \\n        for(int currTime = 0; currTime<=maxTime; currTime++){\\n            foreach(int[] edge in edges){                    // loop through all the edges\\n                int reachTime = currTime+edge[2];      // if time to reach the next node is > maxTime, then just skip this edge\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t// the edges are bidirectional, so we have to handle both directions\\n                for(int i=0;reachTime<=maxTime && i<=1;i++){    \\n                    int fromNode = edge[i^0], toNode = edge[i^1];    // intelligent way to swap the fromNode and toNode\\n                    if(dp[currTime,fromNode]!=int.MaxValue && reachTime<=maxTime){\\n                    dp[reachTime,toNode] = Math.Min(dp[reachTime,toNode], dp[currTime,fromNode]+fee[toNode]);\\n                    }      \\n                } \\n            } \\n        }\\n        for(int t=0;t<=maxTime; t++)    minCost = Math.Min(minCost, dp[t,n-1]); // find the minCost to reach lastNode\\n        return minCost==int.MaxValue? -1 : minCost;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinCost(int maxTime, int[][] edges, int[] fee) {\\n       \\n        int n = fee.Length, minCost = int.MaxValue;\\n        int[,] dp = new int [maxTime+1,n];\\n        for(int row =0; row<maxTime+1;row++)\\n            for(int col=0; col<n;col++){dp[row, col]=int.MaxValue;  \\n                                        }// initialise the dp with infinity\\n        dp[0,0] = fee[0];      // cost_to_reach_sourceNode = fee[sourceNode]\\n        \\n        for(int currTime = 0; currTime<=maxTime; currTime++){\\n            foreach(int[] edge in edges){                    // loop through all the edges\\n                int reachTime = currTime+edge[2];      // if time to reach the next node is > maxTime, then just skip this edge\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t// the edges are bidirectional, so we have to handle both directions\\n                for(int i=0;reachTime<=maxTime && i<=1;i++){    \\n                    int fromNode = edge[i^0], toNode = edge[i^1];    // intelligent way to swap the fromNode and toNode\\n                    if(dp[currTime,fromNode]!=int.MaxValue && reachTime<=maxTime){\\n                    dp[reachTime,toNode] = Math.Min(dp[reachTime,toNode], dp[currTime,fromNode]+fee[toNode]);\\n                    }      \\n                } \\n            } \\n        }\\n        for(int t=0;t<=maxTime; t++)    minCost = Math.Min(minCost, dp[t,n-1]); // find the minCost to reach lastNode\\n        return minCost==int.MaxValue? -1 : minCost;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514001,
                "title": "easy-python-solution-using-heap-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], fees: List[int]) -> int:\\n        h = defaultdict(list)\\n        for i,j,k in edges:\\n            h[i].append((j,k))\\n            h[j].append((i,k))\\n        n = len(fees)\\n        q = [(fees[0],0,0)]\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        while q:\\n            cost, time, node = heapq.heappop(q)\\n            if node == n-1:return cost\\n            adj = h[node]\\n            for j, k in adj:\\n                if dist[j] > k+time and k+time <= maxTime:\\n                    # if j == n-1:return cost+fees[j]\\n                    dist[j] = k+time\\n                    heapq.heappush(q, (cost+fees[j], k+time, j))\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], fees: List[int]) -> int:\\n        h = defaultdict(list)\\n        for i,j,k in edges:\\n            h[i].append((j,k))\\n            h[j].append((i,k))\\n        n = len(fees)\\n        q = [(fees[0],0,0)]\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        while q:\\n            cost, time, node = heapq.heappop(q)\\n            if node == n-1:return cost\\n            adj = h[node]\\n            for j, k in adj:\\n                if dist[j] > k+time and k+time <= maxTime:\\n                    # if j == n-1:return cost+fees[j]\\n                    dist[j] = k+time\\n                    heapq.heappush(q, (cost+fees[j], k+time, j))\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469696,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ; \\nclass Solution {\\nprivate:\\n    int n ;\\n    int maxTime ;\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n = passingFees.size() ;\\n        this->maxTime = maxTime ;\\n        vector<vector<PII>>next(n) ;\\n\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            int w = e[2] ;\\n            next[u].emplace_back(v, w) ;\\n            next[v].emplace_back(u, w) ;\\n        }\\n        return dijkstra(next, 0, n-1, passingFees) ;\\n    }\\n    \\n    int dijkstra(vector<vector<PII>>&next, int src, int dist, vector<int>& passingFees){\\n        // cost[i] := min cost to reach cities[i]\\n        vector<int>cost(n, INT_MAX) ;\\n        // time[i] := min time to reach cities[i]\\n        vector<int>time(n, INT_MAX) ;\\n        using T = tuple<int, int, int> ;  //cost[u], times[u], u\\n        cost[src] = passingFees[src] ;\\n        time[src] = 0 ;\\n        priority_queue<T, vector<T>, greater<>>minHeap ;\\n        minHeap.emplace(cost[src], time[src], src) ;\\n        \\n        while(!minHeap.empty()){\\n            auto [curCost , curTime, cur] = minHeap.top() ;\\n            minHeap.pop() ;\\n            if(cur == dist)\\n                return cost[cur] ;\\n            for(auto [nxt, nxtTime] : next[cur]){\\n                if(curTime + nxtTime > maxTime)\\n                    continue ;\\n                if(curCost + passingFees[nxt] < cost[nxt]){\\n                    cost[nxt] = curCost + passingFees[nxt] ;\\n                    time[nxt] = curTime + nxtTime ;\\n                    minHeap.emplace(cost[nxt], time[nxt], nxt) ;\\n                }\\n                else if(curTime + nxtTime < time[nxt]){\\n                    time[nxt] = curTime + nxtTime;\\n                    minHeap.emplace(curCost + passingFees[nxt], time[nxt], nxt) ;\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing PII = pair<int, int> ; \\nclass Solution {\\nprivate:\\n    int n ;\\n    int maxTime ;\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n = passingFees.size() ;\\n        this->maxTime = maxTime ;\\n        vector<vector<PII>>next(n) ;\\n\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            int w = e[2] ;\\n            next[u].emplace_back(v, w) ;\\n            next[v].emplace_back(u, w) ;\\n        }\\n        return dijkstra(next, 0, n-1, passingFees) ;\\n    }\\n    \\n    int dijkstra(vector<vector<PII>>&next, int src, int dist, vector<int>& passingFees){\\n        // cost[i] := min cost to reach cities[i]\\n        vector<int>cost(n, INT_MAX) ;\\n        // time[i] := min time to reach cities[i]\\n        vector<int>time(n, INT_MAX) ;\\n        using T = tuple<int, int, int> ;  //cost[u], times[u], u\\n        cost[src] = passingFees[src] ;\\n        time[src] = 0 ;\\n        priority_queue<T, vector<T>, greater<>>minHeap ;\\n        minHeap.emplace(cost[src], time[src], src) ;\\n        \\n        while(!minHeap.empty()){\\n            auto [curCost , curTime, cur] = minHeap.top() ;\\n            minHeap.pop() ;\\n            if(cur == dist)\\n                return cost[cur] ;\\n            for(auto [nxt, nxtTime] : next[cur]){\\n                if(curTime + nxtTime > maxTime)\\n                    continue ;\\n                if(curCost + passingFees[nxt] < cost[nxt]){\\n                    cost[nxt] = curCost + passingFees[nxt] ;\\n                    time[nxt] = curTime + nxtTime ;\\n                    minHeap.emplace(cost[nxt], time[nxt], nxt) ;\\n                }\\n                else if(curTime + nxtTime < time[nxt]){\\n                    time[nxt] = curTime + nxtTime;\\n                    minHeap.emplace(curCost + passingFees[nxt], time[nxt], nxt) ;\\n                }\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426908,
                "title": "edge-pruning-and-priority-queue-bfs-commented-and-explained-100-time-wo-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the problem description our initial set of edges is not suitable for a standard approach (multiple edges of different times but same cost between nodes). This lets us know we will need a pruning approach. The second part of the problem that serves as a hint is that we want the minimal cost, which suggests path prioritization, which suggests a priority queue, for which we choose a heap. The last condition is also a potential hazard, for which we do a light feasability check before continuing after pruning the graph of checking to see if it is even possible to arrive in time considering the edges immediately at source and goal only. If these are possible, we then continue to frontier progression. As we progress through the frontier, since it is a priority queue, we also always get minimal cost, and thus have a guarantee of minimal cost on reaching goal. From this, we know that if we reach the goal, the cost found is the minimal cost. Otherwise, we know that if we exhaust the queue, there is a disjoint in the graph and it is not possible, thus returning -1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by first getting n and goal as the length of the passingFees and the length - 1 respectively. We set a min time for an edge case of 2 cities. Iff we have exactly two cities, \\n- for edge in edges get min time of travel \\n- if min time of travel is greater than maxTime, return -1, else return min_time\\n\\nset a graph as a dictionary of dictionaries \\nfor edge in edges (split into src, dst, time) \\n- if src in graph \\n    - if dst not in graph[src], graph[src][dst] = [time, passingFees[dst]]\\n    - otherwise, graph[src][dst][0] is min of itself and time \\n- otherwise, graph[src][dst] = [time, passingFees[dst]]\\n- and similar for dst to src version \\n\\nWe now have our feasability check. We find minimal departure from src, and minimal arrival for dst via the graph. Then, \\n- if goal in graph[0] \\n    - if min arrival greater than maxTime, return -1 \\n- otherwise, if min_departure + min_arrival is greater than maxTime, return -1 \\n\\nWe can use these since if we are not able to ever arrive, we never will have a satisfactory path \\n\\nSatisfying these, we turn to our set up. We set a time to node array of math.inf of size n, and then set time to node of 0 to 0, since we start there. This will let us keep best paths to each node timewise, which lets us hunt the minimal time path to goal. \\n\\nOur first state in our frontier will be the cost at 0, time at 0 (0) and id of 0 (0). We heappush this into a frontier list. \\n\\nwhile we have a frontier \\n- pop off the cost, time, and node id \\n- if node is goal, return cost \\n- otherwise, get node neighbors via graph[node] \\n- for neighbor in node neighbors \\n    - travel time and travel cost are graph at node at neighbor \\n    - if time + travel time is less than or equal to maxTime and time + travel time is strictly less than time to node at neighbor \\n        - update time to node at neighbor to time plus travel time \\n        - push new state of cost + travel cost, time + travel time, neighbor into frontier \\n    - otherwise, continue \\n\\nif we exhaust the frontier, there was no physical way to reach the goal, return -1      \\n\\n# Complexity\\n- Time complexity: O(E log E)\\n    - We loop over E edges to make the graph \\n    - We loop over potentially V-1 vertices twice to get departure check\\n    - In the frontier loop we again do E work as we may need to travel every edge to determine physical unreachability. This involves pushes into a heap, so this is actually E log E work. \\n    - This gives us a total time complexity of E log E + E + (V-1)\\n    - This reduces to E log E \\n\\n- Space complexity: O(E) \\n    - We store each edge in the graph \\n    - and potentially each edge in the frontier  \\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        # get n and goal \\n        n = len(passingFees)\\n        goal = n - 1 \\n        # set min_time for the use case of only 2 cities \\n        min_time = math.inf\\n        # if only two cities \\n        if n == 2 : \\n            # find the least time cost route \\n            for edge in edges : \\n                min_time = min(edge[2], min_time)\\n            # if least time is out of bounds, no way to do it with two cities \\n            if min_time > maxTime : \\n                return -1 \\n            else : \\n                # otherwise, return sum of passing fees \\n                return sum(passingFees)\\n        # the minimum cost among paths connecting 0 to n - 1 \\n        # built in cost is 0 and n-1 \\n        # all others are optional \\n        # must be a valid path (less than maxTime) \\n        # breadth first search with full edge coverage (must consider all valid edges) \\n        # can be reduced by looking at minimal time edges only and then by getting minimal cost edges \\n        # this can be done by first pruning graph and then by heap based priority queue \\n        graph = collections.defaultdict(dict)\\n        # build graph of edges with costs associated to arrivals \\n        for [src, dst, time] in edges : \\n            if src in graph : \\n                if dst not in graph[src] : \\n                    graph[src][dst] = [time, passingFees[dst]]\\n                else : \\n                    graph[src][dst][0] = min(time, graph[src][dst][0])\\n            else : \\n                graph[src][dst] = [time, passingFees[dst]]\\n            if dst in graph : \\n                if src not in graph[dst] : \\n                    graph[dst][src] = [time, passingFees[src]]\\n                else : \\n                    graph[dst][src][0] = min(time, graph[dst][src][0])\\n            else : \\n                graph[dst][src] = [time, passingFees[src]]\\n        \\n        # find minimal departure\\n        min_departure = math.inf\\n        for node in graph[0] : \\n            min_departure = min(min_departure, graph[0][node][0]) \\n        \\n        # find minimal arrival \\n        min_arrival = math.inf\\n        for node in graph[goal] : \\n            min_arrival = min(min_arrival, graph[goal][node][0])\\n        \\n        if goal in graph[0] : \\n            if min_arrival > maxTime : \\n                return -1 \\n        else : \\n            if min_departure + min_arrival > maxTime : \\n                return -1 \\n\\n        # set up array of time to reach node \\n        time_to_node = [math.inf] * n\\n        # you start here, so your time to reach here is 0 \\n        time_to_node[0] = 0\\n        # set up a frontier \\n        frontier = []\\n        # your first state is the passing fees of the 0th node at time 0 and node 0 \\n        first_state = (passingFees[0], 0, 0)\\n        # heapify on push in \\n        heapq.heappush(frontier, first_state) \\n        # while you have a frontier \\n        while frontier : \\n            # pop the cost, time and node from the heap \\n            cost, time, node = heapq.heappop(frontier)\\n            # if you have reached the goal, based on the priority queue process, cost is your final cost \\n            if node == goal : \\n                return cost \\n            # otherwise, get the neighbors of this node from the graph \\n            node_neighbors = graph[node]\\n            # for each of your node neighbors \\n            for neighbor in node_neighbors : \\n                # get minimal travel time from here to there and minimal cost \\n                travel_time, travel_cost = graph[node][neighbor]\\n                # if travel time is in range and time to node is strictly greater than this time to node \\n                # then we have an improvement on our current time to node and thus an improvement on \\n                # potentially reaching the goal. If this is the case, \\n                if time + travel_time <= maxTime and time_to_node[neighbor] > time + travel_time : \\n                    # update time to node to prevent less succesful trips \\n                    time_to_node[neighbor] = time + travel_time \\n                    # push in a new node of cost + travel cost, time + travel time and neighbor \\n                    heapq.heappush(frontier, ( cost+travel_cost, time + travel_time, neighbor ))\\n        # if we exhaust the heap but do not reach the goal, we never could have reached the goal \\n        # in this case, we return -1 \\n        return -1 \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        # get n and goal \\n        n = len(passingFees)\\n        goal = n - 1 \\n        # set min_time for the use case of only 2 cities \\n        min_time = math.inf\\n        # if only two cities \\n        if n == 2 : \\n            # find the least time cost route \\n            for edge in edges : \\n                min_time = min(edge[2], min_time)\\n            # if least time is out of bounds, no way to do it with two cities \\n            if min_time > maxTime : \\n                return -1 \\n            else : \\n                # otherwise, return sum of passing fees \\n                return sum(passingFees)\\n        # the minimum cost among paths connecting 0 to n - 1 \\n        # built in cost is 0 and n-1 \\n        # all others are optional \\n        # must be a valid path (less than maxTime) \\n        # breadth first search with full edge coverage (must consider all valid edges) \\n        # can be reduced by looking at minimal time edges only and then by getting minimal cost edges \\n        # this can be done by first pruning graph and then by heap based priority queue \\n        graph = collections.defaultdict(dict)\\n        # build graph of edges with costs associated to arrivals \\n        for [src, dst, time] in edges : \\n            if src in graph : \\n                if dst not in graph[src] : \\n                    graph[src][dst] = [time, passingFees[dst]]\\n                else : \\n                    graph[src][dst][0] = min(time, graph[src][dst][0])\\n            else : \\n                graph[src][dst] = [time, passingFees[dst]]\\n            if dst in graph : \\n                if src not in graph[dst] : \\n                    graph[dst][src] = [time, passingFees[src]]\\n                else : \\n                    graph[dst][src][0] = min(time, graph[dst][src][0])\\n            else : \\n                graph[dst][src] = [time, passingFees[src]]\\n        \\n        # find minimal departure\\n        min_departure = math.inf\\n        for node in graph[0] : \\n            min_departure = min(min_departure, graph[0][node][0]) \\n        \\n        # find minimal arrival \\n        min_arrival = math.inf\\n        for node in graph[goal] : \\n            min_arrival = min(min_arrival, graph[goal][node][0])\\n        \\n        if goal in graph[0] : \\n            if min_arrival > maxTime : \\n                return -1 \\n        else : \\n            if min_departure + min_arrival > maxTime : \\n                return -1 \\n\\n        # set up array of time to reach node \\n        time_to_node = [math.inf] * n\\n        # you start here, so your time to reach here is 0 \\n        time_to_node[0] = 0\\n        # set up a frontier \\n        frontier = []\\n        # your first state is the passing fees of the 0th node at time 0 and node 0 \\n        first_state = (passingFees[0], 0, 0)\\n        # heapify on push in \\n        heapq.heappush(frontier, first_state) \\n        # while you have a frontier \\n        while frontier : \\n            # pop the cost, time and node from the heap \\n            cost, time, node = heapq.heappop(frontier)\\n            # if you have reached the goal, based on the priority queue process, cost is your final cost \\n            if node == goal : \\n                return cost \\n            # otherwise, get the neighbors of this node from the graph \\n            node_neighbors = graph[node]\\n            # for each of your node neighbors \\n            for neighbor in node_neighbors : \\n                # get minimal travel time from here to there and minimal cost \\n                travel_time, travel_cost = graph[node][neighbor]\\n                # if travel time is in range and time to node is strictly greater than this time to node \\n                # then we have an improvement on our current time to node and thus an improvement on \\n                # potentially reaching the goal. If this is the case, \\n                if time + travel_time <= maxTime and time_to_node[neighbor] > time + travel_time : \\n                    # update time to node to prevent less succesful trips \\n                    time_to_node[neighbor] = time + travel_time \\n                    # push in a new node of cost + travel cost, time + travel time and neighbor \\n                    heapq.heappush(frontier, ( cost+travel_cost, time + travel_time, neighbor ))\\n        # if we exhaust the heap but do not reach the goal, we never could have reached the goal \\n        # in this case, we return -1 \\n        return -1 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383176,
                "title": "c-easy-solution-dijkastra-priority-queue-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using dijkastra\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        map<int,vector<pair<int,int>>> mp;\\n        vector<int> dist(n,INT_MAX);\\n        vector<int> time(n,INT_MAX);\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            mp[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        dist[0]=passingFees[0];\\n        q.push({dist[0],{0,0}});\\n        while(!q.empty()){\\n            int fee=q.top().first;\\n            int dis=q.top().second.first;\\n            int node=q.top().second.second;\\n            q.pop();\\n            for(auto it:mp[node]){\\n                int next_dis=dis+it.second;\\n                if(next_dis<=maxTime ){\\n                        //explore if current fee is less than dist[it.first]\\n                    if(fee+passingFees[it.first]<dist[it.first]){\\n                        dist[it.first]=fee+passingFees[it.first];\\n                        time[it.first]=dis+it.second;\\n                         q.push({dist[it.first],{time[it.first],it.first}});                   \\n                    }else if(time[it.first]>dis+it.second){\\n                         //explore path if time is less than time[it.first] because now fee is high but after some exploration it may be reduce\\n                        int cost=fee+passingFees[it.first];\\n                        time[it.first]=dis+it.second;\\n                        q.push({cost,{time[it.first],it.first}});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        if(dist[n-1]==INT_MAX){\\n            return -1;\\n        }\\n        return dist[n-1];\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using dijkastra\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        map<int,vector<pair<int,int>>> mp;\\n        vector<int> dist(n,INT_MAX);\\n        vector<int> time(n,INT_MAX);\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            mp[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        dist[0]=passingFees[0];\\n        q.push({dist[0],{0,0}});\\n        while(!q.empty()){\\n            int fee=q.top().first;\\n            int dis=q.top().second.first;\\n            int node=q.top().second.second;\\n            q.pop();\\n            for(auto it:mp[node]){\\n                int next_dis=dis+it.second;\\n                if(next_dis<=maxTime ){\\n                        //explore if current fee is less than dist[it.first]\\n                    if(fee+passingFees[it.first]<dist[it.first]){\\n                        dist[it.first]=fee+passingFees[it.first];\\n                        time[it.first]=dis+it.second;\\n                         q.push({dist[it.first],{time[it.first],it.first}});                   \\n                    }else if(time[it.first]>dis+it.second){\\n                         //explore path if time is less than time[it.first] because now fee is high but after some exploration it may be reduce\\n                        int cost=fee+passingFees[it.first];\\n                        time[it.first]=dis+it.second;\\n                        q.push({cost,{time[it.first],it.first}});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        if(dist[n-1]==INT_MAX){\\n            return -1;\\n        }\\n        return dist[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239831,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_cost(max_time: i32, edges: Vec<Vec<i32>>, passing_fees: Vec<i32>) -> i32 {\\n        fn solve(dp: &mut Vec<Vec<i32>>, time: i32, adj: &Vec<Vec<(i32, i32)>>, v: i32, pass: &Vec<i32>) -> i32 {\\n            if time < 0 {\\n                return std::i32::MAX;\\n            }\\n            let n = pass.len() as i32;\\n            if v == n - 1 {\\n                return pass[v as usize];\\n            }\\n            if dp[v as usize][time as usize] != -1 {\\n                return dp[v as usize][time as usize];\\n            }\\n            let mut cost = std::i32::MAX;\\n            for x in &adj[v as usize] {\\n                let u = x.0;\\n                let temp = x.1;\\n                if temp <= time {\\n                    let sol = solve(dp, time - temp, adj, u, pass);\\n                    cost = cost.min(sol);\\n                }\\n            }\\n            if cost == std::i32::MAX {\\n                dp[v as usize][time as usize] = std::i32::MAX;\\n                return std::i32::MAX;\\n            }\\n            dp[v as usize][time as usize] = cost + pass[v as usize];\\n            dp[v as usize][time as usize]\\n        }\\n\\n        let mut dp = vec![vec![-1; 1001]; 1001];\\n        let n = passing_fees.len();\\n        let mut adj = vec![vec![]; n];\\n        for edge in edges.iter() {\\n            let x = edge[0] as usize;\\n            let y = edge[1] as usize;\\n            let time = edge[2];\\n            adj[x].push((y as i32, time));\\n            adj[y].push((x as i32, time));\\n        }\\n        let ans = solve(&mut dp, max_time, &adj, 0, &passing_fees);\\n        if ans == std::i32::MAX {\\n            return -1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(max_time: i32, edges: Vec<Vec<i32>>, passing_fees: Vec<i32>) -> i32 {\\n        fn solve(dp: &mut Vec<Vec<i32>>, time: i32, adj: &Vec<Vec<(i32, i32)>>, v: i32, pass: &Vec<i32>) -> i32 {\\n            if time < 0 {\\n                return std::i32::MAX;\\n            }\\n            let n = pass.len() as i32;\\n            if v == n - 1 {\\n                return pass[v as usize];\\n            }\\n            if dp[v as usize][time as usize] != -1 {\\n                return dp[v as usize][time as usize];\\n            }\\n            let mut cost = std::i32::MAX;\\n            for x in &adj[v as usize] {\\n                let u = x.0;\\n                let temp = x.1;\\n                if temp <= time {\\n                    let sol = solve(dp, time - temp, adj, u, pass);\\n                    cost = cost.min(sol);\\n                }\\n            }\\n            if cost == std::i32::MAX {\\n                dp[v as usize][time as usize] = std::i32::MAX;\\n                return std::i32::MAX;\\n            }\\n            dp[v as usize][time as usize] = cost + pass[v as usize];\\n            dp[v as usize][time as usize]\\n        }\\n\\n        let mut dp = vec![vec![-1; 1001]; 1001];\\n        let n = passing_fees.len();\\n        let mut adj = vec![vec![]; n];\\n        for edge in edges.iter() {\\n            let x = edge[0] as usize;\\n            let y = edge[1] as usize;\\n            let time = edge[2];\\n            adj[x].push((y as i32, time));\\n            adj[y].push((x as i32, time));\\n        }\\n        let ans = solve(&mut dp, max_time, &adj, 0, &passing_fees);\\n        if ans == std::i32::MAX {\\n            return -1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196747,
                "title": "python-straight-forward-dp-easy-to-understand-but-slow-and-memory-consuming",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(t \\\\cdot V \\\\cdot E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V \\\\cdot E + t \\\\cdot V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinValue(dict):\\n    def __setitem__(self, key, value, /):\\n        if value < self.get(key, inf):\\n            super().__setitem__(key, value)\\n\\n\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], F: List[int]) -> int:\\n        M = [MinValue() for _ in range(len(F))]\\n        for i, j, t in edges:\\n            M[i][j] = M[j][i] = t\\n\\n        @cache\\n        def dp(t, i):\\n            if t >= 0 and i == 0:\\n                return F[0]\\n            cost = inf\\n            for j, dt in M[i].items():\\n                t_ = t - dt\\n                if t_ >= 0:\\n                    cost = min(cost, dp(t_, j))\\n            return cost + F[i]\\n\\n        ans = dp(maxTime, len(F)-1)\\n        return -1 if ans == inf else ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass MinValue(dict):\\n    def __setitem__(self, key, value, /):\\n        if value < self.get(key, inf):\\n            super().__setitem__(key, value)\\n\\n\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], F: List[int]) -> int:\\n        M = [MinValue() for _ in range(len(F))]\\n        for i, j, t in edges:\\n            M[i][j] = M[j][i] = t\\n\\n        @cache\\n        def dp(t, i):\\n            if t >= 0 and i == 0:\\n                return F[0]\\n            cost = inf\\n            for j, dt in M[i].items():\\n                t_ = t - dt\\n                if t_ >= 0:\\n                    cost = min(cost, dp(t_, j))\\n            return cost + F[i]\\n\\n        ans = dp(maxTime, len(F)-1)\\n        return -1 if ans == inf else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054318,
                "title": "c-solution-dijkstra",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<int> cost(n, INT_MAX);\\n        vector<int> time(n, INT_MAX);\\n        \\n        vector<pair<int,int>> adj[n+1];\\n        for(auto i: edges) {\\n            int u = i[0], v =  i[1], t = i[2];\\n            adj[u].push_back({v, t});\\n            adj[v].push_back({u, t});\\n        }\\n\\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({cost[0], {time[0], 0}});\\n\\n        while(!pq.empty()) {\\n            auto p = pq.top();\\n            pq.pop();\\n\\n            int pay = p.first, tim = p.second.first, node = p.second.second;\\n            \\n            for(auto i: adj[node]) {\\n                int v = i.first, t = i.second;\\n                if(pay + passingFees[v] <= cost[v] and t + tim <= maxTime) {\\n                    cost[v] = pay + passingFees[v];\\n                    time[v] = t + tim;\\n                    pq.push({cost[v], {time[v], v}});\\n                } else if(t + tim < time[v]) { // if still the time is less than the first calculated node\\n                    time[v] = t + tim;\\n                    pq.push({pay + passingFees[v], {time[v], v}});\\n                }\\n            }\\n        }\\n\\n        return cost[n - 1] == INT_MAX ? -1 : cost[n - 1] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<int> cost(n, INT_MAX);\\n        vector<int> time(n, INT_MAX);\\n        \\n        vector<pair<int,int>> adj[n+1];\\n        for(auto i: edges) {\\n            int u = i[0], v =  i[1], t = i[2];\\n            adj[u].push_back({v, t});\\n            adj[v].push_back({u, t});\\n        }\\n\\n        cost[0] = passingFees[0];\\n        time[0] = 0;\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({cost[0], {time[0], 0}});\\n\\n        while(!pq.empty()) {\\n            auto p = pq.top();\\n            pq.pop();\\n\\n            int pay = p.first, tim = p.second.first, node = p.second.second;\\n            \\n            for(auto i: adj[node]) {\\n                int v = i.first, t = i.second;\\n                if(pay + passingFees[v] <= cost[v] and t + tim <= maxTime) {\\n                    cost[v] = pay + passingFees[v];\\n                    time[v] = t + tim;\\n                    pq.push({cost[v], {time[v], v}});\\n                } else if(t + tim < time[v]) { // if still the time is less than the first calculated node\\n                    time[v] = t + tim;\\n                    pq.push({pay + passingFees[v], {time[v], v}});\\n                }\\n            }\\n        }\\n\\n        return cost[n - 1] == INT_MAX ? -1 : cost[n - 1] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040775,
                "title": "dfs-dp-c-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1001][1001];\\n\\n    ll solve(vector<pair<ll,ll>>adj[],ll curr,ll maxtime,vector<int>&passingFees,ll n){\\n        if(curr==n-1){\\n            return passingFees[n-1];\\n        }\\n        if(dp[curr][maxtime]!=-1){\\n            return dp[curr][maxtime];\\n        }\\n        ll answer=INT_MAX;\\n        for(auto &x:adj[curr]){\\n            if(maxtime>=x.second){\\n                answer=min(answer,passingFees[curr]+solve(adj,x.first,maxtime-x.second,passingFees,n));\\n            }\\n        }\\n        return dp[curr][maxtime]=answer;\\n    }\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        ll n=passingFees.size(),maxtime=maxTime;\\n        memset(dp,-1,sizeof(dp));\\n        vector<pair<ll,ll>>adj[n];\\n        for(auto &x:edges){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        ll answer=solve(adj,0,maxtime,passingFees,n);\\n        return (answer==INT_MAX?-1:answer);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1001][1001];\\n\\n    ll solve(vector<pair<ll,ll>>adj[],ll curr,ll maxtime,vector<int>&passingFees,ll n){\\n        if(curr==n-1){\\n            return passingFees[n-1];\\n        }\\n        if(dp[curr][maxtime]!=-1){\\n            return dp[curr][maxtime];\\n        }\\n        ll answer=INT_MAX;\\n        for(auto &x:adj[curr]){\\n            if(maxtime>=x.second){\\n                answer=min(answer,passingFees[curr]+solve(adj,x.first,maxtime-x.second,passingFees,n));\\n            }\\n        }\\n        return dp[curr][maxtime]=answer;\\n    }\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        ll n=passingFees.size(),maxtime=maxTime;\\n        memset(dp,-1,sizeof(dp));\\n        vector<pair<ll,ll>>adj[n];\\n        for(auto &x:edges){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        ll answer=solve(adj,0,maxtime,passingFees,n);\\n        return (answer==INT_MAX?-1:answer);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960443,
                "title": "simple-c-solution-with-inline-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int numCities = passingFees.size();\\n        vector<vector<pair<int, int>>> graphEdges(numCities);\\n        for (auto & vec: edges) {\\n            graphEdges[vec[0]].emplace_back(vec[1], vec[2]);\\n            graphEdges[vec[1]].emplace_back(vec[0], vec[2]);\\n        }\\n        vector<int> timeTaken(numCities);\\n        typedef tuple<int,int,int> CostVertexTime;\\n        //standard PQ is ordered less, need to do greater. \\n        priority_queue<CostVertexTime, vector<CostVertexTime>, greater<>> pQ;\\n        pQ.emplace(passingFees[0], 0, 0);\\n        while (!pQ.empty()) {\\n            auto [currCost, currVertex, currTime]  = pQ.top(); pQ.pop();\\n            //if you reach the same node again, only process if new time is less than prior time\\n            //this is the ONLY difference between this problem and standard shortest paths\\n            //that\\'s because you can get into a scenario where you reached an intermediate vertex with less cost\\n            //but later crossed the max time and hence couldn\\'t reach destination\\n            //another path may cross the same vertex with higher cost but in less time and thus still create more possibilities\\n            if (timeTaken[currVertex] != 0 && currTime >= timeTaken[currVertex]) continue;\\n            timeTaken[currVertex] = currTime;\\n            if (currVertex == numCities-1) return currCost;\\n            for (auto & p: graphEdges[currVertex]) {\\n                if (timeTaken[p.first] != 0 && currTime + p.second >= timeTaken[p.first]) continue;\\n                if ((p.second + currTime) > maxTime) continue;\\n                pQ.emplace(passingFees[p.first] + currCost, p.first, currTime + p.second);\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int numCities = passingFees.size();\\n        vector<vector<pair<int, int>>> graphEdges(numCities);\\n        for (auto & vec: edges) {\\n            graphEdges[vec[0]].emplace_back(vec[1], vec[2]);\\n            graphEdges[vec[1]].emplace_back(vec[0], vec[2]);\\n        }\\n        vector<int> timeTaken(numCities);\\n        typedef tuple<int,int,int> CostVertexTime;\\n        //standard PQ is ordered less, need to do greater. \\n        priority_queue<CostVertexTime, vector<CostVertexTime>, greater<>> pQ;\\n        pQ.emplace(passingFees[0], 0, 0);\\n        while (!pQ.empty()) {\\n            auto [currCost, currVertex, currTime]  = pQ.top(); pQ.pop();\\n            //if you reach the same node again, only process if new time is less than prior time\\n            //this is the ONLY difference between this problem and standard shortest paths\\n            //that\\'s because you can get into a scenario where you reached an intermediate vertex with less cost\\n            //but later crossed the max time and hence couldn\\'t reach destination\\n            //another path may cross the same vertex with higher cost but in less time and thus still create more possibilities\\n            if (timeTaken[currVertex] != 0 && currTime >= timeTaken[currVertex]) continue;\\n            timeTaken[currVertex] = currTime;\\n            if (currVertex == numCities-1) return currCost;\\n            for (auto & p: graphEdges[currVertex]) {\\n                if (timeTaken[p.first] != 0 && currTime + p.second >= timeTaken[p.first]) continue;\\n                if ((p.second + currTime) > maxTime) continue;\\n                pQ.emplace(passingFees[p.first] + currCost, p.first, currTime + p.second);\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2899499,
                "title": "simple-dart-solution-a-hard-question-is-the-complexity",
                "content": "# Intuition\\nA simple solution can be built on the top of the standard Dijkstra algorithm. \\n\\n# Approach\\n\\nIgnore items from the Dijkstra queue when we run out of time, and instead of the \"Set of visited\" items - use two values, the min cost and min time required to get to the node. Any new candidate from the BFS should improve either cost or time. If not - ignore it since in no way this can improve our results.\\n\\nIn the implementation I used SplayTreeMap sice LeetCode does not allow import of the priority queue from the collection package.\\n\\n# Complexity\\nHard question. \\nLiterally we use Djikstra algorithm multimple times whenever we run out of the given maxTime - algorithm reverts to less optimal by the cost factor but more optimal by the time factor. so the result can be something like X * E * Log(Y).\\nQueue can hold same node with different time spent - so I used Y instead of N.\\n\\nmy guess for the time complexity:  N * E * log(N)\\n\\n\\n\\n# Code\\n```\\n\\nimport \\'dart:collection\\';\\n\\nclass QueueData {\\n  int node;\\n  int cost;\\n  int time;\\n  QueueData(this.node, this.cost, this.time);\\n}\\n\\nclass Solution {\\n  int minCost(int maxTime, List<List<int>> edges, List<int> passingFees) {\\n    int N = passingFees.length;\\n    final graph = List<List<List<int>>>.generate( // build graph - O(E)\\n        N, (index) => List<List<int>>.empty(growable: true));\\n    edges.forEach((e) {\\n      graph[e[0]].add([e[1], e[2]]);\\n      graph[e[1]].add([e[0], e[2]]);\\n    });\\n\\n    final minTime = List<int>.filled(N, -1);\\n    final minCost = List<int>.filled(N, -1);\\n    final queue = SplayTreeSet<QueueData>((a, b) =>\\n        a.cost == b.cost ? a.time.compareTo(b.time) : a.cost.compareTo(b.cost));\\n    queue.add(QueueData(0, passingFees[0], 0));\\n    while (queue.isNotEmpty) {\\n      final firstNode = queue.first;\\n      queue.remove(firstNode);\\n      // if we are out of time - ignore this BFS item\\n      if (firstNode.time > maxTime) continue;\\n      if (firstNode.node == N - 1) return firstNode.cost;\\n      graph[firstNode.node].forEach((n) {\\n        // either time of cost should be less then from the previous node visit\\n        // this prevents cycles and works pretty much like the \\n        // set of visited nodes from the standard Dijkstra algorithm \\n        if (minTime[n[0]] == -1 || \\n            (firstNode.cost + passingFees[n[0]] < minCost[n[0]] ||\\n                firstNode.time + n[1] < minTime[n[0]])) {\\n          int t = firstNode.time + n[1];\\n          int c = firstNode.cost + passingFees[n[0]];\\n          minTime[n[0]] = minTime[n[0]] == -1 ? t : min(t, minTime[n[0]]);\\n\\n          minCost[n[0]] = minCost[n[0]] == -1 ? c : min(c, minCost[n[0]]);\\n          queue.add(QueueData(n[0], c, t));\\n        }\\n      });\\n    }\\n    return -1;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nimport \\'dart:collection\\';\\n\\nclass QueueData {\\n  int node;\\n  int cost;\\n  int time;\\n  QueueData(this.node, this.cost, this.time);\\n}\\n\\nclass Solution {\\n  int minCost(int maxTime, List<List<int>> edges, List<int> passingFees) {\\n    int N = passingFees.length;\\n    final graph = List<List<List<int>>>.generate( // build graph - O(E)\\n        N, (index) => List<List<int>>.empty(growable: true));\\n    edges.forEach((e) {\\n      graph[e[0]].add([e[1], e[2]]);\\n      graph[e[1]].add([e[0], e[2]]);\\n    });\\n\\n    final minTime = List<int>.filled(N, -1);\\n    final minCost = List<int>.filled(N, -1);\\n    final queue = SplayTreeSet<QueueData>((a, b) =>\\n        a.cost == b.cost ? a.time.compareTo(b.time) : a.cost.compareTo(b.cost));\\n    queue.add(QueueData(0, passingFees[0], 0));\\n    while (queue.isNotEmpty) {\\n      final firstNode = queue.first;\\n      queue.remove(firstNode);\\n      // if we are out of time - ignore this BFS item\\n      if (firstNode.time > maxTime) continue;\\n      if (firstNode.node == N - 1) return firstNode.cost;\\n      graph[firstNode.node].forEach((n) {\\n        // either time of cost should be less then from the previous node visit\\n        // this prevents cycles and works pretty much like the \\n        // set of visited nodes from the standard Dijkstra algorithm \\n        if (minTime[n[0]] == -1 || \\n            (firstNode.cost + passingFees[n[0]] < minCost[n[0]] ||\\n                firstNode.time + n[1] < minTime[n[0]])) {\\n          int t = firstNode.time + n[1];\\n          int c = firstNode.cost + passingFees[n[0]];\\n          minTime[n[0]] = minTime[n[0]] == -1 ? t : min(t, minTime[n[0]]);\\n\\n          minCost[n[0]] = minCost[n[0]] == -1 ? c : min(c, minCost[n[0]]);\\n          queue.add(QueueData(n[0], c, t));\\n        }\\n      });\\n    }\\n    return -1;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883927,
                "title": "python-dijkstra-s-algorithm-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it is a minimum cost of path problem, my first intuition was Dijkstra\\'s Algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to modify Dijkstra\\'s Algorithm a bit to accomodate for fee to pass a city in the min heap. We also update the minimum fees to complete in a separae array while keeping track of minimum time in the min heap.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        fee = [float(\"inf\") for i in range(n)]# the final fee\\n        heap, graph = [(0, passingFees[0], 0)], collections.defaultdict(list)\\n        for start, end, time in edges:\\n            graph[start].append((end, time))\\n            graph[end].append((start, time))\\n        while heap:\\n            curTime, curFee, curNode = heappop(heap)\\n            if fee[curNode] <= curFee:\\n                continue\\n            fee[curNode] = curFee\\n            for neighbor, time in graph[curNode]:\\n                if time + curTime <= maxTime:\\n                    heappush(heap, (time + curTime, curFee + passingFees[neighbor], neighbor))\\n        return fee[-1] if fee[-1] != float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Graph",
                    "Biconnected Component"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        fee = [float(\"inf\") for i in range(n)]# the final fee\\n        heap, graph = [(0, passingFees[0], 0)], collections.defaultdict(list)\\n        for start, end, time in edges:\\n            graph[start].append((end, time))\\n            graph[end].append((start, time))\\n        while heap:\\n            curTime, curFee, curNode = heappop(heap)\\n            if fee[curNode] <= curFee:\\n                continue\\n            fee[curNode] = curFee\\n            for neighbor, time in graph[curNode]:\\n                if time + curTime <= maxTime:\\n                    heappush(heap, (time + curTime, curFee + passingFees[neighbor], neighbor))\\n        return fee[-1] if fee[-1] != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841255,
                "title": "python-dijkstra-s-algorithm-36-time-8-space",
                "content": "```python []\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        mat = {}\\n        for x, y, time in edges:\\n            if x not in mat: mat[x] = set()\\n            if y not in mat: mat[y] = set()\\n            mat[x].add((y, time))\\n            mat[y].add((x, time))\\n\\n        h = [(passingFees[0], 0, 0)]\\n        visited = set()\\n        while h:\\n            fees, time_so_far, city = heappop(h)\\n            if time_so_far > maxTime: continue\\n            if city == n - 1: return fees\\n\\n            if (city, time_so_far) in visited: continue\\n            visited.add((city, time_so_far))\\n            \\n            for nxt, time_to_travel in mat[city]:\\n                # Check if we are retracing a visited path\\n                if (nxt, time_so_far - time_to_travel) in visited: continue\\n                heappush(h, (fees + passingFees[nxt], time_so_far + time_to_travel, nxt))\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        mat = {}\\n        for x, y, time in edges:\\n            if x not in mat: mat[x] = set()\\n            if y not in mat: mat[y] = set()\\n            mat[x].add((y, time))\\n            mat[y].add((x, time))\\n\\n        h = [(passingFees[0], 0, 0)]\\n        visited = set()\\n        while h:\\n            fees, time_so_far, city = heappop(h)\\n            if time_so_far > maxTime: continue\\n            if city == n - 1: return fees\\n\\n            if (city, time_so_far) in visited: continue\\n            visited.add((city, time_so_far))\\n            \\n            for nxt, time_to_travel in mat[city]:\\n                # Check if we are retracing a visited path\\n                if (nxt, time_so_far - time_to_travel) in visited: continue\\n                heappush(h, (fees + passingFees[nxt], time_so_far + time_to_travel, nxt))\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835639,
                "title": "normal-dp-without-dfs-or-bfs-or-dijkstra",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n        int n = (int)cost.size();\\n        typedef pair<int,int> pii;\\n        vector<vector<pii>>g(n);\\n        for(vector<int>here : edges){\\n            int u = here[0],v = here[1], t = here[2];\\n            g[u].push_back({v,t});\\n            g[v].push_back({u,t});\\n        }\\n        vector<vector<int>> dp(n,vector<int>(maxTime+1,1e9));\\n        dp[0][0]=cost[0];\\n        // for every t and in O(VE) relax everything u can\\n        for(int tnow = 0; tnow<=maxTime; tnow++)for(int v = 0; v<n;v++){\\n            for(auto [x,t] : g[v])if(t+tnow<=maxTime){\\n                dp[x][t+tnow] = min(dp[x][t+tnow],cost[x]+dp[v][tnow]);\\n            }\\n        }\\n        int ans = *min_element(dp[n-1].begin(),dp[n-1].end());\\n        return (ans>=1e9 ? -1 : ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n        int n = (int)cost.size();\\n        typedef pair<int,int> pii;\\n        vector<vector<pii>>g(n);\\n        for(vector<int>here : edges){\\n            int u = here[0],v = here[1], t = here[2];\\n            g[u].push_back({v,t});\\n            g[v].push_back({u,t});\\n        }\\n        vector<vector<int>> dp(n,vector<int>(maxTime+1,1e9));\\n        dp[0][0]=cost[0];\\n        // for every t and in O(VE) relax everything u can\\n        for(int tnow = 0; tnow<=maxTime; tnow++)for(int v = 0; v<n;v++){\\n            for(auto [x,t] : g[v])if(t+tnow<=maxTime){\\n                dp[x][t+tnow] = min(dp[x][t+tnow],cost[x]+dp[v][tnow]);\\n            }\\n        }\\n        int ans = *min_element(dp[n-1].begin(),dp[n-1].end());\\n        return (ans>=1e9 ? -1 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818010,
                "title": "c-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int T, vector<vector<int>>& E, vector<int>& F) {\\n        unordered_map<int, unordered_map<int, int>> g;\\n        for(auto & e : E) {\\n            if(g[e[0]].find(e[1]) == g[e[0]].end()) g[e[0]][e[1]] = e[2];\\n            else g[e[0]][e[1]] = min(g[e[0]][e[1]], e[2]);\\n            if(g[e[1]].find(e[0]) == g[e[1]].end()) g[e[1]][e[0]] = e[2];\\n            else g[e[1]][e[0]] = min(g[e[1]][e[0]], e[2]);\\n        }\\n\\n        priority_queue<array<int, 3>> pq;\\n        pq.push({-F[0], 0, 0});\\n\\n        int N = F.size();\\n        vector<int> cost(N, INT_MAX), time(N, INT_MAX);\\n        cost[0] = F[0];\\n        time[0] = 0;\\n\\n        while(!pq.empty()) {\\n            auto cur = pq.top(); pq.pop();\\n            if(cur[2] == N-1) return -cur[0];\\n            if(g.find(cur[2]) == g.end()) continue;\\n            for(auto& [node, t_nxt] : g[cur[2]]) {\\n                int c = -cur[0]+ F[node];\\n                int t = cur[1] + t_nxt;\\n                if(t <= T && (t < time[node] || c < cost[node])) {\\n                    cost[node] = min(cost[node], c);\\n                    time[node] = min(time[node], t);\\n                    pq.push({-c, t, node});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int T, vector<vector<int>>& E, vector<int>& F) {\\n        unordered_map<int, unordered_map<int, int>> g;\\n        for(auto & e : E) {\\n            if(g[e[0]].find(e[1]) == g[e[0]].end()) g[e[0]][e[1]] = e[2];\\n            else g[e[0]][e[1]] = min(g[e[0]][e[1]], e[2]);\\n            if(g[e[1]].find(e[0]) == g[e[1]].end()) g[e[1]][e[0]] = e[2];\\n            else g[e[1]][e[0]] = min(g[e[1]][e[0]], e[2]);\\n        }\\n\\n        priority_queue<array<int, 3>> pq;\\n        pq.push({-F[0], 0, 0});\\n\\n        int N = F.size();\\n        vector<int> cost(N, INT_MAX), time(N, INT_MAX);\\n        cost[0] = F[0];\\n        time[0] = 0;\\n\\n        while(!pq.empty()) {\\n            auto cur = pq.top(); pq.pop();\\n            if(cur[2] == N-1) return -cur[0];\\n            if(g.find(cur[2]) == g.end()) continue;\\n            for(auto& [node, t_nxt] : g[cur[2]]) {\\n                int c = -cur[0]+ F[node];\\n                int t = cur[1] + t_nxt;\\n                if(t <= T && (t < time[node] || c < cost[node])) {\\n                    cost[node] = min(cost[node], c);\\n                    time[node] = min(time[node], t);\\n                    pq.push({-c, t, node});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768345,
                "title": "video-walkthrough-10-line-solution-python",
                "content": "https://youtu.be/O_8D97luwzU\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        G, C, DST, pq = [[] for _ in passingFees], [float(\"inf\")] * len(passingFees), len(passingFees) - 1, [(passingFees[0],0, 0)]\\n        for u,v, t in edges: G[u].append((v,t)), G[v].append((u,t))\\n        while pq: \\n            w_u, u, t_u = heapq.heappop(pq)\\n            if u == DST: return w_u\\n            if t_u >= C[u]: continue\\n            C[u] = t_u\\n            for v, t_v in G[u]:\\n                if t_u + t_v <= maxTime: heapq.heappush(pq,(w_u + passingFees[v], v, t_u + t_v))\\n        return -1\\n```\\n    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        G, C, DST, pq = [[] for _ in passingFees], [float(\"inf\")] * len(passingFees), len(passingFees) - 1, [(passingFees[0],0, 0)]\\n        for u,v, t in edges: G[u].append((v,t)), G[v].append((u,t))\\n        while pq: \\n            w_u, u, t_u = heapq.heappop(pq)\\n            if u == DST: return w_u\\n            if t_u >= C[u]: continue\\n            C[u] = t_u\\n            for v, t_v in G[u]:\\n                if t_u + t_v <= maxTime: heapq.heappush(pq,(w_u + passingFees[v], v, t_u + t_v))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710030,
                "title": "easy-c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long dp[1001][1001];\\n    vector<pair<int,int>> ed[1001];\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n         memset(dp,-1,sizeof(dp));\\n         int n = passingFees.size();\\n         for(int i=0; i<edges.size(); i++) {\\n               ed[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n               ed[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n         }\\n         long ans = solve(0,maxTime,passingFees);\\n         return ans == INT_MAX ? -1 : ans;\\n    }\\n    long solve(int src,int time,vector<int> &fees) {\\n         if(src == fees.size() - 1) return fees[src];\\n         if(dp[src][time]!=-1) return dp[src][time];\\n         long  cnt = INT_MAX;\\n         for(auto e : ed[src]) {\\n              if(time-e.second>=0) {\\n                   cnt = min(cnt,fees[src]+solve(e.first,time-e.second,fees));\\n              }\\n         }\\n        return dp[src][time] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[1001][1001];\\n    vector<pair<int,int>> ed[1001];\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n         memset(dp,-1,sizeof(dp));\\n         int n = passingFees.size();\\n         for(int i=0; i<edges.size(); i++) {\\n               ed[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n               ed[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n         }\\n         long ans = solve(0,maxTime,passingFees);\\n         return ans == INT_MAX ? -1 : ans;\\n    }\\n    long solve(int src,int time,vector<int> &fees) {\\n         if(src == fees.size() - 1) return fees[src];\\n         if(dp[src][time]!=-1) return dp[src][time];\\n         long  cnt = INT_MAX;\\n         for(auto e : ed[src]) {\\n              if(time-e.second>=0) {\\n                   cnt = min(cnt,fees[src]+solve(e.first,time-e.second,fees));\\n              }\\n         }\\n        return dp[src][time] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708748,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        int n = passingFees.size();\\n        \\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        for(auto &x: edges)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector<int> times(n,-1);\\n        \\n       priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        \\n       \\n        \\n        pq.push({passingFees[0],0,0});\\n        \\n        while(!pq.empty())\\n        {\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            int cost = cur[0],time = cur[1], node = cur[2];\\n            \\n            if(time > maxTime)\\n            {\\n                continue;\\n            }\\n             if(node == n-1)\\n            {\\n                return cost;\\n            }\\n            \\n            if(times[node] != -1 && times[node] <= time)\\n            {\\n                continue;\\n            }\\n            times[node] = time;\\n            \\n            for(auto &x: graph[node])\\n            {\\n                int new_time = time + x.second;\\n                \\n                pq.push({cost+passingFees[x.first],new_time,x.first});\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        int n = passingFees.size();\\n        \\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        for(auto &x: edges)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2688093,
                "title": "python-modified-djikstra-s",
                "content": "```\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        adj, cost = defaultdict(list), [-1]*len(passingFees)\\n        for u,v,t in edges:\\n            adj[u].append([v, t])\\n            adj[v].append([u, t])\\n        \\n        heap = [[0, passingFees[0], 0]]\\n        while heap:\\n            t, currentcost, node = heapq.heappop(heap)\\n            if cost[node] < 0 or currentcost < cost[node]:\\n                cost[node] = currentcost\\n                for nei, tt in adj[node]:\\n                    if t + tt <= maxTime:\\n                        heapq.heappush(heap, [t + tt, currentcost + passingFees[nei], nei])\\n        \\n        return cost[len(passingFees)-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        adj, cost = defaultdict(list), [-1]*len(passingFees)\\n        for u,v,t in edges:\\n            adj[u].append([v, t])\\n            adj[v].append([u, t])\\n        \\n        heap = [[0, passingFees[0], 0]]\\n        while heap:\\n            t, currentcost, node = heapq.heappop(heap)\\n            if cost[node] < 0 or currentcost < cost[node]:\\n                cost[node] = currentcost\\n                for nei, tt in adj[node]:\\n                    if t + tt <= maxTime:\\n                        heapq.heappush(heap, [t + tt, currentcost + passingFees[nei], nei])\\n        \\n        return cost[len(passingFees)-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2688051,
                "title": "c-easy-to-understand-dp-solution-similar-approach-as-fibonacci",
                "content": "# Intuition\\nThink along the similar lines of fibonacci. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For any node, the way to reach that node is through its adjacent nodes.\\n2. So to reach node n-1, recurse back for it adjacent nodes and same goes on until the recursion reaches till node 0.\\n3. When recursion call reaches node 0, return just the passing fees of it because it is the starting point.\\n4. Also return the maximum possible passing fees(i.e., INT_MAX) when you run out of allotted maxTime.\\n5. At the end return the minimum cost to reach the given node. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int, int>>>adj;\\n    vector<vector<int>>dp;\\n    \\n    int solve(int v, int time, vector<int>& fees){\\n        if(time < 0){\\n            return INT_MAX;\\n        }\\n        if(v == 0){\\n            return fees[0];\\n        }\\n        if(dp[v][time]!=-1){\\n            return dp[v][time];\\n        }\\n        int cost = INT_MAX;\\n        for(auto next:adj[v]){\\n            int u = next.first;\\n            int nextTime = next.second;\\n            cost = min(cost, solve(u, time-nextTime, fees));\\n        }\\n        if(cost == INT_MAX){\\n            return dp[v][time] = INT_MAX;\\n        }\\n        return dp[v][time] = cost + fees[v];\\n    }\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        adj.resize(n);\\n        dp.resize(n, vector<int>(maxTime+1, -1));\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        \\n        int ans = solve(n-1, maxTime, passingFees);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int, int>>>adj;\\n    vector<vector<int>>dp;\\n    \\n    int solve(int v, int time, vector<int>& fees){\\n        if(time < 0){\\n            return INT_MAX;\\n        }\\n        if(v == 0){\\n            return fees[0];\\n        }\\n        if(dp[v][time]!=-1){\\n            return dp[v][time];\\n        }\\n        int cost = INT_MAX;\\n        for(auto next:adj[v]){\\n            int u = next.first;\\n            int nextTime = next.second;\\n            cost = min(cost, solve(u, time-nextTime, fees));\\n        }\\n        if(cost == INT_MAX){\\n            return dp[v][time] = INT_MAX;\\n        }\\n        return dp[v][time] = cost + fees[v];\\n    }\\n\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        adj.resize(n);\\n        dp.resize(n, vector<int>(maxTime+1, -1));\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        \\n        int ans = solve(n-1, maxTime, passingFees);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685765,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "\\n    def minCost(self, maxTime, edges, passingFees):\\n        dict1, n = defaultdict(list), len(passingFees)\\n        \\n        for i,j,k in edges:\\n            dict1[i].append((j,k))\\n            dict1[j].append((i,k))\\n            \\n        \\n        visited, stack = {i:float(\"inf\") for i in range(n)}, [(passingFees[0],0,0)]\\n        \\n        visited[0] = 0\\n        \\n        while stack:\\n            cost, time, node = heappop(stack)\\n            \\n            if node == n-1:\\n                return cost\\n            \\n            for neighbor in dict1[node]:\\n                if visited[neighbor[0]] > neighbor[1] + time and neighbor[1] + time <= maxTime:\\n                    visited[neighbor[0]] = neighbor[1] + time\\n                    heappush(stack,(cost + passingFees[neighbor[0]],time+neighbor[1],neighbor[0]))\\n                    \\n        return -1",
                "solutionTags": [],
                "code": "\\n    def minCost(self, maxTime, edges, passingFees):\\n        dict1, n = defaultdict(list), len(passingFees)\\n        \\n        for i,j,k in edges:\\n            dict1[i].append((j,k))\\n            dict1[j].append((i,k))\\n            \\n        \\n        visited, stack = {i:float(\"inf\") for i in range(n)}, [(passingFees[0],0,0)]\\n        \\n        visited[0] = 0\\n        \\n        while stack:\\n            cost, time, node = heappop(stack)\\n            \\n            if node == n-1:\\n                return cost\\n            \\n            for neighbor in dict1[node]:\\n                if visited[neighbor[0]] > neighbor[1] + time and neighbor[1] + time <= maxTime:\\n                    visited[neighbor[0]] = neighbor[1] + time\\n                    heappush(stack,(cost + passingFees[neighbor[0]],time+neighbor[1],neighbor[0]))\\n                    \\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 2668271,
                "title": "explanation-why-visited-dp-node-time-is-wrong",
                "content": "With DP of (node, time), if you keep track of visited, you might get the wrong answer. Look at the image below, if you take the higher cost path first and you reach node X at some time T. The cost (X, T) will be stored and fixed without exploring a lower cost path.\\nDP of (node, cost) will work without visited but given the constraints of this problem thats much slower than (node, time)\\n\\n![image.png](https://assets.leetcode.com/users/images/cd86673f-bbca-41cd-853d-830a0ff7619e_1665053908.483594.png)\\n\\nPython Solution with some pruning gets accepted 4900ms\\nWithout any pruning and just dfs + memoization is TLE\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        graph = [dict() for _ in range(n)]\\n        for a,b,travelTime in edges:\\n            graph[a][b] = graph[b][a] = min(travelTime, graph[a].get(b, inf))\\n\\n        #how to solve this problem?\\n        #run dijsktra from target and save Time it takes to reach each node\\n        #if u can not reach source from target in maxTime return -1, otherwise \\n        #run dfs try everyPath and keep track of time (to make sure we dont go over maxTime)\\n        #the only state paratmeters are (c_node, c_time) so u can cache repeated calls\\n        heap = [[0, n-1]]\\n        time = [inf]*n\\n        while heap:\\n            c_time, c_node = heappop(heap)\\n\\n            if time[c_node] != inf: continue\\n            time[c_node] = c_time\\n\\n            for neigh,travelTime in graph[c_node].items():\\n                if time[neigh] == inf:\\n                    heappush(heap, [c_time + travelTime, neigh])\\n        if time[0] > maxTime: return -1\\n\\n        @lru_cache(None)\\n        def dfs(c_node, c_time):\\n            if c_node == n-1: return passingFees[c_node]\\n\\n            res = math.inf\\n\\n            for neigh,travelTime in graph[c_node].items():\\n                if c_time + travelTime + time[neigh] <= maxTime:\\n                    res = min(dfs(neigh, c_time + travelTime), res)\\n            \\n            return res + passingFees[c_node]\\n        \\n        return dfs(0, 0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        graph = [dict() for _ in range(n)]\\n        for a,b,travelTime in edges:\\n            graph[a][b] = graph[b][a] = min(travelTime, graph[a].get(b, inf))\\n\\n        #how to solve this problem?\\n        #run dijsktra from target and save Time it takes to reach each node\\n        #if u can not reach source from target in maxTime return -1, otherwise \\n        #run dfs try everyPath and keep track of time (to make sure we dont go over maxTime)\\n        #the only state paratmeters are (c_node, c_time) so u can cache repeated calls\\n        heap = [[0, n-1]]\\n        time = [inf]*n\\n        while heap:\\n            c_time, c_node = heappop(heap)\\n\\n            if time[c_node] != inf: continue\\n            time[c_node] = c_time\\n\\n            for neigh,travelTime in graph[c_node].items():\\n                if time[neigh] == inf:\\n                    heappush(heap, [c_time + travelTime, neigh])\\n        if time[0] > maxTime: return -1\\n\\n        @lru_cache(None)\\n        def dfs(c_node, c_time):\\n            if c_node == n-1: return passingFees[c_node]\\n\\n            res = math.inf\\n\\n            for neigh,travelTime in graph[c_node].items():\\n                if c_time + travelTime + time[neigh] <= maxTime:\\n                    res = min(dfs(neigh, c_time + travelTime), res)\\n            \\n            return res + passingFees[c_node]\\n        \\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638003,
                "title": "c-code-using-dijkstra-s-algorithm-with-slight-modfication-easy-to-understand",
                "content": "Here if u just write the if conditon the result will be wrong because there will be a path from where u can take minimum cost but in future u might get the time to exceed so u have to also take the case for minimum time as well\\n```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        vector<int>cost(n,INT_MAX);\\n        vector<int>time(n,INT_MAX);\\n        cost[0]=passingFees[0];\\n        time[0]=0;\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({cost[0],0,0});\\n        \\n        while(!pq.empty()){\\n            auto it=pq.top(); pq.pop();\\n            int cost_from_src=it[0];\\n            int time_from_src=it[1];\\n            int src=it[2];\\n            \\n            for(auto i: adj[src]){\\n                \\n                if(time_from_src+i.second<=maxTime){\\n                    // when cost reduces\\n                    if(cost_from_src+passingFees[i.first]<cost[i.first]){\\n                        cost[i.first]=cost_from_src+passingFees[i.first];\\n                        pq.push({cost[i.first],time_from_src+i.second,i.first});\\n                    }\\n                    // when time reduces\\n                    else if(time_from_src+i.second<time[i.first]){\\n                        time[i.first]=time_from_src+i.second;\\n                        pq.push({cost_from_src+passingFees[i.first],time[i.first],i.first});\\n                    }\\n                }\\n            }\\n        }\\n        return cost[n-1]==INT_MAX?-1:cost[n-1];\\n    }",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "Here if u just write the if conditon the result will be wrong because there will be a path from where u can take minimum cost but in future u might get the time to exceed so u have to also take the case for minimum time as well\\n```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        vector<int>cost(n,INT_MAX);\\n        vector<int>time(n,INT_MAX);\\n        cost[0]=passingFees[0];\\n        time[0]=0;\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({cost[0],0,0});\\n        \\n        while(!pq.empty()){\\n            auto it=pq.top(); pq.pop();\\n            int cost_from_src=it[0];\\n            int time_from_src=it[1];\\n            int src=it[2];\\n            \\n            for(auto i: adj[src]){\\n                \\n                if(time_from_src+i.second<=maxTime){\\n                    // when cost reduces\\n                    if(cost_from_src+passingFees[i.first]<cost[i.first]){\\n                        cost[i.first]=cost_from_src+passingFees[i.first];\\n                        pq.push({cost[i.first],time_from_src+i.second,i.first});\\n                    }\\n                    // when time reduces\\n                    else if(time_from_src+i.second<time[i.first]){\\n                        time[i.first]=time_from_src+i.second;\\n                        pq.push({cost_from_src+passingFees[i.first],time[i.first],i.first});\\n                    }\\n                }\\n            }\\n        }\\n        return cost[n-1]==INT_MAX?-1:cost[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2611971,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n     vector<pair<int,int>> mp[1001] ;  \\n    vector<bool>vis;\\n    int n  ;\\n    map<pair<int,int>,int>cost;\\n    int mx = 0  ;\\n    int dp[5001][3001] ; \\n    int solve(int mx , int st,int en,int tot,vector<int>&pass){\\n        \\n        if(mx >=  tot && en == st){\\n            return (pass[0]) ; \\n        }\\n        else if(mx < tot)\\n            return 1e7 ; \\n        \\n        if(dp[st][tot] != -1)\\n            return dp[st][tot] ; \\n        \\n        int ans = 1e7 ; \\n       \\n        for(auto i : mp[st]){\\n                if(tot + i.second <= mx){\\n                int r = pass[i.first] + solve(mx,i.first,en,tot+i.second,pass);\\n                ans = min(ans,r);\\n                }\\n            \\n        }\\n       \\n        return dp[st][tot] = ans ; \\n    }\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        for(auto i : edges){\\n            mp[i[0]].push_back({i[1],i[2]}) ; \\n            mp[i[1]].push_back({i[0],i[2]}) ; \\n            mx = max({mx,i[0],i[1]}) ; \\n            \\n            \\n        }\\n        \\n        n = edges.size() ; \\n        vis.resize(n+1,false) ; \\n        \\n        memset(dp,-1,sizeof(dp))  ; \\n        \\n        int p = solve(maxTime,0,mx,0,passingFees);\\n        if(p >= 1e7)\\n            return -1;\\n        \\n        return p ; \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n     vector<pair<int,int>> mp[1001] ;  \\n    vector<bool>vis;\\n    int n  ;\\n    map<pair<int,int>,int>cost;\\n    int mx = 0  ;\\n    int dp[5001][3001] ; \\n    int solve(int mx , int st,int en,int tot,vector<int>&pass){\\n        \\n        if(mx >=  tot && en == st){\\n            return (pass[0]) ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2511309,
                "title": "one-important-thing-to-notice-hint",
                "content": "Do not only apply **Dijkstra\\'s** Algoritm only on cost, cause time will matter too.\\nLet see by an example:\\nSince we have to reach at the destination with not the minimum time but in just *MaxTime*...\\nLet say for example,  we have to reach till 5 with a maxTime of 10,\\nthere is 2 ways to reach  3rd node with  cost 5 with time 7 and another with cost 10 and time 6.\\nNow if there is a edges between 3 and 4 with time 4 so, \\nIf we have just tried to minimise cost then we would have considered {5, 7} pair [cost,time]\\nand since maxTime is 10 so, 7+4> 10 so you would have returned -1 i.e. we wont be able to reach at all.\\nbut by second way {10,6} we can reach the destination.\\nHope you find it helpful, Please Upvote so more people see it.\\nPlease comment if you find anything incorrect.",
                "solutionTags": [],
                "code": "Do not only apply **Dijkstra\\'s** Algoritm only on cost, cause time will matter too.\\nLet see by an example:\\nSince we have to reach at the destination with not the minimum time but in just *MaxTime*...\\nLet say for example,  we have to reach till 5 with a maxTime of 10,\\nthere is 2 ways to reach  3rd node with  cost 5 with time 7 and another with cost 10 and time 6.\\nNow if there is a edges between 3 and 4 with time 4 so, \\nIf we have just tried to minimise cost then we would have considered {5, 7} pair [cost,time]\\nand since maxTime is 10 so, 7+4> 10 so you would have returned -1 i.e. we wont be able to reach at all.\\nbut by second way {10,6} we can reach the destination.\\nHope you find it helpful, Please Upvote so more people see it.\\nPlease comment if you find anything incorrect.",
                "codeTag": "Unknown"
            },
            {
                "id": 2488821,
                "title": "1928-python",
                "content": "\\tclass Solution:\\n\\t\\tdef minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n\\t\\t\\tstack = [(passingFees[0],0,0)]\\n\\t\\t\\tgraph= defaultdict(list)\\n\\t\\t\\tn = len(passingFees)\\n\\t\\t\\tmincost = [math.inf]*n\\n\\t\\t\\tmintime = [math.inf]*n\\n\\n\\t\\t\\tmincost[0] = passingFees[0]\\n\\t\\t\\tmintime[0] = 0\\n\\n\\t\\t\\tfor i,j,c in edges:\\n\\t\\t\\t\\tgraph[i].append((j,c))\\n\\t\\t\\t\\tgraph[j].append((i,c))\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tcost,node,time = heapq.heappop(stack)\\n\\n\\t\\t\\t\\tfor u,t in graph[node]:\\n\\t\\t\\t\\t\\tif time+t<= maxTime:\\n\\t\\t\\t\\t\\t\\tncost = cost+passingFees[u]\\n\\t\\t\\t\\t\\t\\tntime = time+t\\n\\n\\t\\t\\t\\t\\t\\tif ncost < mincost[u]:\\n\\t\\t\\t\\t\\t\\t\\tmincost[u] = ncost\\n\\t\\t\\t\\t\\t\\t\\tmintime[u] = ntime\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(stack,(ncost,u,ntime))\\n\\n\\t\\t\\t\\t\\t\\telif ntime < mintime[u]:\\n\\t\\t\\t\\t\\t\\t\\tmintime[u] = ntime\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(stack,(ncost,u,ntime))\\n\\t\\t\\treturn mincost[-1] if mincost[-1] != math.inf else -1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n\\t\\t\\tstack = [(passingFees[0],0,0)]\\n\\t\\t\\tgraph= defaultdict(list)\\n\\t\\t\\tn = len(passingFees)\\n\\t\\t\\tmincost = [math.inf]*n\\n\\t\\t\\tmintime = [math.inf]*n\\n\\n\\t\\t\\tmincost[0] = passingFees[0]\\n\\t\\t\\tmintime[0] = 0\\n\\n\\t\\t\\tfor i,j,c in edges:\\n\\t\\t\\t\\tgraph[i].append((j,c))\\n\\t\\t\\t\\tgraph[j].append((i,c))\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tcost,node,time = heapq.heappop(stack)\\n\\n\\t\\t\\t\\tfor u,t in graph[node]:\\n\\t\\t\\t\\t\\tif time+t<= maxTime:\\n\\t\\t\\t\\t\\t\\tncost = cost+passingFees[u]\\n\\t\\t\\t\\t\\t\\tntime = time+t\\n\\n\\t\\t\\t\\t\\t\\tif ncost < mincost[u]:\\n\\t\\t\\t\\t\\t\\t\\tmincost[u] = ncost\\n\\t\\t\\t\\t\\t\\t\\tmintime[u] = ntime\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(stack,(ncost,u,ntime))\\n\\n\\t\\t\\t\\t\\t\\telif ntime < mintime[u]:\\n\\t\\t\\t\\t\\t\\t\\tmintime[u] = ntime\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(stack,(ncost,u,ntime))\\n\\t\\t\\treturn mincost[-1] if mincost[-1] != math.inf else -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2424409,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    long long dfs(int i, vector<int>& passingFees, vector<vector<int>> &dp, vector<vector<int>> graph[], int maxTime)\\n    {\\n        if(i == passingFees.size()-1)\\n            return passingFees[passingFees.size()-1];\\n        if(dp[i][maxTime] != -1)\\n            return dp[i][maxTime];\\n        long long mx = INT_MAX;\\n        for(vector<int> &v : graph[i])\\n        {\\n            if(maxTime-v[1] < 0)\\n                continue;\\n            long long val = (long long)passingFees[i] + dfs(v[0], passingFees, dp, graph, maxTime-v[1]);\\n            if(mx > val)\\n                mx = val;\\n        }\\n        return dp[i][maxTime] = mx;\\n    }\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<vector<int>> graph[n];\\n        for(vector<int> &vec : edges)\\n        {\\n            graph[vec[0]].push_back({vec[1],vec[2]});\\n            graph[vec[1]].push_back({vec[0],vec[2]});\\n        }\\n        vector<vector<int>> dp(n+1, vector<int> (maxTime+1,-1));\\n        long long ans = dfs(0, passingFees, dp, graph, maxTime);\\n        if(ans >= INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long long dfs(int i, vector<int>& passingFees, vector<vector<int>> &dp, vector<vector<int>> graph[], int maxTime)\\n    {\\n        if(i == passingFees.size()-1)\\n            return passingFees[passingFees.size()-1];\\n        if(dp[i][maxTime] != -1)\\n            return dp[i][maxTime];\\n        long long mx = INT_MAX;\\n        for(vector<int> &v : graph[i])\\n        {\\n            if(maxTime-v[1] < 0)\\n                continue;\\n            long long val = (long long)passingFees[i] + dfs(v[0], passingFees, dp, graph, maxTime-v[1]);\\n            if(mx > val)\\n                mx = val;\\n        }\\n        return dp[i][maxTime] = mx;\\n    }\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n = passingFees.size();\\n        vector<vector<int>> graph[n];\\n        for(vector<int> &vec : edges)\\n        {\\n            graph[vec[0]].push_back({vec[1],vec[2]});\\n            graph[vec[1]].push_back({vec[0],vec[2]});\\n        }\\n        vector<vector<int>> dp(n+1, vector<int> (maxTime+1,-1));\\n        long long ans = dfs(0, passingFees, dp, graph, maxTime);\\n        if(ans >= INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317664,
                "title": "dijkstra-0-nlogn",
                "content": "```\\nclass Solution {\\n    //dijsktra\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        //mintime journey complete & passing fees shoud be min\\n        int n=passingFees.length;\\n        List<List<int[]>>gr=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++)\\n            gr.add(new ArrayList<>());\\n        \\n        for(int[]edge:edges){\\n           gr.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n           gr.get(edge[1]).add(new int[]{edge[0],edge[2]});    \\n        }\\n        \\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]-b[1]);//sort on the bases of fees\\n        \\n        int[]time=new int[n];\\n        Arrays.fill(time,Integer.MAX_VALUE);\\n        time[0]=0;\\n        \\n        pq.add(new int[]{0,passingFees[0],0});\\n        \\n        \\n        while(pq.size() > 0){\\n            int[]tmp=pq.remove();\\n            \\n            \\n            if(tmp[2] > maxTime)continue;\\n            \\n            if(tmp[0]==n-1)return tmp[1];\\n              \\n           \\n            for(int[]child:gr.get(tmp[0])){\\n                \\n                     if(time[child[0]] > tmp[2]+child[1]){  //either cost is less or time is less\\n                       time[child[0]]=tmp[2]+child[1];\\n                       int c=tmp[1]+passingFees[child[0]];\\n                        \\n                      pq.add(new int[]{child[0],c,time[child[0]]});\\n                }\\n            }\\n\\n        }\\n        \\n        return -1;\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //dijsktra\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        //mintime journey complete & passing fees shoud be min\\n        int n=passingFees.length;\\n        List<List<int[]>>gr=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++)\\n            gr.add(new ArrayList<>());\\n        \\n        for(int[]edge:edges){\\n           gr.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n           gr.get(edge[1]).add(new int[]{edge[0],edge[2]});    \\n        }\\n        \\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]-b[1]);//sort on the bases of fees\\n        \\n        int[]time=new int[n];\\n        Arrays.fill(time,Integer.MAX_VALUE);\\n        time[0]=0;\\n        \\n        pq.add(new int[]{0,passingFees[0],0});\\n        \\n        \\n        while(pq.size() > 0){\\n            int[]tmp=pq.remove();\\n            \\n            \\n            if(tmp[2] > maxTime)continue;\\n            \\n            if(tmp[0]==n-1)return tmp[1];\\n              \\n           \\n            for(int[]child:gr.get(tmp[0])){\\n                \\n                     if(time[child[0]] > tmp[2]+child[1]){  //either cost is less or time is less\\n                       time[child[0]]=tmp[2]+child[1];\\n                       int c=tmp[1]+passingFees[child[0]];\\n                        \\n                      pq.add(new int[]{child[0],c,time[child[0]]});\\n                }\\n            }\\n\\n        }\\n        \\n        return -1;\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305164,
                "title": "ez-python-dijkstra",
                "content": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \"\"\"\\n            There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself. (no self loops but parallel routes)\\n            \\n            return minimum cost to complete jouney from 0 to n-1 within maxTime time (cost = money paid when you pass a city including source/destination)\\n        \\n            return -1 if not possible to reach\\n        \\n            q. does taking best <time, cost> greedily work? modified dijkistra\\n            a. \\n        \"\"\"\\n        \\n        N = len(passingFees)\\n        \\n        g = defaultdict(list)\\n        \\n        \\n        for u, v, w in edges:\\n            g[u].append([v, w])\\n            g[v].append([u, w])\\n        \\n        \\n        def dij(src, dest):\\n            \\n            pq = [(passingFees[src], 0, src)] # cost, time, curr_node (we are optimizing on cost)\\n            dists = [inf] * N #  this will store shortest known cost\\n            dists[src] = 0 # default \\n            seen = set() #\\n            \\n            while pq:\\n                \\n                cost, time, curr_node = heappop(pq)\\n                \\n                if time > maxTime:\\n                    continue\\n                \\n                if curr_node == dest:\\n                    return cost\\n                \\n                for v, w in g[curr_node]:\\n                    if dists[v] > w + time:\\n                        dists[v] = w + time\\n                        heappush(pq, (cost + passingFees[v], time + w, v))\\n            \\n            \\n            return -1\\n        \\n        return dij(0, N - 1)\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \"\"\"\\n            There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself. (no self loops but parallel routes)\\n            \\n            return minimum cost to complete jouney from 0 to n-1 within maxTime time (cost = money paid when you pass a city including source/destination)\\n        \\n            return -1 if not possible to reach\\n        \\n            q. does taking best <time, cost> greedily work? modified dijkistra\\n            a. \\n        \"\"\"\\n        \\n        N = len(passingFees)\\n        \\n        g = defaultdict(list)\\n        \\n        \\n        for u, v, w in edges:\\n            g[u].append([v, w])\\n            g[v].append([u, w])\\n        \\n        \\n        def dij(src, dest):\\n            \\n            pq = [(passingFees[src], 0, src)] # cost, time, curr_node (we are optimizing on cost)\\n            dists = [inf] * N #  this will store shortest known cost\\n            dists[src] = 0 # default \\n            seen = set() #\\n            \\n            while pq:\\n                \\n                cost, time, curr_node = heappop(pq)\\n                \\n                if time > maxTime:\\n                    continue\\n                \\n                if curr_node == dest:\\n                    return cost\\n                \\n                for v, w in g[curr_node]:\\n                    if dists[v] > w + time:\\n                        dists[v] = w + time\\n                        heappush(pq, (cost + passingFees[v], time + w, v))\\n            \\n            \\n            return -1\\n        \\n        return dij(0, N - 1)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289544,
                "title": "c-code-dijkstra-s-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> adj[1005];\\n    \\n    int minCost(int mxt, vector<vector<int>>& v, vector<int>& val) {\\n        int i;\\n        \\n        for (i=0; i<v.size(); i++){\\n            adj[v[i][0]].push_back({v[i][1],v[i][2]});\\n            adj[v[i][1]].push_back({v[i][0],v[i][2]});\\n        }\\n        \\n        int n=val.size();\\n        vector<int> cost(n+1,1e9+5),tame(n+1,1e9+5);\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        q.push({val[0],{0,0}});\\n        \\n        cost[0]=val[0];\\n        tame[0]=0;\\n        \\n        while (!q.empty()){\\n            pair<int,pair<int,int>> p=q.top();\\n            q.pop();\\n            \\n            int node=p.second.first;\\n            int time=p.second.second;\\n            int cst=p.first;\\n            \\n            \\n            for (auto it: adj[node]){\\n             if (time+it.second<=mxt){\\n                if (cost[it.first]>cst+val[it.first]){\\n                    cost[it.first]=cst+val[it.first];\\n                    tame[it.first]=time+it.second;\\n                    q.push({cost[it.first],{it.first,time+it.second}});\\n                }\\n                else if (tame[it.first]>time+it.second){\\n                    tame[it.first]=time+it.second;\\n                    q.push({val[it.first]+cst,{it.first,tame[it.first]}});\\n                }\\n             }\\n           }\\n        }\\n        \\n     if (cost[n-1]>=1e9+5){\\n         return -1;\\n     }\\n        \\n     return cost[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> adj[1005];\\n    \\n    int minCost(int mxt, vector<vector<int>>& v, vector<int>& val) {\\n        int i;\\n        \\n        for (i=0; i<v.size(); i++){\\n            adj[v[i][0]].push_back({v[i][1],v[i][2]});\\n            adj[v[i][1]].push_back({v[i][0],v[i][2]});\\n        }\\n        \\n        int n=val.size();\\n        vector<int> cost(n+1,1e9+5),tame(n+1,1e9+5);\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n        q.push({val[0],{0,0}});\\n        \\n        cost[0]=val[0];\\n        tame[0]=0;\\n        \\n        while (!q.empty()){\\n            pair<int,pair<int,int>> p=q.top();\\n            q.pop();\\n            \\n            int node=p.second.first;\\n            int time=p.second.second;\\n            int cst=p.first;\\n            \\n            \\n            for (auto it: adj[node]){\\n             if (time+it.second<=mxt){\\n                if (cost[it.first]>cst+val[it.first]){\\n                    cost[it.first]=cst+val[it.first];\\n                    tame[it.first]=time+it.second;\\n                    q.push({cost[it.first],{it.first,time+it.second}});\\n                }\\n                else if (tame[it.first]>time+it.second){\\n                    tame[it.first]=time+it.second;\\n                    q.push({val[it.first]+cst,{it.first,tame[it.first]}});\\n                }\\n             }\\n           }\\n        }\\n        \\n     if (cost[n-1]>=1e9+5){\\n         return -1;\\n     }\\n        \\n     return cost[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245731,
                "title": "kotlin-dijkstra-s-algorithm-with-comments",
                "content": "\\n\\n```kotlin\\nfun minCost(maxTime: Int, edges: Array<IntArray>, passingFees: IntArray): Int {\\n\\n  val times = IntArray(passingFees.size) { Int.MAX_VALUE } // set max time for every city\\n  val graph = mutableMapOf<Int, List<CityPoint>>()\\n  for ((from, to, time) in edges) { // fill the graph\\n    graph[from] = graph.getOrDefault(from, mutableListOf()) + CityPoint(to, time)\\n    graph[to] = graph.getOrDefault(to, mutableListOf()) + CityPoint(from, time)\\n  }\\n  val queue = PriorityQueue<CityTrip> { o1, o2 -> o1.price - o2.price }\\n  queue.add(CityTrip(0, 0, passingFees.first())) // start from first city\\n  while (queue.isNotEmpty()) {\\n    val (time, to, price) = queue.poll()\\n    if (time >= times[to]) continue // skip out of time\\n    times[to] = time\\n    if (passingFees.lastIndex == to) { // if we reached the last station\\n      return price\\n    }\\n    for (point in graph.getOrDefault(to, mutableListOf())) {\\n      val currTime = time + point.time\\n      val currPrice = price + passingFees[point.to]\\n      if (currTime > maxTime) continue // skip max time\\n      if (currTime > times[point.to]) continue // we need only min time\\n      queue.add(CityTrip(currTime, point.to, currPrice))\\n    }\\n  }\\n  return -1\\n}\\n\\nprivate data class CityPoint(val to: Int, var time: Int)\\nprivate data class CityTrip(val time: Int, val to: Int, var price: Int)\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun minCost(maxTime: Int, edges: Array<IntArray>, passingFees: IntArray): Int {\\n\\n  val times = IntArray(passingFees.size) { Int.MAX_VALUE } // set max time for every city\\n  val graph = mutableMapOf<Int, List<CityPoint>>()\\n  for ((from, to, time) in edges) { // fill the graph\\n    graph[from] = graph.getOrDefault(from, mutableListOf()) + CityPoint(to, time)\\n    graph[to] = graph.getOrDefault(to, mutableListOf()) + CityPoint(from, time)\\n  }\\n  val queue = PriorityQueue<CityTrip> { o1, o2 -> o1.price - o2.price }\\n  queue.add(CityTrip(0, 0, passingFees.first())) // start from first city\\n  while (queue.isNotEmpty()) {\\n    val (time, to, price) = queue.poll()\\n    if (time >= times[to]) continue // skip out of time\\n    times[to] = time\\n    if (passingFees.lastIndex == to) { // if we reached the last station\\n      return price\\n    }\\n    for (point in graph.getOrDefault(to, mutableListOf())) {\\n      val currTime = time + point.time\\n      val currPrice = price + passingFees[point.to]\\n      if (currTime > maxTime) continue // skip max time\\n      if (currTime > times[point.to]) continue // we need only min time\\n      queue.add(CityTrip(currTime, point.to, currPrice))\\n    }\\n  }\\n  return -1\\n}\\n\\nprivate data class CityPoint(val to: Int, var time: Int)\\nprivate data class CityTrip(val time: Int, val to: Int, var price: Int)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245355,
                "title": "java-easy-dfs-dp-reccursion",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        \\n        List<List<int[]>>g=new ArrayList<>();\\n        int n=passingFees.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            g.add(new ArrayList<>());\\n        }\\n        for(int arr[]:edges)\\n        {\\n            int u=arr[0];\\n            int v=arr[1];\\n            int wt=arr[2];\\n            \\n            int a1[]={v,wt};\\n            int a2[]={u,wt};\\n            g.get(u).add(a1);\\n            g.get(v).add(a2);\\n        }\\n        \\n        Integer t[][]=new Integer[n+1][maxTime+4];\\n        \\n        int res= dfs(g,maxTime,0,0,passingFees,n,t);\\n        if(res>=Integer.MAX_VALUE/2)\\n        {\\n            return -1;\\n        }\\n        return res;\\n        \\n    }\\n    \\n    int dfs(List<List<int[]>>g,int maxTime,int time,int src,int fee[],int n,Integer t[][])\\n    {\\n        if(time>maxTime)\\n        {\\n            return Integer.MAX_VALUE/2;\\n        }\\n        \\n        \\n        \\n        if(src==n-1)\\n        {\\n            return fee[src];\\n        }\\n        \\n        if(t[src][time]!=null)\\n        {\\n            return t[src][time];\\n        }\\n        \\n        int res=Integer.MAX_VALUE/2;\\n        \\n        for(int v[]:g.get(src))\\n        {\\n            int ans=fee[src]+dfs(g,maxTime,time+v[1],v[0],fee,n,t);\\n            \\n            res=Math.min(ans,res);\\n            \\n        }\\n        t[src][time]= res;\\n        return res;\\n        \\n    }\\n    \\n}\\n\\n//if u are not getting any step please do let me know\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        \\n        List<List<int[]>>g=new ArrayList<>();\\n        int n=passingFees.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            g.add(new ArrayList<>());\\n        }\\n        for(int arr[]:edges)\\n        {\\n            int u=arr[0];\\n            int v=arr[1];\\n            int wt=arr[2];\\n            \\n            int a1[]={v,wt};\\n            int a2[]={u,wt};\\n            g.get(u).add(a1);\\n            g.get(v).add(a2);\\n        }\\n        \\n        Integer t[][]=new Integer[n+1][maxTime+4];\\n        \\n        int res= dfs(g,maxTime,0,0,passingFees,n,t);\\n        if(res>=Integer.MAX_VALUE/2)\\n        {\\n            return -1;\\n        }\\n        return res;\\n        \\n    }\\n    \\n    int dfs(List<List<int[]>>g,int maxTime,int time,int src,int fee[],int n,Integer t[][])\\n    {\\n        if(time>maxTime)\\n        {\\n            return Integer.MAX_VALUE/2;\\n        }\\n        \\n        \\n        \\n        if(src==n-1)\\n        {\\n            return fee[src];\\n        }\\n        \\n        if(t[src][time]!=null)\\n        {\\n            return t[src][time];\\n        }\\n        \\n        int res=Integer.MAX_VALUE/2;\\n        \\n        for(int v[]:g.get(src))\\n        {\\n            int ans=fee[src]+dfs(g,maxTime,time+v[1],v[0],fee,n,t);\\n            \\n            res=Math.min(ans,res);\\n            \\n        }\\n        t[src][time]= res;\\n        return res;\\n        \\n    }\\n    \\n}\\n\\n//if u are not getting any step please do let me know\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233841,
                "title": "confused-why-my-dijkstra-code-is-wrong",
                "content": "In the below code if I give preference to time then it works. Otherwise not.\\n```\\n\\nstruct customSort{\\n    bool operator()(vector<int> v1, vector<int> v2) {\\n        return v1[0]>v2[0];\\n    }\\n};\\nclass Solution {\\npublic:\\n    // Appraoch 2\\n//     int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n//     }\\n    \\n    // Approach 1\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        unordered_map<int,unordered_map<int,int>> graph;\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].insert({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].insert({edges[i][0],edges[i][2]});\\n        }\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,customSort> pq;\\n        vector<int> cost(n,INT_MAX);\\n        vector<int> times(n,INT_MAX);\\n        cost[0]=passingFees[0];\\n        times[0]=0;\\n        pq.push({cost[0],0,0});\\n        \\n        while(!pq.empty()) {\\n            vector<int> v = pq.top(); pq.pop();\\n            int cur_fee =v[0];\\n            int node = v[1];\\n            int time = v[2];\\n            \\n            if(time>maxTime) continue;\\n            if(node==n-1) return cur_fee;\\n            \\n            for(auto i=graph[node].begin();i!=graph[node].end();i++) {\\n                int child_node = i->first;\\n                int edge_time = i->second;\\n                if(cur_fee+passingFees[child_node] < cost[child_node]) {\\n                    cost[child_node] = cur_fee+passingFees[child_node];\\n                    times[child_node] = time+edge_time;\\n                    pq.push({cost[child_node],child_node,times[child_node]});\\n                }\\n                else if(time+edge_time<times[child_node]) {\\n                    pq.push({cur_fee+passingFees[child_node],child_node,time+edge_time});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct customSort{\\n    bool operator()(vector<int> v1, vector<int> v2) {\\n        return v1[0]>v2[0];\\n    }\\n};\\nclass Solution {\\npublic:\\n    // Appraoch 2\\n//     int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n//     }\\n    \\n    // Approach 1\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        int n=passingFees.size();\\n        unordered_map<int,unordered_map<int,int>> graph;\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].insert({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].insert({edges[i][0],edges[i][2]});\\n        }\\n        \\n        priority_queue<vector<int>,vector<vector<int>>,customSort> pq;\\n        vector<int> cost(n,INT_MAX);\\n        vector<int> times(n,INT_MAX);\\n        cost[0]=passingFees[0];\\n        times[0]=0;\\n        pq.push({cost[0],0,0});\\n        \\n        while(!pq.empty()) {\\n            vector<int> v = pq.top(); pq.pop();\\n            int cur_fee =v[0];\\n            int node = v[1];\\n            int time = v[2];\\n            \\n            if(time>maxTime) continue;\\n            if(node==n-1) return cur_fee;\\n            \\n            for(auto i=graph[node].begin();i!=graph[node].end();i++) {\\n                int child_node = i->first;\\n                int edge_time = i->second;\\n                if(cur_fee+passingFees[child_node] < cost[child_node]) {\\n                    cost[child_node] = cur_fee+passingFees[child_node];\\n                    times[child_node] = time+edge_time;\\n                    pq.push({cost[child_node],child_node,times[child_node]});\\n                }\\n                else if(time+edge_time<times[child_node]) {\\n                    pq.push({cur_fee+passingFees[child_node],child_node,time+edge_time});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182856,
                "title": "java-dijkstra-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<int[]>[] adjList= new ArrayList[n];\\n        Arrays.setAll(adjList, a-> new ArrayList<>());\\n        for (int[] edge: edges){\\n            adjList[edge[0]].add(new int[]{edge[1], edge[2]});\\n            adjList[edge[1]].add(new int[]{edge[0], edge[2]});\\n        }\\n        PriorityQueue<int[]> minHeap= new PriorityQueue<>((a, b)->a[2]-b[2]);\\n        int[] visited= new int[n];\\n        Arrays.fill(visited, Integer.MAX_VALUE);\\n        minHeap.offer(new int[]{0,0,passingFees[0]});\\n        while(!minHeap.isEmpty()){\\n            int[] node=minHeap.poll();\\n            if (node[0]==n-1)\\n                return node[2];\\n            for(int[] neighbor: adjList[node[0]]){\\n                if (node[1]+ neighbor[1]>maxTime)\\n                    continue;\\n                int newTime= node[1]+neighbor[1];\\n                if (newTime< visited[neighbor[0]]){\\n                    visited[neighbor[0]]=newTime;\\n                    minHeap.offer(new int[]{neighbor[0], node[1]+neighbor[1], node[2]+passingFees[neighbor[0]]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<int[]>[] adjList= new ArrayList[n];\\n        Arrays.setAll(adjList, a-> new ArrayList<>());\\n        for (int[] edge: edges){\\n            adjList[edge[0]].add(new int[]{edge[1], edge[2]});\\n            adjList[edge[1]].add(new int[]{edge[0], edge[2]});\\n        }\\n        PriorityQueue<int[]> minHeap= new PriorityQueue<>((a, b)->a[2]-b[2]);\\n        int[] visited= new int[n];\\n        Arrays.fill(visited, Integer.MAX_VALUE);\\n        minHeap.offer(new int[]{0,0,passingFees[0]});\\n        while(!minHeap.isEmpty()){\\n            int[] node=minHeap.poll();\\n            if (node[0]==n-1)\\n                return node[2];\\n            for(int[] neighbor: adjList[node[0]]){\\n                if (node[1]+ neighbor[1]>maxTime)\\n                    continue;\\n                int newTime= node[1]+neighbor[1];\\n                if (newTime< visited[neighbor[0]]){\\n                    visited[neighbor[0]]=newTime;\\n                    minHeap.offer(new int[]{neighbor[0], node[1]+neighbor[1], node[2]+passingFees[neighbor[0]]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081629,
                "title": "python-bfs-dijkstra-annotated-with-explanation-faster-than-87-29",
                "content": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        # The question said \"There may be multiple roads of differing travel times connecting the same two cities\",\\n        # so what is the shortest time between each node to its nghbs?\\n        adj = defaultdict(dict)\\n        for _from, _to, _time in edges:\\n            if _to in adj[_from]:\\n                adj[_from][_to] = min(adj[_from][_to], _time)\\n            else:\\n                adj[_from][_to] = _time\\n            if _from in adj[_to]:\\n                adj[_to][_from] = min(adj[_to][_from], _time)\\n            else:\\n                adj[_to][_from] = _time\\n        \\n        N = len(passingFees)\\n        \\n        # What is the latest time I must reach each node?\\n        mustReachBy = [0] * N\\n        q = deque([[N-1, maxTime]])\\n        while q:\\n            node, reachBy = q.popleft()\\n            if mustReachBy[node] >= reachBy:\\n                continue\\n            mustReachBy[node] = reachBy\\n            for nghb in adj[node]:\\n                q.append([nghb, reachBy - adj[node][nghb]])\\n        \\n        earliest = [float(\\'inf\\')] * N\\n        earliest[0] = 0\\n        fees = [float(\\'inf\\')] * N\\n        fees[0] = passingFees[0]\\n        h = [[passingFees[0], 0, 0]]\\n        \\n        while h:\\n            price, node, time = heapq.heappop(h)\\n            \\n            # I am supposed to reach node at / before mustReachBy[node], but I reached here after that, so my path is invalid\\n            if time > mustReachBy[node]:\\n                continue\\n                \\n            # I reached node (n - 1), at / before maxTime, so this is the cheapest (as I am using a minheap)\\n            if node == N - 1:\\n                return price\\n            \\n            # Update cheapest and earliest method to reach here\\n            fees[node] = min(fees[node], price)\\n            earliest[node] = min(earliest[node], time)\\n            \\n            # I have yet to reach node (n - 1)\\n            # Let me go through my neighbours\\n            for nghb in adj[node]:\\n                # If there is already a way to reach that nghb in a cheaper and faster way, I shall not proceed.\\n                # OR if there is already to reach that nghb with the same time and cost, then don\\'t try to re-invent the wheel\\n                if fees[nghb] <= price + passingFees[nghb] and earliest[nghb] <= time + adj[node][nghb]:\\n                    continue\\n                heapq.heappush(h, [price + passingFees[nghb], nghb, time + adj[node][nghb]])\\n        \\n        # No way to reach node (n - 1) at / before maxTime\\n        return - 1\\n```\\nRuntime: 419 ms (87.29%)\\nMemory: 15 MB (32.60%)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        # The question said \"There may be multiple roads of differing travel times connecting the same two cities\",\\n        # so what is the shortest time between each node to its nghbs?\\n        adj = defaultdict(dict)\\n        for _from, _to, _time in edges:\\n            if _to in adj[_from]:\\n                adj[_from][_to] = min(adj[_from][_to], _time)\\n            else:\\n                adj[_from][_to] = _time\\n            if _from in adj[_to]:\\n                adj[_to][_from] = min(adj[_to][_from], _time)\\n            else:\\n                adj[_to][_from] = _time\\n        \\n        N = len(passingFees)\\n        \\n        # What is the latest time I must reach each node?\\n        mustReachBy = [0] * N\\n        q = deque([[N-1, maxTime]])\\n        while q:\\n            node, reachBy = q.popleft()\\n            if mustReachBy[node] >= reachBy:\\n                continue\\n            mustReachBy[node] = reachBy\\n            for nghb in adj[node]:\\n                q.append([nghb, reachBy - adj[node][nghb]])\\n        \\n        earliest = [float(\\'inf\\')] * N\\n        earliest[0] = 0\\n        fees = [float(\\'inf\\')] * N\\n        fees[0] = passingFees[0]\\n        h = [[passingFees[0], 0, 0]]\\n        \\n        while h:\\n            price, node, time = heapq.heappop(h)\\n            \\n            # I am supposed to reach node at / before mustReachBy[node], but I reached here after that, so my path is invalid\\n            if time > mustReachBy[node]:\\n                continue\\n                \\n            # I reached node (n - 1), at / before maxTime, so this is the cheapest (as I am using a minheap)\\n            if node == N - 1:\\n                return price\\n            \\n            # Update cheapest and earliest method to reach here\\n            fees[node] = min(fees[node], price)\\n            earliest[node] = min(earliest[node], time)\\n            \\n            # I have yet to reach node (n - 1)\\n            # Let me go through my neighbours\\n            for nghb in adj[node]:\\n                # If there is already a way to reach that nghb in a cheaper and faster way, I shall not proceed.\\n                # OR if there is already to reach that nghb with the same time and cost, then don\\'t try to re-invent the wheel\\n                if fees[nghb] <= price + passingFees[nghb] and earliest[nghb] <= time + adj[node][nghb]:\\n                    continue\\n                heapq.heappush(h, [price + passingFees[nghb], nghb, time + adj[node][nghb]])\\n        \\n        # No way to reach node (n - 1) at / before maxTime\\n        return - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081391,
                "title": "python3-2d-dijstra-with-explanation",
                "content": "For each node, there exists many different ways of fees and time reaching it. We simply push all these possibilites into Dijstra priority queue. and pop the one with minimum fee.\\nThe \"min_fee_time\" hash set is used to preventing re-access visited node. It records both the minimum time and minimum cost reaching a node. We only process those with either better time or better costs in \"min_fee_time\" hash set.\\n<img src=\"https://assets.leetcode.com/users/images/474441fc-82a9-412e-bb74-2baf0623548a_1653705792.068937.png\" width=250/>\\n\\n```\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        G = defaultdict(list)\\n        for a,b,c in edges:\\n            G[a].append([b,c])\\n            G[b].append([a,c])\\n        que = [[passingFees[0],0,0]]\\n        min_fee_time = defaultdict(lambda: [math.inf,math.inf])\\n        while que:\\n            fee,time,node = heapq.heappop(que)\\n            min_fee,min_time = min_fee_time[node]\\n            if time>maxTime or (min_fee<=fee and min_time<=time):\\n                continue\\n            min_fee_time[node]=[min(min_fee,fee),min(min_time,time)]\\n            if node == n-1:\\n                return fee\\n            for nxt,nxt_time in G[node]:\\n                heapq.heappush(que,[fee+passingFees[nxt],time+nxt_time,nxt])\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        G = defaultdict(list)\\n        for a,b,c in edges:\\n            G[a].append([b,c])\\n            G[b].append([a,c])\\n        que = [[passingFees[0],0,0]]\\n        min_fee_time = defaultdict(lambda: [math.inf,math.inf])\\n        while que:\\n            fee,time,node = heapq.heappop(que)\\n            min_fee,min_time = min_fee_time[node]\\n            if time>maxTime or (min_fee<=fee and min_time<=time):\\n                continue\\n            min_fee_time[node]=[min(min_fee,fee),min(min_time,time)]\\n            if node == n-1:\\n                return fee\\n            for nxt,nxt_time in G[node]:\\n                heapq.heappush(que,[fee+passingFees[nxt],time+nxt_time,nxt])\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2034443,
                "title": "java-priority-queue-solution-89-92-test-passed",
                "content": "Hi, I need help in identifying why 3 test cases are failing with my solution\\n\\n\\n```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        int n = passingFees.length;\\n        \\n        Map<Integer, List<CityCostTime>> graph = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++)\\n            graph.put(i, new ArrayList<>());\\n        \\n        for(int[] edge : edges){\\n            \\n            int from = edge[0];\\n            int to = edge[1];\\n\\n            graph.get(from).add(new CityCostTime(to, passingFees[to], edge[2]));\\n            graph.get(to).add(new CityCostTime(from, passingFees[from], edge[2]));\\n            \\n        }\\n        \\n        Integer[] dist = new Integer[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        \\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        \\n        PriorityQueue<CityCostTime> pq = new PriorityQueue<>( (a,b) -> a.cost - b.cost );\\n        \\n        pq.add(new CityCostTime(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()){\\n            \\n            CityCostTime curr = pq.poll();\\n            \\n            int currCity = curr.city;\\n            int currCost = curr.cost;\\n            int currTime = curr.time;\\n            \\n            \\n            if(currTime > maxTime)\\n                continue;\\n\\n            dist[currCity] = currCost;\\n            \\n            if(currCity == n - 1)\\n                return dist[currCity];\\n            \\n            \\n            for(CityCostTime next : graph.get(currCity)){\\n                \\n                int nextCity = next.city;\\n                \\n                if(currCost + next.cost < dist[nextCity]){\\n                    pq.add(new CityCostTime(nextCity, currCost + next.cost, currTime + next.time));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n\\nclass CityCostTime{\\n    \\n    int city;\\n    int cost;\\n    int time;\\n    \\n    public CityCostTime(int city, int cost, int time){\\n        this.city = city;\\n        this.cost = cost;\\n        this.time = time;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        int n = passingFees.length;\\n        \\n        Map<Integer, List<CityCostTime>> graph = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++)\\n            graph.put(i, new ArrayList<>());\\n        \\n        for(int[] edge : edges){\\n            \\n            int from = edge[0];\\n            int to = edge[1];\\n\\n            graph.get(from).add(new CityCostTime(to, passingFees[to], edge[2]));\\n            graph.get(to).add(new CityCostTime(from, passingFees[from], edge[2]));\\n            \\n        }\\n        \\n        Integer[] dist = new Integer[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        \\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        \\n        PriorityQueue<CityCostTime> pq = new PriorityQueue<>( (a,b) -> a.cost - b.cost );\\n        \\n        pq.add(new CityCostTime(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()){\\n            \\n            CityCostTime curr = pq.poll();\\n            \\n            int currCity = curr.city;\\n            int currCost = curr.cost;\\n            int currTime = curr.time;\\n            \\n            \\n            if(currTime > maxTime)\\n                continue;\\n\\n            dist[currCity] = currCost;\\n            \\n            if(currCity == n - 1)\\n                return dist[currCity];\\n            \\n            \\n            for(CityCostTime next : graph.get(currCity)){\\n                \\n                int nextCity = next.city;\\n                \\n                if(currCost + next.cost < dist[nextCity]){\\n                    pq.add(new CityCostTime(nextCity, currCost + next.cost, currTime + next.time));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n\\nclass CityCostTime{\\n    \\n    int city;\\n    int cost;\\n    int time;\\n    \\n    public CityCostTime(int city, int cost, int time){\\n        this.city = city;\\n        this.cost = cost;\\n        this.time = time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988918,
                "title": "dijkstra-on-cost-taken-till-each-city",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        int len = passingFees.length;\\n        boolean[] visited = new boolean[len];\\n        int[] minTime = new int[len];\\n        List<int[]>[] graph = new LinkedList[len];\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            minTime[i] = -1;\\n            graph[i] = new LinkedList();\\n        }\\n        \\n        for(int[] edge: edges)\\n        {\\n            int src = edge[0], dest = edge[1];\\n            int time = edge[2];\\n            graph[src].add(new int[]{dest, time});\\n            graph[dest].add(new int[]{src, time});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, passingFees[0]});\\n        \\n        while(!pq.isEmpty())\\n        {\\n            int[] current = pq.poll();\\n            int src = current[0], time = current[1], cost = current[2];\\n            \\n            if(time > maxTime) continue;\\n            if(src == len - 1) return cost;\\n            \\n            if(time >= minTime[src] && minTime[src] != -1) continue;    \\n            minTime[src] = time;\\n            \\n            for(int[] neighbour: graph[src])\\n            {\\n                int nextCity = neighbour[0], edgeTime = neighbour[1];\\n                \\n                pq.offer(new int[]{nextCity, edgeTime + time, cost + passingFees[nextCity]});\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        int len = passingFees.length;\\n        boolean[] visited = new boolean[len];\\n        int[] minTime = new int[len];\\n        List<int[]>[] graph = new LinkedList[len];\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            minTime[i] = -1;\\n            graph[i] = new LinkedList();\\n        }\\n        \\n        for(int[] edge: edges)\\n        {\\n            int src = edge[0], dest = edge[1];\\n            int time = edge[2];\\n            graph[src].add(new int[]{dest, time});\\n            graph[dest].add(new int[]{src, time});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, passingFees[0]});\\n        \\n        while(!pq.isEmpty())\\n        {\\n            int[] current = pq.poll();\\n            int src = current[0], time = current[1], cost = current[2];\\n            \\n            if(time > maxTime) continue;\\n            if(src == len - 1) return cost;\\n            \\n            if(time >= minTime[src] && minTime[src] != -1) continue;    \\n            minTime[src] = time;\\n            \\n            for(int[] neighbour: graph[src])\\n            {\\n                int nextCity = neighbour[0], edgeTime = neighbour[1];\\n                \\n                pq.offer(new int[]{nextCity, edgeTime + time, cost + passingFees[nextCity]});\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957793,
                "title": "fastest-python3-solution-293-ms-dijkstra-s-with-pruning",
                "content": "For this problem, we are going to use Dijkstra\\'s Algorithm, where cost is the variable that the min-heap is sorted by. One optimization we can use right off the bat is using the fastest road between each pair of cities, since the problem states that there can be multiple roads between 2 cities. We will use 2 arrays: costs and times, which represent the least amount of money required to get to each node, and the least amount of time to get to each node. \\n\\nIf your current node is n-1 and your time is less than maxTime, then you return your current cost as the answer, since you know by Dijkstra\\'s algorithm that you will have the cheapest route to your current node. If your current time is greater than maxTime, then just continue because your current route is invalid and you should not waste time on it. Additionally, we need to check if your path is either the cheapest route to your node or the quickest. If it is neither of those, then continue, because this route is invalid. Then we will loop through all of the neighbors and if the paths through your neighbors are valid, we will push them to the heap, and update the times and costs lists accordingly.\\n\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        graph = defaultdict(lambda: defaultdict(lambda: math.inf))\\n        n = len(passingFees)\\n        for s,e,t in edges:\\n            graph[s][e] = min(graph[s][e], t)\\n            graph[e][s] = min(graph[e][s], t)\\n            \\n        costs = [math.inf]*n\\n        times = [math.inf]*n\\n        times[0] = 0\\n        costs[0] = passingFees[0]\\n        \\n        heap = [(passingFees[0], 0,0)]\\n        while heap:\\n            currentCost, currentTime, node = heappop(heap)\\n            if node == n-1 and currentTime <= maxTime:\\n                return currentCost\\n            if currentTime > maxTime or (currentCost > costs[node] and currentTime > times[node]):\\n                continue\\n            for nei in graph[node]:\\n                if currentTime + graph[node][nei] < times[nei] or currentCost + passingFees[nei] < costs[nei]:\\n                    times[nei] = min(times[nei], currentTime + graph[node][nei])\\n                    costs[nei] = min(costs[nei], currentCost + passingFees[nei])\\n                    heappush(heap,(currentCost + passingFees[nei], currentTime + graph[node][nei], nei))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        graph = defaultdict(lambda: defaultdict(lambda: math.inf))\\n        n = len(passingFees)\\n        for s,e,t in edges:\\n            graph[s][e] = min(graph[s][e], t)\\n            graph[e][s] = min(graph[e][s], t)\\n            \\n        costs = [math.inf]*n\\n        times = [math.inf]*n\\n        times[0] = 0\\n        costs[0] = passingFees[0]\\n        \\n        heap = [(passingFees[0], 0,0)]\\n        while heap:\\n            currentCost, currentTime, node = heappop(heap)\\n            if node == n-1 and currentTime <= maxTime:\\n                return currentCost\\n            if currentTime > maxTime or (currentCost > costs[node] and currentTime > times[node]):\\n                continue\\n            for nei in graph[node]:\\n                if currentTime + graph[node][nei] < times[nei] or currentCost + passingFees[nei] < costs[nei]:\\n                    times[nei] = min(times[nei], currentTime + graph[node][nei])\\n                    costs[nei] = min(costs[nei], currentCost + passingFees[nei])\\n                    heappush(heap,(currentCost + passingFees[nei], currentTime + graph[node][nei], nei))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843136,
                "title": "c-dp-dfs",
                "content": "**Idea**\\nBuild a 2D dp, where `dp[i][j]` denote the **min_cost** to reach at node `n-1` ( n=no. of nodes) from node `i` when `j` amount of time left. I have used vector of user defined data-type to build the graph, you can use any other method to build the graph. After that do simple dfs.\\n\\n**Time: O(n*maxTime )**\\n```\\nclass node{\\npublic:\\n    int c,v;\\n    node(){c=0,v=0;}\\n    node(int x,int y) {v=x,c=y;}\\n};\\nclass Solution {\\npublic:\\n    int n;\\n    int dfs(vector<vector<node>> &g,vector<int>& nums,vector<vector<int>> &dp,int in,int time){\\n        if(in==n-1) return nums[in];\\n        if(dp[in][time]!=-1) return dp[in][time];\\n        int re = INT_MAX;\\n        for(int i = 0; i<g[in].size();++i){\\n            node &q = g[in][i];\\n            int k = 0;\\n            if(q.c<=time ){\\n                k = dfs(g,nums,dp,q.v,time-q.c);\\n                re=min(re,k);\\n            }\\n        }\\n        if(re!=INT_MAX) re+=nums[in];\\n        return dp[in][time] = re;\\n    }\\n    int minCost(int t, vector<vector<int>>& arr, vector<int>& nums) {\\n        n = nums.size();\\n        vector<vector<node>> g(n);\\n        for(int i = 0; i<arr.size();++i){\\n            g[arr[i][0]].push_back(node(arr[i][1],arr[i][2]));\\n            g[arr[i][1]].push_back(node(arr[i][0],arr[i][2]));\\n        }\\n        vector<vector<int>> dp(n,vector<int>(t+5,-1));\\n        int k =  dfs(g,nums,dp,0,t);\\n        if(k==INT_MAX) k=-1;\\n        return k;\\n    }\\n};\\n```\\n**upvote if it helps**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass node{\\npublic:\\n    int c,v;\\n    node(){c=0,v=0;}\\n    node(int x,int y) {v=x,c=y;}\\n};\\nclass Solution {\\npublic:\\n    int n;\\n    int dfs(vector<vector<node>> &g,vector<int>& nums,vector<vector<int>> &dp,int in,int time){\\n        if(in==n-1) return nums[in];\\n        if(dp[in][time]!=-1) return dp[in][time];\\n        int re = INT_MAX;\\n        for(int i = 0; i<g[in].size();++i){\\n            node &q = g[in][i];\\n            int k = 0;\\n            if(q.c<=time ){\\n                k = dfs(g,nums,dp,q.v,time-q.c);\\n                re=min(re,k);\\n            }\\n        }\\n        if(re!=INT_MAX) re+=nums[in];\\n        return dp[in][time] = re;\\n    }\\n    int minCost(int t, vector<vector<int>>& arr, vector<int>& nums) {\\n        n = nums.size();\\n        vector<vector<node>> g(n);\\n        for(int i = 0; i<arr.size();++i){\\n            g[arr[i][0]].push_back(node(arr[i][1],arr[i][2]));\\n            g[arr[i][1]].push_back(node(arr[i][0],arr[i][2]));\\n        }\\n        vector<vector<int>> dp(n,vector<int>(t+5,-1));\\n        int k =  dfs(g,nums,dp,0,t);\\n        if(k==INT_MAX) k=-1;\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826987,
                "title": "modified-dijkstra-js-fully-working",
                "content": "```\\nconst PriorityQueue  = require(\\'js-priority-queue\\');\\n/**\\n * @param {number} maxTime\\n * @param {number[][]} edges\\n * @param {number[]} passingFees\\n * @return {number}\\n */\\nvar minCost = function(maxTime, edges, passingFees) {\\n    // Create a graph from edges\\n    let graph = {};\\n    for (let edge of edges){\\n        let [u, v, time] = edge;\\n    \\n        if (!graph[u]){\\n            graph[u] = [];\\n        }\\n        if (!graph[v]){\\n            graph[v] = [];\\n        }\\n        \\n        graph[u].push([v, time, passingFees[u]]);\\n        graph[v].push([u,time, passingFees[v]]);\\n    }\\n\\n    let visited = new Array(passingFees.length -1);\\n    visited.fill(-1);\\n    let path = [];\\n    const customPriorityComparator = (a, b) => a[0] - b[0];\\n    const priorityQueue = new PriorityQueue({ comparator: customPriorityComparator});\\n    priorityQueue.queue([passingFees[0],0, 0]);\\n    path.push(0);\\n    while (priorityQueue.length > 0){\\n        let [fees, time, node] = priorityQueue.dequeue();\\n        if (node === passingFees.length - 1){\\n            console.log(path)\\n            return fees;\\n        }\\n                \\n        \\n        for (let neighbor of graph[node]){\\n            if (visited[neighbor[0]] !== -1 && (time + neighbor[1]) >= visited[neighbor[0]]){\\n                continue;\\n            }\\n            visited[neighbor[0]] = time + neighbor[1];\\n            if ((time + neighbor[1]) <= maxTime){ \\n                let newFees = fees + passingFees[neighbor[0]];\\n                path.push(neighbor[0])\\n                priorityQueue.queue([newFees, time + neighbor[1], neighbor[0]]);\\n                \\n            }\\n        }\\n        \\n    }\\n    return -1;\\n}\\n\\nconst maxTime = 30\\nconst edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]]\\nconst passingFees = [5,1,2,20,20,3]\\n\\nconsole.log(minCost(maxTime, edges, passingFees));\\n```",
                "solutionTags": [],
                "code": "```\\nconst PriorityQueue  = require(\\'js-priority-queue\\');\\n/**\\n * @param {number} maxTime\\n * @param {number[][]} edges\\n * @param {number[]} passingFees\\n * @return {number}\\n */\\nvar minCost = function(maxTime, edges, passingFees) {\\n    // Create a graph from edges\\n    let graph = {};\\n    for (let edge of edges){\\n        let [u, v, time] = edge;\\n    \\n        if (!graph[u]){\\n            graph[u] = [];\\n        }\\n        if (!graph[v]){\\n            graph[v] = [];\\n        }\\n        \\n        graph[u].push([v, time, passingFees[u]]);\\n        graph[v].push([u,time, passingFees[v]]);\\n    }\\n\\n    let visited = new Array(passingFees.length -1);\\n    visited.fill(-1);\\n    let path = [];\\n    const customPriorityComparator = (a, b) => a[0] - b[0];\\n    const priorityQueue = new PriorityQueue({ comparator: customPriorityComparator});\\n    priorityQueue.queue([passingFees[0],0, 0]);\\n    path.push(0);\\n    while (priorityQueue.length > 0){\\n        let [fees, time, node] = priorityQueue.dequeue();\\n        if (node === passingFees.length - 1){\\n            console.log(path)\\n            return fees;\\n        }\\n                \\n        \\n        for (let neighbor of graph[node]){\\n            if (visited[neighbor[0]] !== -1 && (time + neighbor[1]) >= visited[neighbor[0]]){\\n                continue;\\n            }\\n            visited[neighbor[0]] = time + neighbor[1];\\n            if ((time + neighbor[1]) <= maxTime){ \\n                let newFees = fees + passingFees[neighbor[0]];\\n                path.push(neighbor[0])\\n                priorityQueue.queue([newFees, time + neighbor[1], neighbor[0]]);\\n                \\n            }\\n        }\\n        \\n    }\\n    return -1;\\n}\\n\\nconst maxTime = 30\\nconst edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]]\\nconst passingFees = [5,1,2,20,20,3]\\n\\nconsole.log(minCost(maxTime, edges, passingFees));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787078,
                "title": "please-help-my-dp-solution-is-giving-wrong-answer-for-3-last-test-case",
                "content": "Kindly help to review my code\\n```\\nclass Solution {\\npublic:\\n    void buildGraph(int graph[][1000],vector<vector<int> >&edges){\\n\\tfor(int i=0;i<edges.size();++i){\\n\\t\\tgraph[edges[i][0]][edges[i][1]]=edges[i][2];\\n\\t\\tgraph[edges[i][1]][edges[i][0]]=edges[i][2];\\n\\t}\\n}\\nint solve(int graph[][1000],int n,int u,vector<bool>&vis,vector<int>&cost,int maxtime,int dp[][1000+1]){\\n\\tif(u==n-1){\\n        return cost[n-1];\\n    }\\n    if(maxtime<0)return 1e8+134;\\n    if(dp[u][maxtime]!=-1)return dp[u][maxtime];\\t\\n\\tvis[u]=1;\\n\\tint ans=1e8+134;\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(!vis[i]&&graph[u][i]!=0&&maxtime-graph[u][i]>=0){\\n\\t\\t\\tans=min(ans,cost[u]+solve(graph,n,i,vis,cost,maxtime-graph[u][i],dp));\\n\\t\\t}\\n\\t}\\n\\tvis[u]=0;\\n\\treturn dp[u][maxtime]=ans;\\n}\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n    int n=cost.size();\\n\\tint graph[1000][1000];\\n\\tmemset(graph,0,sizeof graph);\\n\\tbuildGraph(graph,edges);\\n\\tvector<bool>vis(n+1,0);\\n\\tint dp[1000+1][1000+1];\\n\\tmemset(dp,-1,sizeof dp);\\n\\tint m=solve(graph,n,0,vis,cost,maxTime,dp);\\n        if(m==1e8+134)return -1;\\n        return m; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void buildGraph(int graph[][1000],vector<vector<int> >&edges){\\n\\tfor(int i=0;i<edges.size();++i){\\n\\t\\tgraph[edges[i][0]][edges[i][1]]=edges[i][2];\\n\\t\\tgraph[edges[i][1]][edges[i][0]]=edges[i][2];\\n\\t}\\n}\\nint solve(int graph[][1000],int n,int u,vector<bool>&vis,vector<int>&cost,int maxtime,int dp[][1000+1]){\\n\\tif(u==n-1){\\n        return cost[n-1];\\n    }\\n    if(maxtime<0)return 1e8+134;\\n    if(dp[u][maxtime]!=-1)return dp[u][maxtime];\\t\\n\\tvis[u]=1;\\n\\tint ans=1e8+134;\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(!vis[i]&&graph[u][i]!=0&&maxtime-graph[u][i]>=0){\\n\\t\\t\\tans=min(ans,cost[u]+solve(graph,n,i,vis,cost,maxtime-graph[u][i],dp));\\n\\t\\t}\\n\\t}\\n\\tvis[u]=0;\\n\\treturn dp[u][maxtime]=ans;\\n}\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n    int n=cost.size();\\n\\tint graph[1000][1000];\\n\\tmemset(graph,0,sizeof graph);\\n\\tbuildGraph(graph,edges);\\n\\tvector<bool>vis(n+1,0);\\n\\tint dp[1000+1][1000+1];\\n\\tmemset(dp,-1,sizeof dp);\\n\\tint m=solve(graph,n,0,vis,cost,maxTime,dp);\\n        if(m==1e8+134)return -1;\\n        return m; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781556,
                "title": "python3-djikstra-summarized",
                "content": "This to me was easier than some medium tagged questions on the same topic which I sometimes struggled with TLE.\\n\\n1. Use the quantity you are trying to minimize as the key to min_heap of Djikstra. So you always end up getting shortest/smallest of that\\n\\tquantity as you pop from the heap. Here it is the cost of passing a city.\\n\\t\\n2. When pushing to the heap respect the extra constraints. Here it is the time elapsed to a vertex before making the decision to push to heap. This is not used as a key to heap since constraints are known ahead but the minimized value is not.\\n\\n3.  You can add further constraints such as if a better time-elapsed is available with a better cost. This will make your solution faster/slower depending on the inputs. I don\\'t do it below but either case the algorithm has an upper bound of O(ElogE) which I guess is equivalent to O(ElogV).\\n\\n```\\ndef to_adj_list(edges: List[List[int]], n : int):\\n    adj_list = {}\\n    for u, v, time in edges:\\n        adj_list.setdefault(u, []).append((v, time))\\n        adj_list.setdefault(v, []).append((u, time))     \\n    return adj_list\\n    \\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj_list = to_adj_list(edges, n)\\n        min_heap = [(passingFees[0], 0, 0)]\\n        \\n        known_times = {0 : 0}\\n        \\n        while min_heap:\\n            fee, vertex, cum_time = heapq.heappop(min_heap)\\n\\n            if vertex == n-1:\\n                return fee\\n            \\n            for neighbor, time in adj_list.get(vertex, []):\\n                \\n                if (cum_time + time < known_times.get(neighbor, float(\"inf\"))\\n                    and cum_time + time <= maxTime):\\n                        \\n                    known_times[neighbor] = cum_time + time\\n                    heapq.heappush(min_heap, (fee + passingFees[neighbor], neighbor, cum_time + time))\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef to_adj_list(edges: List[List[int]], n : int):\\n    adj_list = {}\\n    for u, v, time in edges:\\n        adj_list.setdefault(u, []).append((v, time))\\n        adj_list.setdefault(v, []).append((u, time))     \\n    return adj_list\\n    \\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        adj_list = to_adj_list(edges, n)\\n        min_heap = [(passingFees[0], 0, 0)]\\n        \\n        known_times = {0 : 0}\\n        \\n        while min_heap:\\n            fee, vertex, cum_time = heapq.heappop(min_heap)\\n\\n            if vertex == n-1:\\n                return fee\\n            \\n            for neighbor, time in adj_list.get(vertex, []):\\n                \\n                if (cum_time + time < known_times.get(neighbor, float(\"inf\"))\\n                    and cum_time + time <= maxTime):\\n                        \\n                    known_times[neighbor] = cum_time + time\\n                    heapq.heappush(min_heap, (fee + passingFees[neighbor], neighbor, cum_time + time))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779882,
                "title": "c-dijkstra-s-algo",
                "content": "```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        \\n        int n= passingFees.size();\\n        \\n        vector<pair<int,int>> dp[n+100];\\n        \\n        for(auto x : edges){\\n            \\n            dp[x[0]].push_back({x[1],x[2]});\\n            dp[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector<int> dis(n+1,INT_MAX);\\n        \\n        \\n        dis[0]=passingFees[0];\\n        \\n        \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> q;\\n        \\n        q.push({passingFees[0],0,0});\\n        \\n        while(!q.empty()){\\n            \\n            auto tp=q.top();\\n            q.pop();\\n            int f=tp[0];\\n            int time=tp[1];\\n            int node= tp[2];\\n            \\n             if(node==n-1) return f;\\n            for(auto x: dp[node]){\\n                \\n               \\n                int new_time= time+x.second;\\n                \\n                if(new_time<=maxTime and dis[x.first]>new_time){\\n                    dis[x.first]= new_time;\\n                    q.push({f + passingFees[x.first],new_time,x.first});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        \\n        \\n        int n= passingFees.size();\\n        \\n        vector<pair<int,int>> dp[n+100];\\n        \\n        for(auto x : edges){\\n            \\n            dp[x[0]].push_back({x[1],x[2]});\\n            dp[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector<int> dis(n+1,INT_MAX);\\n        \\n        \\n        dis[0]=passingFees[0];\\n        \\n        \\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> q;\\n        \\n        q.push({passingFees[0],0,0});\\n        \\n        while(!q.empty()){\\n            \\n            auto tp=q.top();\\n            q.pop();\\n            int f=tp[0];\\n            int time=tp[1];\\n            int node= tp[2];\\n            \\n             if(node==n-1) return f;\\n            for(auto x: dp[node]){\\n                \\n               \\n                int new_time= time+x.second;\\n                \\n                if(new_time<=maxTime and dis[x.first]>new_time){\\n                    dis[x.first]= new_time;\\n                    q.push({f + passingFees[x.first],new_time,x.first});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1773173,
                "title": "simple-dp",
                "content": "```\\nclass Solution {\\n    int dp[2001][2001];\\npublic:\\n    int get(vector<pair<int,int>>adj[],int node,int par,int maxtime,int dst,vector<int>&fee)\\n    {\\n        if(maxtime<0)\\n        {\\n            return 1e9;\\n        }\\n        if(node==dst)\\n        {\\n           \\n            return dp[node][maxtime]=(maxtime>=0)?fee[node]:1e9;\\n        }\\n        if(dp[node][maxtime]!=-1)\\n        {\\n            return dp[node][maxtime];\\n        }\\n        int ans=1e9;\\n        \\n        for(auto v1:adj[node])\\n        {\\n            int child=v1.first;\\n            int we=v1.second;\\n            if(maxtime>=we)\\n            {\\n                int res=get(adj,child,node,maxtime-(we),dst,fee)+fee[node];\\n                 ans=min(ans,res);\\n            }\\n           \\n        }\\n        return dp[node][maxtime]=ans;\\n    }\\n    int minCost(int maxTime, vector<vector<int>>&a, vector<int>&fee) {\\n        \\n        int n=fee.size();\\n        vector<pair<int,int>>adj[n];\\n        \\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int u=a[i][0];\\n            int v=a[i][1];\\n            int w=a[i][2];\\n            \\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int x=get(adj,0,-1,maxTime,n-1,fee);\\n        \\n        if(x>=1e8)\\n        {\\n            return -1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[2001][2001];\\npublic:\\n    int get(vector<pair<int,int>>adj[],int node,int par,int maxtime,int dst,vector<int>&fee)\\n    {\\n        if(maxtime<0)\\n        {\\n            return 1e9;\\n        }\\n        if(node==dst)\\n        {\\n           \\n            return dp[node][maxtime]=(maxtime>=0)?fee[node]:1e9;\\n        }\\n        if(dp[node][maxtime]!=-1)\\n        {\\n            return dp[node][maxtime];\\n        }\\n        int ans=1e9;\\n        \\n        for(auto v1:adj[node])\\n        {\\n            int child=v1.first;\\n            int we=v1.second;\\n            if(maxtime>=we)\\n            {\\n                int res=get(adj,child,node,maxtime-(we),dst,fee)+fee[node];\\n                 ans=min(ans,res);\\n            }\\n           \\n        }\\n        return dp[node][maxtime]=ans;\\n    }\\n    int minCost(int maxTime, vector<vector<int>>&a, vector<int>&fee) {\\n        \\n        int n=fee.size();\\n        vector<pair<int,int>>adj[n];\\n        \\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int u=a[i][0];\\n            int v=a[i][1];\\n            int w=a[i][2];\\n            \\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int x=get(adj,0,-1,maxTime,n-1,fee);\\n        \\n        if(x>=1e8)\\n        {\\n            return -1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748716,
                "title": "dikshtra-python-algo-with-limiting-condition-within-k-stops-within-x-time",
                "content": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \\n        #For src to dst within x time or k stops also to minimize cost ( passing fees)  - Dikshtra from 0 to n-1\\n        \\n\\t\\t#Get all nodes and edges with their time\\n        adj = defaultdict(list)\\n        for x,y,t in edges:\\n            adj[x].append((y,t))\\n            adj[y].append((x,t))\\n        n = len(passingFees)\\n\\t\\t\\n\\t    #One which is to be minimized (passing fees) is kept in minheap\\n        heap = [(passingFees[0],0,maxTime)] #fees from 0, city id , timeleft\\n        heapq.heapify(heap)\\n        cityfees = {}\\n\\n\\t\\t#keep track of timeleft with each city , \\n\\t\\t#here we can visit a city multiple times ( one with least passing fees, other iteration with more timeleft\\n        times = [float(\"-inf\")]*n \\n\\n\\t\\t#iterate till elements in heap or you reach destination with satisfying condition ( timeleft>=0)  \\n        while heap:\\n            fees,city,timeleft = heapq.heappop(heap)\\n            #ans - reach destination and still timeleft - yaay\\n            if city == n-1:\\n                if timeleft>=0:\\n                    return fees\\n                else:\\n\\t\\t\\t\\t\\t#lets try other cities with different passing fees\\n                    continue\\n            #if next path or city takes more timeleft then previous one then only we proceed\\n            if timeleft<=times[city]:\\n                continue\\n\\t\\t\\t#we are good to update and proceed further\\n            cityfees[city]=fees\\n            times[city]=timeleft\\n            for nc,t in adj[city]:\\n\\t\\t\\t\\t#no track of  visited as we will be visiting same city again and again with more timeleft,\\n\\t\\t\\t\\t #pruning condition will avoid same stops again.\\n                heapq.heappush(heap,(fees+passingFees[nc],nc,timeleft-t))\\n        return cityfees[n-1] if n-1 in cityfees else -1 \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        \\n        #For src to dst within x time or k stops also to minimize cost ( passing fees)  - Dikshtra from 0 to n-1\\n        \\n\\t\\t#Get all nodes and edges with their time\\n        adj = defaultdict(list)\\n        for x,y,t in edges:\\n            adj[x].append((y,t))\\n            adj[y].append((x,t))\\n        n = len(passingFees)\\n\\t\\t\\n\\t    #One which is to be minimized (passing fees) is kept in minheap\\n        heap = [(passingFees[0],0,maxTime)] #fees from 0, city id , timeleft\\n        heapq.heapify(heap)\\n        cityfees = {}\\n\\n\\t\\t#keep track of timeleft with each city , \\n\\t\\t#here we can visit a city multiple times ( one with least passing fees, other iteration with more timeleft\\n        times = [float(\"-inf\")]*n \\n\\n\\t\\t#iterate till elements in heap or you reach destination with satisfying condition ( timeleft>=0)  \\n        while heap:\\n            fees,city,timeleft = heapq.heappop(heap)\\n            #ans - reach destination and still timeleft - yaay\\n            if city == n-1:\\n                if timeleft>=0:\\n                    return fees\\n                else:\\n\\t\\t\\t\\t\\t#lets try other cities with different passing fees\\n                    continue\\n            #if next path or city takes more timeleft then previous one then only we proceed\\n            if timeleft<=times[city]:\\n                continue\\n\\t\\t\\t#we are good to update and proceed further\\n            cityfees[city]=fees\\n            times[city]=timeleft\\n            for nc,t in adj[city]:\\n\\t\\t\\t\\t#no track of  visited as we will be visiting same city again and again with more timeleft,\\n\\t\\t\\t\\t #pruning condition will avoid same stops again.\\n                heapq.heappush(heap,(fees+passingFees[nc],nc,timeleft-t))\\n        return cityfees[n-1] if n-1 in cityfees else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737064,
                "title": "c-solution-passing-85-92-cases",
                "content": "My intution is do bfs from starting point till reaches end point. And ignore vertices we already considered and those states whose time is greater than maxTime.\\n\\nCan anyone please help me to figure out why is it failing some test cases?\\n\\n```\\nclass State { \\npublic:\\n    int vertex, cost , time;\\n    \\n    State(int _vertex, int _cost, int _time) {\\n        vertex = _vertex;\\n        cost = _cost;\\n        time = _time;\\n    }  \\n};\\n\\nclass CompareState {\\npublic:\\n  bool operator()(const State& s1, const State& s2) {\\n      if(s1.cost==s2.cost) return s1.time>s2.time;\\n      return s1.cost > s2.cost;\\n  }  \\n};\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        const int n = passingFees.size();\\n        vector<vector<vector<int>>> adjacency(n);\\n        vector<bool> visited(n);\\n        \\n        for(auto& edge: edges) {\\n            adjacency[edge[0]].push_back({edge[1], edge[2]});\\n            adjacency[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        \\n        priority_queue<State,vector<State>, CompareState> pq;\\n        pq.push(State(0,passingFees[0],0));\\n        \\n        while(!pq.empty()) {\\n            State s = pq.top();\\n            pq.pop();\\n            \\n            if(s.vertex==n-1) \\n                return s.cost;\\n            \\n            if(visited[s.vertex]) \\n                continue;\\n        \\n            visited[s.vertex] = true;\\n            \\n            for(auto& edge: adjacency[s.vertex]) {\\n                if(visited[edge[0]] or s.time + edge[1] > maxTime) continue;\\n                pq.push(State(edge[0], s.cost + passingFees[edge[0]] , s.time + edge[1]));\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass State { \\npublic:\\n    int vertex, cost , time;\\n    \\n    State(int _vertex, int _cost, int _time) {\\n        vertex = _vertex;\\n        cost = _cost;\\n        time = _time;\\n    }  \\n};\\n\\nclass CompareState {\\npublic:\\n  bool operator()(const State& s1, const State& s2) {\\n      if(s1.cost==s2.cost) return s1.time>s2.time;\\n      return s1.cost > s2.cost;\\n  }  \\n};\\n\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        const int n = passingFees.size();\\n        vector<vector<vector<int>>> adjacency(n);\\n        vector<bool> visited(n);\\n        \\n        for(auto& edge: edges) {\\n            adjacency[edge[0]].push_back({edge[1], edge[2]});\\n            adjacency[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        \\n        priority_queue<State,vector<State>, CompareState> pq;\\n        pq.push(State(0,passingFees[0],0));\\n        \\n        while(!pq.empty()) {\\n            State s = pq.top();\\n            pq.pop();\\n            \\n            if(s.vertex==n-1) \\n                return s.cost;\\n            \\n            if(visited[s.vertex]) \\n                continue;\\n        \\n            visited[s.vertex] = true;\\n            \\n            for(auto& edge: adjacency[s.vertex]) {\\n                if(visited[edge[0]] or s.time + edge[1] > maxTime) continue;\\n                pq.push(State(edge[0], s.cost + passingFees[edge[0]] , s.time + edge[1]));\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712574,
                "title": "dfs-memo-simple-intuitive-but-can-you-find-the-bug",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        Map<Integer, List<int[]>> graph = new HashMap();\\n        for(int[] edge: edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0], new ArrayList());\\n            }\\n            if(!graph.containsKey(edge[1])){\\n                graph.put(edge[1], new ArrayList());\\n            }\\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\\n        }\\n        \\n        int[] visited = new int[passingFees.length];\\n        int[] memo = new int[passingFees.length];\\n        Arrays.fill(memo, -1);\\n        visited[0]=1;\\n        int min = dfs(graph, maxTime, passingFees, 0,visited,memo, 0);\\n        return min ==  Integer.MAX_VALUE ? -1 : min;\\n    }\\n    \\n    public int dfs(Map<Integer, List<int[]>> graph, int maxTime, \\n                   int[] passingFees, int currNode, int[] visited, \\n                   int[] memo, int currTime){\\n        \\n        if(currNode == passingFees.length-1 && currTime <= maxTime){\\n            return passingFees[currNode];\\n        }\\n        if(currTime > maxTime || !graph.containsKey(currNode)){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(memo[currNode] != -1){\\n            return memo[currNode] ;\\n        }\\n        int checkMin = Integer.MAX_VALUE;\\n        int check = Integer.MAX_VALUE;\\n        for(int i=0;i<graph.get(currNode).size();i++){\\n            int nextNode = graph.get(currNode).get(i)[0];\\n            int nextNodeTime = graph.get(currNode).get(i)[1];\\n            if(visited[nextNode] != 1){\\n                visited[nextNode] = 1;\\n                check =\\n                    dfs(graph, maxTime, passingFees, nextNode,\\n                       visited,memo, currTime+nextNodeTime);\\n                visited[nextNode] = 0;\\n            }\\n\\n                checkMin = Math.min(check, checkMin);\\n            \\n            \\n        }\\n        int curr= (checkMin == Integer.MAX_VALUE ? Integer.MAX_VALUE : passingFees[currNode]+checkMin);\\n        memo[currNode] = curr;\\n        return curr;\\n    }\\n}\\n\\n```\\n\\nfailing for: \\n\\n```\\n119\\n[[9,18,2],[1,35,4],[24,26,34],[2,47,19],[15,31,33],[21,10,37],[35,33,20],[32,15,40],[13,5,33],[28,34,4],[31,11,31],[17,34,20],[49,48,33],[37,35,34],[21,26,2],[42,11,22],[15,49,1],[4,36,26],[32,31,39],[37,23,4],[32,34,39],[2,46,13],[34,19,9],[11,14,20],[34,12,50],[43,8,38],[24,8,19],[3,28,42],[38,8,44],[10,34,11],[37,1,33],[28,31,11],[4,42,42],[23,13,4],[12,27,29],[33,6,17],[32,27,16],[26,29,24],[26,14,39],[36,42,36],[17,22,50],[9,6,45],[48,24,27],[45,9,23],[49,42,47],[3,27,47],[38,46,45],[4,2,11],[33,23,38],[14,38,48],[46,20,29],[30,13,25],[5,30,22],[6,32,9],[37,15,48],[27,0,23],[37,44,43],[21,11,39],[36,25,8],[31,30,1],[27,39,14],[11,0,25],[31,1,7],[9,29,7],[15,44,32],[44,39,42],[22,1,42],[3,6,39],[41,32,48],[28,10,38],[19,47,46],[16,14,13],[29,8,37],[48,12,11],[37,41,19],[6,21,22],[25,34,8],[30,29,42],[30,35,3],[7,3,13],[48,22,13],[49,34,41],[7,0,39],[48,42,45],[44,42,46],[2,39,12],[19,10,34],[28,21,48],[42,39,28],[13,12,11],[1,36,12],[6,43,21],[13,6,48],[2,46,41],[10,15,35],[46,9,5],[35,45,21],[37,27,6],[23,20,26],[36,31,18],[2,40,24],[42,40,37],[13,29,42],[41,7,16],[48,40,15],[20,23,14],[46,15,14],[38,32,13],[23,9,17],[24,30,2],[21,32,32],[39,3,37],[35,6,42],[5,28,13],[38,11,13],[31,7,33],[11,20,10],[34,27,29],[6,3,21],[2,17,40],[41,22,48],[14,28,21],[42,38,2],[3,47,47],[36,33,1],[20,31,45],[34,22,11],[5,39,16],[39,32,20],[35,13,31],[4,8,50],[29,22,15],[29,2,29],[11,47,40],[39,48,4],[33,21,38],[25,0,35],[15,19,21],[44,11,49],[28,23,48],[10,38,9],[49,34,36],[1,39,1],[22,6,13],[40,27,27],[34,26,16],[9,10,15],[11,12,15],[33,29,13],[20,25,45],[41,22,39],[24,42,33],[12,3,24],[9,37,10],[10,32,14],[5,26,10],[20,49,31],[33,37,3],[25,0,25],[17,11,50],[22,33,48],[14,11,20],[26,47,11],[13,32,33],[12,27,5],[20,32,27],[28,15,45],[37,27,40],[1,29,26],[30,44,16],[20,34,41],[41,17,47],[32,24,34],[41,42,35],[9,15,16],[30,34,3],[15,27,11],[34,4,36],[8,9,1],[12,31,18],[38,42,27],[22,28,7],[18,22,50],[41,40,32],[24,26,7],[41,4,13],[7,44,42],[25,49,30],[8,28,26],[25,7,46],[11,3,24],[32,40,6],[24,0,3],[20,26,8],[41,24,23],[44,0,47],[6,17,47],[4,6,50],[25,34,14],[46,35,48],[43,33,20],[46,19,48],[40,15,17],[6,4,44],[38,23,3],[6,8,15],[17,13,15],[2,0,31],[45,31,26],[5,1,25],[46,17,30],[5,46,24],[42,15,44],[16,14,12],[23,48,36],[30,23,2],[11,48,22],[27,8,22],[30,32,2],[46,23,1],[26,43,36],[5,39,32],[23,27,36],[44,18,27],[9,43,21],[25,34,28],[4,38,50],[23,21,42],[38,39,41],[35,45,28],[8,1,23],[6,27,4],[30,44,21],[37,4,32],[44,36,29],[23,32,23],[47,3,33],[34,39,15],[37,32,31],[9,22,9],[2,23,37],[10,31,24],[11,8,1],[33,15,7],[40,11,26],[33,8,46],[1,41,5],[45,13,4],[15,40,41],[7,4,14],[28,9,15],[23,49,4],[15,22,42],[13,39,10],[4,19,37],[34,21,22],[2,33,13],[1,18,40],[17,46,27],[44,15,41],[3,20,11],[13,0,44],[15,44,50],[20,24,14],[49,39,15],[27,45,16],[5,8,19],[2,39,16],[37,20,28],[49,28,39],[39,12,15],[23,41,23],[1,19,30],[25,41,39],[25,17,23],[46,9,4],[37,11,21],[21,9,17],[30,10,18],[35,2,46],[10,19,37],[17,32,12],[26,4,34],[8,35,46],[10,42,43],[23,21,17],[29,47,31],[29,4,13],[18,36,40],[27,15,32],[20,14,4],[23,22,45],[37,5,1],[12,20,23],[37,32,8],[22,20,26],[12,48,37],[14,42,12],[14,8,7],[0,14,49],[37,39,45],[15,46,3],[17,13,18],[30,34,39],[23,8,20],[12,17,19],[29,21,40],[48,11,39],[37,7,3],[34,7,35],[20,9,39],[6,3,26],[11,29,50],[21,3,30],[33,24,31],[2,1,21],[22,3,38],[34,21,16],[7,42,42],[27,16,49],[23,12,15],[16,22,25],[27,23,15],[48,7,33],[14,18,45],[45,4,50],[7,36,42],[16,19,1],[16,35,3],[48,25,36],[10,8,29],[37,13,19],[36,41,20],[8,40,7],[35,32,15],[30,4,49],[7,27,41],[35,1,30],[38,48,3],[37,33,9],[48,5,41],[44,30,22],[9,7,29],[21,3,31],[0,45,8],[0,9,9],[48,49,5],[17,39,31],[29,18,1],[22,44,37],[18,9,10],[17,39,5],[13,25,47],[12,38,16],[38,25,31],[27,24,46],[35,20,18],[0,24,36],[42,8,12],[19,12,39],[45,43,20],[47,2,28],[22,29,49],[11,30,29],[36,25,16],[43,24,6],[32,40,43],[34,4,16],[14,18,46],[20,21,19],[41,30,43],[38,34,17],[10,17,27],[21,48,24],[21,4,42],[35,37,30],[8,45,1],[43,20,39],[10,11,25],[35,46,42],[27,35,20],[4,2,34],[43,44,14],[16,15,14],[9,24,28],[29,8,45],[40,0,1],[10,21,9],[4,9,43],[3,7,28],[48,11,14],[3,24,6],[28,11,36],[1,41,45],[45,1,5],[32,9,21],[15,7,2],[3,49,21],[13,12,5],[36,14,40],[11,39,29],[45,37,22],[41,5,9],[49,11,15],[46,22,15],[1,23,9],[10,40,19],[33,1,37],[31,45,29],[39,47,31],[28,2,22],[43,9,44],[30,3,48],[29,32,36],[5,39,17],[26,4,17],[18,3,5],[24,20,49],[33,8,3],[20,1,12],[46,9,11],[2,37,33],[27,0,20],[30,3,36],[5,4,46],[3,1,24],[22,23,24],[35,10,45],[45,8,18],[38,16,44],[48,9,9],[34,0,11],[46,23,23],[28,21,33],[9,8,11],[47,29,18],[38,22,17],[46,37,21],[7,5,48],[16,39,4],[49,46,40],[27,9,36],[17,33,13],[47,22,5],[5,46,7],[20,16,9],[27,23,36],[9,4,43],[47,36,42],[6,28,46],[31,4,33],[34,43,46],[18,11,7],[29,25,46],[36,33,46],[42,15,5],[49,13,2],[20,38,8],[37,31,3],[32,44,2],[31,11,29],[9,18,31],[1,15,43],[28,36,7],[40,5,35],[13,24,43],[37,12,38],[12,44,33],[34,9,15],[16,19,32],[42,4,36],[37,3,14],[19,1,5],[31,2,11],[4,49,28],[23,31,42],[17,9,28],[32,19,14],[29,9,24],[15,21,22],[36,8,36],[9,31,8],[37,16,47],[32,30,37],[26,0,19],[20,21,20],[47,21,44],[43,47,37],[5,28,42],[7,37,9],[40,45,48],[24,27,4],[1,13,21],[36,48,26],[3,11,34],[25,29,8],[23,48,29],[37,35,18],[37,6,26],[25,22,48],[23,32,18],[33,10,37],[25,24,27],[17,36,30],[25,40,3],[23,16,20],[0,2,28],[19,24,1],[14,4,40],[17,31,7],[38,21,15],[45,14,7],[32,28,14],[12,5,41],[33,19,15],[19,5,29],[29,41,41],[43,2,13],[37,6,40],[7,11,25],[19,41,38],[43,39,20],[8,2,18],[34,30,37],[24,42,31],[42,39,25],[40,33,28],[3,22,8],[11,32,23],[7,2,8],[45,25,25],[28,12,12],[21,11,37],[28,32,27],[0,21,8],[36,0,13],[25,3,38],[13,18,15],[45,18,7],[47,45,29],[15,35,45],[17,26,9],[34,4,16],[41,12,39],[28,31,25],[41,7,23],[13,25,4],[43,9,2],[49,11,35],[1,0,44],[30,2,34],[28,34,29],[36,17,12],[3,0,3],[16,13,39],[21,48,46],[14,34,45],[9,13,24],[46,16,49],[25,29,40],[7,34,47],[20,14,21],[4,43,12],[19,37,48],[35,40,22],[44,19,3],[20,34,24],[5,33,12],[35,22,9],[7,37,2],[7,27,10],[20,10,18],[42,26,26],[15,5,48],[44,40,10],[45,39,34],[3,1,48],[39,3,40],[25,44,25],[39,12,35],[2,33,47],[13,28,19],[43,21,29],[26,12,45],[32,30,39],[6,24,4],[48,2,32],[26,29,22],[4,37,35],[12,42,47],[10,9,1],[0,16,49],[5,32,20],[40,14,16],[3,23,32],[23,19,19],[23,42,38],[41,47,17],[35,7,50],[20,31,44],[36,42,20],[45,5,22],[30,46,37],[28,14,18],[13,27,16],[24,42,50],[13,45,30],[42,23,27],[23,6,7],[38,20,37],[6,34,25],[30,1,28],[16,33,28],[26,17,50],[25,28,10],[29,18,38],[7,25,22],[20,42,48],[36,2,46],[34,47,4],[10,3,40],[5,19,32],[32,10,9],[32,6,11],[32,6,9],[5,25,33],[36,44,13],[44,33,18],[35,42,18],[17,2,41],[42,18,49],[41,46,37],[23,26,26],[30,19,5],[22,6,26],[32,42,26],[49,21,38],[12,10,9],[18,11,27],[30,40,2],[31,34,19],[31,36,19]]\\n[73,745,752,321,138,703,619,28,645,724,388,653,58,298,354,790,674,885,954,928,18,712,636,450,325,599,11,781,546,324,942,905,747,806,402,712,968,778,750,53,598,833,700,458,875,703,707,667,100,434]\\n```\\n\\n```\\n Output: 805\\nExpected: 536 \\n```\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        Map<Integer, List<int[]>> graph = new HashMap();\\n        for(int[] edge: edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0], new ArrayList());\\n            }\\n            if(!graph.containsKey(edge[1])){\\n                graph.put(edge[1], new ArrayList());\\n            }\\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\\n        }\\n        \\n        int[] visited = new int[passingFees.length];\\n        int[] memo = new int[passingFees.length];\\n        Arrays.fill(memo, -1);\\n        visited[0]=1;\\n        int min = dfs(graph, maxTime, passingFees, 0,visited,memo, 0);\\n        return min ==  Integer.MAX_VALUE ? -1 : min;\\n    }\\n    \\n    public int dfs(Map<Integer, List<int[]>> graph, int maxTime, \\n                   int[] passingFees, int currNode, int[] visited, \\n                   int[] memo, int currTime){\\n        \\n        if(currNode == passingFees.length-1 && currTime <= maxTime){\\n            return passingFees[currNode];\\n        }\\n        if(currTime > maxTime || !graph.containsKey(currNode)){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(memo[currNode] != -1){\\n            return memo[currNode] ;\\n        }\\n        int checkMin = Integer.MAX_VALUE;\\n        int check = Integer.MAX_VALUE;\\n        for(int i=0;i<graph.get(currNode).size();i++){\\n            int nextNode = graph.get(currNode).get(i)[0];\\n            int nextNodeTime = graph.get(currNode).get(i)[1];\\n            if(visited[nextNode] != 1){\\n                visited[nextNode] = 1;\\n                check =\\n                    dfs(graph, maxTime, passingFees, nextNode,\\n                       visited,memo, currTime+nextNodeTime);\\n                visited[nextNode] = 0;\\n            }\\n\\n                checkMin = Math.min(check, checkMin);\\n            \\n            \\n        }\\n        int curr= (checkMin == Integer.MAX_VALUE ? Integer.MAX_VALUE : passingFees[currNode]+checkMin);\\n        memo[currNode] = curr;\\n        return curr;\\n    }\\n}\\n\\n```\n```\\n119\\n[[9,18,2],[1,35,4],[24,26,34],[2,47,19],[15,31,33],[21,10,37],[35,33,20],[32,15,40],[13,5,33],[28,34,4],[31,11,31],[17,34,20],[49,48,33],[37,35,34],[21,26,2],[42,11,22],[15,49,1],[4,36,26],[32,31,39],[37,23,4],[32,34,39],[2,46,13],[34,19,9],[11,14,20],[34,12,50],[43,8,38],[24,8,19],[3,28,42],[38,8,44],[10,34,11],[37,1,33],[28,31,11],[4,42,42],[23,13,4],[12,27,29],[33,6,17],[32,27,16],[26,29,24],[26,14,39],[36,42,36],[17,22,50],[9,6,45],[48,24,27],[45,9,23],[49,42,47],[3,27,47],[38,46,45],[4,2,11],[33,23,38],[14,38,48],[46,20,29],[30,13,25],[5,30,22],[6,32,9],[37,15,48],[27,0,23],[37,44,43],[21,11,39],[36,25,8],[31,30,1],[27,39,14],[11,0,25],[31,1,7],[9,29,7],[15,44,32],[44,39,42],[22,1,42],[3,6,39],[41,32,48],[28,10,38],[19,47,46],[16,14,13],[29,8,37],[48,12,11],[37,41,19],[6,21,22],[25,34,8],[30,29,42],[30,35,3],[7,3,13],[48,22,13],[49,34,41],[7,0,39],[48,42,45],[44,42,46],[2,39,12],[19,10,34],[28,21,48],[42,39,28],[13,12,11],[1,36,12],[6,43,21],[13,6,48],[2,46,41],[10,15,35],[46,9,5],[35,45,21],[37,27,6],[23,20,26],[36,31,18],[2,40,24],[42,40,37],[13,29,42],[41,7,16],[48,40,15],[20,23,14],[46,15,14],[38,32,13],[23,9,17],[24,30,2],[21,32,32],[39,3,37],[35,6,42],[5,28,13],[38,11,13],[31,7,33],[11,20,10],[34,27,29],[6,3,21],[2,17,40],[41,22,48],[14,28,21],[42,38,2],[3,47,47],[36,33,1],[20,31,45],[34,22,11],[5,39,16],[39,32,20],[35,13,31],[4,8,50],[29,22,15],[29,2,29],[11,47,40],[39,48,4],[33,21,38],[25,0,35],[15,19,21],[44,11,49],[28,23,48],[10,38,9],[49,34,36],[1,39,1],[22,6,13],[40,27,27],[34,26,16],[9,10,15],[11,12,15],[33,29,13],[20,25,45],[41,22,39],[24,42,33],[12,3,24],[9,37,10],[10,32,14],[5,26,10],[20,49,31],[33,37,3],[25,0,25],[17,11,50],[22,33,48],[14,11,20],[26,47,11],[13,32,33],[12,27,5],[20,32,27],[28,15,45],[37,27,40],[1,29,26],[30,44,16],[20,34,41],[41,17,47],[32,24,34],[41,42,35],[9,15,16],[30,34,3],[15,27,11],[34,4,36],[8,9,1],[12,31,18],[38,42,27],[22,28,7],[18,22,50],[41,40,32],[24,26,7],[41,4,13],[7,44,42],[25,49,30],[8,28,26],[25,7,46],[11,3,24],[32,40,6],[24,0,3],[20,26,8],[41,24,23],[44,0,47],[6,17,47],[4,6,50],[25,34,14],[46,35,48],[43,33,20],[46,19,48],[40,15,17],[6,4,44],[38,23,3],[6,8,15],[17,13,15],[2,0,31],[45,31,26],[5,1,25],[46,17,30],[5,46,24],[42,15,44],[16,14,12],[23,48,36],[30,23,2],[11,48,22],[27,8,22],[30,32,2],[46,23,1],[26,43,36],[5,39,32],[23,27,36],[44,18,27],[9,43,21],[25,34,28],[4,38,50],[23,21,42],[38,39,41],[35,45,28],[8,1,23],[6,27,4],[30,44,21],[37,4,32],[44,36,29],[23,32,23],[47,3,33],[34,39,15],[37,32,31],[9,22,9],[2,23,37],[10,31,24],[11,8,1],[33,15,7],[40,11,26],[33,8,46],[1,41,5],[45,13,4],[15,40,41],[7,4,14],[28,9,15],[23,49,4],[15,22,42],[13,39,10],[4,19,37],[34,21,22],[2,33,13],[1,18,40],[17,46,27],[44,15,41],[3,20,11],[13,0,44],[15,44,50],[20,24,14],[49,39,15],[27,45,16],[5,8,19],[2,39,16],[37,20,28],[49,28,39],[39,12,15],[23,41,23],[1,19,30],[25,41,39],[25,17,23],[46,9,4],[37,11,21],[21,9,17],[30,10,18],[35,2,46],[10,19,37],[17,32,12],[26,4,34],[8,35,46],[10,42,43],[23,21,17],[29,47,31],[29,4,13],[18,36,40],[27,15,32],[20,14,4],[23,22,45],[37,5,1],[12,20,23],[37,32,8],[22,20,26],[12,48,37],[14,42,12],[14,8,7],[0,14,49],[37,39,45],[15,46,3],[17,13,18],[30,34,39],[23,8,20],[12,17,19],[29,21,40],[48,11,39],[37,7,3],[34,7,35],[20,9,39],[6,3,26],[11,29,50],[21,3,30],[33,24,31],[2,1,21],[22,3,38],[34,21,16],[7,42,42],[27,16,49],[23,12,15],[16,22,25],[27,23,15],[48,7,33],[14,18,45],[45,4,50],[7,36,42],[16,19,1],[16,35,3],[48,25,36],[10,8,29],[37,13,19],[36,41,20],[8,40,7],[35,32,15],[30,4,49],[7,27,41],[35,1,30],[38,48,3],[37,33,9],[48,5,41],[44,30,22],[9,7,29],[21,3,31],[0,45,8],[0,9,9],[48,49,5],[17,39,31],[29,18,1],[22,44,37],[18,9,10],[17,39,5],[13,25,47],[12,38,16],[38,25,31],[27,24,46],[35,20,18],[0,24,36],[42,8,12],[19,12,39],[45,43,20],[47,2,28],[22,29,49],[11,30,29],[36,25,16],[43,24,6],[32,40,43],[34,4,16],[14,18,46],[20,21,19],[41,30,43],[38,34,17],[10,17,27],[21,48,24],[21,4,42],[35,37,30],[8,45,1],[43,20,39],[10,11,25],[35,46,42],[27,35,20],[4,2,34],[43,44,14],[16,15,14],[9,24,28],[29,8,45],[40,0,1],[10,21,9],[4,9,43],[3,7,28],[48,11,14],[3,24,6],[28,11,36],[1,41,45],[45,1,5],[32,9,21],[15,7,2],[3,49,21],[13,12,5],[36,14,40],[11,39,29],[45,37,22],[41,5,9],[49,11,15],[46,22,15],[1,23,9],[10,40,19],[33,1,37],[31,45,29],[39,47,31],[28,2,22],[43,9,44],[30,3,48],[29,32,36],[5,39,17],[26,4,17],[18,3,5],[24,20,49],[33,8,3],[20,1,12],[46,9,11],[2,37,33],[27,0,20],[30,3,36],[5,4,46],[3,1,24],[22,23,24],[35,10,45],[45,8,18],[38,16,44],[48,9,9],[34,0,11],[46,23,23],[28,21,33],[9,8,11],[47,29,18],[38,22,17],[46,37,21],[7,5,48],[16,39,4],[49,46,40],[27,9,36],[17,33,13],[47,22,5],[5,46,7],[20,16,9],[27,23,36],[9,4,43],[47,36,42],[6,28,46],[31,4,33],[34,43,46],[18,11,7],[29,25,46],[36,33,46],[42,15,5],[49,13,2],[20,38,8],[37,31,3],[32,44,2],[31,11,29],[9,18,31],[1,15,43],[28,36,7],[40,5,35],[13,24,43],[37,12,38],[12,44,33],[34,9,15],[16,19,32],[42,4,36],[37,3,14],[19,1,5],[31,2,11],[4,49,28],[23,31,42],[17,9,28],[32,19,14],[29,9,24],[15,21,22],[36,8,36],[9,31,8],[37,16,47],[32,30,37],[26,0,19],[20,21,20],[47,21,44],[43,47,37],[5,28,42],[7,37,9],[40,45,48],[24,27,4],[1,13,21],[36,48,26],[3,11,34],[25,29,8],[23,48,29],[37,35,18],[37,6,26],[25,22,48],[23,32,18],[33,10,37],[25,24,27],[17,36,30],[25,40,3],[23,16,20],[0,2,28],[19,24,1],[14,4,40],[17,31,7],[38,21,15],[45,14,7],[32,28,14],[12,5,41],[33,19,15],[19,5,29],[29,41,41],[43,2,13],[37,6,40],[7,11,25],[19,41,38],[43,39,20],[8,2,18],[34,30,37],[24,42,31],[42,39,25],[40,33,28],[3,22,8],[11,32,23],[7,2,8],[45,25,25],[28,12,12],[21,11,37],[28,32,27],[0,21,8],[36,0,13],[25,3,38],[13,18,15],[45,18,7],[47,45,29],[15,35,45],[17,26,9],[34,4,16],[41,12,39],[28,31,25],[41,7,23],[13,25,4],[43,9,2],[49,11,35],[1,0,44],[30,2,34],[28,34,29],[36,17,12],[3,0,3],[16,13,39],[21,48,46],[14,34,45],[9,13,24],[46,16,49],[25,29,40],[7,34,47],[20,14,21],[4,43,12],[19,37,48],[35,40,22],[44,19,3],[20,34,24],[5,33,12],[35,22,9],[7,37,2],[7,27,10],[20,10,18],[42,26,26],[15,5,48],[44,40,10],[45,39,34],[3,1,48],[39,3,40],[25,44,25],[39,12,35],[2,33,47],[13,28,19],[43,21,29],[26,12,45],[32,30,39],[6,24,4],[48,2,32],[26,29,22],[4,37,35],[12,42,47],[10,9,1],[0,16,49],[5,32,20],[40,14,16],[3,23,32],[23,19,19],[23,42,38],[41,47,17],[35,7,50],[20,31,44],[36,42,20],[45,5,22],[30,46,37],[28,14,18],[13,27,16],[24,42,50],[13,45,30],[42,23,27],[23,6,7],[38,20,37],[6,34,25],[30,1,28],[16,33,28],[26,17,50],[25,28,10],[29,18,38],[7,25,22],[20,42,48],[36,2,46],[34,47,4],[10,3,40],[5,19,32],[32,10,9],[32,6,11],[32,6,9],[5,25,33],[36,44,13],[44,33,18],[35,42,18],[17,2,41],[42,18,49],[41,46,37],[23,26,26],[30,19,5],[22,6,26],[32,42,26],[49,21,38],[12,10,9],[18,11,27],[30,40,2],[31,34,19],[31,36,19]]\\n[73,745,752,321,138,703,619,28,645,724,388,653,58,298,354,790,674,885,954,928,18,712,636,450,325,599,11,781,546,324,942,905,747,806,402,712,968,778,750,53,598,833,700,458,875,703,707,667,100,434]\\n```\n```\\n Output: 805\\nExpected: 536 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644979,
                "title": "please-help-my-dp-solution-is-giving-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    void buildGraph(int graph[][1000],vector<vector<int> >&edges){\\n\\tfor(int i=0;i<edges.size();++i){\\n//\\t\\tcout<<edges[i][0]<<\" \"<<edges[i][1]<<\" \"<<edges[i][2]<<endl;\\n\\t\\tgraph[edges[i][0]][edges[i][1]]=edges[i][2];\\n\\t\\tgraph[edges[i][1]][edges[i][0]]=edges[i][2];\\n\\t}\\n}\\nint solve(int graph[][1000],int n,int u,vector<bool>&vis,vector<int>&cost,int maxtime,int dp[][1000]){\\n\\tif(dp[maxtime][u]!=-1){\\n\\treturn dp[maxtime][u];\\t\\n\\t}\\n    if(u==n-1){\\n        return cost[n-1];\\n    }\\n\\n\\tvis[u]=1;\\n\\tint ans=1e7,k=1e7;\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(!vis[i]&&graph[u][i]!=0&&maxtime-graph[u][i]>=0){\\n\\t\\t\\tk=cost[u]+solve(graph,n,i,vis,cost,maxtime-graph[u][i],dp);\\n\\t\\t}\\n        ans=min(ans,k);\\n\\t}\\n\\tvis[u]=0;\\n\\treturn dp[u][maxtime]=ans;\\n}\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n    int n=cost.size();\\n\\tint graph[1000][1000];\\n\\tmemset(graph,0,sizeof graph);\\n\\tbuildGraph(graph,edges);\\n\\tvector<bool>vis(n+1,0);\\n\\tint dp[1000][1000];\\n\\tmemset(dp,-1,sizeof dp);\\n\\tint m=solve(graph,n,0,vis,cost,maxTime,dp);\\n        if(m==1e7)return -1;\\n        return m; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void buildGraph(int graph[][1000],vector<vector<int> >&edges){\\n\\tfor(int i=0;i<edges.size();++i){\\n//\\t\\tcout<<edges[i][0]<<\" \"<<edges[i][1]<<\" \"<<edges[i][2]<<endl;\\n\\t\\tgraph[edges[i][0]][edges[i][1]]=edges[i][2];\\n\\t\\tgraph[edges[i][1]][edges[i][0]]=edges[i][2];\\n\\t}\\n}\\nint solve(int graph[][1000],int n,int u,vector<bool>&vis,vector<int>&cost,int maxtime,int dp[][1000]){\\n\\tif(dp[maxtime][u]!=-1){\\n\\treturn dp[maxtime][u];\\t\\n\\t}\\n    if(u==n-1){\\n        return cost[n-1];\\n    }\\n\\n\\tvis[u]=1;\\n\\tint ans=1e7,k=1e7;\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tif(!vis[i]&&graph[u][i]!=0&&maxtime-graph[u][i]>=0){\\n\\t\\t\\tk=cost[u]+solve(graph,n,i,vis,cost,maxtime-graph[u][i],dp);\\n\\t\\t}\\n        ans=min(ans,k);\\n\\t}\\n\\tvis[u]=0;\\n\\treturn dp[u][maxtime]=ans;\\n}\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n    int n=cost.size();\\n\\tint graph[1000][1000];\\n\\tmemset(graph,0,sizeof graph);\\n\\tbuildGraph(graph,edges);\\n\\tvector<bool>vis(n+1,0);\\n\\tint dp[1000][1000];\\n\\tmemset(dp,-1,sizeof dp);\\n\\tint m=solve(graph,n,0,vis,cost,maxTime,dp);\\n        if(m==1e7)return -1;\\n        return m; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1633404,
                "title": "java-slow-basic-solution-without-optimization-but-intuition",
                "content": "Hi Folks, just the first solution that came to mind with Dijsktra, the only modification being if node has already been visited we still want that node to be given another chance to reach the goal node.\\n\\nIn other words, if by dikstra shortest cost path has been visited but the total path length used to reach in that instance was more, we don\\'t want to mark is visited rather mark [node][pathCostTillNow] as visited. This is the idea.\\n\\n```\\nclass Solution {\\n    private Map<Integer, List<Pair<Integer, Integer>>> map;\\n    static class Node implements Comparable<Node> {\\n        int id;\\n        int cost;\\n        int totalPath;\\n        \\n        public Node(int id, int cost, int totalPath) {\\n            this.id = id;\\n            this.cost = cost;\\n            this.totalPath = totalPath;\\n        }\\n        \\n        public int compareTo(Node o) {\\n            return this.cost - o.cost;\\n        }\\n    }\\n    \\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        map = new HashMap<>();\\n        populate(edges);\\n        boolean [][] vis = new boolean[edges.length+1][9000];\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n        pq.offer(new Node(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()) {\\n            Node cur = pq.poll();\\n            if(vis[cur.id][cur.totalPath] || cur.totalPath>maxTime) continue;\\n            if(cur.id == passingFees.length - 1) return cur.cost;\\n            vis[cur.id][cur.totalPath] = true;\\n            for(Pair<Integer, Integer> nei: map.getOrDefault(cur.id, new ArrayList<>())) {\\n                if(!vis[nei.getKey()][cur.totalPath+nei.getValue()]) {\\n                    pq.add(\\n                        new Node(\\n                            nei.getKey(),\\n                            cur.cost + passingFees[nei.getKey()],\\n                            cur.totalPath + nei.getValue())\\n                    );\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private void populate(int [][]edges) {\\n        \\n        for(int i=0;i<=edges.length;i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        for(int []e: edges) {\\n            map.get(e[0]).add(new Pair(e[1], e[2]));\\n            map.get(e[1]).add(new Pair(e[0], e[2]));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Map<Integer, List<Pair<Integer, Integer>>> map;\\n    static class Node implements Comparable<Node> {\\n        int id;\\n        int cost;\\n        int totalPath;\\n        \\n        public Node(int id, int cost, int totalPath) {\\n            this.id = id;\\n            this.cost = cost;\\n            this.totalPath = totalPath;\\n        }\\n        \\n        public int compareTo(Node o) {\\n            return this.cost - o.cost;\\n        }\\n    }\\n    \\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        map = new HashMap<>();\\n        populate(edges);\\n        boolean [][] vis = new boolean[edges.length+1][9000];\\n        PriorityQueue<Node> pq = new PriorityQueue<>();\\n        pq.offer(new Node(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()) {\\n            Node cur = pq.poll();\\n            if(vis[cur.id][cur.totalPath] || cur.totalPath>maxTime) continue;\\n            if(cur.id == passingFees.length - 1) return cur.cost;\\n            vis[cur.id][cur.totalPath] = true;\\n            for(Pair<Integer, Integer> nei: map.getOrDefault(cur.id, new ArrayList<>())) {\\n                if(!vis[nei.getKey()][cur.totalPath+nei.getValue()]) {\\n                    pq.add(\\n                        new Node(\\n                            nei.getKey(),\\n                            cur.cost + passingFees[nei.getKey()],\\n                            cur.totalPath + nei.getValue())\\n                    );\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private void populate(int [][]edges) {\\n        \\n        for(int i=0;i<=edges.length;i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        for(int []e: edges) {\\n            map.get(e[0]).add(new Pair(e[1], e[2]));\\n            map.get(e[1]).add(new Pair(e[0], e[2]));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589954,
                "title": "java-dp",
                "content": "Java DP\\n\\n```\\nclass Solution {\\n    class Data{\\n        int node;\\n        int time;\\n        public Data(int node,int time){\\n            this.node = node;\\n            this.time = time;\\n        }\\n    }\\n    HashMap<Integer,List<Data>> graph = new HashMap<>();\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        for(int [] edge : edges){\\n            List<Data> list = graph.getOrDefault(edge[0],new ArrayList<>());\\n            list.add(new Data(edge[1],edge[2]));\\n            graph.put(edge[0],list);\\n            list = graph.getOrDefault(edge[1],new ArrayList<>());\\n            list.add(new Data(edge[0],edge[2]));\\n            graph.put(edge[1],list);\\n        }\\n        int [][]dp = new int[passingFees.length][maxTime+1];\\n        for(int [] row : dp)Arrays.fill(row,-1);\\n        int val = solve(0,0,maxTime,passingFees,dp);\\n        return val == Integer.MAX_VALUE?-1:val;\\n    }\\n    \\n    private int solve(int curr,int time,int maxTime,int[]passingFees,int[][]dp){\\n        if(curr==passingFees.length-1){\\n            return time<=maxTime?passingFees[passingFees.length-1]:Integer.MAX_VALUE;\\n        }\\n        if(time>maxTime){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(curr>=passingFees.length){\\n            return 0;\\n        }\\n        if(dp[curr][time]!=-1){\\n            return dp[curr][time];\\n        }\\n        int best = Integer.MAX_VALUE;\\n        if(graph.containsKey(curr)){\\n            for(Data next : graph.get(curr)){\\n                int val = solve(next.node,time+next.time,maxTime,passingFees,dp);\\n                if(val!=Integer.MAX_VALUE){\\n                    best = Math.min(best,val+passingFees[curr]);\\n                }\\n            }\\n        }\\n        \\n        return dp[curr][time]=best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    class Data{\\n        int node;\\n        int time;\\n        public Data(int node,int time){\\n            this.node = node;\\n            this.time = time;\\n        }\\n    }\\n    HashMap<Integer,List<Data>> graph = new HashMap<>();\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        for(int [] edge : edges){\\n            List<Data> list = graph.getOrDefault(edge[0],new ArrayList<>());\\n            list.add(new Data(edge[1],edge[2]));\\n            graph.put(edge[0],list);\\n            list = graph.getOrDefault(edge[1],new ArrayList<>());\\n            list.add(new Data(edge[0],edge[2]));\\n            graph.put(edge[1],list);\\n        }\\n        int [][]dp = new int[passingFees.length][maxTime+1];\\n        for(int [] row : dp)Arrays.fill(row,-1);\\n        int val = solve(0,0,maxTime,passingFees,dp);\\n        return val == Integer.MAX_VALUE?-1:val;\\n    }\\n    \\n    private int solve(int curr,int time,int maxTime,int[]passingFees,int[][]dp){\\n        if(curr==passingFees.length-1){\\n            return time<=maxTime?passingFees[passingFees.length-1]:Integer.MAX_VALUE;\\n        }\\n        if(time>maxTime){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(curr>=passingFees.length){\\n            return 0;\\n        }\\n        if(dp[curr][time]!=-1){\\n            return dp[curr][time];\\n        }\\n        int best = Integer.MAX_VALUE;\\n        if(graph.containsKey(curr)){\\n            for(Data next : graph.get(curr)){\\n                int val = solve(next.node,time+next.time,maxTime,passingFees,dp);\\n                if(val!=Integer.MAX_VALUE){\\n                    best = Math.min(best,val+passingFees[curr]);\\n                }\\n            }\\n        }\\n        \\n        return dp[curr][time]=best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558242,
                "title": "javascript-dijkstra",
                "content": "```\\nvar minCost = function(maxTime, raw_edges, raw_fees) {\\n    const [length, start, end] = [raw_fees.length, 0, raw_fees.length - 1];\\n    const [edges, times, fees] = [new Map(), Array.from({length}).fill(Infinity), Array.from({length}).fill(Infinity)];\\n    const [edge, bi_dir, compare, time, fee] = [\\n        (u, v, t) => edges.set(u, (edges.get(u) || new Set()).add([v, t])),\\n        ([u,v,t]) => { edge(u,v,t); edge(v,u,t); },\\n        ([,[t1, f1]], [,[t2, f2]]) => f1 === f2 ? t1 - t2 : f1 - f2,\\n        (city, t) => t < times[city], (city, f) => f < fees[city]        \\n    ];\\n    raw_edges.forEach(bi_dir);\\n    const q = new MinPriorityQueue({compare});\\n    q.enqueue([start, [0, raw_fees[start]]]);\\n    [times[start], fees[start]] = [0, raw_fees[start]];\\n    while(q.size()) {\\n        const [cur, [cur_time, cur_fee]] = q.dequeue();\\n        for(const [next, next_time] of edges.get(cur)) {\\n            const [new_time, new_fee] = [cur_time + next_time, cur_fee + raw_fees[next]];\\n            if(new_time > maxTime)\\n                continue;\\n            const [better_time, better_fee] = [time(next, new_time), fee(next, new_fee)];\\n            if(!better_time && !better_fee)\\n                continue;\\n            q.enqueue([next, [new_time, new_fee]]);\\n            if(better_time) times[next] = new_time;\\n            if(better_fee) fees[next] = new_fee;\\n        }\\n    }\\n    return fees[end] < Infinity ? fees[end] : -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minCost = function(maxTime, raw_edges, raw_fees) {\\n    const [length, start, end] = [raw_fees.length, 0, raw_fees.length - 1];\\n    const [edges, times, fees] = [new Map(), Array.from({length}).fill(Infinity), Array.from({length}).fill(Infinity)];\\n    const [edge, bi_dir, compare, time, fee] = [\\n        (u, v, t) => edges.set(u, (edges.get(u) || new Set()).add([v, t])),\\n        ([u,v,t]) => { edge(u,v,t); edge(v,u,t); },\\n        ([,[t1, f1]], [,[t2, f2]]) => f1 === f2 ? t1 - t2 : f1 - f2,\\n        (city, t) => t < times[city], (city, f) => f < fees[city]        \\n    ];\\n    raw_edges.forEach(bi_dir);\\n    const q = new MinPriorityQueue({compare});\\n    q.enqueue([start, [0, raw_fees[start]]]);\\n    [times[start], fees[start]] = [0, raw_fees[start]];\\n    while(q.size()) {\\n        const [cur, [cur_time, cur_fee]] = q.dequeue();\\n        for(const [next, next_time] of edges.get(cur)) {\\n            const [new_time, new_fee] = [cur_time + next_time, cur_fee + raw_fees[next]];\\n            if(new_time > maxTime)\\n                continue;\\n            const [better_time, better_fee] = [time(next, new_time), fee(next, new_fee)];\\n            if(!better_time && !better_fee)\\n                continue;\\n            q.enqueue([next, [new_time, new_fee]]);\\n            if(better_time) times[next] = new_time;\\n            if(better_fee) fees[next] = new_fee;\\n        }\\n    }\\n    return fees[end] < Infinity ? fees[end] : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532663,
                "title": "java-priorityqueue-solution",
                "content": "```\\npublic int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n\\t\\tint nodes = passingFees.length, res = 0;\\n        int[] minTime = new int[nodes];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        List<int[]> graph[] = new List[nodes];\\n        for (int i=0;i<nodes;i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            graph[(edge[0])].add(new int[]{edge[1], edge[2]});\\n            graph[(edge[1])].add(new int[]{edge[0], edge[2]});\\n        }\\n        PriorityQueue<int[]> pQ = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n        pQ.offer(new int[]{0, passingFees[0], 0});\\n\\n        while (!pQ.isEmpty()) {\\n            int[] top = pQ.poll();\\n            int sNode = top[0];\\n            int feeTillHere = top[1];\\n            int timeTaken = top[2];\\n\\n            // If the time taken to reach at this node is greater than already minTime till node OR\\n            // timeTaken is more than max allowed time.\\n            if (timeTaken >= minTime[sNode] || timeTaken > maxTime) {\\n                continue;\\n            }\\n\\n            // If its the final node return the fees\\n            if (sNode == nodes-1) {\\n                return feeTillHere;\\n            }\\n\\n            minTime[sNode] = Math.min(timeTaken, minTime[sNode]);\\n\\n            for (int[] child : graph[sNode]) {\\n                int newNode = child[0];\\n                int newTime = timeTaken + child[1];\\n                int totalFees = feeTillHere + passingFees[newNode];\\n                \\n                pQ.offer(new int[]{newNode, totalFees, newTime});\\n            }\\n        }\\n\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n\\t\\tint nodes = passingFees.length, res = 0;\\n        int[] minTime = new int[nodes];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        List<int[]> graph[] = new List[nodes];\\n        for (int i=0;i<nodes;i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            graph[(edge[0])].add(new int[]{edge[1], edge[2]});\\n            graph[(edge[1])].add(new int[]{edge[0], edge[2]});\\n        }\\n        PriorityQueue<int[]> pQ = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n        pQ.offer(new int[]{0, passingFees[0], 0});\\n\\n        while (!pQ.isEmpty()) {\\n            int[] top = pQ.poll();\\n            int sNode = top[0];\\n            int feeTillHere = top[1];\\n            int timeTaken = top[2];\\n\\n            // If the time taken to reach at this node is greater than already minTime till node OR\\n            // timeTaken is more than max allowed time.\\n            if (timeTaken >= minTime[sNode] || timeTaken > maxTime) {\\n                continue;\\n            }\\n\\n            // If its the final node return the fees\\n            if (sNode == nodes-1) {\\n                return feeTillHere;\\n            }\\n\\n            minTime[sNode] = Math.min(timeTaken, minTime[sNode]);\\n\\n            for (int[] child : graph[sNode]) {\\n                int newNode = child[0];\\n                int newTime = timeTaken + child[1];\\n                int totalFees = feeTillHere + passingFees[newNode];\\n                \\n                pQ.offer(new int[]{newNode, totalFees, newTime});\\n            }\\n        }\\n\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1529039,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        // first optimize on cost then time\\n        final PriorityQueue<Tuple> pq = new PriorityQueue<>((a, b) -> {\\n            if(a.cost != b.cost) {\\n                return a.cost - b.cost;\\n            }\\n            return a.time - b.time;\\n        });\\n        final int n = passingFees.length;\\n        final int[] minTime = new int[n];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        \\n        final Graph graph = new Graph();\\n        for(final int[] edge : edges) {\\n            graph.addEdge(edge[0], edge[1], edge[2]);\\n        }\\n        pq.offer(new Tuple(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()) {\\n            final Tuple curr = pq.poll();\\n            if(curr.time > maxTime || curr.time >= minTime[curr.node]) {\\n                continue;\\n            }\\n            minTime[curr.node] = curr.time;\\n            if(curr.node == n - 1) {\\n                return curr.cost;\\n            }\\n            for(final Edge edge : graph.getEdges(curr.node)) {\\n                final int time = curr.time + edge.weight;\\n                if(time > maxTime) {\\n                    continue;\\n                }\\n                if(time >= minTime[edge.dst]) {\\n                    continue;\\n                }\\n                pq.offer(new Tuple(edge.dst, curr.cost + passingFees[edge.dst], time));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private final static class Graph {\\n        private final Map<Integer, List<Edge>> edges = new HashMap<>();\\n        \\n        private void addEdge(final int src, final int dst, final int weight) {\\n            this.edges.computeIfAbsent(src , k -> new ArrayList<>()).add(new Edge(src, dst, weight));\\n            this.edges.computeIfAbsent(dst , k -> new ArrayList<>()).add(new Edge(dst, src, weight));\\n        }\\n        \\n        private List<Edge> getEdges(final int node) {\\n            return this.edges.getOrDefault(node, new ArrayList<>());\\n        }\\n    }\\n    \\n    private static final class Edge {\\n        private final int src;\\n        private final int dst;\\n        private final int weight;\\n        \\n        private Edge(final int src, final int dst, final int weight) {\\n            this.src = src;\\n            this.dst = dst;\\n            this.weight = weight;\\n        }\\n        \\n        public String toString() {\\n            return \"(\" + src + \",\" + dst + \",\" + weight + \")\";\\n        }\\n    }\\n    \\n    private static final class Tuple {\\n        private final int node;\\n        private final int cost;\\n        private final int time;\\n        \\n        private Tuple(final int node, final int cost, final int time) {\\n            this.node = node;\\n            this.cost = cost;\\n            this.time = time;\\n        }\\n        \\n        public String toString() {\\n            return \"(\" + node + \",\" + cost + \",\" + time + \")\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        // first optimize on cost then time\\n        final PriorityQueue<Tuple> pq = new PriorityQueue<>((a, b) -> {\\n            if(a.cost != b.cost) {\\n                return a.cost - b.cost;\\n            }\\n            return a.time - b.time;\\n        });\\n        final int n = passingFees.length;\\n        final int[] minTime = new int[n];\\n        Arrays.fill(minTime, Integer.MAX_VALUE);\\n        \\n        final Graph graph = new Graph();\\n        for(final int[] edge : edges) {\\n            graph.addEdge(edge[0], edge[1], edge[2]);\\n        }\\n        pq.offer(new Tuple(0, passingFees[0], 0));\\n        \\n        while(!pq.isEmpty()) {\\n            final Tuple curr = pq.poll();\\n            if(curr.time > maxTime || curr.time >= minTime[curr.node]) {\\n                continue;\\n            }\\n            minTime[curr.node] = curr.time;\\n            if(curr.node == n - 1) {\\n                return curr.cost;\\n            }\\n            for(final Edge edge : graph.getEdges(curr.node)) {\\n                final int time = curr.time + edge.weight;\\n                if(time > maxTime) {\\n                    continue;\\n                }\\n                if(time >= minTime[edge.dst]) {\\n                    continue;\\n                }\\n                pq.offer(new Tuple(edge.dst, curr.cost + passingFees[edge.dst], time));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private final static class Graph {\\n        private final Map<Integer, List<Edge>> edges = new HashMap<>();\\n        \\n        private void addEdge(final int src, final int dst, final int weight) {\\n            this.edges.computeIfAbsent(src , k -> new ArrayList<>()).add(new Edge(src, dst, weight));\\n            this.edges.computeIfAbsent(dst , k -> new ArrayList<>()).add(new Edge(dst, src, weight));\\n        }\\n        \\n        private List<Edge> getEdges(final int node) {\\n            return this.edges.getOrDefault(node, new ArrayList<>());\\n        }\\n    }\\n    \\n    private static final class Edge {\\n        private final int src;\\n        private final int dst;\\n        private final int weight;\\n        \\n        private Edge(final int src, final int dst, final int weight) {\\n            this.src = src;\\n            this.dst = dst;\\n            this.weight = weight;\\n        }\\n        \\n        public String toString() {\\n            return \"(\" + src + \",\" + dst + \",\" + weight + \")\";\\n        }\\n    }\\n    \\n    private static final class Tuple {\\n        private final int node;\\n        private final int cost;\\n        private final int time;\\n        \\n        private Tuple(final int node, final int cost, final int time) {\\n            this.node = node;\\n            this.cost = cost;\\n            this.time = time;\\n        }\\n        \\n        public String toString() {\\n            return \"(\" + node + \",\" + cost + \",\" + time + \")\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510736,
                "title": "c-dynamic-programming-solution-with-comments",
                "content": "dp[i][j] stores the minimum cost of travel from source vertex=i and max_time_limit-j to destination vertex=n-1\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int solve(int time, vector<pair<int,int>> adj[],vector<int>& cost, int i)\\n    {\\n        if(time<0)\\n            return INT_MAX;\\n \\n      int n=cost.size();\\n      if(i==n-1)\\n        {\\n           return dp[i][time]=cost[i];\\n            \\n         // if we have already reached n-1th city---cost from the city to itself will be just cost[n-1]\\n        }     \\n         //if it is already calculated \\n        if(dp[i][time]!=-1)\\n            return dp[i][time];\\n        \\n          // traversing through all neighbours of ith city to get the minimum cost route from i to n-1 in maximum_time==time \\n         int ans=INT_MAX;\\n        \\n        for(pair<int,int> p:adj[i])\\n        {\\n                int u=p.first;\\n               int traveltime=p.second;\\n            \\n                if(traveltime<=time)\\n           {\\n               int t=solve(time-traveltime,adj,cost,u);\\n               \\n               ans=min(ans,t);\\n           }\\n\\n        }\\n\\n \\n \\n        if(ans==INT_MAX)                                 //  did not find any route from ith city to n-1th city\\n            return dp[i][time]=INT_MAX;                  // that can be completed in \\'time\\' duration\\n        else\\n            return dp[i][time]=ans+cost[i];\\n\\n     \\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n       \\n        \\n        int n=cost.size();\\n         memset(dp,-1,sizeof(dp));\\n        vector<pair<int,int>> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            \\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n            \\n        }\\n       \\n        int ans=solve(maxTime,adj,cost,0);\\n        \\n        //we are sending the source city---and the maximum time limit---to get minimum cost of travel from 0 to n-1th city\\n        \\n        // dp[i][time]--> is the minimum cost for journey from source=i and destination=n-1 when maximum time limit == time\\n        \\n        if(ans==INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int solve(int time, vector<pair<int,int>> adj[],vector<int>& cost, int i)\\n    {\\n        if(time<0)\\n            return INT_MAX;\\n \\n      int n=cost.size();\\n      if(i==n-1)\\n        {\\n           return dp[i][time]=cost[i];\\n            \\n         // if we have already reached n-1th city---cost from the city to itself will be just cost[n-1]\\n        }     \\n         //if it is already calculated \\n        if(dp[i][time]!=-1)\\n            return dp[i][time];\\n        \\n          // traversing through all neighbours of ith city to get the minimum cost route from i to n-1 in maximum_time==time \\n         int ans=INT_MAX;\\n        \\n        for(pair<int,int> p:adj[i])\\n        {\\n                int u=p.first;\\n               int traveltime=p.second;\\n            \\n                if(traveltime<=time)\\n           {\\n               int t=solve(time-traveltime,adj,cost,u);\\n               \\n               ans=min(ans,t);\\n           }\\n\\n        }\\n\\n \\n \\n        if(ans==INT_MAX)                                 //  did not find any route from ith city to n-1th city\\n            return dp[i][time]=INT_MAX;                  // that can be completed in \\'time\\' duration\\n        else\\n            return dp[i][time]=ans+cost[i];\\n\\n     \\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& cost) {\\n       \\n        \\n        int n=cost.size();\\n         memset(dp,-1,sizeof(dp));\\n        vector<pair<int,int>> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            \\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n            \\n        }\\n       \\n        int ans=solve(maxTime,adj,cost,0);\\n        \\n        //we are sending the source city---and the maximum time limit---to get minimum cost of travel from 0 to n-1th city\\n        \\n        // dp[i][time]--> is the minimum cost for journey from source=i and destination=n-1 when maximum time limit == time\\n        \\n        if(ans==INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504401,
                "title": "binary-search-dfs-but-not-passing-all-test-cases",
                "content": "Idea:\\nBasically check for a given value of maxPassingFees if a path is possible from source to target or not. This can be done in single DFS pass.\\nNow, we perform binary search on passingFees possible values to see what is the min value for which there is a path between source and target.\\n\\nCan someone help understand what is missing in this approach?\\nMainly, is it possible to check if there is path from source to target with passingFess leess than or equal to maxPassingFees in a single DFS?\\n\\n```\\npublic class Solution {\\n    public int MinCost(int maxTime, int[][] edges, int[] passingFees) {\\n    int minPassingFees = passingFees[0];\\n\\tint maxPassingFees = 0;\\n\\tforeach (int fees in passingFees)\\n\\t{\\n\\t\\tmaxPassingFees += fees;\\n    }\\n\\n    List<(int,int)>[] graph = new List<(int, int)>[passingFees.Length];\\n    for (int i=0; i<graph.Length; i++)\\n    {\\n        graph[i] = new List<(int, int)>();\\n    }\\n\\n    foreach (int[] edge in edges)\\n    {\\n\\t    graph[edge[0]].Add((edge[1], edge[2]));\\n\\t    graph[edge[1]].Add((edge[0], edge[2]));\\n    }\\n\\n    int ans = -1;\\n    while (minPassingFees <= maxPassingFees)\\n    {\\n\\t    int mid = minPassingFees + (maxPassingFees - minPassingFees)/2;\\n\\t\\n\\t    bool[] visited = new bool[passingFees.Length];\\n\\t    bool isPathPossible = DoDFS(graph, passingFees, mid, maxTime, 0, passingFees.Length-1, visited);\\n\\n\\t    if (isPathPossible)\\n\\t    {\\n\\t\\t    ans = mid;\\n\\t\\t    maxPassingFees = mid-1;\\n        }\\n        else\\n        {\\n\\t        minPassingFees = mid+1;\\n        }\\n    }\\n\\n    return ans;\\n    }\\n\\n\\n    private bool DoDFS(List<(int,int)>[] graph, int[] passingFees, int feesDebt, int maxTime, int vertex, int target, bool[] visited)\\n    {\\n\\t    if (visited[vertex])\\n\\t    {\\n\\t\\t    return false;\\n        }\\n        if (feesDebt < passingFees[vertex])\\n        {\\n\\t        return false;\\n        }\\n\\n        if (vertex == target)\\n        {\\n\\t        return true;\\n        }\\n\\n        visited[vertex] = true;\\n        bool isPossible = false;\\n        foreach ((int, int) neighbour in graph[vertex])\\n        {\\n\\t        if (neighbour.Item2 <= maxTime)\\n            {\\n\\t            isPossible |= DoDFS(graph, passingFees, feesDebt - passingFees[vertex], maxTime - neighbour.Item2, neighbour.Item1, target, visited);\\n\\t            if (isPossible)\\n\\t            {\\n\\t\\t            return true;\\n                }\\n            }\\n        }\\n\\n    return isPossible;\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinCost(int maxTime, int[][] edges, int[] passingFees) {\\n    int minPassingFees = passingFees[0];\\n\\tint maxPassingFees = 0;\\n\\tforeach (int fees in passingFees)\\n\\t{\\n\\t\\tmaxPassingFees += fees;\\n    }\\n\\n    List<(int,int)>[] graph = new List<(int, int)>[passingFees.Length];\\n    for (int i=0; i<graph.Length; i++)\\n    {\\n        graph[i] = new List<(int, int)>();\\n    }\\n\\n    foreach (int[] edge in edges)\\n    {\\n\\t    graph[edge[0]].Add((edge[1], edge[2]));\\n\\t    graph[edge[1]].Add((edge[0], edge[2]));\\n    }\\n\\n    int ans = -1;\\n    while (minPassingFees <= maxPassingFees)\\n    {\\n\\t    int mid = minPassingFees + (maxPassingFees - minPassingFees)/2;\\n\\t\\n\\t    bool[] visited = new bool[passingFees.Length];\\n\\t    bool isPathPossible = DoDFS(graph, passingFees, mid, maxTime, 0, passingFees.Length-1, visited);\\n\\n\\t    if (isPathPossible)\\n\\t    {\\n\\t\\t    ans = mid;\\n\\t\\t    maxPassingFees = mid-1;\\n        }\\n        else\\n        {\\n\\t        minPassingFees = mid+1;\\n        }\\n    }\\n\\n    return ans;\\n    }\\n\\n\\n    private bool DoDFS(List<(int,int)>[] graph, int[] passingFees, int feesDebt, int maxTime, int vertex, int target, bool[] visited)\\n    {\\n\\t    if (visited[vertex])\\n\\t    {\\n\\t\\t    return false;\\n        }\\n        if (feesDebt < passingFees[vertex])\\n        {\\n\\t        return false;\\n        }\\n\\n        if (vertex == target)\\n        {\\n\\t        return true;\\n        }\\n\\n        visited[vertex] = true;\\n        bool isPossible = false;\\n        foreach ((int, int) neighbour in graph[vertex])\\n        {\\n\\t        if (neighbour.Item2 <= maxTime)\\n            {\\n\\t            isPossible |= DoDFS(graph, passingFees, feesDebt - passingFees[vertex], maxTime - neighbour.Item2, neighbour.Item1, target, visited);\\n\\t            if (isPossible)\\n\\t            {\\n\\t\\t            return true;\\n                }\\n            }\\n        }\\n\\n    return isPossible;\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498814,
                "title": "commented-python-code-dijkstra-like-o-maxtime-m-log-m",
                "content": "```\\nfrom heapq import heappush as push\\nfrom heapq import heappop as pop\\n\\n\\nclass Solution:\\n    def minCost(self, maxTime, edges, passingFees):\\n        n = len(passingFees)\\n        graph = [[] for _ in range(n)]\\n        edge2time = {}\\n        # initialize the graph\\n        for a, b, t in edges:\\n            if (a, b) in edge2time: # against multiple edges, pick one with less time\\n                min_time = min(t, edge2time[(a, b)])\\n                edge2time[(a, b)] = min_time\\n                edge2time[(b, a)] = min_time\\n                continue\\n\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            edge2time[(a, b)] = t\\n            edge2time[(b, a)] = t\\n\\n        start = (passingFees[0], 0, 0) # cost, node, time\\n        h = []\\n        attended = [10 ** 9 for _ in range(n)] # node -> minimal time spent to reach\\n        push(h, start)\\n\\n        # dijkstra like algorithm, but you may attend in worst case each node maxTime times\\n        # because in each new attendence you must have new attended time to decrease (from maxTime to zero)\\n        # thus you happen to be in each node maxTime times, and from each node you loop Degree of a Node times\\n        # so the time complexity is O(maxTime * M * log (M * maxTime))\\n        # but for worst case to happen the world must fall, basically intuitively doesnt happen\\n        while len(h) > 0:\\n            cost, node, time = pop(h)\\n            # if attended[node] has a value, then you have been here with less cost\\n            # if your new time isn\\'t better than previous, you continue, else update attended[node]\\n            if attended[node] > time:\\n                attended[node] = time\\n            else:\\n                continue\\n\\n            if node == n - 1:\\n                return cost\\n            for nb in graph[node]:\\n                nb_time = time + edge2time[(node, nb)]\\n                if nb_time > maxTime:\\n                    continue\\n                # if below false, then you\\'ve been to this node before (therefore with less cost) and less time spent by inequality\\n                if attended[nb] > nb_time:\\n                    push(h, (cost + passingFees[nb], nb, nb_time))\\n\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush as push\\nfrom heapq import heappop as pop\\n\\n\\nclass Solution:\\n    def minCost(self, maxTime, edges, passingFees):\\n        n = len(passingFees)\\n        graph = [[] for _ in range(n)]\\n        edge2time = {}\\n        # initialize the graph\\n        for a, b, t in edges:\\n            if (a, b) in edge2time: # against multiple edges, pick one with less time\\n                min_time = min(t, edge2time[(a, b)])\\n                edge2time[(a, b)] = min_time\\n                edge2time[(b, a)] = min_time\\n                continue\\n\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            edge2time[(a, b)] = t\\n            edge2time[(b, a)] = t\\n\\n        start = (passingFees[0], 0, 0) # cost, node, time\\n        h = []\\n        attended = [10 ** 9 for _ in range(n)] # node -> minimal time spent to reach\\n        push(h, start)\\n\\n        # dijkstra like algorithm, but you may attend in worst case each node maxTime times\\n        # because in each new attendence you must have new attended time to decrease (from maxTime to zero)\\n        # thus you happen to be in each node maxTime times, and from each node you loop Degree of a Node times\\n        # so the time complexity is O(maxTime * M * log (M * maxTime))\\n        # but for worst case to happen the world must fall, basically intuitively doesnt happen\\n        while len(h) > 0:\\n            cost, node, time = pop(h)\\n            # if attended[node] has a value, then you have been here with less cost\\n            # if your new time isn\\'t better than previous, you continue, else update attended[node]\\n            if attended[node] > time:\\n                attended[node] = time\\n            else:\\n                continue\\n\\n            if node == n - 1:\\n                return cost\\n            for nb in graph[node]:\\n                nb_time = time + edge2time[(node, nb)]\\n                if nb_time > maxTime:\\n                    continue\\n                # if below false, then you\\'ve been to this node before (therefore with less cost) and less time spent by inequality\\n                if attended[nb] > nb_time:\\n                    push(h, (cost + passingFees[nb], nb, nb_time))\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470252,
                "title": "can-any-one-guide-me-what-is-wron-is-this-code",
                "content": "Can any one guide me what is wron is this code. it is failing some testcases.\\n\\n```\\n/**\\n * @param {number} maxTime\\n * @param {number[][]} edges\\n * @param {number[]} passingFees\\n * @return {number}\\n */\\nvar minCost = function(maxTime, edges, passingFees) {\\n    const adjList ={}\\n    let output = [];\\n    let s= new Set();\\n    let maxnode= -1;\\n    let count =0;\\n    const toAdj = ()=>{\\n        for(let [s,d,wt] of edges){\\n            // console.log(s,d,wt)\\n            adjList[s] = adjList[s] || []\\n            adjList[d] = adjList[d] || []\\n            adjList[s] = [...adjList[s], [d+\\'\\', wt] ]\\n            adjList[d] = [...adjList[d], [s+\\'\\', wt] ]\\n            if(maxnode < s){\\n                maxnode =s\\n            }\\n             if(maxnode < d){\\n                maxnode =d\\n            }\\n        }\\n    }\\n    toAdj();\\n    // console.log(adjList)\\n    const DFS = (src, meta)=>{\\n        if(maxTime < meta.time) return\\n        if(src == maxnode){\\n            console.log(meta)\\n            output = [...output, meta.path]\\n            return;\\n        }\\n        s.add(src)\\n        if(adjList[src]){\\n            for(let item of adjList[src]){\\n                \\n                if(!s.has(item[0])){\\n                    const newMeta = {\\n                        time : meta.time + item[1],\\n                        path : [...meta.path, item[0]]\\n                    }\\n                    DFS(item[0],newMeta)\\n                }\\n            }\\n        }\\n        s.delete(src)\\n    }\\n    \\n    DFS(\\'0\\', {\\n        time : 0,\\n        path :[\\'0\\']\\n    })\\n    console.log(output, maxnode)\\n    let r =Infinity;\\n    if(output.length > 0){\\n        for(let o of output){\\n            count = o.reduce((a,c)=>{\\n                return a + passingFees[+c]\\n            }, 0)\\n            if(r > count){\\n                r= count;\\n            }\\n        }\\n        // console.log(count)\\n        return r\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} maxTime\\n * @param {number[][]} edges\\n * @param {number[]} passingFees\\n * @return {number}\\n */\\nvar minCost = function(maxTime, edges, passingFees) {\\n    const adjList ={}\\n    let output = [];\\n    let s= new Set();\\n    let maxnode= -1;\\n    let count =0;\\n    const toAdj = ()=>{\\n        for(let [s,d,wt] of edges){\\n            // console.log(s,d,wt)\\n            adjList[s] = adjList[s] || []\\n            adjList[d] = adjList[d] || []\\n            adjList[s] = [...adjList[s], [d+\\'\\', wt] ]\\n            adjList[d] = [...adjList[d], [s+\\'\\', wt] ]\\n            if(maxnode < s){\\n                maxnode =s\\n            }\\n             if(maxnode < d){\\n                maxnode =d\\n            }\\n        }\\n    }\\n    toAdj();\\n    // console.log(adjList)\\n    const DFS = (src, meta)=>{\\n        if(maxTime < meta.time) return\\n        if(src == maxnode){\\n            console.log(meta)\\n            output = [...output, meta.path]\\n            return;\\n        }\\n        s.add(src)\\n        if(adjList[src]){\\n            for(let item of adjList[src]){\\n                \\n                if(!s.has(item[0])){\\n                    const newMeta = {\\n                        time : meta.time + item[1],\\n                        path : [...meta.path, item[0]]\\n                    }\\n                    DFS(item[0],newMeta)\\n                }\\n            }\\n        }\\n        s.delete(src)\\n    }\\n    \\n    DFS(\\'0\\', {\\n        time : 0,\\n        path :[\\'0\\']\\n    })\\n    console.log(output, maxnode)\\n    let r =Infinity;\\n    if(output.length > 0){\\n        for(let o of output){\\n            count = o.reduce((a,c)=>{\\n                return a + passingFees[+c]\\n            }, 0)\\n            if(r > count){\\n                r= count;\\n            }\\n        }\\n        // console.log(count)\\n        return r\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458199,
                "title": "c-dijkstra-using-sortedset",
                "content": "```\\npublic class Solution {\\n    public int MinCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        var n = passingFees.Length;\\n        var graph = new List<int[]>[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new List<int[]>();\\n        \\n        var minTime = new int[n]; //gotcha\\n        for(int i = 0; i < n; i++)\\n            minTime[i] = int.MaxValue; //gotcha\\n      \\n        foreach(var edge in edges)\\n        {\\n            graph[edge[0]].Add(new int[]{edge[1], edge[2]});\\n            graph[edge[1]].Add(new int[]{edge[0], edge[2]});\\n        }\\n        \\n        var pq = new SortedSet<(int fees, int time, int source)>();\\n        pq.Add((passingFees[0], 0, 0));  \\n       \\n        while(pq.Count > 0)\\n        {\\n            var item = pq.Min;\\n            pq.Remove(item);\\n            \\n            if(item.time >= minTime[item.source] || item.time > maxTime)\\n                continue;\\n            \\n            if(item.source == n - 1)\\n                return item.fees;\\n            \\n            minTime[item.source] = item.time;\\n            foreach(var node in graph[item.source])\\n            {\\n                pq.Add((item.fees + passingFees[node[0]], item.time + node[1], node[0])); //gotcha\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n//Important: There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\\n// var graph = new List<int[]>[];\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinCost(int maxTime, int[][] edges, int[] passingFees) {\\n        \\n        var n = passingFees.Length;\\n        var graph = new List<int[]>[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new List<int[]>();\\n        \\n        var minTime = new int[n]; //gotcha\\n        for(int i = 0; i < n; i++)\\n            minTime[i] = int.MaxValue; //gotcha\\n      \\n        foreach(var edge in edges)\\n        {\\n            graph[edge[0]].Add(new int[]{edge[1], edge[2]});\\n            graph[edge[1]].Add(new int[]{edge[0], edge[2]});\\n        }\\n        \\n        var pq = new SortedSet<(int fees, int time, int source)>();\\n        pq.Add((passingFees[0], 0, 0));  \\n       \\n        while(pq.Count > 0)\\n        {\\n            var item = pq.Min;\\n            pq.Remove(item);\\n            \\n            if(item.time >= minTime[item.source] || item.time > maxTime)\\n                continue;\\n            \\n            if(item.source == n - 1)\\n                return item.fees;\\n            \\n            minTime[item.source] = item.time;\\n            foreach(var node in graph[item.source])\\n            {\\n                pq.Add((item.fees + passingFees[node[0]], item.time + node[1], node[0])); //gotcha\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n//Important: There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\\n// var graph = new List<int[]>[];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436009,
                "title": "java-min-heap-bfs-dp",
                "content": "1. queue_element -> {fee, time, vertex}\\n2. dp -> (key=node) => (value=time_taken_to_reach_the_key_node)\\n\\t1. Only process new queue elements if time_taken is less than the previous visit.\\n\\t2. dp_condition => current_time_take_to_reach_node_a < previous_time_taken_to_reach_node_a.\\n3. start the queue by pushing vertex 0.\\n4. stop the queue when you reach vertex n-1.\\n\\n```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n=passingFees.length;\\n        HashMap<Integer, List<int[]>> adj=new HashMap<>();\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            int[] e=edges[i];\\n            if(!adj.containsKey(e[0]))\\n            {\\n                adj.put(e[0], new ArrayList<int[]>());\\n            }\\n            adj.get(e[0]).add(new int[]{e[1], e[2]});\\n            if(!adj.containsKey(e[1]))\\n            {\\n                adj.put(e[1], new ArrayList<int[]>());\\n            }\\n            adj.get(e[1]).add(new int[]{e[0], e[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(n, (a,b)->{\\n            int cmp = Integer.compare(a[0],b[0]);\\n            if(cmp==0)\\n            {\\n                cmp = Integer.compare(a[0],b[0]);\\n            }\\n            return cmp;\\n        });\\n        q.add(new int[]{passingFees[0], 0, 0});\\n        int vis[]=new int[n];\\n        while(!q.isEmpty())\\n        {\\n            int[] node=q.poll();\\n            if(vis[node[2]]!=0 && node[1]>=vis[node[2]])\\n            {\\n                continue;\\n            }\\n            if(node[2]==n-1)\\n            {\\n                return node[0];\\n            }\\n            vis[node[2]]=node[1];\\n            if(adj.containsKey(node[2]))\\n            {\\n                for(int[] nb:adj.get(node[2]))\\n                {\\n                    if(node[1]+nb[1]>maxTime)\\n                    {\\n                        continue;\\n                    }\\n                    q.add(new int[]{node[0]+passingFees[nb[0]], node[1]+nb[1], nb[0]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n=passingFees.length;\\n        HashMap<Integer, List<int[]>> adj=new HashMap<>();\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            int[] e=edges[i];\\n            if(!adj.containsKey(e[0]))\\n            {\\n                adj.put(e[0], new ArrayList<int[]>());\\n            }\\n            adj.get(e[0]).add(new int[]{e[1], e[2]});\\n            if(!adj.containsKey(e[1]))\\n            {\\n                adj.put(e[1], new ArrayList<int[]>());\\n            }\\n            adj.get(e[1]).add(new int[]{e[0], e[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(n, (a,b)->{\\n            int cmp = Integer.compare(a[0],b[0]);\\n            if(cmp==0)\\n            {\\n                cmp = Integer.compare(a[0],b[0]);\\n            }\\n            return cmp;\\n        });\\n        q.add(new int[]{passingFees[0], 0, 0});\\n        int vis[]=new int[n];\\n        while(!q.isEmpty())\\n        {\\n            int[] node=q.poll();\\n            if(vis[node[2]]!=0 && node[1]>=vis[node[2]])\\n            {\\n                continue;\\n            }\\n            if(node[2]==n-1)\\n            {\\n                return node[0];\\n            }\\n            vis[node[2]]=node[1];\\n            if(adj.containsKey(node[2]))\\n            {\\n                for(int[] nb:adj.get(node[2]))\\n                {\\n                    if(node[1]+nb[1]>maxTime)\\n                    {\\n                        continue;\\n                    }\\n                    q.add(new int[]{node[0]+passingFees[nb[0]], node[1]+nb[1], nb[0]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427477,
                "title": "java-clean-using-dijkstra",
                "content": "```\\n  public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<int[]>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n        \\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[0] = 0;\\n       \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->(a[2] == b[2]) ? a[1] - b[1] : a[2]-b[2]);\\n        minHeap.offer(new int[]{0, dist[0], passingFees[0]});  // src, dist, toll\\n        while (!minHeap.isEmpty()) {\\n            int[] top = minHeap.poll();\\n            int u = top[0], d = top[1], toll = top[2];            \\n            if (u == n-1) return toll;\\n           // if(d > dist[u]) continue; //even if d > dist[u] toll might be cheaper\\n            for (int[] nei : graph[u]) {             \\n                int v = nei[0], time = nei[1] ;\\n                if (d + time > maxTime) continue;               \\n                if (d + time < dist[v]){\\n                    dist[v] = d + time;\\n                    minHeap.add(new int[]{v, dist[v], toll+passingFees[v]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        List<int[]>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n        \\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[0] = 0;\\n       \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->(a[2] == b[2]) ? a[1] - b[1] : a[2]-b[2]);\\n        minHeap.offer(new int[]{0, dist[0], passingFees[0]});  // src, dist, toll\\n        while (!minHeap.isEmpty()) {\\n            int[] top = minHeap.poll();\\n            int u = top[0], d = top[1], toll = top[2];            \\n            if (u == n-1) return toll;\\n           // if(d > dist[u]) continue; //even if d > dist[u] toll might be cheaper\\n            for (int[] nei : graph[u]) {             \\n                int v = nei[0], time = nei[1] ;\\n                if (d + time > maxTime) continue;               \\n                if (d + time < dist[v]){\\n                    dist[v] = d + time;\\n                    minHeap.add(new int[]{v, dist[v], toll+passingFees[v]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424763,
                "title": "java-dijkstra-with-minor-changes",
                "content": "We build adjacency lists and perform regular Dijkstra with some adjustments :\\n- We follow Dijkstra with edges from minHeap sorted by fees instead of time (each time we peek minimal fee edge available and discovered earlier)\\n- We save minimal visited vertex overall time in time[] array\\n- For every newly discovered edge, we check whether we have faced better time or whether current time less than maxTime threshold.\\n- Since we go by the shortest  fee-edges and don\\'t allow time more than maxTime, first moment when  we visit destination vertex will be the minimal fee route with time <= maxTime \\n\\n```\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n= passingFees.length;\\n        \\n        int[] time = new int[n];\\n        Arrays.fill(time,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> pq = new PriorityQueue<>((a,b)-> a[2]-b[2]);\\n        pq.offer(new int[]{0,0,passingFees[0]});\\n\\n        List<int[]>[] adj = new List[n];\\n        for(int i=0;i<n;i++)\\n            adj[i] = new ArrayList<>();\\n        for(int[] edge : edges){\\n            int from = edge[0], to = edge[1], t = edge[2];\\n            adj[from].add(new int[]{to, t});\\n            adj[to].add(new int[]{from, t});\\n        }\\n\\n        while(!pq.isEmpty()){\\n            int[] edge = pq.poll();\\n            int v = edge[0], t = edge[1], f = edge[2];\\n\\n            if(t >= time[v] || t > maxTime)\\n                continue;\\n            \\n            time[v] = t;\\n            \\n            if(v==n-1)\\n                return f;\\n            \\n            for(int[] next : adj[v]){\\n                int vv = next[0], tt=t+next[1], ff=f+passingFees[vv];\\n                pq.offer(new int[]{vv, tt, ff});\\n            }\\n        }\\n        \\n        return -1; //vertex is not reachable within maxTime or edge connections\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n= passingFees.length;\\n        \\n        int[] time = new int[n];\\n        Arrays.fill(time,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> pq = new PriorityQueue<>((a,b)-> a[2]-b[2]);\\n        pq.offer(new int[]{0,0,passingFees[0]});\\n\\n        List<int[]>[] adj = new List[n];\\n        for(int i=0;i<n;i++)\\n            adj[i] = new ArrayList<>();\\n        for(int[] edge : edges){\\n            int from = edge[0], to = edge[1], t = edge[2];\\n            adj[from].add(new int[]{to, t});\\n            adj[to].add(new int[]{from, t});\\n        }\\n\\n        while(!pq.isEmpty()){\\n            int[] edge = pq.poll();\\n            int v = edge[0], t = edge[1], f = edge[2];\\n\\n            if(t >= time[v] || t > maxTime)\\n                continue;\\n            \\n            time[v] = t;\\n            \\n            if(v==n-1)\\n                return f;\\n            \\n            for(int[] next : adj[v]){\\n                int vv = next[0], tt=t+next[1], ff=f+passingFees[vv];\\n                pq.offer(new int[]{vv, tt, ff});\\n            }\\n        }\\n        \\n        return -1; //vertex is not reachable within maxTime or edge connections\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407100,
                "title": "c-better-than-100",
                "content": "```\\nclass Solution {\\nint INF=1e9+5;\\n#define light ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        light;\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>>g(n);\\n        for(auto &v:edges){\\n            g[v[0]].push_back({v[1],v[2]});\\n            g[v[1]].push_back({v[0],v[2]});\\n        }\\n        set<pair<int,pair<int,int>>>st;\\n        st.insert({passingFees[0],{0,0}});\\n        vector<int>t1(n,INF);\\n        vector<int>fees(n,INF);\\n        t1[0]=0;\\n        fees[0]=passingFees[0];\\n        int ans=INF;\\n        while(!st.empty()){\\n            int node=(*st.begin()).second.first,time=(*st.begin()).second.second,cost=(*st.begin()).first;\\n            st.erase(st.begin());\\n            if(node==n-1){\\n                ans=cost;\\n                break;\\n            }\\n            if(cost!=fees[node] && time!=t1[node]){\\n                continue;\\n            }\\n            for(auto &child:g[node]){\\n                int cost1=cost+passingFees[child.first];\\n                int time1=time+child.second;\\n                int node1=child.first;\\n                if(time1<=maxTime && (t1[node1]>time1||fees[node1]>cost1)){\\n                    t1[node1]=min(t1[node1],time1);\\n                    fees[node1]=min(fees[node1],cost1);\\n                    st.insert({cost1,{node1,time1}});\\n                }\\n            }\\n        }\\n        if(ans==INF){\\n            ans=-1;\\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nint INF=1e9+5;\\n#define light ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        light;\\n        int n=passingFees.size();\\n        vector<vector<pair<int,int>>>g(n);\\n        for(auto &v:edges){\\n            g[v[0]].push_back({v[1],v[2]});\\n            g[v[1]].push_back({v[0],v[2]});\\n        }\\n        set<pair<int,pair<int,int>>>st;\\n        st.insert({passingFees[0],{0,0}});\\n        vector<int>t1(n,INF);\\n        vector<int>fees(n,INF);\\n        t1[0]=0;\\n        fees[0]=passingFees[0];\\n        int ans=INF;\\n        while(!st.empty()){\\n            int node=(*st.begin()).second.first,time=(*st.begin()).second.second,cost=(*st.begin()).first;\\n            st.erase(st.begin());\\n            if(node==n-1){\\n                ans=cost;\\n                break;\\n            }\\n            if(cost!=fees[node] && time!=t1[node]){\\n                continue;\\n            }\\n            for(auto &child:g[node]){\\n                int cost1=cost+passingFees[child.first];\\n                int time1=time+child.second;\\n                int node1=child.first;\\n                if(time1<=maxTime && (t1[node1]>time1||fees[node1]>cost1)){\\n                    t1[node1]=min(t1[node1],time1);\\n                    fees[node1]=min(fees[node1],cost1);\\n                    st.insert({cost1,{node1,time1}});\\n                }\\n            }\\n        }\\n        if(ans==INF){\\n            ans=-1;\\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1387930,
                "title": "c-clean-dp-memoization",
                "content": "For `next` try to use pairs inside the vector to avoid TLE. `next` stores the next stop information and the time used on the road.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxi;\\n    int n;\\n    vector<vector<int>> memo;\\n    vector<vector<pair<int, int>>> next;\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        maxi = maxTime;\\n        n = passingFees.size();\\n        memo.assign(n, vector<int>(maxi + 1, -1));\\n        next.assign(n, vector<pair<int, int>>{});\\n        for (auto e: edges){\\n            next[e[0]].push_back({e[1], e[2]});\\n            next[e[1]].push_back({e[0], e[2]});\\n        }\\n        int ans = dp(passingFees, 0, 0, 0);\\n        return (ans == INT_MAX/2) ? -1: ans;\\n    }\\n    \\n    int dp(vector<int>& passingFees, int i, int time, int cost){\\n        if (time > maxi) return INT_MAX/2;\\n        if (i == n - 1)\\n            return passingFees[i];\\n        if (memo[i][time] < 0){\\n            memo[i][time] = INT_MAX/2;\\n            for (auto p: next[i]){\\n                int j = p.first, t = p.second;\\n                memo[i][time] = min(memo[i][time],\\n                                    passingFees[i] + dp(passingFees, j, time + t, cost));\\n            }\\n        }\\n        return memo[i][time];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxi;\\n    int n;\\n    vector<vector<int>> memo;\\n    vector<vector<pair<int, int>>> next;\\n    \\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        maxi = maxTime;\\n        n = passingFees.size();\\n        memo.assign(n, vector<int>(maxi + 1, -1));\\n        next.assign(n, vector<pair<int, int>>{});\\n        for (auto e: edges){\\n            next[e[0]].push_back({e[1], e[2]});\\n            next[e[1]].push_back({e[0], e[2]});\\n        }\\n        int ans = dp(passingFees, 0, 0, 0);\\n        return (ans == INT_MAX/2) ? -1: ans;\\n    }\\n    \\n    int dp(vector<int>& passingFees, int i, int time, int cost){\\n        if (time > maxi) return INT_MAX/2;\\n        if (i == n - 1)\\n            return passingFees[i];\\n        if (memo[i][time] < 0){\\n            memo[i][time] = INT_MAX/2;\\n            for (auto p: next[i]){\\n                int j = p.first, t = p.second;\\n                memo[i][time] = min(memo[i][time],\\n                                    passingFees[i] + dp(passingFees, j, time + t, cost));\\n            }\\n        }\\n        return memo[i][time];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375090,
                "title": "revisit-a-node-only-if-improving-time-or-cost-bfs",
                "content": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        G, n = defaultdict(set), len(passingFees)\\n        for x,y,t in edges:\\n            G[x].add((y, t))\\n            G[y].add((x, t))\\n        ans = math.inf\\n        Q = [(passingFees[0], 0, 0)]\\n        T = [math.inf] * n\\n        C = [math.inf] * n\\n        while Q:\\n            c, t, i = heappop(Q)\\n            if i == n - 1:\\n                if t <= maxTime: ans = min(ans, c)\\n                continue\\n\\t\\t\\tif t >= maxTime:\\n                continue\\n            for j, t1 in G[i]:\\n                if T[j] > t + t1 or C[j] > c + passingFees[j]:\\n                    T[j] = t + t1\\n                    C[j] = c + passingFees[j]\\n                    heappush(Q, (C[j], T[j], j))\\n        return ans if ans < math.inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        G, n = defaultdict(set), len(passingFees)\\n        for x,y,t in edges:\\n            G[x].add((y, t))\\n            G[y].add((x, t))\\n        ans = math.inf\\n        Q = [(passingFees[0], 0, 0)]\\n        T = [math.inf] * n\\n        C = [math.inf] * n\\n        while Q:\\n            c, t, i = heappop(Q)\\n            if i == n - 1:\\n                if t <= maxTime: ans = min(ans, c)\\n                continue\\n\\t\\t\\tif t >= maxTime:\\n                continue\\n            for j, t1 in G[i]:\\n                if T[j] > t + t1 or C[j] > c + passingFees[j]:\\n                    T[j] = t + t1\\n                    C[j] = c + passingFees[j]\\n                    heappush(Q, (C[j], T[j], j))\\n        return ans if ans < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342595,
                "title": "c-simple-soulution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int mt, vector<vector<int>>& edges, vector<int>& fee) {\\n        vector<vector<tuple<int, int, int>>> adj(fee.size());\\n        vector<int> time(fee.size(), INT_MAX);\\n        time[0] = 0;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        pq.emplace(make_tuple(fee[0], 0, 0));\\n        for (int i = 0, e = edges.size(); i < e; i++) {\\n            adj[edges[i][0]].push_back({fee[edges[i][1]], edges[i][2], edges[i][1]});\\n            adj[edges[i][1]].push_back({fee[edges[i][0]], edges[i][2], edges[i][0]});\\n        }\\n        for (; !pq.empty();) {\\n            auto [cf, ct, cc] = pq.top();\\n            pq.pop();\\n            if (cc == fee.size() - 1) return cf;\\n            for (auto &a : adj[cc]) {\\n                auto [nf, nt, nc] = a;\\n                if (ct + nt <= min(mt, time[nc] - 1)) {\\n                    time[nc] = ct + nt;\\n                    pq.emplace(make_tuple(cf + nf, ct + nt, nc));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int mt, vector<vector<int>>& edges, vector<int>& fee) {\\n        vector<vector<tuple<int, int, int>>> adj(fee.size());\\n        vector<int> time(fee.size(), INT_MAX);\\n        time[0] = 0;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        pq.emplace(make_tuple(fee[0], 0, 0));\\n        for (int i = 0, e = edges.size(); i < e; i++) {\\n            adj[edges[i][0]].push_back({fee[edges[i][1]], edges[i][2], edges[i][1]});\\n            adj[edges[i][1]].push_back({fee[edges[i][0]], edges[i][2], edges[i][0]});\\n        }\\n        for (; !pq.empty();) {\\n            auto [cf, ct, cc] = pq.top();\\n            pq.pop();\\n            if (cc == fee.size() - 1) return cf;\\n            for (auto &a : adj[cc]) {\\n                auto [nf, nt, nc] = a;\\n                if (ct + nt <= min(mt, time[nc] - 1)) {\\n                    time[nc] = ct + nt;\\n                    pq.emplace(make_tuple(cf + nf, ct + nt, nc));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338331,
                "title": "java-solutio-using-dijktra-solution",
                "content": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n  = passingFees.length;\\n        List<int []> [] adList = getAdList(edges, n);\\n        int [] cost = new int [n];\\n        Arrays.fill(cost, Integer.MAX_VALUE);\\n        \\n        PriorityQueue<int []> minHeap = new PriorityQueue<int []>((int [] a, int [] b) -> a[1] < b[1]?-1:a[1]>b[1]?1:\\n                                                         a[2]<b[2]?-1:a[2]>b[2]?1:a[0]-b[0]);\\n        int res = Integer.MAX_VALUE;\\n        minHeap.add(new int[]{0, 0, passingFees[0]});\\n        while(minHeap.size() > 0){\\n            int [] poll = minHeap.poll();\\n            int cityId = poll[0];\\n            int currT = poll[1];\\n            int currCost = poll[2];\\n            if(cityId == n-1){\\n                res = Math.min(res, currCost);\\n                continue;\\n            }\\n            if(currCost >= cost[cityId])\\n                continue;\\n            cost[cityId] = currCost;\\n            for(int [] edge : adList[cityId]){\\n                int nCityId = edge[0];\\n                int nTime = currT+edge[1];\\n                int nCost = currCost + passingFees[nCityId];\\n                if(nTime > maxTime || nCost > res || nCost >= cost[nCityId])\\n                    continue;\\n                minHeap.add(new int []{nCityId, nTime, nCost});\\n            }\\n        }\\n        return res == Integer.MAX_VALUE?-1:res;\\n    }\\n    \\n    private List<int []> [] getAdList(int [][] edges, int n){\\n        Map<Integer, Integer> [] adList = new HashMap [n];\\n        for(int [] edge : edges){\\n            int s = edge[0];\\n            int d = edge[1];\\n            int t = edge[2];\\n            if(adList[s] == null)\\n                adList[s] = new HashMap();\\n            if(adList[d] == null)\\n                adList[d] = new HashMap();\\n            adList[s].put(d, Math.min(adList[s].getOrDefault(d, Integer.MAX_VALUE), t));\\n            adList[d].put(s, Math.min(adList[d].getOrDefault(s, Integer.MAX_VALUE), t));\\n        }\\n        List<int []> [] res = new ArrayList [n];\\n        for(int i = 0;i<res.length; i++){\\n            res[i] = new ArrayList();\\n            if(adList[i] == null)\\n                continue;\\n            for(Map.Entry<Integer, Integer> entry : adList[i].entrySet())\\n                res[i].add(new int[]{entry.getKey(), entry.getValue()});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n  = passingFees.length;\\n        List<int []> [] adList = getAdList(edges, n);\\n        int [] cost = new int [n];\\n        Arrays.fill(cost, Integer.MAX_VALUE);\\n        \\n        PriorityQueue<int []> minHeap = new PriorityQueue<int []>((int [] a, int [] b) -> a[1] < b[1]?-1:a[1]>b[1]?1:\\n                                                         a[2]<b[2]?-1:a[2]>b[2]?1:a[0]-b[0]);\\n        int res = Integer.MAX_VALUE;\\n        minHeap.add(new int[]{0, 0, passingFees[0]});\\n        while(minHeap.size() > 0){\\n            int [] poll = minHeap.poll();\\n            int cityId = poll[0];\\n            int currT = poll[1];\\n            int currCost = poll[2];\\n            if(cityId == n-1){\\n                res = Math.min(res, currCost);\\n                continue;\\n            }\\n            if(currCost >= cost[cityId])\\n                continue;\\n            cost[cityId] = currCost;\\n            for(int [] edge : adList[cityId]){\\n                int nCityId = edge[0];\\n                int nTime = currT+edge[1];\\n                int nCost = currCost + passingFees[nCityId];\\n                if(nTime > maxTime || nCost > res || nCost >= cost[nCityId])\\n                    continue;\\n                minHeap.add(new int []{nCityId, nTime, nCost});\\n            }\\n        }\\n        return res == Integer.MAX_VALUE?-1:res;\\n    }\\n    \\n    private List<int []> [] getAdList(int [][] edges, int n){\\n        Map<Integer, Integer> [] adList = new HashMap [n];\\n        for(int [] edge : edges){\\n            int s = edge[0];\\n            int d = edge[1];\\n            int t = edge[2];\\n            if(adList[s] == null)\\n                adList[s] = new HashMap();\\n            if(adList[d] == null)\\n                adList[d] = new HashMap();\\n            adList[s].put(d, Math.min(adList[s].getOrDefault(d, Integer.MAX_VALUE), t));\\n            adList[d].put(s, Math.min(adList[d].getOrDefault(s, Integer.MAX_VALUE), t));\\n        }\\n        List<int []> [] res = new ArrayList [n];\\n        for(int i = 0;i<res.length; i++){\\n            res[i] = new ArrayList();\\n            if(adList[i] == null)\\n                continue;\\n            for(Map.Entry<Integer, Integer> entry : adList[i].entrySet())\\n                res[i].add(new int[]{entry.getKey(), entry.getValue()});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337818,
                "title": "c-1928-minimum-cost-to-reach-destination-in-time",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        unordered_map<int, vector<pair<int, int>>> graph; \\n        for (auto& edge : edges) {\\n            graph[edge[0]].emplace_back(edge[1], edge[2]); \\n            graph[edge[1]].emplace_back(edge[0], edge[2]); \\n        }\\n        \\n        // Dijkstra\\'s algo\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq; // min-heap \\n        pq.push({passingFees[0], 0, 0}); \\n        unordered_map<int, int> dist = {{0, passingFees[0]}}; \\n        while (pq.size()) {\\n            auto [cost, k, t] = pq.top(); pq.pop(); \\n            if (k == passingFees.size()-1) return cost; \\n            for (auto& [kk, tt] : graph[k]) {\\n                if (t + tt <= maxTime && (!dist.count(kk) || t + tt < dist[kk])) {\\n                    dist[kk] = t + tt; \\n                    pq.push({cost + passingFees[kk], kk, t + tt}); \\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        unordered_map<int, vector<pair<int, int>>> graph; \\n        for (auto& edge : edges) {\\n            graph[edge[0]].emplace_back(edge[1], edge[2]); \\n            graph[edge[1]].emplace_back(edge[0], edge[2]); \\n        }\\n        \\n        // Dijkstra\\'s algo\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq; // min-heap \\n        pq.push({passingFees[0], 0, 0}); \\n        unordered_map<int, int> dist = {{0, passingFees[0]}}; \\n        while (pq.size()) {\\n            auto [cost, k, t] = pq.top(); pq.pop(); \\n            if (k == passingFees.size()-1) return cost; \\n            for (auto& [kk, tt] : graph[k]) {\\n                if (t + tt <= maxTime && (!dist.count(kk) || t + tt < dist[kk])) {\\n                    dist[kk] = t + tt; \\n                    pq.push({cost + passingFees[kk], kk, t + tt}); \\n                }\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336167,
                "title": "python3-dijkstra-algo",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        graph = {}\\n        for u, v, t in edges: \\n            graph.setdefault(u, []).append((v, t))\\n            graph.setdefault(v, []).append((u, t))\\n        \\n        pq = [(passingFees[0], 0, 0)]\\n        dist = {0: 0}\\n        while pq: \\n            cost, k, t = heappop(pq)\\n            if k == len(passingFees)-1: return cost\\n            for kk, tt in graph.get(k, []): \\n                if t + tt <= maxTime and t + tt < dist.get(kk, inf): \\n                    dist[kk] = t + tt\\n                    heappush(pq, (cost + passingFees[kk], kk, t + tt))\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        graph = {}\\n        for u, v, t in edges: \\n            graph.setdefault(u, []).append((v, t))\\n            graph.setdefault(v, []).append((u, t))\\n        \\n        pq = [(passingFees[0], 0, 0)]\\n        dist = {0: 0}\\n        while pq: \\n            cost, k, t = heappop(pq)\\n            if k == len(passingFees)-1: return cost\\n            for kk, tt in graph.get(k, []): \\n                if t + tt <= maxTime and t + tt < dist.get(kk, inf): \\n                    dist[kk] = t + tt\\n                    heappush(pq, (cost + passingFees[kk], kk, t + tt))\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334359,
                "title": "c-knapsack-recursion-memoisation",
                "content": "```\\nclass Solution {\\npublic:\\n    #define inf 100000000;\\n    int n;\\n    vector<vector<int>> dp;\\n    int sol(vector<vector<int>> adj[],int time,vector<int>& fees,int node){\\n        // int cost=fees[node];\\n        if(time<0)\\n            return inf;\\n        if(node==n-1)\\n            return 0;\\n        if(dp[node][time]!=-1)\\n            return dp[node][time];\\n        int mn=inf;\\n        for(auto& x:adj[node]){\\n            if(time>=x[1])\\n            mn=min(mn,fees[x[0]]+sol(adj,time-x[1],fees,x[0]));\\n        }\\n        return dp[node][time]=mn;\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n=passingFees.size();\\n        vector<vector<int>> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        dp.resize(n,vector<int>(maxTime+1,-1));\\n        int x=passingFees[0]+sol(adj,maxTime,passingFees,0);\\n        if(x>=100000000)\\n            return -1;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define inf 100000000;\\n    int n;\\n    vector<vector<int>> dp;\\n    int sol(vector<vector<int>> adj[],int time,vector<int>& fees,int node){\\n        // int cost=fees[node];\\n        if(time<0)\\n            return inf;\\n        if(node==n-1)\\n            return 0;\\n        if(dp[node][time]!=-1)\\n            return dp[node][time];\\n        int mn=inf;\\n        for(auto& x:adj[node]){\\n            if(time>=x[1])\\n            mn=min(mn,fees[x[0]]+sol(adj,time-x[1],fees,x[0]));\\n        }\\n        return dp[node][time]=mn;\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {\\n        n=passingFees.size();\\n        vector<vector<int>> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        dp.resize(n,vector<int>(maxTime+1,-1));\\n        int x=passingFees[0]+sol(adj,maxTime,passingFees,0);\\n        if(x>=100000000)\\n            return -1;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334016,
                "title": "python-dijkstra-w-time-descent-addition",
                "content": "```python\\ndef minCost(self, maxTime, edges, passingFees):\\n\\n    n = len(passingFees)\\n\\t\\n    G = [[] for _ in range(n)]\\n    for u, v, t in edges:\\n        G[u].append((v, passingFees[v], t))\\n        G[v].append((u, passingFees[u], t))\\n\\t\\t\\n    C = [0] + [float(\"inf\")] * (n - 1)\\n    T = [0] + [float(\"inf\")] * (n - 1)\\n    Q = [(passingFees[0], 0, 0)]\\n\\t\\n    while Q:\\n        cu, tu, u = heapq.heappop(Q)                       # cost-descent node first;\\n        if u == n - 1:\\n            return cu\\n        for v, c, t in G[u]:\\n            cv, tv = cu + c, tu + t\\n            if tv <= maxTime and (C[v] > cv or T[v] > tv): # beside cost-descent node,\\n\\t\\t\\t                                               # add time-descent costlier node against potential overtime;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n                C[v], T[v] = min(C[v], cv), min(T[v], tv)  # store globally min cost and locally min time to minimize PQ size;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n                heapq.heappush(Q, (cv, tv, v))             # add sieved triple (cost, time, node),\\n\\t\\t\\t\\t                                           # sort out PQ access below,\\n \\t\\t\\t\\t                                           # P1: c0 ci c(n-1) ti        => minimum cost,\\n\\t\\t\\t\\t                                           # P2: c0 ci        ti t(n-1) => sub-optimal cost,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   # P3: c0 ci        ti        => unreachable;\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minCost(self, maxTime, edges, passingFees):\\n\\n    n = len(passingFees)\\n\\t\\n    G = [[] for _ in range(n)]\\n    for u, v, t in edges:\\n        G[u].append((v, passingFees[v], t))\\n        G[v].append((u, passingFees[u], t))\\n\\t\\t\\n    C = [0] + [float(\"inf\")] * (n - 1)\\n    T = [0] + [float(\"inf\")] * (n - 1)\\n    Q = [(passingFees[0], 0, 0)]\\n\\t\\n    while Q:\\n        cu, tu, u = heapq.heappop(Q)                       # cost-descent node first;\\n        if u == n - 1:\\n            return cu\\n        for v, c, t in G[u]:\\n            cv, tv = cu + c, tu + t\\n            if tv <= maxTime and (C[v] > cv or T[v] > tv): # beside cost-descent node,\\n\\t\\t\\t                                               # add time-descent costlier node against potential overtime;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n                C[v], T[v] = min(C[v], cv), min(T[v], tv)  # store globally min cost and locally min time to minimize PQ size;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n                heapq.heappush(Q, (cv, tv, v))             # add sieved triple (cost, time, node),\\n\\t\\t\\t\\t                                           # sort out PQ access below,\\n \\t\\t\\t\\t                                           # P1: c0 ci c(n-1) ti        => minimum cost,\\n\\t\\t\\t\\t                                           # P2: c0 ci        ti t(n-1) => sub-optimal cost,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   # P3: c0 ci        ti        => unreachable;\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1333148,
                "title": "only-1-case-out-of-85-cases-failing-please-help",
                "content": "```\\nclass Solution {\\n        public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n            int n = passingFees.length;\\n\\n            int[][] matrix = new int[n][n];\\n            for (int[] edge : edges) {\\n                matrix[edge[0]][edge[1]] = edge[2];\\n                matrix[edge[1]][edge[0]] = edge[2];\\n            }\\n\\n            int[] costToReach = new int[n];\\n            int[] timeToReach = new int[n];\\n            Arrays.fill(costToReach, Integer.MAX_VALUE);\\n            Arrays.fill(timeToReach, Integer.MAX_VALUE);\\n            costToReach[0] = passingFees[0];\\n            timeToReach[0] = 0;\\n\\n            //Minimum Cost at Top\\n            PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n            minHeap.add(new int[]{0, costToReach[0], 0});\\n\\n            while (!minHeap.isEmpty()) {\\n                int[] info = minHeap.poll(); //pick min costly city\\n\\n                int currCity = info[0];\\n                int costToReachCurrCity = info[1];\\n                int timeToReachCurrCity = info[2];\\n\\n                if (currCity == n - 1)    // If destination reached\\n                    return costToReachCurrCity;\\n\\n                if (timeToReachCurrCity > maxTime)    // If current time to reach curr city exceeds maxTime\\n                    continue;\\n\\n                for (int nextCity = 0; nextCity < n; nextCity++) {\\n                    if (matrix[currCity][nextCity] > 0) {\\n                        int timeToReachNextFromCurrCity = matrix[currCity][nextCity];\\n                        int timeToReachNextCity = timeToReach[nextCity];\\n\\n                        if (timeToReachCurrCity + timeToReachNextFromCurrCity > maxTime)\\n                            continue;\\n\\n                        if ((timeToReachCurrCity + timeToReachNextFromCurrCity < timeToReachNextCity) || (costToReachCurrCity + passingFees[nextCity] < costToReach[nextCity])) {\\n                            minHeap.add(new int[]{nextCity, costToReachCurrCity + passingFees[nextCity], timeToReachCurrCity + timeToReachNextFromCurrCity});\\n                            costToReach[nextCity] = costToReachCurrCity + passingFees[nextCity];\\n                            timeToReach[nextCity] = timeToReachCurrCity + timeToReachNextFromCurrCity;\\n                        }\\n                    }\\n                }\\n            }\\n            return costToReach[n - 1] == Integer.MAX_VALUE ? -1 : costToReach[n - 1];\\n        }\\n    }\\n\\t```\\n\\t\\n\\t\\n\\t\\n\\tThe test case failing is as follows :\\n\\t\\n24\\n[[27,8,37],[9,36,15],[15,8,13],[30,8,12],[21,4,30],[22,33,46],[27,29,10],[35,32,35],[22,39,34],[9,45,14],[26,21,44],[13,36,14],[3,49,20],[28,44,11],[15,30,5],[26,49,36],[8,40,3],[28,25,1],[41,46,48],[38,24,8],[30,7,39],[14,3,36],[2,19,21],[12,39,37],[16,3,47],[11,31,22],[38,25,34],[42,6,47],[14,20,21],[33,8,35],[17,5,2],[36,19,3],[47,28,40],[37,33,35],[24,47,40],[7,15,26],[8,0,13],[40,34,10],[25,3,19],[44,9,5],[16,6,22],[34,35,39],[24,5,2],[3,22,16],[27,24,3],[35,5,29],[5,48,49],[12,22,8],[45,15,36],[2,35,36],[24,18,14],[24,49,3],[49,20,38],[41,24,25],[18,49,15],[24,4,23],[16,0,22],[41,46,34],[7,12,31],[9,5,13],[19,44,49],[8,25,8],[24,7,9],[4,33,38],[49,19,17],[11,31,19],[29,40,31],[30,29,10],[25,20,31],[38,28,18],[21,29,18],[18,46,19],[43,33,43],[22,15,19],[26,44,21],[9,13,13],[0,20,9],[11,9,12],[22,39,43],[43,47,29],[12,10,34],[49,36,41],[39,48,11],[9,27,13],[9,8,30],[18,49,39],[18,33,40],[35,22,28],[8,6,24],[14,41,10],[21,34,20],[37,6,2],[20,7,24],[11,10,29],[12,35,2],[22,41,9],[47,1,16],[29,2,38],[46,40,29],[32,47,10],[39,33,23],[24,17,3],[27,47,3],[28,10,37],[42,48,46],[48,24,20],[48,44,16],[34,47,28],[48,34,3],[12,23,39],[13,4,44],[0,33,39],[21,3,3],[45,14,38],[36,9,18],[19,3,37],[6,2,27],[29,40,37],[37,42,44],[10,14,10],[15,17,21],[35,12,14],[46,10,18],[41,0,47],[46,28,42],[13,19,25],[42,11,30],[27,14,47],[47,30,36],[13,43,4],[29,3,14],[36,16,40],[1,0,18],[18,6,1],[18,0,20],[24,38,37],[25,48,12],[34,12,27],[8,42,12],[40,4,5],[33,15,13],[40,14,43],[17,23,25],[7,3,12],[41,42,32],[7,11,4],[33,23,36],[3,25,7],[20,22,29],[19,18,21],[6,34,34],[21,31,9],[48,16,22],[14,0,7],[20,10,24],[5,6,44],[24,48,27],[4,39,1],[16,41,43],[2,27,1],[0,7,13],[6,2,30],[40,43,15],[35,39,44],[45,47,37],[29,28,40],[27,41,38],[43,48,49],[23,3,34],[48,43,10],[7,23,17],[4,9,44],[22,41,29],[42,13,33],[40,7,24],[23,21,8],[4,3,27],[7,22,42],[12,26,3],[38,23,3],[14,8,16],[35,26,31],[40,7,9],[4,13,4],[48,47,27],[18,27,2],[20,30,27],[7,32,32],[12,5,25],[47,41,25],[49,27,37],[9,43,4],[47,2,15],[14,47,24],[28,10,4],[36,2,11],[36,25,14],[17,5,38],[26,20,17],[25,40,5],[26,12,30],[29,19,24],[47,16,15],[4,19,27],[8,44,1],[13,41,44],[6,20,28],[44,13,35],[11,39,25],[6,8,19],[16,30,15],[36,43,25],[43,2,9],[34,42,46],[13,18,45],[48,27,36],[16,13,9],[48,27,9],[49,18,6],[41,5,50],[1,20,12],[27,13,40],[1,0,30],[48,28,14],[20,29,15],[14,23,27],[14,23,4],[3,48,18],[2,21,31],[18,43,31],[7,1,11],[25,23,24],[24,0,21],[2,1,38],[20,31,27],[8,38,50],[23,16,33],[22,28,19],[48,17,8],[22,6,22],[4,3,43],[35,4,40],[32,7,8],[46,37,49],[39,24,24],[36,9,25],[39,34,22],[10,28,24],[36,8,21],[23,30,36],[6,0,27],[35,39,47],[14,40,30],[16,24,32],[1,22,13],[0,40,32],[20,15,48],[28,16,2],[16,29,42],[24,19,1],[32,31,11],[4,29,4],[35,39,16],[46,12,38],[22,48,49],[28,12,47],[0,6,22],[39,44,14],[5,37,19],[43,33,33],[37,23,21],[13,8,50],[36,16,30],[9,24,30],[24,10,28],[12,42,11],[4,20,4],[6,44,31],[15,17,39],[14,30,36],[18,47,34],[18,30,28],[16,40,50],[30,3,24],[6,4,41],[7,11,6],[10,20,20],[16,43,18],[13,27,14],[18,1,33],[24,48,45],[2,48,21],[30,18,32],[18,42,17],[42,15,36],[36,7,6],[35,31,12],[13,31,45],[7,8,8],[39,29,12],[20,39,43],[14,42,5],[6,32,44],[11,4,21],[34,25,26],[28,29,28],[45,4,7],[12,2,5],[27,41,44],[44,34,11],[7,11,37],[31,16,13],[47,13,14],[5,34,6],[41,11,49],[48,11,20],[33,42,2],[18,5,21],[4,19,9],[38,46,26],[26,17,13],[19,41,49],[11,38,22],[2,21,11],[13,49,14],[21,9,36],[8,14,27],[45,9,14],[1,2,1],[38,4,35],[1,48,39],[1,18,50],[3,5,4],[47,3,37],[6,26,31],[49,22,46],[14,19,49],[11,33,34],[17,7,25],[30,14,31],[18,14,45],[29,2,45],[14,35,49],[10,37,28],[12,15,20],[34,0,45],[42,7,37],[41,15,16],[47,12,26],[0,30,11],[10,1,22],[16,36,16],[24,32,10],[24,22,50],[35,4,13],[45,10,41],[17,36,23],[2,48,14],[33,11,30],[6,22,27],[42,14,35],[22,4,17],[25,35,26],[49,18,13],[16,25,35],[41,20,12],[2,30,29],[12,11,12],[47,3,13],[2,10,34],[13,29,15],[37,34,44],[8,33,21],[42,37,49],[48,26,31],[18,44,23],[22,8,18],[34,37,30],[41,40,49],[17,41,11],[1,23,32],[5,1,48],[49,23,50],[40,49,32],[25,46,6],[43,30,37],[20,3,13],[5,46,49],[34,10,35],[42,48,38],[40,16,31],[49,43,16],[24,12,16],[2,0,36],[49,29,10],[16,37,37],[22,45,44],[42,21,35],[39,33,14],[9,3,2],[42,34,19],[35,46,24],[36,30,44],[17,2,34],[4,30,29],[28,15,28],[9,8,44],[36,42,46],[9,14,41],[40,23,3],[41,9,23],[42,47,29],[2,22,48],[22,44,32],[15,7,46],[11,28,4],[28,7,47],[14,39,21],[2,7,6],[1,9,12],[25,16,15],[44,10,48],[46,15,3],[7,3,32],[44,30,18],[27,10,46],[11,4,28],[49,15,15],[49,36,10],[36,15,39],[16,36,21],[11,21,29],[29,12,17],[29,31,24],[32,47,13],[3,4,17],[31,18,13],[11,33,6],[7,27,50],[7,3,40],[24,40,41],[47,25,42],[20,38,21],[42,25,10],[20,0,42],[31,19,6],[31,8,29],[3,19,10],[9,32,50],[15,17,40],[12,9,42],[16,28,25],[26,10,20],[19,0,42],[10,48,27],[47,1,33],[36,29,18],[38,36,38],[0,41,31],[17,27,23],[39,8,30],[47,37,5],[39,1,50],[39,25,21],[13,35,22],[0,22,8],[3,1,39],[11,7,3],[12,44,28],[33,13,27],[30,16,7],[36,45,31],[33,32,42],[33,1,15],[39,3,23],[48,6,12],[24,49,5],[13,46,22],[43,23,26],[24,15,46],[24,43,14],[0,14,31],[42,41,6],[14,47,6],[36,39,6],[24,18,45],[10,39,1],[17,25,22],[36,23,23],[10,23,42],[40,33,41],[41,28,13],[25,1,1],[10,45,19],[40,2,42],[14,42,40],[13,37,24],[29,38,32],[47,11,35],[24,4,45],[37,40,7],[29,45,37],[13,44,49]]\\n[190,843,824,838,336,528,395,301,902,169,729,254,2,463,15,649,865,840,198,789,232,516,699,157,608,893,40,87,615,294,214,66,313,103,847,326,501,1000,65,35,622,905,15,571,808,444,866,11,182,657]\\n\\n\\n\\n\\nAfter checking few solutions tried to change the adjacency matrix to adjacency list ie.\\n\\nfrom int[][] graph = new int[n][n]    ->    List<int[]>[] graph = new List [n]\\n\\nand it worked!!\\n\\nCan someone please explain what is happening internally in JAVA ??\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n            int n = passingFees.length;\\n\\n            int[][] matrix = new int[n][n];\\n            for (int[] edge : edges) {\\n                matrix[edge[0]][edge[1]] = edge[2];\\n                matrix[edge[1]][edge[0]] = edge[2];\\n            }\\n\\n            int[] costToReach = new int[n];\\n            int[] timeToReach = new int[n];\\n            Arrays.fill(costToReach, Integer.MAX_VALUE);\\n            Arrays.fill(timeToReach, Integer.MAX_VALUE);\\n            costToReach[0] = passingFees[0];\\n            timeToReach[0] = 0;\\n\\n            //Minimum Cost at Top\\n            PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n            minHeap.add(new int[]{0, costToReach[0], 0});\\n\\n            while (!minHeap.isEmpty()) {\\n                int[] info = minHeap.poll(); //pick min costly city\\n\\n                int currCity = info[0];\\n                int costToReachCurrCity = info[1];\\n                int timeToReachCurrCity = info[2];\\n\\n                if (currCity == n - 1)    // If destination reached\\n                    return costToReachCurrCity;\\n\\n                if (timeToReachCurrCity > maxTime)    // If current time to reach curr city exceeds maxTime\\n                    continue;\\n\\n                for (int nextCity = 0; nextCity < n; nextCity++) {\\n                    if (matrix[currCity][nextCity] > 0) {\\n                        int timeToReachNextFromCurrCity = matrix[currCity][nextCity];\\n                        int timeToReachNextCity = timeToReach[nextCity];\\n\\n                        if (timeToReachCurrCity + timeToReachNextFromCurrCity > maxTime)\\n                            continue;\\n\\n                        if ((timeToReachCurrCity + timeToReachNextFromCurrCity < timeToReachNextCity) || (costToReachCurrCity + passingFees[nextCity] < costToReach[nextCity])) {\\n                            minHeap.add(new int[]{nextCity, costToReachCurrCity + passingFees[nextCity], timeToReachCurrCity + timeToReachNextFromCurrCity});\\n                            costToReach[nextCity] = costToReachCurrCity + passingFees[nextCity];\\n                            timeToReach[nextCity] = timeToReachCurrCity + timeToReachNextFromCurrCity;\\n                        }\\n                    }\\n                }\\n            }\\n            return costToReach[n - 1] == Integer.MAX_VALUE ? -1 : costToReach[n - 1];\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1332315,
                "title": "java",
                "content": "Dijkstra, priority queue compares by cost, a visited node may need to be enqueued again on the condition of less time consuming(cost is always increasing), return cost when the first time we encounter the last node since priority queue guarantees the lowest cost.\\n```\\nclass Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        int[] min = new int[n];\\n        Arrays.fill(min, Integer.MAX_VALUE);\\n        Map<Integer, List<int[]>> map = new HashMap();\\n        for(int[] edge : edges){\\n            map.putIfAbsent(edge[0], new ArrayList());\\n            map.putIfAbsent(edge[1], new ArrayList());\\n            map.get(edge[0]).add(new int[]{edge[1], edge[2]});\\n            map.get(edge[1]).add(new int[]{edge[0], edge[2]});\\n        }\\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>((a,b)->(a[1]-b[1]));\\n        q.offer(new int[]{0, passingFees[0], 0});\\n        while(!q.isEmpty()){\\n            int[] cur = q.poll();\\n            if(cur[0]==n-1) return cur[1];\\n            for(int[] neig : map.get(cur[0])){\\n                if(cur[2]+neig[1]>maxTime || cur[2]+neig[1]>=min[neig[0]]) continue;\\n                min[neig[0]] = cur[2]+neig[1];\\n                q.offer(new int[]{neig[0], cur[1]+passingFees[neig[0]], cur[2]+neig[1]});\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\\n        int n = passingFees.length;\\n        int[] min = new int[n];\\n        Arrays.fill(min, Integer.MAX_VALUE);\\n        Map<Integer, List<int[]>> map = new HashMap();\\n        for(int[] edge : edges){\\n            map.putIfAbsent(edge[0], new ArrayList());\\n            map.putIfAbsent(edge[1], new ArrayList());\\n            map.get(edge[0]).add(new int[]{edge[1], edge[2]}",
                "codeTag": "Java"
            },
            {
                "id": 1331766,
                "title": "simple-dfs-with-dp-memoization",
                "content": "\\n\\n```\\n    int n,mtime;\\n    vector<pair<int,int>> adj[1001]; \\n     int  dp[1001][1001];\\n    \\n    \\n    int dfs(int u,vector<pair<int,int>> *adj, vector<int> &fee, int ct)\\n    {\\n\\t\\t\\t//if we reach the end \\n        if(u==n-1)\\n            return fee[n-1];\\n\\t\\t\\t\\n\\t\\t\\t//if we already encountered this vertex with current time ct \\n       if(dp[u][ct]!=-1)\\n           return dp[u][ct];\\n       \\n        \\n        int ans=INT_MAX;\\n        for(auto it: adj[u]){\\n            if(ct+it.second>mtime ) // if adding time  exceeds the maxtime then we simply continue\\n                continue;\\n            int next = dfs(it.first, adj, fee, ct+it.second);\\n            ans=min(next, ans);\\n        }\\n      \\n        if(ans==INT_MAX)\\n            return dp[u][ct]= INT_MAX; //if none of the vertex gives us the  path satisfying time constraint\\n\\t\\t\\t\\n        return dp[u][ct]=ans+fee[u];\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        n=0;\\n        for(int i=0;i<n;i++)\\n            adj[i].clear();\\n\\t\\t\\t\\n        memset(dp,-1,sizeof(dp));\\n        mtime=maxTime;\\n        n=fee.size();\\n\\t\\t\\n        for(auto it: edges){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n\\t\\t\\n        \\n        int ans=  dfs(0,adj,fee,0);\\n\\t\\t\\n        if(ans==INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n        \\n    } ```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n    int n,mtime;\\n    vector<pair<int,int>> adj[1001]; \\n     int  dp[1001][1001];\\n    \\n    \\n    int dfs(int u,vector<pair<int,int>> *adj, vector<int> &fee, int ct)\\n    {\\n\\t\\t\\t//if we reach the end \\n        if(u==n-1)\\n            return fee[n-1];\\n\\t\\t\\t\\n\\t\\t\\t//if we already encountered this vertex with current time ct \\n       if(dp[u][ct]!=-1)\\n           return dp[u][ct];\\n       \\n        \\n        int ans=INT_MAX;\\n        for(auto it: adj[u]){\\n            if(ct+it.second>mtime ) // if adding time  exceeds the maxtime then we simply continue\\n                continue;\\n            int next = dfs(it.first, adj, fee, ct+it.second);\\n            ans=min(next, ans);\\n        }\\n      \\n        if(ans==INT_MAX)\\n            return dp[u][ct]= INT_MAX; //if none of the vertex gives us the  path satisfying time constraint\\n\\t\\t\\t\\n        return dp[u][ct]=ans+fee[u];\\n    }\\n    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fee) {\\n        n=0;\\n        for(int i=0;i<n;i++)\\n            adj[i].clear();\\n\\t\\t\\t\\n        memset(dp,-1,sizeof(dp));\\n        mtime=maxTime;\\n        n=fee.size();\\n\\t\\t\\n        for(auto it: edges){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n\\t\\t\\n        \\n        int ans=  dfs(0,adj,fee,0);\\n\\t\\t\\n        if(ans==INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n        \\n    } ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330972,
                "title": "modified-dijkstra-but-keeping-code-simple-and-more-intuitive",
                "content": "```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n        int n = fees.size();\\n        vector<vector<int>> graph(n,vector<int>(n,-1));\\n        for(auto& edge : edges){\\n            int city1 = edge[0];\\n            int city2 = edge[1];\\n            int time = edge[2];\\n            if(graph[city1][city2] > 0) {\\n\\t\\t\\t\\t// since two nodes can have multiple edges between them. \\n\\t\\t\\t\\t//we would always want to use the best edge, so we take only the smallest.\\n                graph[city1][city2] = min(graph[city1][city2],time);\\n            }else\\n                graph[city1][city2]=time;\\n            graph[city2][city1] = graph[city1][city2];\\n        }\\n        \\n        vector<int> ntime(n,INT_MAX);\\n        vector<int> ncost(n,INT_MAX);\\n        ntime[0]=0;\\n        ncost[0]=fees[0];\\n        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq; \\n        pq.push({fees[0],0,0});\\n        while(pq.empty()==false)\\n        {\\n            auto [cost,time,city] = pq.top();pq.pop();\\n            //cout << cost << \",\" << time << \",\"<<city << endl;\\n            if(city == n-1)return cost;\\n            for(int i=0; i<n;i++){\\n                if(i!=city and graph[city][i]>=0 and time+graph[city][i]<= maxTime){\\n                    if(fees[i]+cost < ncost[i] or time+graph[city][i] < ntime[i]){\\n                        ncost[i] = min(fees[i]+cost, ncost[i]);\\n                        ntime[i] = min(time+graph[city][i],ntime[i]);\\n                        pq.push({fees[i]+cost,time+graph[city][i],i});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minCost(int maxTime, vector<vector<int>>& edges, vector<int>& fees) {\\n        int n = fees.size();\\n        vector<vector<int>> graph(n,vector<int>(n,-1));\\n        for(auto& edge : edges){\\n            int city1 = edge[0];\\n            int city2 = edge[1];\\n            int time = edge[2];\\n            if(graph[city1][city2] > 0) {\\n\\t\\t\\t\\t// since two nodes can have multiple edges between them. \\n\\t\\t\\t\\t//we would always want to use the best edge, so we take only the smallest.\\n                graph[city1][city2] = min(graph[city1][city2],time);\\n            }else\\n                graph[city1][city2]=time;\\n            graph[city2][city1] = graph[city1][city2];\\n        }\\n        \\n        vector<int> ntime(n,INT_MAX);\\n        vector<int> ncost(n,INT_MAX);\\n        ntime[0]=0;\\n        ncost[0]=fees[0];\\n        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq; \\n        pq.push({fees[0],0,0});\\n        while(pq.empty()==false)\\n        {\\n            auto [cost,time,city] = pq.top();pq.pop();\\n            //cout << cost << \",\" << time << \",\"<<city << endl;\\n            if(city == n-1)return cost;\\n            for(int i=0; i<n;i++){\\n                if(i!=city and graph[city][i]>=0 and time+graph[city][i]<= maxTime){\\n                    if(fees[i]+cost < ncost[i] or time+graph[city][i] < ntime[i]){\\n                        ncost[i] = min(fees[i]+cost, ncost[i]);\\n                        ntime[i] = min(time+graph[city][i],ntime[i]);\\n                        pq.push({fees[i]+cost,time+graph[city][i],i});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1566668,
                "content": [
                    {
                        "username": "iit2018133",
                        "content": "if we take priority queue of [cost,time,vertex] and use custom comparator such that top of the heap is max cost and minimum time.\\n\\ncomment your responses and UPVOTE if useful.\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thanks. I was not even aware that you can use custom comparator in pq as well.\\n"
                    },
                    {
                        "username": "eminem18753",
                        "content": "You probably trim all the paths which don\\'t have smallest cost.\\nHowever, the trimmed paths may have smaller time cost, in this case, you can\\'t reach the target within max time.\\neg. You only keep the path with smallest fee, but with probably larger time cost. The paths with smaller time cost may be trimmed.\\nTips:\\nIf you use heap/priority_queue, you should trim the paths if the total time is larger, but not if the total cost is larger."
                    },
                    {
                        "username": "rohanchhabra424",
                        "content": "Hi, I have been able to solve this question using DFS + DP (memoization). However, the solution is correct if, during DFS, we don\\'t discard the parent/visited node in the current path. Can anyone explain how this is optimal? Since all the values are +ve, this just doesn\\'t feel intuitive at all."
                    }
                ]
            },
            {
                "id": 1575517,
                "content": [
                    {
                        "username": "iit2018133",
                        "content": "if we take priority queue of [cost,time,vertex] and use custom comparator such that top of the heap is max cost and minimum time.\\n\\ncomment your responses and UPVOTE if useful.\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thanks. I was not even aware that you can use custom comparator in pq as well.\\n"
                    },
                    {
                        "username": "eminem18753",
                        "content": "You probably trim all the paths which don\\'t have smallest cost.\\nHowever, the trimmed paths may have smaller time cost, in this case, you can\\'t reach the target within max time.\\neg. You only keep the path with smallest fee, but with probably larger time cost. The paths with smaller time cost may be trimmed.\\nTips:\\nIf you use heap/priority_queue, you should trim the paths if the total time is larger, but not if the total cost is larger."
                    },
                    {
                        "username": "rohanchhabra424",
                        "content": "Hi, I have been able to solve this question using DFS + DP (memoization). However, the solution is correct if, during DFS, we don\\'t discard the parent/visited node in the current path. Can anyone explain how this is optimal? Since all the values are +ve, this just doesn\\'t feel intuitive at all."
                    }
                ]
            },
            {
                "id": 1677687,
                "content": [
                    {
                        "username": "iit2018133",
                        "content": "if we take priority queue of [cost,time,vertex] and use custom comparator such that top of the heap is max cost and minimum time.\\n\\ncomment your responses and UPVOTE if useful.\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thanks. I was not even aware that you can use custom comparator in pq as well.\\n"
                    },
                    {
                        "username": "eminem18753",
                        "content": "You probably trim all the paths which don\\'t have smallest cost.\\nHowever, the trimmed paths may have smaller time cost, in this case, you can\\'t reach the target within max time.\\neg. You only keep the path with smallest fee, but with probably larger time cost. The paths with smaller time cost may be trimmed.\\nTips:\\nIf you use heap/priority_queue, you should trim the paths if the total time is larger, but not if the total cost is larger."
                    },
                    {
                        "username": "rohanchhabra424",
                        "content": "Hi, I have been able to solve this question using DFS + DP (memoization). However, the solution is correct if, during DFS, we don\\'t discard the parent/visited node in the current path. Can anyone explain how this is optimal? Since all the values are +ve, this just doesn\\'t feel intuitive at all."
                    }
                ]
            }
        ]
    }
]