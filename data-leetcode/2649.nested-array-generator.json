[
    {
        "title": "Nested Array Generator",
        "question_content": "Given a&nbsp;multi-dimensional array of integers, return&nbsp;a generator object which&nbsp;yields integers in the same order as&nbsp;inorder traversal.\nA&nbsp;multi-dimensional array&nbsp;is a recursive data structure that contains both integers and other&nbsp;multi-dimensional arrays.\ninorder traversal&nbsp;iterates over&nbsp;each array from left to right, yielding any integers it encounters or applying&nbsp;inorder traversal&nbsp;to any arrays it encounters.\n&nbsp;\nExample 1:\n\nInput: arr = [[[6]],[1,3],[]]\nOutput: [6,1,3]\nExplanation:\nconst generator = inorderTraversal(arr);\ngenerator.next().value; // 6\ngenerator.next().value; // 1\ngenerator.next().value; // 3\ngenerator.next().done; // true\n\nExample 2:\n\nInput: arr = []\nOutput: []\nExplanation: There are no integers so the generator doesn't yield anything.\n\n&nbsp;\nConstraints:\n\n\t0 <= arr.flat().length <= 105\n\t0 <= arr.flat()[i]&nbsp;<= 105\n\tmaxNestingDepth <= 105\n\n&nbsp;\nCan you solve this without creating a new flattened version of the array?",
        "solutions": [
            {
                "id": 3439989,
                "title": "javascript-recursive-generator-o-n-time-and-o-d-space",
                "content": "Generator is a feature introduced in Javascript ES6. Through the `yield` keyword, we can pause function execution and return an intermediate value until the next time the generator is invoked.\\n\\n`yield*` is used when we want to delegate to another Generator (in this case the recursive call).\\n\\nTime complexity: O(n), where n is the # of *total* elements in array, i.e. `arr.flat().length`\\nSpace complexity: O(d), where d is the maximum depth of the nested array\\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let element of arr) {\\n        if (Array.isArray(element)) {\\n            yield* inorderTraversal(element);\\n        } else {\\n            yield element;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    for (let element of arr) {\\n        if (Array.isArray(element)) {\\n            yield* inorderTraversal(element);\\n        } else {\\n            yield element;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591354,
                "title": "inorder-yield-with-explanation",
                "content": "The `inorderTraversal` function uses a generator `(function*)` to yield integers in the same order as an inorder traversal of the multi-dimensional array.\\n\\nThe function iterates over each element in the array. If the element is an array itself, the function recursively calls `inorderTraversal` on that subarray using the `yield*` syntax to yield integers from the subarray in the correct order. If the element is an integer, it is immediately yielded.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591317,
                "title": "4-liner-lets-go-commented",
                "content": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n```\\n\\nThe code we provided is a JavaScript generator function that performs an inorder traversal on a nested array (`arr`) and yields each element in the traversal sequence. Let\\'s break down the code and explain it with an example:\\n\\nThe `for` loop iterates over each element in the `arr` array. \\n\\n- If the current element `arr[i]` is an array itself (checked using `Array.isArray()`), it recursively calls the `inorderTraversal` function with the nested array `arr[i]` as the argument, using the `yield*` syntax. This means that the generator will yield all the values generated by the recursive call.\\n- If the current element `arr[i]` is not an array, it means it is a leaf node in the tree structure, so it is directly yielded using the `yield` keyword.\\n\\nHere\\'s an example to illustrate how the code works:\\n\\n```javascript\\nconst arr = [1, [2, 3, [4, 5]], 6, [7, 8]];\\n\\nconst generator = inorderTraversal(arr);\\n\\nfor (const value of generator) {\\n  console.log(value);\\n}\\n```\\n\\nThe nested array `arr` contains several levels of nesting. The inorder traversal will yield the elements in the order they would be visited in an inorder traversal of the nested structure. The expected output of the example above would be:\\n\\n```\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n```\\n\\nThe generator first yields the elements from the left subtree, then the root, and finally the elements from the right subtree, following the order: left subtree -> root -> right subtree.",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n```\n```javascript\\nconst arr = [1, [2, 3, [4, 5]], 6, [7, 8]];\\n\\nconst generator = inorderTraversal(arr);\\n\\nfor (const value of generator) {\\n  console.log(value);\\n}\\n```\n```\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591518,
                "title": "java-script-solution-for-nested-array-generator-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use recursion to perform an inorder traversal on the multi-dimensional array. The approach is to define a helper function called traverse that recursively traverses the array and yields integers encountered in the inorder traversal order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inorderTraversal function takes the input multi-dimensional array arr and returns a generator object.\\n1. The traverse function is a recursive helper function that takes a node as input.\\n1. If the node is an array, the function iterates over each subarray using a for...of loop.\\n1. For each subarray, the traverse function recursively calls itself with the subarray as the argument.\\n1. If the node is not an array (i.e., it\\'s an integer), the function yields the integer using the yield keyword.\\n1. The yield* traverse(arr) statement in the inorderTraversal function initializes the generator and starts the traversal by calling the traverse function with the input array arr.\\n1. Each time the generator\\'s next() method is called, it progresses through the traversal and returns the next yielded value.\\n1. The generator can be used to retrieve integers from the multi-dimensional array in the order of an inorder traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(N), where N is the total number of integers in the multi-dimensional array. This is because the solution needs to visit each integer exactly once to yield it.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(D), where D is the maximum nesting depth of the multi-dimensional array. This is because the recursion depth is equal to the nesting depth, and each recursive call consumes stack space.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591734,
                "title": "easy-solution-beat-100-approx",
                "content": "![image.png](https://assets.leetcode.com/users/images/899c7053-f2fb-4131-920f-7e112233d0f9_1685772426.0217776.png)\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    const inorderArray = [];\\n    const solve = (arr) => {\\n      for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i])) solve(arr[i]);\\n        else inorderArray.push(arr[i]);\\n      }\\n    }\\n    solve(arr);\\n    for(let i=0;i<inorderArray.length;i++){\\n      yield inorderArray[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    const inorderArray = [];\\n    const solve = (arr) => {\\n      for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i])) solve(arr[i]);\\n        else inorderArray.push(arr[i]);\\n      }\\n    }\\n    solve(arr);\\n    for(let i=0;i<inorderArray.length;i++){\\n      yield inorderArray[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3559657,
                "title": "simple-solution-using-a-stack",
                "content": "# Approach\\nUses a stack to keep track of which elements to visit next.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n  if (arr.length === 0) {\\n    return null\\n  }\\n\\n  const stack = [arr]\\n  while (stack.length > 0) {\\n    const current = stack.pop()\\n    if (Array.isArray(current)) {\\n      for (let i = current.length - 1; i >= 0; i--) {\\n        stack.push(current[i])\\n      }\\n    } else {\\n      yield current\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n  if (arr.length === 0) {\\n    return null\\n  }\\n\\n  const stack = [arr]\\n  while (stack.length > 0) {\\n    const current = stack.pop()\\n    if (Array.isArray(current)) {\\n      for (let i = current.length - 1; i >= 0; i--) {\\n        stack.push(current[i])\\n      }\\n    } else {\\n      yield current\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924305,
                "title": "1-line-typescript-solution",
                "content": "# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(\\n  arr: MultidimensionalArray\\n): Generator<number, void, unknown> {\\n  for (const x of arr) Array.isArray(x) ? yield* inorderTraversal(x) : yield x;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(\\n  arr: MultidimensionalArray\\n): Generator<number, void, unknown> {\\n  for (const x of arr) Array.isArray(x) ? yield* inorderTraversal(x) : yield x;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533497,
                "title": "simplest-and-easiest-solution-in-javascript-wow-0-0-you-must-watch-solution",
                "content": "# Please upvote if you liked :)\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let array = arr.flat(Infinity)\\n    array.reverse()\\n    while(array.length) {\\n        yield array.pop()\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let array = arr.flat(Infinity)\\n    array.reverse()\\n    while(array.length) {\\n        yield array.pop()\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462325,
                "title": "javascript-simplest-solution",
                "content": "\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097005,
                "title": "new-flattened-version-of-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using the delegation (yield*), we can make the main generator function in charge of yielding the sub generator function. If an item in the array is another array, the sub generator function will delegate the\\xA0yielding process of\\xA0another sub generator function that contains our sub array, automating the yielding process.\\n# Complexity\\n- Time complexity: 153ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 74.09MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    function* Generator(interior){\\n        for(let i = 0;i < interior.length;i++){\\n            if(Array.isArray(interior[i])){\\n                yield* Generator(interior[i]);\\n            }else{\\n                yield interior[i];\\n            };\\n        }\\n    }\\n    yield* Generator(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2                                                                                   \\n * gen.next().value; // 3 */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    function* Generator(interior){\\n        for(let i = 0;i < interior.length;i++){\\n            if(Array.isArray(interior[i])){\\n                yield* Generator(interior[i]);\\n            }else{\\n                yield interior[i];\\n            };\\n        }\\n    }\\n    yield* Generator(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2                                                                                   \\n * gen.next().value; // 3 */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062068,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978369,
                "title": "recursive-generator-explained-145ms-74-71mb-beats-87-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOff the name of the problem and from a quick glance you can easily tell that this calls for recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Loop through the multidimensional array\\n    - If the current item is an array yield the generator with the current array as the argument\\n    - Else the current item is a number, yield the number  \\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray)\\n        } else {\\n            yield arr[i] as number\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray)\\n        } else {\\n            yield arr[i] as number\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958842,
                "title": "javascript-simple-approach-yield-operator-beats-95-run-time",
                "content": "\\n# Code\\n```\\n\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity)\\n\\n    var i = 0\\n\\n    let n = arr.length\\n\\n    for(i; i < n; i++){\\n        yield arr[i]\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity)\\n\\n    var i = 0\\n\\n    let n = arr.length\\n\\n    for(i; i < n; i++){\\n        yield arr[i]\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932680,
                "title": "typescript-recursive-solution",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr)\\n        if (Array.isArray(item)) yield* inorderTraversal(item as MultidimensionalArray)\\n        else yield item\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr)\\n        if (Array.isArray(item)) yield* inorderTraversal(item as MultidimensionalArray)\\n        else yield item\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928992,
                "title": "using-built-in-flat-iterative-and-recursive-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Using Flat\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\\n\\n# Using Iterative\\n```\\n/**\\n* @param {Array} arr\\n*\\n* @return {Generator}\\n*/\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n\\n    while(stack.length) {\\n      let item = stack.pop()\\n\\n      if(typeof item == \\'number\\') {\\n        yield item\\n        continue;\\n      }\\n\\n      for(let i = item.length - 1; i >= 0; i--) {\\n        stack.push(item[i])\\n      }\\n    }\\n}\\n```\\n\\n# Using Recursive\\n\\n```\\n/**\\n* @param {Array} arr\\n* @return {Generator}\\n* /\\nvar inorderTraversal = function*(arr) {   \\n    for(let i = 0; i < arr.length; ++i) {\\n        if(typeof arr[i] == \\'number\\') yield arr[i]\\n        else {\\n           yield* inorderTraversal(arr[i])\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\n```\\n/**\\n* @param {Array} arr\\n*\\n* @return {Generator}\\n*/\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n\\n    while(stack.length) {\\n      let item = stack.pop()\\n\\n      if(typeof item == \\'number\\') {\\n        yield item\\n        continue;\\n      }\\n\\n      for(let i = item.length - 1; i >= 0; i--) {\\n        stack.push(item[i])\\n      }\\n    }\\n}\\n```\n```\\n/**\\n* @param {Array} arr\\n* @return {Generator}\\n* /\\nvar inorderTraversal = function*(arr) {   \\n    for(let i = 0; i < arr.length; ++i) {\\n        if(typeof arr[i] == \\'number\\') yield arr[i]\\n        else {\\n           yield* inorderTraversal(arr[i])\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915612,
                "title": "simple-js-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar inorderTraversal = function*(arr) {\\n    const q = arr.reverse()\\n\\n    while (q.length) {\\n        const curr = q.pop()\\n        if (typeof curr === \\'number\\') yield curr\\n        else q.push(...curr.reverse())\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    const q = arr.reverse()\\n\\n    while (q.length) {\\n        const curr = q.pop()\\n        if (typeof curr === \\'number\\') yield curr\\n        else q.push(...curr.reverse())\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909471,
                "title": "javascript-solution-beats-96-31-flat-approach",
                "content": "```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let flatArray = arr.flat(Infinity);\\n    for (let i = 0; i < flatArray.length; i++) {\\n        yield flatArray[i];\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let flatArray = arr.flat(Infinity);\\n    for (let i = 0; i < flatArray.length; i++) {\\n        yield flatArray[i];\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895707,
                "title": "yield-array-flat",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) We transfer the nested array into a flattened array\\n2) We iterate and yield the current index each time\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flattenedArr = arr.flat(Infinity) ;\\n    let i = 0 ;\\n    while(i < flattenedArr.length) yield flattenedArr[i++] ;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flattenedArr = arr.flat(Infinity) ;\\n    let i = 0 ;\\n    while(i < flattenedArr.length) yield flattenedArr[i++] ;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814962,
                "title": "the-js-way-flat-and-then-yield",
                "content": "# Complexity\\n- Time complexity: O(n), where n is the number of 2d arrays\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is size of flatArr\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flatArr = helper(arr);\\n\\n    let i = 0;\\n\\n    while(i < flatArr.length) {\\n        yield flatArr[i];\\n        i++;\\n    }\\n\\n    function helper(arr) {\\n        const newArr = [];\\n\\n        for(let i=0; i<arr.length; i++) {\\n            if(Array.isArray(arr[i])) {\\n                newArr.push(...helper(arr[i]));\\n            } else {\\n                newArr.push(arr[i]);\\n            }\\n        }\\n\\n        return newArr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const flatArr = helper(arr);\\n\\n    let i = 0;\\n\\n    while(i < flatArr.length) {\\n        yield flatArr[i];\\n        i++;\\n    }\\n\\n    function helper(arr) {\\n        const newArr = [];\\n\\n        for(let i=0; i<arr.length; i++) {\\n            if(Array.isArray(arr[i])) {\\n                newArr.push(...helper(arr[i]));\\n            } else {\\n                newArr.push(arr[i]);\\n            }\\n        }\\n\\n        return newArr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799621,
                "title": "iterative-approach",
                "content": "# Intuition\\nTraverse the array using iterators\\n\\n# Approach\\nI used an iterative approach using a stack: \\n\\n- Keep iterating until done with each level of the stack\\n- Add array iterator to the stack when encountering a nested array\\n- Yield any values encountered\\n\\n# Complexity\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nconst inorderTraversal = function *(arr) {\\n    if (!arr.length) return;\\n\\n    const stack = [arr[Symbol.iterator]()];\\n    while (stack.length) {\\n        const cur = stack[stack.length-1].next();\\n        if (cur.done) {\\n            stack.pop();\\n            if (cur.value === undefined) continue;\\n        }\\n\\n        if (Array.isArray(cur.value)) {\\n            stack.push(cur.value[Symbol.iterator]());\\n        } else {\\n            yield cur.value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nconst inorderTraversal = function *(arr) {\\n    if (!arr.length) return;\\n\\n    const stack = [arr[Symbol.iterator]()];\\n    while (stack.length) {\\n        const cur = stack[stack.length-1].next();\\n        if (cur.done) {\\n            stack.pop();\\n            if (cur.value === undefined) continue;\\n        }\\n\\n        if (Array.isArray(cur.value)) {\\n            stack.push(cur.value[Symbol.iterator]());\\n        } else {\\n            yield cur.value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791275,
                "title": "fast-and-simple-beats-85",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n\\n    for ( const number of arr ) {\\n        yield number;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n\\n    for ( const number of arr ) {\\n        yield number;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737762,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const el of arr){\\n        if(Array.isArray(el)){\\n            yield *inorderTraversal(el); //delegate generator\\n        }else{\\n            yield el;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const el of arr){\\n        if(Array.isArray(el)){\\n            yield *inorderTraversal(el); //delegate generator\\n        }else{\\n            yield el;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737628,
                "title": "easy-javascript-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function*(arr) {\\n    let flatArray =  arr.flat(Infinity);\\n   for(ele of flatArray){\\n     yield ele;\\n   }\\n   \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function*(arr) {\\n    let flatArray =  arr.flat(Infinity);\\n   for(ele of flatArray){\\n     yield ele;\\n   }\\n   \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714405,
                "title": "simple-easy-one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray.flat() to flatten the nested array. maxNestingDepth <= Math.pow(10, 5)\\nThe flatten array is an iterable object.\\nThe yield* expression iterates over the operand and yields each value returned by it.\\n![\\u6355\\u83B7.JPG](https://assets.leetcode.com/users/images/f67e6d95-0935-4d13-8227-33b7b5e35666_1688412203.5342648.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Math.pow(10, 5))\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Math.pow(10, 5))\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709610,
                "title": "generators-are-functions-that-can-be-exited-and-later-re-entered",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr=arr.flat(Infinity);\\n    while(arr.length){\\n        yield arr.shift();\\n        inorderTraversal(arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr=arr.flat(Infinity);\\n    while(arr.length){\\n        yield arr.shift();\\n        inorderTraversal(arr);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671001,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(arr.length === 0) return arr;\\n\\n    function* rec(arr) {\\n        for(var i = 0; i < arr.length; i++){\\n            if(Array.isArray(arr[i])) {\\n                yield * rec(arr[i]);\\n            }\\n            if(typeof arr[i] === \\'number\\' && Number.isInteger(arr[i])) {\\n                yield arr[i];\\n            }\\n        };\\n    }\\n    yield * rec(arr)\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(arr.length === 0) return arr;\\n\\n    function* rec(arr) {\\n        for(var i = 0; i < arr.length; i++){\\n            if(Array.isArray(arr[i])) {\\n                yield * rec(arr[i]);\\n            }\\n            if(typeof arr[i] === \\'number\\' && Number.isInteger(arr[i])) {\\n                yield arr[i];\\n            }\\n        };\\n    }\\n    yield * rec(arr)\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665110,
                "title": "easy-recursive-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i =0; i<arr.length; i++ ){\\n        if(Array.isArray(arr[i])){\\n             yield *inorderTraversal(arr[i]);\\n        }\\n        else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i =0; i<arr.length; i++ ){\\n        if(Array.isArray(arr[i])){\\n             yield *inorderTraversal(arr[i]);\\n        }\\n        else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3649791,
                "title": "1-liner-flat-hack",
                "content": "# Approach\\nJust use flat method to unpack all inner arrays, iterate it, enjoy it\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const el of arr.flat(Infinity)) yield el\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const el of arr.flat(Infinity)) yield el\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609994,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595963,
                "title": "traverse-it-recursively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we have an array such that some of elements are arrays too - we use recursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a loop to interate through array\\n2. check current element\\n    - if it is non-array element - yield it\\n    - otherwise, invoke itself with this element\\n    - keep invoking `next` until it is `.done`\\n    - before that `yield` each `value`\\n    \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (arr.length === 0) { return; }\\n    for (let key in arr) {\\n      if (Array.isArray(arr[key])) {\\n        const innerGen = inorderTraversal(arr[key]);\\n        let task;\\n        do {\\n          if (task) {\\n            yield task.value;\\n          }\\n          task = innerGen.next();\\n        } while (!task.done)\\n      } else {\\n        yield arr[key];\\n      }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (arr.length === 0) { return; }\\n    for (let key in arr) {\\n      if (Array.isArray(arr[key])) {\\n        const innerGen = inorderTraversal(arr[key]);\\n        let task;\\n        do {\\n          if (task) {\\n            yield task.value;\\n          }\\n          task = innerGen.next();\\n        } while (!task.done)\\n      } else {\\n        yield arr[key];\\n      }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595284,
                "title": "simple-inorder-yield",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594575,
                "title": "day-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item; // Yield integers encountered\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item; // Yield integers encountered\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594490,
                "title": "easy-beginner-friendly-day-30",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594429,
                "title": "javascript-faster-than-65-recursion",
                "content": "# Intuition\\nUse recursion.\\n\\n# Approach\\nUse recursion if the typeof arr is not a number. Otherwise return arr.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is a total number of integer items in arr.\\n\\n- Space complexity:\\n$$O(n)$$, where n is a total number of integer items in arr.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (typeof arr == \\'number\\'){\\n        yield arr;\\n    }\\n    else\\n    {\\n        for (let i = 0; i < arr.length; i++){\\n            yield * inorderTraversal(arr[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (typeof arr == \\'number\\'){\\n        yield arr;\\n    }\\n    else\\n    {\\n        for (let i = 0; i < arr.length; i++){\\n            yield * inorderTraversal(arr[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594067,
                "title": "typescript-recursion-solution",
                "content": "# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0, n = arr.length; i < n; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n        } else yield arr[i] as number;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (let i = 0, n = arr.length; i < n; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n        } else yield arr[i] as number;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594035,
                "title": "my-js-solution-stepping-through-each-element-runtime-beats-96-27-memory-beats-99-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI step through each element without modifying the original arr parameter. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep through each element in the array until a child array is found. Then step through that array, and repeat. \\nI dont save the index of where I left of in the parent and instead use .indexOf the partent to find the childs index value and continue from there.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!arr.length){\\n        return [];\\n    }\\n\\n    let refScope = [arr];\\n    let refIndex = 0;\\n\\n    while(refScope.length){\\n        let ref = refScope[refScope.length - 1];\\n\\n        //if we\\'re finished with the current array remove it\\n        if(refIndex >= ref.length){\\n            //set index to the last spot of previous scope first.\\n            if(refScope.length >= 2){\\n                refIndex = refScope[refScope.length - 2].indexOf(ref) + 1;\\n            }\\n            refScope.pop();\\n            continue;\\n        }\\n\\n        let next = ref[refIndex];\\n\\n        //if the next is an array reset index and continue to start traversing the next array\\n        if(Array.isArray(next)){\\n            refScope.push(next);\\n            refIndex = 0;\\n            continue;\\n        }\\n\\n        //otherwise yield the next index\\n        refIndex++;\\n        yield next;\\n\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!arr.length){\\n        return [];\\n    }\\n\\n    let refScope = [arr];\\n    let refIndex = 0;\\n\\n    while(refScope.length){\\n        let ref = refScope[refScope.length - 1];\\n\\n        //if we\\'re finished with the current array remove it\\n        if(refIndex >= ref.length){\\n            //set index to the last spot of previous scope first.\\n            if(refScope.length >= 2){\\n                refIndex = refScope[refScope.length - 2].indexOf(ref) + 1;\\n            }\\n            refScope.pop();\\n            continue;\\n        }\\n\\n        let next = ref[refIndex];\\n\\n        //if the next is an array reset index and continue to start traversing the next array\\n        if(Array.isArray(next)){\\n            refScope.push(next);\\n            refIndex = 0;\\n            continue;\\n        }\\n\\n        //otherwise yield the next index\\n        refIndex++;\\n        yield next;\\n\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593779,
                "title": "java-script-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     // Helper function to perform inorder traversal recursively\\n  function* traverse(node) {\\n    if (Array.isArray(node)) {\\n      for (let subArray of node) {\\n        yield* traverse(subArray);\\n      }\\n    } else {\\n      yield node;\\n    }\\n  }\\n\\n  yield* traverse(arr);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593733,
                "title": "extended-solution-for-better-understanding",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n\\n    // recursive function\\n    const deepExtract = function*(v) {\\n\\n        // if v is object type, starting to iterate over it and yielding \\n        // deepExtract instances to dig down to the integer value we\\'re searching\\n        if (typeof v === \\'object\\') {\\n            for (let i = 0; i < v.length; i++) {\\n                // return nested generator here\\n                yield * deepExtract(v[i]);\\n            }\\n        }\\n\\n        // if number value found, just yield it\\n        if (typeof v === \\'number\\') {\\n            yield v\\n        }\\n    }\\n\\n    \\n    for (let item of deepExtract(arr)) {\\n        yield item\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n\\n    // recursive function\\n    const deepExtract = function*(v) {\\n\\n        // if v is object type, starting to iterate over it and yielding \\n        // deepExtract instances to dig down to the integer value we\\'re searching\\n        if (typeof v === \\'object\\') {\\n            for (let i = 0; i < v.length; i++) {\\n                // return nested generator here\\n                yield * deepExtract(v[i]);\\n            }\\n        }\\n\\n        // if number value found, just yield it\\n        if (typeof v === \\'number\\') {\\n            yield v\\n        }\\n    }\\n\\n    \\n    for (let item of deepExtract(arr)) {\\n        yield item\\n    }\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3593631,
                "title": "simple-solution-eliminates-the-need-for-recursive-function-calls-and-avoid-unnecessary-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [...arr];\\n    while (stack.length > 0){\\n        const current = stack.shift();\\n\\n        if(Array.isArray(current)){\\n            stack.unshift(...current);\\n        }else if(Number.isInteger(current)){\\n            yield current;\\n        }\\n    } \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [...arr];\\n    while (stack.length > 0){\\n        const current = stack.shift();\\n\\n        if(Array.isArray(current)){\\n            stack.unshift(...current);\\n        }else if(Number.isInteger(current)){\\n            yield current;\\n        }\\n    } \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593557,
                "title": "simple-linear-solution-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem involves implementing an `inorderTraversal` generator function that takes an array as input and yields its elements in an `inorder traversal` order. The function should traverse the array, including nested arrays, and yield each encountered element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a generator function `inorderTraversal` that takes an array `arr` as its parameter.\\n2. Initialize a stack variable with an initial value of `[arr]`. The stack will be used to keep track of the elements to be processed.\\n3. Enter a while loop that continues until the stack is empty. This loop will be the core of the generator.\\n4. Inside the loop, retrieve the top element from the stack. This element represents the current item to be processed.\\n5. Check if `poped element` is not an array. If it is not an array, yield `poped element` using the `yield` keyword and continue to the next iteration of the loop.\\n6. If `element` is an array, iterate over its elements in reverse order using a for loop.\\n7. Inside the loop, push each element to the stack. This ensures that nested arrays are processed in the desired order.\\n8. Once the while loop finishes, the generator function will stop yielding values.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    let stack: MultidimensionalArray = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\n``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    let stack: MultidimensionalArray = [arr];\\n\\n    while(stack.length) {\\n        const ele = stack.pop();\\n        if(!Array.isArray(ele)) {\\n            yield ele;\\n            continue;\\n        }\\n\\n        for(let i = ele.length - 1; i >= 0; i--) {\\n            stack.push(ele[i]);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593552,
                "title": "simple-solution-easy-to-understand-o-n-time-o-d-space",
                "content": "# Complexity\\n- Time complexity: **O(n)** - where **n** is the total number of elements in the input array\\n- Space complexity: **O(d)** - where **d** is the maximum depth of the recursive calls\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593470,
                "title": "day-30-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; ++i) {\\n    Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i];\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; ++i) {\\n    Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i];\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593093,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length;i++){\\n        if(Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length;i++){\\n        if(Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593051,
                "title": "chatgpt-code-snippet",
                "content": "**Intuition:**\\nThe problem asks us to traverse a multi-dimensional array and yield integers in the same order as the inorder traversal. To solve this, we can use a generator function and perform a recursive inorder traversal of the array. \\n\\n**Approach:**\\n1. Define the generator function `inorderTraversal` that takes an array `arr` as the input parameter.\\n2. Iterate over each element `element` in the array `arr` using a `for...of` loop.\\n3. Check if the `element` is an array using the `Array.isArray()` method.\\n    - If it is an array, recursively call the `inorderTraversal` function with `element` as the argument using the `yield*` syntax. This allows us to yield integers in the same order as the inorder traversal of nested arrays.\\n    - If it is not an array (i.e., it\\'s an integer), yield the `element` using the `yield` keyword.\\n4. The generator function will yield integers in the same order as the inorder traversal of the input array.\\n\\n**Complexity Analysis:**\\nThe time complexity of the solution is O(N), where N is the total number of elements in the multi-dimensional array. We need to visit each element once during the inorder traversal.\\n\\nThe space complexity is O(D), where D is the maximum nesting depth of the array. This is the space required for the recursive call stack.\\n\\n**Code:**\\nHere is the complete code implementation:\\n\\n```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (let element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n```\\n\\n**Example Usage:**\\nHere is an example usage of the `inorderTraversal` function:\\n\\n```javascript\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // 1\\nconsole.log(gen.next().value); // 2\\nconsole.log(gen.next().value); // 3\\n```\\n\\nOutput:\\n```\\n1\\n2\\n3\\n```\\n\\nThe generator object correctly yields the integers in the same order as the inorder traversal of the input array.\\n\\nThis solution provides an efficient and concise way to traverse a multi-dimensional array and yield integers in the desired order using a generator function.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (let element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n```\n```javascript\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // 1\\nconsole.log(gen.next().value); // 2\\nconsole.log(gen.next().value); // 3\\n```\n```\\n1\\n2\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592985,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe easy way\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      for (let i = 0; i < arr.length; i++) {\\n    const element = arr[i];\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element); // Recursively traverse nested arrays\\n    } else {\\n      yield element; // Yield integers\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      for (let i = 0; i < arr.length; i++) {\\n    const element = arr[i];\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element); // Recursively traverse nested arrays\\n    } else {\\n      yield element; // Yield integers\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592853,
                "title": "simple-recursive-stack-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            let gen = inorderTraversal(arr[i]);\\n            yield* gen;\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            let gen = inorderTraversal(arr[i]);\\n            yield* gen;\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592795,
                "title": "nested-generator-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should not flatten array, so let\\'s recursively call the function instead\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe would yield integer value, otherwise we would call recursively our function and yield it as an generator\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for(const num of arr) {\\n    if (Array.isArray(num)) {\\n      yield* inorderTraversal(num);\\n    } else {\\n      yield num;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for(const num of arr) {\\n    if (Array.isArray(num)) {\\n      yield* inorderTraversal(num);\\n    } else {\\n      yield num;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592683,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 135 ms, faster than 95.58% of JavaScript online submissions for Nested Array Generator.\\n# Memory Usage: 60.5 MB, less than 96.75% of JavaScript online submissions for Nested Array Generator.\\n\\tvar inorderTraversal = function*(arr) {\\n\\n\\t\\tconst stack = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tcurrent_array = stack.pop();\\n\\n\\t\\t\\tif(Array.isArray(current_array) == false){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 122 ms, faster than 98.19% of TypeScript online submissions for Nested Array Generator.\\n# Memory Usage: 62.6 MB, less than 94.88% of TypeScript online submissions for Nested Array Generator.\\n\\ttype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\tfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n\\t\\tconst stack : MultidimensionalArray[] = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tconst current_array = stack.pop();\\n\\n\\t\\t\\tif(!Array.isArray(current_array)){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index] as MultidimensionalArray);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Stack"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 135 ms, faster than 95.58% of JavaScript online submissions for Nested Array Generator.\\n# Memory Usage: 60.5 MB, less than 96.75% of JavaScript online submissions for Nested Array Generator.\\n\\tvar inorderTraversal = function*(arr) {\\n\\n\\t\\tconst stack = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tcurrent_array = stack.pop();\\n\\n\\t\\t\\tif(Array.isArray(current_array) == false){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 122 ms, faster than 98.19% of TypeScript online submissions for Nested Array Generator.\\n# Memory Usage: 62.6 MB, less than 94.88% of TypeScript online submissions for Nested Array Generator.\\n\\ttype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\tfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n\\t\\tconst stack : MultidimensionalArray[] = [arr];\\n\\n\\t\\twhile(stack.length > 0){\\n\\n\\t\\t\\tconst current_array = stack.pop();\\n\\n\\t\\t\\tif(!Array.isArray(current_array)){\\n\\t\\t\\t\\tyield current_array;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(let index = current_array.length - 1 ; index >= 0 ; index--){\\n\\t\\t\\t\\tstack.push(current_array[index] as MultidimensionalArray);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3592629,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\\n``` javascript []\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\n``` javascript []\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592609,
                "title": "easy-approach-flat-javascript",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592583,
                "title": "nested-generator-function-or-using-flat-array-method",
                "content": "# Using Nested generator Function\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let i = 0;\\n  while (i < arr.length) {\\n    if (typeof arr[i] === \\'object\\') {\\n      yield* inorderTraversal((arr[i] as MultidimensionalArray))\\n    } else {\\n      yield arr[i] as number\\n    }\\n    i++\\n  }\\n\\n};\\n```\\n\\n\\n# Using flat array method\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const newArr:number[] = arr.flat(Infinity);\\n    let i=0;\\n    while(i<newArr.length){\\n        yield newArr[i++]\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let i = 0;\\n  while (i < arr.length) {\\n    if (typeof arr[i] === \\'object\\') {\\n      yield* inorderTraversal((arr[i] as MultidimensionalArray))\\n    } else {\\n      yield arr[i] as number\\n    }\\n    i++\\n  }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592554,
                "title": "easy-js-solution-runtime-beats-90-memory-beats-70",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    const maxNestingDepth = 100000;\\n    const flatArr = arr.flat(maxNestingDepth);\\n\\n    for (const element of flatArr) {\\n        yield element;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    const maxNestingDepth = 100000;\\n    const flatArr = arr.flat(maxNestingDepth);\\n\\n    for (const element of flatArr) {\\n        yield element;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592511,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/9e6c248f-0ca1-47b4-ac1a-627f16cbf19e_1685786482.2844036.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592431,
                "title": "using-typeof-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem description gives all the hints itself: If it\\'s an array, recursively break it down, otherwise yield the item \\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr){\\n        if (typeof item == \"number\"){\\n            yield item;\\n        }\\n        else {\\n            yield* inorderTraversal(item);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const item of arr){\\n        if (typeof item == \"number\"){\\n            yield item;\\n        }\\n        else {\\n            yield* inorderTraversal(item);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592381,
                "title": "typescript-solution",
                "content": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number> {\\n    if (!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for (let element of arr) {\\n        yield* inorderTraversal(element as MultidimensionalArray)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number> {\\n    if (!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for (let element of arr) {\\n        yield* inorderTraversal(element as MultidimensionalArray)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592380,
                "title": "one-liner-with-explanation",
                "content": "# Intuition\\nWe can use the concept of recursion to yield the values in deeper levels. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe iterate over the array, and for each value, if the value is an Array, we yield it\\'s value using the `yeild*` syntax. The `*` here makes it yeild values from a generator. This same kind of task can be achieved less abstactly without using the `yield*` syntax.\\n\\nAn approach of doing the same without `yeild*` syntax is as below.\\n\\n```js\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr){\\n        if(val instanceof Array){\\n            const gen = inorderTraversal(val);\\n            let nxt = gen.next()\\n            while(!nxt.done){\\n                yield nxt.value\\n                nxt = gen.next()\\n            }\\n        }\\n        else yield val;\\n    }\\n};\\n```\\n\\nThis works similar to how `yeild*` would work.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n\\n> One Liner Solution\\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr) (val instanceof Array) ? yield* inorderTraversal(val) : yield val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr){\\n        if(val instanceof Array){\\n            const gen = inorderTraversal(val);\\n            let nxt = gen.next()\\n            while(!nxt.done){\\n                yield nxt.value\\n                nxt = gen.next()\\n            }\\n        }\\n        else yield val;\\n    }\\n};\\n```\n```\\nvar inorderTraversal = function*(arr) {\\n    for(let val of arr) (val instanceof Array) ? yield* inorderTraversal(val) : yield val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592378,
                "title": "yieid-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let ele of arr) {\\n        if(Array.isArray(ele)) {\\n            yield* inorderTraversal(ele);\\n        } else {\\n            yield ele;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let ele of arr) {\\n        if(Array.isArray(ele)) {\\n            yield* inorderTraversal(ele);\\n        } else {\\n            yield ele;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592350,
                "title": "typescript-2-liner-runtime-70-memory-60",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf it is not an array, use the `yield` keyword to yield the value, if it is use the `yield*` to yield a new generator function.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, since function stack is created everytime it calls a new function\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const v of arr) {\\n        if (Array.isArray(v)) yield* inorderTraversal(v);\\n        else yield v;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const v of arr) {\\n        if (Array.isArray(v)) yield* inorderTraversal(v);\\n        else yield v;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592332,
                "title": "day30-simplest-easy-js-beginner-solution",
                "content": "# Intuition\\n\\n**Inorder** :\\n```\\n The inorder traversal means we will travel in the form of\\n        left node   -> node  -> right node\\n\\nhere left node will contain the nested array elements.\\nnode : is the current array element\\nright node : is the element after the  current array element\\nor the elements situated in right of the current element in array,\\n\\n```\\n\\n\\n**Generator Function** :\\n```\\nThe generator function returns a value when an instnce of function is \\ncalled with .next();\\n\\nThe generator function is denoted by *(astrix)  after \\nthe function name\\n\\n        function* CallFunc(){\\n            const val = 10\\n            yield val;\\n        }\\n\\n\\nThe generator function will return a value when it is called \\n\\n        const gen = CallFunc() ;\\n\\n        console.log(gen.next().value)\\n \\nthis will return a value of the gen which is the instant of the \\ngenerator function . \\n```\\n# Approach\\nThe appraoch for the question is simple .\\n- we will traverse the array and for each element we will check \\nis the element we are on is an instance of array or not\\n```\\nfor(const node of arr){\\n        ...function definition \\n}\\n```\\n- if this is the instance of array we will be calling inorder function recursively for that element\\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n}\\n```\\n\\n- else we will yield the current element.\\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n         else yield node\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ n is the no of Elements of array , and we will travel them only once.\\n\\n- Space complexity:\\n $$O(d)$$ d is the depth of nested array , for max d recursive calls will be made .\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    for(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n        else yield node\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n The inorder traversal means we will travel in the form of\\n        left node   -> node  -> right node\\n\\nhere left node will contain the nested array elements.\\nnode : is the current array element\\nright node : is the element after the  current array element\\nor the elements situated in right of the current element in array,\\n\\n```\n```\\nThe generator function returns a value when an instnce of function is \\ncalled with .next();\\n\\nThe generator function is denoted by *(astrix)  after \\nthe function name\\n\\n        function* CallFunc(){\\n            const val = 10\\n            yield val;\\n        }\\n\\n\\nThe generator function will return a value when it is called \\n\\n        const gen = CallFunc() ;\\n\\n        console.log(gen.next().value)\\n \\nthis will return a value of the gen which is the instant of the \\ngenerator function . \\n```\n```\\nfor(const node of arr){\\n        ...function definition \\n}\\n```\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n}\\n```\n```\\nfor(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n         else yield node\\n}\\n```\n```\\nvar inorderTraversal = function*(arr) {\\n    for(const node of arr){\\n        if(Array.isArray(node)) yield* inorderTraversal(node)\\n        else yield node\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592312,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Generator:**\\n- It is created using generator functions, which are declared using `function*` or `function *`.\\n- It\\'s an object which can produce a sequence of values and can be iterated over like an array, also.\\n- In precise terms, it\\'s an object which implements the iterator and the iterable protocols.\\n- As it is a iterator, we can perform following operations:\\n\\n```\\nconst generator = ... // A generator\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\n```\\n\\n**yield:**\\n- In a generator function, the values that are going to be returned when the *next function* is called on it, we use the `yield` keyword.\\n\\n**yield\\\\*:**\\n- Used to yield the values of an other generator, inside our generator. \\n- Like in case of fibonacci sequence using recursion:\\n```\\nfunction* fibonacciGenerator(x = 0, y = 1) {\\n  yield x;   \\n  yield* fibonacciGenerator(y, y + x);\\n}\\n```\\n\\n\\n# Code\\n``` javaScript []\\nvar inorderTraversal = function*(arr) {\\n\\n    for(let i = 0; i < arr.length; ++i){\\n        if(Array.isArray(arr[i]))\\n            yield* inorderTraversal(arr[i]);\\n        else\\n            yield arr[i];\\n    }\\n    \\n};\\n```\\n***\\uD83D\\uDC47\\uD83C\\uDFFC Do Share your Opinion, by voting.***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst generator = ... // A generator\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\ngenerator.next();\\n```\n```\\nfunction* fibonacciGenerator(x = 0, y = 1) {\\n  yield x;   \\n  yield* fibonacciGenerator(y, y + x);\\n}\\n```\n``` javaScript []\\nvar inorderTraversal = function*(arr) {\\n\\n    for(let i = 0; i < arr.length; ++i){\\n        if(Array.isArray(arr[i]))\\n            yield* inorderTraversal(arr[i]);\\n        else\\n            yield arr[i];\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592291,
                "title": "self-explanatory-easy-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for ( const a of arr){\\n        if(Array.isArray(a)) yield* inorderTraversal(a);\\n        else yield a;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for ( const a of arr){\\n        if(Array.isArray(a)) yield* inorderTraversal(a);\\n        else yield a;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592290,
                "title": "simple-one-line-code",
                "content": "```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592175,
                "title": "beginner-friendly-js-solution",
                "content": "> **DISCLAIMER: ** I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nNeed to flatten the array first \\uD83E\\uDD14\\uD83D\\uDE00\\n\\n# Approach\\nCreate a utility function which will take the input array and returns\\nthe flatten array. Once the Array is flattened we can now then loop through it and yield each value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/6ffe09d8-8f50-4272-bf93-dbfabe643c6b_1685779356.3141398.png)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\n// Function to flaten the input array\\nfunction flattenArray(arr){\\nlet finalArray = [];\\nfor(let i=0; i <=arr.length-1; i++){\\n  if(Array.isArray(arr[i])){\\n    finalArray.push(...flattenArray(arr[i]))\\n  }else{\\n    finalArray.push(arr[i])\\n  }\\n}\\nreturn finalArray;\\n}\\n\\nvar inorderTraversal = function*(arr) {\\n\\n  flatArray = flattenArray(arr);\\n  for(let i= 0; i <= flatArray.length-1; i++){\\n       yield flatArray[i];\\n  }\\n \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\n// Function to flaten the input array\\nfunction flattenArray(arr){\\nlet finalArray = [];\\nfor(let i=0; i <=arr.length-1; i++){\\n  if(Array.isArray(arr[i])){\\n    finalArray.push(...flattenArray(arr[i]))\\n  }else{\\n    finalArray.push(arr[i])\\n  }\\n}\\nreturn finalArray;\\n}\\n\\nvar inorderTraversal = function*(arr) {\\n\\n  flatArray = flattenArray(arr);\\n  for(let i= 0; i <= flatArray.length-1; i++){\\n       yield flatArray[i];\\n  }\\n \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592088,
                "title": "easy-solution-o-n",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const e of arr){\\n        if(Array.isArray(e)) yield* inorderTraversal(e);\\n        else yield e;\\n    };\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const e of arr){\\n        if(Array.isArray(e)) yield* inorderTraversal(e);\\n        else yield e;\\n    };\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592069,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592013,
                "title": "day-30-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n     yield* arr.flat(Infinity);\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591960,
                "title": "js-easy-solution-day-30",
                "content": "var inorderTraversal = function*(arr) {\\n    for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  } \\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var inorderTraversal = function*(arr) {\\n    for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  } \\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3591926,
                "title": "js-recrusion-time-190ms-72-space-74mb-49",
                "content": "# Approach\\nWe recursively traverse the nested arrays and use `yield*` to delegate the generator. When we reach a leaf node, we then properly yield.\\n\\n# Complexity\\n- Time complexity:\\nO(n) *, where n is the flattened length of the array*\\n\\n- Space complexity:\\nO(d) *, where d is the maximum depth of the array*\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // recrusively traverse array\\n    if(Array.isArray(arr)) {\\n        for (let i = 0; i < arr.length; i++) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n    }\\n    // yield if leaf node reached\\n    else yield arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // recrusively traverse array\\n    if(Array.isArray(arr)) {\\n        for (let i = 0; i < arr.length; i++) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n    }\\n    // yield if leaf node reached\\n    else yield arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591880,
                "title": "day-30-easy-solution-in-js",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        else yield arr[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        else yield arr[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591830,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n    for(let i= 0;i <arr.length;i++){\\n       yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n    for(let i= 0;i <arr.length;i++){\\n       yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591767,
                "title": "easy-solution-2649-nested-array-generator-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }\\n        else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const n of arr){\\n        if(Array.isArray(n)){\\n            yield* inorderTraversal(n);\\n        }\\n        else{\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591752,
                "title": "true-generator-without-array-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arrays) {\\n    for (const arr of arrays) {\\n        if (typeof arr !== \\'object\\')\\n            yield arr;\\n        else {\\n            const flatterArr = inorderTraversal(arr);\\n            for (const val of flatterArr)\\n                yield val;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arrays) {\\n    for (const arr of arrays) {\\n        if (typeof arr !== \\'object\\')\\n            yield arr;\\n        else {\\n            const flatterArr = inorderTraversal(arr);\\n            for (const val of flatterArr)\\n                yield val;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591639,
                "title": "nested-array-generator-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe inorderTraversal function uses a generator (function*) to yield integers in the same order as an inorder traversal of the multi-dimensional array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const n of arr) {\\n        if (Array.isArray(n)) {\\n            yield* inorderTraversal(n);\\n        } else {\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const n of arr) {\\n        if (Array.isArray(n)) {\\n            yield* inorderTraversal(n);\\n        } else {\\n            yield n;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591547,
                "title": "simple-single-line-solution-using-flat-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFlat Method\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nthe time complexity of the flat() method is O(N), where N is the total number of elements in the array. Since the generator function yields each element of the flattened array once, the overall time complexity of the function is also O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the flat() method is also O(N), since it creates a new flattened array. The generator function does not create any new data structures, so the overall space complexity is also O(N).\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity);\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591528,
                "title": "easy-solution-using-recursive-generators",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let elem of arr) {\\n        if(elem instanceof Array) yield * inorderTraversal(elem);\\n        else yield elem;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let elem of arr) {\\n        if(elem instanceof Array) yield * inorderTraversal(elem);\\n        else yield elem;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591507,
                "title": "javascript-two-liner-begineer-friendly-with-explanation",
                "content": "# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity); // Make flat array\\n    for(x of arr) yield x; // Return each element\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity); // Make flat array\\n    for(x of arr) yield x; // Return each element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591454,
                "title": "simple-explanation-for-beginners-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, let\\'s think about how we would traverse the multi-dimensional array and yield the integers in the same order as an inorder traversal. We can start by using a generator function, which allows us to iterate over the array and process its elements one by one. As we iterate through the array, we\\'ll need to handle two cases: encountering an integer or encountering another sub-array.\\n\\nIf we encounter an integer, we can simply yield it right away. However, if we encounter a sub-array, we\\'ll need to go deeper and recursively apply the same process to that sub-array. This ensures that we explore all levels of the multi-dimensional array and yield integers in the desired order. By using this recursive approach, we can effectively perform an inorder traversal and yield the integers as we encounter them.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a generator function, let\\'s call it inorderTraversal, that takes the multi-dimensional array as input.\\n2. In the generator function, iterate over the elements of the array using a loop.\\n3. For each element encountered: \\n    * If the element is an integer, yield it using the yield keyword.\\n    * If the element is a sub-array, recursively call the inorderTraversal function on that sub-array.\\n4. By using recursion, we can traverse the multi-dimensional array and yield the integers in the same order as an inorder traversal.\\n5. The generator function will continue to yield integers until all elements have been processed.\\n6. Finally, we can create an instance of the generator function with the input array and use the next() method to retrieve the next yielded integer in the inorder traversal.\\n\\nThis approach allows us to traverse the multi-dimensional array in a depth-first manner, ensuring that integers are yielded in the desired order.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    The time complexity of the solution is O(N).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    The space complexity is O(M).\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr \\n * @return {Generator} \\n */\\nvar inorderTraversal = function*(arr) {\\n  // Iterate over each item in the array\\n  for (const item of arr) {\\n    // Check if the item is an array\\n    if (Array.isArray(item)) {\\n      // If it is an array, recursively call the inorderTraversal function on the sub-array\\n      yield* inorderTraversal(item);\\n    } \\n    else {\\n      // If it is an integer, yield the integer\\n      yield item;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * console.log(gen.next().value); // 1\\n * console.log(gen.next().value); // 2\\n * console.log(gen.next().value); // 3\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr \\n * @return {Generator} \\n */\\nvar inorderTraversal = function*(arr) {\\n  // Iterate over each item in the array\\n  for (const item of arr) {\\n    // Check if the item is an array\\n    if (Array.isArray(item)) {\\n      // If it is an array, recursively call the inorderTraversal function on the sub-array\\n      yield* inorderTraversal(item);\\n    } \\n    else {\\n      // If it is an integer, yield the integer\\n      yield item;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * console.log(gen.next().value); // 1\\n * console.log(gen.next().value); // 2\\n * console.log(gen.next().value); // 3\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591446,
                "title": "typescript-easy-to-understand-beats-98-in-space-complexity",
                "content": "# Intuition\\n1. I would like to try the non-recursive solution.\\n2. A stack is needed for the current state.\\n3. Try to handle the array one layer by one layer\\n4. If we see an array, put the current one to the stack\\n\\n# Approach\\n1. Prepare stack and use the input `arr` as the `currentArr`.\\n2. The finding target is: the first item is a number not an array.\\n3. If the first item is array:\\n   1. Put the  `currentArr` into the stack and use the `first` as the `currentArr`.\\n4. Check if we already run out of all items in the `currentArr`. If yes, we need to pop an non-empty array from the stack.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const stack: MultidimensionalArray[] = [];\\n    let currentArr = arr;\\n    while (currentArr.length > 0) {\\n        // take out the first item\\n        const first = currentArr.shift();\\n        // check the type of first item\\n        if (!Array.isArray(first)) {\\n            yield first as number;\\n        } else {\\n            // we need to push the current array to the stack and use the first item as the current array.\\n            stack.push(currentArr);\\n            currentArr = first;\\n        }\\n        // pop the array if we have arrays in the stack.\\n        while (stack.length > 0 && currentArr.length === 0) {\\n            currentArr = stack.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\n![Screen Shot 2023-06-03 at 12.20.46 PM.png](https://assets.leetcode.com/users/images/26e05922-b4be-4e4d-b004-37db9f363a47_1685766403.7755122.png)\\n\\n",
                "solutionTags": [
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const stack: MultidimensionalArray[] = [];\\n    let currentArr = arr;\\n    while (currentArr.length > 0) {\\n        // take out the first item\\n        const first = currentArr.shift();\\n        // check the type of first item\\n        if (!Array.isArray(first)) {\\n            yield first as number;\\n        } else {\\n            // we need to push the current array to the stack and use the first item as the current array.\\n            stack.push(currentArr);\\n            currentArr = first;\\n        }\\n        // pop the array if we have arrays in the stack.\\n        while (stack.length > 0 && currentArr.length === 0) {\\n            currentArr = stack.pop();\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591415,
                "title": "easy-solution-one-line-code-85-beats",
                "content": "# Intuition\\nIt\\'s important to note that the flat() method used in the approach has a time complexity of O(n), where n is the total number of elements in the array. So, if the input array is deeply nested, the overall time complexity could be affected by the flat() operation.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach you provided is a generator function called inorderTraversal, which aims to traverse an array in an inorder manner. It uses the yield keyword to generate each element of the array during iteration.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr.flat(Infinity)) yield i;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr.flat(Infinity)) yield i;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591413,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const o of arr) {\\n        if (Array.isArray(o)) {\\n            yield* inorderTraversal(o)\\n        } else {\\n            yield o\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const o of arr) {\\n        if (Array.isArray(o)) {\\n            yield* inorderTraversal(o)\\n        } else {\\n            yield o\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591411,
                "title": "js-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n        if (Array.isArray(item)) yield* inorderTraversal(item);\\n        else yield item;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (const item of arr) {\\n        if (Array.isArray(item)) yield* inorderTraversal(item);\\n        else yield item;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591405,
                "title": "day-30-30-days-of-lc-javascript-challenge-let-s-discuss",
                "content": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\nThis code defines a function called inorderTraversal that takes an array (arr) as input and returns a generator object.\\n\\nA generator is a special type of function in JavaScript that allows you to define an iterative algorithm by pausing and resuming execution at specific points. Each time the generator\\'s yield keyword is encountered, it returns a value and pauses execution until the next iteration.\\n\\nThe inorderTraversal function uses a recursive approach to perform an inorder traversal of a nested array. In inorder traversal, the elements of a binary tree (in this case, represented by the nested array) are visited in the order of left subtree, root, and right subtree.\\n\\n**Here\\'s a step-by-step explanation of how the code works:**\\n\\n1. The inorderTraversal function is defined with a single parameter (arr), which is the input array.\\n\\n2. Inside the function, a for loop is used to iterate over each element of the arr array.\\n\\n3. Within the loop, an if statement checks if the current element (arr[i]) is an array using the Array.isArray function. If it is an array, it means it represents a subtree, so the yield* keyword is used to delegate the traversal of that subtree to another recursive call of the inorderTraversal function. This allows the function to handle nested arrays and traverse them in an inorder manner.\\n\\n4. If the current element is not an array (i.e., it is a leaf node), the else block is executed. In this case, the yield keyword is used to return the value of the leaf node.\\n\\n5. After the loop finishes, the function execution is complete, and the generator object is returned.\\n\\nTo use the **inorderTraversal** function, you can create an instance of the generator by calling it with an array argument. The returned generator object can then be used to iterate over the values of the array in an inorder traversal.\\n\\nIn the example code at the bottom, the inorderTraversal function is called with the array [1, [2, 3]], and the returned generator object is stored in the variable gen.\\n\\nTo access the values returned by the generator, you can use the next() method on the generator object. Each call to gen.next().value will return the next value in the inorder traversal sequence. In this case, the values returned will be 1, 2, and 3, respectively, as specified in the comments.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    \\n  for (let i = 0; i < arr.length; i++){\\n        \\n      if (Array.isArray(arr[i]))yield* inorderTraversal(arr[i])\\n        \\n      else yield arr[i]\\n        \\n    }  \\n};\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591394,
                "title": "recursive-inorder-traversal-generator-for-multi-dimensional-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to perform an inorder traversal on a multi-dimensional array and yield the integers encountered in the same order. We can approach this problem recursively by iterating over the elements of the array. If an element is an array, I recursively call the `inorderTraversal` function on it. If an element is an integer, I yield it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define the `inorderTraversal` function that takes an array as input and returns a generator object.\\n2. Iterate over each element of the array using a for loop.\\n3. If the current element is an array, recursively cakk the `inorderTraversal` function on it using the yield* syntax.\\n4. If the current element is an integer, yield it using the yield keyword.\\n5. Test the function by creating an array and initializing the generator object. Use the `next()` method on the generator to retrieve the next yielded value.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the total number of integers in the multi-dimensional array. I need to iterate over each element of the array to yield the integers.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m), where m is the maximum nesting depth of the multi-dimensional array. The recursive function calls and generator object require additional space proportional to the nesting depth of the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        } else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591365,
                "title": "nested-array-generator-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr - The input array.\\n * @return {Generator} - A generator for inorder traversal of the array.\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      yield* inorderTraversal(arr[i]); // Recursively yield elements of nested arrays\\n    } else {\\n      yield arr[i]; // Yield individual elements\\n    }\\n  }\\n};\\n\\n// Example usage:\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // Output: 1\\nconsole.log(gen.next().value); // Output: 2\\nconsole.log(gen.next().value); // Output: 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr - The input array.\\n * @return {Generator} - A generator for inorder traversal of the array.\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      yield* inorderTraversal(arr[i]); // Recursively yield elements of nested arrays\\n    } else {\\n      yield arr[i]; // Yield individual elements\\n    }\\n  }\\n};\\n\\n// Example usage:\\nconst gen = inorderTraversal([1, [2, 3]]);\\nconsole.log(gen.next().value); // Output: 1\\nconsole.log(gen.next().value); // Output: 2\\nconsole.log(gen.next().value); // Output: 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591308,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction func(arr){\\n    let newArr = [];\\n    let i = 0;\\n    while(i<arr.length){\\n        if(Array.isArray(arr[i])){\\n            newArr.push(...func(arr[i]));\\n        }\\n        else{\\n            newArr.push(arr[i]);\\n        }\\n        i++;\\n    }\\n    return newArr;\\n} \\nvar inorderTraversal = function*(arr) {\\n    newArr = func(arr);\\n    // console.log(newArr);\\n    let i = 0;\\n    while(i<newArr.length){\\n        yield newArr[i];\\n        i++;\\n    }\\n};\\n/*\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n*/\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction func(arr){\\n    let newArr = [];\\n    let i = 0;\\n    while(i<arr.length){\\n        if(Array.isArray(arr[i])){\\n            newArr.push(...func(arr[i]));\\n        }\\n        else{\\n            newArr.push(arr[i]);\\n        }\\n        i++;\\n    }\\n    return newArr;\\n} \\nvar inorderTraversal = function*(arr) {\\n    newArr = func(arr);\\n    // console.log(newArr);\\n    let i = 0;\\n    while(i<newArr.length){\\n        yield newArr[i];\\n        i++;\\n    }\\n};\\n/*\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n*/\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591301,
                "title": "easy-solution-with-flattened-array",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // .flat(Infinity) will flatten an array of any depth\\n    // .reverse() allows us to use pop() to get the next value instead of .unshift() for a performance boost\\n    const flatArray = arr.flat(Infinity).reverse();\\n\\n    // As long as flatArray has values, we can keep yielding results\\n    while(flatArray.length) {\\n        yield flatArray.pop();\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    // .flat(Infinity) will flatten an array of any depth\\n    // .reverse() allows us to use pop() to get the next value instead of .unshift() for a performance boost\\n    const flatArray = arr.flat(Infinity).reverse();\\n\\n    // As long as flatArray has values, we can keep yielding results\\n    while(flatArray.length) {\\n        yield flatArray.pop();\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591282,
                "title": "typescript-solution-using-recursive-generator-call",
                "content": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (let i = 0 ; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const gen = inorderTraversal(arr[i] as MultidimensionalArray);\\n      while (true) {\\n        const next = gen.next();\\n        if (next.done) break;\\n        yield next!.value as number;\\n      }\\n    }\\n    else yield arr[i] as number;\\n  }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (let i = 0 ; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const gen = inorderTraversal(arr[i] as MultidimensionalArray);\\n      while (true) {\\n        const next = gen.next();\\n        if (next.done) break;\\n        yield next!.value as number;\\n      }\\n    }\\n    else yield arr[i] as number;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591266,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }\\n        else{\\n            yield element;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(const element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }\\n        else{\\n            yield element;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591182,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(Array.isArray(arr)){\\n        for(const x of arr){\\n            yield* inorderTraversal(x);\\n        }\\n    }\\n    else{\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(Array.isArray(arr)){\\n        for(const x of arr){\\n            yield* inorderTraversal(x);\\n        }\\n    }\\n    else{\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591171,
                "title": "javascript-stack-but-different",
                "content": "# Intuition\\nWhen we finish processing a sub-array, we need to know which array to return to (the parent array), and the index where the sub-array was found. With that we can continue processing the parent.\\n\\nIf we use an object we can store the index and the array. Since the array property will just be a reference/pointer to the array we can avoid any copying of the data.\\n\\nSub-arrays can be nested so we need to store the parent information in a Last In First Out (LIFO) data structure, like a stack.\\n\\n# Approach\\n- Create an object that represents the array we are currently processing and which index we are on. \\n- Use a standard array for our stack.\\n- Continue processing as long as we are not at the end of the current array, or if we are but there is another array waiting to be popped off the stack.\\n- If we are at the end of the current array, pop the stack to return to the parent array.\\n- If the current element is an array, push the current array on to the stack and then set the new current array to be this sub-array element.\\n- If the current element is not an array just yield it.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let curArr = {array: arr, index: 0};\\n    let stack = [];\\n\\n    while (curArr.index < curArr.array.length || stack.length > 0){\\n        if (curArr.index === curArr.array.length) {\\n            curArr = stack.pop();\\n            curArr.index++;\\n            continue;            \\n        }\\n        if (Array.isArray(curArr.array[curArr.index])){\\n            stack.push(curArr);\\n            curArr = {array: curArr.array[curArr.index], index: 0};\\n        }\\n        else {\\n            yield curArr.array[curArr.index];\\n            curArr.index++;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let curArr = {array: arr, index: 0};\\n    let stack = [];\\n\\n    while (curArr.index < curArr.array.length || stack.length > 0){\\n        if (curArr.index === curArr.array.length) {\\n            curArr = stack.pop();\\n            curArr.index++;\\n            continue;            \\n        }\\n        if (Array.isArray(curArr.array[curArr.index])){\\n            stack.push(curArr);\\n            curArr = {array: curArr.array[curArr.index], index: 0};\\n        }\\n        else {\\n            yield curArr.array[curArr.index];\\n            curArr.index++;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591148,
                "title": "easy-approach-flatten-then-loop",
                "content": "# Intuition\\n- Flatten the array first, then loop through the new flatten array\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nconst flattenArr = (arr) => {\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++) {\\n        if(Array.isArray(arr[i])) {\\n            res = [...res, ...flattenArr(arr[i])]\\n        }\\n        else res.push(arr[i])\\n    }\\n    return res\\n}\\n    \\nvar inorderTraversal = function*(arr) {\\n    const newArr = flattenArr(arr)\\n    for(let i = 0; i < newArr.length; i++) {\\n        yield(newArr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nconst flattenArr = (arr) => {\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++) {\\n        if(Array.isArray(arr[i])) {\\n            res = [...res, ...flattenArr(arr[i])]\\n        }\\n        else res.push(arr[i])\\n    }\\n    return res\\n}\\n    \\nvar inorderTraversal = function*(arr) {\\n    const newArr = flattenArr(arr)\\n    for(let i = 0; i < newArr.length; i++) {\\n        yield(newArr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591122,
                "title": "javascript-and-typescript-with-explanation",
                "content": "\\n- The code provided defines a type MultidimensionalArray as an array that can contain either numbers or nested arrays of numbers. The inorderTraversal function is a generator function that takes a MultidimensionalArray as input and yields its elements in an inorder traversal.\\n- The function takes an array arr of type **MultidimensionalArray** as input.\\n- The array arr is flattened using the $$flat$$ method with **Infinity** depth. This converts any nested arrays into a single-dimensional array.\\n- A variable n is initialized to 0, which will be used as an index to iterate over the elements of the flattened array.\\n- The generator function enters a while loop that continues as long as **temp[n] or temp[n] == 0** is truthy. This allows the function to handle elements that are explicitly set to 0.\\n- Within each iteration of the loop, the current element **temp[n]** is yielded using the $$yield$$ keyword.\\n- The index **n** is incremented to move to the next element in the array.\\n- The loop continues until there are no more elements in the array, at which point the generator function terminates.\\n\\n`typescript`\\n```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\n---\\n- The $$inorderTraversal$$ function takes an array $$arr$$ as input.\\n- Inside the function, a **for...of** loop is used to iterate over each element of the arr array.\\n- For each element, it checks if it is an array using the **Array.isArray** function.\\n- If the element is an array, it recursively calls the $$inorderTraversal$$ function passing the nested array as the argument, using the $$yield*$$ syntax to yield the values from the recursive generator.\\n- If the element is not an array, it is a leaf node, and the element itself is yielded using the $$yield$$ keyword.\\n- The generator function continues iterating over the elements of the **arr** array, yielding values in an inorder traversal.\\n- When there are no more elements to traverse, the generator function terminates.\\n\\n`Javascript`\\n```javascript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```\n```javascript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n\\n    let temp:number[] = arr.flat(Infinity)\\n    let n:number = 0\\n\\n    while(temp[n] || temp[n] == 0){\\n        yield temp[n]\\n        n++;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591095,
                "title": "javascript-yeild",
                "content": "The yield* expression is used to delegate to another generator or iterable object.\\nThe yield* expression iterates over the operand and yields each value returned by it.\\nyield* is a way to yield all values from another generator (or any iterable) in the middle of your generator. \\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++){\\n        if (Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        }else{\\n            yield arr[i]\\n        }\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The yield* expression is used to delegate to another generator or iterable object.\\nThe yield* expression iterates over the operand and yields each value returned by it.\\nyield* is a way to yield all values from another generator (or any iterable) in the middle of your generator. \\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0; i < arr.length; i++){\\n        if (Array.isArray(arr[i])){\\n            yield* inorderTraversal(arr[i])\\n        }else{\\n            yield arr[i]\\n        }\\n    }\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3591085,
                "title": "stack-approach",
                "content": "In-order traversal is a method used to traverse or visit each node in a binary tree or, in this case, a multi-dimensional array, in a left to right order.\\n\\nFor a multi-dimensional array, in-order traversal can be understood as visiting each element of the array in a left-to-right manner\\n\\nThe in-order traversal of the multi-dimensional array means visiting each element of the array, including both integers and sub-arrays, from left to right and top to bottom, yielding any encountered integers and applying the in-order traversal to any encountered sub-arrays.\\n\\n### Iterative approach\\n\\nUse a `stack` to keep track of the elements of the multi-dimensional array that we need to process. We start by pushing the root array onto the stack.\\n\\nDuring each iteration of the **`while`** loop, we pop an element from the stack. \\n\\n- If the popped element is an integer, we yield it.\\n- If it is an array, we iterate over its elements in reverse order and push them onto the stack. This ensures that we process the elements in the same order as an `inorder` traversal.\\n\\nThe loop continues until the stack is empty, yielding integers in the desired order.\\n\\n### Time Complexity: O(n + m)\\n\\n### Space Complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while(stack.length) {\\n        const current = stack.pop()\\n        if(!Array.isArray(current)){\\n            yield current\\n        }else{\\n            for(let i = current.length - 1; i >= 0; i--) stack.push(current[i])\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while(stack.length) {\\n        const current = stack.pop()\\n        if(!Array.isArray(current)){\\n            yield current\\n        }else{\\n            for(let i = current.length - 1; i >= 0; i--) stack.push(current[i])\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591084,
                "title": "2649-nested-array-generator-level-up-your-js-skills-day-30-with-2-different-approach",
                "content": "# **Approach 1: Recursive Solution**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe nested arrays can be processed and their elements retrieved by employing a recursive generator.\\n# Algorithm\\n- Non-array elements are treated as integers, and the generator function yields them to the caller.\\n- The yield statement in the generator function allows pausing its execution and providing the yielded value to the caller.\\n- Resuming the generator function from where it left off continues the loop and further traverses the array.\\n- When encountering a nested array, a for loop iterates over its elements using the index ```i```.\\n- To handle the nested array condition, the generator function recursively invokes ```yield* inorderTraversal(arr[i])```.\\n- The recursive call ensures that the nested array is also traversed in an inorder manner.\\n- Using ```yield*``` delegates to another Generator (recursive call) and returns the value when it is closed.\\n- The generator yields integers in the order they are encountered during the traversal.\\n\\n# Implementation:\\n\\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)){\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0;i<arr.length; i++)\\n        yield* inorderTraversal(arr[i]);\\n};\\n```\\n```TypeScript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\\n\\n---\\n\\n# Complexity Analysis:\\n\\n**Time complexity:** O($$N$$), where $$N$$ is the total number of elements in the array.\\n\\n**Space complexity:** O($$D$$), where $$D$$ is the depth of the recursion call.\\n\\n\\n---\\n---\\n\\n# **Approach 2: Using Flat Method**\\n\\n# **Intuition:**\\n\\nHave you ever wondered why it is possible to use ```yield*``` with an array? Let\\'s take a moment to ponder the mechanics behind ```yield*``` and ```arrays (iterables)``` that allow them to seamlessly work together. If you haven\\'t given it much thought, let\\'s explore this concept further.\\n\\n- ```Yield*``` works with arrays because arrays in JavaScript are iterable objects.\\n- Iterables implement the iterable protocol, which involves having a method called ```Symbol.iterator()``` that returns an iterator object.\\n- The iterator object is responsible for sequentially producing the values of the iterable.\\n- When a generator uses ```yield*``` with an array, it delegates the iteration control to the array\\'s iterator.\\n- The generator pauses its execution and yields values generated by iterating over the array\\'s iterator.\\n- After the array has been fully iterated, the generator resumes execution.\\n- This mechanism establishes a standardized approach for iterating over different iterable objects.\\n- It enables generators to handle various types of iterables, including arrays, without requiring explicit handling for each type.\\n\\n# **Algorithm:**\\nWe can use a built-in function ```flat()``` to get flat array with param ```Infinity``` to flatten all levels.\\n\\n# Implementation:\\n\\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n```\\n```TypeScript []\\n\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  yield* (arr.flat(Infinity) as unknown as Generator<number, void, unknown>);\\n}\\n```\\n\\n---\\n\\n# **Complexity Analysis:**\\n**Time complexity:** The time complexity of the ```flat()``` method is O($$N$$), where $$N$$ is the total number of elements in the array. Since the generator function yields each element of the flattened array once, the overall time complexity of the function is also O($$N$$).\\n\\n**Space complexity:** The space complexity of the ```flat()``` method is also O($$N$$), since it creates a new flattened array. The generator function does not create any new data structures, so the overall space complexity is also O($$N$$).\\n\\n---\\n```\\n\\n\\nPlease Upvote if u like the solution\\uD83D\\uDC4D!!!\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```i```\n```yield* inorderTraversal(arr[i])```\n```yield*```\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if(!Array.isArray(arr)){\\n        yield arr;\\n        return;\\n    }\\n\\n    for(let i = 0;i<arr.length; i++)\\n        yield* inorderTraversal(arr[i]);\\n};\\n```\n```TypeScript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  if (!Array.isArray(arr)) {\\n    yield arr;\\n    return;\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    yield* inorderTraversal(arr[i] as MultidimensionalArray);\\n  }\\n}\\n```\n```yield*```\n```yield*```\n```arrays (iterables)```\n```Yield*```\n```Symbol.iterator()```\n```yield*```\n```flat()```\n```Infinity```\n```javascript []\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  yield* arr.flat(Infinity);\\n};\\n```\n```TypeScript []\\n\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  yield* (arr.flat(Infinity) as unknown as Generator<number, void, unknown>);\\n}\\n```\n```flat()```\n```flat()```\n```\\n\\n\\nPlease Upvote if u like the solution\\uD83D\\uDC4D!!!\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591051,
                "title": "js-easy-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!(arr instanceof Array)) {\\n        yield arr\\n        return\\n    }\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!(arr instanceof Array)) {\\n        yield arr\\n        return\\n    }\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591039,
                "title": "nested-array-generator",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function* (arr) {\\n  // checking if arr is an array\\n  if (Array.isArray(arr)) {\\n    // iterateing over each element \\n    for (let i = 0; i < arr.length; i++) {\\n      // recursively yield elements from sub-array\\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    // base case\\n    yield arr;\\n  }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\n\\nvar inorderTraversal = function* (arr) {\\n  // checking if arr is an array\\n  if (Array.isArray(arr)) {\\n    // iterateing over each element \\n    for (let i = 0; i < arr.length; i++) {\\n      // recursively yield elements from sub-array\\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    // base case\\n    yield arr;\\n  }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591008,
                "title": "day-30-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    if(!Array.isArray(arr)) {\\n        yield arr\\n        return\\n    }\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i])\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586598,
                "title": "solution-using-recursion",
                "content": "# Intuition\\nCheck if the parameter \\'arr\\' is an array. If it is an array, iterate over the array and call the function inorderTraversal recursively by passing the current array element.\\n\\nIf it is not an array, simple return arr.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n    } else {\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n        yield* inorderTraversal(arr[i]);\\n    }\\n    } else {\\n        yield arr;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585052,
                "title": "simple-easy-2-lines-full-simple-explanation",
                "content": "# Approach\\n- In order to return values in subarrays, we need to recursively call the ```inorderTraversal``` function. We can\\'t just yield the result of the recursive call on a generator function as one would usually return the result of a non-generator recursive call. We need to be able to yield in the recursive call as one would in the main call.\\n- This can be solved with ```yield*```, which essentially allows us to call on a generator function, and yield each result as one would want to do. In this case, it means yielding each time we reach the next value.\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    for (val of arr) {\\n        // if val is array, make recursive call. Else, yield val\\n        if (Array.isArray(val)) yield* inorderTraversal(val)\\n        else yield val;\\n    }\\n};\\n```\\n\\n# Some JavaScript stuff: yield\\nIf you don\\'t know what the ```yield``` keyword does in JavaScript, this section might help.\\n\\nGenerator functions (indicated by the ```*``` in ```function*()```) is a function that allows you to iterate throughout code in a function to return different values by calling the same function. While this can be done with regular functions, the conveinent thing with generator functions is they allow you to use the keyword ```yield```, which allows you to stop in the middle of the code and return a value, then when you come back to the function with another call, you pick up where you left off. We can do this using the ```.next().value``` method call, which generator functions automatically have.\\n\\n\\u2014\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```inorderTraversal```\n```yield*```\n```\\nvar inorderTraversal = function*(arr) {\\n    for (val of arr) {\\n        // if val is array, make recursive call. Else, yield val\\n        if (Array.isArray(val)) yield* inorderTraversal(val)\\n        else yield val;\\n    }\\n};\\n```\n```yield```\n```*```\n```function*()```\n```yield```\n```.next().value```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567768,
                "title": "a-simple-dfs-solution",
                "content": "# Intuition\\nSimple Solution with Of DFS.\\n\\n# Complexity\\n- Time complexity:\\n<!-- $$O(arr.flat().length)$$ -->\\n\\n- Space complexity:\\n<!-- $$O(deepth)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    var stk = [], i = 0, curr = arr, len = arr.length;\\n    while (stk.length || i < len) {\\n        while (stk.length && i === len) {\\n            var preLv = stk.pop();\\n            curr = preLv.arr;\\n            len = curr.length;\\n            i = preLv.nxt;\\n        }\\n        if(i===len) return;        \\n        var c = curr[i];\\n        if (c instanceof Array) {\\n            stk.push({arr: curr, nxt: ++i});\\n            curr = c;\\n            len = c.length;\\n            i = 0;\\n        } else {\\n            yield c;\\n            i++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function* (arr) {\\n    var stk = [], i = 0, curr = arr, len = arr.length;\\n    while (stk.length || i < len) {\\n        while (stk.length && i === len) {\\n            var preLv = stk.pop();\\n            curr = preLv.arr;\\n            len = curr.length;\\n            i = preLv.nxt;\\n        }\\n        if(i===len) return;        \\n        var c = curr[i];\\n        if (c instanceof Array) {\\n            stk.push({arr: curr, nxt: ++i});\\n            curr = c;\\n            len = c.length;\\n            i = 0;\\n        } else {\\n            yield c;\\n            i++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548928,
                "title": "nested-array-generator-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if (Array.isArray(i)) yield *inorderTraversal(i)\\n        else yield i\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if (Array.isArray(i)) yield *inorderTraversal(i)\\n        else yield i\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546707,
                "title": "javascript-easy-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n    let newArr = [], len = arr.length;\\n    for(let i = len-1; i >= 0; i--) {\\n        newArr.push(arr[i]);\\n    }\\n    while(len) {\\n        yield newArr.pop();\\n        len--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr = arr.flat(Infinity);\\n    let newArr = [], len = arr.length;\\n    for(let i = len-1; i >= 0; i--) {\\n        newArr.push(arr[i]);\\n    }\\n    while(len) {\\n        yield newArr.pop();\\n        len--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536816,
                "title": "stack-solution",
                "content": "**Time complexity:**\\n*~O(n)\\nn - arr.flat().length*\\n\\n**Space complexity:**\\n*O(n)\\nn - arr.flat().length*\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while (stack.length > 0) {\\n        const curr = stack.pop();\\n\\n        if (Array.isArray(curr)) {\\n            for (let i = curr.length - 1; i >= 0; i--) {\\n                stack.push(curr[i])\\n            }\\n        } else {\\n            yield curr;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [arr]\\n    while (stack.length > 0) {\\n        const curr = stack.pop();\\n\\n        if (Array.isArray(curr)) {\\n            for (let i = curr.length - 1; i >= 0; i--) {\\n                stack.push(curr[i])\\n            }\\n        } else {\\n            yield curr;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530675,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let temp:number[] = arr.flat(Infinity)\\n  let i:number = 0;\\n   while(temp[i] || temp[i] == 0 ){\\n   yield temp[i];\\n   i++;\\n  \\n  }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  let temp:number[] = arr.flat(Infinity)\\n  let i:number = 0;\\n   while(temp[i] || temp[i] == 0 ){\\n   yield temp[i];\\n   i++;\\n  \\n  }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526609,
                "title": "recursive-generator-with-yield",
                "content": "# Intuition\\nIn this case, the solution involves performing an inorder traversal on the multi-dimensional array, which means visiting the elements in the array in a specific order.\\n\\n# Approach\\nThe provided code implements a generator function called inorderTraversal that performs the inorder traversal on the multi-dimensional array. Here\\'s a step-by-step explanation of how the code works:\\n1. The function receives the multi-dimensional array as input: arr.\\n\\n2. The arr.entries() method is used to obtain an iterator over the entries of the array. Each entry is a key-value pair, where the key is the index of the element and the value is the element itself.\\n\\n3. The nextElementItx variable is assigned the result of calling arrItx.next(). This retrieves the next element from the iterator.\\n\\n4. A while loop is used to iterate over the elements of the array until there are no more elements to process.\\n\\n5. Inside the loop, the code checks if the current element is an array using Array.isArray(). If it is an array, it means we need to perform an inorder traversal on it. In this case, the yield* syntax is used to delegate the traversal of the sub-array to the same generator function (inorderTraversal), allowing for recursion. This ensures that all the elements within the sub-array are processed in the correct order.\\n\\n6. If the current element is not an array, it means it is an integer. In this case, the code uses the yield keyword to yield the integer value.\\n\\n7. Finally, the nextElementItx variable is updated by calling arrItx.next() to retrieve the next element from the iterator.\\n\\n8. The loop continues until there are no more elements to process, at which point the generator function finishes.\\n\\n# Complexity\\nThe time complexity of this solution depends on the number of elements in the multi-dimensional array. If we denote the total number of elements as n and the maximum depth of nesting as m, the time complexity can be expressed as O(m * log(n)). This is because each level of nesting requires a recursive call, and the depth of recursion is at most m. Additionally, the log(n) factor accounts for the traversal of each element in the array. The space complexity is O(n) because the generator function yields the elements one by one without storing all of them in memory at once.\\n\\nOverall, the provided code effectively performs an inorder traversal on a multi-dimensional array and yields the integers in the same order.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let arrItx = arr.entries();\\n    let nextElementItx = arrItx.next();\\n    while (nextElementItx.value){\\n        if (Array.isArray(nextElementItx.value[1])) {\\n            yield* inorderTraversal(nextElementItx.value[1]);\\n        } else {\\n          yield nextElementItx.value[1];\\n        }\\n      nextElementItx = arrItx.next();\\n    }    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let arrItx = arr.entries();\\n    let nextElementItx = arrItx.next();\\n    while (nextElementItx.value){\\n        if (Array.isArray(nextElementItx.value[1])) {\\n            yield* inorderTraversal(nextElementItx.value[1]);\\n        } else {\\n          yield nextElementItx.value[1];\\n        }\\n      nextElementItx = arrItx.next();\\n    }    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519915,
                "title": "antarnab-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let element of arr){\\n        if(Array.isArray(element)){\\n            yield*inorderTraversal(element);\\n        }else{\\n            yield element;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519538,
                "title": "2-lines-solution-flat-method-typescript",
                "content": "\\n# Approach\\nwe use **flat** method to flatten the multidimentional array into a single dim array.\\n\\n\\n# Code\\n```\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n let x = arr.flat(Infinity);\\n for(let element of x) yield element;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n let x = arr.flat(Infinity);\\n for(let element of x) yield element;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516736,
                "title": "stack-no-recursion",
                "content": "# Intuition\\nNo recursion, just stack\\n\\n# Approach\\nWe store in stack current array and index\\nIf we find subArray we add one level to stack\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let st = [{\\n        pos: 0,\\n        arr: arr,\\n    }];\\n\\n    while (true) {\\n        if (st.length == 0) {\\n            return;\\n        };\\n        if (st.at(-1).pos >= st.at(-1).arr.length ) {\\n            st.pop();\\n            continue;\\n        }\\n        if (st.at(-1).arr[st.at(-1).pos] instanceof Array) {\\n            st.push({\\n                pos: 0,\\n                arr: st.at(-1).arr[st.at(-1).pos],\\n            });\\n            st.at(-2).pos++;\\n        } else {\\n            yield st.at(-1).arr[st.at(-1).pos];\\n            st.at(-1).pos++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let st = [{\\n        pos: 0,\\n        arr: arr,\\n    }];\\n\\n    while (true) {\\n        if (st.length == 0) {\\n            return;\\n        };\\n        if (st.at(-1).pos >= st.at(-1).arr.length ) {\\n            st.pop();\\n            continue;\\n        }\\n        if (st.at(-1).arr[st.at(-1).pos] instanceof Array) {\\n            st.push({\\n                pos: 0,\\n                arr: st.at(-1).arr[st.at(-1).pos],\\n            });\\n            st.at(-2).pos++;\\n        } else {\\n            yield st.at(-1).arr[st.at(-1).pos];\\n            st.at(-1).pos++;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503693,
                "title": "ts-recursive-solution",
                "content": "# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nconst isArray = (item: unknown): item is MultidimensionalArray => Array.isArray(item);\\nconst isNumber = (item: unknown): item is number => typeof item === \\'number\\';\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (isArray(item)) yield* inorderTraversal(item);\\n    if (isNumber(item)) yield item;\\n  }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nconst isArray = (item: unknown): item is MultidimensionalArray => Array.isArray(item);\\nconst isNumber = (item: unknown): item is number => typeof item === \\'number\\';\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (isArray(item)) yield* inorderTraversal(item);\\n    if (isNumber(item)) yield item;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499169,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let temp = arr.flat(Infinity);\\n    for(let i=0;i<temp.length;i++){\\n        yield temp[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let temp = arr.flat(Infinity);\\n    for(let i=0;i<temp.length;i++){\\n        yield temp[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497217,
                "title": "clean-solution-with-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack=[arr]\\n    while(stack.length){\\n        let item=stack.pop()\\n        if(Array.isArray(item)){\\n            item.reverse()\\n            stack.push(...item)\\n        }\\n        else{\\n            yield item;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let stack=[arr]\\n    while(stack.length){\\n        let item=stack.pop()\\n        if(Array.isArray(item)){\\n            item.reverse()\\n            stack.push(...item)\\n        }\\n        else{\\n            yield item;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496741,
                "title": "no-yield-treat-input-array-as-a-stack",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr.reverse();\\n    while (arr.length > 0) {\\n        while ((Array.isArray(arr[-1]) && (arr[-1].length === 0))) {\\n            arr.pop();\\n        }\\n        top = arr.pop();\\n        if (!Array.isArray(top)) {\\n            yield top;\\n        }\\n        else {\\n            top.reverse()\\n            arr.push(...top);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    arr.reverse();\\n    while (arr.length > 0) {\\n        while ((Array.isArray(arr[-1]) && (arr[-1].length === 0))) {\\n            arr.pop();\\n        }\\n        top = arr.pop();\\n        if (!Array.isArray(top)) {\\n            yield top;\\n        }\\n        else {\\n            top.reverse()\\n            arr.push(...top);\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486204,
                "title": "done-the-hard-way-without-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length; i++){\\n        if(Array.isArray(arr[i])){\\n            let gen = inorderTraversal(arr[i]);\\n            let tobeCalled = true;\\n            while(tobeCalled){\\n                let nextgen = gen.next();\\n                if(nextgen && !nextgen.done)\\n                yield nextgen.value;\\n                else{\\n                    tobeCalled = false;\\n                }\\n            }\\n        }else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0; i<arr.length; i++){\\n        if(Array.isArray(arr[i])){\\n            let gen = inorderTraversal(arr[i]);\\n            let tobeCalled = true;\\n            while(tobeCalled){\\n                let nextgen = gen.next();\\n                if(nextgen && !nextgen.done)\\n                yield nextgen.value;\\n                else{\\n                    tobeCalled = false;\\n                }\\n            }\\n        }else{\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486155,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nfunction* inorderTraversal(arr) {\\n  for (const element of arr) {\\n    if (Array.isArray(element)) {\\n      yield* inorderTraversal(element);\\n    } else {\\n      yield element;\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486131,
                "title": "simplest-solution-using-arr-flat-infinity-function",
                "content": "# Approach\\nFlatten the array to Infinity levels using ```arr.flat(Infinity)```\\n\\nThen keep traversing and keep doing yield of each value\\n\\n\\n\\n# Code\\n```\\nvar inorderTraversal = function*(arr) {\\n    const arr1=arr.flat(Infinity);\\n    for(let i=0;i<arr1.length;i++){\\n        yield arr1[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```arr.flat(Infinity)```\n```\\nvar inorderTraversal = function*(arr) {\\n    const arr1=arr.flat(Infinity);\\n    for(let i=0;i<arr1.length;i++){\\n        yield arr1[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485732,
                "title": "typescript-recursion",
                "content": "# Intuition\\nTo solve this problem, we can use a generator function that performs a recursive traversal of the input multidimensional array. This will allow us to yield each integer encountered during the traversal in the same order as an inorder traversal.\\n\\n# Approach\\n1. Create a generator function called `inorderTraversal` that takes a multidimensional array as input.\\n2. Iterate through the elements of the input array.\\n3. If the current element is an array, call `inorderTraversal` recursively on the array and use the `yield*` keyword to yield the results of the recursive call.\\n4. If the current element is a number, yield it.\\n\\nBy following this approach, we ensure that the generator function yields integers in the order they are encountered during an inorder traversal of the input multidimensional array.\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the total number of elements in the flattened input array. This is because we visit each element exactly once during the traversal.\\n- Space complexity: $$O(d)$$, where $$d$$ is the maximum depth of the nested input array. This is because the maximum depth of the recursion determines the maximum amount of space required on the call stack.\\n\\n# Code\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n  for (const item of arr) {\\n    if (Array.isArray(item)) {\\n      yield* inorderTraversal(item);\\n    } else {\\n      yield item;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483591,
                "title": "inordertraversal-generator-using-for-loop-with-yield-keyoword",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n// recursivly doing the function why because our value is 6 first time running [[6]] and second time [6] third time 6 after that return the value through the yield keyword... \\n// [ [ [ 6 ] ]\\n// [ [ 6 ] ]\\n// [ 6 ]\\n// 6 \\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    yield arr;\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n      if (Array.isArray(arr)) {\\n    for (let i = 0; i < arr.length; i++) {\\n// recursivly doing the function why because our value is 6 first time running [[6]] and second time [6] third time 6 after that return the value through the yield keyword... \\n// [ [ [ 6 ] ]\\n// [ [ 6 ] ]\\n// [ 6 ]\\n// 6 \\n      yield* inorderTraversal(arr[i]);\\n    }\\n  } else {\\n    yield arr;\\n  }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483090,
                "title": "easy-solution-to-understand-for-beginners",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i+=1) {\\n        if(Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n        else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i=0;i<arr.length;i+=1) {\\n        if(Array.isArray(arr[i])) {\\n            yield* inorderTraversal(arr[i]);\\n        }\\n        else {\\n            yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470733,
                "title": "1-liner",
                "content": "```\\nvar inorderTraversal = function* f(a)\\n{\\n    for(x of a) Array.isArray(x) ? yield* f(x) : yield x\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar inorderTraversal = function* f(a)\\n{\\n    for(x of a) Array.isArray(x) ? yield* f(x) : yield x\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469105,
                "title": "easy-js-solution-beats-95-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let ans=[];\\n     let traverse=(arr)=>{\\n          for(let i=0;i<arr.length;i++){\\n          if(Array.isArray(arr[i])){\\n            traverse(arr[i]);\\n          }\\n          else{\\n              ans.push(arr[i]);\\n          }\\n      }\\n     }\\n     traverse(arr)\\n     yield* ans;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    let ans=[];\\n     let traverse=(arr)=>{\\n          for(let i=0;i<arr.length;i++){\\n          if(Array.isArray(arr[i])){\\n            traverse(arr[i]);\\n          }\\n          else{\\n              ans.push(arr[i]);\\n          }\\n      }\\n     }\\n     traverse(arr)\\n     yield* ans;\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468355,
                "title": "built-in-recursive-iterative",
                "content": "# Built-in\\n\\nO(n) time\\n0(n) memory\\n\\n```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\\n\\n# Recursive\\n\\nO(n) time\\nO(m) memory (max level of recursion)\\n\\n```js\\nvar inorderTraversal = function*(_arr) {\\n    for (const arr of _arr) {\\n        if (Array.isArray(arr)) {\\n            yield* inorderTraversal(arr);\\n        } else {\\n            yield arr;\\n        }\\n    }\\n};\\n```\\n\\n# Iterative\\n\\nO(n) time\\nO(m) memory (max level of recursion)\\n\\n```js\\nvar inorderTraversal = function*(arr) {\\n    const stack = [[arr, 0]];\\n    while (stack.length) {\\n        let [arr, i] = stack.pop();\\n        for (; i < arr.length; i++) {\\n            if (Array.isArray(arr[i])) {\\n                stack.push([arr, i + 1], [arr[i], 0]);\\n                break;\\n            }\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar inorderTraversal = function*(arr) {\\n    yield* arr.flat(Infinity)\\n};\\n```\n```js\\nvar inorderTraversal = function*(_arr) {\\n    for (const arr of _arr) {\\n        if (Array.isArray(arr)) {\\n            yield* inorderTraversal(arr);\\n        } else {\\n            yield arr;\\n        }\\n    }\\n};\\n```\n```js\\nvar inorderTraversal = function*(arr) {\\n    const stack = [[arr, 0]];\\n    while (stack.length) {\\n        let [arr, i] = stack.pop();\\n        for (; i < arr.length; i++) {\\n            if (Array.isArray(arr[i])) {\\n                stack.push([arr, i + 1], [arr[i], 0]);\\n                break;\\n            }\\n            yield arr[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465964,
                "title": "js-solution-without-flat-function",
                "content": "# Code\\n```\\n\\nfunction oneDimensionalArray(arr,answer){\\n    for (let element of arr){\\n        if (Array.isArray(element)){\\n            oneDimensionalArray(element,answer);\\n        }else {\\n            answer.push(element);\\n        }\\n    }\\n};\\n\\nvar inorderTraversal = function*(arr) {\\n    let answer = [];\\n    oneDimensionalArray(arr,answer);\\n\\n    while (answer.length !== 0){\\n        yield answer.shift();\\n    }\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n\\nfunction oneDimensionalArray(arr,answer){\\n    for (let element of arr){\\n        if (Array.isArray(element)){\\n            oneDimensionalArray(element,answer);\\n        }else {\\n            answer.push(element);\\n        }\\n    }\\n};\\n\\nvar inorderTraversal = function*(arr) {\\n    let answer = [];\\n    oneDimensionalArray(arr,answer);\\n\\n    while (answer.length !== 0){\\n        yield answer.shift();\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3463204,
                "title": "clean-and-easy-to-understand-recursive-solution-with-yield",
                "content": "# Intuition\\n\\nWhat if I recursively traverse it as the usual nested array, but with generator syntax?\\n\\n# Approach\\n\\nThe `yield*` expression iterates over the operand and yields each value it returns. Here it\\'s the same generator function, which we call if the next element is an array.\\n\\nReference: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (const el of arr) {\\n    if (Array.isArray(el)) {\\n      yield* inorderTraversal(el);\\n    } else {\\n      yield el;\\n    }\\n  }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "# Intuition\\n\\nWhat if I recursively traverse it as the usual nested array, but with generator syntax?\\n\\n# Approach\\n\\nThe `yield*` expression iterates over the operand and yields each value it returns. Here it\\'s the same generator function, which we call if the next element is an array.\\n\\nReference: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n  for (const el of arr) {\\n    if (Array.isArray(el)) {\\n      yield* inorderTraversal(el);\\n    } else {\\n      yield el;\\n    }\\n  }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3460727,
                "title": "accepted-javascript",
                "content": "```\\nvar inorderTraversal = function*(arr) {\\n\\n    if (!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n\\n        let gen = inorderTraversal(arr[i]);\\n        var val = gen.next().value;\\n\\n        while (val != null) {\\n            yield val;\\n            val = gen.next().value;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n\\n    if (!Array.isArray(arr)) {\\n        yield arr;\\n        return;\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n\\n        let gen = inorderTraversal(arr[i]);\\n        var val = gen.next().value;\\n\\n        while (val != null) {\\n            yield val;\\n            val = gen.next().value;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458593,
                "title": "the-simplest-for-javascript-typescript-extremely-short-and-elegant",
                "content": "# Approach\\nThe proposed solution is to use a generator function that flattens the nested array in an in-order manner. The function receives a multidimensional array as input, and then uses the `flat()` method to flatten the array in an in-order manner. The `flat()` method is called with the argument `Infinity`, which means that all nested arrays are recursively flattened. Finally, the generator function yields each element of the flattened array using the `yield*` statement.\\n\\n# Complexity\\n- Time complexity: `O(n)`, where `n` is the total number of elements in the nested array. The time complexity of the `flat()` method is `O(n)`, where `n` is the total number of elements in the array. Since the generator function yields each element of the flattened array once, the overall time complexity of the function is also `O(n)`.\\n\\n- Space complexity: `O(n)`, where `n` is the total number of elements in the nested array. The space complexity of the `flat()` method is also `O(n)`, since it creates a new flattened array. The generator function does not create any new data structures, so the overall space complexity is also `O(n)`.\\n\\n# Code\\n```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```\\n```javascript []\\nfunction* inorderTraversal(arr) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript []\\ntype MultidimensionalArray = (MultidimensionalArray | number)[];\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```\n```javascript []\\nfunction* inorderTraversal(arr) {\\n  yield* arr.flat(Infinity);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455397,
                "title": "ts-recursive-approach-80-time-217ms-50-space-74-2mb",
                "content": "Classical recursive data structure problem that we will solve with a recursive parsing - the only novel bit would be to `yield` instead of `return`ing the result.\\n\\nWe will loop through each element `el` in `arr` and:\\n* if it is of type `number`, we will simply `yield` `el`;\\n* alternatively, we will:\\n    * declare `gen` as a new generator calling recursively `inorderTraversal` with `el`;\\n    * declare `tmp` as the result of `gen.next()`;\\n    * loop `while` we are not done (ie: `!tmp.done`) and:\\n        * `yield` `tmp.value` (cast with the `Number` constructor to make TS happy);\\n        * update `tmp` to be `gen.next()`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(d)$$ (with `d` being the depth of the recursive stack)\\n\\n# Code\\n```ts\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const el of arr) {\\n        // base case: el is a number\\n        if (typeof(el) === \"number\") yield el;\\n        // general case: we go one level deeper\\n        else {\\n            const gen = inorderTraversal(el);\\n            let tmp = gen.next();\\n            while (!tmp.done) {\\n                yield Number(tmp.value);\\n                tmp = gen.next();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```ts\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    for (const el of arr) {\\n        // base case: el is a number\\n        if (typeof(el) === \"number\") yield el;\\n        // general case: we go one level deeper\\n        else {\\n            const gen = inorderTraversal(el);\\n            let tmp = gen.next();\\n            while (!tmp.done) {\\n                yield Number(tmp.value);\\n                tmp = gen.next();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455005,
                "title": "simple-recursive-solution-4-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let el of arr){\\n        if(Array.isArray(el)){\\n            yield* inorderTraversal(el);\\n        }\\n        else yield el;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let el of arr){\\n        if(Array.isArray(el)){\\n            yield* inorderTraversal(el);\\n        }\\n        else yield el;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454009,
                "title": "easy-typescript-solution",
                "content": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction flatten(arr:MultidimensionalArray){\\n    const list:number[]=[]\\n    arr.forEach(item=>{\\n        if(typeof item ==\"number\") list.push(item)\\n        else list.push(...flatten(item))\\n    })\\n    return list\\n}\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const list=flatten(arr);\\n    for(let i=0;i<list.length;i++){\\n        yield list[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction flatten(arr:MultidimensionalArray){\\n    const list:number[]=[]\\n    arr.forEach(item=>{\\n        if(typeof item ==\"number\") list.push(item)\\n        else list.push(...flatten(item))\\n    })\\n    return list\\n}\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    const list=flatten(arr);\\n    for(let i=0;i<list.length;i++){\\n        yield list[i]\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 3453883,
                "title": "55-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet flat = (arr) => {\\n    let flatArr = [];\\n    arr.forEach(i => {\\n        if(Array.isArray(i)) flatArr.push(...flat(i))\\n        else flatArr.push(i);\\n    })\\n    return flatArr;\\n}\\n\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if(Array.isArray(i)) {\\n            let sub = flat(i);\\n            while(sub.length > 0) {\\n                yield sub.shift();\\n            }\\n        } else yield i;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet flat = (arr) => {\\n    let flatArr = [];\\n    arr.forEach(i => {\\n        if(Array.isArray(i)) flatArr.push(...flat(i))\\n        else flatArr.push(i);\\n    })\\n    return flatArr;\\n}\\n\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for(let i of arr) {\\n        if(Array.isArray(i)) {\\n            let sub = flat(i);\\n            while(sub.length > 0) {\\n                yield sub.shift();\\n            }\\n        } else yield i;\\n    }\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452424,
                "title": "javascript-simplest-solution",
                "content": "\\n# Code\\n```\\nvar inorderTraversal = function* (arr) {\\n    if (Number.isInteger(arr)) {\\n        yield arr;\\n    } else {\\n        for (const i in arr) yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar inorderTraversal = function* (arr) {\\n    if (Number.isInteger(arr)) {\\n        yield arr;\\n    } else {\\n        for (const i in arr) yield* inorderTraversal(arr[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449797,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0;i<arr.length;i++)\\n        Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i]\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let i = 0;i<arr.length;i++)\\n        Array.isArray(arr[i]) ? yield* inorderTraversal(arr[i]) : yield arr[i]\\n};\\n\\n/**\\n * const gen = inorderTraversal([1, [2, 3]]);\\n * gen.next().value; // 1\\n * gen.next().value; // 2\\n * gen.next().value; // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449788,
                "title": "javascript-2-solutions-recursive-generator-and-flat",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use function `flat` to get flat array with param `Infinity` to flatten all levels. Then just `yield` all nums in a loop.\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const nums = arr.flat(Infinity);\\n\\n    for (let num of nums) {\\n        yield num;\\n    }\\n};\\n```\\n\\nSecond approach is to use recursive generator, this solution really slower (almost twice) than the first one. And demands more memory.\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let num of arr) {\\n        if (Array.isArray(num)) {\\n            yield* inorderTraversal(num)\\n        } else {\\n            yield num;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    const nums = arr.flat(Infinity);\\n\\n    for (let num of nums) {\\n        yield num;\\n    }\\n};\\n```\n```\\n/**\\n * @param {Array} arr\\n * @return {Generator}\\n */\\nvar inorderTraversal = function*(arr) {\\n    for (let num of arr) {\\n        if (Array.isArray(num)) {\\n            yield* inorderTraversal(num)\\n        } else {\\n            yield num;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449325,
                "title": "simple-non-recursive-one-loop-approach",
                "content": "Currently outperforms 100% of other solutions on time and memory\\n\\n```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    if (!arr.length) return;\\n\\n    for (let i = 0, q: MultidimensionalArray = []; q.length || i < arr.length;) {\\n        let el = q.length ? q.shift() : arr[i++];\\n        if (Array.isArray(el)) q.unshift(...el);\\n        else yield el!;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultidimensionalArray = (MultidimensionalArray | number)[]\\n\\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\\n    if (!arr.length) return;\\n\\n    for (let i = 0, q: MultidimensionalArray = []; q.length || i < arr.length;) {\\n        let el = q.length ? q.shift() : arr[i++];\\n        if (Array.isArray(el)) q.unshift(...el);\\n        else yield el!;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446310,
                "title": "javascript-stack-based-approach",
                "content": "This solution uses a stack to track the current state of the iterator.\\n \\nInitially, and when an `Array` is encoutered, it is pushed onto the top of the stack along with an index indicating the current element in the `Array`\\n \\nThe next element is determined by looking at the\\xA0`Array` on top of the stack. If the corresponding index is less than the length of the `Array`, then use the element at the specified index and increment. Otherwise, pop the top of the stack off.\\n\\n```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [{arr, idx: 0}];\\n    while (stack.length) {\\n        const top = stack[stack.length - 1];\\n        if (top.idx < top.arr.length) {\\n            const elem = top.arr[top.idx++];\\n            if (Array.isArray(elem)) {\\n                stack.push({arr:elem, idx: 0});\\n            }\\n            else {\\n                yield elem;\\n            }\\n        }\\n        else {\\n            stack.pop();\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar inorderTraversal = function*(arr) {\\n    const stack = [{arr, idx: 0}];\\n    while (stack.length) {\\n        const top = stack[stack.length - 1];\\n        if (top.idx < top.arr.length) {\\n            const elem = top.arr[top.idx++];\\n            if (Array.isArray(elem)) {\\n                stack.push({arr:elem, idx: 0});\\n            }\\n            else {\\n                yield elem;\\n            }\\n        }\\n        else {\\n            stack.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915282,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            },
            {
                "id": 1915122,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            },
            {
                "id": 1915071,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            },
            {
                "id": 1914869,
                "content": [
                    {
                        "username": "quaos",
                        "content": "1. use a stack to keep upper \"level\" array with index\\n2. iterate over current \"level\", starting from `arr`; go down a level when the element is an array, and go up a level to continue iteration when current level is exhausted. `yield` any non-array element."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day30 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\nHint : You can use loop for traversing the array , generator function returns a value when it is called ,next() , which is returned by the function with the help of yield keyword.\\n\\nThe question may be Done using Recursion "
                    },
                    {
                        "username": "raj2k00",
                        "content": "This should be easy problem."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "You need to understand the concept of generator and this question will fall into easy category "
                    }
                ]
            }
        ]
    }
]